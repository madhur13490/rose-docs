<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: MemoryMap Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>MemoryMap Class Reference</h1><!-- doxytag: class="MemoryMap" --><code>#include &lt;<a class="el" href="MemoryMap_8h-source.html">MemoryMap.h</a>&gt;</code>
<p>
Collaboration diagram for MemoryMap:<p><center><img src="classMemoryMap__coll__graph.png" border="0" usemap="#MemoryMap__coll__map" alt="Collaboration graph"></center>
<map name="MemoryMap__coll__map">
<area href="classRangeMap.html" shape="rect" coords="5,7,147,33" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classMemoryMap-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
An efficient mapping from an address space to stored data. 
<p>
This class maps addresses in a 64-bit virtual address space to data stored in buffers. The address space is segmented into non-overlapping, contiguous regions called "segments" (see <a class="el" href="classMemoryMap_1_1Segment.html">MemoryMap::Segment</a>) and the addresses in a segment are mapped 1:1 onto data storage containers (see <a class="el" href="classMemoryMap_1_1Buffer.html">MemoryMap::Buffer</a>). A <a class="el" href="classMemoryMap.html">MemoryMap</a> stores pairs of address ranges and segments, and each <a class="el" href="classMemoryMap_1_1Segment.html">Segment</a> points to a <a class="el" href="classMemoryMap_1_1Buffer.html">Buffer</a>.<p>
Buffers come in a variety of kinds, all derived from <a class="el" href="classMemoryMap_1_1Buffer.html">MemoryMap::Buffer</a>, and they are reference counted via Boost smart pointers. Always refer to a buffer with the <a class="el" href="classMemoryMap.html#3fcd4dad3786a2b27069c7891eb7b378">MemoryMap::BufferPtr</a> type. They should be created with various create() class methods, and they should never be explicitly freed.<p>
Here's an example of mapping a file into an address space at virtual address 0x08040000 and then temporarily replacing the second 8k page of the file with our own data. We demonstrate using an <a class="el" href="classMemoryMap_1_1MmapBuffer.html">MmapBuffer</a> because these are very fast for large files, especially if only small parts of the file are accessed. We could have also used <a class="el" href="classMemoryMap_1_1ByteBuffer.html#62eea3258ecf31382563115772c1a7cb">MemoryMap::ByteBuffer::create_from_file()</a>, but this copies the entire file contents into a heap-allocated buffer, which is slower.<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// Create and initialize the overlay data</span>
  my_data_size = 8192;
  uint8_t *my_data = <span class="keyword">new</span> uint8_t[my_data_size];
  initialize(my_data, my_data_size);

  <span class="comment">// Create the two buffers: one for the file, one for the overlay data</span>
  <a class="code" href="classMemoryMap.html#3fcd4dad3786a2b27069c7891eb7b378">MemoryMap::BufferPtr</a> file_buf = <a class="code" href="classMemoryMap_1_1MmapBuffer.html">MemoryMap::MmapBuffer</a>(<span class="stringliteral">"the_file"</span>, O_RDONLY, PROT_READ, MAP_PRIVATE);
  <a class="code" href="classMemoryMap.html#3fcd4dad3786a2b27069c7891eb7b378">MemoryMap::BufferPtr</a> data_buf = <a class="code" href="classMemoryMap_1_1ByteBuffer.html">MemoryMap::ByteBuffer</a>(my_data, my_data_size);
  my_data = NULL; <span class="comment">// it is now owned by data_buf and will be deleted automatically</span>

  <span class="comment">// Create the memory map.</span>
  <a class="code" href="classMemoryMap.html">MemoryMap</a> map;
  map.<a class="code" href="classMemoryMap.html#d8b51b8c73d8bb8d5922cbf1360800ef">insert</a>(<a class="code" href="Cxx__Grammar_8h.html#d8e49820aaa106bb8a2dc17d9ad38d87">Extent</a>(0x08040000, file_buf-&gt;size()),
             <a class="code" href="classMemoryMap_1_1Segment.html">MemoryMap::Segment</a>(file_buf, 0, <a class="code" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575721c493a6d527e717ffd911d2f18060f">MemoryMap::MM_PROT_READ</a>, <span class="stringliteral">"the file contents"</span>));
  map.<a class="code" href="classMemoryMap.html#d8b51b8c73d8bb8d5922cbf1360800ef">insert</a>(<a class="code" href="Cxx__Grammar_8h.html#d8e49820aaa106bb8a2dc17d9ad38d87">Extent</a>(0x08042000, data_buf-&gt;size()),
             <a class="code" href="classMemoryMap_1_1Segment.html">MemoryMap::Segment</a>(data_buf, 0, <a class="code" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd5757928ac57b8a90b020a73405a03fdfe3d">MemoryMap::MM_PROT_RW</a>, <span class="stringliteral">"data overlay"</span>));
</pre></div><p>
A <a class="el" href="classMemoryMap.html">MemoryMap</a> provides methods to easily read from and write to the underlying data storage, addressing it in terms of the virtual address space. These functions return the number of bytes copied.<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// read part of the data, right across the file/overlay boundary</span>
  uint8_t data[4096];
  size_t nread = map.<a class="code" href="classMemoryMap.html#709a3ab13e92a0cbd4a12184e35d4941">read</a>(data, 0x0804ff00, <span class="keyword">sizeof</span> data);
  assert(nread==<span class="keyword">sizeof</span> data);
</pre></div><p>
A <a class="el" href="classMemoryMap.html">MemoryMap</a> is built on top of a RangeMap&lt;Extent,Segment&gt; and the map is available with via the <a class="el" href="classMemoryMap.html#48c9dda77ad1d1335a441aaeef55d98e">segments()</a> method. Therefore, all the usual <a class="el" href="classRangeMap.html">RangeMap</a> operations are available. For instance, here's one way to determine if there's a large free area at 0xc0000000:<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// The set of addresses that are unmapped</span>
  <a class="code" href="classExtentMap.html">ExtentMap</a> free_areas = map.<a class="code" href="classMemoryMap.html#48c9dda77ad1d1335a441aaeef55d98e">segments</a>().<a class="code" href="classRangeMap.html#19f65661f7cda3080ef227a72f5833a1">invert</a>&lt;<a class="code" href="classExtentMap.html">ExtentMap</a>&gt;();
  <span class="keywordtype">bool</span> b = free_areas.<a class="code" href="classRangeMap.html#cb7a2bd99750f3b48f7667d5f01fe083">contains</a>(<a class="code" href="Cxx__Grammar_8h.html#d8e49820aaa106bb8a2dc17d9ad38d87">Extent</a>(0xc0000000,0x20000000));
</pre></div> 
<p>

<p>
Definition at line <a class="el" href="MemoryMap_8h-source.html#l00069">69</a> of file <a class="el" href="MemoryMap_8h-source.html">MemoryMap.h</a>.<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef boost::shared_ptr&lt;<br>
 <a class="el" href="classMemoryMap_1_1Buffer.html">Buffer</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#3fcd4dad3786a2b27069c7891eb7b378">BufferPtr</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classRangeMap.html">RangeMap</a>&lt; <a class="el" href="classRange.html">Extent</a>,<br>
 <a class="el" href="classMemoryMap_1_1Segment.html">Segment</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#3f808792b2ee48f78aa3ca3458802ff7">Segments</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">Segments::iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#8255b6a315bc53637c79b969e5cae4b5">iterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">Segments::const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#253e4f90f6e05db9b23c6977242eb8b9">const_iterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classRangeMap.html#8074a1b4f0b2bba0cf371d996a1e5dd6">Segments::reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#cff2f77b09bed0611cb58fcf662e8abf">reverse_iterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classRangeMap.html#39b1f3d923e2f3da32c75b2b63329331">Segments::const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#5a1d87cde99299cecaa96d6b5da619f1">const_reverse_iterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575cacde481f9cbe4995f73568e0d0be55e">MM_PROT_BITS</a> = 0x00000007</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bits used to indication memory region protections.  <a href="#33a974d3db4ffc22f5ccc7311e4fd575cacde481f9cbe4995f73568e0d0be55e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575721c493a6d527e717ffd911d2f18060f">MM_PROT_READ</a> = 0x00000001</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pages can be read.  <a href="#33a974d3db4ffc22f5ccc7311e4fd575721c493a6d527e717ffd911d2f18060f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575ba37f8b609f7bd6bc6a454be584726df">MM_PROT_WRITE</a> = 0x00000002</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pages can be written.  <a href="#33a974d3db4ffc22f5ccc7311e4fd575ba37f8b609f7bd6bc6a454be584726df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575a061dc1ffe578fdaea067d730efb00ac">MM_PROT_EXEC</a> = 0x00000004</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pages can be executed.  <a href="#33a974d3db4ffc22f5ccc7311e4fd575a061dc1ffe578fdaea067d730efb00ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd57544ce6196a00fe1b9a997bbd34b607f12">MM_PROT_NONE</a> = 0x00000000</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pages cannot be accessed.  <a href="#33a974d3db4ffc22f5ccc7311e4fd57544ce6196a00fe1b9a997bbd34b607f12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575879a02b819512db1be014e27610f9448">MM_PROT_ANY</a> = 0x00000007</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Any access.  <a href="#33a974d3db4ffc22f5ccc7311e4fd575879a02b819512db1be014e27610f9448"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd5757928ac57b8a90b020a73405a03fdfe3d">MM_PROT_RW</a> = (MM_PROT_READ|MM_PROT_WRITE)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read or write.  <a href="#33a974d3db4ffc22f5ccc7311e4fd5757928ac57b8a90b020a73405a03fdfe3d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd57589290f94ccb75d2e8b659c4ef50bb700">MM_PROT_RX</a> = (MM_PROT_READ|MM_PROT_EXEC)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read or execute.  <a href="#33a974d3db4ffc22f5ccc7311e4fd57589290f94ccb75d2e8b659c4ef50bb700"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd5751c088a07943114be142477c0c13a40ae">MM_PROT_RWX</a> = (MM_PROT_ANY)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575a4b0336509df0d1ffacee7b2d8aaf2a1">MM_PROT_FLAGS</a> = 0xfffffff0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mask of protection bits that are available for use by other layers.  <a href="#33a974d3db4ffc22f5ccc7311e4fd575a4b0336509df0d1ffacee7b2d8aaf2a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575142989711b3e75e3e66a96461b8fbd6a">MM_PROT_PRIVATE</a> = 0x00000010</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pages are not shared between mapped regions.  <a href="#33a974d3db4ffc22f5ccc7311e4fd575142989711b3e75e3e66a96461b8fbd6a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#e687c5c475ed18d7d747d672e54e3aef7e46f89c5a5b88fda5e18612c7ed100b">COPY_SHALLOW</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy segments, but not the buffers to which they point.  <a href="#e687c5c475ed18d7d747d672e54e3aef7e46f89c5a5b88fda5e18612c7ed100b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#e687c5c475ed18d7d747d672e54e3aefc5ee4ee2a54afd2865f02c9df5f60ad8">COPY_DEEP</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy segments and their buffers.  <a href="#e687c5c475ed18d7d747d672e54e3aefc5ee4ee2a54afd2865f02c9df5f60ad8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#e687c5c475ed18d7d747d672e54e3aef67d781375bccde7428a844b6504ec3ac">COPY_ON_WRITE</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy segments and mark them so they copy buffers on write.  <a href="#e687c5c475ed18d7d747d672e54e3aef67d781375bccde7428a844b6504ec3ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575">Protection</a> { <br>
&nbsp;&nbsp;<a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575cacde481f9cbe4995f73568e0d0be55e">MM_PROT_BITS</a> =  0x00000007, 
<br>
&nbsp;&nbsp;<a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575721c493a6d527e717ffd911d2f18060f">MM_PROT_READ</a> =  0x00000001, 
<br>
&nbsp;&nbsp;<a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575ba37f8b609f7bd6bc6a454be584726df">MM_PROT_WRITE</a> =  0x00000002, 
<br>
&nbsp;&nbsp;<a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575a061dc1ffe578fdaea067d730efb00ac">MM_PROT_EXEC</a> =  0x00000004, 
<br>
&nbsp;&nbsp;<a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd57544ce6196a00fe1b9a997bbd34b607f12">MM_PROT_NONE</a> =  0x00000000, 
<br>
&nbsp;&nbsp;<a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575879a02b819512db1be014e27610f9448">MM_PROT_ANY</a> =  0x00000007, 
<br>
&nbsp;&nbsp;<a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd5757928ac57b8a90b020a73405a03fdfe3d">MM_PROT_RW</a> =  (MM_PROT_READ|MM_PROT_WRITE), 
<br>
&nbsp;&nbsp;<a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd57589290f94ccb75d2e8b659c4ef50bb700">MM_PROT_RX</a> =  (MM_PROT_READ|MM_PROT_EXEC), 
<br>
&nbsp;&nbsp;<a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd5751c088a07943114be142477c0c13a40ae">MM_PROT_RWX</a> =  (MM_PROT_ANY), 
<br>
&nbsp;&nbsp;<a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575a4b0336509df0d1ffacee7b2d8aaf2a1">MM_PROT_FLAGS</a> =  0xfffffff0, 
<br>
&nbsp;&nbsp;<a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575142989711b3e75e3e66a96461b8fbd6a">MM_PROT_PRIVATE</a> =  0x00000010
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mapping permissions.  <a href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#e687c5c475ed18d7d747d672e54e3aef">CopyLevel</a> { <br>
&nbsp;&nbsp;<a class="el" href="classMemoryMap.html#e687c5c475ed18d7d747d672e54e3aef7e46f89c5a5b88fda5e18612c7ed100b">COPY_SHALLOW</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classMemoryMap.html#e687c5c475ed18d7d747d672e54e3aefc5ee4ee2a54afd2865f02c9df5f60ad8">COPY_DEEP</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classMemoryMap.html#e687c5c475ed18d7d747d672e54e3aef67d781375bccde7428a844b6504ec3ac">COPY_ON_WRITE</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Map copying.  <a href="classMemoryMap.html#e687c5c475ed18d7d747d672e54e3aef">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#400f3136e664fd3e3f5c2730ce3a2a5f">MemoryMap</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs an empty memory map.  <a href="#400f3136e664fd3e3f5c2730ce3a2a5f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#2a72c1c6bd2724ca82c60bca7f7c9aaf">MemoryMap</a> (const <a class="el" href="classMemoryMap.html">MemoryMap</a> &amp;other, <a class="el" href="classMemoryMap.html#e687c5c475ed18d7d747d672e54e3aef">CopyLevel</a> copy_level=COPY_SHALLOW)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shallow copy constructor.  <a href="#2a72c1c6bd2724ca82c60bca7f7c9aaf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classMemoryMap.html">MemoryMap</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#9f97bb1d4be7848e91e91bdd3d47c8ba">init</a> (const <a class="el" href="classMemoryMap.html">MemoryMap</a> &amp;source, <a class="el" href="classMemoryMap.html#e687c5c475ed18d7d747d672e54e3aef">CopyLevel</a> copy_level=COPY_SHALLOW)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize this memory map with info from another.  <a href="#9f97bb1d4be7848e91e91bdd3d47c8ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#de35471bd24f46fc5099d8a6a97b0ddf">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the entire memory map by erasing all addresses that are defined.  <a href="#de35471bd24f46fc5099d8a6a97b0ddf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#d8b51b8c73d8bb8d5922cbf1360800ef">insert</a> (const <a class="el" href="classRange.html">Extent</a> &amp;range, const <a class="el" href="classMemoryMap_1_1Segment.html">Segment</a> &amp;segment, bool erase_prior=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define a new area of memory.  <a href="#d8b51b8c73d8bb8d5922cbf1360800ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#497cf700231115f91e5627a11c166653">erase</a> (const <a class="el" href="classRange.html">Extent</a> &amp;range)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase parts of the mapping that correspond to the specified virtual address range.  <a href="#497cf700231115f91e5627a11c166653"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#0426d0034ef1b0177b57e558f4eb6fd2">erase</a> (const <a class="el" href="classMemoryMap_1_1Segment.html">Segment</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase a single extent from a memory map.  <a href="#0426d0034ef1b0177b57e558f4eb6fd2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt; <a class="el" href="classRange.html">Extent</a>, <a class="el" href="classMemoryMap_1_1Segment.html">Segment</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#236831c642b73ee2c26459340c7ee761">at</a> (<a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get information about an address.  <a href="#236831c642b73ee2c26459340c7ee761"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#99e2f3d47ce36283671962e5f6ee93f5">find_free</a> (<a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> start_va, size_t size, <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> mem_alignment=1) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search for free space in the mapping.  <a href="#99e2f3d47ce36283671962e5f6ee93f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#c4c396cc00022426897339bbc310eddd">find_last_free</a> (<a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> max=(<a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>)(-1)) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the highest area of unmapped addresses.  <a href="#c4c396cc00022426897339bbc310eddd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#8eabb07a63d701ffb17649284a35eb2a">traverse</a> (<a class="el" href="classMemoryMap_1_1Visitor.html">Visitor</a> &amp;visitor) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Traverses the segments of a map.  <a href="#8eabb07a63d701ffb17649284a35eb2a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#8e5d8580f91704ebfb5b28bcbd71c01a">prune</a> (<a class="el" href="classMemoryMap_1_1Visitor.html">Visitor</a> &amp;predicate)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes segments for which <code>predicate</code> returns true.  <a href="#8e5d8580f91704ebfb5b28bcbd71c01a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#66054714b17e6aebf094cf7883bf134c">prune</a> (unsigned required, unsigned prohibited=MM_PROT_NONE)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes segments based on permissions.  <a href="#66054714b17e6aebf094cf7883bf134c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classRangeMap.html">Segments</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#48c9dda77ad1d1335a441aaeef55d98e">segments</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of map segments.  <a href="#48c9dda77ad1d1335a441aaeef55d98e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="Cxx__Grammar_8h.html#4f57773a5fc8d0d005f7553cd47cbc4e">SgUnsignedCharList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#c0d0f7ab2482f726f1c02a54efc11372">read</a> (<a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> start_va, size_t desired, unsigned req_perms=MM_PROT_READ) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads data from a memory map.  <a href="#c0d0f7ab2482f726f1c02a54efc11372"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classExtentMap.html">ExtentMap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#8ffed06efb5ddeb4c08c3fcafcc08c20">va_extents</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns just the virtual address extents for a memory map.  <a href="#8ffed06efb5ddeb4c08c3fcafcc08c20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#9b60b4c96694154fbf1bb2d7c089a7a6">mprotect</a> (<a class="el" href="classRange.html">Extent</a> range, unsigned perms, bool relax=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets protection bits for the specified address range.  <a href="#9b60b4c96694154fbf1bb2d7c089a7a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#5f8be6a3c404404aa8c4b1b7fdff3c95">dump</a> (const std::string &amp;basename) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dumps the entire map and its contents into a set of files.  <a href="#5f8be6a3c404404aa8c4b1b7fdff3c95"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#e99220f42b2ae4bce99bd56910efcab1">load</a> (const std::string &amp;basename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a memory map from a set of memory dump files.  <a href="#e99220f42b2ae4bce99bd56910efcab1"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#372b80eef545c53a95b322c53e526e64">exists</a> (<a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va, unsigned required_perms=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether a virtual address is defined.  <a href="#372b80eef545c53a95b322c53e526e64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#abb3c20acb870b8fd6723b9217cbaff2">exists</a> (<a class="el" href="classRange.html">Extent</a> range, unsigned required_perms=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines whether a virtual address is defined.  <a href="#abb3c20acb870b8fd6723b9217cbaff2"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#709a3ab13e92a0cbd4a12184e35d4941">read</a> (void *dst_buf, <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> start_va, size_t desired, unsigned req_perms=MM_PROT_READ) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies data from a contiguous region of the virtual address space into a user supplied buffer.  <a href="#709a3ab13e92a0cbd4a12184e35d4941"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#f8683ff784134fad5c016d51e03143e0">read1</a> (void *dst_buf, <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> start_va, size_t desired, unsigned req_perms=MM_PROT_READ) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies data from a contiguous region of the virtual address space into a user supplied buffer.  <a href="#f8683ff784134fad5c016d51e03143e0"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#4c05a968b891c4848ce6dc802fb1ada2">write</a> (const void *src_buf, <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> start_va, size_t desired, unsigned req_perms=MM_PROT_WRITE)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies data from a supplied buffer into the specified virtual addresses.  <a href="#4c05a968b891c4848ce6dc802fb1ada2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#2a0e72bbdaf6a582f9b484ff9696bf76">write1</a> (const void *src_buf, <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> start_va, size_t desired, unsigned req_perms=MM_PROT_WRITE)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies data from a supplied buffer into the specified virtual addresses.  <a href="#2a0e72bbdaf6a582f9b484ff9696bf76"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#c45b1135441de2185b0b72c858066911">dump</a> (FILE *, const char *prefix=&quot;&quot;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints the contents of the map for debugging.  <a href="#c45b1135441de2185b0b72c858066911"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#436d1d9026091be94f841d843a2fe810">dump</a> (std::ostream &amp;, std::string prefix=&quot;&quot;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints the contents of the map for debugging.  <a href="#436d1d9026091be94f841d843a2fe810"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#f284bb08259e651c94309bcbf3994a6a">print</a> (std::ostream &amp;o, std::string prefix=&quot;&quot;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints the contents of the map for debugging.  <a href="#f284bb08259e651c94309bcbf3994a6a"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html">Segments</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#6a03e9d53a131a9aa6ae0786c3c0f55a">p_segments</a></td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap.html#62d57db8b553f396fa5786845552edbb">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="classMemoryMap.html">MemoryMap</a> &amp;)</td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap_1_1AnonymousBuffer.html">AnonymousBuffer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classMemoryMap_1_1Buffer.html">Buffer</a> of bytes.  <a href="classMemoryMap_1_1AnonymousBuffer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap_1_1Buffer.html">Buffer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for data associated with a memory segment.  <a href="classMemoryMap_1_1Buffer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap_1_1ByteBuffer.html">ByteBuffer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classMemoryMap_1_1Buffer.html">Buffer</a> of bytes.  <a href="classMemoryMap_1_1ByteBuffer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap_1_1Exception.html">Exception</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classMemoryMap_1_1Exception.html">Exception</a> for <a class="el" href="classMemoryMap.html">MemoryMap</a> operations.  <a href="classMemoryMap_1_1Exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap_1_1ExternBuffer.html">ExternBuffer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classMemoryMap_1_1Buffer.html">Buffer</a> of data owned by someone else.  <a href="classMemoryMap_1_1ExternBuffer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMemoryMap_1_1Inconsistent.html">Inconsistent</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classMemoryMap_1_1Exception.html">Exception</a> for an inconsistent mapping.  <a href="structMemoryMap_1_1Inconsistent.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap_1_1MmapBuffer.html">MmapBuffer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classMemoryMap_1_1Buffer.html">Buffer</a> whose underlying storage is from mmap.  <a href="classMemoryMap_1_1MmapBuffer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMemoryMap_1_1NoFreeSpace.html">NoFreeSpace</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classMemoryMap_1_1Exception.html">Exception</a> thrown by <a class="el" href="classMemoryMap.html#99e2f3d47ce36283671962e5f6ee93f5">find_free()</a> when there's not enough free space left.  <a href="structMemoryMap_1_1NoFreeSpace.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMemoryMap_1_1NotMapped.html">NotMapped</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classMemoryMap_1_1Exception.html">Exception</a> for when we try to access a virtual address that isn't mapped.  <a href="structMemoryMap_1_1NotMapped.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap_1_1NullBuffer.html">NullBuffer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classMemoryMap_1_1Buffer.html">Buffer</a> that has no data.  <a href="classMemoryMap_1_1NullBuffer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap_1_1Segment.html">Segment</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A contiguous, homogeneous region of an address space.  <a href="classMemoryMap_1_1Segment.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMemoryMap_1_1SyntaxError.html">SyntaxError</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classMemoryMap_1_1Exception.html">Exception</a> thrown by <a class="el" href="classMemoryMap.html#e99220f42b2ae4bce99bd56910efcab1">load()</a> when there's a syntax error in the index file.  <a href="structMemoryMap_1_1SyntaxError.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryMap_1_1Visitor.html">Visitor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classMemoryMap_1_1Visitor.html">Visitor</a> for traversing a memory map.  <a href="classMemoryMap_1_1Visitor.html#_details">More...</a><br></td></tr>
</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="3fcd4dad3786a2b27069c7891eb7b378"></a><!-- doxytag: member="MemoryMap::BufferPtr" ref="3fcd4dad3786a2b27069c7891eb7b378" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="classMemoryMap_1_1Buffer.html">Buffer</a>&gt; <a class="el" href="classMemoryMap.html#3fcd4dad3786a2b27069c7891eb7b378">MemoryMap::BufferPtr</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="MemoryMap_8h-source.html#l00105">105</a> of file <a class="el" href="MemoryMap_8h-source.html">MemoryMap.h</a>.
</div>
</div><p>
<a class="anchor" name="3f808792b2ee48f78aa3ca3458802ff7"></a><!-- doxytag: member="MemoryMap::Segments" ref="3f808792b2ee48f78aa3ca3458802ff7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classRangeMap.html">RangeMap</a>&lt;<a class="el" href="classRange.html">Extent</a>, <a class="el" href="classMemoryMap_1_1Segment.html">Segment</a>&gt; <a class="el" href="classRangeMap.html">MemoryMap::Segments</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="MemoryMap_8h-source.html#l00400">400</a> of file <a class="el" href="MemoryMap_8h-source.html">MemoryMap.h</a>.
</div>
</div><p>
<a class="anchor" name="8255b6a315bc53637c79b969e5cae4b5"></a><!-- doxytag: member="MemoryMap::iterator" ref="8255b6a315bc53637c79b969e5cae4b5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">Segments::iterator</a> <a class="el" href="classMemoryMap.html#8255b6a315bc53637c79b969e5cae4b5">MemoryMap::iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="MemoryMap_8h-source.html#l00401">401</a> of file <a class="el" href="MemoryMap_8h-source.html">MemoryMap.h</a>.
</div>
</div><p>
<a class="anchor" name="253e4f90f6e05db9b23c6977242eb8b9"></a><!-- doxytag: member="MemoryMap::const_iterator" ref="253e4f90f6e05db9b23c6977242eb8b9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">Segments::const_iterator</a> <a class="el" href="classMemoryMap.html#253e4f90f6e05db9b23c6977242eb8b9">MemoryMap::const_iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="MemoryMap_8h-source.html#l00402">402</a> of file <a class="el" href="MemoryMap_8h-source.html">MemoryMap.h</a>.
</div>
</div><p>
<a class="anchor" name="cff2f77b09bed0611cb58fcf662e8abf"></a><!-- doxytag: member="MemoryMap::reverse_iterator" ref="cff2f77b09bed0611cb58fcf662e8abf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classRangeMap.html#8074a1b4f0b2bba0cf371d996a1e5dd6">Segments::reverse_iterator</a> <a class="el" href="classMemoryMap.html#cff2f77b09bed0611cb58fcf662e8abf">MemoryMap::reverse_iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="MemoryMap_8h-source.html#l00403">403</a> of file <a class="el" href="MemoryMap_8h-source.html">MemoryMap.h</a>.
</div>
</div><p>
<a class="anchor" name="5a1d87cde99299cecaa96d6b5da619f1"></a><!-- doxytag: member="MemoryMap::const_reverse_iterator" ref="5a1d87cde99299cecaa96d6b5da619f1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classRangeMap.html#39b1f3d923e2f3da32c75b2b63329331">Segments::const_reverse_iterator</a> <a class="el" href="classMemoryMap.html#5a1d87cde99299cecaa96d6b5da619f1">MemoryMap::const_reverse_iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="MemoryMap_8h-source.html#l00404">404</a> of file <a class="el" href="MemoryMap_8h-source.html">MemoryMap.h</a>.
</div>
</div><p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="33a974d3db4ffc22f5ccc7311e4fd575"></a><!-- doxytag: member="MemoryMap::Protection" ref="33a974d3db4ffc22f5ccc7311e4fd575" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575">MemoryMap::Protection</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mapping permissions. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="33a974d3db4ffc22f5ccc7311e4fd575cacde481f9cbe4995f73568e0d0be55e"></a><!-- doxytag: member="MM_PROT_BITS" ref="33a974d3db4ffc22f5ccc7311e4fd575cacde481f9cbe4995f73568e0d0be55e" args="" -->MM_PROT_BITS</em>&nbsp;</td><td>
Bits used to indication memory region protections. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="33a974d3db4ffc22f5ccc7311e4fd575721c493a6d527e717ffd911d2f18060f"></a><!-- doxytag: member="MM_PROT_READ" ref="33a974d3db4ffc22f5ccc7311e4fd575721c493a6d527e717ffd911d2f18060f" args="" -->MM_PROT_READ</em>&nbsp;</td><td>
Pages can be read. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="33a974d3db4ffc22f5ccc7311e4fd575ba37f8b609f7bd6bc6a454be584726df"></a><!-- doxytag: member="MM_PROT_WRITE" ref="33a974d3db4ffc22f5ccc7311e4fd575ba37f8b609f7bd6bc6a454be584726df" args="" -->MM_PROT_WRITE</em>&nbsp;</td><td>
Pages can be written. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="33a974d3db4ffc22f5ccc7311e4fd575a061dc1ffe578fdaea067d730efb00ac"></a><!-- doxytag: member="MM_PROT_EXEC" ref="33a974d3db4ffc22f5ccc7311e4fd575a061dc1ffe578fdaea067d730efb00ac" args="" -->MM_PROT_EXEC</em>&nbsp;</td><td>
Pages can be executed. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="33a974d3db4ffc22f5ccc7311e4fd57544ce6196a00fe1b9a997bbd34b607f12"></a><!-- doxytag: member="MM_PROT_NONE" ref="33a974d3db4ffc22f5ccc7311e4fd57544ce6196a00fe1b9a997bbd34b607f12" args="" -->MM_PROT_NONE</em>&nbsp;</td><td>
Pages cannot be accessed. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="33a974d3db4ffc22f5ccc7311e4fd575879a02b819512db1be014e27610f9448"></a><!-- doxytag: member="MM_PROT_ANY" ref="33a974d3db4ffc22f5ccc7311e4fd575879a02b819512db1be014e27610f9448" args="" -->MM_PROT_ANY</em>&nbsp;</td><td>
Any access. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="33a974d3db4ffc22f5ccc7311e4fd5757928ac57b8a90b020a73405a03fdfe3d"></a><!-- doxytag: member="MM_PROT_RW" ref="33a974d3db4ffc22f5ccc7311e4fd5757928ac57b8a90b020a73405a03fdfe3d" args="" -->MM_PROT_RW</em>&nbsp;</td><td>
Read or write. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="33a974d3db4ffc22f5ccc7311e4fd57589290f94ccb75d2e8b659c4ef50bb700"></a><!-- doxytag: member="MM_PROT_RX" ref="33a974d3db4ffc22f5ccc7311e4fd57589290f94ccb75d2e8b659c4ef50bb700" args="" -->MM_PROT_RX</em>&nbsp;</td><td>
Read or execute. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="33a974d3db4ffc22f5ccc7311e4fd5751c088a07943114be142477c0c13a40ae"></a><!-- doxytag: member="MM_PROT_RWX" ref="33a974d3db4ffc22f5ccc7311e4fd5751c088a07943114be142477c0c13a40ae" args="" -->MM_PROT_RWX</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="33a974d3db4ffc22f5ccc7311e4fd575a4b0336509df0d1ffacee7b2d8aaf2a1"></a><!-- doxytag: member="MM_PROT_FLAGS" ref="33a974d3db4ffc22f5ccc7311e4fd575a4b0336509df0d1ffacee7b2d8aaf2a1" args="" -->MM_PROT_FLAGS</em>&nbsp;</td><td>
Mask of protection bits that are available for use by other layers. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="33a974d3db4ffc22f5ccc7311e4fd575142989711b3e75e3e66a96461b8fbd6a"></a><!-- doxytag: member="MM_PROT_PRIVATE" ref="33a974d3db4ffc22f5ccc7311e4fd575142989711b3e75e3e66a96461b8fbd6a" args="" -->MM_PROT_PRIVATE</em>&nbsp;</td><td>
Pages are not shared between mapped regions. </td></tr>
</table>
</dl>

<p>
Definition at line <a class="el" href="MemoryMap_8h-source.html#l00073">73</a> of file <a class="el" href="MemoryMap_8h-source.html">MemoryMap.h</a>.
</div>
</div><p>
<a class="anchor" name="e687c5c475ed18d7d747d672e54e3aef"></a><!-- doxytag: member="MemoryMap::CopyLevel" ref="e687c5c475ed18d7d747d672e54e3aef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classMemoryMap.html#e687c5c475ed18d7d747d672e54e3aef">MemoryMap::CopyLevel</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Map copying. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="e687c5c475ed18d7d747d672e54e3aef7e46f89c5a5b88fda5e18612c7ed100b"></a><!-- doxytag: member="COPY_SHALLOW" ref="e687c5c475ed18d7d747d672e54e3aef7e46f89c5a5b88fda5e18612c7ed100b" args="" -->COPY_SHALLOW</em>&nbsp;</td><td>
Copy segments, but not the buffers to which they point. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="e687c5c475ed18d7d747d672e54e3aefc5ee4ee2a54afd2865f02c9df5f60ad8"></a><!-- doxytag: member="COPY_DEEP" ref="e687c5c475ed18d7d747d672e54e3aefc5ee4ee2a54afd2865f02c9df5f60ad8" args="" -->COPY_DEEP</em>&nbsp;</td><td>
Copy segments and their buffers. 
<p>
This copies buffer data. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="e687c5c475ed18d7d747d672e54e3aef67d781375bccde7428a844b6504ec3ac"></a><!-- doxytag: member="COPY_ON_WRITE" ref="e687c5c475ed18d7d747d672e54e3aef67d781375bccde7428a844b6504ec3ac" args="" -->COPY_ON_WRITE</em>&nbsp;</td><td>
Copy segments and mark them so they copy buffers on write. </td></tr>
</table>
</dl>

<p>
Definition at line <a class="el" href="MemoryMap_8h-source.html#l00095">95</a> of file <a class="el" href="MemoryMap_8h-source.html">MemoryMap.h</a>.
</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="400f3136e664fd3e3f5c2730ce3a2a5f"></a><!-- doxytag: member="MemoryMap::MemoryMap" ref="400f3136e664fd3e3f5c2730ce3a2a5f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MemoryMap::MemoryMap           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs an empty memory map. 
<p>

<p>
Definition at line <a class="el" href="MemoryMap_8h-source.html#l00486">486</a> of file <a class="el" href="MemoryMap_8h-source.html">MemoryMap.h</a>.
</div>
</div><p>
<a class="anchor" name="2a72c1c6bd2724ca82c60bca7f7c9aaf"></a><!-- doxytag: member="MemoryMap::MemoryMap" ref="2a72c1c6bd2724ca82c60bca7f7c9aaf" args="(const MemoryMap &amp;other, CopyLevel copy_level=COPY_SHALLOW)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MemoryMap::MemoryMap           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMemoryMap.html">MemoryMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMemoryMap.html#e687c5c475ed18d7d747d672e54e3aef">CopyLevel</a>&nbsp;</td>
          <td class="paramname"> <em>copy_level</em> = <code>COPY_SHALLOW</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shallow copy constructor. 
<p>
The new memory map describes the same mapping and points to shared copies of the underlying data. In other words, changing the mapping of one map (<a class="el" href="classMemoryMap.html#de35471bd24f46fc5099d8a6a97b0ddf">clear()</a>, <a class="el" href="classMemoryMap.html#d8b51b8c73d8bb8d5922cbf1360800ef">insert()</a>, <a class="el" href="classMemoryMap.html#497cf700231115f91e5627a11c166653">erase()</a>) does not change the mapping of the other, but changing the data (<a class="el" href="classMemoryMap.html#4c05a968b891c4848ce6dc802fb1ada2">write()</a>) in one map changes it in the other. See also <a class="el" href="classMemoryMap.html#9f97bb1d4be7848e91e91bdd3d47c8ba">init()</a>, which takes an argument describing how to copy. 
<p>
Definition at line <a class="el" href="MemoryMap_8h-source.html#l00492">492</a> of file <a class="el" href="MemoryMap_8h-source.html">MemoryMap.h</a>.
<p>
References <a class="el" href="MemoryMap_8C-source.html#l00562">init()</a>.
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="9f97bb1d4be7848e91e91bdd3d47c8ba"></a><!-- doxytag: member="MemoryMap::init" ref="9f97bb1d4be7848e91e91bdd3d47c8ba" args="(const MemoryMap &amp;source, CopyLevel copy_level=COPY_SHALLOW)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMemoryMap.html">MemoryMap</a> &amp; MemoryMap::init           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMemoryMap.html">MemoryMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMemoryMap.html#e687c5c475ed18d7d747d672e54e3aef">CopyLevel</a>&nbsp;</td>
          <td class="paramname"> <em>copy_level</em> = <code>COPY_SHALLOW</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize this memory map with info from another. 
<p>
This map is first cleared and then initialized with a copy of the <code>source</code> map. A reference to this map is returned for convenience since init is often used in conjunction with constructors. 
<p>
Definition at line <a class="el" href="MemoryMap_8C-source.html#l00562">562</a> of file <a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a>.
<p>
References <a class="el" href="rangemap_8h-source.html#l00775">RangeMap&lt; R, T &gt;::begin()</a>, <a class="el" href="classMemoryMap.html#e687c5c475ed18d7d747d672e54e3aefc5ee4ee2a54afd2865f02c9df5f60ad8">COPY_DEEP</a>, <a class="el" href="MemoryMap_8h-source.html#l00098">COPY_ON_WRITE</a>, <a class="el" href="classMemoryMap.html#e687c5c475ed18d7d747d672e54e3aef7e46f89c5a5b88fda5e18612c7ed100b">COPY_SHALLOW</a>, <a class="el" href="rangemap_8h-source.html#l00787">RangeMap&lt; R, T &gt;::end()</a>, and <a class="el" href="MemoryMap_8h-source.html#l00652">p_segments</a>.
<p>
Referenced by <a class="el" href="MemoryMap_8h-source.html#l00492">MemoryMap()</a>.
</div>
</div><p>
<a class="anchor" name="de35471bd24f46fc5099d8a6a97b0ddf"></a><!-- doxytag: member="MemoryMap::clear" ref="de35471bd24f46fc5099d8a6a97b0ddf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryMap::clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear the entire memory map by erasing all addresses that are defined. 
<p>

<p>
Definition at line <a class="el" href="MemoryMap_8C-source.html#l00556">556</a> of file <a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a>.
<p>
References <a class="el" href="rangemap_8h-source.html#l00979">RangeMap&lt; R, T &gt;::clear()</a>, and <a class="el" href="MemoryMap_8h-source.html#l00652">p_segments</a>.
<p>
Referenced by <a class="el" href="MemoryMap_8C-source.html#l00901">load()</a>, and <a class="el" href="Partitioner_8C-source.html#l00174">Partitioner::set_map()</a>.
</div>
</div><p>
<a class="anchor" name="d8b51b8c73d8bb8d5922cbf1360800ef"></a><!-- doxytag: member="MemoryMap::insert" ref="d8b51b8c73d8bb8d5922cbf1360800ef" args="(const Extent &amp;range, const Segment &amp;segment, bool erase_prior=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryMap::insert           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Extent</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMemoryMap_1_1Segment.html">Segment</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>segment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>erase_prior</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Define a new area of memory. 
<p>
The <code>segment</code> is copied into the memory map and the reference count for the <a class="el" href="classMemoryMap_1_1Buffer.html">Buffer</a> to which it points (if any) is incremented. A check is performed to ensure that the <code>range</code> and <code>segment</code> are compatible (that the size of the range is not greater than the size of the segment's underlying buffer). This operation is somewhat like the POSIX mmap() function.<p>
If the <code>range</code> overlaps with existing segments and <code>erase_prior</code> is set (the default), then the overlapping parts of the virtual address space are first removed from the mapping. Otherwise an overlap throws a <a class="el" href="structMemoryMap_1_1Inconsistent.html">MemoryMap::Inconsistent</a> exception. If an exception is thrown, then the memory map is not changed. 
<p>
Definition at line <a class="el" href="MemoryMap_8C-source.html#l00585">585</a> of file <a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a>.
<p>
References <a class="el" href="rangemap_8h-source.html#l00787">RangeMap&lt; R, T &gt;::end()</a>, <a class="el" href="rangemap_8h-source.html#l00098">Range&lt; T &gt;::first()</a>, <a class="el" href="rangemap_8h-source.html#l01062">RangeMap&lt; R, T &gt;::insert()</a>, <a class="el" href="rangemap_8h-source.html#l00842">RangeMap&lt; R, T &gt;::lower_bound()</a>, <a class="el" href="rangemap_8h-source.html#l00323">Range&lt; T &gt;::overlaps()</a>, and <a class="el" href="MemoryMap_8h-source.html#l00652">p_segments</a>.
<p>
Referenced by <a class="el" href="Disassembler_8C-source.html#l00420">Disassembler::disassembleBlock()</a>, <a class="el" href="Disassembler_8C-source.html#l00720">Disassembler::disassembleBuffer()</a>, <a class="el" href="Disassembler_8C-source.html#l00312">Disassembler::disassembleOne()</a>, <a class="el" href="MemoryMap_8C-source.html#l00901">load()</a>, <a class="el" href="Partitioner_8C-source.html#l01019">Partitioner::mark_ipd_configuration()</a>, and <a class="el" href="AsmUnparser_8C-source.html#l00901">AsmUnparser::StaticDataDisassembler::operator()()</a>.
</div>
</div><p>
<a class="anchor" name="372b80eef545c53a95b322c53e526e64"></a><!-- doxytag: member="MemoryMap::exists" ref="372b80eef545c53a95b322c53e526e64" args="(rose_addr_t va, unsigned required_perms=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MemoryMap::exists           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td>
          <td class="paramname"> <em>va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>required_perms</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether a virtual address is defined. 
<p>
Returns true if the specified virtual address (or all addresses in a range of addresses) are defined, false otherwise. An address is defined if it is associated with a <a class="el" href="classMemoryMap_1_1Segment.html">Segment</a>. If <code>required_perms</code> is non-zero, then the address (or all addresses in the range) must be mapped with at least those permission bits. 
<p>
Definition at line <a class="el" href="MemoryMap_8h-source.html#l00517">517</a> of file <a class="el" href="MemoryMap_8h-source.html">MemoryMap.h</a>.
<p>
Referenced by <a class="el" href="PeFileHeader_8C-source.html#l00522">SgAsmPEFileHeader::create_table_sections()</a>, <a class="el" href="Disassembler_8C-source.html#l00441">Disassembler::disassembleBuffer()</a>, <a class="el" href="Partitioner_8C-source.html#l00191">Partitioner::discover_jump_table()</a>, <a class="el" href="GenericFile_8C-source.html#l00165">SgAsmGenericFile::read_content()</a>, <a class="el" href="Disassembler_8C-source.html#l00515">Disassembler::search_following()</a>, <a class="el" href="Disassembler_8C-source.html#l00672">Disassembler::search_function_symbols()</a>, <a class="el" href="Disassembler_8C-source.html#l00539">Disassembler::search_immediate()</a>, and <a class="el" href="Disassembler_8C-source.html#l00570">Disassembler::search_words()</a>.
</div>
</div><p>
<a class="anchor" name="abb3c20acb870b8fd6723b9217cbaff2"></a><!-- doxytag: member="MemoryMap::exists" ref="abb3c20acb870b8fd6723b9217cbaff2" args="(Extent range, unsigned required_perms=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MemoryMap::exists           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRange.html">Extent</a>&nbsp;</td>
          <td class="paramname"> <em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>required_perms</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether a virtual address is defined. 
<p>
Returns true if the specified virtual address (or all addresses in a range of addresses) are defined, false otherwise. An address is defined if it is associated with a <a class="el" href="classMemoryMap_1_1Segment.html">Segment</a>. If <code>required_perms</code> is non-zero, then the address (or all addresses in the range) must be mapped with at least those permission bits. 
<p>
Definition at line <a class="el" href="MemoryMap_8C-source.html#l00599">599</a> of file <a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a>.
<p>
References <a class="el" href="rangemap_8h-source.html#l00245">Range&lt; T &gt;::begins_before()</a>, <a class="el" href="rangemap_8h-source.html#l01133">RangeMap&lt; R, T &gt;::contains()</a>, <a class="el" href="rangemap_8h-source.html#l00197">Range&lt; T &gt;::empty()</a>, <a class="el" href="rangemap_8h-source.html#l00787">RangeMap&lt; R, T &gt;::end()</a>, <a class="el" href="rangemap_8h-source.html#l00824">RangeMap&lt; R, T &gt;::find()</a>, <a class="el" href="rangemap_8h-source.html#l00098">Range&lt; T &gt;::first()</a>, <a class="el" href="MemoryMap_8h-source.html#l00331">MemoryMap::Segment::get_mapperms()</a>, <a class="el" href="rangemap_8h-source.html#l00087">Range&lt; T &gt;::inin()</a>, <a class="el" href="rangemap_8h-source.html#l00117">Range&lt; T &gt;::last()</a>, and <a class="el" href="MemoryMap_8h-source.html#l00652">p_segments</a>.
</div>
</div><p>
<a class="anchor" name="497cf700231115f91e5627a11c166653"></a><!-- doxytag: member="MemoryMap::erase" ref="497cf700231115f91e5627a11c166653" args="(const Extent &amp;range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryMap::erase           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Extent</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>range</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase parts of the mapping that correspond to the specified virtual address range. 
<p>
The addresses to be erased don't necessarily need to correspond to a similar <a class="el" href="namespacecfgUtils.html#495bbf2d6fb84a47ca0cc937068ab793">add()</a> call; for instance, it's possible to add a large address space and then erase parts of it to make holes. This operation is somewhat like the POSIX munmap() function.<p>
It is not an error to erase parts of the virtual address space that are not defined. Note that it is more efficient to call <a class="el" href="classMemoryMap.html#de35471bd24f46fc5099d8a6a97b0ddf">clear()</a> than to erase the entire virtual address space. 
<p>
Definition at line <a class="el" href="MemoryMap_8C-source.html#l00622">622</a> of file <a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a>.
<p>
References <a class="el" href="rangemap_8h-source.html#l00991">RangeMap&lt; R, T &gt;::erase()</a>, and <a class="el" href="MemoryMap_8h-source.html#l00652">p_segments</a>.
<p>
Referenced by <a class="el" href="MemoryMap_8C-source.html#l00628">erase()</a>, and <a class="el" href="Partitioner_8C-source.html#l01019">Partitioner::mark_ipd_configuration()</a>.
</div>
</div><p>
<a class="anchor" name="0426d0034ef1b0177b57e558f4eb6fd2"></a><!-- doxytag: member="MemoryMap::erase" ref="0426d0034ef1b0177b57e558f4eb6fd2" args="(const Segment &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryMap::erase           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMemoryMap_1_1Segment.html">Segment</a> &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase a single extent from a memory map. 
<p>
Erasing by range is more efficient (O(ln N) vs O(N)) but sometimes it's more convenient to erase a single segment when we don't know it's range. 
<p>
Definition at line <a class="el" href="MemoryMap_8C-source.html#l00628">628</a> of file <a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a>.
<p>
References <a class="el" href="rangemap_8h-source.html#l00775">RangeMap&lt; R, T &gt;::begin()</a>, <a class="el" href="rangemap_8h-source.html#l00787">RangeMap&lt; R, T &gt;::end()</a>, <a class="el" href="MemoryMap_8C-source.html#l00622">erase()</a>, and <a class="el" href="MemoryMap_8h-source.html#l00652">p_segments</a>.
</div>
</div><p>
<a class="anchor" name="236831c642b73ee2c26459340c7ee761"></a><!-- doxytag: member="MemoryMap::at" ref="236831c642b73ee2c26459340c7ee761" args="(rose_addr_t va) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classRange.html">Extent</a>, <a class="el" href="classMemoryMap_1_1Segment.html">MemoryMap::Segment</a> &gt; MemoryMap::at           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td>
          <td class="paramname"> <em>va</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get information about an address. 
<p>
The return value is a pair containing the range of virtual addresses in the segment and a copy of the <a class="el" href="classMemoryMap_1_1Segment.html">Segment</a> object. If the value is not found, then a RangeMap::NotMapped exception is thrown. See also, <a class="el" href="classMemoryMap.html#372b80eef545c53a95b322c53e526e64">exists()</a>. 
<p>
Definition at line <a class="el" href="MemoryMap_8C-source.html#l00639">639</a> of file <a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a>.
<p>
References <a class="el" href="rangemap_8h-source.html#l00787">RangeMap&lt; R, T &gt;::end()</a>, <a class="el" href="rangemap_8h-source.html#l00824">RangeMap&lt; R, T &gt;::find()</a>, and <a class="el" href="MemoryMap_8h-source.html#l00652">p_segments</a>.
<p>
Referenced by <a class="el" href="PeFileHeader_8C-source.html#l00522">SgAsmPEFileHeader::create_table_sections()</a>, <a class="el" href="MemoryMap_8C-source.html#l00113">MemoryMap::Buffer::is_zero()</a>, and <a class="el" href="GenericFile_8C-source.html#l00165">SgAsmGenericFile::read_content()</a>.
</div>
</div><p>
<a class="anchor" name="99e2f3d47ce36283671962e5f6ee93f5"></a><!-- doxytag: member="MemoryMap::find_free" ref="99e2f3d47ce36283671962e5f6ee93f5" args="(rose_addr_t start_va, size_t size, rose_addr_t mem_alignment=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> MemoryMap::find_free           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td>
          <td class="paramname"> <em>start_va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td>
          <td class="paramname"> <em>mem_alignment</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Search for free space in the mapping. 
<p>
This is done by looking for the lowest possible address not less than <code>start_va</code> and with the specified alignment where there are at least <code>size</code> free bytes. Throws a <a class="el" href="structMemoryMap_1_1NoFreeSpace.html">MemoryMap::NoFreeSpace</a> exception if the search fails to find free space. 
<p>
Definition at line <a class="el" href="MemoryMap_8C-source.html#l00648">648</a> of file <a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a>.
<p>
References <a class="el" href="MemoryMap_8h-source.html#l00007">ALIGN_UP</a>, <a class="el" href="rangemap_8h-source.html#l00787">RangeMap&lt; R, T &gt;::end()</a>, <a class="el" href="rangemap_8h-source.html#l00906">RangeMap&lt; R, T &gt;::first_fit()</a>, <a class="el" href="rangemap_8h-source.html#l01226">RangeMap&lt; R, T &gt;::invert()</a>, <a class="el" href="rangemap_8h-source.html#l00842">RangeMap&lt; R, T &gt;::lower_bound()</a>, and <a class="el" href="MemoryMap_8h-source.html#l00652">p_segments</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l01019">Partitioner::mark_ipd_configuration()</a>.
</div>
</div><p>
<a class="anchor" name="c4c396cc00022426897339bbc310eddd"></a><!-- doxytag: member="MemoryMap::find_last_free" ref="c4c396cc00022426897339bbc310eddd" args="(rose_addr_t max=(rose_addr_t)(-1)) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> MemoryMap::find_last_free           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td>
          <td class="paramname"> <em>max</em> = <code>(<a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>)(-1)</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds the highest area of unmapped addresses. 
<p>
The return value is the starting address of the highest contiguous region of unmapped address space that starts at or below the specified maximum. If no unmapped region exists then a <a class="el" href="structMemoryMap_1_1NoFreeSpace.html">MemoryMap::NoFreeSpace</a> exception is thrown. 
<p>
Definition at line <a class="el" href="MemoryMap_8C-source.html#l00664">664</a> of file <a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a>.
<p>
References <a class="el" href="rangemap_8h-source.html#l00787">RangeMap&lt; R, T &gt;::end()</a>, <a class="el" href="rangemap_8h-source.html#l00853">RangeMap&lt; R, T &gt;::find_prior()</a>, <a class="el" href="rangemap_8h-source.html#l01226">RangeMap&lt; R, T &gt;::invert()</a>, and <a class="el" href="MemoryMap_8h-source.html#l00652">p_segments</a>.
</div>
</div><p>
<a class="anchor" name="8eabb07a63d701ffb17649284a35eb2a"></a><!-- doxytag: member="MemoryMap::traverse" ref="8eabb07a63d701ffb17649284a35eb2a" args="(Visitor &amp;visitor) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryMap::traverse           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMemoryMap_1_1Visitor.html">Visitor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Traverses the segments of a map. 
<p>
The visitor is called for each segment. The visitor's return value is ignored. 
<p>
Definition at line <a class="el" href="MemoryMap_8C-source.html#l00674">674</a> of file <a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a>.
<p>
References <a class="el" href="rangemap_8h-source.html#l00775">RangeMap&lt; R, T &gt;::begin()</a>, <a class="el" href="rangemap_8h-source.html#l00787">RangeMap&lt; R, T &gt;::end()</a>, and <a class="el" href="MemoryMap_8h-source.html#l00652">p_segments</a>.
<p>
Referenced by <a class="el" href="Disassembler_8C-source.html#l00570">Disassembler::search_words()</a>.
</div>
</div><p>
<a class="anchor" name="8e5d8580f91704ebfb5b28bcbd71c01a"></a><!-- doxytag: member="MemoryMap::prune" ref="8e5d8580f91704ebfb5b28bcbd71c01a" args="(Visitor &amp;predicate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryMap::prune           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMemoryMap_1_1Visitor.html">Visitor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>predicate</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes segments for which <code>predicate</code> returns true. 
<p>
If the predicate always returns false then nothing is removed from the map, and the predicate can be used for its side effect (such as counting how many map segments satisfy certain criteria. 
<p>
Definition at line <a class="el" href="MemoryMap_8C-source.html#l00681">681</a> of file <a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a>.
<p>
References <a class="el" href="rangemap_8h-source.html#l00775">RangeMap&lt; R, T &gt;::begin()</a>, <a class="el" href="rangemap_8h-source.html#l00787">RangeMap&lt; R, T &gt;::end()</a>, <a class="el" href="rangemap_8h-source.html#l00991">RangeMap&lt; R, T &gt;::erase()</a>, <a class="el" href="rangemap_8h-source.html#l01062">RangeMap&lt; R, T &gt;::insert()</a>, and <a class="el" href="MemoryMap_8h-source.html#l00652">p_segments</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03245">Partitioner::post_cfg()</a>, <a class="el" href="MemoryMap_8C-source.html#l00694">prune()</a>, and <a class="el" href="Partitioner_8C-source.html#l00174">Partitioner::set_map()</a>.
</div>
</div><p>
<a class="anchor" name="66054714b17e6aebf094cf7883bf134c"></a><!-- doxytag: member="MemoryMap::prune" ref="66054714b17e6aebf094cf7883bf134c" args="(unsigned required, unsigned prohibited=MM_PROT_NONE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryMap::prune           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>required</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>prohibited</em> = <code>MM_PROT_NONE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes segments based on permissions. 
<p>
Keeps segments that have any of the required bits and none of the prohibited bits. No bits are required if <code>required</code> is zero. 
<p>
Definition at line <a class="el" href="MemoryMap_8C-source.html#l00694">694</a> of file <a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a>.
<p>
References <a class="el" href="MemoryMap_8h-source.html#l00331">MemoryMap::Segment::get_mapperms()</a>, and <a class="el" href="MemoryMap_8C-source.html#l00681">prune()</a>.
</div>
</div><p>
<a class="anchor" name="48c9dda77ad1d1335a441aaeef55d98e"></a><!-- doxytag: member="MemoryMap::segments" ref="48c9dda77ad1d1335a441aaeef55d98e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRangeMap.html">Segments</a>&amp; MemoryMap::segments           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
List of map segments. 
<p>

<p>
Definition at line <a class="el" href="MemoryMap_8h-source.html#l00561">561</a> of file <a class="el" href="MemoryMap_8h-source.html">MemoryMap.h</a>.
<p>
References <a class="el" href="MemoryMap_8h-source.html#l00652">p_segments</a>.
<p>
Referenced by <a class="el" href="Disassembler_8C-source.html#l00821">Disassembler::mark_referenced_instructions()</a>, and <a class="el" href="Disassembler_8C-source.html#l00617">Disassembler::search_next_address()</a>.
</div>
</div><p>
<a class="anchor" name="709a3ab13e92a0cbd4a12184e35d4941"></a><!-- doxytag: member="MemoryMap::read" ref="709a3ab13e92a0cbd4a12184e35d4941" args="(void *dst_buf, rose_addr_t start_va, size_t desired, unsigned req_perms=MM_PROT_READ) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MemoryMap::read           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dst_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td>
          <td class="paramname"> <em>start_va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>req_perms</em> = <code>MM_PROT_READ</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies data from a contiguous region of the virtual address space into a user supplied buffer. 
<p>
The portion of the virtual address space to copy begins at <code>start_va</code> and continues for <code>desired</code> bytes. The data is copied into the beginning of the <code>dst_buf</code> buffer. The return value is the number of bytes that were copied, which might be fewer than the number of bytes desired if the mapping does not include part of the address space requested or part of the address space does not have MM_PROT_READ permission (or the specified permissions). The <code>dst_buf</code> bytes that do not correpond to mapped virtual addresses will be zero filled so that <code>desired</code> bytes are always initialized.<p>
If <code>dst_buf</code> is the null pointer then this method only measures how many bytes could have been read.<p>
The <a class="el" href="classMemoryMap.html#709a3ab13e92a0cbd4a12184e35d4941">read()</a> and <a class="el" href="classMemoryMap.html#f8683ff784134fad5c016d51e03143e0">read1()</a> methods behave identically except <a class="el" href="classMemoryMap.html#f8683ff784134fad5c016d51e03143e0">read1()</a> restricts the readable area to be from a single segment. Thus, <a class="el" href="classMemoryMap.html#f8683ff784134fad5c016d51e03143e0">read1()</a> may return fewer bytes than <a class="el" href="classMemoryMap.html#709a3ab13e92a0cbd4a12184e35d4941">read()</a>. 
<p>
Definition at line <a class="el" href="MemoryMap_8C-source.html#l00728">728</a> of file <a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a>.
<p>
References <a class="el" href="MemoryMap_8C-source.html#l00708">read1()</a>.
<p>
Referenced by <a class="el" href="DisassemblerX86_8C-source.html#l00079">DisassemblerX86::disassembleOne()</a>, <a class="el" href="DisassemblerArm_8C-source.html#l00030">DisassemblerArm::disassembleOne()</a>, <a class="el" href="Partitioner_8C-source.html#l00191">Partitioner::discover_jump_table()</a>, <a class="el" href="Partitioner_8C-source.html#l01998">Partitioner::find_db_starting()</a>, <a class="el" href="PartialSymbolicSemantics_8h-source.html#l00391">BinaryAnalysis::InstructionSemantics::PartialSymbolicSemantics::Policy&lt; State, ValueType &gt;::mem_read()</a>, <a class="el" href="Partitioner_8C-source.html#l01730">Partitioner::FindDataPadding::operator()()</a>, and <a class="el" href="PeImportDirectory_8C-source.html#l00086">SgAsmPEImportDirectory::parse()</a>.
</div>
</div><p>
<a class="anchor" name="f8683ff784134fad5c016d51e03143e0"></a><!-- doxytag: member="MemoryMap::read1" ref="f8683ff784134fad5c016d51e03143e0" args="(void *dst_buf, rose_addr_t start_va, size_t desired, unsigned req_perms=MM_PROT_READ) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MemoryMap::read1           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dst_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td>
          <td class="paramname"> <em>start_va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>req_perms</em> = <code>MM_PROT_READ</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies data from a contiguous region of the virtual address space into a user supplied buffer. 
<p>
The portion of the virtual address space to copy begins at <code>start_va</code> and continues for <code>desired</code> bytes. The data is copied into the beginning of the <code>dst_buf</code> buffer. The return value is the number of bytes that were copied, which might be fewer than the number of bytes desired if the mapping does not include part of the address space requested or part of the address space does not have MM_PROT_READ permission (or the specified permissions). The <code>dst_buf</code> bytes that do not correpond to mapped virtual addresses will be zero filled so that <code>desired</code> bytes are always initialized.<p>
If <code>dst_buf</code> is the null pointer then this method only measures how many bytes could have been read.<p>
The <a class="el" href="classMemoryMap.html#709a3ab13e92a0cbd4a12184e35d4941">read()</a> and <a class="el" href="classMemoryMap.html#f8683ff784134fad5c016d51e03143e0">read1()</a> methods behave identically except <a class="el" href="classMemoryMap.html#f8683ff784134fad5c016d51e03143e0">read1()</a> restricts the readable area to be from a single segment. Thus, <a class="el" href="classMemoryMap.html#f8683ff784134fad5c016d51e03143e0">read1()</a> may return fewer bytes than <a class="el" href="classMemoryMap.html#709a3ab13e92a0cbd4a12184e35d4941">read()</a>. 
<p>
Definition at line <a class="el" href="MemoryMap_8C-source.html#l00708">708</a> of file <a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a>.
<p>
References <a class="el" href="MemoryMap_8C-source.html#l00349">MemoryMap::Segment::check()</a>, <a class="el" href="rangemap_8h-source.html#l00274">Range&lt; T &gt;::contains()</a>, <a class="el" href="rangemap_8h-source.html#l00787">RangeMap&lt; R, T &gt;::end()</a>, <a class="el" href="rangemap_8h-source.html#l00824">RangeMap&lt; R, T &gt;::find()</a>, <a class="el" href="MemoryMap_8h-source.html#l00312">MemoryMap::Segment::get_buffer()</a>, <a class="el" href="MemoryMap_8h-source.html#l00347">MemoryMap::Segment::get_buffer_offset()</a>, <a class="el" href="MemoryMap_8h-source.html#l00331">MemoryMap::Segment::get_mapperms()</a>, <a class="el" href="rangemap_8h-source.html#l00117">Range&lt; T &gt;::last()</a>, and <a class="el" href="MemoryMap_8h-source.html#l00652">p_segments</a>.
<p>
Referenced by <a class="el" href="MemoryMap_8C-source.html#l00728">read()</a>, <a class="el" href="GenericFile_8C-source.html#l00165">SgAsmGenericFile::read_content()</a>, and <a class="el" href="Disassembler_8C-source.html#l00570">Disassembler::search_words()</a>.
</div>
</div><p>
<a class="anchor" name="c0d0f7ab2482f726f1c02a54efc11372"></a><!-- doxytag: member="MemoryMap::read" ref="c0d0f7ab2482f726f1c02a54efc11372" args="(rose_addr_t start_va, size_t desired, unsigned req_perms=MM_PROT_READ) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Cxx__Grammar_8h.html#4f57773a5fc8d0d005f7553cd47cbc4e">SgUnsignedCharList</a> MemoryMap::read           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td>
          <td class="paramname"> <em>start_va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>req_perms</em> = <code>MM_PROT_READ</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads data from a memory map. 
<p>
Reads data beginning at the <code>start_va</code> virtual address in the memory map and continuing for up to <code>desired</code> bytes, returning the result as an SgUnsignedCharList. The read may be shorter than requested if we reach a point in the memory map that is not defined or which does not have the requested permissions. The size of the return value indicates that number of bytes that were read (i.e., the return value is not zero-filled). 
<p>
Definition at line <a class="el" href="MemoryMap_8C-source.html#l00742">742</a> of file <a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a>.
<p>
References <a class="el" href="MemoryMap_8C-source.html#l00708">read1()</a>.
</div>
</div><p>
<a class="anchor" name="4c05a968b891c4848ce6dc802fb1ada2"></a><!-- doxytag: member="MemoryMap::write" ref="4c05a968b891c4848ce6dc802fb1ada2" args="(const void *src_buf, rose_addr_t start_va, size_t desired, unsigned req_perms=MM_PROT_WRITE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MemoryMap::write           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>src_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td>
          <td class="paramname"> <em>start_va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>req_perms</em> = <code>MM_PROT_WRITE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies data from a supplied buffer into the specified virtual addresses. 
<p>
If part of the destination address space is not mapped, then all bytes up to that location are copied and no additional bytes are copied. The write is also aborted early if a segment lacks the MM_PROT_WRITE bit (or specified bits) or its buffer is marked as read-only. The return value is the number of bytes copied.<p>
If <code>src_buf</code> is the null pointer then this method only measures how many bytes could have been written.<p>
The <a class="el" href="classMemoryMap.html#4c05a968b891c4848ce6dc802fb1ada2">write()</a> and <a class="el" href="classMemoryMap.html#2a0e72bbdaf6a582f9b484ff9696bf76">write1()</a> methods behave identically, except <a class="el" href="classMemoryMap.html#2a0e72bbdaf6a582f9b484ff9696bf76">write1()</a> restricts the operation to a single segment. Thus, <a class="el" href="classMemoryMap.html#2a0e72bbdaf6a582f9b484ff9696bf76">write1()</a> may write fewer bytes than <a class="el" href="classMemoryMap.html#4c05a968b891c4848ce6dc802fb1ada2">write()</a>. 
<p>
Definition at line <a class="el" href="MemoryMap_8C-source.html#l00792">792</a> of file <a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a>.
<p>
References <a class="el" href="MemoryMap_8C-source.html#l00761">write1()</a>.
</div>
</div><p>
<a class="anchor" name="2a0e72bbdaf6a582f9b484ff9696bf76"></a><!-- doxytag: member="MemoryMap::write1" ref="2a0e72bbdaf6a582f9b484ff9696bf76" args="(const void *src_buf, rose_addr_t start_va, size_t desired, unsigned req_perms=MM_PROT_WRITE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MemoryMap::write1           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>src_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td>
          <td class="paramname"> <em>start_va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>req_perms</em> = <code>MM_PROT_WRITE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies data from a supplied buffer into the specified virtual addresses. 
<p>
If part of the destination address space is not mapped, then all bytes up to that location are copied and no additional bytes are copied. The write is also aborted early if a segment lacks the MM_PROT_WRITE bit (or specified bits) or its buffer is marked as read-only. The return value is the number of bytes copied.<p>
If <code>src_buf</code> is the null pointer then this method only measures how many bytes could have been written.<p>
The <a class="el" href="classMemoryMap.html#4c05a968b891c4848ce6dc802fb1ada2">write()</a> and <a class="el" href="classMemoryMap.html#2a0e72bbdaf6a582f9b484ff9696bf76">write1()</a> methods behave identically, except <a class="el" href="classMemoryMap.html#2a0e72bbdaf6a582f9b484ff9696bf76">write1()</a> restricts the operation to a single segment. Thus, <a class="el" href="classMemoryMap.html#2a0e72bbdaf6a582f9b484ff9696bf76">write1()</a> may write fewer bytes than <a class="el" href="classMemoryMap.html#4c05a968b891c4848ce6dc802fb1ada2">write()</a>. 
<p>
Definition at line <a class="el" href="MemoryMap_8C-source.html#l00761">761</a> of file <a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a>.
<p>
References <a class="el" href="rangemap_8h-source.html#l00775">RangeMap&lt; R, T &gt;::begin()</a>, <a class="el" href="rangemap_8h-source.html#l00274">Range&lt; T &gt;::contains()</a>, <a class="el" href="rangemap_8h-source.html#l00787">RangeMap&lt; R, T &gt;::end()</a>, <a class="el" href="rangemap_8h-source.html#l00824">RangeMap&lt; R, T &gt;::find()</a>, and <a class="el" href="MemoryMap_8h-source.html#l00652">p_segments</a>.
<p>
Referenced by <a class="el" href="MemoryMap_8C-source.html#l00792">write()</a>.
</div>
</div><p>
<a class="anchor" name="8ffed06efb5ddeb4c08c3fcafcc08c20"></a><!-- doxytag: member="MemoryMap::va_extents" ref="8ffed06efb5ddeb4c08c3fcafcc08c20" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classExtentMap.html">ExtentMap</a> MemoryMap::va_extents           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns just the virtual address extents for a memory map. 
<p>

<p>
Definition at line <a class="el" href="MemoryMap_8C-source.html#l00805">805</a> of file <a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a>.
<p>
References <a class="el" href="MemoryMap_8h-source.html#l00652">p_segments</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l01643">Partitioner::scan_unassigned_bytes()</a>.
</div>
</div><p>
<a class="anchor" name="9b60b4c96694154fbf1bb2d7c089a7a6"></a><!-- doxytag: member="MemoryMap::mprotect" ref="9b60b4c96694154fbf1bb2d7c089a7a6" args="(Extent range, unsigned perms, bool relax=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryMap::mprotect           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRange.html">Extent</a>&nbsp;</td>
          <td class="paramname"> <em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>perms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>relax</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets protection bits for the specified address range. 
<p>
The entire address range must already be mapped, but if <code>relax</code> is set then no exception is thrown if part of the range is not mapped (that part is just ignored). This operation is somewhat like the POSIX <a class="el" href="classMemoryMap.html#9b60b4c96694154fbf1bb2d7c089a7a6">mprotect()</a> function. 
<p>
Definition at line <a class="el" href="MemoryMap_8C-source.html#l00811">811</a> of file <a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a>.
<p>
References <a class="el" href="rangemap_8h-source.html#l00274">Range&lt; T &gt;::contains()</a>, <a class="el" href="rangemap_8h-source.html#l00197">Range&lt; T &gt;::empty()</a>, <a class="el" href="rangemap_8h-source.html#l00787">RangeMap&lt; R, T &gt;::end()</a>, <a class="el" href="rangemap_8h-source.html#l00098">Range&lt; T &gt;::first()</a>, <a class="el" href="rangemap_8h-source.html#l00087">Range&lt; T &gt;::inin()</a>, <a class="el" href="rangemap_8h-source.html#l01062">RangeMap&lt; R, T &gt;::insert()</a>, <a class="el" href="rangemap_8h-source.html#l00117">Range&lt; T &gt;::last()</a>, <a class="el" href="rangemap_8h-source.html#l00842">RangeMap&lt; R, T &gt;::lower_bound()</a>, <a class="el" href="MemoryMap_8h-source.html#l00652">p_segments</a>, <a class="el" href="MemoryMap_8C-source.html#l00378">MemoryMap::Segment::set_buffer_offset()</a>, and <a class="el" href="MemoryMap_8h-source.html#l00332">MemoryMap::Segment::set_mapperms()</a>.
</div>
</div><p>
<a class="anchor" name="c45b1135441de2185b0b72c858066911"></a><!-- doxytag: member="MemoryMap::dump" ref="c45b1135441de2185b0b72c858066911" args="(FILE *, const char *prefix=&quot;&quot;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryMap::dump           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>prefix</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prints the contents of the map for debugging. 
<p>
The <code>prefix</code> string is added to the beginning of every line of output and typically is used to indent the output. 
<p>
Definition at line <a class="el" href="MemoryMap_8C-source.html#l00854">854</a> of file <a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a>.
<p>
Referenced by <a class="el" href="PeExport_8C-source.html#l00008">SgAsmPEExportDirectory::ctor()</a>, <a class="el" href="MemoryMap_8C-source.html#l00031">MemoryMap::Exception::details()</a>, <a class="el" href="Disassembler_8C-source.html#l00748">Disassembler::disassembleInterp()</a>, <a class="el" href="PeFileHeader_8C-source.html#l00820">SgAsmPEFileHeader::dump()</a>, <a class="el" href="Partitioner_8C-source.html#l01019">Partitioner::mark_ipd_configuration()</a>, <a class="el" href="PeImportDirectory_8C-source.html#l00086">SgAsmPEImportDirectory::parse()</a>, <a class="el" href="PeExport_8C-source.html#l00144">SgAsmPEExportSection::parse()</a>, <a class="el" href="PeImportDirectory_8C-source.html#l00159">SgAsmPEImportDirectory::parse_ilt_iat()</a>, and <a class="el" href="MemoryMap_8h-source.html#l00614">print()</a>.
</div>
</div><p>
<a class="anchor" name="436d1d9026091be94f841d843a2fe810"></a><!-- doxytag: member="MemoryMap::dump" ref="436d1d9026091be94f841d843a2fe810" args="(std::ostream &amp;, std::string prefix=&quot;&quot;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryMap::dump           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>prefix</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prints the contents of the map for debugging. 
<p>
The <code>prefix</code> string is added to the beginning of every line of output and typically is used to indent the output. 
<p>
Definition at line <a class="el" href="MemoryMap_8C-source.html#l00862">862</a> of file <a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a>.
<p>
References <a class="el" href="namespaceStringUtility.html#b07dfdb6df484680f9a29ad4fcf79f80">StringUtility::addrToString()</a>, <a class="el" href="rangemap_8h-source.html#l00775">RangeMap&lt; R, T &gt;::begin()</a>, <a class="el" href="rangemap_8h-source.html#l00787">RangeMap&lt; R, T &gt;::end()</a>, <a class="el" href="MemoryMap_8h-source.html#l00652">p_segments</a>, and <a class="el" href="rangemap_8h-source.html#l00942">RangeMap&lt; R, T &gt;::size()</a>.
</div>
</div><p>
<a class="anchor" name="f284bb08259e651c94309bcbf3994a6a"></a><!-- doxytag: member="MemoryMap::print" ref="f284bb08259e651c94309bcbf3994a6a" args="(std::ostream &amp;o, std::string prefix=&quot;&quot;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryMap::print           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>prefix</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prints the contents of the map for debugging. 
<p>
The <code>prefix</code> string is added to the beginning of every line of output and typically is used to indent the output. 
<p>
Definition at line <a class="el" href="MemoryMap_8h-source.html#l00614">614</a> of file <a class="el" href="MemoryMap_8h-source.html">MemoryMap.h</a>.
<p>
References <a class="el" href="MemoryMap_8C-source.html#l00854">dump()</a>, and <a class="el" href="SgUnaryOp_8docs.html#c6cf1576467b95ef29f025f8e47eea437afa939f8bd773f5f7e326990b07580c">prefix</a>.
<p>
Referenced by <a class="el" href="MemoryMap_8C-source.html#l00012">operator&lt;&lt;()</a>.
</div>
</div><p>
<a class="anchor" name="5f8be6a3c404404aa8c4b1b7fdff3c95"></a><!-- doxytag: member="MemoryMap::dump" ref="5f8be6a3c404404aa8c4b1b7fdff3c95" args="(const std::string &amp;basename) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryMap::dump           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>basename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dumps the entire map and its contents into a set of files. 
<p>
The file names are constructed from the <code>basename</code> by appending a hypen and a hexadecimal address (without the leading "0x") and the extension ".data". The text file whose name is constructed by appending ".index" to the <code>basename</code> contains an index of the memory map. 
<p>
Definition at line <a class="el" href="MemoryMap_8C-source.html#l00886">886</a> of file <a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a>.
<p>
References <a class="el" href="namespaceStringUtility.html#b07dfdb6df484680f9a29ad4fcf79f80">StringUtility::addrToString()</a>, <a class="el" href="rangemap_8h-source.html#l00775">RangeMap&lt; R, T &gt;::begin()</a>, <a class="el" href="rangemap_8h-source.html#l00787">RangeMap&lt; R, T &gt;::end()</a>, and <a class="el" href="MemoryMap_8h-source.html#l00652">p_segments</a>.
</div>
</div><p>
<a class="anchor" name="e99220f42b2ae4bce99bd56910efcab1"></a><!-- doxytag: member="MemoryMap::load" ref="e99220f42b2ae4bce99bd56910efcab1" args="(const std::string &amp;basename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MemoryMap::load           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>basename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a memory map from a set of memory dump files. 
<p>
The argument should be the same basename that was given to an invocation of the <a class="el" href="classMemoryMap.html#c45b1135441de2185b0b72c858066911">dump()</a> method. The memory map is adjusted according to the contents of the index file. Returns true if the data was successfully read in its entirety; note that when returning false, this memory map object might be partially changed (although still in a consistent state).<p>
This method also understands a more user-friendly dump index format. Each line of the index is either blank (containing only white space), a comment (introduced with a '#') or a segment specification. A segment specification contains the following fields separated by white space (and/or a comma):<p>
<ul>
<li>
The virtual address for the start of this memory area. </li>
<li>
The size of this memory area in bytes. </li>
<li>
Mapping permissions consisting of the letters "r" (read), "w" (write), "x" (execute), or "p" (private). Hyphens also be present in this field and do not affect the permissions. </li>
<li>
The source of the data. This field consists of everything up to the next "0x" string (but leading and trailing white space is stripped). It may be the name of a file or the name of a buffer. <a class="el" href="classMemoryMap_1_1Buffer.html">Buffer</a> names are only used for debugging. </li>
<li>
The byte offset of the start of data within the file. It allows a single file to contain multiple memory areas. </li>
<li>
An optional comment which will appear as the map element name for debugging. </li>
</ul>
<p>
If an error occurs an exception is thrown. 
<p>
Definition at line <a class="el" href="MemoryMap_8C-source.html#l00901">901</a> of file <a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a>.
<p>
References <a class="el" href="MemoryMap_8C-source.html#l00556">clear()</a>, <a class="el" href="MemoryMap_8C-source.html#l00194">MemoryMap::ByteBuffer::create_from_file()</a>, <a class="el" href="MemoryMap_8C-source.html#l00585">insert()</a>, <a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575a061dc1ffe578fdaea067d730efb00ac">MM_PROT_EXEC</a>, <a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575142989711b3e75e3e66a96461b8fbd6a">MM_PROT_PRIVATE</a>, <a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575721c493a6d527e717ffd911d2f18060f">MM_PROT_READ</a>, and <a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575ba37f8b609f7bd6bc6a454be584726df">MM_PROT_WRITE</a>.
</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="62d57db8b553f396fa5786845552edbb"></a><!-- doxytag: member="MemoryMap::operator&lt;&lt;" ref="62d57db8b553f396fa5786845552edbb" args="(std::ostream &amp;, const MemoryMap &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMemoryMap.html">MemoryMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="MemoryMap_8C-source.html#l00012">12</a> of file <a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a>.
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="6a03e9d53a131a9aa6ae0786c3c0f55a"></a><!-- doxytag: member="MemoryMap::p_segments" ref="6a03e9d53a131a9aa6ae0786c3c0f55a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html">Segments</a> <a class="el" href="classMemoryMap.html#6a03e9d53a131a9aa6ae0786c3c0f55a">MemoryMap::p_segments</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="MemoryMap_8h-source.html#l00652">652</a> of file <a class="el" href="MemoryMap_8h-source.html">MemoryMap.h</a>.
<p>
Referenced by <a class="el" href="MemoryMap_8C-source.html#l00639">at()</a>, <a class="el" href="MemoryMap_8C-source.html#l00556">clear()</a>, <a class="el" href="MemoryMap_8C-source.html#l00862">dump()</a>, <a class="el" href="MemoryMap_8C-source.html#l00622">erase()</a>, <a class="el" href="MemoryMap_8C-source.html#l00599">exists()</a>, <a class="el" href="MemoryMap_8C-source.html#l00648">find_free()</a>, <a class="el" href="MemoryMap_8C-source.html#l00664">find_last_free()</a>, <a class="el" href="MemoryMap_8C-source.html#l00562">init()</a>, <a class="el" href="MemoryMap_8C-source.html#l00585">insert()</a>, <a class="el" href="MemoryMap_8C-source.html#l00811">mprotect()</a>, <a class="el" href="MemoryMap_8C-source.html#l00681">prune()</a>, <a class="el" href="MemoryMap_8C-source.html#l00708">read1()</a>, <a class="el" href="MemoryMap_8h-source.html#l00561">segments()</a>, <a class="el" href="MemoryMap_8C-source.html#l00674">traverse()</a>, <a class="el" href="MemoryMap_8C-source.html#l00805">va_extents()</a>, and <a class="el" href="MemoryMap_8C-source.html#l00761">write1()</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="MemoryMap_8h-source.html">MemoryMap.h</a><li><a class="el" href="MemoryMap_8C-source.html">MemoryMap.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
