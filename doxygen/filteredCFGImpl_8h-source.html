<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: filteredCFGImpl.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>filteredCFGImpl.h</h1><a href="filteredCFGImpl_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//#include &lt;rose.h&gt;</span>
<a name="l00002"></a>00002 <span class="preprocessor">#include "<a class="code" href="filteredCFG_8h.html">filteredCFG.h</a>"</span>
<a name="l00003"></a>00003 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &lt;iomanip&gt;</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &lt;stdint.h&gt;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;set&gt;</span>
<a name="l00007"></a>00007 
<a name="l00008"></a><a class="code" href="filteredCFGImpl_8h.html#adbab08643e41419b9821541a0654e97">00008</a> <span class="preprocessor">#define SgNULL_FILE Sg_File_Info::generateDefaultFileInfoForTransformationNode()</span>
<a name="l00009"></a>00009 <span class="preprocessor"></span>
<a name="l00010"></a>00010 <span class="keyword">namespace </span>VirtualCFG
<a name="l00011"></a>00011 {
<a name="l00012"></a>00012   <span class="comment">/* Documented by Liao, May not be entirely accurate. 2/14/2012</span>
<a name="l00013"></a>00013 <span class="comment">   *</span>
<a name="l00014"></a>00014 <span class="comment">   * Filtered CFG is handled internally when FilteredCFGNode &lt;T&gt;::inEdges() and ::outEdges() are requested</span>
<a name="l00015"></a>00015 <span class="comment">   * Take FilteredCFGNode &lt; FilterFunction &gt;::outEdges() as an example, here is how it works:</span>
<a name="l00016"></a>00016 <span class="comment">   * Each raw outgoing virtual CFG edge is a candidate, and converted to a CFGPath each. </span>
<a name="l00017"></a>00017 <span class="comment">   * For each candidate CFGPath, check the target Node (the node pointed to by the last edge of the path) </span>
<a name="l00018"></a>00018 <span class="comment">   *  - if the target node is an interesting node according to the filter function, then the path is good, the edge can be returned as it is mostly. </span>
<a name="l00019"></a>00019 <span class="comment">   *  - if the target node is a CFG node to be filtered out, then the original path is extended to include all successors </span>
<a name="l00020"></a>00020 <span class="comment">   *    By following raw outEdges of the target node, we now have N candidate CFGPaths if there are N raw outEdges of target </span>
<a name="l00021"></a>00021 <span class="comment">   *    - Recursively handle all the new N CFGPaths until a path has a target node which is not being filtered out (interesting)</span>
<a name="l00022"></a>00022 <span class="comment">   */</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024     <span class="keyword">template</span> &lt; <span class="keyword">typename</span> FindSuccessors, <span class="comment">// a function to obtain successor edges of a node</span>
<a name="l00025"></a>00025                <span class="keyword">typename</span> FindEnd,  <span class="comment">// obtain the final node of a CFG path</span>
<a name="l00026"></a>00026                <span class="keyword">typename</span> DontAddChildren,  <span class="comment">// filter function (functor)</span>
<a name="l00027"></a>00027                <span class="keyword">typename</span> Join, <span class="comment">// merge two paths into one path</span>
<a name="l00028"></a>00028                <span class="keyword">typename</span> FilteredEdge &gt; 
<a name="l00029"></a><a class="code" href="structVirtualCFG_1_1MakeClosure.html">00029</a>     <span class="keyword">struct </span><a class="code" href="structVirtualCFG_1_1MakeClosure.html">MakeClosure</a> <span class="comment">// a template struct to make raw input edges closure (filter out unnecessary edges) </span>
<a name="l00030"></a>00030     {
<a name="l00031"></a><a class="code" href="structVirtualCFG_1_1MakeClosure.html#101e24702366d60501d5d782788d951c">00031</a>         std::set &lt; CFGNode &gt; <a class="code" href="structVirtualCFG_1_1MakeClosure.html#101e24702366d60501d5d782788d951c">visitedNodes</a>;
<a name="l00032"></a><a class="code" href="structVirtualCFG_1_1MakeClosure.html#81387dedc613283d891f8adc7bdf7e96">00032</a>         std::vector &lt; CFGPath &gt; <a class="code" href="structVirtualCFG_1_1MakeClosure.html#81387dedc613283d891f8adc7bdf7e96">visitedPaths</a>;
<a name="l00033"></a><a class="code" href="structVirtualCFG_1_1MakeClosure.html#c1857bf241d772f3cdcb54aec6eaf1e5">00033</a>         <span class="keyword">const</span> FindSuccessors &amp; <a class="code" href="structVirtualCFG_1_1MakeClosure.html#c1857bf241d772f3cdcb54aec6eaf1e5">findSuccessors</a>;
<a name="l00034"></a><a class="code" href="structVirtualCFG_1_1MakeClosure.html#c4401f8db1fbaac31add9b93520e0fdd">00034</a>         <span class="keyword">const</span> FindEnd &amp; <a class="code" href="structVirtualCFG_1_1MakeClosure.html#c4401f8db1fbaac31add9b93520e0fdd">findEnd</a>;
<a name="l00035"></a><a class="code" href="structVirtualCFG_1_1MakeClosure.html#48c8ea0cfeb9cec9099285b57c43cd88">00035</a>         <span class="keyword">const</span> DontAddChildren &amp; <a class="code" href="structVirtualCFG_1_1MakeClosure.html#48c8ea0cfeb9cec9099285b57c43cd88">dontAddChildren</a>;
<a name="l00036"></a><a class="code" href="structVirtualCFG_1_1MakeClosure.html#16245c51043e80089b0b76312d0dbf6b">00036</a>         <span class="keyword">const</span> Join &amp; <a class="code" href="structVirtualCFG_1_1MakeClosure.html#16245c51043e80089b0b76312d0dbf6b">join</a>;
<a name="l00037"></a>00037 
<a name="l00038"></a><a class="code" href="structVirtualCFG_1_1MakeClosure.html#af377b322d72c66bcec975dd7ec3efd0">00038</a>         <a class="code" href="structVirtualCFG_1_1MakeClosure.html#af377b322d72c66bcec975dd7ec3efd0">MakeClosure</a>(<span class="keyword">const</span> FindSuccessors &amp; <a class="code" href="structVirtualCFG_1_1MakeClosure.html#c1857bf241d772f3cdcb54aec6eaf1e5">findSuccessors</a>, 
<a name="l00039"></a>00039                     <span class="keyword">const</span> FindEnd &amp; <a class="code" href="structVirtualCFG_1_1MakeClosure.html#c4401f8db1fbaac31add9b93520e0fdd">findEnd</a>,
<a name="l00040"></a>00040                     <span class="keyword">const</span> DontAddChildren &amp; <a class="code" href="structVirtualCFG_1_1MakeClosure.html#48c8ea0cfeb9cec9099285b57c43cd88">dontAddChildren</a>,
<a name="l00041"></a>00041                     <span class="keyword">const</span> Join &amp; <a class="code" href="structVirtualCFG_1_1MakeClosure.html#16245c51043e80089b0b76312d0dbf6b">join</a>) :
<a name="l00042"></a>00042             findSuccessors(findSuccessors), findEnd(findEnd),
<a name="l00043"></a>00043             dontAddChildren(dontAddChildren), join(join)
<a name="l00044"></a>00044         {
<a name="l00045"></a>00045         }
<a name="l00046"></a>00046 
<a name="l00048"></a><a class="code" href="structVirtualCFG_1_1MakeClosure.html#e1b860249ac485248e1fd792551ce3b2">00048</a>         <span class="keywordtype">void</span> <a class="code" href="structVirtualCFG_1_1MakeClosure.html#e1b860249ac485248e1fd792551ce3b2">go</a>(<span class="keyword">const</span> <a class="code" href="classVirtualCFG_1_1CFGPath.html">CFGPath</a> &amp; p)
<a name="l00049"></a>00049         {
<a name="l00050"></a>00050             <a class="code" href="classVirtualCFG_1_1CFGNode.html">CFGNode</a> end = <a class="code" href="structVirtualCFG_1_1MakeClosure.html#c4401f8db1fbaac31add9b93520e0fdd">findEnd</a>(p);<span class="comment">// obtain the final node of the path</span>
<a name="l00051"></a>00051 
<a name="l00052"></a>00052             <span class="comment">// skip visited end CFGNode, the corresponding successor paths of the end node are processed already</span>
<a name="l00053"></a>00053             <span class="keywordflow">if</span> (<a class="code" href="structVirtualCFG_1_1MakeClosure.html#101e24702366d60501d5d782788d951c">visitedNodes</a>.find(end) != <a class="code" href="structVirtualCFG_1_1MakeClosure.html#101e24702366d60501d5d782788d951c">visitedNodes</a>.end()) 
<a name="l00054"></a>00054                <span class="keywordflow">return</span>;
<a name="l00055"></a>00055             <a class="code" href="structVirtualCFG_1_1MakeClosure.html#101e24702366d60501d5d782788d951c">visitedNodes</a>.insert(end); <span class="comment">//bookkeeping</span>
<a name="l00056"></a>00056             <a class="code" href="structVirtualCFG_1_1MakeClosure.html#81387dedc613283d891f8adc7bdf7e96">visitedPaths</a>.push_back(p);
<a name="l00057"></a>00057             <span class="comment">// Reach an end CFG node which should be not filtered out. The path is valid already (ending with an interesting node).</span>
<a name="l00058"></a>00058             <span class="keywordflow">if</span> (<a class="code" href="structVirtualCFG_1_1MakeClosure.html#48c8ea0cfeb9cec9099285b57c43cd88">dontAddChildren</a>(end)) 
<a name="l00059"></a>00059                   <span class="keywordflow">return</span>;
<a name="l00060"></a>00060             <span class="comment">// The end Node is one which will be filtered out, look further down the successors:outEdges() or inEdges()</span>
<a name="l00061"></a>00061             <span class="comment">// to find an interesting node as the new end</span>
<a name="l00062"></a>00062             std::vector &lt; CFGEdge &gt; edges = <a class="code" href="structVirtualCFG_1_1MakeClosure.html#c1857bf241d772f3cdcb54aec6eaf1e5">findSuccessors</a>(end); 
<a name="l00063"></a>00063             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; edges.size(); ++i)
<a name="l00064"></a>00064             {
<a name="l00065"></a>00065                 <a class="code" href="structVirtualCFG_1_1MakeClosure.html#e1b860249ac485248e1fd792551ce3b2">go</a>(<a class="code" href="structVirtualCFG_1_1MakeClosure.html#16245c51043e80089b0b76312d0dbf6b">join</a>(p, edges[i])); <span class="comment">// connect the current path to successors, for each connected path, </span>
<a name="l00066"></a>00066                                        <span class="comment">//do the same processing (make sure end node is interesting)</span>
<a name="l00067"></a>00067             }
<a name="l00068"></a>00068         }
<a name="l00070"></a><a class="code" href="structVirtualCFG_1_1MakeClosure.html#6928fa5feab1125e0f06be3a8dabff37">00070</a>         std::vector &lt; FilteredEdge &gt; <a class="code" href="structVirtualCFG_1_1MakeClosure.html#6928fa5feab1125e0f06be3a8dabff37">filter</a>()<span class="keyword"> const</span>
<a name="l00071"></a>00071 <span class="keyword">        </span>{
<a name="l00072"></a>00072             std::vector &lt; FilteredEdge &gt; edges;
<a name="l00073"></a>00073             <span class="comment">// for each valid paths</span>
<a name="l00074"></a>00074             <span class="keywordflow">for</span> (std::vector &lt; CFGPath &gt;::const_iterator i = <a class="code" href="structVirtualCFG_1_1MakeClosure.html#81387dedc613283d891f8adc7bdf7e96">visitedPaths</a>.begin(); i != <a class="code" href="structVirtualCFG_1_1MakeClosure.html#81387dedc613283d891f8adc7bdf7e96">visitedPaths</a>.end(); ++i)
<a name="l00075"></a>00075             { 
<a name="l00076"></a>00076                 <span class="keyword">const</span> <a class="code" href="classVirtualCFG_1_1CFGPath.html">CFGPath</a> &amp; p = *i; 
<a name="l00077"></a>00077                 <span class="keywordflow">if</span> (<a class="code" href="structVirtualCFG_1_1MakeClosure.html#48c8ea0cfeb9cec9099285b57c43cd88">dontAddChildren</a>(<a class="code" href="structVirtualCFG_1_1MakeClosure.html#c4401f8db1fbaac31add9b93520e0fdd">findEnd</a>(p))) <span class="comment">// if the end edge of a current path should not filtered out (interesting path)</span>
<a name="l00078"></a>00078                    edges.push_back(FilteredEdge(*i));
<a name="l00079"></a>00079             }
<a name="l00080"></a>00080             <span class="keywordflow">return</span> edges;
<a name="l00081"></a>00081         }
<a name="l00082"></a>00082     };
<a name="l00083"></a>00083     <span class="comment">// a template function to instantiate MakeClosure</span>
<a name="l00084"></a>00084     <span class="keyword">template</span> &lt; <span class="keyword">typename</span> FilteredEdge, 
<a name="l00085"></a>00085                <span class="keyword">typename</span> FindSuccessors, 
<a name="l00086"></a>00086                <span class="keyword">typename</span> FindEnd,
<a name="l00087"></a>00087                <span class="keyword">typename</span> AddChildren, <span class="comment">// CFG Filter function</span>
<a name="l00088"></a>00088                <span class="keyword">typename</span> Join &gt; 
<a name="l00089"></a><a class="code" href="namespaceVirtualCFG.html#9d6be8b80e4d30a69b53b3652d363c27">00089</a>     std::vector &lt; FilteredEdge &gt; <a class="code" href="namespaceVirtualCFG.html#9d6be8b80e4d30a69b53b3652d363c27">makeClosure</a>(<span class="keyword">const</span> std::vector &lt; CFGPath &gt; &amp;p, <span class="comment">//  a vector of CFGPath be be made closure, in of out edges</span>
<a name="l00090"></a>00090                                              <span class="keyword">const</span> FindSuccessors &amp; findSuccessors,
<a name="l00091"></a>00091                                              <span class="keyword">const</span> FindEnd &amp; findEnd,
<a name="l00092"></a>00092                                              <span class="keyword">const</span> AddChildren &amp; addChildren, <span class="comment">// filter functor</span>
<a name="l00093"></a>00093                                              <span class="keyword">const</span> Join &amp; join)
<a name="l00094"></a>00094     {
<a name="l00095"></a>00095         MakeClosure &lt; FindSuccessors, FindEnd, AddChildren, Join, FilteredEdge &gt; 
<a name="l00096"></a>00096            mc(findSuccessors, findEnd, addChildren, join);
<a name="l00097"></a>00097         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; p.size(); ++i)
<a name="l00098"></a>00098             mc.<a class="code" href="structVirtualCFG_1_1MakeClosure.html#e1b860249ac485248e1fd792551ce3b2">go</a>(p[i]);
<a name="l00099"></a>00099         <span class="keywordflow">return</span> mc.<a class="code" href="structVirtualCFG_1_1MakeClosure.html#6928fa5feab1125e0f06be3a8dabff37">filter</a>();
<a name="l00100"></a>00100     }
<a name="l00101"></a>00101 
<a name="l00102"></a>00102    <span class="comment">// internal function: make a set of raw edges closure</span>
<a name="l00103"></a>00103     <span class="keyword">template</span> &lt; <span class="keyword">typename</span> FilteredEdge, <span class="keyword">typename</span> Filter &gt;
<a name="l00104"></a><a class="code" href="namespaceVirtualCFG.html#a04305a9d7cd2665422f6ee3cd23a599">00104</a>     std::vector &lt; FilteredEdge &gt; <a class="code" href="namespaceVirtualCFG.html#9d6be8b80e4d30a69b53b3652d363c27">makeClosure</a>(<span class="keyword">const</span> std::vector &lt; CFGEdge &gt; &amp;orig, <span class="comment">// input raw edges</span>
<a name="l00105"></a>00105                                                    std::vector &lt; CFGEdge &gt; (<a class="code" href="classVirtualCFG_1_1CFGNode.html">CFGNode</a>::*closure) ()<span class="keyword">const</span>, <span class="comment">// FindSuccessors operator: CFGNode::outEdges() in fact</span>
<a name="l00106"></a>00106                                                    <a class="code" href="classVirtualCFG_1_1CFGNode.html">CFGNode</a>(<a class="code" href="classVirtualCFG_1_1CFGPath.html">CFGPath</a>::*otherSide) ()<span class="keyword">const</span>, <span class="comment">//FindEnd operator: CFGPath::target() </span>
<a name="l00107"></a>00107                                                    <a class="code" href="classVirtualCFG_1_1CFGPath.html">CFGPath</a>(*merge) (<span class="keyword">const</span> <a class="code" href="classVirtualCFG_1_1CFGPath.html">CFGPath</a> &amp;, <span class="keyword">const</span> CFGPath &amp;), <span class="comment">// Join operator: VirtualCFG::mergePaths()</span>
<a name="l00108"></a>00108                                              <span class="keyword">const</span> Filter &amp; filter) <span class="comment">// the filter function</span>
<a name="l00109"></a>00109     {
<a name="l00110"></a>00110         std::vector &lt; CFGPath &gt; <a class="code" href="yicesParserLib_8h.html#0ab651cea734fb0eb3ed32cef06b99ec">paths</a>(orig.begin(), orig.end()); <span class="comment">// convert each raw edges into a path: 1-to-1 conversion for now</span>
<a name="l00111"></a>00111         <span class="keywordflow">return</span> makeClosure &lt; FilteredEdge &gt; (<a class="code" href="yicesParserLib_8h.html#0ab651cea734fb0eb3ed32cef06b99ec">paths</a>, 
<a name="l00112"></a>00112                                              std::mem_fun_ref(closure),
<a name="l00113"></a>00113                                              std::mem_fun_ref(otherSide), 
<a name="l00114"></a>00114                                              filter,
<a name="l00115"></a>00115                                              merge);
<a name="l00116"></a>00116     }
<a name="l00117"></a>00117 
<a name="l00118"></a>00118 
<a name="l00119"></a>00119     <span class="comment">// Class Impl: user-level interface function for outEdges for FilteredCFGNode &lt;T&gt;, Only FilterFunction is needed</span>
<a name="l00120"></a>00120     <span class="comment">// The returned edges already make the filtered CFG closure (internally and transparently)</span>
<a name="l00121"></a>00121     <span class="keyword">template</span> &lt; <span class="keyword">typename</span> FilterFunction &gt; 
<a name="l00122"></a><a class="code" href="classVirtualCFG_1_1FilteredCFGNode.html#4058df7ccdb8db3c149cffa1742c8faf">00122</a>     std::vector &lt; FilteredCFGEdge &lt; FilterFunction &gt; &gt;  <a class="code" href="namespaceStaticCFG.html#b6db4c881b581bbf831656db30daf0ce">FilteredCFGNode &lt; FilterFunction &gt;::outEdges</a>()<span class="keyword">const</span>
<a name="l00123"></a>00123     {
<a name="l00124"></a>00124         <span class="keywordflow">return</span> <a class="code" href="namespaceVirtualCFG.html#9d6be8b80e4d30a69b53b3652d363c27">makeClosure</a> &lt; FilteredCFGEdge &lt; FilterFunction &gt; &gt;(n.outEdges(), <span class="comment">// start with raw CFGNode's outEdges</span>
<a name="l00125"></a>00125                                                                   &amp;<a class="code" href="classVirtualCFG_1_1CFGNode.html#fb50fcf06bd74a1a10ded04e5fd061f3">CFGNode::outEdges</a>, <span class="comment">//FindSuccessors operator</span>
<a name="l00126"></a>00126                                                                   &amp;<a class="code" href="classVirtualCFG_1_1CFGPath.html#9840a71f85e47838c88fdb309b737a3f">CFGPath::target</a>, <span class="comment">//FindEnd operator, the target node the path leads to</span>
<a name="l00127"></a>00127                                                                   &amp;<a class="code" href="namespaceVirtualCFG.html#f0c17c7c5f4f8ec4e80f098f226d81a8">mergePaths</a>, <span class="comment">// merge/join operator: VirtualCFG::mergePaths(), defined in virtualCFG.h</span>
<a name="l00128"></a>00128                                                                   filter); <span class="comment">// the FilterFunction member of FilteredCFGNode</span>
<a name="l00129"></a>00129     }
<a name="l00130"></a>00130     <span class="comment">// Class Impl: user-level interface function for inEdges() of FilteredCFGNnode &lt;T&gt;</span>
<a name="l00131"></a>00131     <span class="keyword">template</span> &lt; <span class="keyword">typename</span> FilterFunction &gt; 
<a name="l00132"></a><a class="code" href="classVirtualCFG_1_1FilteredCFGNode.html#06fb7f16c40282bf96473d0be86762f1">00132</a>     std::vector &lt; FilteredCFGEdge &lt; FilterFunction &gt;  &gt; <a class="code" href="namespaceStaticCFG.html#ed5c146d0f80fb458f99e8cf7a700199">FilteredCFGNode &lt; FilterFunction &gt;::inEdges</a>() <span class="keyword">const</span>
<a name="l00133"></a>00133     {
<a name="l00134"></a>00134         <span class="keywordflow">return</span> <a class="code" href="namespaceVirtualCFG.html#9d6be8b80e4d30a69b53b3652d363c27">makeClosure</a> &lt; FilteredCFGEdge &lt; FilterFunction &gt; &gt;(n.inEdges(),
<a name="l00135"></a>00135                                                                   &amp;<a class="code" href="classVirtualCFG_1_1CFGNode.html#8b34e7598e1a03a8b39497e26a27ae27">CFGNode::inEdges</a>,
<a name="l00136"></a>00136                                                                   &amp;<a class="code" href="classVirtualCFG_1_1CFGPath.html#602014eec86cfaf87a5ea8a5a72899bc">CFGPath::source</a>,
<a name="l00137"></a>00137                                                                   &amp;<a class="code" href="namespaceVirtualCFG.html#684bdbfd795da2598c38f718b68cf7eb">mergePathsReversed</a>, 
<a name="l00138"></a>00138                                                                   filter);
<a name="l00139"></a>00139     }
<a name="l00140"></a>00140     <span class="comment">// ---------------------------------------------</span>
<a name="l00141"></a>00141     <span class="comment">// DOT OUT IMPL</span>
<a name="l00142"></a>00142     <span class="keyword">template</span> &lt; <span class="keyword">typename</span> NodeT, <span class="keyword">typename</span> EdgeT ,<span class="keywordtype">bool</span> Debug&gt;  <span class="comment">/*Filtered Node Type, Filtered CFG Type*/</span>
<a name="l00143"></a><a class="code" href="classVirtualCFG_1_1CfgToDotImpl.html">00143</a>     <span class="keyword">class </span><a class="code" href="classVirtualCFG_1_1CfgToDotImpl.html">CfgToDotImpl</a>
<a name="l00144"></a>00144     {
<a name="l00145"></a><a class="code" href="classVirtualCFG_1_1CfgToDotImpl.html#4ff4f2dee0457649de76063443f22bd3">00145</a>         std::multimap &lt; SgNode *, NodeT &gt; <a class="code" href="classVirtualCFG_1_1CfgToDotImpl.html#4ff4f2dee0457649de76063443f22bd3">exploredNodes</a>;
<a name="l00146"></a><a class="code" href="classVirtualCFG_1_1CfgToDotImpl.html#c19a52047cc6264b3ca8d4ae997eb6f9">00146</a>         std::set &lt; SgNode * &gt;<a class="code" href="classVirtualCFG_1_1CfgToDotImpl.html#c19a52047cc6264b3ca8d4ae997eb6f9">nodesPrinted</a>;
<a name="l00147"></a><a class="code" href="classVirtualCFG_1_1CfgToDotImpl.html#2284d29034b214ceb2bea666102413d8">00147</a>         std::ostream &amp; <a class="code" href="classVirtualCFG_1_1CfgToDotImpl.html#2284d29034b214ceb2bea666102413d8">o</a>;
<a name="l00148"></a>00148 
<a name="l00149"></a>00149       <span class="keyword">public</span>:
<a name="l00150"></a><a class="code" href="classVirtualCFG_1_1CfgToDotImpl.html#f77474f50d09c7bd1c5c0267b0394093">00150</a>       <a class="code" href="classVirtualCFG_1_1CfgToDotImpl.html#f77474f50d09c7bd1c5c0267b0394093">CfgToDotImpl</a>(std::ostream &amp; <a class="code" href="classVirtualCFG_1_1CfgToDotImpl.html#2284d29034b214ceb2bea666102413d8">o</a>) :
<a name="l00151"></a>00151         <a class="code" href="classVirtualCFG_1_1CfgToDotImpl.html#4ff4f2dee0457649de76063443f22bd3">exploredNodes</a>(), <a class="code" href="classVirtualCFG_1_1CfgToDotImpl.html#c19a52047cc6264b3ca8d4ae997eb6f9">nodesPrinted</a>(), o(o)
<a name="l00152"></a>00152         {
<a name="l00153"></a>00153         }
<a name="l00154"></a>00154       <span class="keywordtype">void</span> <a class="code" href="classVirtualCFG_1_1CfgToDotImpl.html#734cfdd0cfe25397230acc25ff3e3d26">processNodes</a>(NodeT n);
<a name="l00155"></a>00155     };
<a name="l00156"></a>00156 
<a name="l00158"></a>00158     <span class="keyword">template</span> &lt; <span class="keyword">typename</span> NodeT &gt; 
<a name="l00159"></a><a class="code" href="namespaceVirtualCFG.html#0d0e4fda6f275a23ff128b825ffd2315">00159</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespaceVirtualCFG.html#0d0e4fda6f275a23ff128b825ffd2315">printNode</a>(std::ostream &amp; o, <span class="keyword">const</span> NodeT &amp; n)
<a name="l00160"></a>00160     {
<a name="l00161"></a>00161         std::string <span class="keywordtype">id</span> = n.id();
<a name="l00162"></a>00162         std::string nodeColor = <span class="stringliteral">"black"</span>;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164         <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#7d348e0bace46affee89eda20b156134">isSgStatement</a>(n.getNode()))
<a name="l00165"></a>00165             nodeColor = <span class="stringliteral">"blue"</span>;
<a name="l00166"></a>00166         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#37e487b3acaac2a43a5cdd4c3c0f6e8a">isSgExpression</a>(n.getNode()))
<a name="l00167"></a>00167             nodeColor = <span class="stringliteral">"green"</span>;
<a name="l00168"></a>00168         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#3d55e45b923661b7efeeb664266d2527">isSgInitializedName</a>(n.getNode()))
<a name="l00169"></a>00169             nodeColor = <span class="stringliteral">"red"</span>;
<a name="l00170"></a>00170 
<a name="l00171"></a>00171         o &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">" [label=\""</span>  &lt;&lt; <a class="code" href="escape_8h.html#fe2eed2102b5e1df8cf454304111f5ca">escapeString</a>(n.toString()) &lt;&lt; <span class="stringliteral">"\", color=\""</span> &lt;&lt; nodeColor &lt;&lt;
<a name="l00172"></a>00172             <span class="stringliteral">"\", style=\""</span> &lt;&lt; (n.isInteresting()? <span class="stringliteral">"solid"</span> : <span class="stringliteral">"dotted"</span>) &lt;&lt; <span class="stringliteral">"\"];\n"</span>;
<a name="l00173"></a>00173     }
<a name="l00175"></a>00175     <span class="keyword">template</span> &lt; <span class="keyword">typename</span> EdgeT &gt;
<a name="l00176"></a><a class="code" href="namespaceVirtualCFG.html#c24d3f40a411d2e5c2bcb07a4c8ee612">00176</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespaceVirtualCFG.html#c24d3f40a411d2e5c2bcb07a4c8ee612">printEdge</a>(std::ostream &amp; o, <span class="keyword">const</span> EdgeT &amp; e, <span class="keywordtype">bool</span> isInEdge)
<a name="l00177"></a>00177     {
<a name="l00178"></a>00178         o &lt;&lt; e.source().id() &lt;&lt; <span class="stringliteral">" -&gt; "</span> &lt;&lt; e.target().id() &lt;&lt; <span class="stringliteral">" [label=\""</span> &lt;&lt; 
<a name="l00179"></a>00179           <a class="code" href="escape_8h.html#fe2eed2102b5e1df8cf454304111f5ca">escapeString</a>(e.toString()) &lt;&lt; <span class="stringliteral">"\", style=\""</span> &lt;&lt; (isInEdge ? <span class="stringliteral">"dotted"</span> : <span class="stringliteral">"solid"</span>) &lt;&lt; <span class="stringliteral">"\"];\n"</span>;
<a name="l00180"></a>00180     }
<a name="l00181"></a>00181 
<a name="l00183"></a>00183     <span class="keyword">template</span> &lt; <span class="keyword">typename</span> NodeT, <span class="keyword">typename</span> EdgeT &gt; 
<a name="l00184"></a>00184     <span class="keywordtype">void</span> <a class="code" href="namespaceVirtualCFG.html#6ac6f52ea23ae48b5d70ea76326f6769">printNodePlusEdges</a>(std::ostream &amp; o,NodeT n);
<a name="l00185"></a>00185 
<a name="l00186"></a>00186     <span class="comment">/* Internal template function handles the details*/</span>
<a name="l00187"></a>00187     <span class="keyword">template</span> &lt; <span class="keyword">typename</span> NodeT, <span class="keyword">typename</span> EdgeT ,<span class="keywordtype">bool</span> Debug&gt;
<a name="l00188"></a><a class="code" href="classVirtualCFG_1_1CfgToDotImpl.html#734cfdd0cfe25397230acc25ff3e3d26">00188</a>     <span class="keywordtype">void</span> CfgToDotImpl &lt; NodeT, EdgeT, Debug &gt;::processNodes(NodeT n)
<a name="l00189"></a>00189     {
<a name="l00190"></a>00190         ROSE_ASSERT(n.getNode());
<a name="l00191"></a>00191         std::pair &lt; typename std::multimap &lt; SgNode *, NodeT &gt;::const_iterator,
<a name="l00192"></a>00192             <span class="keyword">typename</span> std::multimap &lt; SgNode *, NodeT &gt;::const_iterator &gt; ip =
<a name="l00193"></a>00193             exploredNodes.equal_range(n.getNode());
<a name="l00194"></a>00194         <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::multimap &lt; SgNode *, NodeT &gt;::const_iterator i = ip.first;
<a name="l00195"></a>00195              i != ip.second; ++i)
<a name="l00196"></a>00196         {
<a name="l00197"></a>00197             <span class="keywordflow">if</span> (i-&gt;second == n)
<a name="l00198"></a>00198                 <span class="keywordflow">return</span>;
<a name="l00199"></a>00199         }
<a name="l00200"></a>00200         exploredNodes.insert(std::make_pair(n.getNode(), n));
<a name="l00201"></a>00201         printNodePlusEdges&lt;NodeT, EdgeT&gt;(o, n);
<a name="l00202"></a>00202         std::vector &lt; EdgeT &gt; <a class="code" href="namespaceStaticCFG.html#b6db4c881b581bbf831656db30daf0ce">outEdges</a> = n.outEdges();
<a name="l00203"></a>00203         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; outEdges.size(); ++i)
<a name="l00204"></a>00204         {
<a name="l00205"></a>00205             ROSE_ASSERT(outEdges[i].source() == n);
<a name="l00206"></a>00206             processNodes(outEdges[i].target());
<a name="l00207"></a>00207         }
<a name="l00208"></a>00208         std::vector &lt; EdgeT &gt; <a class="code" href="namespaceStaticCFG.html#ed5c146d0f80fb458f99e8cf7a700199">inEdges</a> = n.inEdges();
<a name="l00209"></a>00209         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; inEdges.size(); ++i)
<a name="l00210"></a>00210         {
<a name="l00211"></a>00211             ROSE_ASSERT(inEdges[i].target() == n);
<a name="l00212"></a>00212             processNodes(inEdges[i].source());
<a name="l00213"></a>00213         }
<a name="l00214"></a>00214     }
<a name="l00215"></a>00215 
<a name="l00217"></a>00217     <span class="keyword">template</span> &lt; <span class="keyword">typename</span> NodeT, <span class="keyword">typename</span> EdgeT &gt; 
<a name="l00218"></a><a class="code" href="namespaceVirtualCFG.html#6ac6f52ea23ae48b5d70ea76326f6769">00218</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceVirtualCFG.html#6ac6f52ea23ae48b5d70ea76326f6769">printNodePlusEdges</a>(std::ostream &amp; o, NodeT n)
<a name="l00219"></a>00219     {
<a name="l00220"></a>00220         <a class="code" href="namespaceVirtualCFG.html#0d0e4fda6f275a23ff128b825ffd2315">printNode</a>(o, n);
<a name="l00221"></a>00221         std::vector &lt; EdgeT &gt; <a class="code" href="namespaceStaticCFG.html#b6db4c881b581bbf831656db30daf0ce">outEdges</a> = n.outEdges();
<a name="l00222"></a>00222         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; outEdges.size(); ++i)
<a name="l00223"></a>00223         {
<a name="l00224"></a>00224             <a class="code" href="namespaceVirtualCFG.html#c24d3f40a411d2e5c2bcb07a4c8ee612">printEdge</a>(o, outEdges[i], <span class="keyword">false</span>);
<a name="l00225"></a>00225         }
<a name="l00226"></a>00226 <span class="preprocessor">        #ifdef DEBUG</span>
<a name="l00227"></a>00227 <span class="preprocessor"></span>        std::vector &lt; EdgeT &gt; <a class="code" href="namespaceStaticCFG.html#ed5c146d0f80fb458f99e8cf7a700199">inEdges</a> = n.inEdges();
<a name="l00228"></a>00228         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; inEdges.size(); ++i)
<a name="l00229"></a>00229         {
<a name="l00230"></a>00230             <a class="code" href="namespaceVirtualCFG.html#c24d3f40a411d2e5c2bcb07a4c8ee612">printEdge</a>(o, inEdges[i], <span class="keyword">true</span>);
<a name="l00231"></a>00231         }
<a name="l00232"></a>00232 <span class="preprocessor">        #endif</span>
<a name="l00233"></a>00233 <span class="preprocessor"></span>    }
<a name="l00234"></a>00234 <span class="preprocessor">#if 0</span>
<a name="l00235"></a>00235 <span class="preprocessor"></span>    <span class="keyword">template</span> &lt; <span class="keyword">typename</span> NodeT, <span class="keyword">typename</span> EdgeT &gt;
<a name="l00236"></a>00236         <span class="keywordtype">void</span> CfgToDotImpl &lt; NodeT, EdgeT &gt;::processNodes(<a class="code" href="classSgNode.html">SgNode</a> *)
<a name="l00237"></a>00237     {
<a name="l00238"></a>00238         <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::multimap &lt; SgNode *, NodeT &gt;::const_iterator it =
<a name="l00239"></a>00239              exploredNodes.begin(); it != exploredNodes.end(); ++it)
<a name="l00240"></a>00240         {
<a name="l00241"></a>00241             printNodePlusEdges &lt; NodeT, EdgeT &gt; (o, it-&gt;second);
<a name="l00242"></a>00242         }
<a name="l00243"></a>00243     }
<a name="l00244"></a>00244 <span class="preprocessor">#endif</span>
<a name="l00245"></a>00245 <span class="preprocessor"></span>
<a name="l00246"></a>00246     <span class="comment">/*User-level interface template function */</span>
<a name="l00247"></a>00247     <span class="keyword">template</span> &lt; <span class="keyword">typename</span> FilterFunction &gt; 
<a name="l00248"></a><a class="code" href="namespaceVirtualCFG.html#12127e3141705a1a5da33b6c5a178bc9">00248</a>     std::ostream &amp; <a class="code" href="namespaceVirtualCFG.html#8d44b01d1fea2890c11fb58ec43c46c3">cfgToDot</a>(std::ostream &amp; o, <span class="comment">/* output stream*/</span>
<a name="l00249"></a>00249                             std::string graphName, <span class="comment">/* graph name*/</span>
<a name="l00250"></a>00250                             FilteredCFGNode &lt; FilterFunction &gt; start) <span class="comment">/* start filtered CFG Node */</span>
<a name="l00251"></a>00251     {
<a name="l00252"></a>00252         o &lt;&lt; <span class="stringliteral">"digraph "</span> &lt;&lt; graphName &lt;&lt; <span class="stringliteral">" {\n"</span>;
<a name="l00253"></a>00253         CfgToDotImpl &lt; FilteredCFGNode &lt; FilterFunction &gt;,
<a name="l00254"></a>00254                        FilteredCFGEdge &lt; FilterFunction &gt; ,
<a name="l00255"></a>00255                        <span class="keyword">false</span>&gt;  impl(o);
<a name="l00256"></a>00256         impl.<a class="code" href="classVirtualCFG_1_1CfgToDotImpl.html#734cfdd0cfe25397230acc25ff3e3d26">processNodes</a>(start);
<a name="l00257"></a>00257         o &lt;&lt; <span class="stringliteral">"}\n"</span>;
<a name="l00258"></a>00258         <span class="keywordflow">return</span> o;
<a name="l00259"></a>00259     }
<a name="l00260"></a>00260 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
