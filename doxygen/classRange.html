<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: Range&lt; T &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>Range&lt; T &gt; Class Template Reference</h1><!-- doxytag: class="Range" --><code>#include &lt;<a class="el" href="rangemap_8h-source.html">rangemap.h</a>&gt;</code>
<p>
Inheritance diagram for Range&lt; T &gt;:<p><center><img src="classRange__inherit__graph.png" border="0" usemap="#Range_3_01T_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="Range_3_01T_01_4__inherit__map">
<area href="classRange.html" shape="rect" coords="93,103,232,129" alt="">
<area href="classBinaryAnalysis_1_1InstructionSemantics_1_1Interval.html" shape="rect" coords="5,183,320,209" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classRange-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T&gt;<br>
 class Range&lt; T &gt;</h3>

A contiguous range of values. 
<p>
Represents a contiguous range of <code>size</code> values beginning at <code>begin</code>, and defines relationships between two ranges. The ranges are designed such that they can represent unsigned values up to and including the maximum possible values for the data type. However, this means that a range that represents all possible values will have a <a class="el" href="classRange.html#d2aea45d89cade181ad89a7b75756bf9">size()</a> of zero due to overflow.<p>
Floating point ranges are also possible (types "float" or "double") but the behavior of some methods differs slightly from integers. For instance, an integer range containing a single value has size 1, but a floating point range with one value has size zero. The differences are noted in the documentation for the particular methods affected. 
<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00045">45</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::pair&lt; <a class="el" href="classRange.html">Range</a>,<br>
 <a class="el" href="classRange.html">Range</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#e3923ec69e4164340464742755686ade">Pair</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A pair of ranges.  <a href="#e3923ec69e4164340464742755686ade"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#6f65c35914aeb4d5238b6acddaf40680">Range</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an empty range.  <a href="#6f65c35914aeb4d5238b6acddaf40680"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#63708908faf1d6cd293bf6a83cf5a13a">Range</a> (const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> &amp;first)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new range of unit size.  <a href="#63708908faf1d6cd293bf6a83cf5a13a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#3930d5474001c881ca3ff922fb22501b">Range</a> (const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> &amp;first, const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> &amp;size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new range of specified size.  <a href="#3930d5474001c881ca3ff922fb22501b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Other&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRange.html#26d693e65a891d503864af9833c9e769">Range</a> (const Other &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new range from a different range.  <a href="#26d693e65a891d503864af9833c9e769"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#d2aea45d89cade181ad89a7b75756bf9">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of values represented by the range.  <a href="#d2aea45d89cade181ad89a7b75756bf9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRange.html#e3923ec69e4164340464742755686ade">Pair</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#646391dd948436f5a76bfe35bc3e4d4a">split_range_at</a> (const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> &amp;at) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split a range into two parts.  <a href="#646391dd948436f5a76bfe35bc3e4d4a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRange.html">Range</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#f0b6a42b8251e50ddae6c5fda9b45b68">join</a> (const <a class="el" href="classRange.html">Range</a> &amp;right) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Joins two adjacent ranges.  <a href="#f0b6a42b8251e50ddae6c5fda9b45b68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#26b4e8bd476025dc8569512b9d27474f">empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this range is empty.  <a href="#26b4e8bd476025dc8569512b9d27474f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#05a5b908926e64956b0db27d19b0bd5e">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a range empty.  <a href="#05a5b908926e64956b0db27d19b0bd5e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#37d3602cdcb1ecd4cb4fc37c49159c86">begins_with</a> (const <a class="el" href="classRange.html">Range</a> &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do both ranges begin at the same place?  <a href="#37d3602cdcb1ecd4cb4fc37c49159c86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#24e4a7012257d3657431a22ff672cde9">ends_with</a> (const <a class="el" href="classRange.html">Range</a> &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do both ranges end at the same place?  <a href="#24e4a7012257d3657431a22ff672cde9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#1889850aa02767afd89eeda5e099dfcb">begins_after</a> (const <a class="el" href="classRange.html">Range</a> &amp;x, bool strict=true) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does this range begin (strictly) after the beginning of another range?  <a href="#1889850aa02767afd89eeda5e099dfcb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#96a6b77e2c3654f657ddee8f3bf22f4a">begins_before</a> (const <a class="el" href="classRange.html">Range</a> &amp;x, bool strict=true) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does this range begin (strictly) before the beginning of another range?  <a href="#96a6b77e2c3654f657ddee8f3bf22f4a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#b65df2660fb35bfb5d4b6283c8452e7a">ends_after</a> (const <a class="el" href="classRange.html">Range</a> &amp;x, bool strict=true) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does this range end (strictly) after the end of another range?  <a href="#b65df2660fb35bfb5d4b6283c8452e7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#882df9672278b589e22af52f527b682b">ends_before</a> (const <a class="el" href="classRange.html">Range</a> &amp;x, bool strict=true) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does this range end (strictly) before the end of another range?  <a href="#882df9672278b589e22af52f527b682b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#7bfc28d2d8efb645ffc65dd563f3964f">contains</a> (const <a class="el" href="classRange.html">Range</a> &amp;x, bool strict=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does this range contain the argument range?  <a href="#7bfc28d2d8efb645ffc65dd563f3964f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#8c426188008ea033225675d1cbaa480a">contained_in</a> (const <a class="el" href="classRange.html">Range</a> &amp;x, bool strict=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this range contained in the argument range?  <a href="#8c426188008ea033225675d1cbaa480a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#a2fc742e1215cef629d0809dddb610b5">congruent</a> (const <a class="el" href="classRange.html">Range</a> &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Are two ranges equal?  <a href="#a2fc742e1215cef629d0809dddb610b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#b24ab29104e2e373037740a4db6e277a">left_of</a> (const <a class="el" href="classRange.html">Range</a> &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this range left of the argument range?  <a href="#b24ab29104e2e373037740a4db6e277a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#360e56377c954e8ef740e21a85802e04">right_of</a> (const <a class="el" href="classRange.html">Range</a> &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this range right of the argument range?  <a href="#360e56377c954e8ef740e21a85802e04"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#48c694476bfbf8d666b17b415861bee4">overlaps</a> (const <a class="el" href="classRange.html">Range</a> &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does this range overlap with the argument range?  <a href="#48c694476bfbf8d666b17b415861bee4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#cb61f7fc510bff1293aba91613b0064e">distinct</a> (const <a class="el" href="classRange.html">Range</a> &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this range non-overlapping with the argument range?  <a href="#cb61f7fc510bff1293aba91613b0064e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#c340e63ac03d84f59d6da8f4bdc56283">abuts_lt</a> (const <a class="el" href="classRange.html">Range</a> &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this range immediately left of the argument range?  <a href="#c340e63ac03d84f59d6da8f4bdc56283"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#5da759b78848ae631fc364daf94168cf">abuts_gt</a> (const <a class="el" href="classRange.html">Range</a> &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this range immediately right of the argument range?  <a href="#5da759b78848ae631fc364daf94168cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#e12b07fad4dbd61079f71f35c6358ae8">print</a> (std::ostream &amp;o) const </td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRange.html#e610bb824467cca65c3ba3256daa0952">print</a> (std::ostream &amp;o) const</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRange.html#c71b2a2aa7a367773c43a306c24a9395">Range</a> ()</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRange.html#b3019881ac0a1e947a1d453bf351d970">empty</a> () const</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRange.html#b79216fe7200b8925d382723803dcedc">clear</a> ()</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRange.html#d47b62d616f82eaeadb71f56d7c7477e">relaxed_first</a> () const</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRange.html#8dd3f30bfbbb4bb3b15b2f7f7926286e">size</a> () const</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRange.html#072550aa5e4b7c1a4f44cdb7ac4fb4d9">resize</a> (const double &amp;new_size)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRange.html#87ce16af8cb42113f836a9138c2724e0">relaxed_resize</a> (const double &amp;new_size)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classRange.html">Range</a>&lt; double &gt;::<a class="el" href="classRange.html#e3923ec69e4164340464742755686ade">Pair</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRange.html#dcda64c0a43f71af8f35cf4cc2c23ccb">split_range_at</a> (const double &amp;at) const</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRange.html#b5b7d2339f65f0d8ede796da9dba7579">minimum</a> ()</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRange.html#2c024e5c81a030e4cb11aafe4c6de057">maximum</a> ()</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRange.html#4527240a9d1137ddb64cf47af7da09eb">Range</a> ()</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRange.html#cea6017a8e909ee538630a2268fdd3fc">empty</a> () const</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRange.html#e3cefcc5a147db88ef9cf31fc62c3c07">clear</a> ()</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const float&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRange.html#8194c6291233da1ec49309b14fdf2390">relaxed_first</a> () const</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRange.html#fb591b941ae80199fd1bde42710a7290">size</a> () const</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRange.html#43e51060ca8fc64350b76996b13f61c4">resize</a> (const float &amp;new_size)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRange.html#3a03ef3aa481d9835fc63c7ab6117d78">relaxed_resize</a> (const float &amp;new_size)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classRange.html">Range</a>&lt; float &gt;::<a class="el" href="classRange.html#e3923ec69e4164340464742755686ade">Pair</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRange.html#e2f880787afa9241a2e4fc15c7568cdc">split_range_at</a> (const float &amp;at) const</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRange.html#26d9a5b09615559a56b2e0b3ee6e4762">minimum</a> ()</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRange.html#4e1ec23b102256d0379ba75388069548">maximum</a> ()</td></tr>

<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#130cadb6ba89a4777ca44fa1a6489f27">first</a> (const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> &amp;first)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accessor for the first value of a range.  <a href="#130cadb6ba89a4777ca44fa1a6489f27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#35290bda9c50740e6b6aaed75f2ac318">first</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accessor for the first value of a range.  <a href="#35290bda9c50740e6b6aaed75f2ac318"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#231785468b9c01898aeb366b404d9c9a">relaxed_first</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accessor for the first value of a range.  <a href="#231785468b9c01898aeb366b404d9c9a"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#347c0e723bcd929107dc0fffe31478f2">last</a> (const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> &amp;last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accessor for the last value of a range.  <a href="#347c0e723bcd929107dc0fffe31478f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#de602f1b1a62a82430772407f0af9479">last</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accessor for the last value of a range.  <a href="#de602f1b1a62a82430772407f0af9479"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#1aeb60291a7e70db553273ae3fa0fd3e">relaxed_last</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accessor for the last value of a range.  <a href="#1aeb60291a7e70db553273ae3fa0fd3e"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#6d27e17fadca79e6f3851c60ee50d12c">resize</a> (const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> &amp;new_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the range size by adjusting the maximum value.  <a href="#6d27e17fadca79e6f3851c60ee50d12c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#8f5c7d315a8304db49076bfea9a30a24">relaxed_resize</a> (const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> &amp;new_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the range size by adjusting the maximum value.  <a href="#8f5c7d315a8304db49076bfea9a30a24"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classRange.html">Range</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#785281ce194b217cf86c35a4d6f42c98">inin</a> (const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> &amp;v1, const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> &amp;v2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new range by giving the first (inclusive) and last value (inclusive).  <a href="#785281ce194b217cf86c35a4d6f42c98"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#01f96080d72cc93eb611df9032539f6c">minimum</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the minimum possible value represented by this range.  <a href="#01f96080d72cc93eb611df9032539f6c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#71ec8b29f10d748e6c9548e1b38c2d6f">maximum</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the maximum possible value represented by this range.  <a href="#71ec8b29f10d748e6c9548e1b38c2d6f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classRange.html">Range</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#6f18d23e23462756b3ee7d433414eaa9">all</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a range that covers all possible values.  <a href="#6f18d23e23462756b3ee7d433414eaa9"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#f299b59b3a30f29cda6c684e377ce75c">r_first</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">First value in range.  <a href="#f299b59b3a30f29cda6c684e377ce75c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#8a6e0ab604e9afadc469eb3cb1a65584">r_last</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Last value in range.  <a href="#8a6e0ab604e9afadc469eb3cb1a65584"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRange.html#3f65907313638288d6135021415e10d1">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classRange.html">Range</a> &amp;x)</td></tr>

</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="0110e09e84e56cb5b63bc5bde2a2a241"></a><!-- doxytag: member="Range::Value" ref="0110e09e84e56cb5b63bc5bde2a2a241" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classRange.html">Range</a>&lt; T &gt;::<a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00047">47</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="e3923ec69e4164340464742755686ade"></a><!-- doxytag: member="Range::Pair" ref="e3923ec69e4164340464742755686ade" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="classRange.html">Range</a>, <a class="el" href="classRange.html">Range</a>&gt; <a class="el" href="classRange.html">Range</a>&lt; T &gt;::<a class="el" href="classRange.html#e3923ec69e4164340464742755686ade">Pair</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A pair of ranges. 
<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00048">48</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="6f65c35914aeb4d5238b6acddaf40680"></a><!-- doxytag: member="Range::Range" ref="6f65c35914aeb4d5238b6acddaf40680" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRange.html">Range</a>&lt; T &gt;::<a class="el" href="classRange.html">Range</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an empty range. 
<p>
Ranges may have an empty size, but empty ranges will never appear inside a <a class="el" href="classRangeMap.html">RangeMap</a> object. The <code>begin</code> value of an empty range is meaningless. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00057">57</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="63708908faf1d6cd293bf6a83cf5a13a"></a><!-- doxytag: member="Range::Range" ref="63708908faf1d6cd293bf6a83cf5a13a" args="(const Value &amp;first)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRange.html">Range</a>&lt; T &gt;::<a class="el" href="classRange.html">Range</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>first</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new range of unit size. 
<p>
The new range contains only the specified value. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00061">61</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="3930d5474001c881ca3ff922fb22501b"></a><!-- doxytag: member="Range::Range" ref="3930d5474001c881ca3ff922fb22501b" args="(const Value &amp;first, const Value &amp;size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRange.html">Range</a>&lt; T &gt;::<a class="el" href="classRange.html">Range</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new range of specified size. 
<p>
If <code>size</code> is zero then an empty range is created. Note that a zero size is also returned for a range that contains all values, but this is due to overflow. Whether this is an integer range or a floating point range, if size is zero then the range is considered to be empty (but the <code>first</code> value is remembered). To create a floating point range with a single value, use the single-argument constructor. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00068">68</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="26d693e65a891d503864af9833c9e769"></a><!-- doxytag: member="Range::Range" ref="26d693e65a891d503864af9833c9e769" args="(const Other &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class Other&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRange.html">Range</a>&lt; T &gt;::<a class="el" href="classRange.html">Range</a>           </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new range from a different range. 
<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00080">80</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="c71b2a2aa7a367773c43a306c24a9395"></a><!-- doxytag: member="Range::Range" ref="c71b2a2aa7a367773c43a306c24a9395" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRange.html">Range</a>&lt; double &gt;::<a class="el" href="classRange.html">Range</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4527240a9d1137ddb64cf47af7da09eb"></a><!-- doxytag: member="Range::Range" ref="4527240a9d1137ddb64cf47af7da09eb" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRange.html">Range</a>&lt; float &gt;::<a class="el" href="classRange.html">Range</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="785281ce194b217cf86c35a4d6f42c98"></a><!-- doxytag: member="Range::inin" ref="785281ce194b217cf86c35a4d6f42c98" args="(const Value &amp;v1, const Value &amp;v2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRange.html">Range</a> <a class="el" href="classRange.html">Range</a>&lt; T &gt;::inin           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new range by giving the first (inclusive) and last value (inclusive). 
<p>
This is the only way to create a range that contains all values since the size of such a range overflows the range's Value type. If the two values are equal then the created range contains only that value; if the first value is larger than the second then the range is considered to be empty. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00087">87</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l00370">Range&lt; uint64_t &gt;::all()</a>, <a class="el" href="rangemap_8h-source.html#l01051">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::erase_ranges()</a>, <a class="el" href="MemoryMap_8C-source.html#l00599">MemoryMap::exists()</a>, <a class="el" href="rangemap_8h-source.html#l01233">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::invert_within()</a>, <a class="el" href="rangemap_8h-source.html#l00185">Range&lt; uint64_t &gt;::join()</a>, <a class="el" href="rangemap_8h-source.html#l00962">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::minmax()</a>, and <a class="el" href="MemoryMap_8C-source.html#l00811">MemoryMap::mprotect()</a>.
</div>
</div><p>
<a class="anchor" name="130cadb6ba89a4777ca44fa1a6489f27"></a><!-- doxytag: member="Range::first" ref="130cadb6ba89a4777ca44fa1a6489f27" args="(const Value &amp;first)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRange.html">Range</a>&lt; T &gt;::first           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>first</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accessor for the first value of a range. 
<p>
It does not make sense to ask for the first value of an empty range, and an assertion will fail if such a request is made. However, <a class="el" href="classRange.html#231785468b9c01898aeb366b404d9c9a">relaxed_first()</a> will return a value anyway. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00098">98</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l00343">Range&lt; uint64_t &gt;::abuts_lt()</a>, <a class="el" href="rangemap_8h-source.html#l00236">Range&lt; uint64_t &gt;::begins_after()</a>, <a class="el" href="rangemap_8h-source.html#l00245">Range&lt; uint64_t &gt;::begins_before()</a>, <a class="el" href="rangemap_8h-source.html#l00218">Range&lt; uint64_t &gt;::begins_with()</a>, <a class="el" href="MemoryMap_8C-source.html#l00349">MemoryMap::Segment::check()</a>, <a class="el" href="rangemap_8h-source.html#l00294">Range&lt; uint64_t &gt;::congruent()</a>, <a class="el" href="rangemap_8h-source.html#l00285">Range&lt; uint64_t &gt;::contained_in()</a>, <a class="el" href="rangemap_8h-source.html#l01133">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::contains()</a>, <a class="el" href="rangemap_8h-source.html#l00274">Range&lt; uint64_t &gt;::contains()</a>, <a class="el" href="rangemap_8h-source.html#l00991">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::erase()</a>, <a class="el" href="MemoryMap_8C-source.html#l00599">MemoryMap::exists()</a>, <a class="el" href="MemoryMap_8C-source.html#l00371">MemoryMap::Segment::get_buffer_offset()</a>, <a class="el" href="rangemap_8h-source.html#l00087">Range&lt; uint64_t &gt;::inin()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00028">BinaryAnalysis::InstructionSemantics::Interval::inin()</a>, <a class="el" href="rangemap_8h-source.html#l01062">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::insert()</a>, <a class="el" href="MemoryMap_8C-source.html#l00585">MemoryMap::insert()</a>, <a class="el" href="rangemap_8h-source.html#l01233">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::invert_within()</a>, <a class="el" href="rangemap_8h-source.html#l00304">Range&lt; uint64_t &gt;::left_of()</a>, <a class="el" href="MemoryMap_8C-source.html#l00480">MemoryMap::Segment::merge()</a>, <a class="el" href="MemoryMap_8C-source.html#l00811">MemoryMap::mprotect()</a>, <a class="el" href="Partitioner_8C-source.html#l02213">Partitioner::FindThunkTables::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l01730">Partitioner::FindDataPadding::operator()()</a>, <a class="el" href="rangemap_8h-source.html#l01118">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::overlaps()</a>, <a class="el" href="GenericString_8C-source.html#l00305">SgAsmGenericStrtab::reallocate()</a>, <a class="el" href="Disassembler_8C-source.html#l00617">Disassembler::search_next_address()</a>, <a class="el" href="Disassembler_8C-source.html#l00570">Disassembler::search_words()</a>, <a class="el" href="GenericFile_8C-source.html#l00737">SgAsmGenericFile::shift_extend()</a>, <a class="el" href="MemoryMap_8C-source.html#l00512">MemoryMap::Segment::split()</a>, <a class="el" href="rangemap_8h-source.html#l00582">RangeMapValue&lt; Range&lt; rose_addr_t &gt;, Partitioner::Function * &gt;::truncate()</a>, <a class="el" href="rangemap_8h-source.html#l00501">RangeMapVoid&lt; R &gt;::truncate()</a>, and <a class="el" href="MemoryMap_8C-source.html#l00473">MemoryMap::Segment::truncate()</a>.
</div>
</div><p>
<a class="anchor" name="35290bda9c50740e6b6aaed75f2ac318"></a><!-- doxytag: member="Range::first" ref="35290bda9c50740e6b6aaed75f2ac318" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> <a class="el" href="classRange.html">Range</a>&lt; T &gt;::first           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accessor for the first value of a range. 
<p>
It does not make sense to ask for the first value of an empty range, and an assertion will fail if such a request is made. However, <a class="el" href="classRange.html#231785468b9c01898aeb366b404d9c9a">relaxed_first()</a> will return a value anyway. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00101">101</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l00353">Range&lt; uint64_t &gt;::abuts_gt()</a>, <a class="el" href="rangemap_8h-source.html#l00236">Range&lt; uint64_t &gt;::begins_after()</a>, <a class="el" href="rangemap_8h-source.html#l00245">Range&lt; uint64_t &gt;::begins_before()</a>, <a class="el" href="rangemap_8h-source.html#l00218">Range&lt; uint64_t &gt;::begins_with()</a>, <a class="el" href="rangemap_8h-source.html#l00294">Range&lt; uint64_t &gt;::congruent()</a>, <a class="el" href="rangemap_8h-source.html#l00285">Range&lt; uint64_t &gt;::contained_in()</a>, <a class="el" href="rangemap_8h-source.html#l00274">Range&lt; uint64_t &gt;::contains()</a>, <a class="el" href="rangemap_8h-source.html#l00185">Range&lt; uint64_t &gt;::join()</a>, <a class="el" href="rangemap_8h-source.html#l00374">Range&lt; uint64_t &gt;::print()</a>, <a class="el" href="rangemap_8h-source.html#l00105">Range&lt; uint64_t &gt;::relaxed_first()</a>, <a class="el" href="rangemap_8h-source.html#l00314">Range&lt; uint64_t &gt;::right_of()</a>, and <a class="el" href="rangemap_8h-source.html#l00174">Range&lt; uint64_t &gt;::split_range_at()</a>.
</div>
</div><p>
<a class="anchor" name="231785468b9c01898aeb366b404d9c9a"></a><!-- doxytag: member="Range::relaxed_first" ref="231785468b9c01898aeb366b404d9c9a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> <a class="el" href="classRange.html">Range</a>&lt; T &gt;::relaxed_first           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accessor for the first value of a range. 
<p>
It does not make sense to ask for the first value of an empty range, and an assertion will fail if such a request is made. However, <a class="el" href="classRange.html#231785468b9c01898aeb366b404d9c9a">relaxed_first()</a> will return a value anyway. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00105">105</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="ExtentMap_8C-source.html#l00018">ExtentMap::category()</a>, <a class="el" href="rangemap_8h-source.html#l00124">Range&lt; uint64_t &gt;::relaxed_last()</a>, <a class="el" href="rangemap_8h-source.html#l00161">Range&lt; uint64_t &gt;::relaxed_resize()</a>, and <a class="el" href="GenericFile_8C-source.html#l00737">SgAsmGenericFile::shift_extend()</a>.
</div>
</div><p>
<a class="anchor" name="347c0e723bcd929107dc0fffe31478f2"></a><!-- doxytag: member="Range::last" ref="347c0e723bcd929107dc0fffe31478f2" args="(const Value &amp;last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRange.html">Range</a>&lt; T &gt;::last           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>last</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accessor for the last value of a range. 
<p>
It does not make sense to ask for the last value of an empty range, and an assertion will fail if such a request is made. However, <a class="el" href="classRange.html#1aeb60291a7e70db553273ae3fa0fd3e">relaxed_last()</a> will return a value anyway. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00117">117</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l00353">Range&lt; uint64_t &gt;::abuts_gt()</a>, <a class="el" href="rangemap_8h-source.html#l00294">Range&lt; uint64_t &gt;::congruent()</a>, <a class="el" href="rangemap_8h-source.html#l00285">Range&lt; uint64_t &gt;::contained_in()</a>, <a class="el" href="rangemap_8h-source.html#l00274">Range&lt; uint64_t &gt;::contains()</a>, <a class="el" href="rangemap_8h-source.html#l00254">Range&lt; uint64_t &gt;::ends_after()</a>, <a class="el" href="rangemap_8h-source.html#l00263">Range&lt; uint64_t &gt;::ends_before()</a>, <a class="el" href="rangemap_8h-source.html#l00227">Range&lt; uint64_t &gt;::ends_with()</a>, <a class="el" href="rangemap_8h-source.html#l00991">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::erase()</a>, <a class="el" href="MemoryMap_8C-source.html#l00599">MemoryMap::exists()</a>, <a class="el" href="rangemap_8h-source.html#l00087">Range&lt; uint64_t &gt;::inin()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00028">BinaryAnalysis::InstructionSemantics::Interval::inin()</a>, <a class="el" href="rangemap_8h-source.html#l01062">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::insert()</a>, <a class="el" href="rangemap_8h-source.html#l01233">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::invert_within()</a>, <a class="el" href="MemoryMap_8C-source.html#l00480">MemoryMap::Segment::merge()</a>, <a class="el" href="MemoryMap_8C-source.html#l00811">MemoryMap::mprotect()</a>, <a class="el" href="rangemap_8h-source.html#l00732">RangeMap&lt; R, T &gt;::RangeCompare::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l02213">Partitioner::FindThunkTables::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l01730">Partitioner::FindDataPadding::operator()()</a>, <a class="el" href="MemoryMap_8C-source.html#l00708">MemoryMap::read1()</a>, <a class="el" href="rangemap_8h-source.html#l00314">Range&lt; uint64_t &gt;::right_of()</a>, <a class="el" href="Disassembler_8C-source.html#l00617">Disassembler::search_next_address()</a>, <a class="el" href="Disassembler_8C-source.html#l00570">Disassembler::search_words()</a>, <a class="el" href="rangemap_8h-source.html#l00582">RangeMapValue&lt; Range&lt; rose_addr_t &gt;, Partitioner::Function * &gt;::truncate()</a>, <a class="el" href="rangemap_8h-source.html#l00501">RangeMapVoid&lt; R &gt;::truncate()</a>, and <a class="el" href="MemoryMap_8C-source.html#l00473">MemoryMap::Segment::truncate()</a>.
</div>
</div><p>
<a class="anchor" name="de602f1b1a62a82430772407f0af9479"></a><!-- doxytag: member="Range::last" ref="de602f1b1a62a82430772407f0af9479" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> <a class="el" href="classRange.html">Range</a>&lt; T &gt;::last           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accessor for the last value of a range. 
<p>
It does not make sense to ask for the last value of an empty range, and an assertion will fail if such a request is made. However, <a class="el" href="classRange.html#1aeb60291a7e70db553273ae3fa0fd3e">relaxed_last()</a> will return a value anyway. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00120">120</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l00343">Range&lt; uint64_t &gt;::abuts_lt()</a>, <a class="el" href="rangemap_8h-source.html#l00294">Range&lt; uint64_t &gt;::congruent()</a>, <a class="el" href="rangemap_8h-source.html#l00285">Range&lt; uint64_t &gt;::contained_in()</a>, <a class="el" href="rangemap_8h-source.html#l00274">Range&lt; uint64_t &gt;::contains()</a>, <a class="el" href="rangemap_8h-source.html#l00254">Range&lt; uint64_t &gt;::ends_after()</a>, <a class="el" href="rangemap_8h-source.html#l00263">Range&lt; uint64_t &gt;::ends_before()</a>, <a class="el" href="rangemap_8h-source.html#l00227">Range&lt; uint64_t &gt;::ends_with()</a>, <a class="el" href="rangemap_8h-source.html#l00304">Range&lt; uint64_t &gt;::left_of()</a>, <a class="el" href="rangemap_8h-source.html#l00374">Range&lt; uint64_t &gt;::print()</a>, <a class="el" href="rangemap_8h-source.html#l00124">Range&lt; uint64_t &gt;::relaxed_last()</a>, and <a class="el" href="rangemap_8h-source.html#l00174">Range&lt; uint64_t &gt;::split_range_at()</a>.
</div>
</div><p>
<a class="anchor" name="1aeb60291a7e70db553273ae3fa0fd3e"></a><!-- doxytag: member="Range::relaxed_last" ref="1aeb60291a7e70db553273ae3fa0fd3e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> <a class="el" href="classRange.html">Range</a>&lt; T &gt;::relaxed_last           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accessor for the last value of a range. 
<p>
It does not make sense to ask for the last value of an empty range, and an assertion will fail if such a request is made. However, <a class="el" href="classRange.html#1aeb60291a7e70db553273ae3fa0fd3e">relaxed_last()</a> will return a value anyway. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00124">124</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="d2aea45d89cade181ad89a7b75756bf9"></a><!-- doxytag: member="Range::size" ref="d2aea45d89cade181ad89a7b75756bf9" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> <a class="el" href="classRange.html">Range</a>&lt; T &gt;::size           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of values represented by the range. 
<p>
Note that if the range contains all possible values then the returned size may be zero due to overflow, in which case the <a class="el" href="classRange.html#26b4e8bd476025dc8569512b9d27474f">empty()</a> method should also be called to make the determination.<p>
Floating point range sizes are simply the last value minus the first value. Therefore, a singleton floating point range will return a size of zero, while a singleton integer range will return a size of one. This is actualy consistent behavior if you think of an integer value N as the floating point range [N,N+1), where N is included in the range but N+1 is not. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00137">137</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="ExtentMap_8C-source.html#l00018">ExtentMap::category()</a>, <a class="el" href="MemoryMap_8C-source.html#l00349">MemoryMap::Segment::check()</a>, <a class="el" href="Partitioner_8C-source.html#l01730">Partitioner::FindDataPadding::operator()()</a>, <a class="el" href="GenericString_8C-source.html#l00305">SgAsmGenericStrtab::reallocate()</a>, and <a class="el" href="GenericFile_8C-source.html#l00737">SgAsmGenericFile::shift_extend()</a>.
</div>
</div><p>
<a class="anchor" name="6d27e17fadca79e6f3851c60ee50d12c"></a><!-- doxytag: member="Range::resize" ref="6d27e17fadca79e6f3851c60ee50d12c" args="(const Value &amp;new_size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRange.html">Range</a>&lt; T &gt;::resize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>new_size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the range size by adjusting the maximum value. 
<p>
It is an error to change the size of a range from zero to non-zero, but the <a class="el" href="classRange.html#8f5c7d315a8304db49076bfea9a30a24">relaxed_resize()</a> is available for that purpose.<p>
Setting the size to zero causes different behavior for integer ranges than it does for floating point ranges. For integer ranges, setting the size to zero clears the range (makes it empty); for floating point ranges, setting the size to zero causes the range to contain only the starting value. Floating point ranges can be cleared by setting the new size to a negative value. The <a class="el" href="classRange.html#05a5b908926e64956b0db27d19b0bd5e">clear()</a> method should be favored over <a class="el" href="classRange.html#6d27e17fadca79e6f3851c60ee50d12c">resize()</a> for making a range empty. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00152">152</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l01730">Partitioner::FindDataPadding::operator()()</a>.
</div>
</div><p>
<a class="anchor" name="8f5c7d315a8304db49076bfea9a30a24"></a><!-- doxytag: member="Range::relaxed_resize" ref="8f5c7d315a8304db49076bfea9a30a24" args="(const Value &amp;new_size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRange.html">Range</a>&lt; T &gt;::relaxed_resize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>new_size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the range size by adjusting the maximum value. 
<p>
It is an error to change the size of a range from zero to non-zero, but the <a class="el" href="classRange.html#8f5c7d315a8304db49076bfea9a30a24">relaxed_resize()</a> is available for that purpose.<p>
Setting the size to zero causes different behavior for integer ranges than it does for floating point ranges. For integer ranges, setting the size to zero clears the range (makes it empty); for floating point ranges, setting the size to zero causes the range to contain only the starting value. Floating point ranges can be cleared by setting the new size to a negative value. The <a class="el" href="classRange.html#05a5b908926e64956b0db27d19b0bd5e">clear()</a> method should be favored over <a class="el" href="classRange.html#6d27e17fadca79e6f3851c60ee50d12c">resize()</a> for making a range empty. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00161">161</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="646391dd948436f5a76bfe35bc3e4d4a"></a><!-- doxytag: member="Range::split_range_at" ref="646391dd948436f5a76bfe35bc3e4d4a" args="(const Value &amp;at) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRange.html#e3923ec69e4164340464742755686ade">Pair</a> <a class="el" href="classRange.html">Range</a>&lt; T &gt;::split_range_at           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>at</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Split a range into two parts. 
<p>
Returns a pair of adjacent ranges such that <code>at</code> is the first value of the second returned range. The split point must be such that neither range is empty. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00174">174</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l01133">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::contains()</a>.
</div>
</div><p>
<a class="anchor" name="f0b6a42b8251e50ddae6c5fda9b45b68"></a><!-- doxytag: member="Range::join" ref="f0b6a42b8251e50ddae6c5fda9b45b68" args="(const Range &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRange.html">Range</a> <a class="el" href="classRange.html">Range</a>&lt; T &gt;::join           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>right</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Joins two adjacent ranges. 
<p>
This range must be the left range, and the argument is the right range. They must be adjacent without overlapping. If one of the ranges is empty, then the return value is the other range (which might also be empty). 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00185">185</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l01062">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::insert()</a>.
</div>
</div><p>
<a class="anchor" name="26b4e8bd476025dc8569512b9d27474f"></a><!-- doxytag: member="Range::empty" ref="26b4e8bd476025dc8569512b9d27474f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::empty           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this range is empty. 
<p>
Note that many of the range comparison methods have special cases for empty ranges. Note that due to overflow, the <a class="el" href="classRange.html#d2aea45d89cade181ad89a7b75756bf9">size()</a> method may return zero for integer ranges if this range contains all possible values. It follows, then that the expressions "empty()" and "0==size()" are not always equal. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00197">197</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l00353">Range&lt; uint64_t &gt;::abuts_gt()</a>, <a class="el" href="rangemap_8h-source.html#l00343">Range&lt; uint64_t &gt;::abuts_lt()</a>, <a class="el" href="rangemap_8h-source.html#l00236">Range&lt; uint64_t &gt;::begins_after()</a>, <a class="el" href="rangemap_8h-source.html#l00245">Range&lt; uint64_t &gt;::begins_before()</a>, <a class="el" href="rangemap_8h-source.html#l00218">Range&lt; uint64_t &gt;::begins_with()</a>, <a class="el" href="rangemap_8h-source.html#l01268">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::check()</a>, <a class="el" href="MemoryMap_8C-source.html#l00349">MemoryMap::Segment::check()</a>, <a class="el" href="rangemap_8h-source.html#l00203">Range&lt; uint64_t &gt;::clear()</a>, <a class="el" href="rangemap_8h-source.html#l00294">Range&lt; uint64_t &gt;::congruent()</a>, <a class="el" href="rangemap_8h-source.html#l00285">Range&lt; uint64_t &gt;::contained_in()</a>, <a class="el" href="rangemap_8h-source.html#l01133">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::contains()</a>, <a class="el" href="rangemap_8h-source.html#l00274">Range&lt; uint64_t &gt;::contains()</a>, <a class="el" href="rangemap_8h-source.html#l00333">Range&lt; uint64_t &gt;::distinct()</a>, <a class="el" href="rangemap_8h-source.html#l00254">Range&lt; uint64_t &gt;::ends_after()</a>, <a class="el" href="rangemap_8h-source.html#l00263">Range&lt; uint64_t &gt;::ends_before()</a>, <a class="el" href="rangemap_8h-source.html#l00227">Range&lt; uint64_t &gt;::ends_with()</a>, <a class="el" href="rangemap_8h-source.html#l00991">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::erase()</a>, <a class="el" href="MemoryMap_8C-source.html#l00599">MemoryMap::exists()</a>, <a class="el" href="rangemap_8h-source.html#l00101">Range&lt; uint64_t &gt;::first()</a>, <a class="el" href="rangemap_8h-source.html#l01062">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::insert()</a>, <a class="el" href="rangemap_8h-source.html#l01233">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::invert_within()</a>, <a class="el" href="rangemap_8h-source.html#l00185">Range&lt; uint64_t &gt;::join()</a>, <a class="el" href="rangemap_8h-source.html#l00120">Range&lt; uint64_t &gt;::last()</a>, <a class="el" href="rangemap_8h-source.html#l00304">Range&lt; uint64_t &gt;::left_of()</a>, <a class="el" href="rangemap_8h-source.html#l00587">RangeMapValue&lt; Range&lt; rose_addr_t &gt;, Partitioner::Function * &gt;::merge()</a>, <a class="el" href="rangemap_8h-source.html#l00519">RangeMapVoid&lt; R &gt;::merge()</a>, <a class="el" href="MemoryMap_8C-source.html#l00480">MemoryMap::Segment::merge()</a>, <a class="el" href="MemoryMap_8C-source.html#l00811">MemoryMap::mprotect()</a>, <a class="el" href="Partitioner_8C-source.html#l02213">Partitioner::FindThunkTables::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l01730">Partitioner::FindDataPadding::operator()()</a>, <a class="el" href="rangemap_8h-source.html#l01118">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::overlaps()</a>, <a class="el" href="rangemap_8h-source.html#l00323">Range&lt; uint64_t &gt;::overlaps()</a>, <a class="el" href="rangemap_8h-source.html#l00374">Range&lt; uint64_t &gt;::print()</a>, <a class="el" href="rangemap_8h-source.html#l00068">Range&lt; uint64_t &gt;::Range()</a>, <a class="el" href="rangemap_8h-source.html#l00105">Range&lt; uint64_t &gt;::relaxed_first()</a>, <a class="el" href="rangemap_8h-source.html#l00124">Range&lt; uint64_t &gt;::relaxed_last()</a>, <a class="el" href="rangemap_8h-source.html#l00161">Range&lt; uint64_t &gt;::relaxed_resize()</a>, <a class="el" href="rangemap_8h-source.html#l00577">RangeMapValue&lt; Range&lt; rose_addr_t &gt;, Partitioner::Function * &gt;::removing()</a>, <a class="el" href="rangemap_8h-source.html#l00494">RangeMapVoid&lt; R &gt;::removing()</a>, <a class="el" href="MemoryMap_8C-source.html#l00466">MemoryMap::Segment::removing()</a>, <a class="el" href="rangemap_8h-source.html#l00152">Range&lt; uint64_t &gt;::resize()</a>, <a class="el" href="rangemap_8h-source.html#l00314">Range&lt; uint64_t &gt;::right_of()</a>, <a class="el" href="rangemap_8h-source.html#l01252">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::select_overlapping_ranges()</a>, <a class="el" href="rangemap_8h-source.html#l00137">Range&lt; uint64_t &gt;::size()</a>, and <a class="el" href="rangemap_8h-source.html#l00174">Range&lt; uint64_t &gt;::split_range_at()</a>.
</div>
</div><p>
<a class="anchor" name="05a5b908926e64956b0db27d19b0bd5e"></a><!-- doxytag: member="Range::clear" ref="05a5b908926e64956b0db27d19b0bd5e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRange.html">Range</a>&lt; T &gt;::clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make a range empty. 
<p>
An empty range is one in which r_first is greater than r_last. We make special provisions here so that <a class="el" href="classRange.html#231785468b9c01898aeb366b404d9c9a">relaxed_first()</a> will continue to return the same value as it did before the range was set to empty. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00203">203</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l00068">Range&lt; uint64_t &gt;::Range()</a>, <a class="el" href="rangemap_8h-source.html#l00161">Range&lt; uint64_t &gt;::relaxed_resize()</a>, <a class="el" href="rangemap_8h-source.html#l00152">Range&lt; uint64_t &gt;::resize()</a>, and <a class="el" href="GenericFile_8C-source.html#l00737">SgAsmGenericFile::shift_extend()</a>.
</div>
</div><p>
<a class="anchor" name="37d3602cdcb1ecd4cb4fc37c49159c86"></a><!-- doxytag: member="Range::begins_with" ref="37d3602cdcb1ecd4cb4fc37c49159c86" args="(const Range &amp;x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::begins_with           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Do both ranges begin at the same place? 
<p>
An empty range never begins with any other range, including other empty ranges. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00218">218</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l01268">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::check()</a>.
</div>
</div><p>
<a class="anchor" name="24e4a7012257d3657431a22ff672cde9"></a><!-- doxytag: member="Range::ends_with" ref="24e4a7012257d3657431a22ff672cde9" args="(const Range &amp;x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::ends_with           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Do both ranges end at the same place? 
<p>
An empty range never ends with any other range, including other empty ranges. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00227">227</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l01268">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::check()</a>.
</div>
</div><p>
<a class="anchor" name="1889850aa02767afd89eeda5e099dfcb"></a><!-- doxytag: member="Range::begins_after" ref="1889850aa02767afd89eeda5e099dfcb" args="(const Range &amp;x, bool strict=true) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::begins_after           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>strict</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Does this range begin (strictly) after the beginning of another range? 
<p>
An empty range never begins after any other range, including other empty ranges. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00236">236</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l01268">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::check()</a>, and <a class="el" href="rangemap_8h-source.html#l00991">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::erase()</a>.
</div>
</div><p>
<a class="anchor" name="96a6b77e2c3654f657ddee8f3bf22f4a"></a><!-- doxytag: member="Range::begins_before" ref="96a6b77e2c3654f657ddee8f3bf22f4a" args="(const Range &amp;x, bool strict=true) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::begins_before           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>strict</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Does this range begin (strictly) before the beginning of another range? 
<p>
An empty range never begins before any other range, including other empty ranges. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00245">245</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l01133">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::contains()</a>, and <a class="el" href="MemoryMap_8C-source.html#l00599">MemoryMap::exists()</a>.
</div>
</div><p>
<a class="anchor" name="b65df2660fb35bfb5d4b6283c8452e7a"></a><!-- doxytag: member="Range::ends_after" ref="b65df2660fb35bfb5d4b6283c8452e7a" args="(const Range &amp;x, bool strict=true) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::ends_after           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>strict</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Does this range end (strictly) after the end of another range? 
<p>
An empty range never ends after any other range, including other empty ranges. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00254">254</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="882df9672278b589e22af52f527b682b"></a><!-- doxytag: member="Range::ends_before" ref="882df9672278b589e22af52f527b682b" args="(const Range &amp;x, bool strict=true) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::ends_before           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>strict</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Does this range end (strictly) before the end of another range? 
<p>
An empty range never ends before any other range, including other empty ranges. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00263">263</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l01133">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::contains()</a>, and <a class="el" href="rangemap_8h-source.html#l00991">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::erase()</a>.
</div>
</div><p>
<a class="anchor" name="7bfc28d2d8efb645ffc65dd563f3964f"></a><!-- doxytag: member="Range::contains" ref="7bfc28d2d8efb645ffc65dd563f3964f" args="(const Range &amp;x, bool strict=false) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::contains           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>strict</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Does this range contain the argument range? 
<p>
The argument is contained in this range if the argument starts at or after the start of this range and ends at or before the end of this range. If <code>strict</code> is true, then the comparisons do not include equality. An empty range does not contain any other range, including other empty ranges. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00274">274</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l00991">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::erase()</a>, <a class="el" href="MemoryMap_8C-source.html#l00371">MemoryMap::Segment::get_buffer_offset()</a>, <a class="el" href="MemoryMap_8C-source.html#l00811">MemoryMap::mprotect()</a>, <a class="el" href="MemoryMap_8C-source.html#l00708">MemoryMap::read1()</a>, <a class="el" href="rangemap_8h-source.html#l00528">RangeMapVoid&lt; R &gt;::split()</a>, <a class="el" href="Partitioner_8h-source.html#l00665">Partitioner::DataRangeMapValue::split()</a>, <a class="el" href="Partitioner_8h-source.html#l00642">Partitioner::FunctionRangeMapValue::split()</a>, and <a class="el" href="MemoryMap_8C-source.html#l00761">MemoryMap::write1()</a>.
</div>
</div><p>
<a class="anchor" name="8c426188008ea033225675d1cbaa480a"></a><!-- doxytag: member="Range::contained_in" ref="8c426188008ea033225675d1cbaa480a" args="(const Range &amp;x, bool strict=false) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::contained_in           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>strict</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is this range contained in the argument range? 
<p>
This range is contained in the argument range if this range starts at or after the start of the argument and ends at or before the end of the argument. If <code>strict</code> is true, then the comparisons do not include equality. An empty range does not contain any other range, including other empty ranges. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00285">285</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l00991">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::erase()</a>.
</div>
</div><p>
<a class="anchor" name="a2fc742e1215cef629d0809dddb610b5"></a><!-- doxytag: member="Range::congruent" ref="a2fc742e1215cef629d0809dddb610b5" args="(const Range &amp;x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::congruent           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Are two ranges equal? 
<p>
They are equal if the start and end at the same place or if they are both empty. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00294">294</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="b24ab29104e2e373037740a4db6e277a"></a><!-- doxytag: member="Range::left_of" ref="b24ab29104e2e373037740a4db6e277a" args="(const Range &amp;x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::left_of           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is this range left of the argument range? 
<p>
This range is left of the argument range if this range ends before the start of the argument. They may adjoin, but must not overlap. An empty range is never left of any other range, including other empty ranges. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00304">304</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l00991">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::erase()</a>, <a class="el" href="rangemap_8h-source.html#l01233">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::invert_within()</a>, <a class="el" href="rangemap_8h-source.html#l00323">Range&lt; uint64_t &gt;::overlaps()</a>, and <a class="el" href="rangemap_8h-source.html#l01252">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::select_overlapping_ranges()</a>.
</div>
</div><p>
<a class="anchor" name="360e56377c954e8ef740e21a85802e04"></a><!-- doxytag: member="Range::right_of" ref="360e56377c954e8ef740e21a85802e04" args="(const Range &amp;x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::right_of           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is this range right of the argument range? 
<p>
This range is right of the argument range if this range starts after the end of the argument range. They may adjoin, but must not overlap. An empty range is never right of any other range, including other empty ranges. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00314">314</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l00323">Range&lt; uint64_t &gt;::overlaps()</a>.
</div>
</div><p>
<a class="anchor" name="48c694476bfbf8d666b17b415861bee4"></a><!-- doxytag: member="Range::overlaps" ref="48c694476bfbf8d666b17b415861bee4" args="(const Range &amp;x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::overlaps           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Does this range overlap with the argument range? 
<p>
An empty range does not overlap with any other rance, including other empty ranges. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00323">323</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l01133">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::contains()</a>, <a class="el" href="rangemap_8h-source.html#l00333">Range&lt; uint64_t &gt;::distinct()</a>, <a class="el" href="rangemap_8h-source.html#l01062">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::insert()</a>, <a class="el" href="MemoryMap_8C-source.html#l00585">MemoryMap::insert()</a>, <a class="el" href="rangemap_8h-source.html#l01118">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::overlaps()</a>, and <a class="el" href="rangemap_8h-source.html#l01252">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::select_overlapping_ranges()</a>.
</div>
</div><p>
<a class="anchor" name="cb61f7fc510bff1293aba91613b0064e"></a><!-- doxytag: member="Range::distinct" ref="cb61f7fc510bff1293aba91613b0064e" args="(const Range &amp;x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::distinct           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is this range non-overlapping with the argument range? 
<p>
In other words, do the two ranges represent distinct sets of values? An empty range is always distinct from all other ranges (including other empty ranges). 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00333">333</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="c340e63ac03d84f59d6da8f4bdc56283"></a><!-- doxytag: member="Range::abuts_lt" ref="c340e63ac03d84f59d6da8f4bdc56283" args="(const Range &amp;x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::abuts_lt           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is this range immediately left of the argument range? 
<p>
Returns true if this range ends at the beginning of the argument, with no overlap and no space between them. An empty range does not abut any other range, including other empty ranges. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00343">343</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l01062">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::insert()</a>, <a class="el" href="rangemap_8h-source.html#l00185">Range&lt; uint64_t &gt;::join()</a>, and <a class="el" href="MemoryMap_8C-source.html#l00480">MemoryMap::Segment::merge()</a>.
</div>
</div><p>
<a class="anchor" name="5da759b78848ae631fc364daf94168cf"></a><!-- doxytag: member="Range::abuts_gt" ref="5da759b78848ae631fc364daf94168cf" args="(const Range &amp;x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; T &gt;::abuts_gt           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is this range immediately right of the argument range? 
<p>
Returns true if this range begins at the end of the argument, with no overlap and no space between them. An empty range does not abut any other range, including other empty ranges. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00353">353</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l01062">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::insert()</a>, and <a class="el" href="MemoryMap_8C-source.html#l00480">MemoryMap::Segment::merge()</a>.
</div>
</div><p>
<a class="anchor" name="01f96080d72cc93eb611df9032539f6c"></a><!-- doxytag: member="Range::minimum" ref="01f96080d72cc93eb611df9032539f6c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> <a class="el" href="classRange.html">Range</a>&lt; T &gt;::minimum           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the minimum possible value represented by this range. 
<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00360">360</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l00370">Range&lt; uint64_t &gt;::all()</a>, <a class="el" href="rangemap_8h-source.html#l01062">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::insert()</a>, <a class="el" href="Partitioner_8C-source.html#l02176">Partitioner::FindInterPadFunctions::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l02036">Partitioner::FindFunctionFragments::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l01820">Partitioner::FindData::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l01730">Partitioner::FindDataPadding::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l01697">Partitioner::scan_interfunc_bytes()</a>, and <a class="el" href="Partitioner_8C-source.html#l01664">Partitioner::scan_intrafunc_bytes()</a>.
</div>
</div><p>
<a class="anchor" name="71ec8b29f10d748e6c9548e1b38c2d6f"></a><!-- doxytag: member="Range::maximum" ref="71ec8b29f10d748e6c9548e1b38c2d6f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> <a class="el" href="classRange.html">Range</a>&lt; T &gt;::maximum           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the maximum possible value represented by this range. 
<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00365">365</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l00370">Range&lt; uint64_t &gt;::all()</a>, <a class="el" href="rangemap_8h-source.html#l00203">Range&lt; uint64_t &gt;::clear()</a>, <a class="el" href="rangemap_8h-source.html#l01062">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::insert()</a>, <a class="el" href="Partitioner_8C-source.html#l02176">Partitioner::FindInterPadFunctions::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l02036">Partitioner::FindFunctionFragments::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l01730">Partitioner::FindDataPadding::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l01697">Partitioner::scan_interfunc_bytes()</a>, and <a class="el" href="Partitioner_8C-source.html#l01664">Partitioner::scan_intrafunc_bytes()</a>.
</div>
</div><p>
<a class="anchor" name="6f18d23e23462756b3ee7d433414eaa9"></a><!-- doxytag: member="Range::all" ref="6f18d23e23462756b3ee7d433414eaa9" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRange.html">Range</a> <a class="el" href="classRange.html">Range</a>&lt; T &gt;::all           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a range that covers all possible values. 
<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00370">370</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l01226">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::invert()</a>.
</div>
</div><p>
<a class="anchor" name="e12b07fad4dbd61079f71f35c6358ae8"></a><!-- doxytag: member="Range::print" ref="e12b07fad4dbd61079f71f35c6358ae8" args="(std::ostream &amp;o) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRange.html">Range</a>&lt; T &gt;::print           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>o</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Reimplemented in <a class="el" href="classBinaryAnalysis_1_1InstructionSemantics_1_1Interval.html#864fabbd0c78a4ad5a125d448f0d022a">BinaryAnalysis::InstructionSemantics::Interval</a>.
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00374">374</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="e610bb824467cca65c3ba3256daa0952"></a><!-- doxytag: member="Range::print" ref="e610bb824467cca65c3ba3256daa0952" args="(std::ostream &amp;o) const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRange.html">Range</a>&lt; <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> &gt;::print           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>o</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b3019881ac0a1e947a1d453bf351d970"></a><!-- doxytag: member="Range::empty" ref="b3019881ac0a1e947a1d453bf351d970" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; double &gt;::empty           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b79216fe7200b8925d382723803dcedc"></a><!-- doxytag: member="Range::clear" ref="b79216fe7200b8925d382723803dcedc" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRange.html">Range</a>&lt; double &gt;::clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="d47b62d616f82eaeadb71f56d7c7477e"></a><!-- doxytag: member="Range::relaxed_first" ref="d47b62d616f82eaeadb71f56d7c7477e" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="classRange.html">Range</a>&lt; double &gt;::relaxed_first           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8dd3f30bfbbb4bb3b15b2f7f7926286e"></a><!-- doxytag: member="Range::size" ref="8dd3f30bfbbb4bb3b15b2f7f7926286e" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classRange.html">Range</a>&lt; double &gt;::size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="072550aa5e4b7c1a4f44cdb7ac4fb4d9"></a><!-- doxytag: member="Range::resize" ref="072550aa5e4b7c1a4f44cdb7ac4fb4d9" args="(const double &amp;new_size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRange.html">Range</a>&lt; double &gt;::resize           </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&nbsp;</td>
          <td class="paramname"> <em>new_size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="87ce16af8cb42113f836a9138c2724e0"></a><!-- doxytag: member="Range::relaxed_resize" ref="87ce16af8cb42113f836a9138c2724e0" args="(const double &amp;new_size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRange.html">Range</a>&lt; double &gt;::relaxed_resize           </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&nbsp;</td>
          <td class="paramname"> <em>new_size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="dcda64c0a43f71af8f35cf4cc2c23ccb"></a><!-- doxytag: member="Range::split_range_at" ref="dcda64c0a43f71af8f35cf4cc2c23ccb" args="(const double &amp;at) const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRange.html">Range</a>&lt; double &gt;::<a class="el" href="classRange.html#e3923ec69e4164340464742755686ade">Pair</a> <a class="el" href="classRange.html">Range</a>&lt; double &gt;::split_range_at           </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&nbsp;</td>
          <td class="paramname"> <em>at</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b5b7d2339f65f0d8ede796da9dba7579"></a><!-- doxytag: member="Range::minimum" ref="b5b7d2339f65f0d8ede796da9dba7579" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classRange.html">Range</a>&lt; double &gt;::minimum           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2c024e5c81a030e4cb11aafe4c6de057"></a><!-- doxytag: member="Range::maximum" ref="2c024e5c81a030e4cb11aafe4c6de057" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classRange.html">Range</a>&lt; double &gt;::maximum           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="cea6017a8e909ee538630a2268fdd3fc"></a><!-- doxytag: member="Range::empty" ref="cea6017a8e909ee538630a2268fdd3fc" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRange.html">Range</a>&lt; float &gt;::empty           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e3cefcc5a147db88ef9cf31fc62c3c07"></a><!-- doxytag: member="Range::clear" ref="e3cefcc5a147db88ef9cf31fc62c3c07" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRange.html">Range</a>&lt; float &gt;::clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8194c6291233da1ec49309b14fdf2390"></a><!-- doxytag: member="Range::relaxed_first" ref="8194c6291233da1ec49309b14fdf2390" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const float <a class="el" href="classRange.html">Range</a>&lt; float &gt;::relaxed_first           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="fb591b941ae80199fd1bde42710a7290"></a><!-- doxytag: member="Range::size" ref="fb591b941ae80199fd1bde42710a7290" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classRange.html">Range</a>&lt; float &gt;::size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="43e51060ca8fc64350b76996b13f61c4"></a><!-- doxytag: member="Range::resize" ref="43e51060ca8fc64350b76996b13f61c4" args="(const float &amp;new_size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRange.html">Range</a>&lt; float &gt;::resize           </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&nbsp;</td>
          <td class="paramname"> <em>new_size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3a03ef3aa481d9835fc63c7ab6117d78"></a><!-- doxytag: member="Range::relaxed_resize" ref="3a03ef3aa481d9835fc63c7ab6117d78" args="(const float &amp;new_size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRange.html">Range</a>&lt; float &gt;::relaxed_resize           </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&nbsp;</td>
          <td class="paramname"> <em>new_size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e2f880787afa9241a2e4fc15c7568cdc"></a><!-- doxytag: member="Range::split_range_at" ref="e2f880787afa9241a2e4fc15c7568cdc" args="(const float &amp;at) const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRange.html">Range</a>&lt; float &gt;::<a class="el" href="classRange.html#e3923ec69e4164340464742755686ade">Pair</a> <a class="el" href="classRange.html">Range</a>&lt; float &gt;::split_range_at           </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&nbsp;</td>
          <td class="paramname"> <em>at</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="26d9a5b09615559a56b2e0b3ee6e4762"></a><!-- doxytag: member="Range::minimum" ref="26d9a5b09615559a56b2e0b3ee6e4762" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classRange.html">Range</a>&lt; float &gt;::minimum           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4e1ec23b102256d0379ba75388069548"></a><!-- doxytag: member="Range::maximum" ref="4e1ec23b102256d0379ba75388069548" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classRange.html">Range</a>&lt; float &gt;::maximum           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="3f65907313638288d6135021415e10d1"></a><!-- doxytag: member="Range::operator&lt;&lt;" ref="3f65907313638288d6135021415e10d1" args="(std::ostream &amp;o, const Range &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00384">384</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="f299b59b3a30f29cda6c684e377ce75c"></a><!-- doxytag: member="Range::r_first" ref="f299b59b3a30f29cda6c684e377ce75c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> <a class="el" href="classRange.html">Range</a>&lt; T &gt;::<a class="el" href="classRange.html#f299b59b3a30f29cda6c684e377ce75c">r_first</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
First value in range. 
<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00051">51</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l00203">Range&lt; uint64_t &gt;::clear()</a>, <a class="el" href="rangemap_8h-source.html#l00197">Range&lt; uint64_t &gt;::empty()</a>, <a class="el" href="rangemap_8h-source.html#l00098">Range&lt; uint64_t &gt;::first()</a>, <a class="el" href="rangemap_8h-source.html#l00105">Range&lt; uint64_t &gt;::relaxed_first()</a>, <a class="el" href="rangemap_8h-source.html#l00161">Range&lt; uint64_t &gt;::relaxed_resize()</a>, <a class="el" href="rangemap_8h-source.html#l00152">Range&lt; uint64_t &gt;::resize()</a>, and <a class="el" href="rangemap_8h-source.html#l00137">Range&lt; uint64_t &gt;::size()</a>.
</div>
</div><p>
<a class="anchor" name="8a6e0ab604e9afadc469eb3cb1a65584"></a><!-- doxytag: member="Range::r_last" ref="8a6e0ab604e9afadc469eb3cb1a65584" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Value</a> <a class="el" href="classRange.html">Range</a>&lt; T &gt;::<a class="el" href="classRange.html#8a6e0ab604e9afadc469eb3cb1a65584">r_last</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Last value in range. 
<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00052">52</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l00203">Range&lt; uint64_t &gt;::clear()</a>, <a class="el" href="rangemap_8h-source.html#l00197">Range&lt; uint64_t &gt;::empty()</a>, <a class="el" href="rangemap_8h-source.html#l00117">Range&lt; uint64_t &gt;::last()</a>, <a class="el" href="rangemap_8h-source.html#l00068">Range&lt; uint64_t &gt;::Range()</a>, <a class="el" href="rangemap_8h-source.html#l00105">Range&lt; uint64_t &gt;::relaxed_first()</a>, <a class="el" href="rangemap_8h-source.html#l00161">Range&lt; uint64_t &gt;::relaxed_resize()</a>, <a class="el" href="rangemap_8h-source.html#l00152">Range&lt; uint64_t &gt;::resize()</a>, and <a class="el" href="rangemap_8h-source.html#l00137">Range&lt; uint64_t &gt;::size()</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="rangemap_8h-source.html">rangemap.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
