<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: sageInterface.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>sageInterface.h File Reference</h1>
<p>
<code>#include &quot;sage3basic.hhh&quot;</code><br>
<code>#include &lt;stdint.h&gt;</code><br>
<code>#include &lt;utility&gt;</code><br>
<code>#include &quot;rewrite.h&quot;</code><br>
<code>#include &quot;astUnparseAttribute.h&quot;</code><br>
<code>#include &lt;set&gt;</code><br>
<code>#include &quot;LivenessAnalysis.h&quot;</code><br>
<code>#include &quot;abstract_handle.h&quot;</code><br>
<code>#include &quot;<a class="el" href="ClassHierarchyGraph_8h-source.html">ClassHierarchyGraph.h</a>&quot;</code><br>

<p>
Include dependency graph for sageInterface.h:<p><center><img src="sageInterface_8h__incl.png" border="0" usemap="#sageInterface.h_map" alt=""></center>
<map name="sageInterface.h_map">
<area href="ClassHierarchyGraph_8h.html" shape="rect" coords="177,411,345,437" alt="">
</map>

<p>
This graph shows which files directly or indirectly include this file:<p><center><img src="sageInterface_8h__dep__incl.png" border="0" usemap="#sageInterface.hdep_map" alt=""></center>
<map name="sageInterface.hdep_map">
<area href="sage3_8h.html" shape="rect" coords="200,5,272,32" alt="">
<area href="sage3basic_8h.html" shape="rect" coords="183,56,289,83" alt="">
<area href="sageFunctors_8h.html" shape="rect" coords="176,107,296,133" alt="">
</map>

<p>
<a href="sageInterface_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html">SageInterface</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSageInterface_1_1UniqueNameAttribute.html">SageInterface::UniqueNameAttribute</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A persistent attribute to represent a unique name for an expression.  <a href="classSageInterface_1_1UniqueNameAttribute.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSageInterface_1_1hash__nodeptr.html">SageInterface::hash_nodeptr</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSageInterface_1_1OutputLocalSymbolTables.html">SageInterface::OutputLocalSymbolTables</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSageInterface_1_1StatementGenerator.html">SageInterface::StatementGenerator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface for creating a statement whose computation writes its answer into a given variable.  <a href="classSageInterface_1_1StatementGenerator.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Symbol tables</h2></td></tr>
<tr><td colspan="2">utility functions for symbol tables <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#10bd491911b4d8d441c2b0f8d8542f50">SageInterface::lookupVariableSymbolInParentScopes</a> (const <a class="el" href="classSgName.html">SgName</a> &amp;name, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgSymbol.html">SgSymbol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#fbbf691f4ff947b83e93db1e9622a5a3">SageInterface::lookupSymbolInParentScopes</a> (const <a class="el" href="classSgName.html">SgName</a> &amp;name, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a symbol in current and ancestor scopes for a given variable name, starting from top of ScopeStack if currentscope is not given or NULL.  <a href="#fbbf691f4ff947b83e93db1e9622a5a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgFunctionSymbol.html">SgFunctionSymbol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c149a8d976bc90e89fed4d9d6cd3f34a">SageInterface::lookupFunctionSymbolInParentScopes</a> (const <a class="el" href="classSgName.html">SgName</a> &amp;functionName, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">look up the first matched function symbol in parent scopes given only a function name, starting from top of ScopeStack if currentscope is not given or NULL  <a href="#c149a8d976bc90e89fed4d9d6cd3f34a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgFunctionSymbol.html">SgFunctionSymbol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#6e0623b84a44ff5e85dd6334e199f418">SageInterface::lookupFunctionSymbolInParentScopes</a> (const <a class="el" href="classSgName.html">SgName</a> &amp;functionName, const <a class="el" href="classSgType.html">SgType</a> *t, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">look up function symbol in parent scopes given both name and function type, starting from top of ScopeStack if currentscope is not given or NULL  <a href="#6e0623b84a44ff5e85dd6334e199f418"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgClassSymbol.html">SgClassSymbol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4d0c71bada31301e6bd1a569965cdad6">SageInterface::lookupClassSymbolInParentScopes</a> (const <a class="el" href="classSgName.html">SgName</a> &amp;name, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgTypedefSymbol.html">SgTypedefSymbol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#f2272608021e9538be091a4f23ecfc6b">SageInterface::lookupTypedefSymbolInParentScopes</a> (const <a class="el" href="classSgName.html">SgName</a> &amp;name, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgTemplateSymbol.html">SgTemplateSymbol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#15bf8b9e0d05ab2441dfab12f4e0b8af">SageInterface::lookupTemplateSymbolInParentScopes</a> (const <a class="el" href="classSgName.html">SgName</a> &amp;name, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgEnumSymbol.html">SgEnumSymbol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c5944800817c61bf404f7948d0e9431c">SageInterface::lookupEnumSymbolInParentScopes</a> (const <a class="el" href="classSgName.html">SgName</a> &amp;name, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgNamespaceSymbol.html">SgNamespaceSymbol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#9f057986db266f3d6cc83fd8edbab917">SageInterface::lookupNamespaceSymbolInParentScopes</a> (const <a class="el" href="classSgName.html">SgName</a> &amp;name, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#1bbf335d0e6ee069e94e73a62660b8da">SageInterface::set_name</a> (<a class="el" href="classSgInitializedName.html">SgInitializedName</a> *initializedNameNode, <a class="el" href="classSgName.html">SgName</a> new_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set_name of symbol in symbol table.  <a href="#1bbf335d0e6ee069e94e73a62660b8da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a3fbb86d0df5900f41a2b63a81b4355e">SageInterface::outputGlobalFunctionTypeSymbolTable</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output function type symbols in global function type symbol table.  <a href="#a3fbb86d0df5900f41a2b63a81b4355e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ab1b30cc17b041079ccd395c0f48d9a4">SageInterface::outputLocalSymbolTables</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output the local symbol tables.  <a href="#ab1b30cc17b041079ccd395c0f48d9a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#f77c4adbf8e70c2904f5c95f80aa32b4">SageInterface::rebuildSymbolTable</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Regenerate the symbol table.  <a href="#f77c4adbf8e70c2904f5c95f80aa32b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#72448c95af84d803ee677e49650cec12">SageInterface::clearUnusedVariableSymbols</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear those variable symbols (together with initialized names) which are not referenced by any variable references or declarations.  <a href="#72448c95af84d803ee677e49650cec12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#8dd3faa8aa1e1a39859ed2f4046db4c2">SageInterface::fixupReferencesToSymbols</a> (const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *this_scope, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *copy_scope, <a class="el" href="classSgCopyHelp.html">SgCopyHelp</a> &amp;help)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All the symbol table references in the copied AST need to be reset after rebuilding the copied scope's symbol table.  <a href="#8dd3faa8aa1e1a39859ed2f4046db4c2"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Stringify</h2></td></tr>
<tr><td colspan="2">Generate a useful string (name) to describe a <a class="el" href="classSgNode.html">SgNode</a> <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d8c38176c2d0e4d2bc851e70007902f9">SageInterface::get_name</a> (const <a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a useful name to describe the <a class="el" href="classSgNode.html">SgNode</a>.  <a href="#d8c38176c2d0e4d2bc851e70007902f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#fcdc4bf692f0a99cf6c9f8dedd5dba0c">SageInterface::get_name</a> (const <a class="el" href="classSgStatement.html">SgStatement</a> *stmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a useful name to describe the declaration.  <a href="#fcdc4bf692f0a99cf6c9f8dedd5dba0c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e041006d7194c3dcf1771905a310551f">SageInterface::get_name</a> (const <a class="el" href="classSgExpression.html">SgExpression</a> *expr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a useful name to describe the expression.  <a href="#e041006d7194c3dcf1771905a310551f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4a139b6ee7628669382055c4e5cc4091">SageInterface::get_name</a> (const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *declaration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a useful name to describe the declaration.  <a href="#4a139b6ee7628669382055c4e5cc4091"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#94a6b6ad81a1b4fe641ba34a6fa287fb">SageInterface::get_name</a> (const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a useful name to describe the scope.  <a href="#94a6b6ad81a1b4fe641ba34a6fa287fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#215e9d46d141268e3b4841b6a4d105a1">SageInterface::get_name</a> (const <a class="el" href="classSgSymbol.html">SgSymbol</a> *symbol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a useful name to describe the <a class="el" href="classSgSymbol.html">SgSymbol</a>.  <a href="#215e9d46d141268e3b4841b6a4d105a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a3dbafd1030e3d2995e938b98c9e8a34">SageInterface::get_name</a> (const <a class="el" href="classSgType.html">SgType</a> *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a useful name to describe the <a class="el" href="classSgType.html">SgType</a>.  <a href="#a3dbafd1030e3d2995e938b98c9e8a34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e5abb9bb7920c00cd4331354fc470049">SageInterface::get_name</a> (const <a class="el" href="classSgSupport.html">SgSupport</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a useful name to describe the <a class="el" href="classSgSupport.html">SgSupport</a> IR node.  <a href="#e5abb9bb7920c00cd4331354fc470049"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#1fb6f2b9749473b0efcbb19bfd8d019b">SageInterface::get_name</a> (const <a class="el" href="classSgLocatedNodeSupport.html">SgLocatedNodeSupport</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a useful name to describe the <a class="el" href="classSgLocatedNodeSupport.html">SgLocatedNodeSupport</a> IR node.  <a href="#1fb6f2b9749473b0efcbb19bfd8d019b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#571cc2dc63fcd697dcab3e43feb87dc2">SageInterface::get_name</a> (const <a class="el" href="classSgC__PreprocessorDirectiveStatement.html">SgC_PreprocessorDirectiveStatement</a> *directive)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a useful name to describe the <a class="el" href="classSgC__PreprocessorDirectiveStatement.html">SgC_PreprocessorDirectiveStatement</a> IR node.  <a href="#571cc2dc63fcd697dcab3e43feb87dc2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e80c3edde132b58538fe96a143a2f83d">SageInterface::get_name</a> (const <a class="el" href="classSgToken.html">SgToken</a> *token)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a useful name to describe the <a class="el" href="classSgToken.html">SgToken</a> IR node.  <a href="#e80c3edde132b58538fe96a143a2f83d"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Class utilities</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgMemberFunctionDeclaration.html">SgMemberFunctionDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b5161d0357f41bada1b0528284efc66e">SageInterface::getDefaultDestructor</a> (<a class="el" href="classSgClassDeclaration.html">SgClassDeclaration</a> *classDeclaration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the default destructor from the class declaration.  <a href="#b5161d0357f41bada1b0528284efc66e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgMemberFunctionDeclaration.html">SgMemberFunctionDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#44d0f9a4a27a11112c175c114165c5bc">SageInterface::getDefaultConstructor</a> (<a class="el" href="classSgClassDeclaration.html">SgClassDeclaration</a> *classDeclaration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the default constructor from the class declaration.  <a href="#44d0f9a4a27a11112c175c114165c5bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d800514689507e16297989c211bd1d46">SageInterface::templateDefinitionIsInClass</a> (<a class="el" href="classSgTemplateInstantiationMemberFunctionDecl.html">SgTemplateInstantiationMemberFunctionDecl</a> *memberFunctionDeclaration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if template definition is in the class, false if outside of class.  <a href="#d800514689507e16297989c211bd1d46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgTemplateInstantiationMemberFunctionDecl.html">SgTemplateInstantiationMemberFunctionDecl</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#05cf8a0be6e549502d66723997d7a1d6">SageInterface::buildForwardFunctionDeclaration</a> (<a class="el" href="classSgTemplateInstantiationMemberFunctionDecl.html">SgTemplateInstantiationMemberFunctionDecl</a> *memberFunctionInstantiation)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a non-defining (forward) declaration from a defining function declaration.  <a href="#05cf8a0be6e549502d66723997d7a1d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#2bd323ff608813e595cf631ec1f6c620">SageInterface::isStructDeclaration</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a <a class="el" href="classSgNode.html">SgNode</a> is a declaration for a structure.  <a href="#2bd323ff608813e595cf631ec1f6c620"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Misc.</h2></td></tr>
<tr><td colspan="2">Not sure the classifications right now <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#9cfd9f42a896937c833851eeba3b1228">SageInterface::extractPragmaKeyword</a> (const <a class="el" href="classSgPragmaDeclaration.html">SgPragmaDeclaration</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp".  <a href="#9cfd9f42a896937c833851eeba3b1228"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#cd2e56dc7614b724718c8c8bbd75f5d1">SageInterface::isOmpStatement</a> (<a class="el" href="classSgNode.html">SgNode</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a node is SgOmp*Statement.  <a href="#cd2e56dc7614b724718c8c8bbd75f5d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#1a75ef1b6fc0708f3a2791d5198bdf19">SageInterface::isOverloaded</a> (<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *functionDeclaration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if function is overloaded.  <a href="#1a75ef1b6fc0708f3a2791d5198bdf19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#041d0ad3164d050320ad7181d0aacd64">SageInterface::annotateExpressionsWithUniqueNames</a> (<a class="el" href="classSgProject.html">SgProject</a> *<a class="el" href="namespacecfgUtils.html#ce4abf2beca5826144d69d3a0283050f">project</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate unique names for expressions and attach the names as persistent attributes ("UniqueNameAttribute").  <a href="#041d0ad3164d050320ad7181d0aacd64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4d55ef6edf8eebf6577aca1e1fe0de6e">SageInterface::isMain</a> (const <a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a <a class="el" href="classSgNode.html">SgNode</a> is a main() function declaration.  <a href="#4d55ef6edf8eebf6577aca1e1fe0de6e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c088828a4143b77fa9e3b11ba6b40a0e">SageInterface::generateUniqueName</a> (const <a class="el" href="classSgNode.html">SgNode</a> *node, bool ignoreDifferenceBetweenDefiningAndNondefiningDeclarations)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate unique name from C and C++ constructs. The name may contain space.  <a href="#c088828a4143b77fa9e3b11ba6b40a0e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#6401801005892a56b2f337d0ce501eb7">SageInterface::generateUniqueVariableName</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope, std::string baseName=&quot;temp&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a name that is unique in the current scope and any parent and children scopes.  <a href="#6401801005892a56b2f337d0ce501eb7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#322a03f1d6ed3713ed72abcedeb8a51d">SageInterface::declarationPositionString</a> (const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *declaration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a unique string from the source file position information.  <a href="#322a03f1d6ed3713ed72abcedeb8a51d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#90ebac1577ef2a31448937b60c3c09d1">SageInterface::generateProjectName</a> (const <a class="el" href="classSgProject.html">SgProject</a> *<a class="el" href="namespacecfgUtils.html#ce4abf2beca5826144d69d3a0283050f">project</a>, bool supressSuffix=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Added mechanism to generate project name from list of file names.  <a href="#90ebac1577ef2a31448937b60c3c09d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#92c54986b591707f089705085a7b962e">SageInterface::getDeclarationOfNamedFunction</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *func)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a <a class="el" href="classSgExpression.html">SgExpression</a> that represents a named function (or bound member function), return the mentioned function.  <a href="#92c54986b591707f089705085a7b962e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ba53ce71d9c07fc4912d08bfa14aa6c0">SageInterface::forallMaskExpression</a> (<a class="el" href="classSgForAllStatement.html">SgForAllStatement</a> *stmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the mask expression from the header of a <a class="el" href="classSgForAllStatement.html">SgForAllStatement</a>.  <a href="#ba53ce71d9c07fc4912d08bfa14aa6c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#bebf0874533c9176d3dbe203c110d2b6">SageInterface::addVarRefExpFromArrayDimInfo</a> (<a class="el" href="classSgNode.html">SgNode</a> *astNode, Rose_STL_Container&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt; &amp;NodeList_t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find all <a class="el" href="classSgPntrArrRefExp.html">SgPntrArrRefExp</a> under astNode, then add <a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> (if any) of SgPntrArrRefExp's dim_info into NodeList_t.  <a href="#bebf0874533c9176d3dbe203c110d2b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#2e2c09133334d2db043980411ad65a7c">SageInterface::clearMangledNameCache</a> (<a class="el" href="classSgGlobal.html">SgGlobal</a> *globalScope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Support for faster mangled name generation (caching avoids recomputation).  <a href="#2e2c09133334d2db043980411ad65a7c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#939718eb45951e2200eeb23bc903ee40">SageInterface::resetMangledNameCache</a> (<a class="el" href="classSgGlobal.html">SgGlobal</a> *globalScope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp".  <a href="#939718eb45951e2200eeb23bc903ee40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#fec2eead58f0854713f92c73989787ea">SageInterface::getMangledNameFromCache</a> (<a class="el" href="classSgNode.html">SgNode</a> *astNode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp".  <a href="#fec2eead58f0854713f92c73989787ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#cd868f709a4ba10cc7e5367b51033e21">SageInterface::addMangledNameToCache</a> (<a class="el" href="classSgNode.html">SgNode</a> *astNode, const std::string &amp;mangledName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp".  <a href="#cd868f709a4ba10cc7e5367b51033e21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ea729c0291d71f4b0f34192c4e42f974">SageInterface::getNonInstantiatonDeclarationForClass</a> (<a class="el" href="classSgTemplateInstantiationMemberFunctionDecl.html">SgTemplateInstantiationMemberFunctionDecl</a> *memberFunctionInstantiation)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp".  <a href="#ea729c0291d71f4b0f34192c4e42f974"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#f7e85358ccd85bb87b78259de8f4d549">SageInterface::setBaseTypeDefiningDeclaration</a> (<a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *var_decl, <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *base_decl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a better version for SgVariableDeclaration::set_baseTypeDefininingDeclaration(), handling all side effects automatically Used to have a struct declaration embedded into a variable declaration  <a href="#f7e85358ccd85bb87b78259de8f4d549"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#2ad11c9bbccfc5c65ebd5a1e63df8457">SageInterface::declarationPreceedsDefinition</a> (<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *nonDefiningDeclaration, <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *definingDeclaration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a defining declaration comes before of after the non-defining declaration.  <a href="#2ad11c9bbccfc5c65ebd5a1e63df8457"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a7b0761edf91357c7d6b1820f18f95d0">SageInterface::functionCallExpressionPreceedsDeclarationWhichAssociatesScope</a> (<a class="el" href="classSgFunctionCallExp.html">SgFunctionCallExp</a> *functionCall)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp".  <a href="#a7b0761edf91357c7d6b1820f18f95d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#771883836d967b53906ffba1966f6f2c">SageInterface::astIntersection</a> (<a class="el" href="classSgNode.html">SgNode</a> *original, <a class="el" href="classSgNode.html">SgNode</a> *copy, <a class="el" href="classSgCopyHelp.html">SgCopyHelp</a> *help=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the intersection set for two ASTs.  <a href="#771883836d967b53906ffba1966f6f2c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#9fcc4b40da8ae6daa5f50df366350861">SageInterface::deepCopyNode</a> (const <a class="el" href="classSgNode.html">SgNode</a> *subtree)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deep copy an arbitrary subtree.  <a href="#9fcc4b40da8ae6daa5f50df366350861"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename NodeType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">NodeType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#3a89292adcceeeda5391c5f67857251d">SageInterface::deepCopy</a> (const NodeType *subtree)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A template function for deep copying a subtree. It is also used to create deepcopy functions with specialized parameter and return types. e.g SgExpression* <a class="el" href="namespaceSageInterface.html#b716e78a9af76b8ace53782ce98938f8">copyExpression(SgExpression* e)</a>;.  <a href="#3a89292adcceeeda5391c5f67857251d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b716e78a9af76b8ace53782ce98938f8">SageInterface::copyExpression</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deep copy an expression.  <a href="#b716e78a9af76b8ace53782ce98938f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ccb4140d5bad66ff517c5171a8e23790">SageInterface::copyStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deep copy a statement.  <a href="#ccb4140d5bad66ff517c5171a8e23790"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#2e4a80143b2c610c87c8ec6c8ae1a4f6">SageInterface::getFirstVarSym</a> (<a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *decl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the variable symbol for the first initialized name of a declaration stmt.  <a href="#2e4a80143b2c610c87c8ec6c8ae1a4f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgInitializedName.html">SgInitializedName</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#13d0ecca52ba48d86e137017800ace85">SageInterface::getFirstInitializedName</a> (<a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *decl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the first initialized name of a declaration statement.  <a href="#13d0ecca52ba48d86e137017800ace85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#f2a313ede41c7b731cb61c355d1c55e0">SageInterface::myRemoveStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A special purpose statement removal function, originally from inlinerSupport.h, Need Jeremiah's attention to refine it. Please don't use it for now.  <a href="#f2a313ede41c7b731cb61c355d1c55e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#8b764061b63990cb9a90a2e8fba1cd9e">SageInterface::isConstantTrue</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp".  <a href="#8b764061b63990cb9a90a2e8fba1cd9e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#aabc058b0a469b383db6dae596659b1e">SageInterface::isConstantFalse</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp".  <a href="#aabc058b0a469b383db6dae596659b1e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#eb16538d6d56b5b2ef2960c7f8c1ed9c">SageInterface::isCallToParticularFunction</a> (<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *decl, <a class="el" href="classSgExpression.html">SgExpression</a> *e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp".  <a href="#eb16538d6d56b5b2ef2960c7f8c1ed9c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#6fc323c375048618a3713f4f02d9d0fb">SageInterface::isCallToParticularFunction</a> (const std::string &amp;qualifiedName, size_t arity, <a class="el" href="classSgExpression.html">SgExpression</a> *e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp".  <a href="#6fc323c375048618a3713f4f02d9d0fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#345dac5d75b2039d24e0a4f9820d7b7c">SageInterface::isStatic</a> (<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *stmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a declaration has a "static' modifier.  <a href="#345dac5d75b2039d24e0a4f9820d7b7c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#7133b3ef7857297f8fe4cbbdc0757259">SageInterface::setStatic</a> (<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *stmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a declaration as static.  <a href="#7133b3ef7857297f8fe4cbbdc0757259"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#9ccb65716fdfa5b17abb793584b76a40">SageInterface::isExtern</a> (<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *stmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a declaration has an "extern" modifier.  <a href="#9ccb65716fdfa5b17abb793584b76a40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#5a4e98c40873b96844edc32c7b2604e7">SageInterface::setExtern</a> (<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *stmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a declaration as extern.  <a href="#5a4e98c40873b96844edc32c7b2604e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#746a92a94fcc6190e015e74aa1c911e8">SageInterface::isAssignmentStatement</a> (<a class="el" href="classSgNode.html">SgNode</a> *_s, <a class="el" href="classSgExpression.html">SgExpression</a> **lhs=NULL, <a class="el" href="classSgExpression.html">SgExpression</a> **rhs=NULL, bool *readlhs=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a <a class="el" href="classSgNode.html">SgNode</a> _s is an assignment statement (any of =,+=,-=,&amp;=,/=, ^=, etc).  <a href="#746a92a94fcc6190e015e74aa1c911e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgInitializedName.html">SgInitializedName</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#549a580089fff36d4184a4341cc08525">SageInterface::convertRefToInitializedName</a> (<a class="el" href="classSgNode.html">SgNode</a> *current)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classVariable.html">Variable</a> references can be introduced by SgVarRef, <a class="el" href="classSgPntrArrRefExp.html">SgPntrArrRefExp</a>, <a class="el" href="classSgInitializedName.html">SgInitializedName</a>, SgMemberFunctionRef etc. This function will convert them all to a top level <a class="el" href="classSgInitializedName.html">SgInitializedName</a>.  <a href="#549a580089fff36d4184a4341cc08525"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e96f2137bb71d4484508452e554e1ae6">SageInterface::getSgNodeFromAbstractHandleString</a> (const std::string &amp;input_string)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a matching <a class="el" href="classSgNode.html">SgNode</a> from an abstract handle string.  <a href="#e96f2137bb71d4484508452e554e1ae6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#db3bd3c96f7ee7b03abc333cf2d14d96">SageInterface::dumpInfo</a> (<a class="el" href="classSgNode.html">SgNode</a> *node, std::string desc=&quot;&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dump information about a <a class="el" href="classSgNode.html">SgNode</a> for debugging.  <a href="#db3bd3c96f7ee7b03abc333cf2d14d96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#74263a872d82b1b9f570120aad9205a8">SageInterface::sortSgNodeListBasedOnAppearanceOrderInSource</a> (const std::vector&lt; <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> * &gt; &amp;nodevec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reorder a list of declaration statements based on their appearance order in source files.  <a href="#74263a872d82b1b9f570120aad9205a8"></a><br></td></tr>
<tr><td colspan="2"><br><h2>AST properties</h2></td></tr>
<tr><td colspan="2">version, language properties of current AST. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#566a32e0c20fd3f5622ea88542e15fc1">SageInterface::is_C_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a60da61c638f8a24154b5825a61c6cd2">SageInterface::is_OpenMP_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b0e18374a0ed7b0e6316a99024f3d463">SageInterface::is_UPC_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#8ec5479617b0522a268f633eae672480">SageInterface::is_UPC_dynamic_threads</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if dynamic threads compilation is used for UPC programs.  <a href="#8ec5479617b0522a268f633eae672480"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#886098c3840ecd5cd66dc1407dd43276">SageInterface::is_C99_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#f05a80a2ebfff2af0adea468853b95c8">SageInterface::is_Cxx_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#49a362a0ab0c9d904277c2110b3ad49c">SageInterface::is_Java_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#83cad0fd2592f95e81d55335eb6b71c0">SageInterface::is_Fortran_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#92b55e430cd48fbaf0549c18346a5143">SageInterface::is_CAF_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#1d36075c44838671db22569634aa2938">SageInterface::is_PHP_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#23d423a93f8f98375f0d6270830945a2">SageInterface::is_Python_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#bac39765f90bd8e44841f94da97b0983">SageInterface::is_Cuda_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#8adea0a7bcd9c553286b10558f39dc88">SageInterface::is_binary_executable</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#6321d2c29de36e4e3b13d5ad2f05360f">SageInterface::is_mixed_C_and_Cxx_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#0c24f014eaa02cc009e4d5b4e82317b0">SageInterface::is_mixed_Fortran_and_C_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#8400c6f481f8578f7cd13c62abdc0e20">SageInterface::is_mixed_Fortran_and_Cxx_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c403d067f7bef971b67d9a1c4a78d50e">SageInterface::is_mixed_Fortran_and_C_and_Cxx_language</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Scope</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#1035757c3d70027ffd221d21b36af053">SageInterface::resetScopeNumbers</a> (<a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *functionDeclaration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns unique numbers to each <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> of a function.  <a href="#1035757c3d70027ffd221d21b36af053"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d3cad455182a3615812ac2597a50bd09">SageInterface::clearScopeNumbers</a> (<a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *functionDefinition)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the cache of scope,integer pairs for the input function.  <a href="#d3cad455182a3615812ac2597a50bd09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgNamespaceDefinitionStatement.html">SgNamespaceDefinitionStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a192374d0f4322f7c91324938c6b8894">SageInterface::enclosingNamespaceScope</a> (<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *declaration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the enclosing namespace of a declaration.  <a href="#a192374d0f4322f7c91324938c6b8894"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b456db305882bbb6be21968b59fc865c">SageInterface::isPrototypeInScope</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope, <a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *functionDeclaration, <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *startingAtDeclaration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns unique numbers to each <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> of a function.  <a href="#b456db305882bbb6be21968b59fc865c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#74b3faa5cdda97afa174085b4a34a2f1">SageInterface::isAncestor</a> (<a class="el" href="classSgNode.html">SgNode</a> *node1, <a class="el" href="classSgNode.html">SgNode</a> *node2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">check if node1 is a strict ancestor of node 2. (a node is not considered its own ancestor)  <a href="#74b3faa5cdda97afa174085b4a34a2f1"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Preprocessing Information</h2></td></tr>
<tr><td colspan="2">if-else-end, comments, include, etc <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#8d27ee1ca1349f91dc8a18d1aa6cc403">SageInterface::dumpPreprocInfo</a> (<a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> *locatedNode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dumps a located node's preprocessing information.  <a href="#8d27ee1ca1349f91dc8a18d1aa6cc403"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPreprocessingInfo.html">PreprocessingInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#56f045ed55445883dc3fc798738580a2">SageInterface::insertHeader</a> (const std::string &amp;filename, <a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> position=PreprocessingInfo::after, bool isSystemHeader=false, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert include "filename" or include &lt;filename&gt; (system header) into the global scope containing the current scope, right after other include XXX.  <a href="#56f045ed55445883dc3fc798738580a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#283532aef637c65f6d103afc09d5fd71">SageInterface::moveUpPreprocessingInfo</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt_dst, <a class="el" href="classSgStatement.html">SgStatement</a> *stmt_src, <a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> src_position=PreprocessingInfo::undef, <a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> dst_position=PreprocessingInfo::undef, bool usePrepend=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Identical to <a class="el" href="namespaceSageInterface.html#b6bc0e31d1ae1be2e221bb8ddbe1e098">movePreprocessingInfo()</a>, except for the stale name and confusing order of parameters. It will be deprecated soon.  <a href="#283532aef637c65f6d103afc09d5fd71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b6bc0e31d1ae1be2e221bb8ddbe1e098">SageInterface::movePreprocessingInfo</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt_src, <a class="el" href="classSgStatement.html">SgStatement</a> *stmt_dst, <a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> src_position=PreprocessingInfo::undef, <a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> dst_position=PreprocessingInfo::undef, bool usePrepend=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move preprocessing information of stmt_src to stmt_dst, Only move preprocessing information from the specified source-relative position to a specified target position, otherwise move all preprocessing information with position information intact. The preprocessing information is appended to the existing preprocessing information list of the target node by default. Prepending is used if usePreprend is set to true. Optionally, the relative position can be adjust after the moving using dst_position.  <a href="#b6bc0e31d1ae1be2e221bb8ddbe1e098"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#29f09cd84a8eadc2e1c0524898973233">SageInterface::cutPreprocessingInfo</a> (<a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> *src_node, <a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> pos, <a class="el" href="rose__attributes__list_8h.html#d4b5f34bc0846e58b38e0ba5e8aac8b0">AttachedPreprocessingInfoType</a> &amp;save_buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cut preprocessing information from a source node and save it into a buffer. Used in combination of <a class="el" href="namespaceSageInterface.html#fa35ff298b746401f5f535de8a9c3f99">pastePreprocessingInfo()</a>. The cut-paste operation is similar to <a class="el" href="namespaceSageInterface.html#283532aef637c65f6d103afc09d5fd71">moveUpPreprocessingInfo()</a> but it is more flexible in that the destination node can be unknown during the cut operation.  <a href="#29f09cd84a8eadc2e1c0524898973233"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#fa35ff298b746401f5f535de8a9c3f99">SageInterface::pastePreprocessingInfo</a> (<a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> *dst_node, <a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> pos, <a class="el" href="rose__attributes__list_8h.html#d4b5f34bc0846e58b38e0ba5e8aac8b0">AttachedPreprocessingInfoType</a> &amp;saved_buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Paste preprocessing information from a buffer to a destination node. Used in combination of <a class="el" href="namespaceSageInterface.html#29f09cd84a8eadc2e1c0524898973233">cutPreprocessingInfo()</a>.  <a href="#fa35ff298b746401f5f535de8a9c3f99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPreprocessingInfo.html">PreprocessingInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a5cdee81732f9fb464a0239093275d86">SageInterface::attachArbitraryText</a> (<a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> *target, const std::string &amp;text, <a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> position=PreprocessingInfo::before)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attach an arbitrary string to a located node. A workaround to insert irregular statements or vendor-specific attributes.  <a href="#a5cdee81732f9fb464a0239093275d86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#3bf4efffda1365f130307b6581dcc5c9">SageInterface::replaceMacroCallsWithExpandedStrings</a> (<a class="el" href="classSgPragmaDeclaration.html">SgPragmaDeclaration</a> *target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a pragma declaration node has macro calls attached, if yes, replace macro calls within the pragma string with expanded strings. This only works if -rose:wave is turned on.  <a href="#3bf4efffda1365f130307b6581dcc5c9"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Source File Position</h2></td></tr>
<tr><td colspan="2">set <a class="el" href="classSg__File__Info.html">Sg_File_Info</a> for a <a class="el" href="classSgNode.html">SgNode</a> <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPreprocessingInfo.html">PreprocessingInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#67b0e2f8c62c2a8858340e7f90605bc3">SageInterface::attachComment</a> (<a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> *target, const std::string &amp;content, <a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> position=PreprocessingInfo::before, <a class="el" href="classPreprocessingInfo.html#e789144105bc700862c47070f4380064">PreprocessingInfo::DirectiveType</a> dtype=PreprocessingInfo::CpreprocessorUnknownDeclaration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build and attach comment, comment style is inferred from the language type of the target node if not provided.  <a href="#67b0e2f8c62c2a8858340e7f90605bc3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#0c8fca7b7763fe18fe2e65b7a3cf3ebe">SageInterface::addTextForUnparser</a> (<a class="el" href="classSgNode.html">SgNode</a> *astNode, std::string s, AstUnparseAttribute::RelativePositionType inputlocation)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a string to be unparsed to support code generation for back-end specific tools or compilers.  <a href="#0c8fca7b7763fe18fe2e65b7a3cf3ebe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#2d9f0cac1a208b285896a8f38d24910c">SageInterface::setOneSourcePositionForTransformation</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set current node's source position as transformation generated.  <a href="#2d9f0cac1a208b285896a8f38d24910c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c2dd84efb4bec39069ab07683078e29c">SageInterface::setOneSourcePositionNull</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set current node's source position as NULL.  <a href="#c2dd84efb4bec39069ab07683078e29c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4a000085908cd7fe8ab8cf07856b00fe">SageInterface::setSourcePositionForTransformation</a> (<a class="el" href="classSgNode.html">SgNode</a> *root)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recursively set source position info(Sg_File_Info) as transformation generated.  <a href="#4a000085908cd7fe8ab8cf07856b00fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#6bd0bf1527ae929472afba8b567fa808">SageInterface::setSourcePositionForTransformation_memoryPool</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set source position info(Sg_File_Info) as transformation generated for all SgNodes in memory pool.  <a href="#6bd0bf1527ae929472afba8b567fa808"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#bf0f6c68d90fe1d08e382fe8342b3992">SageInterface::setSourcePosition</a> (<a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> *locatedNode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the source position of <a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> to <a class="el" href="classSg__File__Info.html#d546c953744c52cf43459d6a8358851d">Sg_File_Info::generateDefaultFileInfo()</a>. These nodes WILL be unparsed. Not for transformation usage.  <a href="#bf0f6c68d90fe1d08e382fe8342b3992"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Data types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#5eb80ef8782c559e7721b5724889bdbe">SageInterface::getBoolType</a> (<a class="el" href="classSgNode.html">SgNode</a> *n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the right bool type according to C or C++ language input.  <a href="#5eb80ef8782c559e7721b5724889bdbe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#dbfdb7a0b32ca452c00f5e92c67ab504">SageInterface::isStrictIntegerType</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a type is an integral type, only allowing signed/unsigned short, int, long, long long.  <a href="#dbfdb7a0b32ca452c00f5e92c67ab504"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#da61c82df82783bc236b9fb30fbd74fd">SageInterface::getFirstVarType</a> (<a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *decl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the data type of the first initialized name of a declaration statement.  <a href="#da61c82df82783bc236b9fb30fbd74fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#009d6a3353b70c4ccbe95c6f7625afc1">SageInterface::isDefaultConstructible</a> (<a class="el" href="classSgType.html">SgType</a> *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is a type default constructible? This may not quite work properly.  <a href="#009d6a3353b70c4ccbe95c6f7625afc1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#32b9be9817f0b51872d3fcb8318ae729">SageInterface::isCopyConstructible</a> (<a class="el" href="classSgType.html">SgType</a> *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is a type copy constructible? This may not quite work properly.  <a href="#32b9be9817f0b51872d3fcb8318ae729"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#7a37edbdd90a230a51fc90448994cb8b">SageInterface::isAssignable</a> (<a class="el" href="classSgType.html">SgType</a> *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is a type assignable? This may not quite work properly.  <a href="#7a37edbdd90a230a51fc90448994cb8b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d3cb00d489f349ed6eaaaf0d5e1273fa">SageInterface::isPureVirtualClass</a> (<a class="el" href="classSgType.html">SgType</a> *type, const <a class="el" href="classClassHierarchyWrapper.html">ClassHierarchyWrapper</a> &amp;classHierarchy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a class type is a pure virtual class.  <a href="#d3cb00d489f349ed6eaaaf0d5e1273fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#756c8b08ca6df604e0e474ce92520240">SageInterface::hasTrivialDestructor</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does a type have a trivial (built-in) destructor?  <a href="#756c8b08ca6df604e0e474ce92520240"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#82f20af57da57491b26e6028fc4949c7">SageInterface::isNonconstReference</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this type a non-constant reference type? (Handles typedefs correctly).  <a href="#82f20af57da57491b26e6028fc4949c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#82448abd826a63fbf74cabde856223ec">SageInterface::isReferenceType</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this type a const or non-const reference type? (Handles typedefs correctly).  <a href="#82448abd826a63fbf74cabde856223ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#370c189fab51b8d9a5871c569fe2ae76">SageInterface::isPointerType</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this type a pointer type? (Handles typedefs correctly).  <a href="#370c189fab51b8d9a5871c569fe2ae76"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e88d4c976002995bdc89629bf5942812">SageInterface::isPointerToNonConstType</a> (<a class="el" href="classSgType.html">SgType</a> *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this a pointer to a non-const type? Note that this function will return true for const pointers pointing to non-const types.  <a href="#e88d4c976002995bdc89629bf5942812"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#3a8271b0d66df14cd687c3367c3530cc">SageInterface::isConstType</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this a const type?  <a href="#3a8271b0d66df14cd687c3367c3530cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#aad366e0a9271f41b1273169032163a9">SageInterface::removeConst</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove const (if present) from a type. stripType() cannot do this because it removes all modifiers.  <a href="#aad366e0a9271f41b1273169032163a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#bfdc4703511f9477641338f374d2efea">SageInterface::isVolatileType</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this a volatile type?  <a href="#bfdc4703511f9477641338f374d2efea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#9bb1cf771b3824b61f450868a4a37014">SageInterface::isRestrictType</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this a restrict type?  <a href="#9bb1cf771b3824b61f450868a4a37014"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#383e9d7c3a5ecf90215dc596491cb748">SageInterface::isScalarType</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this a scalar type?  <a href="#383e9d7c3a5ecf90215dc596491cb748"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#0c1abd9fda12ecad049dc846ab65dd99">SageInterface::isStructType</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a type is a struct type (a special <a class="el" href="classSgClassType.html">SgClassType</a> in <a class="el" href="namespaceROSE.html">ROSE</a>).  <a href="#0c1abd9fda12ecad049dc846ab65dd99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#42c6089ca6226d5f96cc54164a8c2dec">SageInterface::mangleType</a> (<a class="el" href="classSgType.html">SgType</a> *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a mangled string for a given type based on Itanium C++ ABI.  <a href="#42c6089ca6226d5f96cc54164a8c2dec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4ba1a020452edc07be8aefe8f87c7a52">SageInterface::mangleScalarType</a> (<a class="el" href="classSgType.html">SgType</a> *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate mangled scalar type names according to Itanium C++ ABI, the input type should pass <a class="el" href="namespaceSageInterface.html#383e9d7c3a5ecf90215dc596491cb748">isScalarType()</a> in <a class="el" href="namespaceROSE.html">ROSE</a>.  <a href="#4ba1a020452edc07be8aefe8f87c7a52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#181e5d76b90b579ffe02ce67a9a0ef8b">SageInterface::mangleModifierType</a> (<a class="el" href="classSgModifierType.html">SgModifierType</a> *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generated mangled modifier types, include const, volatile,according to Itanium C++ ABI, with extension to handle UPC shared types.  <a href="#181e5d76b90b579ffe02ce67a9a0ef8b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d41b5baa74591e80698884761377ab6b">SageInterface::getArrayElementCount</a> (<a class="el" href="classSgArrayType.html">SgArrayType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the number of elements of an array type: dim1* dim2*... , assume element count is 1 for int a[]; Strip off THREADS if it is a UPC array.  <a href="#d41b5baa74591e80698884761377ab6b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#8a2ff021fc68f7aa3af9427133e94663">SageInterface::getDimensionCount</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of dimensions of an array type.  <a href="#8a2ff021fc68f7aa3af9427133e94663"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4be15625c027455c3ba044dbeff24f05">SageInterface::getArrayElementType</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the element type of an array.  <a href="#4be15625c027455c3ba044dbeff24f05"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#5eaa89e50137b40aab59321dcfed8d81">SageInterface::getElementType</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the element type of an array, pointer or string, or NULL if not applicable.  <a href="#5eaa89e50137b40aab59321dcfed8d81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgExpression.html">SgExpression</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4f543ac715559ff0b76bdf8fd004fc09">SageInterface::get_C_array_dimensions</a> (const <a class="el" href="classSgArrayType.html">SgArrayType</a> &amp;arrtype)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the array dimensions in an array as defined for arrtype  <a href="#4f543ac715559ff0b76bdf8fd004fc09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgExpression.html">SgExpression</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c4ca57179d072f3577b07b8e33818dca">SageInterface::get_C_array_dimensions</a> (const <a class="el" href="classSgArrayType.html">SgArrayType</a> &amp;arrtype, const <a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> &amp;varref)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the array dimensions in an array as defined for arrtype  <a href="#c4ca57179d072f3577b07b8e33818dca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgExpression.html">SgExpression</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ae2594fcfdf89b9fc795eb4b4c2d04aa">SageInterface::get_C_array_dimensions</a> (const <a class="el" href="classSgArrayType.html">SgArrayType</a> &amp;arrtype, <a class="el" href="classSgInitializedName.html">SgInitializedName</a> &amp;initname)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ae2594fcfdf89b9fc795eb4b4c2d04aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#084d7c6b763876564745cdf9a33a65a3">SageInterface::isArrayReference</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *ref, <a class="el" href="classSgExpression.html">SgExpression</a> **arrayNameExp=NULL, std::vector&lt; <a class="el" href="classSgExpression.html">SgExpression</a> * &gt; **subscripts=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if an expression is an array access (<a class="el" href="classSgPntrArrRefExp.html">SgPntrArrRefExp</a>). If so, return its name expression and subscripts if requested. Users can use <a class="el" href="namespaceSageInterface.html#549a580089fff36d4184a4341cc08525">convertRefToInitializedName()</a> to get the possible name. It does not check if the expression is a top level <a class="el" href="classSgPntrArrRefExp.html">SgPntrArrRefExp</a>.  <a href="#084d7c6b763876564745cdf9a33a65a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#de40549fd13e8fe367b099dca26b05e9">SageInterface::hasUpcSharedType</a> (<a class="el" href="classSgType.html">SgType</a> *t, <a class="el" href="classSgModifierType.html">SgModifierType</a> **mod_type_out=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Has a UPC shared type of any kinds (shared-to-shared, private-to-shared, shared-to-private, shared scalar/array)? An optional parameter, mod_type_out, stores the first <a class="el" href="classSgModifierType.html">SgModifierType</a> with UPC access information.  <a href="#de40549fd13e8fe367b099dca26b05e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b376d542cfdc22ae95a4396a13f4bc93">SageInterface::isUpcSharedType</a> (<a class="el" href="classSgType.html">SgType</a> *t, <a class="el" href="classSgModifierType.html">SgModifierType</a> **mod_type_out=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a type is a UPC shared type, including shared array, shared pointers etc. Exclude private pointers to shared types. Optionally return the modifier type with the UPC shared property.  <a href="#b376d542cfdc22ae95a4396a13f4bc93"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d54acda16a47a2c0cfbf2cfb9acbe8ee">SageInterface::isUpcSharedModifierType</a> (<a class="el" href="classSgModifierType.html">SgModifierType</a> *mod_type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a modifier type is a UPC shared type.  <a href="#d54acda16a47a2c0cfbf2cfb9acbe8ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4d265b598c37bc424f98b5a95573ff15">SageInterface::isUpcSharedArrayType</a> (<a class="el" href="classSgArrayType.html">SgArrayType</a> *array_type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if an array type is a UPC shared type. <a class="el" href="namespaceROSE.html">ROSE</a> AST represents a UPC shared array as regular array of elements of UPC shared Modifier Type. Not directly a UPC shared Modifier Type of an array.  <a href="#4d265b598c37bc424f98b5a95573ff15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#3a8ddc7cf87c39a61529012d179d3dbe">SageInterface::isUpcStrictSharedModifierType</a> (<a class="el" href="classSgModifierType.html">SgModifierType</a> *mode_type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a shared UPC type is strict memory consistency or not. Return false if it is relaxed. (So isUpcRelaxedSharedModifierType() is not necessary.).  <a href="#3a8ddc7cf87c39a61529012d179d3dbe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ad5db4074aa860d969211e082b1fda2a">SageInterface::getUpcSharedBlockSize</a> (<a class="el" href="classSgModifierType.html">SgModifierType</a> *mod_type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the block size of a UPC shared modifier type.  <a href="#ad5db4074aa860d969211e082b1fda2a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a4517f3d9eb77e8c20978d259f05dae9">SageInterface::getUpcSharedBlockSize</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the block size of a UPC shared type, including Modifier types and array of modifier types (shared arrays).  <a href="#a4517f3d9eb77e8c20978d259f05dae9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#78e18bb017714a961c89e99658deaf62">SageInterface::isUpcPhaseLessSharedType</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is UPC phase-less shared type? Phase-less means block size of the first <a class="el" href="classSgModifierType.html">SgModifierType</a> with UPC information is 1 or 0/unspecified. Also return false if the type is not a UPC shared type.  <a href="#78e18bb017714a961c89e99658deaf62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a8dfe505ebec9aa2cc591ab6abd2eee6">SageInterface::isUpcPrivateToSharedType</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is a UPC private-to-shared pointer? <a class="el" href="classSgPointerType.html">SgPointerType</a> comes first compared to <a class="el" href="classSgModifierType.html">SgModifierType</a> with UPC information. Input type must be any of UPC shared types first.  <a href="#a8dfe505ebec9aa2cc591ab6abd2eee6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c9d12d48cbb70bd32351ef1d11bf8a03">SageInterface::isUpcArrayWithThreads</a> (<a class="el" href="classSgArrayType.html">SgArrayType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is a UPC array with dimension of X*THREADS.  <a href="#c9d12d48cbb70bd32351ef1d11bf8a03"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ef8c45dd50e90745d7a58043ff115b59">SageInterface::lookupNamedTypeInParentScopes</a> (const std::string &amp;type_name, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lookup a named type based on its name, bottomup searching from a specified scope. Note name collison might be allowed for c (not C++) between typedef and enum/struct. Only the first matched named type will be returned in this case. typedef is returned as it is, not the base type it actually refers to.  <a href="#ef8c45dd50e90745d7a58043ff115b59"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Loop handling</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#08fe811227383a60a96a1f35e33d58c7">SageInterface::addStepToLoopBody</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *loopStmt, <a class="el" href="classSgStatement.html">SgStatement</a> *step)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a step statement to the end of a loop body Add a new label to the end of the loop, with the step statement after it; then change all continue statements in the old loop body into jumps to the label.  <a href="#08fe811227383a60a96a1f35e33d58c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#8350cdaa61eb225618e5d32d1d6ead35">SageInterface::moveForStatementIncrementIntoBody</a> (<a class="el" href="classSgForStatement.html">SgForStatement</a> *f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a step statement to the end of a loop body Add a new label to the end of the loop, with the step statement after it; then change all continue statements in the old loop body into jumps to the label.  <a href="#8350cdaa61eb225618e5d32d1d6ead35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d8b390197b2be6ccda0b4cd5f5db5924">SageInterface::convertForToWhile</a> (<a class="el" href="classSgForStatement.html">SgForStatement</a> *f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a step statement to the end of a loop body Add a new label to the end of the loop, with the step statement after it; then change all continue statements in the old loop body into jumps to the label.  <a href="#d8b390197b2be6ccda0b4cd5f5db5924"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a952504e784c3893ff962859c02db863">SageInterface::convertAllForsToWhiles</a> (<a class="el" href="classSgNode.html">SgNode</a> *top)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a step statement to the end of a loop body Add a new label to the end of the loop, with the step statement after it; then change all continue statements in the old loop body into jumps to the label.  <a href="#a952504e784c3893ff962859c02db863"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a3c334c13af3f52296a321d7c35baa23">SageInterface::changeContinuesToGotos</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, <a class="el" href="classSgLabelStatement.html">SgLabelStatement</a> *label)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change continue statements in a given block of code to gotos to a label.  <a href="#a3c334c13af3f52296a321d7c35baa23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgInitializedName.html">SgInitializedName</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a665b7831b78df5befccba361619e346">SageInterface::getLoopIndexVariable</a> (<a class="el" href="classSgNode.html">SgNode</a> *loop)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the loop index variable for a for loop.  <a href="#a665b7831b78df5befccba361619e346"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#21ef5a8bfe9a660dbe9206d50f1750ce">SageInterface::isLoopIndexVariable</a> (<a class="el" href="classSgInitializedName.html">SgInitializedName</a> *ivar, <a class="el" href="classSgNode.html">SgNode</a> *subtree_root)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a <a class="el" href="classSgInitializedName.html">SgInitializedName</a> is used as a loop index within a AST subtree This function will use a bottom-up traverse starting from the subtree_root to find all enclosing loops and check if ivar is used as an index for either of them.  <a href="#21ef5a8bfe9a660dbe9206d50f1750ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#cdd84b0f648aacdf4d31692bbff98c42">SageInterface::getLoopBody</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *loop)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Routines to get and set the body of a loop.  <a href="#cdd84b0f648aacdf4d31692bbff98c42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e79df849100431065061cb615b27b5e7">SageInterface::setLoopBody</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *loop, <a class="el" href="classSgStatement.html">SgStatement</a> *body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a step statement to the end of a loop body Add a new label to the end of the loop, with the step statement after it; then change all continue statements in the old loop body into jumps to the label.  <a href="#e79df849100431065061cb615b27b5e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#8a48fa3afe244bdceaf9201f217d9873">SageInterface::getLoopCondition</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *loop)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Routines to get the condition of a loop. It recognize While-loop, For-loop, and Do-While-loop.  <a href="#8a48fa3afe244bdceaf9201f217d9873"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#3368c7c03cdd8fad0ff4dde8ac17a7bc">SageInterface::setLoopCondition</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *loop, <a class="el" href="classSgStatement.html">SgStatement</a> *cond)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the condition statement of a loop, including While-loop, For-loop, and Do-While-loop.  <a href="#3368c7c03cdd8fad0ff4dde8ac17a7bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#8fee9383277837dceac3130968eb447a">SageInterface::isCanonicalForLoop</a> (<a class="el" href="classSgNode.html">SgNode</a> *loop, <a class="el" href="classSgInitializedName.html">SgInitializedName</a> **ivar=NULL, <a class="el" href="classSgExpression.html">SgExpression</a> **lb=NULL, <a class="el" href="classSgExpression.html">SgExpression</a> **ub=NULL, <a class="el" href="classSgExpression.html">SgExpression</a> **step=NULL, <a class="el" href="classSgStatement.html">SgStatement</a> **body=NULL, bool *hasIncrementalIterationSpace=NULL, bool *isInclusiveUpperBound=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a for-loop has a canonical form, return loop index, bounds, step, and body if requested.  <a href="#8fee9383277837dceac3130968eb447a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#25ecfa1b43bb6bef8e6f0c4217206638">SageInterface::isCanonicalDoLoop</a> (<a class="el" href="classSgFortranDo.html">SgFortranDo</a> *loop, <a class="el" href="classSgInitializedName.html">SgInitializedName</a> **ivar, <a class="el" href="classSgExpression.html">SgExpression</a> **lb, <a class="el" href="classSgExpression.html">SgExpression</a> **ub, <a class="el" href="classSgExpression.html">SgExpression</a> **step, <a class="el" href="classSgStatement.html">SgStatement</a> **body, bool *hasIncrementalIterationSpace, bool *isInclusiveUpperBound)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a Fortran Do loop has a complete canonical form: Do I=1, 10, 1.  <a href="#25ecfa1b43bb6bef8e6f0c4217206638"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#9def1f61dcf1d975ebd823f921dc4a92">SageInterface::setLoopLowerBound</a> (<a class="el" href="classSgNode.html">SgNode</a> *loop, <a class="el" href="classSgExpression.html">SgExpression</a> *lb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the lower bound of a loop header for (i=lb; ...).  <a href="#9def1f61dcf1d975ebd823f921dc4a92"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#cc572630786f0e865742cc8274992e8b">SageInterface::setLoopUpperBound</a> (<a class="el" href="classSgNode.html">SgNode</a> *loop, <a class="el" href="classSgExpression.html">SgExpression</a> *ub)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the upper bound of a loop header,regardless the condition expression type. for (i=lb; i op up, ...).  <a href="#cc572630786f0e865742cc8274992e8b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#7ad626782e4cd15b81d486f1012e3944">SageInterface::setLoopStride</a> (<a class="el" href="classSgNode.html">SgNode</a> *loop, <a class="el" href="classSgExpression.html">SgExpression</a> *stride)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the stride(step) of a loop 's incremental expression, regardless the expression types (i+=s; i= i+s, etc).  <a href="#7ad626782e4cd15b81d486f1012e3944"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#56ad0d54049c684d5af206864adf7390">SageInterface::normalizeForLoopInitDeclaration</a> (<a class="el" href="classSgForStatement.html">SgForStatement</a> *loop)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize loop init stmt by promoting the single variable declaration statement outside of the for loop header's init statement, e.g. for (int i=0;) becomes int i_x; for (i_x=0;..) and rewrite the loop with the new index variable, if necessary.  <a href="#56ad0d54049c684d5af206864adf7390"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a500ce86ded48ff840d829a33e08b0d6">SageInterface::forLoopNormalization</a> (<a class="el" href="classSgForStatement.html">SgForStatement</a> *loop)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize a for loop, return true if successful.  <a href="#a500ce86ded48ff840d829a33e08b0d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#714c3bd1a8ad05aefd0a374f5449a975">SageInterface::doLoopNormalization</a> (<a class="el" href="classSgFortranDo.html">SgFortranDo</a> *loop)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize a Fortran Do loop. Make the default increment expression (1) explicit.  <a href="#714c3bd1a8ad05aefd0a374f5449a975"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#32c1cd741a34e12e81515e3e6e3ce6a1">SageInterface::loopUnrolling</a> (<a class="el" href="classSgForStatement.html">SgForStatement</a> *loop, size_t unrolling_factor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unroll a target loop with a specified unrolling factor. It handles steps larger than 1 and adds a fringe loop if the iteration count is not evenly divisible by the unrolling factor.  <a href="#32c1cd741a34e12e81515e3e6e3ce6a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#69c06c565033135bf031e02547d7ffd7">SageInterface::loopInterchange</a> (<a class="el" href="classSgForStatement.html">SgForStatement</a> *loop, size_t depth, size_t lexicoOrder)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interchange/permutate a n-level perfectly-nested loop rooted at 'loop' using a lexicographical order number within (0,depth!).  <a href="#69c06c565033135bf031e02547d7ffd7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#bf67276dd03b4d83fd53e8d17cfee342">SageInterface::loopTiling</a> (<a class="el" href="classSgForStatement.html">SgForStatement</a> *loopNest, size_t targetLevel, size_t tileSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tile the n-level (starting from 1) loop of a perfectly nested loop nest using tiling size s.  <a href="#bf67276dd03b4d83fd53e8d17cfee342"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Topdown search</h2></td></tr>
<tr><td colspan="2">Top-down traversal from current node to find a node of a specified type <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename NodeType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::vector&lt; NodeType * &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#1123219ebb32a1140a1c10e73b97ca22">SageInterface::querySubTree</a> (<a class="el" href="classSgNode.html">SgNode</a> *top, <a class="el" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a> variant=(<a class="el" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a>) NodeType::static_variant)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query a subtree to get all nodes of a given type, with an appropriate downcast.  <a href="#1123219ebb32a1140a1c10e73b97ca22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgFile.html">SgFile</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e033e337d88d92aa952932fdb077cbe4">SageInterface::generateFileList</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns STL vector of <a class="el" href="classSgFile.html">SgFile</a> IR node pointers.  <a href="#e033e337d88d92aa952932fdb077cbe4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgProject.html">SgProject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c2c6c9fdb8ba0b9a21677e11014216cf">SageInterface::getProject</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current <a class="el" href="classSgProject.html">SgProject</a> IR Node.  <a href="#c2c6c9fdb8ba0b9a21677e11014216cf"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename NodeType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static std::vector&lt; NodeType * &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#71fa312dbb8ef1d9a37f6897de49fcce">SageInterface::getSgNodeListFromMemoryPool</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query memory pools to grab <a class="el" href="classSgNode.html">SgNode</a> of a specified type.  <a href="#71fa312dbb8ef1d9a37f6897de49fcce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#0c4e4490c4d20ef7f32dd2d6459c7548">SageInterface::findMain</a> (<a class="el" href="classSgNode.html">SgNode</a> *currentNode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">top-down traversal from current node to find the main() function declaration  <a href="#0c4e4490c4d20ef7f32dd2d6459c7548"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#81e9af0e07a7ba45455e3a463d43ed9f">SageInterface::findLastDeclarationStatement</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the last declaration statement within a scope (if any). This is often useful to decide where to insert another declaration statement.  <a href="#81e9af0e07a7ba45455e3a463d43ed9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#be2c3ab6716f418f4706960427c71545">SageInterface::getSymbolsUsedInExpression</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *expr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find referenced symbols within an expression.  <a href="#be2c3ab6716f418f4706960427c71545"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgBreakStmt.html">SgBreakStmt</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b3fd7caa53c4504d7d668336d4be8097">SageInterface::findBreakStmts</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *code, const std::string &amp;fortranLabel=&quot;&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find break statements inside a particular statement, stopping at nested loops or switches.  <a href="#b3fd7caa53c4504d7d668336d4be8097"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgContinueStmt.html">SgContinueStmt</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d8f642bb83545acd486c40aeb6f3093f">SageInterface::findContinueStmts</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *code, const std::string &amp;fortranLabel=&quot;&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find all continue statements inside a particular statement, stopping at nested loops.  <a href="#d8f642bb83545acd486c40aeb6f3093f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgGotoStatement.html">SgGotoStatement</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c7ba7b7b9738ec66d5e39a0beb16e900">SageInterface::findGotoStmts</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *scope, <a class="el" href="classSgLabelStatement.html">SgLabelStatement</a> *l)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query a subtree to get all nodes of a given type, with an appropriate downcast.  <a href="#c7ba7b7b9738ec66d5e39a0beb16e900"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgStatement.html">SgStatement</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#51e681c5508ac6c664ed3dabdd230323">SageInterface::getSwitchCases</a> (<a class="el" href="classSgSwitchStatement.html">SgSwitchStatement</a> *sw)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query a subtree to get all nodes of a given type, with an appropriate downcast.  <a href="#51e681c5508ac6c664ed3dabdd230323"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b36728bc3a9ee699fb33c04efbb1b553">SageInterface::findDeclarationStatement</a> (<a class="el" href="classSgNode.html">SgNode</a> *root, std::string name, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope, bool isDefining)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Topdown traverse a subtree from root to find the first declaration given its name, scope (optional, can be NULL), and defining or nondefining flag.  <a href="#b36728bc3a9ee699fb33c04efbb1b553"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#25ba093b55f9983f1f3c385563e1b880">SageInterface::findFunctionDeclaration</a> (<a class="el" href="classSgNode.html">SgNode</a> *root, std::string name, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope, bool isDefining)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Topdown traverse a subtree from root to find the first function declaration matching the given name, scope (optional, can be NULL), and defining or nondefining flag. This is an instantiation of findDeclarationStatement&lt;T&gt;.  <a href="#25ba093b55f9983f1f3c385563e1b880"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Bottom up search</h2></td></tr>
<tr><td colspan="2">Backwards traverse through the AST to find a node, findEnclosingXXX() <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename NodeType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">NodeType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#0e13c06070acba9a4028596b14df37c0">SageInterface::getEnclosingNode</a> (const <a class="el" href="classSgNode.html">SgNode</a> *astNode, const bool includingSelf=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a node by type using upward traversal.  <a href="#0e13c06070acba9a4028596b14df37c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#6ec13831a4d9c0142db2f595d56ce862">SageInterface::getScope</a> (const <a class="el" href="classSgNode.html">SgNode</a> *astNode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the closest scope from astNode. Return astNode if it is already a scope.  <a href="#6ec13831a4d9c0142db2f595d56ce862"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgGlobal.html">SgGlobal</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#108fb9317605cd9d1228cb156993e34d">SageInterface::getGlobalScope</a> (const <a class="el" href="classSgNode.html">SgNode</a> *astNode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Traverse back through a node's parents to find the enclosing global scope.  <a href="#108fb9317605cd9d1228cb156993e34d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#3d1cde13da7917ba2ac6005d266f934d">SageInterface::getEnclosingProcedure</a> (<a class="el" href="classSgNode.html">SgNode</a> *n, const bool includingSelf=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the function definition.  <a href="#3d1cde13da7917ba2ac6005d266f934d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#89a3cd0446fb308e841a8844ec69f96e">SageInterface::getEnclosingFunctionDefinition</a> (<a class="el" href="classSgNode.html">SgNode</a> *astNode, const bool includingSelf=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a node by type using upward traversal.  <a href="#89a3cd0446fb308e841a8844ec69f96e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#5717c88c4a9675c30069319cfe913127">SageInterface::getEnclosingStatement</a> (<a class="el" href="classSgNode.html">SgNode</a> *n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the closest enclosing statement, including the given node.  <a href="#5717c88c4a9675c30069319cfe913127"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgSwitchStatement.html">SgSwitchStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ac586c26b215b6fb86a99370905e2044">SageInterface::findEnclosingSwitch</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the closest switch outside a given statement (normally used for case and default statements).  <a href="#ac586c26b215b6fb86a99370905e2044"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#9fc733ce75b79e34e7c85c0e5b5b1d1a">SageInterface::findEnclosingLoop</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *s, const std::string &amp;fortranLabel=&quot;&quot;, bool stopOnSwitches=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the closest loop outside the given statement; if fortranLabel is not empty, the Fortran label of the loop must be equal to it.  <a href="#9fc733ce75b79e34e7c85c0e5b5b1d1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ac9b45bdb148ec342cf14c95f39e64f9">SageInterface::getEnclosingFunctionDeclaration</a> (<a class="el" href="classSgNode.html">SgNode</a> *astNode, const bool includingSelf=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the enclosing function declaration, including its derived instances like isSgProcedureHeaderStatement, isSgProgramHeaderStatement, and isSgMemberFunctionDeclaration.  <a href="#ac9b45bdb148ec342cf14c95f39e64f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgFile.html">SgFile</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#73600ebdd020f6ffed566018c22e20b8">SageInterface::getEnclosingFileNode</a> (<a class="el" href="classSgNode.html">SgNode</a> *astNode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the <a class="el" href="classSgFile.html">SgFile</a> node from current node  <a href="#73600ebdd020f6ffed566018c22e20b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgInitializer.html">SgInitializer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a7ab26b36b4ddffb9db2c7f2160322c8">SageInterface::getInitializerOfExpression</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the initializer containing an expression if it is within an initializer.  <a href="#a7ab26b36b4ddffb9db2c7f2160322c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgClassDefinition.html">SgClassDefinition</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#f3212dbf1eb743a7f9cd2ed35142cd5f">SageInterface::getEnclosingClassDefinition</a> (<a class="el" href="classSgNode.html">SgNode</a> *astnode, const bool includingSelf=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the closest class definition enclosing the specified AST node,.  <a href="#f3212dbf1eb743a7f9cd2ed35142cd5f"></a><br></td></tr>
<tr><td colspan="2"><br><h2>AST Walk and Traversal</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgGlobal.html">SgGlobal</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b45dc06ff0224928a1ae1da997e52b08">SageInterface::getFirstGlobalScope</a> (<a class="el" href="classSgProject.html">SgProject</a> *<a class="el" href="namespacecfgUtils.html#ce4abf2beca5826144d69d3a0283050f">project</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the first global scope under current project  <a href="#b45dc06ff0224928a1ae1da997e52b08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4ad89114f9b3edc1d78c4ed0361b7b8c">SageInterface::getLastStatement</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the last statement within a scope, return NULL if it does not exit  <a href="#4ad89114f9b3edc1d78c4ed0361b7b8c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#2b15b529d2da9a8b370adc56def709fb">SageInterface::getFirstStatement</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope, bool includingCompilerGenerated=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the first statement within a scope, return NULL if it does not exist. Skip compiler-generated statement by default. Count transformation-generated ones, but excluding those which are not to be outputted in unparsers.  <a href="#2b15b529d2da9a8b370adc56def709fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d3bb1a781eb5b2ece057e620dcc3f83c">SageInterface::findFirstDefiningFunctionDecl</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the first defining function declaration statement in a scope.  <a href="#d3bb1a781eb5b2ece057e620dcc3f83c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#514decfd76850247d4e84d54f88ce1c9">SageInterface::getNextStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *currentStmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get next statement within the same scope of current statement.  <a href="#514decfd76850247d4e84d54f88ce1c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#1f85e0ded2e249c9e54b4204eeeed113">SageInterface::getPreviousStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *currentStmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get previous statement within the same scope of current statement.  <a href="#1f85e0ded2e249c9e54b4204eeeed113"></a><br></td></tr>
<tr><td colspan="2"><br><h2>AST Comparison</h2></td></tr>
<tr><td colspan="2">Compare AST nodes, subtree, etc <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#6b16a27989aff98b861e3a677563ae42">SageInterface::isEqualToIntConst</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *e, int value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a <a class="el" href="classSgIntVal.html">SgIntVal</a> node has a given value.  <a href="#6b16a27989aff98b861e3a677563ae42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#2ad29ecfbbcca49188ceb7468e91ae74">SageInterface::isSameFunction</a> (<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *func1, <a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *func2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if two function declarations refer to the same one. Two function declarations are the same when they are a) identical, b) same name in C c) same qualified named and mangled name in C++. A nondefining (prototype) declaration and a defining declaration of a same function are treated as the same.  <a href="#2ad29ecfbbcca49188ceb7468e91ae74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#01df9113c49dfbd3f7145e9a8259d125">SageInterface::isLastStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a statement is the last statement within its closed scope.  <a href="#01df9113c49dfbd3f7145e9a8259d125"></a><br></td></tr>
<tr><td colspan="2"><br><h2>AST insert, removal, and replacement</h2></td></tr>
<tr><td colspan="2">Add, remove,and replace AST<p>
scope-&gt;append_statement(), exprListExp-&gt;append_expression() etc. are not enough to handle side effect of parent pointers, symbol tables, preprocessing info, defining/nondefining pointers etc. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#57437bbbb806858dda0cea7444fbafef">SageInterface::deleteAST</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classFunction.html">Function</a> to delete AST subtree's nodes only, users must take care of any dangling pointers, symbols or types that result.  <a href="#57437bbbb806858dda0cea7444fbafef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#062f0bab3b5deef80a101471d2bc0c0e">SageInterface::deleteExpressionTreeWithOriginalExpressionSubtrees</a> (<a class="el" href="classSgNode.html">SgNode</a> *root)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special purpose function for deleting AST expression tress containing valid original expression trees in constant folded expressions (for internal use only).  <a href="#062f0bab3b5deef80a101471d2bc0c0e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d74e38bddc8dc4d5d0506102782680ef">SageInterface::moveStatementsBetweenBlocks</a> (<a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *sourceBlock, <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *targetBlock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move statements in first block to the second block (preserves order and rebuilds the symbol table).  <a href="#d74e38bddc8dc4d5d0506102782680ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#bd2b74fa3c7de0b27066790dfba32ab7">SageInterface::appendStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a statement to the end of the current scope, handle side effect of appending statements, e.g. preprocessing info, defining/nondefining pointers etc.  <a href="#bd2b74fa3c7de0b27066790dfba32ab7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#dc3d212ae841c07933c40e4235b4f0a9">SageInterface::appendStatementList</a> (const std::vector&lt; <a class="el" href="classSgStatement.html">SgStatement</a> * &gt; &amp;stmt, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a list of statements to the end of the current scope, handle side effect of appending statements, e.g. preprocessing info, defining/nondefining pointers etc.  <a href="#dc3d212ae841c07933c40e4235b4f0a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#6d20d118b27ab3675c748d6adb2ac467">SageInterface::appendStatementWithDependentDeclaration</a> (<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *decl, <a class="el" href="classSgGlobal.html">SgGlobal</a> *scope, <a class="el" href="classSgStatement.html">SgStatement</a> *original_statement, bool excludeHeaderFiles)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a copy ('decl') of a function ('original_statement') into a 'scope', include any referenced declarations required if the scope is within a compiler generated file. All referenced declarations, including those from headers, are inserted if excludeHeaderFiles is set to true (the new file will not have any headers).  <a href="#6d20d118b27ab3675c748d6adb2ac467"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e9c30cd9d9c2589e9534638c7a79e731">SageInterface::prependStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepend a statement to the beginning of the current scope, handling side effects as appropriate.  <a href="#e9c30cd9d9c2589e9534638c7a79e731"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#150082ead31a73a3cd272f7428521823">SageInterface::prependStatementList</a> (const std::vector&lt; <a class="el" href="classSgStatement.html">SgStatement</a> * &gt; &amp;stmt, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">prepend a list of statements to the beginning of the current scope, handling side effects as appropriate  <a href="#150082ead31a73a3cd272f7428521823"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e41c86d0aefd60c26c60bd6f0ec4b76b">SageInterface::hasSimpleChildrenList</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a scope statement has a simple children statement list so insert additional statements under the scope is straightforward and unambiguous .  <a href="#e41c86d0aefd60c26c60bd6f0ec4b76b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#54e6780cc15a76ce7bc37a1212452e66">SageInterface::insertStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *targetStmt, <a class="el" href="classSgStatement.html">SgStatement</a> *newStmt, bool insertBefore=true, bool autoMovePreprocessingInfo=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a statement before or after the target statement within the target's scope. Move around preprocessing info automatically.  <a href="#54e6780cc15a76ce7bc37a1212452e66"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#07fb69a12095f93a9cbe325fe5a8b7d2">SageInterface::insertStatementList</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *targetStmt, const std::vector&lt; <a class="el" href="classSgStatement.html">SgStatement</a> * &gt; &amp;newStmts, bool insertBefore=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a list of statements before or after the target statement within the.  <a href="#07fb69a12095f93a9cbe325fe5a8b7d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#dab9927218b2709b3d99544db4386dc2">SageInterface::insertStatementBefore</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *targetStmt, <a class="el" href="classSgStatement.html">SgStatement</a> *newStmt, bool autoMovePreprocessingInfo=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a statement before a target statement.  <a href="#dab9927218b2709b3d99544db4386dc2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#193b6b847675d342d37b9917bf0a3f43">SageInterface::insertStatementListBefore</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *targetStmt, const std::vector&lt; <a class="el" href="classSgStatement.html">SgStatement</a> * &gt; &amp;newStmts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a list of statements before a target statement.  <a href="#193b6b847675d342d37b9917bf0a3f43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#f43f1edd321a11e4a9d6fd6cf8b4bcd6">SageInterface::insertStatementAfter</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *targetStmt, <a class="el" href="classSgStatement.html">SgStatement</a> *newStmt, bool autoMovePreprocessingInfo=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a statement after a target statement, Move around preprocessing info automatically by default.  <a href="#f43f1edd321a11e4a9d6fd6cf8b4bcd6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4c7e8d91522f9c76e28d35bcd76a07e6">SageInterface::insertStatementListAfter</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *targetStmt, const std::vector&lt; <a class="el" href="classSgStatement.html">SgStatement</a> * &gt; &amp;newStmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a list of statements after a target statement.  <a href="#4c7e8d91522f9c76e28d35bcd76a07e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#918939111ad1510bfc0c520156e8d9e9">SageInterface::insertStatementAfterLastDeclaration</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a statement after the last declaration within a scope. The statement will be prepended to the scope if there is no declaration statement found.  <a href="#918939111ad1510bfc0c520156e8d9e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#9c538bc1293c87f89917412d8729f679">SageInterface::insertStatementAfterLastDeclaration</a> (std::vector&lt; <a class="el" href="classSgStatement.html">SgStatement</a> * &gt; stmt_list, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a list of statements after the last declaration within a scope. The statement will be prepended to the scope if there is no declaration statement found.  <a href="#9c538bc1293c87f89917412d8729f679"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#f5972a33cb2e9b5723e50ceccdaccb9f">SageInterface::removeStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, bool autoRelocatePreprocessingInfo=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a statement from its attach point of the AST. Automatically keep its associated preprocessing information at the original place after the removal. The statement is still in memory and it is up to the users to decide if the removed one will be inserted somewhere else or released from memory (<a class="el" href="namespaceSageInterface.html#57437bbbb806858dda0cea7444fbafef">deleteAST()</a>).  <a href="#f5972a33cb2e9b5723e50ceccdaccb9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#03bd60c658db463cfc3791a7bba5017a">SageInterface::deepDelete</a> (<a class="el" href="classSgNode.html">SgNode</a> *root)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deep delete a sub AST tree. It uses postorder traversal to delete each child node. Users must take care of any dangling pointers, symbols or types that result. This is identical to <a class="el" href="namespaceSageInterface.html#57437bbbb806858dda0cea7444fbafef">deleteAST()</a>.  <a href="#03bd60c658db463cfc3791a7bba5017a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#69827cb64e737fdc661a48871c92ec96">SageInterface::replaceStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *oldStmt, <a class="el" href="classSgStatement.html">SgStatement</a> *newStmt, bool movePreprocessinInfo=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace a statement with another. Move preprocessing information from oldStmt to newStmt if requested.  <a href="#69827cb64e737fdc661a48871c92ec96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#40eb9c7f467b4e0830bae948562d2d89">SageInterface::replaceWithPattern</a> (<a class="el" href="classSgNode.html">SgNode</a> *anchor, <a class="el" href="classSgNode.html">SgNode</a> *new_pattern)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace an anchor node with a specified pattern subtree with optional <a class="el" href="classSgVariantExpression.html">SgVariantExpression</a>. All <a class="el" href="classSgVariantExpression.html">SgVariantExpression</a> in the pattern will be replaced with copies of the anchor node.  <a href="#40eb9c7f467b4e0830bae948562d2d89"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt; <a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *,<br>
 <a class="el" href="classSgExpression.html">SgExpression</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#8b8089083afe0aca12b1c9ba64d4ddc6">SageInterface::createTempVariableForExpression</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *expression, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope, bool initializeInDeclaration, <a class="el" href="classSgAssignOp.html">SgAssignOp</a> **reEvaluate=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an expression, generates a temporary variable whose initializer optionally evaluates that expression.  <a href="#8b8089083afe0aca12b1c9ba64d4ddc6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ef8223b9741c08bb50c4ee85e04bbe16">SageInterface::appendArg</a> (<a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a> *, <a class="el" href="classSgInitializedName.html">SgInitializedName</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an argument to <a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a>, transparently set parent,scope, and symbols for arguments when possible.  <a href="#ef8223b9741c08bb50c4ee85e04bbe16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e997b353e050f84a2e1663e2b0945efa">SageInterface::prependArg</a> (<a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a> *, <a class="el" href="classSgInitializedName.html">SgInitializedName</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepend an argument to <a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a>.  <a href="#e997b353e050f84a2e1663e2b0945efa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e81668e6c7307d8cc9ad38de73282102">SageInterface::appendExpression</a> (<a class="el" href="classSgExprListExp.html">SgExprListExp</a> *, <a class="el" href="classSgExpression.html">SgExpression</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an expression to a <a class="el" href="classSgExprListExp.html">SgExprListExp</a>, set the parent pointer also.  <a href="#e81668e6c7307d8cc9ad38de73282102"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#19c6d987024cdb9c93f33181928beaff">SageInterface::appendExpressionList</a> (<a class="el" href="classSgExprListExp.html">SgExprListExp</a> *, const std::vector&lt; <a class="el" href="classSgExpression.html">SgExpression</a> * &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an expression list to a <a class="el" href="classSgExprListExp.html">SgExprListExp</a>, set the parent pointers also.  <a href="#19c6d987024cdb9c93f33181928beaff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e4200b6d287e2c5b2d7a4d382f110863">SageInterface::setParameterList</a> (<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *func, <a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a> *paralist)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set parameter list for a function declaration, considering existing parameter list etc.  <a href="#e4200b6d287e2c5b2d7a4d382f110863"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#60d9ec8400d43be2985ea888afb69989">SageInterface::setPragma</a> (<a class="el" href="classSgPragmaDeclaration.html">SgPragmaDeclaration</a> *decl, <a class="el" href="classSgPragma.html">SgPragma</a> *pragma)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a pragma of a pragma declaration. handle memory release for preexisting pragma, and set parent pointer.  <a href="#60d9ec8400d43be2985ea888afb69989"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ba697ba095a90c110e020e411fd8158f">SageInterface::replaceExpression</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *oldExp, <a class="el" href="classSgExpression.html">SgExpression</a> *newExp, bool keepOldExp=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace an expression with another, used for variable reference substitution and others. the old expression can be deleted (default case) or kept.  <a href="#ba697ba095a90c110e020e411fd8158f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d85460fd6c32e78e4dda28984b0ab541">SageInterface::replaceExpressionWithStatement</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *from, <a class="el" href="classSageInterface_1_1StatementGenerator.html">SageInterface::StatementGenerator</a> *to)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace a given expression with a list of statements produced by a generator.  <a href="#d85460fd6c32e78e4dda28984b0ab541"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c8ce4794f2e0212a315bceb252fe93f2">SageInterface::replaceSubexpressionWithStatement</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *from, <a class="el" href="classSageInterface_1_1StatementGenerator.html">SageInterface::StatementGenerator</a> *to)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to replaceExpressionWithStatement, but with more restrictions.  <a href="#c8ce4794f2e0212a315bceb252fe93f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#abfd7a4f3af02dea61f7f808d0e60783">SageInterface::setOperand</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *target, <a class="el" href="classSgExpression.html">SgExpression</a> *operand)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set operands for expressions with single operand, such as unary expressions. handle file info, lvalue, pointer downcasting, parent pointer etc.  <a href="#abfd7a4f3af02dea61f7f808d0e60783"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#78098fceed35539df0aa51de3baba983">SageInterface::setLhsOperand</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *target, <a class="el" href="classSgExpression.html">SgExpression</a> *lhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set left hand operand for binary expressions, transparently downcasting target expressions when necessary  <a href="#78098fceed35539df0aa51de3baba983"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c30b58bb417c3b495f24207c81966716">SageInterface::setRhsOperand</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *target, <a class="el" href="classSgExpression.html">SgExpression</a> *rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set left hand operand for binary expression  <a href="#c30b58bb417c3b495f24207c81966716"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#76cf388fb6b43807542edf737bb97a96">SageInterface::removeAllOriginalExpressionTrees</a> (<a class="el" href="classSgNode.html">SgNode</a> *top)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set original expression trees to NULL for <a class="el" href="classSgValueExp.html">SgValueExp</a> or <a class="el" href="classSgCastExp.html">SgCastExp</a> expressions, so you can change the value and have it unparsed correctly.  <a href="#76cf388fb6b43807542edf737bb97a96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e348901720d34fdb3f333e552bcd5253">SageInterface::moveToSubdirectory</a> (std::string directoryName, <a class="el" href="classSgFile.html">SgFile</a> *file)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move file to be generated in a subdirectory (will be generated by the unparser).  <a href="#e348901720d34fdb3f333e552bcd5253"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#5b68578da4f96a5e644cfcb129a7e3dd">SageInterface::findSurroundingStatementFromSameFile</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *targetStmt, bool &amp;surroundingStatementPreceedsTargetStatement)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Supporting function to comment relocation in <a class="el" href="namespaceSageInterface.html#54e6780cc15a76ce7bc37a1212452e66">insertStatement()</a> and <a class="el" href="namespaceSageInterface.html#f5972a33cb2e9b5723e50ceccdaccb9f">removeStatement()</a>.  <a href="#5b68578da4f96a5e644cfcb129a7e3dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#accbb223ed5b025766c10745793d39c6">SageInterface::moveCommentsToNewStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *sourceStatement, const std::vector&lt; int &gt; &amp;indexList, <a class="el" href="classSgStatement.html">SgStatement</a> *targetStatement, bool surroundingStatementPreceedsTargetStatement)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Relocate comments and CPP directives from one statement to another.  <a href="#accbb223ed5b025766c10745793d39c6"></a><br></td></tr>
<tr><td colspan="2"><br><h2>AST repair, fix, and postprocessing.</h2></td></tr>
<tr><td colspan="2">Mostly used internally when some AST pieces are built without knowing their target scope/parent, especially during bottom-up construction of AST. The associated symbols, parent and scope pointers cannot be set on construction then. A set of utility functions are provided to patch up scope, parent, symbol for them when the target scope/parent become know. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#bc07365980c33e6d4f3cca65b2e73970">SageInterface::fixVariableReferences</a> (<a class="el" href="classSgNode.html">SgNode</a> *root)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect variable reference to the right variable symbols when feasible, return the number of references being fixed.  <a href="#bc07365980c33e6d4f3cca65b2e73970"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c56e358f18815a86ca4c9ad738733d37">SageInterface::fixVariableDeclaration</a> (<a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *varDecl, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Patch up symbol, scope, and parent information when a SgVariableDeclaration's scope is known.  <a href="#c56e358f18815a86ca4c9ad738733d37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#198dfdbeffb7cb4e282c0045de88b29d">SageInterface::fixStructDeclaration</a> (<a class="el" href="classSgClassDeclaration.html">SgClassDeclaration</a> *structDecl, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fix symbols, parent and scope pointers. Used internally within appendStatment(), <a class="el" href="namespaceSageInterface.html#54e6780cc15a76ce7bc37a1212452e66">insertStatement()</a> etc when a struct declaration was built without knowing its target scope.  <a href="#198dfdbeffb7cb4e282c0045de88b29d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4e2216ac11843189037ddb386cadbe9f">SageInterface::fixClassDeclaration</a> (<a class="el" href="classSgClassDeclaration.html">SgClassDeclaration</a> *classDecl, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fix symbols, parent and scope pointers. Used internally within appendStatment(), <a class="el" href="namespaceSageInterface.html#54e6780cc15a76ce7bc37a1212452e66">insertStatement()</a> etc when a class declaration was built without knowing its target scope.  <a href="#4e2216ac11843189037ddb386cadbe9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#0605947f38a73309b695c2511a6a008b">SageInterface::fixNamespaceDeclaration</a> (<a class="el" href="classSgNamespaceDeclarationStatement.html">SgNamespaceDeclarationStatement</a> *structDecl, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fix symbols, parent and scope pointers. Used internally within appendStatment(), <a class="el" href="namespaceSageInterface.html#54e6780cc15a76ce7bc37a1212452e66">insertStatement()</a> etc when a namespace declaration was built without knowing its target scope.  <a href="#0605947f38a73309b695c2511a6a008b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d8449795585ef098dedd58658b4ea265">SageInterface::fixLabelStatement</a> (<a class="el" href="classSgLabelStatement.html">SgLabelStatement</a> *label_stmt, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fix symbol table for <a class="el" href="classSgLabelStatement.html">SgLabelStatement</a>. Used Internally when the label is built without knowing its target scope. Both parameters cannot be NULL.  <a href="#d8449795585ef098dedd58658b4ea265"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#221ee5cf1957c22f8e37d2fa1ab96c68">SageInterface::setFortranNumericLabel</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, int label_value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a numerical label for a Fortran statement. The statement should have a enclosing function definition already. <a class="el" href="classSgLabelSymbol.html">SgLabelSymbol</a> and <a class="el" href="classSgLabelRefExp.html">SgLabelRefExp</a> are created transparently as needed.  <a href="#221ee5cf1957c22f8e37d2fa1ab96c68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#79b07f8a7d66fc51a0648df2940a5bf4">SageInterface::suggestNextNumericLabel</a> (<a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *func_def)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suggest next usable (non-conflicting) numeric label value for a Fortran function definition scope.  <a href="#79b07f8a7d66fc51a0648df2940a5bf4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#2410a8e2fc7310bd63c24d10b91594a3">SageInterface::fixStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A wrapper containing fixes (<a class="el" href="namespaceSageInterface.html#c56e358f18815a86ca4c9ad738733d37">fixVariableDeclaration()</a>,<a class="el" href="namespaceSageInterface.html#198dfdbeffb7cb4e282c0045de88b29d">fixStructDeclaration()</a>, <a class="el" href="namespaceSageInterface.html#d8449795585ef098dedd58658b4ea265">fixLabelStatement()</a>, etc) for all kinds statements. Should be used before attaching the statement into AST.  <a href="#2410a8e2fc7310bd63c24d10b91594a3"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Advanced AST transformations, analyses, and optimizations</h2></td></tr>
<tr><td colspan="2">Some complex but commonly used AST transformations. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#2f9dadd01d12ecdc779071da95843b83">SageInterface::collectReadWriteRefs</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, std::vector&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt; &amp;readRefs, std::vector&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt; &amp;writeRefs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collect all read and write references within stmt, which can be a function, a scope statement, or a single statement. Note that a reference can be both read and written, like i++.  <a href="#2f9dadd01d12ecdc779071da95843b83"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#11498284f603a3a574f02df0f44216b8">SageInterface::collectReadWriteVariables</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, std::set&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt; &amp;readVars, std::set&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt; &amp;writeVars)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collect unique variables which are read or written within a statement. Note that a variable can be both read and written. The statement can be either of a function, a scope, or a single line statement.  <a href="#11498284f603a3a574f02df0f44216b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#3dc3524267c97a90f85d723b462e4e8a">SageInterface::collectReadOnlyVariables</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, std::set&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt; &amp;readOnlyVars)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collect read only variables within a statement. The statement can be either of a function, a scope, or a single line statement.  <a href="#3dc3524267c97a90f85d723b462e4e8a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#7b50fd79f9c2175fea1fcfd8d66e8a7d">SageInterface::collectReadOnlySymbols</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, std::set&lt; <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> * &gt; &amp;readOnlySymbols)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collect read only variable symbols within a statement. The statement can be either of a function, a scope, or a single line statement.  <a href="#7b50fd79f9c2175fea1fcfd8d66e8a7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b854982b76a15a37881e460327d45b63">SageInterface::isUseByAddressVariableRef</a> (<a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> *ref)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a variable reference is used by its address: including &amp;a expression and foo(a) when type2 foo(Type&amp; parameter) in C++.  <a href="#b854982b76a15a37881e460327d45b63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#cff1c2e7a141a6360ad735dbe7d4dec8">SageInterface::collectUseByAddressVariableRefs</a> (const <a class="el" href="classSgStatement.html">SgStatement</a> *s, std::set&lt; <a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> * &gt; &amp;varSetB)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collect variable references involving use by address: including &amp;a expression and foo(a) when type2 foo(Type&amp; parameter) in C++.  <a href="#cff1c2e7a141a6360ad735dbe7d4dec8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LivenessAnalysis *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d0fbd473b56e24b39b63f354b7dd61a1">SageInterface::call_liveness_analysis</a> (<a class="el" href="classSgProject.html">SgProject</a> *<a class="el" href="namespacecfgUtils.html#ce4abf2beca5826144d69d3a0283050f">project</a>, bool debug=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call liveness analysis on an entire project.  <a href="#d0fbd473b56e24b39b63f354b7dd61a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#7f94ad31631659aacacfe540a97bcb11">SageInterface::getLiveVariables</a> (LivenessAnalysis *liv, <a class="el" href="classSgForStatement.html">SgForStatement</a> *loop, std::set&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt; &amp;liveIns, std::set&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt; &amp;liveOuts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get liveIn and liveOut variables for a for loop from liveness analysis result liv.  <a href="#7f94ad31631659aacacfe540a97bcb11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a3155e7a4a833e87637709baecd5638d">SageInterface::ReductionRecognition</a> (<a class="el" href="classSgForStatement.html">SgForStatement</a> *loop, std::set&lt; std::pair&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> *, <a class="el" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a> &gt; &gt; &amp;results)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recognize and collect reduction variables and operations within a C/C++ loop, following OpenMP 3.0 specification for allowed reduction variable types and operation types.  <a href="#a3155e7a4a833e87637709baecd5638d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#6f1a171284027fd38c91507a33a12023">SageInterface::constantFolding</a> (<a class="el" href="classSgNode.html">SgNode</a> *r)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant folding an AST subtree rooted at 'r' (replacing its children with their constant values, if applicable). Please be advised that constant folding on floating point computation may decrease the accuracy of floating point computations!  <a href="#6f1a171284027fd38c91507a33a12023"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4087541939de003c4cfb4a51e8ae4737">SageInterface::instrumentEndOfFunction</a> (<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *func, <a class="el" href="classSgStatement.html">SgStatement</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instrument(Add a statement, often a function call) into a function right before the return points, handle multiple return statements and return expressions with side effects. Return the number of statements inserted.  <a href="#4087541939de003c4cfb4a51e8ae4737"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b3b17e2ceead1e6fcbe2671d795859e0">SageInterface::removeJumpsToNextStatement</a> (<a class="el" href="classSgNode.html">SgNode</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove jumps whose label is immediately after the jump. Used to clean up inlined code fragments.  <a href="#b3b17e2ceead1e6fcbe2671d795859e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#1cf3641ce21620223f92f3b00477a50b">SageInterface::removeUnusedLabels</a> (<a class="el" href="classSgNode.html">SgNode</a> *top)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove labels which are not targets of any goto statements.  <a href="#1cf3641ce21620223f92f3b00477a50b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e674125d5affe065c68f6540217b544c">SageInterface::removeConsecutiveLabels</a> (<a class="el" href="classSgNode.html">SgNode</a> *top)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove consecutive labels.  <a href="#e674125d5affe065c68f6540217b544c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgAssignInitializer.html">SgAssignInitializer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#9a28f3454dc1161d208d0eafa27267d5">SageInterface::splitExpression</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *from, std::string newName=&quot;&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace an expression with a temporary variable and an assignment statement.  <a href="#9a28f3454dc1161d208d0eafa27267d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c6a4105eaf9ecae213078b24d5dfc69f">SageInterface::splitExpressionIntoBasicBlock</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *expr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split long expressions into blocks of statements.  <a href="#c6a4105eaf9ecae213078b24d5dfc69f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#72277a774aaa30427c7ba19a5ae0e64e">SageInterface::removeLabeledGotos</a> (<a class="el" href="classSgNode.html">SgNode</a> *top)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove labeled goto statements.  <a href="#72277a774aaa30427c7ba19a5ae0e64e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#2e6c3a91ffcb6a4a8e0a26dd39170498">SageInterface::changeBreakStatementsToGotos</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *loopOrSwitch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the given statement contains any break statements in its body, add a new label below the statement and change the breaks into gotos to that new label.  <a href="#2e6c3a91ffcb6a4a8e0a26dd39170498"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a9363b5ef0fa341b6a69f3143010d03f">SageInterface::ensureBasicBlockAsBodyOfFor</a> (<a class="el" href="classSgForStatement.html">SgForStatement</a> *fs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the body of a 'for' statement is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not.  <a href="#a9363b5ef0fa341b6a69f3143010d03f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4b91f29c299fd9d36d23215caca641a9">SageInterface::ensureBasicBlockAsBodyOfUpcForAll</a> (<a class="el" href="classSgUpcForAllStatement.html">SgUpcForAllStatement</a> *fs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the body of a 'upc_forall' statement is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not.  <a href="#4b91f29c299fd9d36d23215caca641a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b420709b668cbcb97caaa2ba7a311047">SageInterface::ensureBasicBlockAsBodyOfWhile</a> (<a class="el" href="classSgWhileStmt.html">SgWhileStmt</a> *ws)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the body of a 'while' statement is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not.  <a href="#b420709b668cbcb97caaa2ba7a311047"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#10f7e44426ec5cc6cf4878a9f8f3737b">SageInterface::ensureBasicBlockAsBodyOfDoWhile</a> (<a class="el" href="classSgDoWhileStmt.html">SgDoWhileStmt</a> *ws)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the body of a 'do .. while' statement is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not.  <a href="#10f7e44426ec5cc6cf4878a9f8f3737b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#2ee0c40fe00b9aa2e33f07a1f63d1c78">SageInterface::ensureBasicBlockAsBodyOfSwitch</a> (<a class="el" href="classSgSwitchStatement.html">SgSwitchStatement</a> *ws)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the body of a 'switch' statement is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not.  <a href="#2ee0c40fe00b9aa2e33f07a1f63d1c78"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#5dddc30ac598e407d4b675b48817321a">SageInterface::ensureBasicBlockAsTrueBodyOfIf</a> (<a class="el" href="classSgIfStmt.html">SgIfStmt</a> *ifs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the true body of a 'if' statement is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not.  <a href="#5dddc30ac598e407d4b675b48817321a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a0d91d1274666339221f3186847d220a">SageInterface::ensureBasicBlockAsFalseBodyOfIf</a> (<a class="el" href="classSgIfStmt.html">SgIfStmt</a> *ifs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the false body of a 'if' statement is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not.  <a href="#a0d91d1274666339221f3186847d220a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#273d390c4b54e9dc4c02c4806b3747a5">SageInterface::ensureBasicBlockAsBodyOfCatch</a> (<a class="el" href="classSgCatchOptionStmt.html">SgCatchOptionStmt</a> *cos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the body of a 'catch' statement is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not.  <a href="#273d390c4b54e9dc4c02c4806b3747a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#0434e3f30f7426d0ff371c936b2f1e5e">SageInterface::ensureBasicBlockAsBodyOfOmpBodyStmt</a> (<a class="el" href="classSgOmpBodyStatement.html">SgOmpBodyStatement</a> *ompbodyStmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the body of a <a class="el" href="classSgOmpBodyStatement.html">SgOmpBodyStatement</a> is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not.  <a href="#0434e3f30f7426d0ff371c936b2f1e5e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a72050df89f2aa4351288454d544b695">SageInterface::isBodyStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a statement is a (true or false) body of a container-like parent, such as For, Upc_forall, Do-while, switch, If, Catch, OmpBodyStmt, etc.  <a href="#a72050df89f2aa4351288454d544b695"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#f052fc07989bd2870022a0aa4f075d53">SageInterface::changeAllBodiesToBlocks</a> (<a class="el" href="classSgNode.html">SgNode</a> *top)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fix up ifs, loops, while, switch, Catch, OmpBodyStatement, etc. to have blocks as body components. It also adds an empty else body to if statements that don't have them.  <a href="#f052fc07989bd2870022a0aa4f075d53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#fd793e1727df3c73fbd8384ccc604272">SageInterface::changeAllLoopBodiesToBlocks</a> (<a class="el" href="classSgNode.html">SgNode</a> *top)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The same as <a class="el" href="namespaceSageInterface.html#f052fc07989bd2870022a0aa4f075d53">changeAllBodiesToBlocks(SgNode* top)</a>. To be phased out.  <a href="#fd793e1727df3c73fbd8384ccc604272"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#f3cb2f040226ce2af1234b4e94a60d15">SageInterface::makeSingleStatementBodyToBlock</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *singleStmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a single statement body to be a basic block. Its parent is if, while, catch, or upc_forall etc.  <a href="#f3cb2f040226ce2af1234b4e94a60d15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned long long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#7c34b2c7c9c66106eb13c6d253217b5e">SageInterface::getIntegerConstantValue</a> (<a class="el" href="classSgValueExp.html">SgValueExp</a> *expr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the constant value from a constant integer expression; abort on everything else.  <a href="#7c34b2c7c9c66106eb13c6d253217b5e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#318f7cf455f620d5deecb5f37d41f4fe">SageInterface::getDependentDeclarations</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a statement's dependent declarations which declares the types used in the statement. The returned vector of declaration statements are sorted according to their appearance order in the original AST. Any reference to a class or template class from a namespace will treated as a reference to the enclosing namespace.  <a href="#318f7cf455f620d5deecb5f37d41f4fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgCommaOpExp.html">SgCommaOpExp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#88ea6b1684ee9c306a48e10e8a13910b">SageInterface::insertBeforeUsingCommaOp</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *new_exp, <a class="el" href="classSgExpression.html">SgExpression</a> *anchor_exp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert an expression (new_exp )before another expression (anchor_exp) has possible side effects, without changing the original semantics. This is achieved by using a comma operator: (new_exp, anchor_exp). The comma operator is returned.  <a href="#88ea6b1684ee9c306a48e10e8a13910b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgCommaOpExp.html">SgCommaOpExp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#57851892650845148e67407bf2389fd2">SageInterface::insertAfterUsingCommaOp</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *new_exp, <a class="el" href="classSgExpression.html">SgExpression</a> *anchor_exp, <a class="el" href="classSgStatement.html">SgStatement</a> **temp_decl=NULL, <a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> **temp_ref=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert an expression (new_exp ) after another expression (anchor_exp) has possible side effects, without changing the original semantics. This is done by using two comma operators: type T1; ... ((T1 = anchor_exp, new_exp),T1) )... , where T1 is a temp variable saving the possible side effect of anchor_exp. The top level comma op exp is returned. The reference to T1 in T1 = anchor_exp is saved in temp_ref.  <a href="#57851892650845148e67407bf2389fd2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt; <a class="el" href="classSgStatement.html">SgStatement</a> *,<br>
 <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#db9d4a03d11809413cca4cac1dfc18a7">SageInterface::wrapFunction</a> (<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> &amp;definingDeclaration, <a class="el" href="classSgName.html">SgName</a> newName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">moves the body of a function f to a new function f`; f's body is replaced with code that forwards the call to f`.  <a href="#db9d4a03d11809413cca4cac1dfc18a7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class NameGen&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::pair&lt; <a class="el" href="classSgStatement.html">SgStatement</a> *,<br>
 <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#10d65c1ab5842a8ecb88b24abf0b562c">SageInterface::wrapFunction</a> (<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> &amp;definingDeclaration, NameGen nameGen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  NameGen functor that generates a new name based on the old name.see wrapFunction for details.  <a href="#10d65c1ab5842a8ecb88b24abf0b562c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgInitializedName.html">SgInitializedName</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e1fae2ae93d70efe722d0bde9473842e">SageInterface::getFirstVariable</a> (<a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> &amp;vardecl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">convenience function that returns the first initialized name in a list of variable declarations.  <a href="#e1fae2ae93d70efe722d0bde9473842e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sageInterface_8h.html#0f29691a809d5f799ffb9f3369dab99a">TRANS_FILE</a>&nbsp;&nbsp;&nbsp;Sg_File_Info::generateDefaultFileInfoForTransformationNode()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An alias for <a class="el" href="classSg__File__Info.html#a8665cf9099d92f8b03cc6a20fd14676">Sg_File_Info::generateDefaultFileInfoForTransformationNode()</a>.  <a href="#0f29691a809d5f799ffb9f3369dab99a"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgFile.html">SgFile</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sageInterface_8h.html#335d6f76b9197fefa4d538cd26675c37">determineFileType</a> (std::vector&lt; std::string &gt; argv, int &amp;nextErrorCode, <a class="el" href="classSgProject.html">SgProject</a> *<a class="el" href="namespacecfgUtils.html#ce4abf2beca5826144d69d3a0283050f">project</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sageInterface_8h.html#6d0cd96704022f21e971666b81840682">getVariantName</a> (<a class="el" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a> v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A global function for getting the string associated with an enum (which is defined in global scope).  <a href="#6d0cd96704022f21e971666b81840682"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a6670cd18aab211b99ab001c9e150575">SageInterface::getMainInterpretation</a> (<a class="el" href="classSgAsmGenericFile.html">SgAsmGenericFile</a> *file)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#20574ec78dea1f96ddfc689dcd6da9be">SageInterface::getAsmConstant</a> (<a class="el" href="classSgAsmValueExpression.html">SgAsmValueExpression</a> *e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the unsigned value of a disassembled constant.  <a href="#20574ec78dea1f96ddfc689dcd6da9be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#789ac1ef29111e96bf87fbd789dea421">SageInterface::getAsmSignedConstant</a> (<a class="el" href="classSgAsmValueExpression.html">SgAsmValueExpression</a> *e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the signed value of a disassembled constant.  <a href="#789ac1ef29111e96bf87fbd789dea421"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#21d19eaa21c197ce5c65363d225eb31d">SageInterface::addMessageStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, std::string message)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classFunction.html">Function</a> to add "C" style comment to statement.  <a href="#21d19eaa21c197ce5c65363d225eb31d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#732c7df1845f9c11495227cd9fa9e1e1">SageInterface::supplementReplacementSymbolMap</a> (rose_hash::unordered_map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, <a class="el" href="classSgNode.html">SgNode</a> *, hash_nodeptr &gt; &amp;inputReplacementMap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#7ee71882b367869506de6382d1b09cc2">SageInterface::updateDefiningNondefiningLinks</a> (<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *func, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update defining and nondefining links due to a newly introduced function declaration. Should be used after inserting the function into a scope.  <a href="#7ee71882b367869506de6382d1b09cc2"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c634a179b840b4d55d9b32e0288fb1b4">SageInterface::gensym_counter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An internal counter for generating unique <a class="el" href="classSgName.html">SgName</a>.  <a href="#c634a179b840b4d55d9b32e0288fb1b4"></a><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="0f29691a809d5f799ffb9f3369dab99a"></a><!-- doxytag: member="sageInterface.h::TRANS_FILE" ref="0f29691a809d5f799ffb9f3369dab99a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TRANS_FILE&nbsp;&nbsp;&nbsp;Sg_File_Info::generateDefaultFileInfoForTransformationNode()          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
An alias for <a class="el" href="classSg__File__Info.html#a8665cf9099d92f8b03cc6a20fd14676">Sg_File_Info::generateDefaultFileInfoForTransformationNode()</a>. 
<p>

<p>
Definition at line <a class="el" href="sageInterface_8h-source.html#l00052">52</a> of file <a class="el" href="sageInterface_8h-source.html">sageInterface.h</a>.
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="335d6f76b9197fefa4d538cd26675c37"></a><!-- doxytag: member="sageInterface.h::determineFileType" ref="335d6f76b9197fefa4d538cd26675c37" args="(std::vector&lt; std::string &gt; argv, int &amp;nextErrorCode, SgProject *project)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgFile.html">SgFile</a>* determineFileType           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&nbsp;</td>
          <td class="paramname"> <em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>nextErrorCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgProject.html">SgProject</a> *&nbsp;</td>
          <td class="paramname"> <em>project</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6d0cd96704022f21e971666b81840682"></a><!-- doxytag: member="sageInterface.h::getVariantName" ref="6d0cd96704022f21e971666b81840682" args="(VariantT v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string getVariantName           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a>&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A global function for getting the string associated with an enum (which is defined in global scope). 
<p>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
