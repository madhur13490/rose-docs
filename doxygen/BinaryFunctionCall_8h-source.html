<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: BinaryFunctionCall.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>BinaryFunctionCall.h</h1><a href="BinaryFunctionCall_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef ROSE_BinaryAnalysis_FunctionCall_H</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define ROSE_BinaryAnalysis_FunctionCall_H</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="preprocessor">#include "<a class="code" href="BinaryControlFlow_8h.html">BinaryControlFlow.h</a>"</span>
<a name="l00005"></a>00005 
<a name="l00006"></a>00006 <span class="keyword">class </span><a class="code" href="classSgAsmFunction.html">SgAsmFunction</a>;
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 <span class="keyword">namespace </span>BinaryAnalysis {
<a name="l00009"></a>00009 
<a name="l00018"></a><a class="code" href="classBinaryAnalysis_1_1FunctionCall.html">00018</a>     <span class="keyword">class </span><a class="code" href="classBinaryAnalysis_1_1FunctionCall.html">FunctionCall</a> {
<a name="l00019"></a>00019     <span class="keyword">public</span>:
<a name="l00020"></a>00020 
<a name="l00021"></a><a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#b4f7f47cc9da605adb5822828d9b545f">00021</a>         <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#b4f7f47cc9da605adb5822828d9b545f">FunctionCall</a>()
<a name="l00022"></a>00022             : <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#15c397e82988733b7c46d06448f12507">vertex_filter</a>(NULL), <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#bb01f23a6d097056b4503bf3246e5312">edge_filter</a>(NULL)
<a name="l00023"></a>00023             {}
<a name="l00024"></a>00024 
<a name="l00049"></a>00049         <span class="keyword">typedef</span> boost::adjacency_list&lt;boost::setS,                                  <span class="comment">/* out-edges of each vertex in std::list */</span>
<a name="l00050"></a>00050                                       boost::vecS,                                  <span class="comment">/* store vertices in std::vector */</span>
<a name="l00051"></a>00051                                       boost::bidirectionalS,                        <span class="comment">/* call graph is directed */</span>
<a name="l00052"></a>00052                                       boost::property&lt;boost::vertex_name_t, SgAsmFunction*&gt;
<a name="l00053"></a><a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#2532d28ee1226ae45fd43cc6c660ceac">00053</a>                                      &gt; <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#2532d28ee1226ae45fd43cc6c660ceac">Graph</a>;
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 
<a name="l00056"></a>00056         <span class="comment">/**********************************************************************************************************************</span>
<a name="l00057"></a>00057 <span class="comment">         *                                      Filters</span>
<a name="l00058"></a>00058 <span class="comment">         **********************************************************************************************************************/</span>
<a name="l00059"></a>00059     <span class="keyword">public</span>:
<a name="l00060"></a>00060 
<a name="l00065"></a><a class="code" href="classBinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html">00065</a>         <span class="keyword">class </span><a class="code" href="classBinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html">VertexFilter</a> {
<a name="l00066"></a>00066         <span class="keyword">public</span>:
<a name="l00067"></a><a class="code" href="classBinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html#15e258747b9ca83490010be6b706a19d">00067</a>             <span class="keyword">virtual</span> <a class="code" href="classBinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html#15e258747b9ca83490010be6b706a19d">~VertexFilter</a>() {}
<a name="l00068"></a>00068             <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classBinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html#ed3b1ec2180208ccb49c727cd705c906">operator()</a>(<a class="code" href="classBinaryAnalysis_1_1FunctionCall.html">FunctionCall</a>*, <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a>*) = 0;
<a name="l00069"></a>00069         };
<a name="l00070"></a>00070 
<a name="l00075"></a><a class="code" href="classBinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html">00075</a>         <span class="keyword">class </span><a class="code" href="classBinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html">EdgeFilter</a> {
<a name="l00076"></a>00076         <span class="keyword">public</span>:
<a name="l00077"></a><a class="code" href="classBinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html#83836e9694d6af80aff3e4e7996242b2">00077</a>             <span class="keyword">virtual</span> <a class="code" href="classBinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html#83836e9694d6af80aff3e4e7996242b2">~EdgeFilter</a>() {}
<a name="l00078"></a>00078             <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classBinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html#c5eb68008c40e688dfebbe44bd02e788">operator()</a>(<a class="code" href="classBinaryAnalysis_1_1FunctionCall.html">FunctionCall</a>*, <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *source, <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *target) = 0;
<a name="l00079"></a>00079         };
<a name="l00080"></a>00080 
<a name="l00088"></a><a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#2a2742416189f2254f44c6e9c9d2f6a8">00088</a>         <span class="keywordtype">void</span> <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#2a2742416189f2254f44c6e9c9d2f6a8">set_vertex_filter</a>(<a class="code" href="classBinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html">VertexFilter</a> *filter) { <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#15c397e82988733b7c46d06448f12507">vertex_filter</a> = filter; }
<a name="l00089"></a><a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#24444c917456113162c36329f3927c4f">00089</a>         <a class="code" href="classBinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html">VertexFilter</a> *<a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#24444c917456113162c36329f3927c4f">get_vertex_filter</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#15c397e82988733b7c46d06448f12507">vertex_filter</a>; }
<a name="l00098"></a><a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#45dbebd296a340cbd7c0fcba4a0bb9e1">00098</a>         <span class="keywordtype">void</span> <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#45dbebd296a340cbd7c0fcba4a0bb9e1">set_edge_filter</a>(<a class="code" href="classBinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html">EdgeFilter</a> *filter) { <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#bb01f23a6d097056b4503bf3246e5312">edge_filter</a> = filter; }
<a name="l00099"></a><a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#ef508972512bbc8ab37f859f918d6985">00099</a>         <a class="code" href="classBinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html">EdgeFilter</a> *<a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#ef508972512bbc8ab37f859f918d6985">get_edge_filter</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#bb01f23a6d097056b4503bf3246e5312">edge_filter</a>; }
<a name="l00107"></a><a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#a59d513bee13e8339937d35517b018a3">00107</a>         <span class="keywordtype">bool</span> <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#a59d513bee13e8339937d35517b018a3">is_vertex_filtered</a>(<a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *func, <a class="code" href="classBinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html">VertexFilter</a> *filter) {
<a name="l00108"></a>00108             <span class="keywordflow">return</span> filter &amp;&amp; !(*filter)(<span class="keyword">this</span>, func);
<a name="l00109"></a>00109         }
<a name="l00110"></a><a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#e236e4da49ba54eb2368913967ec9dcd">00110</a>         <span class="keywordtype">bool</span> <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#a59d513bee13e8339937d35517b018a3">is_vertex_filtered</a>(<a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *func) {
<a name="l00111"></a>00111             <span class="keywordflow">return</span> <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#a59d513bee13e8339937d35517b018a3">is_vertex_filtered</a>(func, <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#15c397e82988733b7c46d06448f12507">vertex_filter</a>);
<a name="l00112"></a>00112         }
<a name="l00120"></a><a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#3db7e3b728529310098bc4218b618a80">00120</a>         <span class="keywordtype">bool</span> <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#3db7e3b728529310098bc4218b618a80">is_edge_filtered</a>(<a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *src, <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *dst, <a class="code" href="classBinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html">EdgeFilter</a> *filter) {
<a name="l00121"></a>00121             <span class="keywordflow">return</span> filter &amp;&amp; !(*filter)(<span class="keyword">this</span>, src, dst);
<a name="l00122"></a>00122         }
<a name="l00123"></a><a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#7e553622e6f012bfbee95a3e2f36b6ed">00123</a>         <span class="keywordtype">bool</span> <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#3db7e3b728529310098bc4218b618a80">is_edge_filtered</a>(<a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *src, <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *dst) {
<a name="l00124"></a>00124             <span class="keywordflow">return</span> <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#3db7e3b728529310098bc4218b618a80">is_edge_filtered</a>(src, dst, <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#bb01f23a6d097056b4503bf3246e5312">edge_filter</a>);
<a name="l00125"></a>00125         }
<a name="l00128"></a>00128     <span class="keyword">protected</span>:
<a name="l00129"></a><a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#15c397e82988733b7c46d06448f12507">00129</a>         <a class="code" href="classBinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html">VertexFilter</a> *<a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#15c397e82988733b7c46d06448f12507">vertex_filter</a>;
<a name="l00130"></a><a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#bb01f23a6d097056b4503bf3246e5312">00130</a>         <a class="code" href="classBinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html">EdgeFilter</a> *<a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#bb01f23a6d097056b4503bf3246e5312">edge_filter</a>;
<a name="l00131"></a>00131 
<a name="l00132"></a>00132         <span class="comment">/**********************************************************************************************************************</span>
<a name="l00133"></a>00133 <span class="comment">         *                                      Methods that modify the AST</span>
<a name="l00134"></a>00134 <span class="comment">         **********************************************************************************************************************/</span>
<a name="l00135"></a>00135     <span class="keyword">public</span>:
<a name="l00136"></a>00136 
<a name="l00151"></a>00151         <span class="keyword">template</span>&lt;<span class="keyword">class</span> FunctionCallGraph&gt;
<a name="l00152"></a>00152         <span class="keywordtype">void</span> <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#2eba696d163fb97e4e08d26c62f92649">cache_vertex_descriptors</a>(<span class="keyword">const</span> FunctionCallGraph&amp;);
<a name="l00153"></a>00153 
<a name="l00154"></a>00154         <span class="comment">/**********************************************************************************************************************</span>
<a name="l00155"></a>00155 <span class="comment">         *                                      Graph construction methods</span>
<a name="l00156"></a>00156 <span class="comment">         **********************************************************************************************************************/</span>
<a name="l00157"></a>00157     <span class="keyword">public</span>:
<a name="l00158"></a>00158 
<a name="l00170"></a>00170         <span class="keyword">template</span>&lt;<span class="keyword">class</span> FunctionCallGraph, <span class="keyword">class</span> ControlFlowGraph&gt;
<a name="l00171"></a>00171         FunctionCallGraph <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#ccf917f4d9602275b854cc1cf0e2bf48">build_cg_from_cfg</a>(<span class="keyword">const</span> ControlFlowGraph&amp;);
<a name="l00172"></a>00172 
<a name="l00173"></a>00173         <span class="keyword">template</span>&lt;<span class="keyword">class</span> ControlFlowGraph, <span class="keyword">class</span> FunctionCallGraph&gt;
<a name="l00174"></a>00174         <span class="keywordtype">void</span> <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#ccf917f4d9602275b854cc1cf0e2bf48">build_cg_from_cfg</a>(<span class="keyword">const</span> ControlFlowGraph &amp;<a class="code" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>, FunctionCallGraph &amp;cg<span class="comment">/*out*/</span>);
<a name="l00204"></a>00204         <span class="keyword">template</span>&lt;<span class="keyword">class</span> FunctionCallGraph&gt;
<a name="l00205"></a>00205         FunctionCallGraph <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#0a66374f57c8167400aeca97cfe83854">build_cg_from_ast</a>(<a class="code" href="classSgNode.html">SgNode</a> *root);
<a name="l00206"></a>00206 
<a name="l00207"></a>00207         <span class="keyword">template</span>&lt;<span class="keyword">class</span> FunctionCallGraph&gt;
<a name="l00208"></a>00208         <span class="keywordtype">void</span> <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#0a66374f57c8167400aeca97cfe83854">build_cg_from_ast</a>(<a class="code" href="classSgNode.html">SgNode</a> *root, FunctionCallGraph &amp;cg<span class="comment">/*out*/</span>);
<a name="l00221"></a>00221         <span class="keyword">template</span>&lt;<span class="keyword">class</span> FunctionCallGraph&gt;
<a name="l00222"></a>00222         FunctionCallGraph <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#6e95c76343bf40c6d438f41144073b39">copy</a>(<span class="keyword">const</span> FunctionCallGraph &amp;src);
<a name="l00223"></a>00223         <span class="keyword">template</span>&lt;<span class="keyword">class</span> FunctionCallGraph&gt;
<a name="l00224"></a>00224         <span class="keywordtype">void</span> <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#6e95c76343bf40c6d438f41144073b39">copy</a>(<span class="keyword">const</span> FunctionCallGraph &amp;src, FunctionCallGraph &amp;dst<span class="comment">/*out*/</span>);
<a name="l00227"></a>00227     };
<a name="l00228"></a>00228 }
<a name="l00229"></a>00229 
<a name="l00230"></a>00230 
<a name="l00231"></a>00231 
<a name="l00232"></a>00232 <span class="comment">/******************************************************************************************************************************</span>
<a name="l00233"></a>00233 <span class="comment"> *                                      Function template definitions</span>
<a name="l00234"></a>00234 <span class="comment"> ******************************************************************************************************************************/</span>
<a name="l00235"></a>00235 
<a name="l00236"></a>00236 <span class="keyword">template</span>&lt;<span class="keyword">class</span> FunctionCallGraph&gt;
<a name="l00237"></a>00237 <span class="keywordtype">void</span>
<a name="l00238"></a><a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#2eba696d163fb97e4e08d26c62f92649">00238</a> <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#2eba696d163fb97e4e08d26c62f92649">BinaryAnalysis::FunctionCall::cache_vertex_descriptors</a>(<span class="keyword">const</span> FunctionCallGraph &amp;cg)
<a name="l00239"></a>00239 {
<a name="l00240"></a>00240     <span class="keyword">typename</span> <a class="code" href="yicesParserLib_8h.html#01a59c9f4634ace001a235e23a2bc31d">boost::graph_traits&lt;FunctionCallGraph&gt;::vertex_iterator</a> vi, vi_end;
<a name="l00241"></a>00241     <span class="keywordflow">for</span> (boost::tie(vi, vi_end)=vertices(cg); vi!=vi_end; ++vi) {
<a name="l00242"></a>00242         <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *func = get(boost::vertex_name, cg, *vi);
<a name="l00243"></a>00243         <span class="keywordflow">if</span> (func &amp;&amp; !<a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#a59d513bee13e8339937d35517b018a3">is_vertex_filtered</a>(func))
<a name="l00244"></a>00244             func-&gt;set_cached_vertex(*vi);
<a name="l00245"></a>00245     }
<a name="l00246"></a>00246 }
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 <span class="keyword">template</span>&lt;<span class="keyword">class</span> ControlFlowGraph, <span class="keyword">class</span> FunctionCallGraph&gt;
<a name="l00249"></a>00249 <span class="keywordtype">void</span>
<a name="l00250"></a><a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#c878096df46fe62d3a8f7e05aa0c42cd">00250</a> <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#ccf917f4d9602275b854cc1cf0e2bf48">BinaryAnalysis::FunctionCall::build_cg_from_cfg</a>(<span class="keyword">const</span> ControlFlowGraph &amp;<a class="code" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>, FunctionCallGraph &amp;cg<span class="comment">/*out*/</span>)
<a name="l00251"></a>00251 {
<a name="l00252"></a>00252     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::graph_traits&lt;FunctionCallGraph&gt;::vertex_descriptor CG_Vertex;
<a name="l00253"></a>00253     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::graph_traits&lt;ControlFlowGraph&gt;::vertex_descriptor CFG_Vertex;
<a name="l00254"></a>00254     <span class="keyword">typedef</span> std::map&lt;SgAsmFunction*, CG_Vertex&gt; FunctionVertexMap;
<a name="l00255"></a>00255 
<a name="l00256"></a>00256     cg.clear();
<a name="l00257"></a>00257 
<a name="l00258"></a>00258     <span class="comment">/* Add CG vertices by collapsing CFG nodes that belong to a common function. */</span>
<a name="l00259"></a>00259     FunctionVertexMap fv_map;
<a name="l00260"></a>00260     <span class="keyword">typename</span> <a class="code" href="yicesParserLib_8h.html#01a59c9f4634ace001a235e23a2bc31d">boost::graph_traits&lt;ControlFlowGraph&gt;::vertex_iterator</a> vi, vi_end;
<a name="l00261"></a>00261     <span class="keywordflow">for</span> (boost::tie(vi, vi_end)=vertices(cfg); vi!=vi_end; ++vi) {
<a name="l00262"></a>00262         <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *block = get(boost::vertex_name, cfg, *vi);
<a name="l00263"></a>00263         <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *func = block-&gt;get_enclosing_function();
<a name="l00264"></a>00264         <span class="keywordflow">if</span> (!<a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#a59d513bee13e8339937d35517b018a3">is_vertex_filtered</a>(func)) {
<a name="l00265"></a>00265             <span class="keyword">typename</span> FunctionVertexMap::iterator fi=fv_map.find(func);
<a name="l00266"></a>00266             <span class="keywordflow">if</span> (func &amp;&amp; fi==fv_map.end()) {
<a name="l00267"></a>00267                 CG_Vertex v = add_vertex(cg);
<a name="l00268"></a>00268                 put(boost::vertex_name, cg, v, func);
<a name="l00269"></a>00269                 fv_map[func] = v;
<a name="l00270"></a>00270             }
<a name="l00271"></a>00271         }
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273 
<a name="l00274"></a>00274     <span class="comment">/* Add edges whose target is a function entry block. */</span>
<a name="l00275"></a>00275     <span class="keyword">typename</span> <a class="code" href="yicesParserLib_8h.html#c5f273d32fb3bb35cf86b98e401fe9b6">boost::graph_traits&lt;ControlFlowGraph&gt;::edge_iterator</a> ei, ei_end;
<a name="l00276"></a>00276     <span class="keywordflow">for</span> (boost::tie(ei, ei_end)=edges(cfg); ei!=ei_end; ++ei) {
<a name="l00277"></a>00277         CFG_Vertex cfg_a = source(*ei, cfg);
<a name="l00278"></a>00278         CFG_Vertex cfg_b = target(*ei, cfg);
<a name="l00279"></a>00279         <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *block_a = get(boost::vertex_name, cfg, cfg_a);
<a name="l00280"></a>00280         <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *block_b = get(boost::vertex_name, cfg, cfg_b);
<a name="l00281"></a>00281         <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *func_a = block_a-&gt;<a class="code" href="classSgAsmBlock.html#bdd6257d93832cc2b0dcbdf07f9ccd3c">get_enclosing_function</a>();
<a name="l00282"></a>00282         <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *func_b = block_b-&gt;<a class="code" href="classSgAsmBlock.html#bdd6257d93832cc2b0dcbdf07f9ccd3c">get_enclosing_function</a>();
<a name="l00283"></a>00283         <span class="keywordflow">if</span> (func_a &amp;&amp; func_b &amp;&amp; block_b==func_b-&gt;<a class="code" href="classSgAsmFunction.html#89be684ba50382920d018616cfe74f86">get_entry_block</a>() &amp;&amp; !<a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#3db7e3b728529310098bc4218b618a80">is_edge_filtered</a>(func_a, func_b)) {
<a name="l00284"></a>00284             <span class="keyword">typename</span> FunctionVertexMap::iterator fi_a = fv_map.find(func_a);
<a name="l00285"></a>00285             <span class="keywordflow">if</span> (fi_a!=fv_map.end()) {
<a name="l00286"></a>00286                 <span class="keyword">typename</span> FunctionVertexMap::iterator fi_b = fv_map.find(func_b);
<a name="l00287"></a>00287                 <span class="keywordflow">if</span> (fi_b!=fv_map.end())
<a name="l00288"></a>00288                     add_edge(fi_a-&gt;second, fi_b-&gt;second, cg);
<a name="l00289"></a>00289             }
<a name="l00290"></a>00290         }
<a name="l00291"></a>00291     }
<a name="l00292"></a>00292 }
<a name="l00293"></a>00293 
<a name="l00294"></a>00294 <span class="keyword">template</span>&lt;<span class="keyword">class</span> FunctionCallGraph, <span class="keyword">class</span> ControlFlowGraph&gt;
<a name="l00295"></a>00295 FunctionCallGraph
<a name="l00296"></a><a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#ccf917f4d9602275b854cc1cf0e2bf48">00296</a> <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#ccf917f4d9602275b854cc1cf0e2bf48">BinaryAnalysis::FunctionCall::build_cg_from_cfg</a>(<span class="keyword">const</span> ControlFlowGraph &amp;<a class="code" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>)
<a name="l00297"></a>00297 {
<a name="l00298"></a>00298     FunctionCallGraph cg;
<a name="l00299"></a>00299     <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#ccf917f4d9602275b854cc1cf0e2bf48">build_cg_from_cfg</a>(cfg, cg);
<a name="l00300"></a>00300     <span class="keywordflow">return</span> cg;
<a name="l00301"></a>00301 }
<a name="l00302"></a>00302 
<a name="l00303"></a>00303 <span class="keyword">template</span>&lt;<span class="keyword">class</span> FunctionCallGraph&gt;
<a name="l00304"></a>00304 <span class="keywordtype">void</span>
<a name="l00305"></a><a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#45bddd25d52248c3b72797696bf06dcb">00305</a> <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#0a66374f57c8167400aeca97cfe83854">BinaryAnalysis::FunctionCall::build_cg_from_ast</a>(<a class="code" href="classSgNode.html">SgNode</a> *root, FunctionCallGraph &amp;cg<span class="comment">/*out*/</span>)
<a name="l00306"></a>00306 {
<a name="l00307"></a>00307     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::graph_traits&lt;FunctionCallGraph&gt;::vertex_descriptor <a class="code" href="structVertex.html">Vertex</a>;
<a name="l00308"></a>00308     <span class="keyword">typedef</span> std::map&lt;SgAsmFunction*, Vertex&gt; FunctionVertexMap;
<a name="l00309"></a>00309     FunctionVertexMap fv_map;
<a name="l00310"></a>00310 
<a name="l00311"></a>00311     cg.clear();
<a name="l00312"></a>00312 
<a name="l00313"></a>00313     <span class="comment">/* Visiter that adds a vertex for each unique function. */</span>
<a name="l00314"></a>00314     <span class="keyword">struct </span>VertexAdder: <span class="keyword">public</span> <a class="code" href="classAstSimpleProcessing.html">AstSimpleProcessing</a> {
<a name="l00315"></a>00315         <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html">FunctionCall</a> *analyzer;
<a name="l00316"></a>00316         FunctionCallGraph &amp;cg;
<a name="l00317"></a>00317         FunctionVertexMap &amp;fv_map;
<a name="l00318"></a>00318         VertexAdder(<a class="code" href="classBinaryAnalysis_1_1FunctionCall.html">FunctionCall</a> *analyzer, FunctionCallGraph &amp;cg, FunctionVertexMap &amp;fv_map)
<a name="l00319"></a>00319             : analyzer(analyzer), cg(cg), fv_map(fv_map)
<a name="l00320"></a>00320             {}
<a name="l00321"></a>00321         <span class="keywordtype">void</span> visit(<a class="code" href="classSgNode.html">SgNode</a> *node) {
<a name="l00322"></a>00322             <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *func = <a class="code" href="Cxx__Grammar_8h.html#3374b86a87959b6a02d8ca8f792d693e">isSgAsmFunction</a>(node);
<a name="l00323"></a>00323             <span class="keywordflow">if</span> (func &amp;&amp; !analyzer-&gt;<a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#a59d513bee13e8339937d35517b018a3">is_vertex_filtered</a>(func)) {
<a name="l00324"></a>00324                 Vertex vertex = add_vertex(cg);
<a name="l00325"></a>00325                 fv_map[func] = vertex;
<a name="l00326"></a>00326                 put(boost::vertex_name, cg, vertex, func);
<a name="l00327"></a>00327             }
<a name="l00328"></a>00328         }
<a name="l00329"></a>00329     };
<a name="l00330"></a>00330 
<a name="l00331"></a>00331     <span class="comment">/* Visitor that adds edges for each vertex.  Traversal should be over one function at a time. */</span>
<a name="l00332"></a>00332     <span class="keyword">struct </span>EdgeAdder: <span class="keyword">public</span> <a class="code" href="classAstSimpleProcessing.html">AstSimpleProcessing</a> {
<a name="l00333"></a>00333         <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html">FunctionCall</a> *analyzer;
<a name="l00334"></a>00334         FunctionCallGraph &amp;cg;
<a name="l00335"></a>00335         FunctionVertexMap &amp;fv_map;
<a name="l00336"></a>00336         Vertex source_vertex;
<a name="l00337"></a>00337         EdgeAdder(<a class="code" href="classBinaryAnalysis_1_1FunctionCall.html">FunctionCall</a> *analyzer, FunctionCallGraph &amp;cg, FunctionVertexMap &amp;fv_map, Vertex source_vertex)
<a name="l00338"></a>00338             : analyzer(analyzer), cg(cg), fv_map(fv_map), source_vertex(source_vertex)
<a name="l00339"></a>00339             {}
<a name="l00340"></a>00340         <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *function_of(<a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *block) {
<a name="l00341"></a>00341             <span class="keywordflow">return</span> block ? block-&gt;<a class="code" href="classSgAsmBlock.html#bdd6257d93832cc2b0dcbdf07f9ccd3c">get_enclosing_function</a>() : NULL;
<a name="l00342"></a>00342         }
<a name="l00343"></a>00343         <span class="keywordtype">void</span> visit(<a class="code" href="classSgNode.html">SgNode</a> *node) {
<a name="l00344"></a>00344             <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *block_a = <a class="code" href="Cxx__Grammar_8h.html#0f21c6b7a4aede1900e16a5122233a83">isSgAsmBlock</a>(node); <span class="comment">/* the calling block */</span>
<a name="l00345"></a>00345             <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *func_a = function_of(block_a); <span class="comment">/* the calling function */</span>
<a name="l00346"></a>00346             <span class="keywordflow">if</span> (!func_a)
<a name="l00347"></a>00347                 <span class="keywordflow">return</span>;
<a name="l00348"></a>00348             <span class="keyword">const</span> <a class="code" href="Cxx__Grammar_8h.html#3976571c70181bee479389764f0b7eea">SgAsmIntegerValuePtrList</a> &amp;succs = block_a-&gt;<a class="code" href="classSgAsmBlock.html#0e798d793c22e6d6a63a526b6a18e7ce">get_successors</a>();
<a name="l00349"></a>00349             <span class="keywordflow">for</span> (SgAsmIntegerValuePtrList::const_iterator si=succs.begin(); si!=succs.end(); ++si) {
<a name="l00350"></a>00350                 <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *block_b = <a class="code" href="Cxx__Grammar_8h.html#0f21c6b7a4aede1900e16a5122233a83">isSgAsmBlock</a>((*si)-&gt;get_base_node()); <span class="comment">/* the called block */</span>
<a name="l00351"></a>00351                 <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *func_b = function_of(block_b); <span class="comment">/* the called function */</span>
<a name="l00352"></a>00352                 <span class="keywordflow">if</span> (func_b &amp;&amp; block_b==func_b-&gt;<a class="code" href="classSgAsmFunction.html#89be684ba50382920d018616cfe74f86">get_entry_block</a>() &amp;&amp; !analyzer-&gt;<a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#3db7e3b728529310098bc4218b618a80">is_edge_filtered</a>(func_a, func_b)) {
<a name="l00353"></a>00353                     <span class="keyword">typename</span> FunctionVertexMap::iterator fi_b = fv_map.find(func_b); <span class="comment">/* find vertex for called function */</span>
<a name="l00354"></a>00354                     <span class="keywordflow">if</span> (fi_b!=fv_map.end())
<a name="l00355"></a>00355                         add_edge(source_vertex, fi_b-&gt;second, cg);
<a name="l00356"></a>00356                 }
<a name="l00357"></a>00357             }
<a name="l00358"></a>00358         }
<a name="l00359"></a>00359     };
<a name="l00360"></a>00360 
<a name="l00361"></a>00361     VertexAdder(<span class="keyword">this</span>, cg, fv_map).traverse(root, <a class="code" href="Cxx__Grammar_8h.html#59f7fee88581c4dd75f5fb25dbefa29edefb5d09673c144dc5b4dc177e278696">preorder</a>);
<a name="l00362"></a>00362     <span class="keyword">typename</span> <a class="code" href="yicesParserLib_8h.html#01a59c9f4634ace001a235e23a2bc31d">boost::graph_traits&lt;FunctionCallGraph&gt;::vertex_iterator</a> vi, vi_end;
<a name="l00363"></a>00363     <span class="keywordflow">for</span> (boost::tie(vi, vi_end)=vertices(cg); vi!=vi_end; ++vi) {
<a name="l00364"></a>00364         <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *source_func = get(boost::vertex_name, cg, *vi);
<a name="l00365"></a>00365         EdgeAdder(<span class="keyword">this</span>, cg, fv_map, *vi).traverse(source_func, <a class="code" href="Cxx__Grammar_8h.html#59f7fee88581c4dd75f5fb25dbefa29edefb5d09673c144dc5b4dc177e278696">preorder</a>);
<a name="l00366"></a>00366     }
<a name="l00367"></a>00367 }
<a name="l00368"></a>00368 
<a name="l00369"></a>00369 <span class="keyword">template</span>&lt;<span class="keyword">class</span> FunctionCallGraph&gt;
<a name="l00370"></a>00370 FunctionCallGraph
<a name="l00371"></a><a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#0a66374f57c8167400aeca97cfe83854">00371</a> <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#0a66374f57c8167400aeca97cfe83854">BinaryAnalysis::FunctionCall::build_cg_from_ast</a>(<a class="code" href="classSgNode.html">SgNode</a> *root)
<a name="l00372"></a>00372 {
<a name="l00373"></a>00373     FunctionCallGraph cg;
<a name="l00374"></a>00374     <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#0a66374f57c8167400aeca97cfe83854">build_cg_from_ast</a>(root, cg);
<a name="l00375"></a>00375     <span class="keywordflow">return</span> cg;
<a name="l00376"></a>00376 }
<a name="l00377"></a>00377 
<a name="l00378"></a>00378 <span class="keyword">template</span>&lt;<span class="keyword">class</span> FunctionCallGraph&gt;
<a name="l00379"></a>00379 <span class="keywordtype">void</span>
<a name="l00380"></a><a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#90912264c06269fdbee78f1399e6099b">00380</a> <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#6e95c76343bf40c6d438f41144073b39">BinaryAnalysis::FunctionCall::copy</a>(<span class="keyword">const</span> FunctionCallGraph &amp;src, FunctionCallGraph &amp;dst)
<a name="l00381"></a>00381 {
<a name="l00382"></a>00382     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::graph_traits&lt;FunctionCallGraph&gt;::vertex_descriptor <a class="code" href="structVertex.html">Vertex</a>;
<a name="l00383"></a>00383     Vertex NO_VERTEX = <span class="keyword">typename</span> boost::graph_traits&lt;FunctionCallGraph&gt;::null_vertex();
<a name="l00384"></a>00384 
<a name="l00385"></a>00385     dst.clear();
<a name="l00386"></a>00386     std::vector&lt;Vertex&gt; src_to_dst(num_vertices(src), NO_VERTEX);
<a name="l00387"></a>00387 
<a name="l00388"></a>00388     <span class="keyword">typename</span> <a class="code" href="yicesParserLib_8h.html#01a59c9f4634ace001a235e23a2bc31d">boost::graph_traits&lt;FunctionCallGraph&gt;::vertex_iterator</a> vi, vi_end;
<a name="l00389"></a>00389     <span class="keywordflow">for</span> (boost::tie(vi, vi_end)=vertices(src); vi!=vi_end; ++vi) {
<a name="l00390"></a>00390         <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *func = get(boost::vertex_name, src, *vi);
<a name="l00391"></a>00391         <span class="keywordflow">if</span> (!<a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#a59d513bee13e8339937d35517b018a3">is_vertex_filtered</a>(func)) {
<a name="l00392"></a>00392             src_to_dst[*vi] = add_vertex(dst);
<a name="l00393"></a>00393             put(boost::vertex_name, dst, src_to_dst[*vi], func);
<a name="l00394"></a>00394         }
<a name="l00395"></a>00395     }
<a name="l00396"></a>00396 
<a name="l00397"></a>00397     <span class="keyword">typename</span> <a class="code" href="yicesParserLib_8h.html#c5f273d32fb3bb35cf86b98e401fe9b6">boost::graph_traits&lt;FunctionCallGraph&gt;::edge_iterator</a> ei, ei_end;
<a name="l00398"></a>00398     <span class="keywordflow">for</span> (boost::tie(ei, ei_end)=edges(src); ei!=ei_end; ++ei) {
<a name="l00399"></a>00399         <span class="keywordflow">if</span> (NO_VERTEX!=src_to_dst[source(*ei, src)] &amp;&amp; NO_VERTEX!=src_to_dst[target(*ei, src)]) {
<a name="l00400"></a>00400             <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *func1 = get(boost::vertex_name, src, source(*ei, src));
<a name="l00401"></a>00401             <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *func2 = get(boost::vertex_name, src, target(*ei, src));
<a name="l00402"></a>00402             <span class="keywordflow">if</span> (!<a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#3db7e3b728529310098bc4218b618a80">is_edge_filtered</a>(func1, func2))
<a name="l00403"></a>00403                 add_edge(src_to_dst[source(*ei, src)], src_to_dst[target(*ei, src)], dst);
<a name="l00404"></a>00404         }
<a name="l00405"></a>00405     }
<a name="l00406"></a>00406 }
<a name="l00407"></a>00407 
<a name="l00408"></a>00408 <span class="keyword">template</span>&lt;<span class="keyword">class</span> FunctionCallGraph&gt;
<a name="l00409"></a>00409 FunctionCallGraph
<a name="l00410"></a><a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#6e95c76343bf40c6d438f41144073b39">00410</a> <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#6e95c76343bf40c6d438f41144073b39">BinaryAnalysis::FunctionCall::copy</a>(<span class="keyword">const</span> FunctionCallGraph &amp;src)
<a name="l00411"></a>00411 {
<a name="l00412"></a>00412     FunctionCallGraph dst;
<a name="l00413"></a>00413     <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#6e95c76343bf40c6d438f41144073b39">copy</a>(src, dst);
<a name="l00414"></a>00414     <span class="keywordflow">return</span> dst;
<a name="l00415"></a>00415 }
<a name="l00416"></a>00416 
<a name="l00417"></a>00417 
<a name="l00418"></a>00418 
<a name="l00419"></a>00419 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
