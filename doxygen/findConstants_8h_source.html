<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ROSE: findConstants.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.9.5a</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('findConstants_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">findConstants.h</div>  </div>
</div>
<div class="contents">
<a href="findConstants_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* The primary purpose of this header file is to define a &quot;policy&quot; for instruction semantics such as for the</span>
<a name="l00002"></a>00002 <span class="comment"> * X86InstructionSemantics class. This particular policy is for tracking the flow of constant values. */</span>
<a name="l00003"></a>00003 
<a name="l00004"></a>00004 <span class="preprocessor">#ifndef findConstants_H</span>
<a name="l00005"></a>00005 <span class="preprocessor"></span><span class="preprocessor">#define findConstants_H</span>
<a name="l00006"></a>00006 <span class="preprocessor"></span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &quot;<a class="code" href="x86InstructionSemantics_8h.html">x86InstructionSemantics.h</a>&quot;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &quot;<a class="code" href="integerOps_8h.html">integerOps.h</a>&quot;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &quot;<a class="code" href="flowEquations_8h.html">flowEquations.h</a>&quot;</span>
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;cassert&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;cstdio&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;boost/lexical_cast.hpp&gt;</span>
<a name="l00014"></a>00014 
<a name="l00024"></a>00024 <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;                         <span class="comment">// Sums are modulo 2^Len</span>
<a name="l00025"></a><a class="code" href="structLatticeElement.html">00025</a> <span class="keyword">struct </span><a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement</a> {
<a name="l00026"></a><a class="code" href="structLatticeElement.html#a4cf276f9d7e1d0dde19af9d40c8f7c5b">00026</a>     <span class="keywordtype">bool</span> <a class="code" href="structLatticeElement.html#a4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>;
<a name="l00027"></a><a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">00027</a>     uint64_t <a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a>;                            <span class="comment">// 0 for constants, a nonzero ID number for everything else</span>
<a name="l00028"></a><a class="code" href="structLatticeElement.html#afb9076844cf7aeb97f205a872b685e1b">00028</a>     <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* <a class="code" href="structLatticeElement.html#afb9076844cf7aeb97f205a872b685e1b">definingInstruction</a>; <span class="comment">// Functionally dependent on name (mostly for debugging)</span>
<a name="l00029"></a><a class="code" href="structLatticeElement.html#a6bfb90dd4b9e80a03cdef7d2f55d78f8">00029</a>     <span class="keywordtype">bool</span> <a class="code" href="structLatticeElement.html#a6bfb90dd4b9e80a03cdef7d2f55d78f8">negate</a>;                              <span class="comment">// Switch between name+offset and -name+offset; should be false for constants</span>
<a name="l00030"></a><a class="code" href="structLatticeElement.html#a5f7046b6efe5660c07b84883ee26a4cc">00030</a>     uint64_t <a class="code" href="structLatticeElement.html#a5f7046b6efe5660c07b84883ee26a4cc">offset</a>;                          <span class="comment">// Offset from name</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032     <span class="comment">/* Constructs a &quot;top&quot; lattice element */</span>
<a name="l00033"></a><a class="code" href="structLatticeElement.html#a100ba60a126161578eb3a603de93d1eb">00033</a>     <a class="code" href="structLatticeElement.html#a100ba60a126161578eb3a603de93d1eb">LatticeElement</a>()
<a name="l00034"></a>00034         : <a class="code" href="structLatticeElement.html#a4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>(true), <a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a>(0), <a class="code" href="structLatticeElement.html#afb9076844cf7aeb97f205a872b685e1b">definingInstruction</a>(NULL), <a class="code" href="structLatticeElement.html#a6bfb90dd4b9e80a03cdef7d2f55d78f8">negate</a>(false), <a class="code" href="structLatticeElement.html#a5f7046b6efe5660c07b84883ee26a4cc">offset</a>(0)
<a name="l00035"></a>00035         {}
<a name="l00036"></a>00036 
<a name="l00037"></a>00037     <span class="comment">/* Construct a named lattice element (no offset) */</span>
<a name="l00038"></a><a class="code" href="structLatticeElement.html#a68f4d621d8c1df5143663efbec642574">00038</a>     <span class="keyword">static</span> <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement</a> <a class="code" href="structLatticeElement.html#a68f4d621d8c1df5143663efbec642574">nonconstant</a>(uint64_t <a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a>, <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* <a class="code" href="structLatticeElement.html#afb9076844cf7aeb97f205a872b685e1b">definingInstruction</a>) {
<a name="l00039"></a>00039         <span class="keywordflow">return</span> <a class="code" href="structLatticeElement.html#a100ba60a126161578eb3a603de93d1eb">LatticeElement</a>(name, definingInstruction, <span class="keyword">false</span>, 0);
<a name="l00040"></a>00040     }
<a name="l00041"></a>00041 
<a name="l00042"></a>00042     <span class="comment">/* Construct a non-top, named lattice element with optional offset. */</span>
<a name="l00043"></a><a class="code" href="structLatticeElement.html#a06677733e32d97109956f0edd702a2cb">00043</a>     <a class="code" href="structLatticeElement.html#a100ba60a126161578eb3a603de93d1eb">LatticeElement</a>(uint64_t <a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a>, <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* <a class="code" href="structLatticeElement.html#afb9076844cf7aeb97f205a872b685e1b">definingInstruction</a>, <span class="keywordtype">bool</span> <a class="code" href="structLatticeElement.html#a6bfb90dd4b9e80a03cdef7d2f55d78f8">negate</a>, uint64_t <a class="code" href="structLatticeElement.html#a5f7046b6efe5660c07b84883ee26a4cc">offset</a>)
<a name="l00044"></a>00044         : <a class="code" href="structLatticeElement.html#a4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>(false), name(name), definingInstruction(definingInstruction), negate(negate),
<a name="l00045"></a>00045           offset(offset &amp; (IntegerOps::GenMask&lt;uint64_t, Len&gt;::value))
<a name="l00046"></a>00046         {}
<a name="l00047"></a>00047 
<a name="l00048"></a>00048     <span class="comment">/* Construct a named lattice element with optional offset. */</span>
<a name="l00049"></a><a class="code" href="structLatticeElement.html#a6d3b3d1c4b1438daecd7b1a20b1d831c">00049</a>     <a class="code" href="structLatticeElement.html#a100ba60a126161578eb3a603de93d1eb">LatticeElement</a>(<span class="keywordtype">bool</span> <a class="code" href="structLatticeElement.html#a4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>, uint64_t <a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a>, <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* <a class="code" href="structLatticeElement.html#afb9076844cf7aeb97f205a872b685e1b">definingInstruction</a>, <span class="keywordtype">bool</span> <a class="code" href="structLatticeElement.html#a6bfb90dd4b9e80a03cdef7d2f55d78f8">negate</a>, uint64_t <a class="code" href="structLatticeElement.html#a5f7046b6efe5660c07b84883ee26a4cc">offset</a>)
<a name="l00050"></a>00050         : isTop(isTop), name(name), definingInstruction(definingInstruction), negate(negate),
<a name="l00051"></a>00051           offset(offset &amp; (IntegerOps::GenMask&lt;uint64_t, Len&gt;::value))
<a name="l00052"></a>00052         {}
<a name="l00053"></a>00053 
<a name="l00054"></a>00054     <span class="comment">/* Construct a constant lattice element */</span>
<a name="l00055"></a><a class="code" href="structLatticeElement.html#a260c3631fc51e216ccbed10e2df772f2">00055</a>     <span class="keyword">static</span> <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement</a> <a class="code" href="structLatticeElement.html#a260c3631fc51e216ccbed10e2df772f2">constant</a>(uint64_t c, <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* <a class="code" href="structLatticeElement.html#afb9076844cf7aeb97f205a872b685e1b">definingInstruction</a>) {
<a name="l00056"></a>00056         <span class="keywordflow">return</span> <a class="code" href="structLatticeElement.html#a100ba60a126161578eb3a603de93d1eb">LatticeElement</a>(0, definingInstruction, <span class="keyword">false</span>, c);
<a name="l00057"></a>00057     }
<a name="l00058"></a>00058 
<a name="l00059"></a><a class="code" href="structLatticeElement.html#a959696a386346cf3e0375340b65d114c">00059</a>     <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="structLatticeElement.html#a959696a386346cf3e0375340b65d114c">operator==</a>(<span class="keyword">const</span> <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement</a>&amp; a, <span class="keyword">const</span> <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement</a>&amp; b) {
<a name="l00060"></a>00060         <span class="keywordflow">if</span> (a.<a class="code" href="structLatticeElement.html#a4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a> != b.<a class="code" href="structLatticeElement.html#a4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00061"></a>00061         <span class="keywordflow">if</span> (a.<a class="code" href="structLatticeElement.html#a4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00062"></a>00062         <span class="keywordflow">return</span> a.<a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a> == b.<a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a> &amp;&amp; (a.<a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a> == 0 || a.<a class="code" href="structLatticeElement.html#a6bfb90dd4b9e80a03cdef7d2f55d78f8">negate</a> == b.<a class="code" href="structLatticeElement.html#a6bfb90dd4b9e80a03cdef7d2f55d78f8">negate</a>) &amp;&amp; a.<a class="code" href="structLatticeElement.html#a5f7046b6efe5660c07b84883ee26a4cc">offset</a> == b.<a class="code" href="structLatticeElement.html#a5f7046b6efe5660c07b84883ee26a4cc">offset</a>;
<a name="l00063"></a>00063     }
<a name="l00064"></a><a class="code" href="structLatticeElement.html#a3b8f0baf79c98d6faa3aa6c6a8540806">00064</a>     <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="structLatticeElement.html#a3b8f0baf79c98d6faa3aa6c6a8540806">operator&lt;</a>(<span class="keyword">const</span> <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement</a>&amp; a, <span class="keyword">const</span> <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement</a>&amp; b) { <span class="comment">// Arbitrary order</span>
<a name="l00065"></a>00065         <span class="keywordflow">if</span> (a.<a class="code" href="structLatticeElement.html#a4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a> &lt; b.<a class="code" href="structLatticeElement.html#a4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00066"></a>00066         <span class="keywordflow">if</span> (b.<a class="code" href="structLatticeElement.html#a4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a> &lt; a.<a class="code" href="structLatticeElement.html#a4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00067"></a>00067         <span class="keywordflow">if</span> (a.<a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a> &lt; b.<a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a>) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00068"></a>00068         <span class="keywordflow">if</span> (b.<a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a> &lt; a.<a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00069"></a>00069         <span class="keywordflow">if</span> (a.<a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a> != 0 &amp;&amp; a.<a class="code" href="structLatticeElement.html#a6bfb90dd4b9e80a03cdef7d2f55d78f8">negate</a> &lt; b.<a class="code" href="structLatticeElement.html#a6bfb90dd4b9e80a03cdef7d2f55d78f8">negate</a>) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00070"></a>00070         <span class="keywordflow">if</span> (a.<a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a> != 0 &amp;&amp; b.<a class="code" href="structLatticeElement.html#a6bfb90dd4b9e80a03cdef7d2f55d78f8">negate</a> &lt; a.<a class="code" href="structLatticeElement.html#a6bfb90dd4b9e80a03cdef7d2f55d78f8">negate</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00071"></a>00071         <span class="keywordflow">return</span> a.<a class="code" href="structLatticeElement.html#a5f7046b6efe5660c07b84883ee26a4cc">offset</a> &lt; b.<a class="code" href="structLatticeElement.html#a5f7046b6efe5660c07b84883ee26a4cc">offset</a>;
<a name="l00072"></a>00072     }
<a name="l00073"></a><a class="code" href="structLatticeElement.html#a1fa61bab0a3202eb472eae5e8e989f16">00073</a>     <span class="keywordtype">void</span> <a class="code" href="structLatticeElement.html#a1fa61bab0a3202eb472eae5e8e989f16">merge</a>(<span class="keyword">const</span> <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement</a>&amp; elt, uint64_t newName, <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* def) {
<a name="l00074"></a>00074         <span class="keywordflow">if</span> (elt.<a class="code" href="structLatticeElement.html#a4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>) <span class="keywordflow">return</span>;
<a name="l00075"></a>00075         <span class="keywordflow">if</span> (this-&gt;<a class="code" href="structLatticeElement.html#a4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>) {
<a name="l00076"></a>00076             *<span class="keyword">this</span> = elt;
<a name="l00077"></a>00077             <span class="keywordflow">return</span>;
<a name="l00078"></a>00078         }
<a name="l00079"></a>00079         <span class="keywordflow">if</span> (*<span class="keyword">this</span> == elt)
<a name="l00080"></a>00080             <span class="keywordflow">return</span>;
<a name="l00081"></a>00081         this-&gt;<a class="code" href="structLatticeElement.html#a4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a> = <span class="keyword">false</span>;
<a name="l00082"></a>00082         this-&gt;<a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a> = newName;
<a name="l00083"></a>00083         this-&gt;<a class="code" href="structLatticeElement.html#afb9076844cf7aeb97f205a872b685e1b">definingInstruction</a> = def;
<a name="l00084"></a>00084         this-&gt;<a class="code" href="structLatticeElement.html#a6bfb90dd4b9e80a03cdef7d2f55d78f8">negate</a> = <span class="keyword">false</span>;
<a name="l00085"></a>00085         this-&gt;<a class="code" href="structLatticeElement.html#a5f7046b6efe5660c07b84883ee26a4cc">offset</a> = 0;
<a name="l00086"></a>00086         <span class="keywordflow">return</span>;
<a name="l00087"></a>00087     }
<a name="l00088"></a>00088 };
<a name="l00089"></a>00089 
<a name="l00096"></a>00096 <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00097"></a><a class="code" href="findConstants_8h.html#a7ce666de780857c26d9783b766a1a975">00097</a> std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, const LatticeElement&lt;Len&gt;&amp; e)
<a name="l00098"></a>00098 {
<a name="l00099"></a>00099     <span class="keywordflow">if</span> (e.isTop) {
<a name="l00100"></a>00100         o &lt;&lt; <span class="stringliteral">&quot;&lt;top&gt;&quot;</span>;
<a name="l00101"></a>00101     } <span class="keywordflow">else</span> {
<a name="l00102"></a>00102         uint64_t sign_bit = (uint64_t)1 &lt;&lt; (Len-1);  <span class="comment">/* e.g., 80000000 */</span>
<a name="l00103"></a>00103         uint64_t val_mask = sign_bit - 1;            <span class="comment">/* e.g., 7fffffff */</span>
<a name="l00104"></a>00104         uint64_t negative = (e.offset &amp; sign_bit) ? (~e.offset &amp; val_mask) + 1 : 0; <span class="comment">/*magnitude of negative value*/</span>
<a name="l00105"></a>00105 
<a name="l00106"></a>00106         <span class="keywordflow">if</span> (e.name!=0) {
<a name="l00107"></a>00107             <span class="comment">/* This is a named value rather than a constant. */</span>
<a name="l00108"></a>00108             <span class="keyword">const</span> <span class="keywordtype">char</span> *sign = e.negate ? <span class="stringliteral">&quot;-&quot;</span> : <span class="stringliteral">&quot;&quot;</span>;
<a name="l00109"></a>00109             o &lt;&lt;sign &lt;&lt;<span class="stringliteral">&quot;v&quot;</span> &lt;&lt;std::dec &lt;&lt;e.name;
<a name="l00110"></a>00110             <span class="keywordflow">if</span> (negative) {
<a name="l00111"></a>00111                 o &lt;&lt;<span class="stringliteral">&quot;-0x&quot;</span> &lt;&lt;std::hex &lt;&lt;negative;
<a name="l00112"></a>00112             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (e.offset) {
<a name="l00113"></a>00113                 o &lt;&lt;<span class="stringliteral">&quot;+0x&quot;</span> &lt;&lt;std::hex &lt;&lt;e.offset;
<a name="l00114"></a>00114             }
<a name="l00115"></a>00115         } <span class="keywordflow">else</span> {
<a name="l00116"></a>00116             <span class="comment">/* This is a constant */</span>
<a name="l00117"></a>00117             ROSE_ASSERT(!e.negate);
<a name="l00118"></a>00118             o  &lt;&lt;<span class="stringliteral">&quot;0x&quot;</span> &lt;&lt;std::hex &lt;&lt;e.offset;
<a name="l00119"></a>00119             <span class="keywordflow">if</span> (negative)
<a name="l00120"></a>00120                 o &lt;&lt;<span class="stringliteral">&quot; (-0x&quot;</span> &lt;&lt;std::hex &lt;&lt;negative &lt;&lt;<span class="stringliteral">&quot;)&quot;</span>;
<a name="l00121"></a>00121         }
<a name="l00122"></a>00122         <span class="keywordflow">if</span> (e.definingInstruction!=NULL)
<a name="l00123"></a>00123             o &lt;&lt; <span class="stringliteral">&quot; [from &quot;</span> &lt;&lt; <a class="code" href="AsmUnparser__compat_8h.html#a3b979292833b85f5b059b2893250453c" title="Returns the string representation of an assembly instruction with address.">unparseInstructionWithAddress</a>(e.definingInstruction) &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>;
<a name="l00124"></a>00124     }
<a name="l00125"></a>00125     <span class="keywordflow">return</span> o;
<a name="l00126"></a>00126 }
<a name="l00127"></a>00127 
<a name="l00129"></a>00129 <span class="keyword">extern</span> uint64_t <a class="code" href="findConstants_8h.html#a23853ba1fee40422cf7195fc41da1da6" title="Counter to generate unique names for XVariables (and thereby, LatticeElements).">xvarNameCounter</a>;
<a name="l00130"></a>00130 
<a name="l00133"></a>00133 <span class="keyword">extern</span> <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* <a class="code" href="findConstants_8h.html#a95f018a40d9bdcb7c342a55a4503c9c1" title="Instruction on which we are currently working.">currentInstruction</a>;
<a name="l00134"></a>00134 
<a name="l00135"></a>00135 <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00136"></a><a class="code" href="structXVariable.html">00136</a> <span class="keyword">struct </span><a class="code" href="structXVariable.html">XVariable</a>: <span class="keyword">public</span> <a class="code" href="classVariable.html">Variable</a> { <span class="comment">/*Variable defined in flowEquations.h*/</span>
<a name="l00137"></a><a class="code" href="structXVariable.html#a1befcc7f34e931bf2b52a233e5693d70">00137</a>     <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;</a> <a class="code" href="structXVariable.html#a1befcc7f34e931bf2b52a233e5693d70">value</a>;
<a name="l00138"></a><a class="code" href="structXVariable.html#a0462c7dbcdfdd6364af9d251b5cbbca3">00138</a>     uint64_t <a class="code" href="structXVariable.html#a0462c7dbcdfdd6364af9d251b5cbbca3">myName</a>;
<a name="l00139"></a><a class="code" href="structXVariable.html#a01f0d45c772847833cbe1afdf9fffc6b">00139</a>     <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* <a class="code" href="structXVariable.html#a01f0d45c772847833cbe1afdf9fffc6b">def</a>;
<a name="l00140"></a><a class="code" href="structXVariable.html#adba4bf2707127da32af3f21caa9639ac">00140</a>     <a class="code" href="structXVariable.html#adba4bf2707127da32af3f21caa9639ac">XVariable</a>()
<a name="l00141"></a>00141         : <a class="code" href="structXVariable.html#a1befcc7f34e931bf2b52a233e5693d70">value</a>(), <a class="code" href="structXVariable.html#a0462c7dbcdfdd6364af9d251b5cbbca3">myName</a>(++<a class="code" href="findConstants_8h.html#a23853ba1fee40422cf7195fc41da1da6" title="Counter to generate unique names for XVariables (and thereby, LatticeElements).">xvarNameCounter</a>), <a class="code" href="structXVariable.html#a01f0d45c772847833cbe1afdf9fffc6b">def</a>(currentInstruction)
<a name="l00142"></a>00142         {}
<a name="l00143"></a>00143 
<a name="l00145"></a><a class="code" href="structXVariable.html#adf3fb4f7f70bf0933ea35fae24d60fb4">00145</a>     <span class="keywordtype">void</span> <span class="keyword">set</span>(<span class="keyword">const</span> <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;</a>&amp; le) {
<a name="l00146"></a>00146         <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;</a> newValue = <a class="code" href="structXVariable.html#a1befcc7f34e931bf2b52a233e5693d70">value</a>;
<a name="l00147"></a>00147         newValue.<a class="code" href="structLatticeElement.html#a1fa61bab0a3202eb472eae5e8e989f16">merge</a>(le, <a class="code" href="structXVariable.html#a0462c7dbcdfdd6364af9d251b5cbbca3">myName</a>, <a class="code" href="structXVariable.html#a01f0d45c772847833cbe1afdf9fffc6b">def</a>);
<a name="l00148"></a>00148         <span class="keywordflow">if</span> (<a class="code" href="structXVariable.html#a1befcc7f34e931bf2b52a233e5693d70">value</a> == newValue)
<a name="l00149"></a>00149             <span class="keywordflow">return</span>;
<a name="l00150"></a>00150         <a class="code" href="structXVariable.html#a1befcc7f34e931bf2b52a233e5693d70">value</a> = newValue;
<a name="l00151"></a>00151         this-&gt;<a class="code" href="classVariable.html#a76683fcd725489142f0397aa957a966d">pushChanges</a>();
<a name="l00152"></a>00152     }
<a name="l00153"></a>00153 
<a name="l00155"></a><a class="code" href="structXVariable.html#ae4cfe6763f2180ecf193537649b4cd5c">00155</a>     <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;</a> <span class="keyword">get</span>() <span class="keyword">const</span> {
<a name="l00156"></a>00156         <span class="keywordflow">return</span> <a class="code" href="structXVariable.html#a1befcc7f34e931bf2b52a233e5693d70">value</a>;
<a name="l00157"></a>00157     }
<a name="l00158"></a>00158 };
<a name="l00159"></a>00159 
<a name="l00161"></a>00161 <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00162"></a><a class="code" href="structXVariablePtr.html">00162</a> <span class="keyword">struct </span><a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr</a> {
<a name="l00163"></a><a class="code" href="structXVariablePtr.html#a23a0566e27ca0439deaf2acc3f2e032b">00163</a>     <a class="code" href="structXVariable.html">XVariable&lt;Len&gt;</a>* <a class="code" href="structXVariablePtr.html#a23a0566e27ca0439deaf2acc3f2e032b">var</a>;
<a name="l00164"></a><a class="code" href="structXVariablePtr.html#a730bc0bbb478a8b005ceae0dd4900ff9">00164</a>     <a class="code" href="structXVariablePtr.html#a730bc0bbb478a8b005ceae0dd4900ff9">XVariablePtr</a>()
<a name="l00165"></a>00165         : <a class="code" href="structXVariablePtr.html#a23a0566e27ca0439deaf2acc3f2e032b">var</a>(NULL)
<a name="l00166"></a>00166         {}
<a name="l00167"></a><a class="code" href="structXVariablePtr.html#a3c5c912b2bf87aa05c686359faa50994">00167</a>     <a class="code" href="structXVariablePtr.html#a730bc0bbb478a8b005ceae0dd4900ff9">XVariablePtr</a>(<a class="code" href="structXVariable.html">XVariable&lt;Len&gt;</a>* <a class="code" href="structXVariablePtr.html#a23a0566e27ca0439deaf2acc3f2e032b">var</a>)
<a name="l00168"></a>00168         : var(var)
<a name="l00169"></a>00169         {}
<a name="l00170"></a><a class="code" href="structXVariablePtr.html#a395bc0856c5c9c65ca4ea1b978ee3cbe">00170</a>     <a class="code" href="structXVariablePtr.html#a395bc0856c5c9c65ca4ea1b978ee3cbe">operator XVariable&lt;Len&gt;*</a>()<span class="keyword"> const </span>{
<a name="l00171"></a>00171         <span class="keywordflow">return</span> <a class="code" href="structXVariablePtr.html#a23a0566e27ca0439deaf2acc3f2e032b">var</a>;
<a name="l00172"></a>00172     }
<a name="l00173"></a><a class="code" href="structXVariablePtr.html#ab4a5bff4958b2bc6e64b004249f8edd2">00173</a>     <a class="code" href="structXVariable.html">XVariable&lt;Len&gt;</a>* <a class="code" href="structXVariablePtr.html#ab4a5bff4958b2bc6e64b004249f8edd2">operator-&gt;</a>()<span class="keyword"> const </span>{
<a name="l00174"></a>00174         <span class="keywordflow">return</span> <a class="code" href="structXVariablePtr.html#a23a0566e27ca0439deaf2acc3f2e032b">var</a>;
<a name="l00175"></a>00175     }
<a name="l00176"></a><a class="code" href="structXVariablePtr.html#aa88822e4d1dc3cdb2b6e58d73f5e2e34">00176</a>     <span class="keyword">static</span> <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr</a> <a class="code" href="structXVariablePtr.html#aa88822e4d1dc3cdb2b6e58d73f5e2e34">bottom</a>() {
<a name="l00177"></a>00177         <span class="keyword">struct </span>BottomConstraint: <span class="keyword">public</span> <a class="code" href="classConstraint.html">Constraint</a> {
<a name="l00178"></a>00178             <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> <a class="code" href="structXVariablePtr.html#a23a0566e27ca0439deaf2acc3f2e032b">var</a>;
<a name="l00179"></a>00179             BottomConstraint(<a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> <a class="code" href="structXVariablePtr.html#a23a0566e27ca0439deaf2acc3f2e032b">var</a>)
<a name="l00180"></a>00180                 : <a class="code" href="structXVariablePtr.html#a23a0566e27ca0439deaf2acc3f2e032b">var</a>(var)
<a name="l00181"></a>00181                 {}
<a name="l00182"></a>00182             <span class="keyword">virtual</span> <span class="keywordtype">void</span> run()<span class="keyword"> const </span>{
<a name="l00183"></a>00183                 var-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;::nonconstant</a>(var-&gt;myName, var-&gt;def));
<a name="l00184"></a>00184             }
<a name="l00185"></a>00185             <span class="keyword">virtual</span> <span class="keywordtype">void</span> markDependencies() {}
<a name="l00186"></a>00186         };
<a name="l00187"></a>00187         <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> <a class="code" href="structXVariablePtr.html#a23a0566e27ca0439deaf2acc3f2e032b">var</a> = <span class="keyword">new</span> <a class="code" href="structXVariable.html">XVariable&lt;Len&gt;</a>();
<a name="l00188"></a>00188         (<span class="keyword">new</span> BottomConstraint(var))-&gt;activate();
<a name="l00189"></a>00189         <span class="keywordflow">return</span> <a class="code" href="structXVariablePtr.html#a23a0566e27ca0439deaf2acc3f2e032b">var</a>;
<a name="l00190"></a>00190     }
<a name="l00191"></a>00191 };
<a name="l00192"></a>00192 
<a name="l00193"></a>00193 <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00194"></a><a class="code" href="findConstants_8h.html#a50f5a00fe3ff97588408cfeb95e1560e">00194</a> std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, XVariablePtr&lt;Len&gt; v) {
<a name="l00195"></a>00195     o &lt;&lt; v-&gt;value;
<a name="l00196"></a>00196     <span class="keywordflow">return</span> o;
<a name="l00197"></a>00197 }
<a name="l00198"></a>00198 
<a name="l00201"></a><a class="code" href="structMemoryWrite.html">00201</a> <span class="keyword">struct </span><a class="code" href="structMemoryWrite.html" title="Information about the contents of memory at a given address.">MemoryWrite</a> {
<a name="l00202"></a><a class="code" href="structMemoryWrite.html#adcf4704cebd9c4531cd9700527988b5f">00202</a>     <a class="code" href="structLatticeElement.html">LatticeElement&lt;32&gt;</a> <a class="code" href="structMemoryWrite.html#adcf4704cebd9c4531cd9700527988b5f">address</a>;
<a name="l00203"></a><a class="code" href="structMemoryWrite.html#af1c2a8cf93c214c396251533c66b5296">00203</a>     <a class="code" href="structLatticeElement.html">LatticeElement&lt;32&gt;</a> <a class="code" href="structMemoryWrite.html#af1c2a8cf93c214c396251533c66b5296">data</a>;
<a name="l00204"></a><a class="code" href="structMemoryWrite.html#a35e235bb9134cc729b8a5174e13a9af1">00204</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structMemoryWrite.html#a35e235bb9134cc729b8a5174e13a9af1">len</a>;
<a name="l00205"></a><a class="code" href="structMemoryWrite.html#ae127a0b2e42c26626e060b79fd97df6b">00205</a>     <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="structMemoryWrite.html#ae127a0b2e42c26626e060b79fd97df6b">operator==</a>(<span class="keyword">const</span> <a class="code" href="structMemoryWrite.html" title="Information about the contents of memory at a given address.">MemoryWrite</a>&amp; a, <span class="keyword">const</span> <a class="code" href="structMemoryWrite.html" title="Information about the contents of memory at a given address.">MemoryWrite</a>&amp; b) {
<a name="l00206"></a>00206         <span class="keywordflow">return</span> a.<a class="code" href="structMemoryWrite.html#adcf4704cebd9c4531cd9700527988b5f">address</a> == b.<a class="code" href="structMemoryWrite.html#adcf4704cebd9c4531cd9700527988b5f">address</a> &amp;&amp; a.<a class="code" href="structMemoryWrite.html#af1c2a8cf93c214c396251533c66b5296">data</a> == b.<a class="code" href="structMemoryWrite.html#af1c2a8cf93c214c396251533c66b5296">data</a> &amp;&amp; a.<a class="code" href="structMemoryWrite.html#a35e235bb9134cc729b8a5174e13a9af1">len</a> == b.<a class="code" href="structMemoryWrite.html#a35e235bb9134cc729b8a5174e13a9af1">len</a>;
<a name="l00207"></a>00207     }
<a name="l00208"></a><a class="code" href="structMemoryWrite.html#a6bdd4bc6845b262ad56566b5fd6b5f5c">00208</a>     <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="structMemoryWrite.html#a6bdd4bc6845b262ad56566b5fd6b5f5c">operator&lt;</a>(<span class="keyword">const</span> <a class="code" href="structMemoryWrite.html" title="Information about the contents of memory at a given address.">MemoryWrite</a>&amp; a, <span class="keyword">const</span> <a class="code" href="structMemoryWrite.html" title="Information about the contents of memory at a given address.">MemoryWrite</a>&amp; b) {
<a name="l00209"></a>00209         <span class="keywordflow">return</span> a.<a class="code" href="structMemoryWrite.html#adcf4704cebd9c4531cd9700527988b5f">address</a> &lt; b.<a class="code" href="structMemoryWrite.html#adcf4704cebd9c4531cd9700527988b5f">address</a>;
<a name="l00210"></a>00210     }
<a name="l00211"></a>00211 };
<a name="l00212"></a>00212 
<a name="l00213"></a>00213 <span class="keywordtype">bool</span> <a class="code" href="findConstants_8h.html#ad533e286da133784685293ce0a44ee0f" title="Returns true if the contents of memory location a could possibly overlap with b.">mayAlias</a>(<span class="keyword">const</span> <a class="code" href="structMemoryWrite.html" title="Information about the contents of memory at a given address.">MemoryWrite</a>&amp;, <span class="keyword">const</span> <a class="code" href="structMemoryWrite.html" title="Information about the contents of memory at a given address.">MemoryWrite</a>&amp;);
<a name="l00214"></a>00214 <span class="keywordtype">bool</span> <a class="code" href="findConstants_8h.html#a3d2a6c2edc28257d61a10d11cf67c5ec" title="Returns true if memory locations a and b are the same (note that &quot;same&quot; is more strict than &quot;overlap&quot;...">mustAlias</a>(<span class="keyword">const</span> <a class="code" href="structMemoryWrite.html" title="Information about the contents of memory at a given address.">MemoryWrite</a>&amp;, <span class="keyword">const</span> <a class="code" href="structMemoryWrite.html" title="Information about the contents of memory at a given address.">MemoryWrite</a>&amp;);
<a name="l00215"></a>00215 
<a name="l00216"></a>00216 <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> From, <span class="keywordtype">size_t</span> To&gt;
<a name="l00217"></a>00217 <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;To&gt;</a> <a class="code" href="findConstants_8h.html#ac561d0ac17798b48263f8622d1ece112">extendByMSB</a>(<a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;From&gt;</a>);
<a name="l00218"></a>00218 
<a name="l00219"></a>00219 <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> From, <span class="keywordtype">size_t</span> To, <span class="keywordtype">size_t</span> Len&gt;
<a name="l00220"></a>00220 <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr</a>&lt;To - From&gt; <a class="code" href="findConstants_8h.html#adcd954f1007c97339e8b507f1915f435">extract</a>(<a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a>);
<a name="l00221"></a>00221 
<a name="l00223"></a>00223 <span class="comment">/* FIXME: Why are addresses and data always 32 bits? Will this work for a 64-bit architecture? [RPM 2009-02-03] */</span>
<a name="l00224"></a><a class="code" href="structMemoryWriteSet.html">00224</a> <span class="keyword">struct </span><a class="code" href="structMemoryWriteSet.html" title="A set of values stored in memory.">MemoryWriteSet</a> {
<a name="l00225"></a><a class="code" href="structMemoryWriteSet.html#a26845f2d2d0f83b00c0156a1642de9c0">00225</a>     <span class="keywordtype">bool</span> <a class="code" href="structMemoryWriteSet.html#a26845f2d2d0f83b00c0156a1642de9c0">isTop</a>;
<a name="l00226"></a><a class="code" href="structMemoryWriteSet.html#aff1aab41effbd5b65c11bebd3e9294ca">00226</a>     std::vector&lt;MemoryWrite&gt; <a class="code" href="structMemoryWriteSet.html#aff1aab41effbd5b65c11bebd3e9294ca">writes</a>;         <span class="comment">/* Always sorted by address */</span>
<a name="l00227"></a>00227 
<a name="l00228"></a><a class="code" href="structMemoryWriteSet.html#ae1ade7c6876c844d60df9bae3089d9e0">00228</a>     <a class="code" href="structMemoryWriteSet.html#ae1ade7c6876c844d60df9bae3089d9e0">MemoryWriteSet</a>()
<a name="l00229"></a>00229         : <a class="code" href="structMemoryWriteSet.html#a26845f2d2d0f83b00c0156a1642de9c0">isTop</a>(true), <a class="code" href="structMemoryWriteSet.html#aff1aab41effbd5b65c11bebd3e9294ca">writes</a>()
<a name="l00230"></a>00230         {}
<a name="l00231"></a>00231 
<a name="l00233"></a><a class="code" href="structMemoryWriteSet.html#a0ffbc1b898a737117ce4d5210ba314a7">00233</a>     <span class="keywordtype">void</span> <a class="code" href="structMemoryWriteSet.html#a0ffbc1b898a737117ce4d5210ba314a7" title="Add a value to memory.">addWrite</a>(<a class="code" href="structLatticeElement.html">LatticeElement&lt;32&gt;</a> address, <a class="code" href="structLatticeElement.html">LatticeElement&lt;32&gt;</a> data, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len) {
<a name="l00234"></a>00234         <a class="code" href="structMemoryWriteSet.html#a26845f2d2d0f83b00c0156a1642de9c0">isTop</a> = <span class="keyword">false</span>;
<a name="l00235"></a>00235         <a class="code" href="structMemoryWrite.html" title="Information about the contents of memory at a given address.">MemoryWrite</a> mw;
<a name="l00236"></a>00236         mw.<a class="code" href="structMemoryWrite.html#adcf4704cebd9c4531cd9700527988b5f">address</a> = address;
<a name="l00237"></a>00237         mw.<a class="code" href="structMemoryWrite.html#af1c2a8cf93c214c396251533c66b5296">data</a> = data;
<a name="l00238"></a>00238         mw.<a class="code" href="structMemoryWrite.html#a35e235bb9134cc729b8a5174e13a9af1">len</a> = len;
<a name="l00239"></a>00239         std::vector&lt;MemoryWrite&gt; newWrites;
<a name="l00240"></a>00240         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="structMemoryWriteSet.html#aff1aab41effbd5b65c11bebd3e9294ca">writes</a>.size(); ++i) {
<a name="l00241"></a>00241             <span class="keywordflow">if</span> (!<a class="code" href="findConstants_8h.html#ad533e286da133784685293ce0a44ee0f" title="Returns true if the contents of memory location a could possibly overlap with b.">mayAlias</a>(<a class="code" href="structMemoryWriteSet.html#aff1aab41effbd5b65c11bebd3e9294ca">writes</a>[i], mw))
<a name="l00242"></a>00242                 newWrites.push_back(<a class="code" href="structMemoryWriteSet.html#aff1aab41effbd5b65c11bebd3e9294ca">writes</a>[i]);
<a name="l00243"></a>00243         }
<a name="l00244"></a>00244         newWrites.push_back(mw);
<a name="l00245"></a>00245         <a class="code" href="structMemoryWriteSet.html#aff1aab41effbd5b65c11bebd3e9294ca">writes</a> = newWrites;
<a name="l00246"></a>00246         std::sort(<a class="code" href="structMemoryWriteSet.html#aff1aab41effbd5b65c11bebd3e9294ca">writes</a>.begin(), <a class="code" href="structMemoryWriteSet.html#aff1aab41effbd5b65c11bebd3e9294ca">writes</a>.end());
<a name="l00247"></a>00247     }
<a name="l00248"></a>00248 
<a name="l00250"></a>00250     <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt; <span class="comment">// In bits</span>
<a name="l00251"></a><a class="code" href="structMemoryWriteSet.html#a6655c5dc1e2f02ce1795cecb8a976470">00251</a>     <span class="keywordtype">bool</span> <a class="code" href="structMemoryWriteSet.html#a6655c5dc1e2f02ce1795cecb8a976470" title="Obtains the value stored at the specified memory address, returning true if the address is defined or...">getValueAtAddress</a>(<a class="code" href="structLatticeElement.html">LatticeElement&lt;32&gt;</a> address, <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;</a>&amp; result, uint32_t resultName,
<a name="l00252"></a>00252                            <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* resultDef)<span class="keyword"> const </span>{
<a name="l00253"></a>00253         <span class="comment">/* Construct the MemoryWrite object for the address in question since it&#39;s needed by mustAlias() */</span>
<a name="l00254"></a>00254         <a class="code" href="structMemoryWrite.html" title="Information about the contents of memory at a given address.">MemoryWrite</a> mw;
<a name="l00255"></a>00255         mw.<a class="code" href="structMemoryWrite.html#adcf4704cebd9c4531cd9700527988b5f">address</a> = address;
<a name="l00256"></a>00256         mw.<a class="code" href="structMemoryWrite.html#af1c2a8cf93c214c396251533c66b5296">data</a> = <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;32&gt;::constant</a>(0, resultDef);
<a name="l00257"></a>00257         mw.<a class="code" href="structMemoryWrite.html#a35e235bb9134cc729b8a5174e13a9af1">len</a> = Len / 8;
<a name="l00258"></a>00258 
<a name="l00259"></a>00259         <span class="comment">/* Scan vector until we find a match and then return that value. */</span>
<a name="l00260"></a>00260         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="structMemoryWriteSet.html#aff1aab41effbd5b65c11bebd3e9294ca">writes</a>.size(); ++i) {
<a name="l00261"></a>00261             <span class="keywordflow">if</span> (<a class="code" href="findConstants_8h.html#a3d2a6c2edc28257d61a10d11cf67c5ec" title="Returns true if memory locations a and b are the same (note that &quot;same&quot; is more strict than &quot;overlap&quot;...">mustAlias</a>(<a class="code" href="structMemoryWriteSet.html#aff1aab41effbd5b65c11bebd3e9294ca">writes</a>[i], mw)) {
<a name="l00262"></a>00262                 <span class="comment">//std::cout &lt;&lt; &quot;Found data &quot; &lt;&lt; writes[i].data &lt;&lt; &quot; for address &quot; &lt;&lt; address &lt;&lt; std::endl;</span>
<a name="l00263"></a>00263                 <span class="keyword">const</span> <a class="code" href="structLatticeElement.html">LatticeElement&lt;32&gt;</a>&amp; data = <a class="code" href="structMemoryWriteSet.html#aff1aab41effbd5b65c11bebd3e9294ca">writes</a>[i].data;
<a name="l00264"></a>00264                 result = <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;</a>(data.<a class="code" href="structLatticeElement.html#a4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>, data.<a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a>, data.<a class="code" href="structLatticeElement.html#afb9076844cf7aeb97f205a872b685e1b">definingInstruction</a>, data.<a class="code" href="structLatticeElement.html#a6bfb90dd4b9e80a03cdef7d2f55d78f8">negate</a>, data.<a class="code" href="structLatticeElement.html#a5f7046b6efe5660c07b84883ee26a4cc">offset</a>);
<a name="l00265"></a>00265                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00266"></a>00266             }
<a name="l00267"></a>00267         }
<a name="l00268"></a>00268 
<a name="l00269"></a>00269         <span class="comment">/* No match found */</span>
<a name="l00270"></a>00270         result = <a class="code" href="structMemoryWriteSet.html#a26845f2d2d0f83b00c0156a1642de9c0">isTop</a> ? <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;</a>() : <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;::nonconstant</a>(resultName, resultDef);
<a name="l00271"></a>00271         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273 
<a name="l00274"></a><a class="code" href="structMemoryWriteSet.html#a5f96f9bfa7cc7ca000e22c9eb4b78261">00274</a>     <span class="keyword">static</span> <a class="code" href="structMemoryWriteSet.html" title="A set of values stored in memory.">MemoryWriteSet</a> <a class="code" href="structMemoryWriteSet.html#a5f96f9bfa7cc7ca000e22c9eb4b78261">bottom</a>() {
<a name="l00275"></a>00275         <a class="code" href="structMemoryWriteSet.html" title="A set of values stored in memory.">MemoryWriteSet</a> mws;
<a name="l00276"></a>00276         mws.<a class="code" href="structMemoryWriteSet.html#a26845f2d2d0f83b00c0156a1642de9c0">isTop</a> = <span class="keyword">false</span>;
<a name="l00277"></a>00277         mws.<a class="code" href="structMemoryWriteSet.html#aff1aab41effbd5b65c11bebd3e9294ca">writes</a>.clear();
<a name="l00278"></a>00278         <span class="keywordflow">return</span> mws;
<a name="l00279"></a>00279     }
<a name="l00280"></a>00280 
<a name="l00281"></a><a class="code" href="structMemoryWriteSet.html#a839a6ff0937b5acae8b718c498a66e05">00281</a>     <span class="keywordtype">bool</span> <a class="code" href="structMemoryWriteSet.html#a839a6ff0937b5acae8b718c498a66e05">mergeIn</a>(<span class="keyword">const</span> <a class="code" href="structMemoryWriteSet.html" title="A set of values stored in memory.">MemoryWriteSet</a>&amp; o) { <span class="comment">// Returns to determine whether changes were made</span>
<a name="l00282"></a>00282         <span class="keywordflow">if</span> (o.<a class="code" href="structMemoryWriteSet.html#a26845f2d2d0f83b00c0156a1642de9c0">isTop</a>)
<a name="l00283"></a>00283             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00284"></a>00284         <span class="keywordflow">if</span> (this-&gt;<a class="code" href="structMemoryWriteSet.html#a26845f2d2d0f83b00c0156a1642de9c0">isTop</a>) {
<a name="l00285"></a>00285             *<span class="keyword">this</span> = o;
<a name="l00286"></a>00286             <span class="keywordflow">return</span> !o.<a class="code" href="structMemoryWriteSet.html#a26845f2d2d0f83b00c0156a1642de9c0">isTop</a>;
<a name="l00287"></a>00287         }
<a name="l00288"></a>00288         <span class="keywordtype">bool</span> result = !<a class="code" href="structMemoryWriteSet.html#aff1aab41effbd5b65c11bebd3e9294ca">writes</a>.empty();
<a name="l00289"></a>00289         *<span class="keyword">this</span> = <a class="code" href="structMemoryWriteSet.html#a5f96f9bfa7cc7ca000e22c9eb4b78261">bottom</a>(); <span class="comment">// FIXME [JJW]</span>
<a name="l00290"></a>00290         <span class="keywordflow">return</span> result;
<a name="l00291"></a>00291     }
<a name="l00292"></a>00292 
<a name="l00293"></a><a class="code" href="structMemoryWriteSet.html#af87f4e252204fad19b236b5a076803b6">00293</a>     <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="structMemoryWriteSet.html#af87f4e252204fad19b236b5a076803b6">operator==</a>(<span class="keyword">const</span> <a class="code" href="structMemoryWriteSet.html" title="A set of values stored in memory.">MemoryWriteSet</a>&amp; a, <span class="keyword">const</span> <a class="code" href="structMemoryWriteSet.html" title="A set of values stored in memory.">MemoryWriteSet</a>&amp; b) {
<a name="l00294"></a>00294         <span class="keywordflow">return</span> a.<a class="code" href="structMemoryWriteSet.html#a26845f2d2d0f83b00c0156a1642de9c0">isTop</a> == b.<a class="code" href="structMemoryWriteSet.html#a26845f2d2d0f83b00c0156a1642de9c0">isTop</a> &amp;&amp; (a.<a class="code" href="structMemoryWriteSet.html#a26845f2d2d0f83b00c0156a1642de9c0">isTop</a> || a.<a class="code" href="structMemoryWriteSet.html#aff1aab41effbd5b65c11bebd3e9294ca">writes</a> == b.<a class="code" href="structMemoryWriteSet.html#aff1aab41effbd5b65c11bebd3e9294ca">writes</a>);
<a name="l00295"></a>00295     }
<a name="l00296"></a>00296 };
<a name="l00297"></a>00297 
<a name="l00298"></a><a class="code" href="structMemoryVariable.html">00298</a> <span class="keyword">struct </span><a class="code" href="structMemoryVariable.html">MemoryVariable</a>: <span class="keyword">public</span> <a class="code" href="classVariable.html">Variable</a> {
<a name="l00299"></a><a class="code" href="structMemoryVariable.html#a6a9cd5a38fd49bdf2aabbf8ead3ee0a4">00299</a>     <a class="code" href="structMemoryWriteSet.html" title="A set of values stored in memory.">MemoryWriteSet</a> <a class="code" href="structMemoryVariable.html#a6a9cd5a38fd49bdf2aabbf8ead3ee0a4">mws</a>;
<a name="l00300"></a><a class="code" href="structMemoryVariable.html#af6875e4d6e185fa0be4d1c74b4c527ef">00300</a>     <a class="code" href="structMemoryVariable.html#af6875e4d6e185fa0be4d1c74b4c527ef">MemoryVariable</a>()
<a name="l00301"></a>00301         : <a class="code" href="structMemoryVariable.html#a6a9cd5a38fd49bdf2aabbf8ead3ee0a4">mws</a>()
<a name="l00302"></a>00302         {}
<a name="l00303"></a><a class="code" href="structMemoryVariable.html#a00e681d73a045c3f44ce2758f69b75be">00303</a>     <span class="keywordtype">void</span> <span class="keyword">set</span>(<span class="keyword">const</span> <a class="code" href="structMemoryWriteSet.html" title="A set of values stored in memory.">MemoryWriteSet</a>&amp; s) {
<a name="l00304"></a>00304         <span class="keywordflow">if</span> (<a class="code" href="structMemoryVariable.html#a6a9cd5a38fd49bdf2aabbf8ead3ee0a4">mws</a>.<a class="code" href="structMemoryWriteSet.html#a839a6ff0937b5acae8b718c498a66e05">mergeIn</a>(s)) this-&gt;<a class="code" href="classVariable.html#a76683fcd725489142f0397aa957a966d">pushChanges</a>();
<a name="l00305"></a>00305     }
<a name="l00306"></a><a class="code" href="structMemoryVariable.html#aafe7886f04c547485bb7b0fe23d2093b">00306</a>     <span class="keyword">const</span> <a class="code" href="structMemoryWriteSet.html" title="A set of values stored in memory.">MemoryWriteSet</a>&amp; <span class="keyword">get</span>() <span class="keyword">const</span> {
<a name="l00307"></a>00307         <span class="keywordflow">return</span> <a class="code" href="structMemoryVariable.html#a6a9cd5a38fd49bdf2aabbf8ead3ee0a4">mws</a>;
<a name="l00308"></a>00308     }
<a name="l00309"></a>00309 };
<a name="l00310"></a>00310 
<a name="l00311"></a>00311 <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> OutputLen&gt;
<a name="l00312"></a><a class="code" href="structNullaryConstraint.html">00312</a> <span class="keyword">struct </span><a class="code" href="structNullaryConstraint.html">NullaryConstraint</a>: <span class="keyword">public</span> <a class="code" href="classConstraint.html">Constraint</a> {
<a name="l00313"></a><a class="code" href="structNullaryConstraint.html#a49fd150def191269619c8b9a7a903f9c">00313</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;OutputLen&gt;</a> <a class="code" href="structNullaryConstraint.html#a49fd150def191269619c8b9a7a903f9c">result</a>;
<a name="l00314"></a><a class="code" href="structNullaryConstraint.html#a46951471dbc9e2ec46abcb20ee326f77">00314</a>     <a class="code" href="structNullaryConstraint.html#a46951471dbc9e2ec46abcb20ee326f77">NullaryConstraint</a>(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;OutputLen&gt;</a> <a class="code" href="structNullaryConstraint.html#a49fd150def191269619c8b9a7a903f9c">result</a>): result(result) {}
<a name="l00315"></a><a class="code" href="structNullaryConstraint.html#ada45762ee5b520957b18db4c17c9084e">00315</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structNullaryConstraint.html#ada45762ee5b520957b18db4c17c9084e">run</a>()<span class="keyword"> const </span>{
<a name="l00316"></a>00316         uint64_t newVal = this-&gt;<a class="code" href="structNullaryConstraint.html#a8cc9dfa2f454decab7eb5fd2a96eaf11">compute</a>();
<a name="l00317"></a>00317         <a class="code" href="structNullaryConstraint.html#a49fd150def191269619c8b9a7a903f9c">result</a>-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;OutputLen&gt;::constant</a>(newVal, <a class="code" href="structNullaryConstraint.html#a49fd150def191269619c8b9a7a903f9c">result</a>-&gt;def));
<a name="l00318"></a>00318     }
<a name="l00319"></a><a class="code" href="structNullaryConstraint.html#aa078a1003047b3ae11689cd69619855e">00319</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structNullaryConstraint.html#aa078a1003047b3ae11689cd69619855e">markDependencies</a>() {}
<a name="l00320"></a>00320     <span class="keyword">virtual</span> uint64_t <a class="code" href="structNullaryConstraint.html#a8cc9dfa2f454decab7eb5fd2a96eaf11">compute</a>() <span class="keyword">const</span> = 0;
<a name="l00321"></a>00321 };
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> InputLen, <span class="keywordtype">size_t</span> OutputLen&gt;
<a name="l00324"></a><a class="code" href="structUnaryConstraint.html">00324</a> <span class="keyword">struct </span><a class="code" href="structUnaryConstraint.html">UnaryConstraint</a>: <span class="keyword">public</span> <a class="code" href="classConstraint.html">Constraint</a> {
<a name="l00325"></a><a class="code" href="structUnaryConstraint.html#aeb585e2c7c0d5b9d0a124279f6f068d0">00325</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;OutputLen&gt;</a> <a class="code" href="structUnaryConstraint.html#aeb585e2c7c0d5b9d0a124279f6f068d0">result</a>;
<a name="l00326"></a><a class="code" href="structUnaryConstraint.html#ac400a879600dfa33358fd0450572dec3">00326</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;InputLen&gt;</a> <a class="code" href="structUnaryConstraint.html#ac400a879600dfa33358fd0450572dec3">var</a>;
<a name="l00327"></a><a class="code" href="structUnaryConstraint.html#a3ecf580e67e7aa19cc0c33f63bee4d5d">00327</a>     <a class="code" href="structUnaryConstraint.html#a3ecf580e67e7aa19cc0c33f63bee4d5d">UnaryConstraint</a>(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;OutputLen&gt;</a> <a class="code" href="structUnaryConstraint.html#aeb585e2c7c0d5b9d0a124279f6f068d0">result</a>, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;InputLen&gt;</a> <a class="code" href="structUnaryConstraint.html#ac400a879600dfa33358fd0450572dec3">var</a>)
<a name="l00328"></a>00328         : result(result), var(var)
<a name="l00329"></a>00329         {}
<a name="l00330"></a><a class="code" href="structUnaryConstraint.html#af56691457ea071d4be7166196b3f9998">00330</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structUnaryConstraint.html#af56691457ea071d4be7166196b3f9998">run</a>()<span class="keyword"> const </span>{
<a name="l00331"></a>00331         <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;InputLen&gt;</a> le = <a class="code" href="structUnaryConstraint.html#ac400a879600dfa33358fd0450572dec3">var</a>-&gt;get();
<a name="l00332"></a>00332         <span class="keywordflow">if</span> (le.<a class="code" href="structLatticeElement.html#a4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>) {<a class="code" href="structUnaryConstraint.html#aeb585e2c7c0d5b9d0a124279f6f068d0">result</a>-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;OutputLen&gt;</a>()); <span class="keywordflow">return</span>;}
<a name="l00333"></a>00333         <span class="keywordflow">if</span> (le.<a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a> != 0) {<a class="code" href="structUnaryConstraint.html#aeb585e2c7c0d5b9d0a124279f6f068d0">result</a>-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;OutputLen&gt;::nonconstant</a>(<a class="code" href="structUnaryConstraint.html#aeb585e2c7c0d5b9d0a124279f6f068d0">result</a>-&gt;myName, <a class="code" href="structUnaryConstraint.html#aeb585e2c7c0d5b9d0a124279f6f068d0">result</a>-&gt;def)); <span class="keywordflow">return</span>;}
<a name="l00334"></a>00334         uint64_t newVal = this-&gt;<a class="code" href="structUnaryConstraint.html#af43794932a7875a2d67ccc96d880a966">compute</a>(le.<a class="code" href="structLatticeElement.html#a5f7046b6efe5660c07b84883ee26a4cc">offset</a>);
<a name="l00335"></a>00335         <a class="code" href="structUnaryConstraint.html#aeb585e2c7c0d5b9d0a124279f6f068d0">result</a>-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;OutputLen&gt;::constant</a>(newVal, <a class="code" href="structUnaryConstraint.html#aeb585e2c7c0d5b9d0a124279f6f068d0">result</a>-&gt;def));
<a name="l00336"></a>00336     }
<a name="l00337"></a><a class="code" href="structUnaryConstraint.html#aec2e1af9d980149154d8334dc7473926">00337</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structUnaryConstraint.html#aec2e1af9d980149154d8334dc7473926">markDependencies</a>() {
<a name="l00338"></a>00338         <a class="code" href="classConstraint.html#a30feaf180bce5c1a0cfeee0be9983a93">addDependency</a>(<a class="code" href="structUnaryConstraint.html#ac400a879600dfa33358fd0450572dec3">var</a>);
<a name="l00339"></a>00339     }
<a name="l00340"></a>00340     <span class="keyword">virtual</span> uint64_t <a class="code" href="structUnaryConstraint.html#af43794932a7875a2d67ccc96d880a966">compute</a>(uint64_t a) <span class="keyword">const</span> = 0;
<a name="l00341"></a>00341 };
<a name="l00342"></a>00342 
<a name="l00343"></a><a class="code" href="findConstants_8h.html#ae7b82ea56326cd6904040a31de88c3c3">00343</a> <span class="preprocessor">#define UNARY_COMPUTATION(name, InLen, OutLen, Formula)                                                                        \</span>
<a name="l00344"></a>00344 <span class="preprocessor">    XVariablePtr&lt;(OutLen)&gt; name(XVariablePtr&lt;(InLen)&gt; a) {                                                                     \</span>
<a name="l00345"></a>00345 <span class="preprocessor">        XVariablePtr&lt;(OutLen)&gt; result = new XVariable&lt;(OutLen)&gt;();                                                             \</span>
<a name="l00346"></a>00346 <span class="preprocessor">        struct IC: public UnaryConstraint&lt;(InLen), (OutLen)&gt; {                                                                 \</span>
<a name="l00347"></a>00347 <span class="preprocessor">            IC(XVariablePtr&lt;(OutLen)&gt; result, XVariablePtr&lt;(InLen)&gt; var1)                                                      \</span>
<a name="l00348"></a>00348 <span class="preprocessor">                : UnaryConstraint&lt;(InLen), (OutLen)&gt;(result, var1)                                                             \</span>
<a name="l00349"></a>00349 <span class="preprocessor">                {}                                                                                                             \</span>
<a name="l00350"></a>00350 <span class="preprocessor">            virtual uint64_t compute(uint64_t a) const {                                                                       \</span>
<a name="l00351"></a>00351 <span class="preprocessor">                Formula                                                                                                        \</span>
<a name="l00352"></a>00352 <span class="preprocessor">            }                                                                                                                  \</span>
<a name="l00353"></a>00353 <span class="preprocessor">        };                                                                                                                     \</span>
<a name="l00354"></a>00354 <span class="preprocessor">        (new IC(result, a))-&gt;activate();                                                                                       \</span>
<a name="l00355"></a>00355 <span class="preprocessor">        return result;                                                                                                         \</span>
<a name="l00356"></a>00356 <span class="preprocessor">    }</span>
<a name="l00357"></a>00357 <span class="preprocessor"></span>
<a name="l00358"></a><a class="code" href="findConstants_8h.html#afad9707ae789a80804091a4b4cf02255">00358</a> <span class="preprocessor">#define UNARY_COMPUTATION_SPECIAL(name, InLen1, OutLen, Formula)                                                               \</span>
<a name="l00359"></a>00359 <span class="preprocessor">    XVariablePtr&lt;(OutLen)&gt; name(XVariablePtr&lt;(InLen1)&gt; a) {                                                                    \</span>
<a name="l00360"></a>00360 <span class="preprocessor">        XVariablePtr&lt;(OutLen)&gt; result = new XVariable&lt;(OutLen)&gt;();                                                             \</span>
<a name="l00361"></a>00361 <span class="preprocessor">        struct IC: public UnaryConstraint&lt;(InLen1), (OutLen)&gt; {                                                                \</span>
<a name="l00362"></a>00362 <span class="preprocessor">            IC(XVariablePtr&lt;(OutLen)&gt; result, XVariablePtr&lt;(InLen1)&gt; var1)                                                     \</span>
<a name="l00363"></a>00363 <span class="preprocessor">                : UnaryConstraint&lt;(InLen1), (OutLen)&gt;(result, var1)                                                            \</span>
<a name="l00364"></a>00364 <span class="preprocessor">                {}                                                                                                             \</span>
<a name="l00365"></a>00365 <span class="preprocessor">            virtual void run() const {                                                                                         \</span>
<a name="l00366"></a>00366 <span class="preprocessor">                LatticeElement&lt;(InLen1)&gt; le1 = UnaryConstraint&lt;(InLen1), (OutLen)&gt;::var-&gt;get();                                \</span>
<a name="l00367"></a>00367 <span class="preprocessor">                XVariablePtr&lt;(OutLen)&gt; result = UnaryConstraint&lt;(InLen1), (OutLen)&gt;::result;                                   \</span>
<a name="l00368"></a>00368 <span class="preprocessor">                if (le1.isTop) {result-&gt;set(LatticeElement&lt;(OutLen)&gt;()); return;}                                              \</span>
<a name="l00369"></a>00369 <span class="preprocessor">                Formula                                                                                                        \</span>
<a name="l00370"></a>00370 <span class="preprocessor">            }                                                                                                                  \</span>
<a name="l00371"></a>00371 <span class="preprocessor">            virtual uint64_t compute(uint64_t) const {abort();}                                                                \</span>
<a name="l00372"></a>00372 <span class="preprocessor">        };                                                                                                                     \</span>
<a name="l00373"></a>00373 <span class="preprocessor">        (new IC(result, a))-&gt;activate();                                                                                       \</span>
<a name="l00374"></a>00374 <span class="preprocessor">        return result;                                                                                                         \</span>
<a name="l00375"></a>00375 <span class="preprocessor">    }</span>
<a name="l00376"></a>00376 <span class="preprocessor"></span>
<a name="l00377"></a>00377 <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> InputLen1, <span class="keywordtype">size_t</span> InputLen2, <span class="keywordtype">size_t</span> OutputLen&gt;
<a name="l00378"></a><a class="code" href="structBinaryConstraint.html">00378</a> <span class="keyword">struct </span><a class="code" href="structBinaryConstraint.html">BinaryConstraint</a>: <span class="keyword">public</span> <a class="code" href="classConstraint.html">Constraint</a> {
<a name="l00379"></a><a class="code" href="structBinaryConstraint.html#ad9d52240a0050909996e7adf94ba1540">00379</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;OutputLen&gt;</a> <a class="code" href="structBinaryConstraint.html#ad9d52240a0050909996e7adf94ba1540">result</a>;
<a name="l00380"></a><a class="code" href="structBinaryConstraint.html#a542b1bd52df0ceca1c8320e1f2048c9f">00380</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;InputLen1&gt;</a> <a class="code" href="structBinaryConstraint.html#a542b1bd52df0ceca1c8320e1f2048c9f">var1</a>;
<a name="l00381"></a><a class="code" href="structBinaryConstraint.html#aaada355823e276f040a2627de612fd8e">00381</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;InputLen2&gt;</a> <a class="code" href="structBinaryConstraint.html#aaada355823e276f040a2627de612fd8e">var2</a>;
<a name="l00382"></a>00382 
<a name="l00383"></a><a class="code" href="structBinaryConstraint.html#a26330bf8c82509bf61fe35fdf626aa65">00383</a>     <a class="code" href="structBinaryConstraint.html#a26330bf8c82509bf61fe35fdf626aa65">BinaryConstraint</a>(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;OutputLen&gt;</a> <a class="code" href="structBinaryConstraint.html#ad9d52240a0050909996e7adf94ba1540">result</a>, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;InputLen1&gt;</a> <a class="code" href="structBinaryConstraint.html#a542b1bd52df0ceca1c8320e1f2048c9f">var1</a>, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;InputLen2&gt;</a> <a class="code" href="structBinaryConstraint.html#aaada355823e276f040a2627de612fd8e">var2</a>)
<a name="l00384"></a>00384         : result(result), var1(var1), var2(var2)
<a name="l00385"></a>00385         {}
<a name="l00386"></a>00386 
<a name="l00387"></a><a class="code" href="structBinaryConstraint.html#a64afc7dbfb8b656cdc24cff9cd081157">00387</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structBinaryConstraint.html#a64afc7dbfb8b656cdc24cff9cd081157">run</a>()<span class="keyword"> const </span>{
<a name="l00388"></a>00388         <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;InputLen1&gt;</a> le1 = <a class="code" href="structBinaryConstraint.html#a542b1bd52df0ceca1c8320e1f2048c9f">var1</a>-&gt;get();
<a name="l00389"></a>00389         <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;InputLen2&gt;</a> le2 = <a class="code" href="structBinaryConstraint.html#aaada355823e276f040a2627de612fd8e">var2</a>-&gt;get();
<a name="l00390"></a>00390         <span class="keywordflow">if</span> (le1.<a class="code" href="structLatticeElement.html#a4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a> || le2.<a class="code" href="structLatticeElement.html#a4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>) {
<a name="l00391"></a>00391             <a class="code" href="structBinaryConstraint.html#ad9d52240a0050909996e7adf94ba1540">result</a>-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;OutputLen&gt;</a>());
<a name="l00392"></a>00392             <span class="keywordflow">return</span>;
<a name="l00393"></a>00393         }
<a name="l00394"></a>00394         <span class="keywordflow">if</span> (le1.<a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a> != 0 || le2.<a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a> != 0) {
<a name="l00395"></a>00395             <a class="code" href="structBinaryConstraint.html#ad9d52240a0050909996e7adf94ba1540">result</a>-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;OutputLen&gt;::nonconstant</a>(<a class="code" href="structBinaryConstraint.html#ad9d52240a0050909996e7adf94ba1540">result</a>-&gt;myName, <a class="code" href="structBinaryConstraint.html#ad9d52240a0050909996e7adf94ba1540">result</a>-&gt;def));
<a name="l00396"></a>00396             <span class="keywordflow">return</span>;
<a name="l00397"></a>00397         }
<a name="l00398"></a>00398         uint64_t newVal = this-&gt;<a class="code" href="structBinaryConstraint.html#a892b2699bf75e092f00b32da011f4255">compute</a>(le1.<a class="code" href="structLatticeElement.html#a5f7046b6efe5660c07b84883ee26a4cc">offset</a>, le2.<a class="code" href="structLatticeElement.html#a5f7046b6efe5660c07b84883ee26a4cc">offset</a>);
<a name="l00399"></a>00399         <a class="code" href="structBinaryConstraint.html#ad9d52240a0050909996e7adf94ba1540">result</a>-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;OutputLen&gt;::constant</a>(newVal, <a class="code" href="structBinaryConstraint.html#ad9d52240a0050909996e7adf94ba1540">result</a>-&gt;def));
<a name="l00400"></a>00400     }
<a name="l00401"></a>00401 
<a name="l00402"></a><a class="code" href="structBinaryConstraint.html#a3614385210c3c599b0d31fec62d3e129">00402</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structBinaryConstraint.html#a3614385210c3c599b0d31fec62d3e129">markDependencies</a>() {
<a name="l00403"></a>00403         <a class="code" href="classConstraint.html#a30feaf180bce5c1a0cfeee0be9983a93">addDependency</a>(<a class="code" href="structBinaryConstraint.html#a542b1bd52df0ceca1c8320e1f2048c9f">var1</a>);
<a name="l00404"></a>00404         <a class="code" href="classConstraint.html#a30feaf180bce5c1a0cfeee0be9983a93">addDependency</a>(<a class="code" href="structBinaryConstraint.html#aaada355823e276f040a2627de612fd8e">var2</a>);
<a name="l00405"></a>00405     }
<a name="l00406"></a>00406     <span class="keyword">virtual</span> uint64_t <a class="code" href="structBinaryConstraint.html#a892b2699bf75e092f00b32da011f4255">compute</a>(uint64_t a, uint64_t b) <span class="keyword">const</span> = 0;
<a name="l00407"></a>00407 };
<a name="l00408"></a>00408 
<a name="l00409"></a><a class="code" href="findConstants_8h.html#a0c4b579c98b326eab605862dc73feb78">00409</a> <span class="preprocessor">#define BINARY_COMPUTATION(name, InLen1, InLen2, OutLen, Formula)                                                              \</span>
<a name="l00410"></a>00410 <span class="preprocessor">    XVariablePtr&lt;(OutLen)&gt; name(XVariablePtr&lt;(InLen1)&gt; a, XVariablePtr&lt;(InLen2)&gt; b) {                                          \</span>
<a name="l00411"></a>00411 <span class="preprocessor">        XVariablePtr&lt;(OutLen)&gt; result = new XVariable&lt;(OutLen)&gt;();                                                             \</span>
<a name="l00412"></a>00412 <span class="preprocessor">        struct IC: public BinaryConstraint&lt;(InLen1), (InLen2), (OutLen)&gt; {                                                     \</span>
<a name="l00413"></a>00413 <span class="preprocessor">            IC(XVariablePtr&lt;(OutLen)&gt; result, XVariablePtr&lt;(InLen1)&gt; var1, XVariablePtr&lt;(InLen2)&gt; var2)                        \</span>
<a name="l00414"></a>00414 <span class="preprocessor">                : BinaryConstraint&lt;(InLen1), (InLen2), (OutLen)&gt;(result, var1, var2)                                           \</span>
<a name="l00415"></a>00415 <span class="preprocessor">                {}                                                                                                             \</span>
<a name="l00416"></a>00416 <span class="preprocessor">            virtual uint64_t compute(uint64_t a, uint64_t b) const {                                                           \</span>
<a name="l00417"></a>00417 <span class="preprocessor">                Formula                                                                                                        \</span>
<a name="l00418"></a>00418 <span class="preprocessor">            }                                                                                                                  \</span>
<a name="l00419"></a>00419 <span class="preprocessor">        };                                                                                                                     \</span>
<a name="l00420"></a>00420 <span class="preprocessor">        (new IC(result, a, b))-&gt;activate();                                                                                    \</span>
<a name="l00421"></a>00421 <span class="preprocessor">        return result;                                                                                                         \</span>
<a name="l00422"></a>00422 <span class="preprocessor">    }</span>
<a name="l00423"></a>00423 <span class="preprocessor"></span>
<a name="l00424"></a><a class="code" href="findConstants_8h.html#ab60e9a0c85be40774c6f3a44bf7bbc26">00424</a> <span class="preprocessor">#define BINARY_COMPUTATION_SPECIAL(name, InLen1, InLen2, OutLen, Formula)                                                      \</span>
<a name="l00425"></a>00425 <span class="preprocessor">    XVariablePtr&lt;(OutLen)&gt; name(XVariablePtr&lt;(InLen1)&gt; a, XVariablePtr&lt;(InLen2)&gt; b) {                                          \</span>
<a name="l00426"></a>00426 <span class="preprocessor">        XVariablePtr&lt;(OutLen)&gt; result = new XVariable&lt;(OutLen)&gt;();                                                             \</span>
<a name="l00427"></a>00427 <span class="preprocessor">        struct IC: public BinaryConstraint&lt;(InLen1), (InLen2), (OutLen)&gt; {                                                     \</span>
<a name="l00428"></a>00428 <span class="preprocessor">            IC(XVariablePtr&lt;(OutLen)&gt; result, XVariablePtr&lt;(InLen1)&gt; var1, XVariablePtr&lt;(InLen2)&gt; var2)                        \</span>
<a name="l00429"></a>00429 <span class="preprocessor">                : BinaryConstraint&lt;(InLen1), (InLen2), (OutLen)&gt;(result, var1, var2)                                           \</span>
<a name="l00430"></a>00430 <span class="preprocessor">                {}                                                                                                             \</span>
<a name="l00431"></a>00431 <span class="preprocessor">            virtual void run() const {                                                                                         \</span>
<a name="l00432"></a>00432 <span class="preprocessor">                LatticeElement&lt;(InLen1)&gt; le1 = BinaryConstraint&lt;(InLen1), (InLen2), (OutLen)&gt;::var1-&gt;get();                    \</span>
<a name="l00433"></a>00433 <span class="preprocessor">                LatticeElement&lt;(InLen2)&gt; le2 = BinaryConstraint&lt;(InLen1), (InLen2), (OutLen)&gt;::var2-&gt;get();                    \</span>
<a name="l00434"></a>00434 <span class="preprocessor">                XVariablePtr&lt;(OutLen)&gt; result = BinaryConstraint&lt;(InLen1), (InLen2), (OutLen)&gt;::result;                        \</span>
<a name="l00435"></a>00435 <span class="preprocessor">                if (le1.isTop || le2.isTop) {                                                                                  \</span>
<a name="l00436"></a>00436 <span class="preprocessor">                    result-&gt;set(LatticeElement&lt;(OutLen)&gt;());                                                                   \</span>
<a name="l00437"></a>00437 <span class="preprocessor">                    return;                                                                                                    \</span>
<a name="l00438"></a>00438 <span class="preprocessor">                }                                                                                                              \</span>
<a name="l00439"></a>00439 <span class="preprocessor">                Formula                                                                                                        \</span>
<a name="l00440"></a>00440 <span class="preprocessor">            }                                                                                                                  \</span>
<a name="l00441"></a>00441 <span class="preprocessor">            virtual uint64_t compute(uint64_t, uint64_t) const {                                                               \</span>
<a name="l00442"></a>00442 <span class="preprocessor">                abort();                                                                                                       \</span>
<a name="l00443"></a>00443 <span class="preprocessor">            }                                                                                                                  \</span>
<a name="l00444"></a>00444 <span class="preprocessor">        };                                                                                                                     \</span>
<a name="l00445"></a>00445 <span class="preprocessor">        (new IC(result, a, b))-&gt;activate();                                                                                    \</span>
<a name="l00446"></a>00446 <span class="preprocessor">        return result;                                                                                                         \</span>
<a name="l00447"></a>00447 <span class="preprocessor">    }</span>
<a name="l00448"></a>00448 <span class="preprocessor"></span>
<a name="l00449"></a>00449 <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> InputLen1, <span class="keywordtype">size_t</span> InputLen2, <span class="keywordtype">size_t</span> InputLen3, <span class="keywordtype">size_t</span> OutputLen&gt;
<a name="l00450"></a><a class="code" href="structTernaryConstraint.html">00450</a> <span class="keyword">struct </span><a class="code" href="structTernaryConstraint.html">TernaryConstraint</a>: <span class="keyword">public</span> <a class="code" href="classConstraint.html">Constraint</a> {
<a name="l00451"></a><a class="code" href="structTernaryConstraint.html#a7ef7798903c05d6335a6db862e1a11ac">00451</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;OutputLen&gt;</a> <a class="code" href="structTernaryConstraint.html#a7ef7798903c05d6335a6db862e1a11ac">result</a>;
<a name="l00452"></a><a class="code" href="structTernaryConstraint.html#a9263625a6a3ffe8d08e9939134a23a7f">00452</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;InputLen1&gt;</a> <a class="code" href="structTernaryConstraint.html#a9263625a6a3ffe8d08e9939134a23a7f">var1</a>;
<a name="l00453"></a><a class="code" href="structTernaryConstraint.html#ad154ce39959516e35d7932d1733a98a7">00453</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;InputLen2&gt;</a> <a class="code" href="structTernaryConstraint.html#ad154ce39959516e35d7932d1733a98a7">var2</a>;
<a name="l00454"></a><a class="code" href="structTernaryConstraint.html#ac4036ce47553d33afd80e9c4850a1dee">00454</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;InputLen3&gt;</a> <a class="code" href="structTernaryConstraint.html#ac4036ce47553d33afd80e9c4850a1dee">var3</a>;
<a name="l00455"></a>00455 
<a name="l00456"></a><a class="code" href="structTernaryConstraint.html#a325c61b765e7e13049c0b36d341ababb">00456</a>     <a class="code" href="structTernaryConstraint.html#a325c61b765e7e13049c0b36d341ababb">TernaryConstraint</a>(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;OutputLen&gt;</a> <a class="code" href="structTernaryConstraint.html#a7ef7798903c05d6335a6db862e1a11ac">result</a>,
<a name="l00457"></a>00457                       <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;InputLen1&gt;</a> <a class="code" href="structTernaryConstraint.html#a9263625a6a3ffe8d08e9939134a23a7f">var1</a>, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;InputLen2&gt;</a> <a class="code" href="structTernaryConstraint.html#ad154ce39959516e35d7932d1733a98a7">var2</a>, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;InputLen3&gt;</a> <a class="code" href="structTernaryConstraint.html#ac4036ce47553d33afd80e9c4850a1dee">var3</a>)
<a name="l00458"></a>00458         : result(result), var1(var1), var2(var2), var3(var3)
<a name="l00459"></a>00459         {}
<a name="l00460"></a>00460 
<a name="l00461"></a><a class="code" href="structTernaryConstraint.html#a23c2a3f6d6a876da11bbf3b90074ef0c">00461</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structTernaryConstraint.html#a23c2a3f6d6a876da11bbf3b90074ef0c">run</a>()<span class="keyword"> const </span>{
<a name="l00462"></a>00462         <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;InputLen1&gt;</a> le1 = <a class="code" href="structTernaryConstraint.html#a9263625a6a3ffe8d08e9939134a23a7f">var1</a>-&gt;get();
<a name="l00463"></a>00463         <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;InputLen2&gt;</a> le2 = <a class="code" href="structTernaryConstraint.html#ad154ce39959516e35d7932d1733a98a7">var2</a>-&gt;get();
<a name="l00464"></a>00464         <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;InputLen3&gt;</a> le3 = <a class="code" href="structTernaryConstraint.html#ac4036ce47553d33afd80e9c4850a1dee">var3</a>-&gt;get();
<a name="l00465"></a>00465         <span class="keywordflow">if</span> (le1.<a class="code" href="structLatticeElement.html#a4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a> || le2.<a class="code" href="structLatticeElement.html#a4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a> || le3.<a class="code" href="structLatticeElement.html#a4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>) {
<a name="l00466"></a>00466             <a class="code" href="structTernaryConstraint.html#a7ef7798903c05d6335a6db862e1a11ac">result</a>-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;OutputLen&gt;</a>());
<a name="l00467"></a>00467             <span class="keywordflow">return</span>;
<a name="l00468"></a>00468         }
<a name="l00469"></a>00469         <span class="keywordflow">if</span> (le1.<a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a> != 0 || le2.<a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a> != 0 || le3.<a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a> != 0) {
<a name="l00470"></a>00470             <a class="code" href="structTernaryConstraint.html#a7ef7798903c05d6335a6db862e1a11ac">result</a>-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;OutputLen&gt;::nonconstant</a>(<a class="code" href="structTernaryConstraint.html#a7ef7798903c05d6335a6db862e1a11ac">result</a>-&gt;myName, <a class="code" href="structTernaryConstraint.html#a7ef7798903c05d6335a6db862e1a11ac">result</a>-&gt;def));
<a name="l00471"></a>00471             <span class="keywordflow">return</span>;
<a name="l00472"></a>00472         }
<a name="l00473"></a>00473         uint64_t newVal = this-&gt;<a class="code" href="structTernaryConstraint.html#acb8a3f159a040412a12b631c13859387">compute</a>(le1.<a class="code" href="structLatticeElement.html#a5f7046b6efe5660c07b84883ee26a4cc">offset</a>, le2.<a class="code" href="structLatticeElement.html#a5f7046b6efe5660c07b84883ee26a4cc">offset</a>, le3.<a class="code" href="structLatticeElement.html#a5f7046b6efe5660c07b84883ee26a4cc">offset</a>);
<a name="l00474"></a>00474         <a class="code" href="structTernaryConstraint.html#a7ef7798903c05d6335a6db862e1a11ac">result</a>-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;OutputLen&gt;::constant</a>(newVal, <a class="code" href="structTernaryConstraint.html#a7ef7798903c05d6335a6db862e1a11ac">result</a>-&gt;def));
<a name="l00475"></a>00475     }
<a name="l00476"></a>00476 
<a name="l00477"></a><a class="code" href="structTernaryConstraint.html#aabe5c9b54e4449abc4949771d03af252">00477</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structTernaryConstraint.html#aabe5c9b54e4449abc4949771d03af252">markDependencies</a>() {
<a name="l00478"></a>00478         <a class="code" href="classConstraint.html#a30feaf180bce5c1a0cfeee0be9983a93">addDependency</a>(<a class="code" href="structTernaryConstraint.html#a9263625a6a3ffe8d08e9939134a23a7f">var1</a>);
<a name="l00479"></a>00479         <a class="code" href="classConstraint.html#a30feaf180bce5c1a0cfeee0be9983a93">addDependency</a>(<a class="code" href="structTernaryConstraint.html#ad154ce39959516e35d7932d1733a98a7">var2</a>);
<a name="l00480"></a>00480         <a class="code" href="classConstraint.html#a30feaf180bce5c1a0cfeee0be9983a93">addDependency</a>(<a class="code" href="structTernaryConstraint.html#ac4036ce47553d33afd80e9c4850a1dee">var3</a>);
<a name="l00481"></a>00481     }
<a name="l00482"></a>00482 
<a name="l00483"></a>00483     <span class="keyword">virtual</span> uint64_t <a class="code" href="structTernaryConstraint.html#acb8a3f159a040412a12b631c13859387">compute</a>(uint64_t a, uint64_t b, uint64_t c) <span class="keyword">const</span> = 0;
<a name="l00484"></a>00484 };
<a name="l00485"></a>00485 
<a name="l00486"></a><a class="code" href="findConstants_8h.html#ac665060a61498a5dc2f60f3fb9a0dd52">00486</a> <span class="preprocessor">#define TERNARY_COMPUTATION(name, InLen1, InLen2, InLen3, OutLen, Formula)                                                     \</span>
<a name="l00487"></a>00487 <span class="preprocessor">    XVariablePtr&lt;(OutLen)&gt; name(XVariablePtr&lt;(InLen1)&gt; a, XVariablePtr&lt;(InLen2)&gt; b, XVariablePtr&lt;(InLen3)&gt; c) {                \</span>
<a name="l00488"></a>00488 <span class="preprocessor">        XVariable&lt;(OutLen)&gt;* result = new XVariable&lt;(OutLen)&gt;();                                                               \</span>
<a name="l00489"></a>00489 <span class="preprocessor">        struct IC: public TernaryConstraint&lt;(InLen1), (InLen2), (InLen3), (OutLen)&gt; {                                          \</span>
<a name="l00490"></a>00490 <span class="preprocessor">            IC(XVariablePtr&lt;(OutLen)&gt; result,                                                                                  \</span>
<a name="l00491"></a>00491 <span class="preprocessor">               XVariablePtr&lt;(InLen1)&gt; var1, XVariablePtr&lt;(InLen2)&gt; var2, XVariablePtr&lt;(InLen3)&gt; var3)                          \</span>
<a name="l00492"></a>00492 <span class="preprocessor">                : TernaryConstraint&lt;(InLen1), (InLen2), (InLen3), (OutLen)&gt;(result, var1, var2, var3)                          \</span>
<a name="l00493"></a>00493 <span class="preprocessor">                {}                                                                                                             \</span>
<a name="l00494"></a>00494 <span class="preprocessor">            virtual uint64_t compute(uint64_t a, uint64_t b, uint64_t c) const {                                               \</span>
<a name="l00495"></a>00495 <span class="preprocessor">                Formula                                                                                                        \</span>
<a name="l00496"></a>00496 <span class="preprocessor">            }                                                                                                                  \</span>
<a name="l00497"></a>00497 <span class="preprocessor">        };                                                                                                                     \</span>
<a name="l00498"></a>00498 <span class="preprocessor">        (new IC(result, a, b, c))-&gt;activate();                                                                                 \</span>
<a name="l00499"></a>00499 <span class="preprocessor">        return result;                                                                                                         \</span>
<a name="l00500"></a>00500 <span class="preprocessor">    }</span>
<a name="l00501"></a>00501 <span class="preprocessor"></span>
<a name="l00502"></a><a class="code" href="findConstants_8h.html#acfeda32a953312c23784c6cd3c9ef85c">00502</a> <span class="preprocessor">#define TERNARY_COMPUTATION_SPECIAL(name, InLen1, InLen2, InLen3, OutLen, Formula)                                             \</span>
<a name="l00503"></a>00503 <span class="preprocessor">    XVariablePtr&lt;(OutLen)&gt; name(XVariablePtr&lt;(InLen1)&gt; a, XVariablePtr&lt;(InLen2)&gt; b, XVariablePtr&lt;(InLen3)&gt; c) {                \</span>
<a name="l00504"></a>00504 <span class="preprocessor">        XVariablePtr&lt;(OutLen)&gt; result = new XVariable&lt;(OutLen)&gt;();                                                             \</span>
<a name="l00505"></a>00505 <span class="preprocessor">        struct IC: public TernaryConstraint&lt;(InLen1), (InLen2), (InLen3), (OutLen)&gt; {                                          \</span>
<a name="l00506"></a>00506 <span class="preprocessor">            IC(XVariablePtr&lt;(OutLen)&gt; result,                                                                                  \</span>
<a name="l00507"></a>00507 <span class="preprocessor">               XVariablePtr&lt;(InLen1)&gt; var1, XVariablePtr&lt;(InLen2)&gt; var2, XVariablePtr&lt;(InLen3)&gt; var3)                          \</span>
<a name="l00508"></a>00508 <span class="preprocessor">                : TernaryConstraint&lt;(InLen1), (InLen2), (InLen3), (OutLen)&gt;(result, var1, var2, var3)                          \</span>
<a name="l00509"></a>00509 <span class="preprocessor">                {}                                                                                                             \</span>
<a name="l00510"></a>00510 <span class="preprocessor">            virtual void run() const {                                                                                         \</span>
<a name="l00511"></a>00511 <span class="preprocessor">                LatticeElement&lt;(InLen1)&gt; le1 = TernaryConstraint&lt;(InLen1), (InLen2), (InLen3), (OutLen)&gt;::var1-&gt;get();         \</span>
<a name="l00512"></a>00512 <span class="preprocessor">                LatticeElement&lt;(InLen2)&gt; le2 = TernaryConstraint&lt;(InLen1), (InLen2), (InLen3), (OutLen)&gt;::var2-&gt;get();         \</span>
<a name="l00513"></a>00513 <span class="preprocessor">                LatticeElement&lt;(InLen3)&gt; le3 = TernaryConstraint&lt;(InLen1), (InLen2), (InLen3), (OutLen)&gt;::var3-&gt;get();         \</span>
<a name="l00514"></a>00514 <span class="preprocessor">                XVariablePtr&lt;(OutLen)&gt; result = TernaryConstraint&lt;(InLen1), (InLen2), (InLen3), (OutLen)&gt;::result;             \</span>
<a name="l00515"></a>00515 <span class="preprocessor">                if (le1.isTop || le2.isTop || le3.isTop) {                                                                     \</span>
<a name="l00516"></a>00516 <span class="preprocessor">                    result-&gt;set(LatticeElement&lt;(OutLen)&gt;());                                                                   \</span>
<a name="l00517"></a>00517 <span class="preprocessor">                    return;                                                                                                    \</span>
<a name="l00518"></a>00518 <span class="preprocessor">                }                                                                                                              \</span>
<a name="l00519"></a>00519 <span class="preprocessor">                Formula                                                                                                        \</span>
<a name="l00520"></a>00520 <span class="preprocessor">            }                                                                                                                  \</span>
<a name="l00521"></a>00521 <span class="preprocessor">            virtual uint64_t compute(uint64_t, uint64_t, uint64_t) const {                                                     \</span>
<a name="l00522"></a>00522 <span class="preprocessor">                abort();                                                                                                       \</span>
<a name="l00523"></a>00523 <span class="preprocessor">            }                                                                                                                  \</span>
<a name="l00524"></a>00524 <span class="preprocessor">        };                                                                                                                     \</span>
<a name="l00525"></a>00525 <span class="preprocessor">        (new IC(result, a, b, c))-&gt;activate();                                                                                 \</span>
<a name="l00526"></a>00526 <span class="preprocessor">        return result;                                                                                                         \</span>
<a name="l00527"></a>00527 <span class="preprocessor">    }</span>
<a name="l00528"></a>00528 <span class="preprocessor"></span>
<a name="l00529"></a>00529 
<a name="l00530"></a>00530 <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00531"></a><a class="code" href="structMergeConstraint.html">00531</a> <span class="keyword">struct </span><a class="code" href="structMergeConstraint.html">MergeConstraint</a>: <span class="keyword">public</span> <a class="code" href="classConstraint.html">Constraint</a> {
<a name="l00532"></a><a class="code" href="structMergeConstraint.html#ac157a836a0e36eb0dfcfa74c03d125e4">00532</a>     <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> <a class="code" href="structMergeConstraint.html#ac157a836a0e36eb0dfcfa74c03d125e4">result</a>;
<a name="l00533"></a><a class="code" href="structMergeConstraint.html#ac5f2f712832154cdff7028bbd3508424">00533</a>     <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> <a class="code" href="structMergeConstraint.html#ac5f2f712832154cdff7028bbd3508424">var1</a>;
<a name="l00534"></a><a class="code" href="structMergeConstraint.html#ad139b71af7af9ea9de1cab2237cb4b5d">00534</a>     <a class="code" href="structMergeConstraint.html#ad139b71af7af9ea9de1cab2237cb4b5d">MergeConstraint</a>(<a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> <a class="code" href="structMergeConstraint.html#ac157a836a0e36eb0dfcfa74c03d125e4">result</a>, <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> <a class="code" href="structMergeConstraint.html#ac5f2f712832154cdff7028bbd3508424">var1</a>)
<a name="l00535"></a>00535         : result(result), var1(var1)
<a name="l00536"></a>00536         {}
<a name="l00537"></a><a class="code" href="structMergeConstraint.html#a7a4a2a146905677ed6c3884f1f0747b1">00537</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structMergeConstraint.html#a7a4a2a146905677ed6c3884f1f0747b1">run</a>()<span class="keyword"> const </span>{
<a name="l00538"></a>00538         <a class="code" href="structMergeConstraint.html#ac157a836a0e36eb0dfcfa74c03d125e4">result</a>-&gt;set(<a class="code" href="structMergeConstraint.html#ac5f2f712832154cdff7028bbd3508424">var1</a>-&gt;get());
<a name="l00539"></a>00539     }
<a name="l00540"></a><a class="code" href="structMergeConstraint.html#adcb497b1002d813d1a17cd3a465feab5">00540</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structMergeConstraint.html#adcb497b1002d813d1a17cd3a465feab5">markDependencies</a>() {
<a name="l00541"></a>00541         <a class="code" href="classConstraint.html#a30feaf180bce5c1a0cfeee0be9983a93">addDependency</a>(<a class="code" href="structMergeConstraint.html#ac5f2f712832154cdff7028bbd3508424">var1</a>);
<a name="l00542"></a>00542     }
<a name="l00543"></a>00543 };
<a name="l00544"></a>00544 
<a name="l00545"></a><a class="code" href="structMemoryMergeConstraint.html">00545</a> <span class="keyword">struct </span><a class="code" href="structMemoryMergeConstraint.html">MemoryMergeConstraint</a>: <span class="keyword">public</span> <a class="code" href="classConstraint.html">Constraint</a> {
<a name="l00546"></a><a class="code" href="structMemoryMergeConstraint.html#a9e613ec9f72d23bdedaa388f8c0f04ca">00546</a>     <a class="code" href="structMemoryVariable.html">MemoryVariable</a>* <a class="code" href="structMemoryMergeConstraint.html#a9e613ec9f72d23bdedaa388f8c0f04ca">result</a>;
<a name="l00547"></a><a class="code" href="structMemoryMergeConstraint.html#aa8887266f126a2c752dd7aefcaf24e92">00547</a>     <a class="code" href="structMemoryVariable.html">MemoryVariable</a>* <a class="code" href="structMemoryMergeConstraint.html#aa8887266f126a2c752dd7aefcaf24e92">var1</a>;
<a name="l00548"></a><a class="code" href="structMemoryMergeConstraint.html#aa9271776c910b510d3df5df8b4aca711">00548</a>     <a class="code" href="structMemoryMergeConstraint.html#aa9271776c910b510d3df5df8b4aca711">MemoryMergeConstraint</a>(<a class="code" href="structMemoryVariable.html">MemoryVariable</a>* <a class="code" href="structMemoryMergeConstraint.html#a9e613ec9f72d23bdedaa388f8c0f04ca">result</a>, <a class="code" href="structMemoryVariable.html">MemoryVariable</a>* <a class="code" href="structMemoryMergeConstraint.html#aa8887266f126a2c752dd7aefcaf24e92">var1</a>)
<a name="l00549"></a>00549         : result(result), var1(var1)
<a name="l00550"></a>00550         {}
<a name="l00551"></a><a class="code" href="structMemoryMergeConstraint.html#a54199e4a36b5aa84831e293587e49e60">00551</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structMemoryMergeConstraint.html#a54199e4a36b5aa84831e293587e49e60">run</a>()<span class="keyword"> const </span>{
<a name="l00552"></a>00552         <a class="code" href="structMemoryMergeConstraint.html#a9e613ec9f72d23bdedaa388f8c0f04ca">result</a>-&gt;<a class="code" href="structMemoryVariable.html#a00e681d73a045c3f44ce2758f69b75be">set</a>(<a class="code" href="structMemoryMergeConstraint.html#aa8887266f126a2c752dd7aefcaf24e92">var1</a>-&gt;<a class="code" href="structMemoryVariable.html#aafe7886f04c547485bb7b0fe23d2093b">get</a>());
<a name="l00553"></a>00553     }
<a name="l00554"></a><a class="code" href="structMemoryMergeConstraint.html#aeec1a4bf2b8c2b038efceafcb9d34573">00554</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structMemoryMergeConstraint.html#aeec1a4bf2b8c2b038efceafcb9d34573">markDependencies</a>() {
<a name="l00555"></a>00555         <a class="code" href="classConstraint.html#a30feaf180bce5c1a0cfeee0be9983a93">addDependency</a>(<a class="code" href="structMemoryMergeConstraint.html#aa8887266f126a2c752dd7aefcaf24e92">var1</a>);
<a name="l00556"></a>00556     }
<a name="l00557"></a>00557 };
<a name="l00558"></a>00558 
<a name="l00559"></a><a class="code" href="structRegisterSet.html">00559</a> <span class="keyword">struct </span><a class="code" href="structRegisterSet.html">RegisterSet</a> {
<a name="l00560"></a><a class="code" href="structRegisterSet.html#ac033b9e454a5cfcb642ec5d280be7f90">00560</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> <a class="code" href="structRegisterSet.html#ac033b9e454a5cfcb642ec5d280be7f90">gpr</a>[8];
<a name="l00561"></a><a class="code" href="structRegisterSet.html#ae33c89e2e38c140a4d02bcc40ffd8144">00561</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;16&gt;</a> <a class="code" href="structRegisterSet.html#ae33c89e2e38c140a4d02bcc40ffd8144">segreg</a>[6];
<a name="l00562"></a><a class="code" href="structRegisterSet.html#afaf0508e49f032a7f757bd81ff5dcb89">00562</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;1&gt;</a> <a class="code" href="structRegisterSet.html#afaf0508e49f032a7f757bd81ff5dcb89">flag</a>[16];
<a name="l00563"></a><a class="code" href="structRegisterSet.html#a70669dade0ea18fc20058fc72d36a69e">00563</a>     <a class="code" href="structMemoryVariable.html">MemoryVariable</a>* <a class="code" href="structRegisterSet.html#a70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>; <span class="comment">// Undefined elements are bottom, no two elements can satisfy mayAlias</span>
<a name="l00564"></a>00564     
<a name="l00565"></a><a class="code" href="structRegisterSet.html#a35b21a1b96090ad0fb0d69b02bfff8c5">00565</a>     <a class="code" href="structRegisterSet.html#a35b21a1b96090ad0fb0d69b02bfff8c5">RegisterSet</a>() {
<a name="l00566"></a>00566         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 8; ++i)
<a name="l00567"></a>00567             <a class="code" href="structRegisterSet.html#ac033b9e454a5cfcb642ec5d280be7f90">gpr</a>[i] = <span class="keyword">new</span> <a class="code" href="structXVariable.html">XVariable&lt;32&gt;</a>();
<a name="l00568"></a>00568         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 6; ++i)
<a name="l00569"></a>00569             <a class="code" href="structRegisterSet.html#ae33c89e2e38c140a4d02bcc40ffd8144">segreg</a>[i] = <span class="keyword">new</span> <a class="code" href="structXVariable.html">XVariable&lt;16&gt;</a>();
<a name="l00570"></a>00570         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 16; ++i)
<a name="l00571"></a>00571             <a class="code" href="structRegisterSet.html#afaf0508e49f032a7f757bd81ff5dcb89">flag</a>[i] = <span class="keyword">new</span> <a class="code" href="structXVariable.html">XVariable&lt;1&gt;</a>();
<a name="l00572"></a>00572         <a class="code" href="structRegisterSet.html#a70669dade0ea18fc20058fc72d36a69e">memoryWrites</a> = <span class="keyword">new</span> <a class="code" href="structMemoryVariable.html">MemoryVariable</a>();
<a name="l00573"></a>00573     }
<a name="l00574"></a>00574 
<a name="l00575"></a><a class="code" href="structRegisterSet.html#abd97694302e8f6c77bc5013b82382923">00575</a>     <span class="keywordtype">void</span> <a class="code" href="structRegisterSet.html#abd97694302e8f6c77bc5013b82382923">setToBottom</a>() {
<a name="l00576"></a>00576         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 8; ++i)
<a name="l00577"></a>00577             <a class="code" href="structRegisterSet.html#ac033b9e454a5cfcb642ec5d280be7f90">gpr</a>[i] = <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;32&gt;::bottom</a>();
<a name="l00578"></a>00578         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 6; ++i)
<a name="l00579"></a>00579             <a class="code" href="structRegisterSet.html#ae33c89e2e38c140a4d02bcc40ffd8144">segreg</a>[i] = <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;16&gt;::bottom</a>();
<a name="l00580"></a>00580         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 16; ++i)
<a name="l00581"></a>00581             <a class="code" href="structRegisterSet.html#afaf0508e49f032a7f757bd81ff5dcb89">flag</a>[i] = <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;1&gt;::bottom</a>();
<a name="l00582"></a>00582         <a class="code" href="structRegisterSet.html#a70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>-&gt;<a class="code" href="structMemoryVariable.html#a00e681d73a045c3f44ce2758f69b75be">set</a>(<a class="code" href="structMemoryWriteSet.html#a5f96f9bfa7cc7ca000e22c9eb4b78261">MemoryWriteSet::bottom</a>());
<a name="l00583"></a>00583     }
<a name="l00584"></a>00584 
<a name="l00585"></a><a class="code" href="structRegisterSet.html#a8e135e626e5f37509718f1245fa3da11">00585</a>     <span class="keywordtype">void</span> <a class="code" href="structRegisterSet.html#a8e135e626e5f37509718f1245fa3da11">mergeIn</a>(<span class="keyword">const</span> <a class="code" href="structRegisterSet.html">RegisterSet</a>&amp; rs) {
<a name="l00586"></a>00586         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 8; ++i)
<a name="l00587"></a>00587             (<span class="keyword">new</span> <a class="code" href="structMergeConstraint.html">MergeConstraint&lt;32&gt;</a>(<a class="code" href="structRegisterSet.html#ac033b9e454a5cfcb642ec5d280be7f90">gpr</a>[i], rs.<a class="code" href="structRegisterSet.html#ac033b9e454a5cfcb642ec5d280be7f90">gpr</a>[i]))-&gt;activate();
<a name="l00588"></a>00588         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 6; ++i)
<a name="l00589"></a>00589             (<span class="keyword">new</span> <a class="code" href="structMergeConstraint.html">MergeConstraint&lt;16&gt;</a>(<a class="code" href="structRegisterSet.html#ae33c89e2e38c140a4d02bcc40ffd8144">segreg</a>[i], rs.<a class="code" href="structRegisterSet.html#ae33c89e2e38c140a4d02bcc40ffd8144">segreg</a>[i]))-&gt;activate();
<a name="l00590"></a>00590         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 16; ++i)
<a name="l00591"></a>00591             (<span class="keyword">new</span> <a class="code" href="structMergeConstraint.html">MergeConstraint&lt;1&gt;</a>(<a class="code" href="structRegisterSet.html#afaf0508e49f032a7f757bd81ff5dcb89">flag</a>[i], rs.<a class="code" href="structRegisterSet.html#afaf0508e49f032a7f757bd81ff5dcb89">flag</a>[i]))-&gt;activate();
<a name="l00592"></a>00592         (<span class="keyword">new</span> <a class="code" href="structMemoryMergeConstraint.html">MemoryMergeConstraint</a>(<a class="code" href="structRegisterSet.html#a70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>, rs.<a class="code" href="structRegisterSet.html#a70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>))-&gt;activate();
<a name="l00593"></a>00593     }
<a name="l00594"></a>00594 
<a name="l00596"></a><a class="code" href="structRegisterSet.html#a088acefbd0251e18550839a020727b9c">00596</a>     std::string <a class="code" href="structRegisterSet.html#a088acefbd0251e18550839a020727b9c" title="Show register set, but only the parts that differ from base.">diff</a>(<span class="keyword">const</span> <a class="code" href="structRegisterSet.html">RegisterSet</a> &amp;orig, std::string <a class="code" href="SgUnaryOp_8docs.html#ac6cf1576467b95ef29f025f8e47eea43a7afa939f8bd773f5f7e326990b07580c">prefix</a>=<span class="stringliteral">&quot;&quot;</span>) {
<a name="l00597"></a>00597         std::ostringstream s;
<a name="l00598"></a>00598         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;8; i++) {
<a name="l00599"></a>00599             <span class="keywordflow">if</span> (!(orig.<a class="code" href="structRegisterSet.html#ac033b9e454a5cfcb642ec5d280be7f90">gpr</a>[i]-&gt;get()==<a class="code" href="structRegisterSet.html#ac033b9e454a5cfcb642ec5d280be7f90">gpr</a>[i]-&gt;get())) {
<a name="l00600"></a>00600                 s &lt;&lt;<a class="code" href="SgUnaryOp_8docs.html#ac6cf1576467b95ef29f025f8e47eea43a7afa939f8bd773f5f7e326990b07580c">prefix</a> &lt;&lt;gprToString((<a class="code" href="InstructionEnumsX86_8h.html#a5069ca462f85d162797843f48bc6bced" title="Intel x86 general purpose registers.">X86GeneralPurposeRegister</a>)i) &lt;&lt;<span class="stringliteral">&quot; = &quot;</span> &lt;&lt;<a class="code" href="structRegisterSet.html#ac033b9e454a5cfcb642ec5d280be7f90">gpr</a>[i] &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00601"></a>00601             }
<a name="l00602"></a>00602         }
<a name="l00603"></a>00603         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;6; i++) {
<a name="l00604"></a>00604             <span class="keywordflow">if</span> (!(orig.<a class="code" href="structRegisterSet.html#ae33c89e2e38c140a4d02bcc40ffd8144">segreg</a>[i]-&gt;get()==<a class="code" href="structRegisterSet.html#ae33c89e2e38c140a4d02bcc40ffd8144">segreg</a>[i]-&gt;get())) {
<a name="l00605"></a>00605                 s &lt;&lt;<a class="code" href="SgUnaryOp_8docs.html#ac6cf1576467b95ef29f025f8e47eea43a7afa939f8bd773f5f7e326990b07580c">prefix</a> &lt;&lt;segregToString((<a class="code" href="InstructionEnumsX86_8h.html#a0b09709b1ff4de1bbe47357b6d7b0e64" title="Intel x86 segment registers.">X86SegmentRegister</a>)i) &lt;&lt;<span class="stringliteral">&quot; = &quot;</span> &lt;&lt;<a class="code" href="structRegisterSet.html#ae33c89e2e38c140a4d02bcc40ffd8144">segreg</a>[i] &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00606"></a>00606             }
<a name="l00607"></a>00607         }
<a name="l00608"></a>00608         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;16; i++) {
<a name="l00609"></a>00609             <span class="keywordflow">if</span> (!(orig.<a class="code" href="structRegisterSet.html#afaf0508e49f032a7f757bd81ff5dcb89">flag</a>[i]-&gt;get()==<a class="code" href="structRegisterSet.html#afaf0508e49f032a7f757bd81ff5dcb89">flag</a>[i]-&gt;get())) {
<a name="l00610"></a>00610                 s &lt;&lt;<a class="code" href="SgUnaryOp_8docs.html#ac6cf1576467b95ef29f025f8e47eea43a7afa939f8bd773f5f7e326990b07580c">prefix</a> &lt;&lt;flagToString((<a class="code" href="InstructionEnumsX86_8h.html#ab8c1069abaa6534f3481d52cfe950881" title="Intel x86 status flags.">X86Flag</a>)i) &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt;<a class="code" href="structRegisterSet.html#afaf0508e49f032a7f757bd81ff5dcb89">flag</a>[i] &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00611"></a>00611             }
<a name="l00612"></a>00612         }
<a name="l00613"></a>00613         <span class="comment">/* Show memory in this register set that is different than the original */</span>
<a name="l00614"></a>00614         <span class="keywordflow">if</span> (!<a class="code" href="structRegisterSet.html#a70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>-&gt;<a class="code" href="structMemoryVariable.html#aafe7886f04c547485bb7b0fe23d2093b">get</a>().<a class="code" href="structMemoryWriteSet.html#a26845f2d2d0f83b00c0156a1642de9c0">isTop</a>) {
<a name="l00615"></a>00615             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;<a class="code" href="structRegisterSet.html#a70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>-&gt;<a class="code" href="structMemoryVariable.html#aafe7886f04c547485bb7b0fe23d2093b">get</a>().<a class="code" href="structMemoryWriteSet.html#aff1aab41effbd5b65c11bebd3e9294ca">writes</a>.size(); i++) {
<a name="l00616"></a>00616                 <a class="code" href="structLatticeElement.html">LatticeElement&lt;32&gt;</a> addr = <a class="code" href="structRegisterSet.html#a70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>-&gt;<a class="code" href="structMemoryVariable.html#aafe7886f04c547485bb7b0fe23d2093b">get</a>().<a class="code" href="structMemoryWriteSet.html#aff1aab41effbd5b65c11bebd3e9294ca">writes</a>[i].address;
<a name="l00617"></a>00617                 <a class="code" href="structLatticeElement.html">LatticeElement&lt;32&gt;</a> orig_data;
<a name="l00618"></a>00618                 <span class="keywordflow">if</span> (!orig.<a class="code" href="structRegisterSet.html#a70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>-&gt;<a class="code" href="structMemoryVariable.html#aafe7886f04c547485bb7b0fe23d2093b">get</a>().<a class="code" href="structMemoryWriteSet.html#a6655c5dc1e2f02ce1795cecb8a976470" title="Obtains the value stored at the specified memory address, returning true if the address is defined or...">getValueAtAddress</a>(addr, orig_data<span class="comment">/*out*/</span>, 0, NULL) ||
<a name="l00619"></a>00619                     !(orig_data==<a class="code" href="structRegisterSet.html#a70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>-&gt;<a class="code" href="structMemoryVariable.html#aafe7886f04c547485bb7b0fe23d2093b">get</a>().<a class="code" href="structMemoryWriteSet.html#aff1aab41effbd5b65c11bebd3e9294ca">writes</a>[i].data)) {
<a name="l00620"></a>00620                     s &lt;&lt;<a class="code" href="SgUnaryOp_8docs.html#ac6cf1576467b95ef29f025f8e47eea43a7afa939f8bd773f5f7e326990b07580c">prefix</a> &lt;&lt;<span class="stringliteral">&quot;mem @ &quot;</span> &lt;&lt;addr &lt;&lt;<span class="stringliteral">&quot; = &quot;</span> &lt;&lt;<a class="code" href="structRegisterSet.html#a70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>-&gt;<a class="code" href="structMemoryVariable.html#aafe7886f04c547485bb7b0fe23d2093b">get</a>().<a class="code" href="structMemoryWriteSet.html#aff1aab41effbd5b65c11bebd3e9294ca">writes</a>[i].data &lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00621"></a>00621                 }
<a name="l00622"></a>00622             }
<a name="l00623"></a>00623         }
<a name="l00624"></a>00624         
<a name="l00625"></a>00625 
<a name="l00626"></a>00626         <span class="keywordflow">return</span> s.str();
<a name="l00627"></a>00627     }
<a name="l00628"></a>00628     
<a name="l00629"></a>00629 };
<a name="l00630"></a>00630 
<a name="l00631"></a>00631 std::ostream&amp;
<a name="l00632"></a>00632 <a class="code" href="Cxx__Grammar_8h.html#adb4215b461ab8236ea979e9ab81c61ff">operator&lt;&lt;</a>(std::ostream&amp; o, <span class="keyword">const</span> <a class="code" href="structRegisterSet.html">RegisterSet</a>&amp; rs);
<a name="l00633"></a>00633 
<a name="l00634"></a><a class="code" href="structFindConstantsPolicy.html">00634</a> <span class="keyword">struct </span><a class="code" href="structFindConstantsPolicy.html">FindConstantsPolicy</a> {
<a name="l00635"></a><a class="code" href="structFindConstantsPolicy.html#a86ad83f3a1aeb15f05c22295a649c304">00635</a>     std::map&lt;uint64_t, RegisterSet&gt; <a class="code" href="structFindConstantsPolicy.html#a86ad83f3a1aeb15f05c22295a649c304">rsets</a>;
<a name="l00636"></a><a class="code" href="structFindConstantsPolicy.html#a314eb44b10d0ddb974890f5a903c938e">00636</a>     <a class="code" href="structRegisterSet.html">RegisterSet</a> <a class="code" href="structFindConstantsPolicy.html#a18b80c74732ea19708e2cb7af6cbc1cc">currentRset</a>, *<a class="code" href="structFindConstantsPolicy.html#a314eb44b10d0ddb974890f5a903c938e">initialRset</a>;
<a name="l00637"></a><a class="code" href="structFindConstantsPolicy.html#a4dd275e0c7fde0df2396d2239c845bbe">00637</a>     uint32_t <a class="code" href="structFindConstantsPolicy.html#a4dd275e0c7fde0df2396d2239c845bbe">addr</a>;
<a name="l00638"></a><a class="code" href="structFindConstantsPolicy.html#a94a536bbac269a2f5d6e9c087c392616">00638</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> <a class="code" href="structFindConstantsPolicy.html#a94a536bbac269a2f5d6e9c087c392616">newIp</a>; <span class="comment">// To determine if it is a constant</span>
<a name="l00639"></a>00639     
<a name="l00640"></a><a class="code" href="structFindConstantsPolicy.html#aafa9f6990560e4ae40295a47c9c71035">00640</a>     <a class="code" href="structFindConstantsPolicy.html#aafa9f6990560e4ae40295a47c9c71035">FindConstantsPolicy</a>()
<a name="l00641"></a>00641         : <a class="code" href="structFindConstantsPolicy.html#a314eb44b10d0ddb974890f5a903c938e">initialRset</a>(NULL), <a class="code" href="structFindConstantsPolicy.html#a4dd275e0c7fde0df2396d2239c845bbe">addr</a>(0)
<a name="l00642"></a>00642         {}
<a name="l00643"></a>00643 
<a name="l00644"></a>00644     <span class="comment">/* Use this constructor when performing constant propagation analysis on a function where you want the entry point of the</span>
<a name="l00645"></a>00645 <span class="comment">     * function to use the specified initial values. See FindConstantsPolicy::startInstruction() for how this is used. */</span>
<a name="l00646"></a><a class="code" href="structFindConstantsPolicy.html#abb1ac6c415f1794acd8bebacc3715c10">00646</a>     <a class="code" href="structFindConstantsPolicy.html#aafa9f6990560e4ae40295a47c9c71035">FindConstantsPolicy</a>(<a class="code" href="structRegisterSet.html">RegisterSet</a> *initial_rs)
<a name="l00647"></a>00647         : <a class="code" href="structFindConstantsPolicy.html#a314eb44b10d0ddb974890f5a903c938e">initialRset</a>(initial_rs), <a class="code" href="structFindConstantsPolicy.html#a4dd275e0c7fde0df2396d2239c845bbe">addr</a>(0) {}
<a name="l00648"></a>00648 
<a name="l00649"></a>00649 
<a name="l00650"></a><a class="code" href="structFindConstantsPolicy.html#ad8af255060ed3a1dde73748aa3625963">00650</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> <a class="code" href="structFindConstantsPolicy.html#ad8af255060ed3a1dde73748aa3625963">readGPR</a>(<a class="code" href="InstructionEnumsX86_8h.html#a5069ca462f85d162797843f48bc6bced" title="Intel x86 general purpose registers.">X86GeneralPurposeRegister</a> r) {
<a name="l00651"></a>00651         <span class="keywordflow">return</span> <a class="code" href="structFindConstantsPolicy.html#a18b80c74732ea19708e2cb7af6cbc1cc">currentRset</a>.<a class="code" href="structRegisterSet.html#ac033b9e454a5cfcb642ec5d280be7f90">gpr</a>[r];
<a name="l00652"></a>00652     }
<a name="l00653"></a>00653 
<a name="l00654"></a><a class="code" href="structFindConstantsPolicy.html#abb31566212a8189207ed6c5bb57b79ef">00654</a>     <span class="keywordtype">void</span> <a class="code" href="structFindConstantsPolicy.html#abb31566212a8189207ed6c5bb57b79ef">writeGPR</a>(<a class="code" href="InstructionEnumsX86_8h.html#a5069ca462f85d162797843f48bc6bced" title="Intel x86 general purpose registers.">X86GeneralPurposeRegister</a> r, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> value) {
<a name="l00655"></a>00655         <a class="code" href="structFindConstantsPolicy.html#a18b80c74732ea19708e2cb7af6cbc1cc">currentRset</a>.<a class="code" href="structRegisterSet.html#ac033b9e454a5cfcb642ec5d280be7f90">gpr</a>[r] = value;
<a name="l00656"></a>00656     }
<a name="l00657"></a>00657 
<a name="l00658"></a><a class="code" href="structFindConstantsPolicy.html#a0cdca8598e77e2532d8f722c7e832863">00658</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;16&gt;</a> <a class="code" href="structFindConstantsPolicy.html#a0cdca8598e77e2532d8f722c7e832863">readSegreg</a>(<a class="code" href="InstructionEnumsX86_8h.html#a0b09709b1ff4de1bbe47357b6d7b0e64" title="Intel x86 segment registers.">X86SegmentRegister</a> sr) {
<a name="l00659"></a>00659         <span class="keywordflow">return</span> <a class="code" href="structFindConstantsPolicy.html#a18b80c74732ea19708e2cb7af6cbc1cc">currentRset</a>.<a class="code" href="structRegisterSet.html#ae33c89e2e38c140a4d02bcc40ffd8144">segreg</a>[sr];
<a name="l00660"></a>00660     }
<a name="l00661"></a>00661 
<a name="l00662"></a><a class="code" href="structFindConstantsPolicy.html#a4769265fc540af52f1b61085dbe5589c">00662</a>     <span class="keywordtype">void</span> <a class="code" href="structFindConstantsPolicy.html#a4769265fc540af52f1b61085dbe5589c">writeSegreg</a>(<a class="code" href="InstructionEnumsX86_8h.html#a0b09709b1ff4de1bbe47357b6d7b0e64" title="Intel x86 segment registers.">X86SegmentRegister</a> sr, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;16&gt;</a> val) {
<a name="l00663"></a>00663         <a class="code" href="structFindConstantsPolicy.html#a18b80c74732ea19708e2cb7af6cbc1cc">currentRset</a>.<a class="code" href="structRegisterSet.html#ae33c89e2e38c140a4d02bcc40ffd8144">segreg</a>[sr] = val;
<a name="l00664"></a>00664     }
<a name="l00665"></a>00665 
<a name="l00666"></a><a class="code" href="structFindConstantsPolicy.html#ac53705e1d5e6db9bc488293235b92655">00666</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> <a class="code" href="structFindConstantsPolicy.html#ac53705e1d5e6db9bc488293235b92655">readIP</a>() {
<a name="l00667"></a>00667         <span class="keywordflow">return</span> <a class="code" href="structFindConstantsPolicy.html#a94a536bbac269a2f5d6e9c087c392616">newIp</a>;
<a name="l00668"></a>00668     }
<a name="l00669"></a>00669 
<a name="l00670"></a><a class="code" href="structFindConstantsPolicy.html#ab9cb736d498be259205a789176afe40b">00670</a>     <span class="keywordtype">void</span> <a class="code" href="structFindConstantsPolicy.html#ab9cb736d498be259205a789176afe40b">writeIP</a>(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> n) {
<a name="l00671"></a>00671         <a class="code" href="structFindConstantsPolicy.html#a94a536bbac269a2f5d6e9c087c392616">newIp</a> = n;
<a name="l00672"></a>00672     }
<a name="l00673"></a>00673 
<a name="l00674"></a><a class="code" href="structFindConstantsPolicy.html#a858e580ab1834fb64a0e837d7b37ecc9">00674</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;1&gt;</a> <a class="code" href="structFindConstantsPolicy.html#a858e580ab1834fb64a0e837d7b37ecc9">readFlag</a>(<a class="code" href="InstructionEnumsX86_8h.html#ab8c1069abaa6534f3481d52cfe950881" title="Intel x86 status flags.">X86Flag</a> f) {
<a name="l00675"></a>00675         <span class="keywordflow">return</span> <a class="code" href="structFindConstantsPolicy.html#a18b80c74732ea19708e2cb7af6cbc1cc">currentRset</a>.<a class="code" href="structRegisterSet.html#afaf0508e49f032a7f757bd81ff5dcb89">flag</a>[f];
<a name="l00676"></a>00676     }
<a name="l00677"></a>00677 
<a name="l00678"></a><a class="code" href="structFindConstantsPolicy.html#a4da0db0b4eb713db300d82ac63d45609">00678</a>     <span class="keywordtype">void</span> <a class="code" href="structFindConstantsPolicy.html#a4da0db0b4eb713db300d82ac63d45609">writeFlag</a>(<a class="code" href="InstructionEnumsX86_8h.html#ab8c1069abaa6534f3481d52cfe950881" title="Intel x86 status flags.">X86Flag</a> f, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;1&gt;</a> value) {
<a name="l00679"></a>00679         <a class="code" href="structFindConstantsPolicy.html#a18b80c74732ea19708e2cb7af6cbc1cc">currentRset</a>.<a class="code" href="structRegisterSet.html#afaf0508e49f032a7f757bd81ff5dcb89">flag</a>[f] = value;
<a name="l00680"></a>00680     }
<a name="l00681"></a>00681 
<a name="l00682"></a>00682     <span class="comment">/* Only used by number&lt;&gt;(uint64_t) below, but gcc-4.0.1 on OSX (Apple Inc. build 5484) does not like this struct to be</span>
<a name="l00683"></a>00683 <span class="comment">     * defined inside that function.  It results in strange warnings about an unrelated function in</span>
<a name="l00684"></a>00684 <span class="comment">     * x86InstructionSemantics.C having no return value. [RPM 2010-05-27] */</span>
<a name="l00685"></a>00685     <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00686"></a><a class="code" href="structFindConstantsPolicy_1_1NumberConstraint.html">00686</a>     <span class="keyword">struct </span><a class="code" href="structFindConstantsPolicy_1_1NumberConstraint.html">NumberConstraint</a>: <span class="keyword">public</span> <a class="code" href="structNullaryConstraint.html">NullaryConstraint</a>&lt;Len&gt; {
<a name="l00687"></a><a class="code" href="structFindConstantsPolicy_1_1NumberConstraint.html#a47dbd53f3748a04314717747e6c2d5c1">00687</a>         uint64_t <a class="code" href="structFindConstantsPolicy_1_1NumberConstraint.html#a47dbd53f3748a04314717747e6c2d5c1">val</a>;
<a name="l00688"></a><a class="code" href="structFindConstantsPolicy_1_1NumberConstraint.html#a05fbe942832e2f5c45db3602b02dfc78">00688</a>         <a class="code" href="structFindConstantsPolicy_1_1NumberConstraint.html#a05fbe942832e2f5c45db3602b02dfc78">NumberConstraint</a>(<a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> var, uint64_t <a class="code" href="structFindConstantsPolicy_1_1NumberConstraint.html#a47dbd53f3748a04314717747e6c2d5c1">val</a>)
<a name="l00689"></a>00689             : <a class="code" href="structNullaryConstraint.html">NullaryConstraint</a>&lt;<a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>&gt;(var), val(val)
<a name="l00690"></a>00690             {}
<a name="l00691"></a><a class="code" href="structFindConstantsPolicy_1_1NumberConstraint.html#a5466bf734060acf1f7386cc8344e3055">00691</a>         <span class="keyword">virtual</span> uint64_t <a class="code" href="structFindConstantsPolicy_1_1NumberConstraint.html#a5466bf734060acf1f7386cc8344e3055">compute</a>()<span class="keyword"> const </span>{
<a name="l00692"></a>00692             <span class="keywordflow">return</span> <a class="code" href="structFindConstantsPolicy_1_1NumberConstraint.html#a47dbd53f3748a04314717747e6c2d5c1">val</a>;
<a name="l00693"></a>00693         }
<a name="l00694"></a>00694     };
<a name="l00695"></a>00695         
<a name="l00696"></a>00696     <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00697"></a><a class="code" href="structFindConstantsPolicy.html#aeb2a77732f84fea280fca9fc305a37ec">00697</a>     <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> <a class="code" href="structFindConstantsPolicy.html#aeb2a77732f84fea280fca9fc305a37ec">number</a>(uint64_t n) {
<a name="l00698"></a>00698         <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> var = <span class="keyword">new</span> <a class="code" href="structXVariable.html">XVariable&lt;Len&gt;</a>();
<a name="l00699"></a>00699         (<span class="keyword">new</span> <a class="code" href="structFindConstantsPolicy_1_1NumberConstraint.html">NumberConstraint&lt;Len&gt;</a>(var, n))-&gt;activate();
<a name="l00700"></a>00700         <span class="keywordflow">return</span> var;
<a name="l00701"></a>00701     }
<a name="l00702"></a>00702 
<a name="l00703"></a>00703     <span class="comment">// Only safe when MSBs don&#39;t matter (i.e., you can&#39;t extract bits from something and then use this to put in zeros -- the</span>
<a name="l00704"></a>00704     <span class="comment">// original bits will probably appear again)</span>
<a name="l00705"></a>00705     <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len, <span class="keywordtype">size_t</span> Len2&gt;
<a name="l00706"></a>00706     <span class="keyword">static</span> <a class="code" href="structFindConstantsPolicy.html#a6acb4a68340238a0cee2d458411914f1">UNARY_COMPUTATION_SPECIAL</a>(<a class="code" href="findConstants_8h.html#ac561d0ac17798b48263f8622d1ece112">extendByMSB</a>, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, Len2, {
<a name="l00707"></a>00707             result-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len2&gt;</a>(le1.name, le1.definingInstruction, le1.negate, le1.offset));
<a name="l00708"></a>00708         })
<a name="l00709"></a>00709 
<a name="l00710"></a><a class="code" href="structFindConstantsPolicy.html#ad0d0205878273e563d9a396a26593e5e">00710</a>     template &lt;size_t From, size_t To, size_t Len&gt;
<a name="l00711"></a>00711     <span class="keyword">static</span> <a class="code" href="structFindConstantsPolicy.html#a6acb4a68340238a0cee2d458411914f1">UNARY_COMPUTATION_SPECIAL</a>(<a class="code" href="findConstants_8h.html#adcd954f1007c97339e8b507f1915f435">extract</a>, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#ad0d0205878273e563d9a396a26593e5e">To</a> - From, {
<a name="l00712"></a>00712             <span class="keywordflow">if</span> (From == 0) {
<a name="l00713"></a>00713                 result-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;To - From&gt;</a>(le1.name, le1.definingInstruction, le1.negate, le1.offset));
<a name="l00714"></a>00714                 <span class="keywordflow">return</span>;
<a name="l00715"></a>00715             }
<a name="l00716"></a>00716             <span class="keywordflow">if</span> (le1.name != 0) {
<a name="l00717"></a>00717                 result-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;To - From&gt;::nonconstant</a>(result-&gt;myName, result-&gt;def));
<a name="l00718"></a>00718                 <span class="keywordflow">return</span>;
<a name="l00719"></a>00719             }
<a name="l00720"></a>00720             result-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;To - From&gt;::constant</a>((le1.offset &gt;&gt; From) &amp; (<a class="code" href="structIntegerOps_1_1SHL1.html">IntegerOps::SHL1&lt;uint64_t, To - From&gt;::value</a> - 1),
<a name="l00721"></a>00721                                                             result-&gt;def));
<a name="l00722"></a>00722         })
<a name="l00723"></a>00723 
<a name="l00724"></a>00724 
<a name="l00725"></a>00725     template &lt;size_t Len1, size_t Len2&gt;
<a name="l00726"></a><a class="code" href="structFindConstantsPolicy.html#ade8017e5b68d1137a1bec5590f5eeab8">00726</a>     <a class="code" href="structFindConstantsPolicy.html#ade8017e5b68d1137a1bec5590f5eeab8">BINARY_COMPUTATION</a>(concat, Len1, Len2, Len1 + Len2, {
<a name="l00727"></a>00727             <span class="keywordflow">return</span> a | (b &lt;&lt; Len1);
<a name="l00728"></a>00728         })
<a name="l00729"></a>00729 
<a name="l00730"></a>00730     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;1&gt;</a> false_() {
<a name="l00731"></a>00731         <span class="keywordflow">return</span> number&lt;1&gt;(0);
<a name="l00732"></a>00732     }
<a name="l00733"></a><a class="code" href="structFindConstantsPolicy.html#acbcfb93595f2854c4a5a631d554ecbb5">00733</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;1&gt;</a> <a class="code" href="structFindConstantsPolicy.html#acbcfb93595f2854c4a5a631d554ecbb5">true_</a>() {
<a name="l00734"></a>00734         <span class="keywordflow">return</span> number&lt;1&gt;(1);
<a name="l00735"></a>00735     }
<a name="l00736"></a><a class="code" href="structFindConstantsPolicy.html#aaef23e24a5da0d57730114c4093dd20e">00736</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;1&gt;</a> <a class="code" href="structFindConstantsPolicy.html#aaef23e24a5da0d57730114c4093dd20e">undefined_</a>() {
<a name="l00737"></a>00737         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="structXVariable.html">XVariable&lt;1&gt;</a>();
<a name="l00738"></a>00738     }
<a name="l00739"></a>00739 
<a name="l00740"></a>00740     <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00741"></a>00741     <a class="code" href="structFindConstantsPolicy.html#a6acb4a68340238a0cee2d458411914f1">UNARY_COMPUTATION_SPECIAL</a>(invert, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, {
<a name="l00742"></a>00742             <span class="keywordflow">if</span> (le1.name == 0)
<a name="l00743"></a>00743                 result-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;::constant</a>(~le1.offset, result-&gt;def));
<a name="l00744"></a>00744             <span class="keywordflow">else</span>
<a name="l00745"></a>00745                 result-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;</a>(le1.name, le1.definingInstruction, !le1.negate, ~le1.offset));
<a name="l00746"></a>00746         })
<a name="l00747"></a>00747 
<a name="l00748"></a>00748     template &lt;size_t Len&gt;
<a name="l00749"></a><a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">00749</a>     <a class="code" href="structFindConstantsPolicy.html#a6acb4a68340238a0cee2d458411914f1">UNARY_COMPUTATION_SPECIAL</a>(negate, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, {
<a name="l00750"></a>00750             <span class="keywordflow">if</span> (le1.name == 0)
<a name="l00751"></a>00751                 result-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;::constant</a>(-le1.offset, result-&gt;def));
<a name="l00752"></a>00752             <span class="keywordflow">else</span>
<a name="l00753"></a>00753                 result-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;</a>(le1.name, le1.definingInstruction, !le1.negate, -le1.offset));
<a name="l00754"></a>00754         })
<a name="l00755"></a>00755 
<a name="l00756"></a>00756     template &lt;size_t Len&gt;
<a name="l00757"></a>00757     <a class="code" href="structFindConstantsPolicy.html#ade8017e5b68d1137a1bec5590f5eeab8">BINARY_COMPUTATION</a>(and_, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, {<span class="keywordflow">return</span> (a &amp; b);})
<a name="l00758"></a>00758 
<a name="l00759"></a>00759     template &lt;size_t Len&gt;
<a name="l00760"></a>00760     <a class="code" href="structFindConstantsPolicy.html#ade8017e5b68d1137a1bec5590f5eeab8">BINARY_COMPUTATION</a>(or_, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, {<span class="keywordflow">return</span> (a | b);})
<a name="l00761"></a>00761 
<a name="l00762"></a>00762     template &lt;size_t Len&gt;
<a name="l00763"></a>00763     <a class="code" href="structFindConstantsPolicy.html#ae872ecb519de83aef1789fcc30d948e7">BINARY_COMPUTATION_SPECIAL</a>(xor_, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, {
<a name="l00764"></a>00764             <span class="keywordflow">if</span> (le1 == le2) {
<a name="l00765"></a>00765                 result-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;::constant</a>(0, result-&gt;def));
<a name="l00766"></a>00766                 <span class="keywordflow">return</span>;
<a name="l00767"></a>00767             }
<a name="l00768"></a>00768             <span class="keywordflow">if</span> (le1.name == 0 &amp;&amp; le2.name == 0) {
<a name="l00769"></a>00769                 result-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;::constant</a>(le1.offset ^ le2.offset, result-&gt;def));
<a name="l00770"></a>00770                 <span class="keywordflow">return</span>;
<a name="l00771"></a>00771             }
<a name="l00772"></a>00772             result-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;::nonconstant</a>(result-&gt;myName, result-&gt;def));
<a name="l00773"></a>00773         })
<a name="l00774"></a>00774 
<a name="l00775"></a>00775     template &lt;size_t From, size_t To&gt;
<a name="l00776"></a>00776     <a class="code" href="structFindConstantsPolicy.html#aa67dd1fd9e30f5aa8737f573f736f02e">UNARY_COMPUTATION</a>(<a class="code" href="namespaceIntegerOps.html#a5a0b793b1d5962178ccd48e36d5a4746">signExtend</a>, From, <a class="code" href="structFindConstantsPolicy.html#ad0d0205878273e563d9a396a26593e5e">To</a>, {<span class="keywordflow">return</span> (IntegerOps::signExtend&lt;From, To&gt;(a));})
<a name="l00777"></a>00777 
<a name="l00778"></a>00778     template &lt;size_t Len&gt;
<a name="l00779"></a><a class="code" href="structFindConstantsPolicy.html#ab416604da9233aa2cd9d0ddc17d0742e">00779</a>     <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> ite(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;1&gt;</a> sel, <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> <a class="code" href="structFindConstantsPolicy.html#ab416604da9233aa2cd9d0ddc17d0742e">ifTrue</a>, <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> ifFalse) {
<a name="l00780"></a>00780         <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> result = <span class="keyword">new</span> <a class="code" href="structXVariable.html">XVariable&lt;Len&gt;</a>();
<a name="l00781"></a>00781         <span class="keyword">struct </span>IteConstraint: <span class="keyword">public</span> <a class="code" href="classConstraint.html">Constraint</a> {
<a name="l00782"></a>00782             <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> result;
<a name="l00783"></a>00783             <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> <a class="code" href="structFindConstantsPolicy.html#ab416604da9233aa2cd9d0ddc17d0742e">ifTrue</a>;
<a name="l00784"></a>00784             <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> ifFalse;
<a name="l00785"></a>00785             <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;1&gt;</a> sel;
<a name="l00786"></a>00786             IteConstraint(<a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> result, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;1&gt;</a> sel, <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> ifTrue, <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> ifFalse)
<a name="l00787"></a>00787                 : result(result), <a class="code" href="structFindConstantsPolicy.html#ab416604da9233aa2cd9d0ddc17d0742e">ifTrue</a>(ifTrue), ifFalse(ifFalse), sel(sel)
<a name="l00788"></a>00788                 {}
<a name="l00789"></a>00789             <span class="keyword">virtual</span> <span class="keywordtype">void</span> run()<span class="keyword"> const </span>{
<a name="l00790"></a>00790                 <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;</a> res;
<a name="l00791"></a>00791                 <span class="keywordflow">if</span> (sel-&gt;get().name != 0 || (sel-&gt;get().name == 0 &amp;&amp; sel-&gt;get().offset == 1)) {
<a name="l00792"></a>00792                     res.<a class="code" href="structLatticeElement.html#a1fa61bab0a3202eb472eae5e8e989f16">merge</a>(ifTrue-&gt;get(), result-&gt;myName, result-&gt;def);
<a name="l00793"></a>00793                 }
<a name="l00794"></a>00794                 <span class="keywordflow">if</span> (sel-&gt;get().name != 0 || (sel-&gt;get().name == 0 &amp;&amp; sel-&gt;get().offset == 0)) {
<a name="l00795"></a>00795                     res.<a class="code" href="structLatticeElement.html#a1fa61bab0a3202eb472eae5e8e989f16">merge</a>(ifFalse-&gt;get(), result-&gt;myName, result-&gt;def);
<a name="l00796"></a>00796                 }
<a name="l00797"></a>00797                 result-&gt;set(res);
<a name="l00798"></a>00798             }
<a name="l00799"></a>00799             <span class="keyword">virtual</span> <span class="keywordtype">void</span> markDependencies() {
<a name="l00800"></a>00800                 addDependency(sel);
<a name="l00801"></a>00801                 addDependency(ifTrue);
<a name="l00802"></a>00802                 addDependency(ifFalse);
<a name="l00803"></a>00803             }
<a name="l00804"></a>00804         };
<a name="l00805"></a>00805         (<span class="keyword">new</span> IteConstraint(result, sel, ifTrue, ifFalse))-&gt;activate();
<a name="l00806"></a>00806         <span class="keywordflow">return</span> result;
<a name="l00807"></a>00807     }
<a name="l00808"></a>00808 
<a name="l00809"></a>00809     <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00810"></a>00810     <a class="code" href="structFindConstantsPolicy.html#aa67dd1fd9e30f5aa8737f573f736f02e">UNARY_COMPUTATION</a>(equalToZero, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, 1, {<span class="keywordflow">return</span> (a == 0);})
<a name="l00811"></a>00811 
<a name="l00812"></a>00812     template &lt;size_t Len, size_t SCLen&gt;
<a name="l00813"></a>00813     <a class="code" href="structFindConstantsPolicy.html#aa67dd1fd9e30f5aa8737f573f736f02e">UNARY_COMPUTATION</a>(generateMask, SCLen, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, {<span class="keywordflow">return</span> IntegerOps::genMask&lt;uint64_t&gt;(a);})
<a name="l00814"></a>00814 
<a name="l00815"></a>00815 #<span class="keywordflow">if</span> 1
<a name="l00816"></a>00816     template &lt;size_t Len&gt;
<a name="l00817"></a>00817     <a class="code" href="structFindConstantsPolicy.html#ae872ecb519de83aef1789fcc30d948e7">BINARY_COMPUTATION_SPECIAL</a>(add, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, {
<a name="l00818"></a>00818             <span class="keywordflow">if</span> (le1.name == 0 || le2.name == 0) {
<a name="l00819"></a>00819                 result-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;</a>(le1.name + le2.name, result-&gt;def,
<a name="l00820"></a>00820                                                 le1.negate || le2.negate, le1.offset + le2.offset));
<a name="l00821"></a>00821                 <span class="keywordflow">return</span>;
<a name="l00822"></a>00822             }
<a name="l00823"></a>00823             <span class="keywordflow">if</span> (le1.name == le2.name &amp;&amp; le1.negate == !le2.negate) {
<a name="l00824"></a>00824                 result-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;::constant</a>(le1.offset + le2.offset, result-&gt;def));
<a name="l00825"></a>00825                 <span class="keywordflow">return</span>;
<a name="l00826"></a>00826             }
<a name="l00827"></a>00827             result-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;::nonconstant</a>(result-&gt;myName, result-&gt;def));
<a name="l00828"></a>00828         })
<a name="l00829"></a>00829 #<span class="keywordflow">else</span>
<a name="l00830"></a>00830     template &lt;size_t Len&gt;
<a name="l00831"></a>00831     <a class="code" href="structFindConstantsPolicy.html#ade8017e5b68d1137a1bec5590f5eeab8">BINARY_COMPUTATION</a>(add, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, {<span class="keywordflow">return</span> (a &amp; b);})
<a name="l00832"></a>00832 
<a name="l00833"></a>00833 #endif
<a name="l00834"></a>00834 
<a name="l00835"></a>00835 
<a name="l00836"></a>00836     template &lt;size_t Len&gt;
<a name="l00837"></a><a class="code" href="structFindConstantsPolicy.html#aea0af22cd2fa76a42b432e5d96fbefaf">00837</a>     <a class="code" href="findConstants_8h.html#acfeda32a953312c23784c6cd3c9ef85c">TERNARY_COMPUTATION_SPECIAL</a>(add3, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, 1, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, {
<a name="l00838"></a>00838             <span class="keywordflow">if</span> ((le1.name == 0) + (le2.name == 0) + (le3.name == 0)) {
<a name="l00839"></a>00839                 result-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;</a>(le1.name + le2.name + le3.name, result-&gt;def,
<a name="l00840"></a>00840                                                 le1.negate || le2.negate || le3.negate,
<a name="l00841"></a>00841                                                 le1.offset + le2.offset + le3.offset));
<a name="l00842"></a>00842                 <span class="keywordflow">return</span>;
<a name="l00843"></a>00843             }
<a name="l00844"></a>00844             <span class="keywordflow">if</span> (le1.name == le2.name &amp;&amp; le3.name == 0 &amp;&amp; le1.negate == !le2.negate) {
<a name="l00845"></a>00845                 result-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;::constant</a>(le1.offset + le2.offset + le3.offset, result-&gt;def));
<a name="l00846"></a>00846                 <span class="keywordflow">return</span>;
<a name="l00847"></a>00847             }
<a name="l00848"></a>00848             result-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;::nonconstant</a>(result-&gt;myName, result-&gt;def));
<a name="l00849"></a>00849         })
<a name="l00850"></a>00850 
<a name="l00851"></a>00851     template &lt;size_t Len&gt;
<a name="l00852"></a>00852     <a class="code" href="findConstants_8h.html#ac665060a61498a5dc2f60f3fb9a0dd52">TERNARY_COMPUTATION</a>(xor3, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, {<span class="keywordflow">return</span> (a ^ b ^ c);})
<a name="l00853"></a>00853 
<a name="l00854"></a>00854     template &lt;size_t Len&gt;
<a name="l00855"></a>00855     <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> addWithCarries(<a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> a, <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> b, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;1&gt;</a> carryIn,
<a name="l00856"></a>00856                                      <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a>&amp; carries) { <span class="comment">// Full case</span>
<a name="l00857"></a>00857         <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len + 1&gt;</a> aa = extendByMSB&lt;Len, Len + 1&gt;(a);
<a name="l00858"></a>00858         <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len + 1&gt;</a> bb = extendByMSB&lt;Len, Len + 1&gt;(b);
<a name="l00859"></a>00859         <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len + 1&gt;</a> result = add3(aa, bb, carryIn);
<a name="l00860"></a>00860         carries = extract&lt;1, Len + 1&gt;(xor3(aa, bb, result));
<a name="l00861"></a>00861         <span class="keywordflow">return</span> extract&lt;0, Len&gt;(result);
<a name="l00862"></a>00862     }
<a name="l00863"></a>00863 
<a name="l00864"></a>00864     <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len, <span class="keywordtype">size_t</span> SALen&gt;
<a name="l00865"></a>00865     <a class="code" href="structFindConstantsPolicy.html#ade8017e5b68d1137a1bec5590f5eeab8">BINARY_COMPUTATION</a>(<a class="code" href="namespaceIntegerOps.html#a0b49d016143af0ca43e0c4f0a57aade5">rotateLeft</a>, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, SALen, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, {
<a name="l00866"></a>00866             <span class="keywordflow">return</span> IntegerOps::rotateLeft&lt;Len&gt;(a, b);
<a name="l00867"></a>00867         })
<a name="l00868"></a>00868 
<a name="l00869"></a>00869     template &lt;size_t Len, size_t SALen&gt;
<a name="l00870"></a>00870     <a class="code" href="structFindConstantsPolicy.html#ade8017e5b68d1137a1bec5590f5eeab8">BINARY_COMPUTATION</a>(<a class="code" href="namespaceIntegerOps.html#a4bc67c56910c0a2b96234b6e1143a0f5">rotateRight</a>, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, SALen, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, {
<a name="l00871"></a>00871             <span class="keywordflow">return</span> IntegerOps::rotateRight&lt;Len&gt;(a, b);
<a name="l00872"></a>00872         })
<a name="l00873"></a>00873 
<a name="l00874"></a>00874     template &lt;size_t Len, size_t SALen&gt;
<a name="l00875"></a>00875     <a class="code" href="structFindConstantsPolicy.html#ade8017e5b68d1137a1bec5590f5eeab8">BINARY_COMPUTATION</a>(<a class="code" href="namespaceIntegerOps.html#ada434910fd918097e5a0a26d8798a7a8">shiftLeft</a>, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, SALen, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, {
<a name="l00876"></a>00876             <span class="keywordflow">return</span> IntegerOps::shiftLeft&lt;Len&gt;(a, b);
<a name="l00877"></a>00877         })
<a name="l00878"></a>00878 
<a name="l00879"></a>00879     template &lt;size_t Len, size_t SALen&gt;
<a name="l00880"></a>00880     <a class="code" href="structFindConstantsPolicy.html#ade8017e5b68d1137a1bec5590f5eeab8">BINARY_COMPUTATION</a>(shiftRight, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, SALen, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, {
<a name="l00881"></a>00881             <span class="keywordflow">return</span> IntegerOps::shiftRightLogical&lt;Len&gt;(a, b);
<a name="l00882"></a>00882         })
<a name="l00883"></a>00883 
<a name="l00884"></a>00884     template &lt;size_t Len, size_t SALen&gt;
<a name="l00885"></a>00885     <a class="code" href="structFindConstantsPolicy.html#ade8017e5b68d1137a1bec5590f5eeab8">BINARY_COMPUTATION</a>(<a class="code" href="namespaceIntegerOps.html#a0069af061782ffe71cfcab0a99a2f7b3">shiftRightArithmetic</a>, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, SALen, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, {
<a name="l00886"></a>00886             <span class="keywordflow">return</span> IntegerOps::shiftRightArithmetic&lt;Len&gt;(a, b);
<a name="l00887"></a>00887         })
<a name="l00888"></a>00888 
<a name="l00889"></a>00889     template &lt;size_t Len1, size_t Len2&gt;
<a name="l00890"></a>00890     <a class="code" href="structFindConstantsPolicy.html#ade8017e5b68d1137a1bec5590f5eeab8">BINARY_COMPUTATION</a>(signedMultiply, Len1, Len2, Len1 + Len2, {
<a name="l00891"></a>00891             <span class="keywordflow">return</span> (IntegerOps::signExtend&lt;Len1, 64&gt;(a) * IntegerOps::signExtend&lt;Len2, 64&gt;(b));
<a name="l00892"></a>00892         })
<a name="l00893"></a>00893 
<a name="l00894"></a>00894     template &lt;size_t Len1, size_t Len2&gt;
<a name="l00895"></a>00895     <a class="code" href="structFindConstantsPolicy.html#ade8017e5b68d1137a1bec5590f5eeab8">BINARY_COMPUTATION</a>(unsignedMultiply, Len1, Len2, Len1 + Len2, {
<a name="l00896"></a>00896             <span class="keywordflow">return</span> (a * b);
<a name="l00897"></a>00897         })
<a name="l00898"></a>00898 
<a name="l00899"></a>00899     template &lt;size_t Len1, size_t Len2&gt;
<a name="l00900"></a>00900     <a class="code" href="structFindConstantsPolicy.html#ade8017e5b68d1137a1bec5590f5eeab8">BINARY_COMPUTATION</a>(signedDivide, Len1, Len2, Len1, {
<a name="l00901"></a>00901             <span class="keywordflow">return</span> (IntegerOps::signExtend&lt;Len1, 64&gt;(a) / IntegerOps::signExtend&lt;Len2, 64&gt;(b));
<a name="l00902"></a>00902         })
<a name="l00903"></a>00903 
<a name="l00904"></a>00904     template &lt;size_t Len1, size_t Len2&gt;
<a name="l00905"></a>00905     <a class="code" href="structFindConstantsPolicy.html#ade8017e5b68d1137a1bec5590f5eeab8">BINARY_COMPUTATION</a>(signedModulo, Len1, Len2, Len2, {
<a name="l00906"></a>00906             <span class="keywordflow">return</span> (IntegerOps::signExtend&lt;Len1, 64&gt;(a) % IntegerOps::signExtend&lt;Len2, 64&gt;(b))
<a name="l00907"></a>00907                 ;})
<a name="l00908"></a>00908 
<a name="l00909"></a>00909     template &lt;size_t Len1, size_t Len2&gt;
<a name="l00910"></a>00910     <a class="code" href="structFindConstantsPolicy.html#ade8017e5b68d1137a1bec5590f5eeab8">BINARY_COMPUTATION</a>(unsignedDivide, Len1, Len2, Len1, {
<a name="l00911"></a>00911             <span class="keywordflow">if</span> (0==b) <span class="keywordflow">throw</span> std::string(<span class="stringliteral">&quot;division by zero&quot;</span>);
<a name="l00912"></a>00912             <span class="keywordflow">return</span> (a / b);
<a name="l00913"></a>00913         })
<a name="l00914"></a>00914 
<a name="l00915"></a>00915     template &lt;size_t Len1, size_t Len2&gt;
<a name="l00916"></a>00916     <a class="code" href="structFindConstantsPolicy.html#ade8017e5b68d1137a1bec5590f5eeab8">BINARY_COMPUTATION</a>(unsignedModulo, Len1, Len2, Len2, {
<a name="l00917"></a>00917             <span class="keywordflow">return</span> (a % b);
<a name="l00918"></a>00918         })
<a name="l00919"></a>00919 
<a name="l00920"></a>00920     template &lt;size_t Len&gt;
<a name="l00921"></a><a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">00921</a>     <a class="code" href="structFindConstantsPolicy.html#aa67dd1fd9e30f5aa8737f573f736f02e">UNARY_COMPUTATION</a>(leastSignificantSetBit, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, {
<a name="l00922"></a>00922             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (int)<a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>; ++i) {
<a name="l00923"></a>00923                 <span class="keywordflow">if</span> (a &amp; IntegerOps::shl1&lt;uint64_t&gt;(i))
<a name="l00924"></a>00924                     <span class="keywordflow">return</span> i;
<a name="l00925"></a>00925             }
<a name="l00926"></a>00926             <span class="keywordflow">return</span> 0;
<a name="l00927"></a>00927         })
<a name="l00928"></a>00928 
<a name="l00929"></a>00929     template &lt;size_t Len&gt;
<a name="l00930"></a>00930     <a class="code" href="structFindConstantsPolicy.html#aa67dd1fd9e30f5aa8737f573f736f02e">UNARY_COMPUTATION</a>(mostSignificantSetBit, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>, {
<a name="l00931"></a>00931             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = (<span class="keywordtype">int</span>)<a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a> - 1; i &gt;= 0; --i) {
<a name="l00932"></a>00932                 <span class="keywordflow">if</span> (a &amp; IntegerOps::shl1&lt;uint64_t&gt;(i))
<a name="l00933"></a>00933                     <span class="keywordflow">return</span> i;
<a name="l00934"></a>00934             }
<a name="l00935"></a>00935             <span class="keywordflow">return</span> 0;
<a name="l00936"></a>00936         })
<a name="l00937"></a>00937 
<a name="l00938"></a>00938     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> filterIndirectJumpTarget(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> x) {
<a name="l00939"></a>00939         <span class="keywordflow">return</span> x;
<a name="l00940"></a>00940     }
<a name="l00941"></a>00941     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> filterCallTarget(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> x) {
<a name="l00942"></a>00942         <span class="keywordflow">return</span> x;
<a name="l00943"></a>00943     }
<a name="l00944"></a>00944     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> filterReturnTarget(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> x) {
<a name="l00945"></a>00945         <span class="keywordflow">return</span> x;
<a name="l00946"></a>00946     }
<a name="l00947"></a>00947 
<a name="l00948"></a>00948     <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt; <span class="comment">// In bits</span>
<a name="l00949"></a>00949     <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> readMemory(<a class="code" href="InstructionEnumsX86_8h.html#a0b09709b1ff4de1bbe47357b6d7b0e64" title="Intel x86 segment registers.">X86SegmentRegister</a> segreg, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> <a class="code" href="structFindConstantsPolicy.html#a4dd275e0c7fde0df2396d2239c845bbe">addr</a>, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;1&gt;</a> cond) {
<a name="l00950"></a>00950         <span class="keyword">struct </span>ReadMemoryConstraint: <span class="keyword">public</span> <a class="code" href="classConstraint.html">Constraint</a> {
<a name="l00951"></a>00951             <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> result;
<a name="l00952"></a>00952             <a class="code" href="structMemoryVariable.html">MemoryVariable</a>* memory;
<a name="l00953"></a>00953             <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> <a class="code" href="structFindConstantsPolicy.html#a4dd275e0c7fde0df2396d2239c845bbe">addr</a>;
<a name="l00954"></a>00954             <span class="keyword">virtual</span> <span class="keywordtype">void</span> run()<span class="keyword"> const </span>{
<a name="l00955"></a>00955                 <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;</a> resultRaw;
<a name="l00956"></a>00956                 <span class="keyword">const</span> <a class="code" href="structMemoryWriteSet.html" title="A set of values stored in memory.">MemoryWriteSet</a> &amp;mws = memory-&gt;get();
<a name="l00957"></a>00957                 mws.<a class="code" href="structMemoryWriteSet.html#a6655c5dc1e2f02ce1795cecb8a976470" title="Obtains the value stored at the specified memory address, returning true if the address is defined or...">getValueAtAddress</a>&lt;<a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a>&gt;(addr-&gt;get(), resultRaw, result-&gt;myName, result-&gt;def);
<a name="l00958"></a>00958                 result-&gt;set(resultRaw);
<a name="l00959"></a>00959             }
<a name="l00960"></a>00960             <span class="keyword">virtual</span> <span class="keywordtype">void</span> markDependencies() {
<a name="l00961"></a>00961                 addDependency(memory);
<a name="l00962"></a>00962                 addDependency(addr);
<a name="l00963"></a>00963             }
<a name="l00964"></a>00964         };
<a name="l00965"></a>00965         ReadMemoryConstraint* c = <span class="keyword">new</span> ReadMemoryConstraint();
<a name="l00966"></a>00966         c-&gt;result = <span class="keyword">new</span> <a class="code" href="structXVariable.html">XVariable&lt;Len&gt;</a>();
<a name="l00967"></a>00967         c-&gt;memory = <a class="code" href="structFindConstantsPolicy.html#a18b80c74732ea19708e2cb7af6cbc1cc">currentRset</a>.<a class="code" href="structRegisterSet.html#a70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>;
<a name="l00968"></a>00968         c-&gt;addr = <a class="code" href="structFindConstantsPolicy.html#a4dd275e0c7fde0df2396d2239c845bbe">addr</a>;
<a name="l00969"></a>00969         c-&gt;activate();
<a name="l00970"></a>00970         <span class="keywordflow">return</span> c-&gt;result;
<a name="l00971"></a>00971     }
<a name="l00972"></a>00972 
<a name="l00973"></a>00973     <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00974"></a>00974     <span class="keyword">static</span> <a class="code" href="structMemoryVariable.html">MemoryVariable</a>* memoryWriteHelper(<a class="code" href="structMemoryVariable.html">MemoryVariable</a>* memory, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> address, <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> data) {
<a name="l00975"></a>00975         <span class="keyword">struct </span>C: <span class="keyword">public</span> <a class="code" href="classConstraint.html">Constraint</a> {
<a name="l00976"></a>00976             <a class="code" href="structMemoryVariable.html">MemoryVariable</a>* memory;
<a name="l00977"></a>00977             <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> address;
<a name="l00978"></a>00978             <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> data;
<a name="l00979"></a>00979             <a class="code" href="structMemoryVariable.html">MemoryVariable</a>* memoryOut;
<a name="l00980"></a>00980             <span class="keyword">virtual</span> <span class="keywordtype">void</span> run()<span class="keyword"> const </span>{
<a name="l00981"></a>00981                 <a class="code" href="structMemoryWriteSet.html" title="A set of values stored in memory.">MemoryWriteSet</a> mws = memory-&gt;<a class="code" href="structMemoryVariable.html#aafe7886f04c547485bb7b0fe23d2093b">get</a>();
<a name="l00982"></a>00982                 mws.<a class="code" href="structMemoryWriteSet.html#a0ffbc1b898a737117ce4d5210ba314a7" title="Add a value to memory.">addWrite</a>(address-&gt;get(), extendByMSB&lt;Len, 32&gt;(data)-&gt;<span class="keyword">get</span>(), <a class="code" href="structFindConstantsPolicy.html#a54dbfd93eae48399930ad8875b51d183">Len</a> / 8);
<a name="l00983"></a>00983                 memoryOut-&gt;set(mws);
<a name="l00984"></a>00984             }
<a name="l00985"></a>00985             <span class="keyword">virtual</span> <span class="keywordtype">void</span> markDependencies() {addDependency(memory); addDependency(address); addDependency(data);}
<a name="l00986"></a>00986         };
<a name="l00987"></a>00987         C* c = <span class="keyword">new</span> C();
<a name="l00988"></a>00988         c-&gt;memory = memory;
<a name="l00989"></a>00989         c-&gt;address = address;
<a name="l00990"></a>00990         c-&gt;data = data;
<a name="l00991"></a>00991         c-&gt;memoryOut = <span class="keyword">new</span> <a class="code" href="structMemoryVariable.html">MemoryVariable</a>();
<a name="l00992"></a>00992         c-&gt;activate();
<a name="l00993"></a>00993         <span class="keywordflow">return</span> c-&gt;memoryOut;
<a name="l00994"></a>00994     }
<a name="l00995"></a>00995 
<a name="l00997"></a>00997     <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00998"></a>00998     <span class="keywordtype">void</span> writeMemory(<a class="code" href="InstructionEnumsX86_8h.html#a0b09709b1ff4de1bbe47357b6d7b0e64" title="Intel x86 segment registers.">X86SegmentRegister</a> segreg, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> addr, <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> data, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;1&gt;</a> cond) {
<a name="l00999"></a>00999         <a class="code" href="structFindConstantsPolicy.html#a18b80c74732ea19708e2cb7af6cbc1cc">currentRset</a>.<a class="code" href="structRegisterSet.html#a70669dade0ea18fc20058fc72d36a69e">memoryWrites</a> = memoryWriteHelper(<a class="code" href="structFindConstantsPolicy.html#a18b80c74732ea19708e2cb7af6cbc1cc">currentRset</a>.<a class="code" href="structRegisterSet.html#a70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>, addr, data);
<a name="l01000"></a>01000     }
<a name="l01001"></a>01001 
<a name="l01003"></a>01003     <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> nbits&gt;
<a name="l01004"></a>01004     <span class="keywordtype">void</span> writeMemory(<a class="code" href="InstructionEnumsX86_8h.html#a0b09709b1ff4de1bbe47357b6d7b0e64" title="Intel x86 segment registers.">X86SegmentRegister</a> segreg, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> addr, <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;nbits&gt;</a> data, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> repeat,
<a name="l01005"></a>01005                      <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;1&gt;</a> cond) {
<a name="l01006"></a>01006         <span class="comment">/* If repeat is a constant then perform the write that number of times. */</span>
<a name="l01007"></a>01007         <span class="keywordflow">if</span> (0==repeat-&gt;get().name) {
<a name="l01008"></a>01008             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;repeat-&gt;get().offset; i++) {
<a name="l01009"></a>01009                 <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> tmp_addr = add(addr, number&lt;32&gt;(i*nbits/8));
<a name="l01010"></a>01010                 <a class="code" href="structFindConstantsPolicy.html#a18b80c74732ea19708e2cb7af6cbc1cc">currentRset</a>.<a class="code" href="structRegisterSet.html#a70669dade0ea18fc20058fc72d36a69e">memoryWrites</a> = memoryWriteHelper(<a class="code" href="structFindConstantsPolicy.html#a18b80c74732ea19708e2cb7af6cbc1cc">currentRset</a>.<a class="code" href="structRegisterSet.html#a70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>, tmp_addr, data);
<a name="l01011"></a>01011             }
<a name="l01012"></a>01012         } <span class="keywordflow">else</span> {
<a name="l01013"></a>01013             <a class="code" href="structFindConstantsPolicy.html#a18b80c74732ea19708e2cb7af6cbc1cc">currentRset</a>.<a class="code" href="structRegisterSet.html#a70669dade0ea18fc20058fc72d36a69e">memoryWrites</a> = memoryWriteHelper(<a class="code" href="structFindConstantsPolicy.html#a18b80c74732ea19708e2cb7af6cbc1cc">currentRset</a>.<a class="code" href="structRegisterSet.html#a70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>, addr, data);
<a name="l01014"></a>01014         }
<a name="l01015"></a>01015     }
<a name="l01016"></a>01016 
<a name="l01017"></a>01017     <span class="keywordtype">void</span> hlt() {} <span class="comment">// FIXME</span>
<a name="l01018"></a>01018 
<a name="l01019"></a>01019     <span class="keywordtype">void</span> cpuid() {} <span class="comment">// FIXME</span>
<a name="l01020"></a>01020 
<a name="l01021"></a>01021     <span class="keywordtype">void</span> interrupt(uint8_t num) {
<a name="l01022"></a>01022         <a class="code" href="structFindConstantsPolicy.html#a18b80c74732ea19708e2cb7af6cbc1cc">currentRset</a>.<a class="code" href="structRegisterSet.html#abd97694302e8f6c77bc5013b82382923">setToBottom</a>();
<a name="l01023"></a>01023     }
<a name="l01024"></a>01024 
<a name="l01025"></a>01025     <span class="keywordtype">void</span> sysenter() {
<a name="l01026"></a>01026         <a class="code" href="structFindConstantsPolicy.html#a18b80c74732ea19708e2cb7af6cbc1cc">currentRset</a>.<a class="code" href="structRegisterSet.html#abd97694302e8f6c77bc5013b82382923">setToBottom</a>();
<a name="l01027"></a>01027     }
<a name="l01028"></a>01028 
<a name="l01029"></a>01029     <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;64&gt;</a> rdtsc() { <span class="comment">// FIXME</span>
<a name="l01030"></a>01030         <span class="keywordflow">return</span> number&lt;64&gt;(0);
<a name="l01031"></a>01031     }
<a name="l01032"></a>01032     <span class="keywordtype">void</span> startBlock(uint64_t addr) {}
<a name="l01033"></a>01033 
<a name="l01034"></a>01034     <span class="keywordtype">void</span> finishBlock(uint64_t addr) {}
<a name="l01035"></a>01035 
<a name="l01040"></a>01040     <span class="keywordtype">bool</span> isInstructionExternallyVisible(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a>* insn)<span class="keyword"> const </span>{
<a name="l01041"></a>01041         <span class="keywordflow">return</span> isFunctionEntry(insn);
<a name="l01042"></a>01042     }
<a name="l01043"></a>01043 
<a name="l01045"></a>01045     <span class="keywordtype">bool</span> isFunctionEntry(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn)<span class="keyword"> const </span>{
<a name="l01046"></a>01046         <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *fdefn = containingFunction(insn);
<a name="l01047"></a>01047         ROSE_ASSERT(fdefn);
<a name="l01048"></a>01048         <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *first_bb = <a class="code" href="Cxx__Grammar_8h.html#a0f21c6b7a4aede1900e16a5122233a83">isSgAsmBlock</a>(fdefn-&gt;<a class="code" href="classSgAsmFunction.html#a08fe036249766f5c7bca4403851f9cab">get_statementList</a>()[0]);
<a name="l01049"></a>01049         <span class="keywordflow">return</span> first_bb-&gt;<a class="code" href="classSgAsmBlock.html#adb50d2cc18f2d004a62c4b5f29c36643">get_id</a>()==insn-&gt;<a class="code" href="classSgAsmStatement.html#a9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>();
<a name="l01050"></a>01050     }
<a name="l01051"></a>01051     
<a name="l01053"></a>01053     <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *
<a name="l01054"></a>01054     containingFunction(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn)<span class="keyword"> const </span>{
<a name="l01055"></a>01055         <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *bb = <a class="code" href="Cxx__Grammar_8h.html#a0f21c6b7a4aede1900e16a5122233a83">isSgAsmBlock</a>(insn-&gt;<a class="code" href="classSgNode.html#aaa13b978be2c93c2d6d78f14fbc0e314" title="Access function for parent node.">get_parent</a>());
<a name="l01056"></a>01056         ROSE_ASSERT(bb!=NULL);
<a name="l01057"></a>01057         <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *fdefn = <a class="code" href="Cxx__Grammar_8h.html#a3374b86a87959b6a02d8ca8f792d693e">isSgAsmFunction</a>(bb-&gt;<a class="code" href="classSgNode.html#aaa13b978be2c93c2d6d78f14fbc0e314" title="Access function for parent node.">get_parent</a>());
<a name="l01058"></a>01058         ROSE_ASSERT(fdefn!=NULL);
<a name="l01059"></a>01059         <span class="keywordflow">return</span> fdefn;
<a name="l01060"></a>01060     }
<a name="l01061"></a>01061 
<a name="l01063"></a>01063     <span class="keywordtype">void</span> startInstruction(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a>* insn) {
<a name="l01064"></a>01064         addr = insn-&gt;<a class="code" href="classSgAsmStatement.html#a9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>();
<a name="l01065"></a>01065         <a class="code" href="structFindConstantsPolicy.html#a94a536bbac269a2f5d6e9c087c392616">newIp</a> = number&lt;32&gt;(<a class="code" href="structFindConstantsPolicy.html#a4dd275e0c7fde0df2396d2239c845bbe">addr</a>);
<a name="l01066"></a>01066         <span class="keywordflow">if</span> (isInstructionExternallyVisible(insn)) {
<a name="l01067"></a>01067             <span class="keywordflow">if</span> (<a class="code" href="structFindConstantsPolicy.html#a314eb44b10d0ddb974890f5a903c938e">initialRset</a>) {
<a name="l01068"></a>01068                 <a class="code" href="structFindConstantsPolicy.html#a86ad83f3a1aeb15f05c22295a649c304">rsets</a>[<a class="code" href="structFindConstantsPolicy.html#a4dd275e0c7fde0df2396d2239c845bbe">addr</a>] = *<a class="code" href="structFindConstantsPolicy.html#a314eb44b10d0ddb974890f5a903c938e">initialRset</a>;
<a name="l01069"></a>01069                 <a class="code" href="structFindConstantsPolicy.html#a314eb44b10d0ddb974890f5a903c938e">initialRset</a> = NULL;
<a name="l01070"></a>01070             } <span class="keywordflow">else</span> {
<a name="l01071"></a>01071                 <a class="code" href="structFindConstantsPolicy.html#a86ad83f3a1aeb15f05c22295a649c304">rsets</a>[<a class="code" href="structFindConstantsPolicy.html#a4dd275e0c7fde0df2396d2239c845bbe">addr</a>].setToBottom();
<a name="l01072"></a>01072             }
<a name="l01073"></a>01073         }
<a name="l01074"></a>01074         <a class="code" href="structFindConstantsPolicy.html#a18b80c74732ea19708e2cb7af6cbc1cc">currentRset</a> = <a class="code" href="structFindConstantsPolicy.html#a86ad83f3a1aeb15f05c22295a649c304">rsets</a>[<a class="code" href="structFindConstantsPolicy.html#a4dd275e0c7fde0df2396d2239c845bbe">addr</a>];
<a name="l01075"></a>01075         currentInstruction = <a class="code" href="Cxx__Grammar_8h.html#aa821b70974acc822c032fddf101296e9">isSgAsmx86Instruction</a>(insn);
<a name="l01076"></a>01076     }
<a name="l01077"></a>01077 
<a name="l01080"></a>01080     <span class="keywordtype">void</span> finishInstruction(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a>* insn) {
<a name="l01081"></a>01081         currentInstruction = NULL;
<a name="l01082"></a>01082         <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* insnx = <a class="code" href="Cxx__Grammar_8h.html#aa821b70974acc822c032fddf101296e9">isSgAsmx86Instruction</a>(insn);
<a name="l01083"></a>01083         ROSE_ASSERT (insnx);
<a name="l01084"></a>01084         std::vector&lt;uint64_t&gt; succs;
<a name="l01085"></a>01085         <span class="keywordflow">if</span> (<a class="code" href="structFindConstantsPolicy.html#a94a536bbac269a2f5d6e9c087c392616">newIp</a>-&gt;get().name == 0) {
<a name="l01086"></a>01086             <span class="comment">/* We know the address of the next instruction. */</span>
<a name="l01087"></a>01087             succs.push_back(<a class="code" href="structFindConstantsPolicy.html#a94a536bbac269a2f5d6e9c087c392616">newIp</a>-&gt;get().offset);
<a name="l01088"></a>01088         } <span class="keywordflow">else</span> {
<a name="l01089"></a>01089             <span class="comment">/* We don&#39;t know the address of the next instruction, so compute it from successors */</span>
<a name="l01090"></a>01090             uint64_t nextAddr = insnx-&gt;<a class="code" href="classSgAsmStatement.html#a9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>() + insnx-&gt;<a class="code" href="classSgAsmInstruction.html#ac239f0d80ab88127b2543fb0990803c3">get_raw_bytes</a>().size();
<a name="l01091"></a>01091             <span class="keywordflow">if</span> (!x86InstructionIsUnconditionalBranch(insnx)) {
<a name="l01092"></a>01092                 succs.push_back(nextAddr);
<a name="l01093"></a>01093             }
<a name="l01094"></a>01094             <span class="keywordflow">if</span> (isAsmBranch(insnx)) {
<a name="l01095"></a>01095                 uint64_t addr = 0;
<a name="l01096"></a>01096                 <span class="keywordtype">bool</span> knownTarget = getAsmKnownBranchTarget(insnx, addr);
<a name="l01097"></a>01097                 <span class="keywordflow">if</span> (knownTarget) {
<a name="l01098"></a>01098                     succs.push_back(addr);
<a name="l01099"></a>01099                 }
<a name="l01100"></a>01100             }
<a name="l01101"></a>01101         }
<a name="l01102"></a>01102 
<a name="l01103"></a>01103         <span class="comment">/* Merge result of processing instruction into register sets for successors */</span>
<a name="l01104"></a>01104         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; succs.size(); ++i) {
<a name="l01105"></a>01105             uint64_t s = succs[i];
<a name="l01106"></a>01106             <a class="code" href="structFindConstantsPolicy.html#a86ad83f3a1aeb15f05c22295a649c304">rsets</a>[s].mergeIn(<a class="code" href="structFindConstantsPolicy.html#a18b80c74732ea19708e2cb7af6cbc1cc">currentRset</a>);
<a name="l01107"></a>01107         }
<a name="l01108"></a>01108     }
<a name="l01109"></a>01109 };
<a name="l01110"></a>01110 
<a name="l01112"></a><a class="code" href="classCdeclFunctionPolicy.html">01112</a> <span class="keyword">class </span><a class="code" href="classCdeclFunctionPolicy.html" title="Augment the findConstants policy to do some special things for some instructions.">CdeclFunctionPolicy</a> : <span class="keyword">public</span> <a class="code" href="structFindConstantsPolicy.html">FindConstantsPolicy</a> {
<a name="l01113"></a><a class="code" href="classCdeclFunctionPolicy.html#a73d074e7e22a7df4ed3b4ff5b3d21c60">01113</a>     <a class="code" href="structVirtualBinCFG_1_1AuxiliaryInformation.html">VirtualBinCFG::AuxiliaryInformation</a> *<a class="code" href="classCdeclFunctionPolicy.html#a73d074e7e22a7df4ed3b4ff5b3d21c60">info</a>;
<a name="l01114"></a>01114 <span class="keyword">public</span>:
<a name="l01115"></a><a class="code" href="classCdeclFunctionPolicy.html#a0effeecd6ac9860e36bb1110acb4c2ac">01115</a>     <a class="code" href="classCdeclFunctionPolicy.html#a0effeecd6ac9860e36bb1110acb4c2ac">CdeclFunctionPolicy</a>(<a class="code" href="structVirtualBinCFG_1_1AuxiliaryInformation.html">VirtualBinCFG::AuxiliaryInformation</a> *<a class="code" href="classCdeclFunctionPolicy.html#a73d074e7e22a7df4ed3b4ff5b3d21c60">info</a>, <a class="code" href="structRegisterSet.html">RegisterSet</a> *rs)
<a name="l01116"></a>01116         : <a class="code" href="structFindConstantsPolicy.html">FindConstantsPolicy</a>(rs), info(info) {}
<a name="l01117"></a>01117 
<a name="l01119"></a><a class="code" href="classCdeclFunctionPolicy.html#ae4136b6bffb4c46c7f16476906b24d31">01119</a>     <span class="keywordtype">void</span> <a class="code" href="classCdeclFunctionPolicy.html#ae4136b6bffb4c46c7f16476906b24d31" title="Augments FindConstantsPolicy version.">startInstruction</a>(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a>* insn) {
<a name="l01120"></a>01120         <span class="comment">/* Any instruction that is a branch target should set the registerset to bottom rather than top. This isn&#39;t actually</span>
<a name="l01121"></a>01121 <span class="comment">         * the accurate thing to do, but it turns out that it works better this way for finding the signal handlers. */</span>
<a name="l01122"></a>01122         VirtualBinCFG::InstructionToAddressesMap::iterator found = <a class="code" href="classCdeclFunctionPolicy.html#a73d074e7e22a7df4ed3b4ff5b3d21c60">info</a>-&gt;<a class="code" href="structVirtualBinCFG_1_1AuxiliaryInformation.html#a44cd3f1f8fa5ec7e5d896bdda75850b5">incomingEdges</a>.find(insn);
<a name="l01123"></a>01123         <span class="keywordflow">if</span> (found!=<a class="code" href="classCdeclFunctionPolicy.html#a73d074e7e22a7df4ed3b4ff5b3d21c60">info</a>-&gt;<a class="code" href="structVirtualBinCFG_1_1AuxiliaryInformation.html#a44cd3f1f8fa5ec7e5d896bdda75850b5">incomingEdges</a>.end() &amp;&amp; found-&gt;second.size()&gt;1) {
<a name="l01124"></a>01124             <a class="code" href="structRegisterSet.html">RegisterSet</a> &amp;rs = <a class="code" href="structFindConstantsPolicy.html#a86ad83f3a1aeb15f05c22295a649c304">rsets</a>[insn-&gt;<a class="code" href="classSgAsmStatement.html#a9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>()];
<a name="l01125"></a>01125             <a class="code" href="structMemoryWriteSet.html" title="A set of values stored in memory.">MemoryWriteSet</a> saved = rs.<a class="code" href="structRegisterSet.html#a70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>-&gt;<a class="code" href="structMemoryVariable.html#aafe7886f04c547485bb7b0fe23d2093b">get</a>();
<a name="l01126"></a>01126             rs.<a class="code" href="structRegisterSet.html#abd97694302e8f6c77bc5013b82382923">setToBottom</a>();
<a name="l01127"></a>01127             rs.<a class="code" href="structRegisterSet.html#a70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>-&gt;<a class="code" href="structMemoryVariable.html#a00e681d73a045c3f44ce2758f69b75be">set</a>(saved);
<a name="l01128"></a>01128         }
<a name="l01129"></a>01129 
<a name="l01130"></a>01130         <a class="code" href="classCdeclFunctionPolicy.html#ae4136b6bffb4c46c7f16476906b24d31" title="Augments FindConstantsPolicy version.">FindConstantsPolicy::startInstruction</a>(insn);
<a name="l01131"></a>01131 
<a name="l01132"></a>01132         <span class="comment">/* GCC assumes that the direction flag (df) is zero on function entry. See gcc man page for -mcld switch. */</span>
<a name="l01133"></a>01133         <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;1&gt;</a> df = <a class="code" href="structFindConstantsPolicy.html#a86ad83f3a1aeb15f05c22295a649c304">rsets</a>[insn-&gt;<a class="code" href="classSgAsmStatement.html#a9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>()].flag[<a class="code" href="InstructionEnumsX86_8h.html#ab8c1069abaa6534f3481d52cfe950881a749200f06e597afec773e54419dad228">x86_flag_df</a>]-&gt;get();
<a name="l01134"></a>01134         <span class="keywordflow">if</span> (df.<a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a>!=0)
<a name="l01135"></a>01135             <a class="code" href="structFindConstantsPolicy.html#a4da0db0b4eb713db300d82ac63d45609">writeFlag</a>(<a class="code" href="InstructionEnumsX86_8h.html#ab8c1069abaa6534f3481d52cfe950881a749200f06e597afec773e54419dad228">x86_flag_df</a>, false_());
<a name="l01136"></a>01136 
<a name="l01137"></a>01137 <span class="preprocessor">#if 0   </span><span class="comment">/*DEBUGGING: Show register set at start of instruction */</span>
<a name="l01138"></a>01138         std::cout &lt;&lt;<span class="stringliteral">&quot;Initial RSET for [&quot;</span> &lt;&lt;<a class="code" href="AsmUnparser__compat_8h.html#a3b979292833b85f5b059b2893250453c" title="Returns the string representation of an assembly instruction with address.">unparseInstructionWithAddress</a>(insn) &lt;&lt;<span class="stringliteral">&quot;]\n&quot;</span> &lt;&lt;<a class="code" href="structFindConstantsPolicy.html#a18b80c74732ea19708e2cb7af6cbc1cc">currentRset</a>;
<a name="l01139"></a>01139 <span class="preprocessor">#endif</span>
<a name="l01140"></a>01140 <span class="preprocessor"></span>    }
<a name="l01141"></a>01141 
<a name="l01142"></a>01142     <span class="comment">/* It is common for a function to align local variables on a particular boundary and this happens near the beginning of a</span>
<a name="l01143"></a>01143 <span class="comment">     * function by masking off the low-order bits of the stack pointer. For example:</span>
<a name="l01144"></a>01144 <span class="comment">     *     push ebp                   -- save stack frame</span>
<a name="l01145"></a>01145 <span class="comment">     *     mov  ebp, esp              -- create new stack frame</span>
<a name="l01146"></a>01146 <span class="comment">     *     sub  esp, 0xa8             -- allocate stack space for locals</span>
<a name="l01147"></a>01147 <span class="comment">     *     and  esp, 0xfffffff0       -- align stack on 16-byte boundary</span>
<a name="l01148"></a>01148 <span class="comment">     * The FindConstantsPolicy, when it encounters such an AND instruction with a named value (non-constant) in %esp, simply</span>
<a name="l01149"></a>01149 <span class="comment">     * gives %esp a new named value.  What we want to do instead is subtract 16 from the stack pointer, thus introducing some</span>
<a name="l01150"></a>01150 <span class="comment">     * padding between the top local variable and the bottom of the call frame. The stack after the AND looks like this:</span>
<a name="l01151"></a>01151 <span class="comment">     *     argN</span>
<a name="l01152"></a>01152 <span class="comment">     *     ...</span>
<a name="l01153"></a>01153 <span class="comment">     *     arg0</span>
<a name="l01154"></a>01154 <span class="comment">     *     return address</span>
<a name="l01155"></a>01155 <span class="comment">     *     old stack frame from [push ebp]</span>
<a name="l01156"></a>01156 <span class="comment">     *     padding we inserted from [and esp, 0xfffffff0]</span>
<a name="l01157"></a>01157 <span class="comment">     *     top local variable</span>
<a name="l01158"></a>01158 <span class="comment">     *     ...</span>
<a name="l01159"></a>01159 <span class="comment">     *     bottom local variable          &lt;--- stack pointer points here</span>
<a name="l01160"></a>01160 <span class="comment">     *     </span>
<a name="l01161"></a>01161 <span class="comment">     * Note: The policy &quot;and_&quot; method is called for other instructions besides AND, some of which don&#39;t have two operands.</span>
<a name="l01162"></a>01162 <span class="comment">     */</span>
<a name="l01163"></a>01163     <span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l01164"></a><a class="code" href="classCdeclFunctionPolicy.html#a9d57e77607370dd37f54408e57669ce5">01164</a>     <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> <a class="code" href="classCdeclFunctionPolicy.html#a9d57e77607370dd37f54408e57669ce5">and_</a>(<a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> a, <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> b) {
<a name="l01165"></a>01165         <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> result = <span class="keyword">new</span> <a class="code" href="structXVariable.html">XVariable&lt;Len&gt;</a>();
<a name="l01166"></a>01166         <span class="keyword">struct </span>IC: <span class="keyword">public</span> <a class="code" href="structBinaryConstraint.html">BinaryConstraint</a>&lt;Len, Len, Len&gt; {
<a name="l01167"></a>01167             IC(<a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> result, <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> var1, <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> var2)
<a name="l01168"></a>01168                 : <a class="code" href="structBinaryConstraint.html">BinaryConstraint&lt;Len, Len, Len&gt;</a>(result, var1, var2)
<a name="l01169"></a>01169                 {}
<a name="l01170"></a>01170             <span class="keyword">virtual</span> <span class="keywordtype">void</span> run()<span class="keyword"> const </span>{
<a name="l01171"></a>01171                 <span class="comment">/* &quot;var1&quot;, &quot;var2&quot;, and &quot;result&quot; here are initialized from &quot;a&quot;, &quot;b&quot;, and &quot;result&quot; above */</span>
<a name="l01172"></a>01172                 <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;</a> le1 = <a class="code" href="structBinaryConstraint.html">BinaryConstraint&lt;Len, Len, Len&gt;::var1</a>-&gt;get();
<a name="l01173"></a>01173                 <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;</a> le2 = <a class="code" href="structBinaryConstraint.html">BinaryConstraint&lt;Len, Len, Len&gt;::var2</a>-&gt;get();
<a name="l01174"></a>01174                 <a class="code" href="structXVariablePtr.html" title="A pointer to an XVariable.">XVariablePtr&lt;Len&gt;</a> result = <a class="code" href="structBinaryConstraint.html">BinaryConstraint&lt;Len, Len, Len&gt;::result</a>;
<a name="l01175"></a>01175 
<a name="l01176"></a>01176                 <span class="comment">/* The instruction for which this policy method is being invoked. */</span>
<a name="l01177"></a>01177                 <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn = <a class="code" href="Cxx__Grammar_8h.html#aa821b70974acc822c032fddf101296e9">isSgAsmx86Instruction</a>(result-&gt;def);
<a name="l01178"></a>01178                 ROSE_ASSERT(insn);
<a name="l01179"></a>01179                 <a class="code" href="Cxx__Grammar_8h.html#a5ba40394e1b351b2d55384ed355a4077">SgAsmExpressionPtrList</a> &amp;opands = insn-&gt;<a class="code" href="classSgAsmInstruction.html#a264e86d032b0a589d9dc520e79d09eb8">get_operandList</a>()-&gt;<a class="code" href="classSgAsmOperandList.html#abb5638c0533863030ad7acee019f1f17">get_operands</a>();
<a name="l01180"></a>01180 
<a name="l01181"></a>01181                 <span class="keywordflow">if</span> (!le1.<a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a> &amp;&amp; !le2.<a class="code" href="structLatticeElement.html#a9434c239626487fec51c305b64ac46d0">name</a>) {
<a name="l01182"></a>01182                     <span class="comment">/* Operands are known constants, so the result will be a known constant. */</span>
<a name="l01183"></a>01183                     result-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;::constant</a>(le1.<a class="code" href="structLatticeElement.html#a5f7046b6efe5660c07b84883ee26a4cc">offset</a> &amp; le2.<a class="code" href="structLatticeElement.html#a5f7046b6efe5660c07b84883ee26a4cc">offset</a>, result-&gt;def));
<a name="l01184"></a>01184                 } <span class="keywordflow">else</span> {
<a name="l01185"></a>01185                     <span class="comment">/* Is this instruction aligning the stack pointer? */</span>
<a name="l01186"></a>01186                     <a class="code" href="classSgAsmx86RegisterReferenceExpression.html">SgAsmx86RegisterReferenceExpression</a> *op1 = (opands.size()==2 ?
<a name="l01187"></a>01187                                                                 <a class="code" href="Cxx__Grammar_8h.html#a5e5ead71a8653e1d062d92582359e574">isSgAsmx86RegisterReferenceExpression</a>(opands[0]) : NULL);
<a name="l01188"></a>01188                     <span class="keywordflow">if</span> (op1 &amp;&amp; insn-&gt;<a class="code" href="classSgAsmx86Instruction.html#afb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()==<a class="code" href="AssemblerX86Init_8h.html#acb800e57ccb0a3ac5b7a89056bca5571a7e08555010e9e899f138ebf6ff01bfab">x86_and</a> &amp;&amp;
<a name="l01189"></a>01189                         op1-&gt;<a class="code" href="classSgAsmRegisterReferenceExpression.html#ae4a2ae3037e897d983674a61bbf16ec0">get_descriptor</a>().<a class="code" href="structRegisterDescriptor.html#a00a1b8b124f547095b6409606276a65c">get_major</a>()==<a class="code" href="InstructionEnumsX86_8h.html#a12229bfc0029dbc592944d1d6514e30fabcab68a004f857b0eb9dc6a5b736b1ec" title="Minors are X86GeneralPurposeRegister (ax,cx,dx,bx,sp,bp,si,di,r8..r15)">x86_regclass_gpr</a> &amp;&amp; op1-&gt;<a class="code" href="classSgAsmRegisterReferenceExpression.html#ae4a2ae3037e897d983674a61bbf16ec0">get_descriptor</a>().<a class="code" href="structRegisterDescriptor.html#a2e01183db39faae43a9d6671dd27a12b">get_minor</a>()==<a class="code" href="InstructionEnumsX86_8h.html#a5069ca462f85d162797843f48bc6bceda1f5849637e513ff627dc7360562d1ca0">x86_gpr_sp</a> &amp;&amp;
<a name="l01190"></a>01190                         !le2.<a class="code" href="structLatticeElement.html#a4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>) {
<a name="l01191"></a>01191                         <span class="comment">/* Yes, we&#39;re aligning the stack pointer. */</span>
<a name="l01192"></a>01192                         <a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;</a> newval = le1; <span class="comment">/* stack pointer */</span>
<a name="l01193"></a>01193                         uint32_t alignment = ~(uint32_t)le2.<a class="code" href="structLatticeElement.html#a5f7046b6efe5660c07b84883ee26a4cc">offset</a> + 1; <span class="comment">/*two&#39;s complement*/</span>
<a name="l01194"></a>01194                         <span class="comment">//std::cout &lt;&lt;&quot;ROBB: aligning stack on &quot;&lt;&lt;std::dec &lt;&lt;alignment &lt;&lt;&quot;-byte boundary&quot;</span>
<a name="l01195"></a>01195                         <span class="comment">//          &lt;&lt;&quot; [&quot; &lt;&lt;unparseInstructionWithAddress(insn) &lt;&lt;&quot;]\n&quot;;</span>
<a name="l01196"></a>01196                         newval.<a class="code" href="structLatticeElement.html#a5f7046b6efe5660c07b84883ee26a4cc">offset</a> -= alignment;
<a name="l01197"></a>01197                         newval.<a class="code" href="structLatticeElement.html#afb9076844cf7aeb97f205a872b685e1b">definingInstruction</a> = insn;
<a name="l01198"></a>01198                         result-&gt;set(newval);
<a name="l01199"></a>01199                     } <span class="keywordflow">else</span> {
<a name="l01200"></a>01200                         <span class="comment">/* No, it is some other use of AND and one or both of the operands are unknown values */</span>
<a name="l01201"></a>01201                         result-&gt;set(<a class="code" href="structLatticeElement.html" title="A LatticeElement contains the value of a register or memory location.">LatticeElement&lt;Len&gt;</a>());
<a name="l01202"></a>01202                     }
<a name="l01203"></a>01203                 }
<a name="l01204"></a>01204             }
<a name="l01205"></a>01205             <span class="keyword">virtual</span> uint64_t compute(uint64_t, uint64_t)<span class="keyword"> const </span>{
<a name="l01206"></a>01206                 abort(); <span class="comment">/* handled by run() above */</span>
<a name="l01207"></a>01207             }
<a name="l01208"></a>01208         };
<a name="l01209"></a>01209         (<span class="keyword">new</span> IC(result, a, b))-&gt;activate(); <span class="comment">/*invokes the run() method above*/</span>
<a name="l01210"></a>01210         <span class="keywordflow">return</span> result;
<a name="l01211"></a>01211     }
<a name="l01212"></a>01212 };
<a name="l01213"></a>01213 
<a name="l01218"></a><a class="code" href="classFindConstantsABIPolicy.html">01218</a> <span class="keyword">class </span><a class="code" href="classFindConstantsABIPolicy.html" title="Instruction semantics policy for API-compliant function calls.">FindConstantsABIPolicy</a>: <span class="keyword">public</span> <a class="code" href="structFindConstantsPolicy.html">FindConstantsPolicy</a> {
<a name="l01219"></a>01219 <span class="keyword">public</span>:
<a name="l01220"></a>01220     <span class="comment">/* Returns the function containing the instruction. */</span>
<a name="l01221"></a><a class="code" href="classFindConstantsABIPolicy.html#a2c0c3d921f404ebe181b7e83974f3364">01221</a>     <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a>* <a class="code" href="classFindConstantsABIPolicy.html#a2c0c3d921f404ebe181b7e83974f3364">find_function</a>(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a>* insn) {
<a name="l01222"></a>01222         <a class="code" href="classSgNode.html" title="This class represents the base class for all IR nodes within Sage III.">SgNode</a>* n=insn;
<a name="l01223"></a>01223         <span class="keywordflow">while</span> (n &amp;&amp; !<a class="code" href="Cxx__Grammar_8h.html#a3374b86a87959b6a02d8ca8f792d693e">isSgAsmFunction</a>(n))
<a name="l01224"></a>01224             n = n-&gt;<a class="code" href="classSgNode.html#aaa13b978be2c93c2d6d78f14fbc0e314" title="Access function for parent node.">get_parent</a>();
<a name="l01225"></a>01225         <span class="keywordflow">return</span> <a class="code" href="Cxx__Grammar_8h.html#a3374b86a87959b6a02d8ca8f792d693e">isSgAsmFunction</a>(n);
<a name="l01226"></a>01226     }
<a name="l01227"></a>01227 
<a name="l01228"></a>01228     <span class="comment">/* Determines if the function contains an instruction at the specified address. */</span>
<a name="l01229"></a><a class="code" href="classFindConstantsABIPolicy.html#a65e6121810c2d31fd23675819192f629">01229</a>     <span class="keywordtype">bool</span> <a class="code" href="classFindConstantsABIPolicy.html#a65e6121810c2d31fd23675819192f629">function_contains_address</a>(<a class="code" href="classSgAsmFunction.html">SgAsmFunction</a>* f, <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va) {
<a name="l01230"></a>01230         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;f-&gt;<a class="code" href="classSgAsmFunction.html#a08fe036249766f5c7bca4403851f9cab">get_statementList</a>().size(); ++i) {
<a name="l01231"></a>01231             <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a>* block = <a class="code" href="Cxx__Grammar_8h.html#a0f21c6b7a4aede1900e16a5122233a83">isSgAsmBlock</a>(f-&gt;<a class="code" href="classSgAsmFunction.html#a08fe036249766f5c7bca4403851f9cab">get_statementList</a>()[i]);
<a name="l01232"></a>01232             ROSE_ASSERT(block!=NULL);
<a name="l01233"></a>01233             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0; j&lt;block-&gt;<a class="code" href="classSgAsmBlock.html#ac19627b98d9cee481b9c533ad21ac755">get_statementList</a>().size(); ++j) {
<a name="l01234"></a>01234                 <a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a>* insn = <a class="code" href="Cxx__Grammar_8h.html#a8ea3968ea14e6511567d5e5b654315f1">isSgAsmInstruction</a>(block-&gt;<a class="code" href="classSgAsmBlock.html#ac19627b98d9cee481b9c533ad21ac755">get_statementList</a>()[j]);
<a name="l01235"></a>01235                 <span class="keywordflow">if</span> (insn &amp;&amp; insn-&gt;<a class="code" href="classSgAsmStatement.html#a9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>()==va)
<a name="l01236"></a>01236                     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01237"></a>01237             }
<a name="l01238"></a>01238         }
<a name="l01239"></a>01239         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01240"></a>01240     }
<a name="l01241"></a>01241 
<a name="l01242"></a>01242     <span class="comment">/* Returns true if the function at the specified address complies with the ABI */</span>
<a name="l01243"></a><a class="code" href="classFindConstantsABIPolicy.html#aa6db69906d2c0258ebf0b3afa93c262d">01243</a>     <span class="keywordtype">bool</span> <a class="code" href="classFindConstantsABIPolicy.html#aa6db69906d2c0258ebf0b3afa93c262d">is_abi_compliant</a>(<a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a>) {
<a name="l01244"></a>01244         <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">/* left as an exercise for later ;-) */</span>
<a name="l01245"></a>01245     }
<a name="l01246"></a>01246 
<a name="l01247"></a>01247     <span class="comment">/* Determines if a CALL instruction in fact calls a function. Malware sometimes uses CALL instructions for unconditional</span>
<a name="l01248"></a>01248 <span class="comment">     * jumps, in which case the instruction partitioner (Partitioner class) would have placed the call target in the same</span>
<a name="l01249"></a>01249 <span class="comment">     * function as the CALL instruction (note that recursive calls are to the entry address of the function). */</span>
<a name="l01250"></a><a class="code" href="classFindConstantsABIPolicy.html#a10e0b74511c877dfc306aae065597df5">01250</a>     <span class="keywordtype">bool</span> <a class="code" href="classFindConstantsABIPolicy.html#a10e0b74511c877dfc306aae065597df5">is_abi_function_call</a>(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a>* insn_) {
<a name="l01251"></a>01251         <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* insn = <a class="code" href="Cxx__Grammar_8h.html#aa821b70974acc822c032fddf101296e9">isSgAsmx86Instruction</a>(insn_);
<a name="l01252"></a>01252         ROSE_ASSERT(insn!=NULL);
<a name="l01253"></a>01253         <span class="keywordflow">if</span> (insn-&gt;<a class="code" href="classSgAsmx86Instruction.html#afb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()!=<a class="code" href="AssemblerX86Init_8h.html#acb800e57ccb0a3ac5b7a89056bca5571a221e4d163bb7557e57e351140aa7855e">x86_call</a> &amp;&amp; insn-&gt;<a class="code" href="classSgAsmx86Instruction.html#afb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()!=<a class="code" href="AssemblerX86Init_8h.html#acb800e57ccb0a3ac5b7a89056bca5571a4edb34feaf8cb03afb49361a9a0b26c4">x86_farcall</a>)
<a name="l01254"></a>01254             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01255"></a>01255         <span class="keywordflow">if</span> (<a class="code" href="structFindConstantsPolicy.html#a94a536bbac269a2f5d6e9c087c392616">newIp</a>-&gt;get().name!=0)
<a name="l01256"></a>01256             <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">/*if we don&#39;t know the call target then assume it&#39;s a function call*/</span>
<a name="l01257"></a>01257         <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *caller = <a class="code" href="classFindConstantsABIPolicy.html#a2c0c3d921f404ebe181b7e83974f3364">find_function</a>(insn);
<a name="l01258"></a>01258         <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> callee = <a class="code" href="structFindConstantsPolicy.html#a94a536bbac269a2f5d6e9c087c392616">newIp</a>-&gt;get().offset;
<a name="l01259"></a>01259         <span class="keywordflow">if</span> (<a class="code" href="classFindConstantsABIPolicy.html#a65e6121810c2d31fd23675819192f629">function_contains_address</a>(caller, callee) &amp;&amp; caller-&gt;<a class="code" href="classSgAsmFunction.html#a6edeeb78e01e2af6e59a5c6f7b0088af">get_entry_va</a>()!=callee)
<a name="l01260"></a>01260             <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">/*intra-function branch*/</span>
<a name="l01261"></a>01261         <span class="keywordflow">return</span> <a class="code" href="classFindConstantsABIPolicy.html#aa6db69906d2c0258ebf0b3afa93c262d">is_abi_compliant</a>(callee);
<a name="l01262"></a>01262     }
<a name="l01263"></a>01263 
<a name="l01264"></a>01264     <span class="comment">/* Augments superclass method so that the instruction following a CALL (provided this is really a function call and not</span>
<a name="l01265"></a>01265 <span class="comment">     * just an intra-function branch) has a register set whose callee-preserved registers are actually reserved across the</span>
<a name="l01266"></a>01266 <span class="comment">     * CALL instruction. We also preserve the stack pointer, frame pointer, and all memory. */</span>
<a name="l01267"></a><a class="code" href="classFindConstantsABIPolicy.html#a32e1434e92af6ac7c21b6a173e0d340e">01267</a>     <span class="keywordtype">void</span> <a class="code" href="classFindConstantsABIPolicy.html#a32e1434e92af6ac7c21b6a173e0d340e">finishInstruction</a>(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a>* insn_) {
<a name="l01268"></a>01268         <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* insn = <a class="code" href="Cxx__Grammar_8h.html#aa821b70974acc822c032fddf101296e9">isSgAsmx86Instruction</a>(insn_);
<a name="l01269"></a>01269         ROSE_ASSERT(insn!=NULL);
<a name="l01270"></a>01270         <span class="keywordflow">if</span> (<a class="code" href="classFindConstantsABIPolicy.html#a10e0b74511c877dfc306aae065597df5">is_abi_function_call</a>(insn)) {
<a name="l01271"></a>01271             <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> call_va = insn-&gt;<a class="code" href="classSgAsmStatement.html#a9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>();
<a name="l01272"></a>01272             <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> next_va = insn-&gt;<a class="code" href="classSgAsmStatement.html#a9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>() + insn-&gt;<a class="code" href="classSgAsmInstruction.html#ac239f0d80ab88127b2543fb0990803c3">get_raw_bytes</a>().size();
<a name="l01273"></a>01273             <a class="code" href="structRegisterSet.html">RegisterSet</a> rset;
<a name="l01274"></a>01274             rset.<a class="code" href="structRegisterSet.html#abd97694302e8f6c77bc5013b82382923">setToBottom</a>();
<a name="l01275"></a>01275             rset.<a class="code" href="structRegisterSet.html#a70669dade0ea18fc20058fc72d36a69e">memoryWrites</a> = <a class="code" href="structFindConstantsPolicy.html#a86ad83f3a1aeb15f05c22295a649c304">rsets</a>[call_va].memoryWrites;
<a name="l01276"></a>01276             rset.<a class="code" href="structRegisterSet.html#ac033b9e454a5cfcb642ec5d280be7f90">gpr</a>[<a class="code" href="InstructionEnumsX86_8h.html#a5069ca462f85d162797843f48bc6bceda655fe4130e38fe77197bc264779da97d">x86_gpr_bx</a>] = <a class="code" href="structFindConstantsPolicy.html#a86ad83f3a1aeb15f05c22295a649c304">rsets</a>[call_va].gpr[<a class="code" href="InstructionEnumsX86_8h.html#a5069ca462f85d162797843f48bc6bceda655fe4130e38fe77197bc264779da97d">x86_gpr_bx</a>];
<a name="l01277"></a>01277             rset.<a class="code" href="structRegisterSet.html#ac033b9e454a5cfcb642ec5d280be7f90">gpr</a>[<a class="code" href="InstructionEnumsX86_8h.html#a5069ca462f85d162797843f48bc6bceda4e00b4b002bfe801084a2c7648bf884e">x86_gpr_di</a>] = <a class="code" href="structFindConstantsPolicy.html#a86ad83f3a1aeb15f05c22295a649c304">rsets</a>[call_va].gpr[<a class="code" href="InstructionEnumsX86_8h.html#a5069ca462f85d162797843f48bc6bceda4e00b4b002bfe801084a2c7648bf884e">x86_gpr_di</a>];
<a name="l01278"></a>01278             rset.<a class="code" href="structRegisterSet.html#ac033b9e454a5cfcb642ec5d280be7f90">gpr</a>[<a class="code" href="InstructionEnumsX86_8h.html#a5069ca462f85d162797843f48bc6bceda0b2a4d9f03643be4cb0e519175695e45">x86_gpr_si</a>] = <a class="code" href="structFindConstantsPolicy.html#a86ad83f3a1aeb15f05c22295a649c304">rsets</a>[call_va].gpr[<a class="code" href="InstructionEnumsX86_8h.html#a5069ca462f85d162797843f48bc6bceda0b2a4d9f03643be4cb0e519175695e45">x86_gpr_si</a>];
<a name="l01279"></a>01279             rset.<a class="code" href="structRegisterSet.html#ac033b9e454a5cfcb642ec5d280be7f90">gpr</a>[<a class="code" href="InstructionEnumsX86_8h.html#a5069ca462f85d162797843f48bc6bceda1f5849637e513ff627dc7360562d1ca0">x86_gpr_sp</a>] = <a class="code" href="structFindConstantsPolicy.html#a86ad83f3a1aeb15f05c22295a649c304">rsets</a>[call_va].gpr[<a class="code" href="InstructionEnumsX86_8h.html#a5069ca462f85d162797843f48bc6bceda1f5849637e513ff627dc7360562d1ca0">x86_gpr_sp</a>];
<a name="l01280"></a>01280             rset.<a class="code" href="structRegisterSet.html#ac033b9e454a5cfcb642ec5d280be7f90">gpr</a>[<a class="code" href="InstructionEnumsX86_8h.html#a5069ca462f85d162797843f48bc6bcedaa9ec94ced24945de2d3e64be23e8a19b">x86_gpr_bp</a>] = <a class="code" href="structFindConstantsPolicy.html#a86ad83f3a1aeb15f05c22295a649c304">rsets</a>[call_va].gpr[<a class="code" href="InstructionEnumsX86_8h.html#a5069ca462f85d162797843f48bc6bcedaa9ec94ced24945de2d3e64be23e8a19b">x86_gpr_bp</a>];
<a name="l01281"></a>01281             <a class="code" href="structFindConstantsPolicy.html#a86ad83f3a1aeb15f05c22295a649c304">rsets</a>[next_va].mergeIn(rset);
<a name="l01282"></a>01282         }
<a name="l01283"></a>01283         <a class="code" href="classFindConstantsABIPolicy.html#a32e1434e92af6ac7c21b6a173e0d340e">FindConstantsPolicy::finishInstruction</a>(insn);
<a name="l01284"></a>01284     }
<a name="l01285"></a>01285 };
<a name="l01286"></a>01286 
<a name="l01287"></a>01287 <span class="preprocessor">#endif </span><span class="comment">/* !findConstants_H */</span>
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="findConstants_8h.html">findConstants.h</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Thu Dec 1 2011 16:31:43 for ROSE by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
