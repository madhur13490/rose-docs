<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: BinaryAnalysis::FunctionCall Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceBinaryAnalysis.html">BinaryAnalysis</a>::<a class="el" href="classBinaryAnalysis_1_1FunctionCall.html">FunctionCall</a></div>
<h1>BinaryAnalysis::FunctionCall Class Reference</h1><!-- doxytag: class="BinaryAnalysis::FunctionCall" --><code>#include &lt;<a class="el" href="BinaryFunctionCall_8h-source.html">BinaryFunctionCall.h</a>&gt;</code>
<p>
Collaboration diagram for BinaryAnalysis::FunctionCall:<p><center><img src="classBinaryAnalysis_1_1FunctionCall__coll__graph.png" border="0" usemap="#BinaryAnalysis_1_1FunctionCall__coll__map" alt="Collaboration graph"></center>
<map name="BinaryAnalysis_1_1FunctionCall__coll__map">
<area href="classBinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html" shape="rect" coords="5,7,277,33" alt="">
<area href="classBinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html" shape="rect" coords="301,7,584,33" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classBinaryAnalysis_1_1FunctionCall-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Binary function call analysis. 
<p>
This class serves mostly to organize the functions that operate on function calls, but also provides a container for various settings that influence the function call analyses, such as vertex and edge filters.<p>
<a class="el" href="classFunction.html">Function</a> call graphs can be computed over any subtree of the AST, although one usually does so over an entire binary interpretation (<a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a>). The vertex and edge filters can restrict which functions and call edges are considered by the various methods of this class. 
<p>

<p>
Definition at line <a class="el" href="BinaryFunctionCall_8h-source.html#l00018">18</a> of file <a class="el" href="BinaryFunctionCall_8h-source.html">BinaryFunctionCall.h</a>.<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef boost::adjacency_list&lt;<br>
 boost::setS, boost::vecS,<br>
 boost::bidirectionalS, boost::property&lt;<br>
 boost::vertex_name_t, <a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> * &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#2532d28ee1226ae45fd43cc6c660ceac">Graph</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default function call graph type.  <a href="#2532d28ee1226ae45fd43cc6c660ceac"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#b4f7f47cc9da605adb5822828d9b545f">FunctionCall</a> ()</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class FunctionCallGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#2eba696d163fb97e4e08d26c62f92649">cache_vertex_descriptors</a> (const FunctionCallGraph &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cache vertex descriptors in AST.  <a href="#2eba696d163fb97e4e08d26c62f92649"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#2a2742416189f2254f44c6e9c9d2f6a8">set_vertex_filter</a> (<a class="el" href="classBinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html">VertexFilter</a> *filter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manipulate the vertex filter.  <a href="#2a2742416189f2254f44c6e9c9d2f6a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classBinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html">VertexFilter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#24444c917456113162c36329f3927c4f">get_vertex_filter</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manipulate the vertex filter.  <a href="#24444c917456113162c36329f3927c4f"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#45dbebd296a340cbd7c0fcba4a0bb9e1">set_edge_filter</a> (<a class="el" href="classBinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html">EdgeFilter</a> *filter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manipulate the edge filter.  <a href="#45dbebd296a340cbd7c0fcba4a0bb9e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classBinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html">EdgeFilter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#ef508972512bbc8ab37f859f918d6985">get_edge_filter</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manipulate the edge filter.  <a href="#ef508972512bbc8ab37f859f918d6985"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#a59d513bee13e8339937d35517b018a3">is_vertex_filtered</a> (<a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *func, <a class="el" href="classBinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html">VertexFilter</a> *filter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if a vertex is filtered out.  <a href="#a59d513bee13e8339937d35517b018a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#e236e4da49ba54eb2368913967ec9dcd">is_vertex_filtered</a> (<a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *func)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if a vertex is filtered out.  <a href="#e236e4da49ba54eb2368913967ec9dcd"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#3db7e3b728529310098bc4218b618a80">is_edge_filtered</a> (<a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *src, <a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *dst, <a class="el" href="classBinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html">EdgeFilter</a> *filter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if an edge is filtered out.  <a href="#3db7e3b728529310098bc4218b618a80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#7e553622e6f012bfbee95a3e2f36b6ed">is_edge_filtered</a> (<a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *src, <a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if an edge is filtered out.  <a href="#7e553622e6f012bfbee95a3e2f36b6ed"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class FunctionCallGraph, class ControlFlowGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">FunctionCallGraph&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#ccf917f4d9602275b854cc1cf0e2bf48">build_cg_from_cfg</a> (const ControlFlowGraph &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build a function call graph from a control flow graph.  <a href="#ccf917f4d9602275b854cc1cf0e2bf48"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class ControlFlowGraph, class FunctionCallGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#c878096df46fe62d3a8f7e05aa0c42cd">build_cg_from_cfg</a> (const ControlFlowGraph &amp;<a class="el" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>, FunctionCallGraph &amp;cg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build a function call graph from a control flow graph.  <a href="#c878096df46fe62d3a8f7e05aa0c42cd"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class FunctionCallGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">FunctionCallGraph&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#0a66374f57c8167400aeca97cfe83854">build_cg_from_ast</a> (<a class="el" href="classSgNode.html">SgNode</a> *root)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build a function call graph from an AST.  <a href="#0a66374f57c8167400aeca97cfe83854"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class FunctionCallGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#45bddd25d52248c3b72797696bf06dcb">build_cg_from_ast</a> (<a class="el" href="classSgNode.html">SgNode</a> *root, FunctionCallGraph &amp;cg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build a function call graph from an AST.  <a href="#45bddd25d52248c3b72797696bf06dcb"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class FunctionCallGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">FunctionCallGraph&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#6e95c76343bf40c6d438f41144073b39">copy</a> (const FunctionCallGraph &amp;src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a graph while filtering.  <a href="#6e95c76343bf40c6d438f41144073b39"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class FunctionCallGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#90912264c06269fdbee78f1399e6099b">copy</a> (const FunctionCallGraph &amp;src, FunctionCallGraph &amp;dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a graph while filtering.  <a href="#90912264c06269fdbee78f1399e6099b"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classBinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html">VertexFilter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#15c397e82988733b7c46d06448f12507">vertex_filter</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classBinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html">EdgeFilter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#bb01f23a6d097056b4503bf3246e5312">edge_filter</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html">EdgeFilter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Filter for edges.  <a href="classBinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html">VertexFilter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Filter for vertices.  <a href="classBinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html#_details">More...</a><br></td></tr>
</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="2532d28ee1226ae45fd43cc6c660ceac"></a><!-- doxytag: member="BinaryAnalysis::FunctionCall::Graph" ref="2532d28ee1226ae45fd43cc6c660ceac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::adjacency_list&lt;boost::setS, boost::vecS, boost::bidirectionalS, boost::property&lt;boost::vertex_name_t, <a class="el" href="classSgAsmFunction.html">SgAsmFunction</a>*&gt; &gt; <a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#2532d28ee1226ae45fd43cc6c660ceac">BinaryAnalysis::FunctionCall::Graph</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The default function call graph type. 
<p>
A function call graph is simply a Boost graph whose vertex descriptors are integers and whose vertices point to <a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> nodes in the AST (via the boost::vertex_name property). The graph edges represent function calls from one <a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> to another. Since this graph is a Boost graph, it is endowed with all the features of a Boost graph and can be the operand of the various Boost graph algorithms. See build_cg() for specifics about what is included in such a graph.<p>
Another way to represent function calls is to adapt a global control flow graph (BinaryAnalysis::ControlFlowGraph) to include only the edges (and their incident vertices) that flow from one function to another. The advantage of using a control flow graph to represent function call information is that each call site will be included in the function call graph due to the fact that the control flow graph vertices are blocks (<a class="el" href="classSgAsmBlock.html">SgAsmBlock</a>) rather than functions (<a class="el" href="classSgAsmFunction.html">SgAsmFunction</a>).<p>
It is common to need a type for the vertices and edges. Boost graphs store this information in graph_traits and users should use that to obtain those types. Doing so will, in the long run, make your code more extensible since the only datatype you're depending on is the graph itself--change the graph type and the vertex and edge types will automatically adjust. See Boost Graph Library documentation for all the available types. The most common are:<p>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> boost::graph_traits&lt;Graph&gt;::vertex_descriptor Vertex;
  <span class="keyword">typedef</span> boost::graph_traits&lt;Graph&gt;::edge_descriptor Edge;
</pre></div> 
<p>
Definition at line <a class="el" href="BinaryFunctionCall_8h-source.html#l00053">53</a> of file <a class="el" href="BinaryFunctionCall_8h-source.html">BinaryFunctionCall.h</a>.
</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="b4f7f47cc9da605adb5822828d9b545f"></a><!-- doxytag: member="BinaryAnalysis::FunctionCall::FunctionCall" ref="b4f7f47cc9da605adb5822828d9b545f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BinaryAnalysis::FunctionCall::FunctionCall           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="BinaryFunctionCall_8h-source.html#l00021">21</a> of file <a class="el" href="BinaryFunctionCall_8h-source.html">BinaryFunctionCall.h</a>.
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="2a2742416189f2254f44c6e9c9d2f6a8"></a><!-- doxytag: member="BinaryAnalysis::FunctionCall::set_vertex_filter" ref="2a2742416189f2254f44c6e9c9d2f6a8" args="(VertexFilter *filter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BinaryAnalysis::FunctionCall::set_vertex_filter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html">VertexFilter</a> *&nbsp;</td>
          <td class="paramname"> <em>filter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Manipulate the vertex filter. 
<p>
When building a function call graph, the vertex filter is invoked on each function which is about to be added as a vertex. If the filter returns false then that function is not added to the graph. A null filter accepts all vertices. 
<p>
Definition at line <a class="el" href="BinaryFunctionCall_8h-source.html#l00088">88</a> of file <a class="el" href="BinaryFunctionCall_8h-source.html">BinaryFunctionCall.h</a>.
<p>
References <a class="el" href="BinaryFunctionCall_8h-source.html#l00129">vertex_filter</a>.
</div>
</div><p>
<a class="anchor" name="24444c917456113162c36329f3927c4f"></a><!-- doxytag: member="BinaryAnalysis::FunctionCall::get_vertex_filter" ref="24444c917456113162c36329f3927c4f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html">VertexFilter</a>* BinaryAnalysis::FunctionCall::get_vertex_filter           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Manipulate the vertex filter. 
<p>
When building a function call graph, the vertex filter is invoked on each function which is about to be added as a vertex. If the filter returns false then that function is not added to the graph. A null filter accepts all vertices. 
<p>
Definition at line <a class="el" href="BinaryFunctionCall_8h-source.html#l00089">89</a> of file <a class="el" href="BinaryFunctionCall_8h-source.html">BinaryFunctionCall.h</a>.
<p>
References <a class="el" href="BinaryFunctionCall_8h-source.html#l00129">vertex_filter</a>.
</div>
</div><p>
<a class="anchor" name="45dbebd296a340cbd7c0fcba4a0bb9e1"></a><!-- doxytag: member="BinaryAnalysis::FunctionCall::set_edge_filter" ref="45dbebd296a340cbd7c0fcba4a0bb9e1" args="(EdgeFilter *filter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BinaryAnalysis::FunctionCall::set_edge_filter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html">EdgeFilter</a> *&nbsp;</td>
          <td class="paramname"> <em>filter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Manipulate the edge filter. 
<p>
When building a function call graph, the edge filter is invoked for each edge which is about to be added to the graph. If the filter returns false then that edge is not added to the graph. A null filter accepts all edges. 
<p>
Definition at line <a class="el" href="BinaryFunctionCall_8h-source.html#l00098">98</a> of file <a class="el" href="BinaryFunctionCall_8h-source.html">BinaryFunctionCall.h</a>.
<p>
References <a class="el" href="BinaryFunctionCall_8h-source.html#l00130">edge_filter</a>.
</div>
</div><p>
<a class="anchor" name="ef508972512bbc8ab37f859f918d6985"></a><!-- doxytag: member="BinaryAnalysis::FunctionCall::get_edge_filter" ref="ef508972512bbc8ab37f859f918d6985" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html">EdgeFilter</a>* BinaryAnalysis::FunctionCall::get_edge_filter           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Manipulate the edge filter. 
<p>
When building a function call graph, the edge filter is invoked for each edge which is about to be added to the graph. If the filter returns false then that edge is not added to the graph. A null filter accepts all edges. 
<p>
Definition at line <a class="el" href="BinaryFunctionCall_8h-source.html#l00099">99</a> of file <a class="el" href="BinaryFunctionCall_8h-source.html">BinaryFunctionCall.h</a>.
<p>
References <a class="el" href="BinaryFunctionCall_8h-source.html#l00130">edge_filter</a>.
</div>
</div><p>
<a class="anchor" name="a59d513bee13e8339937d35517b018a3"></a><!-- doxytag: member="BinaryAnalysis::FunctionCall::is_vertex_filtered" ref="a59d513bee13e8339937d35517b018a3" args="(SgAsmFunction *func, VertexFilter *filter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BinaryAnalysis::FunctionCall::is_vertex_filtered           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html">VertexFilter</a> *&nbsp;</td>
          <td class="paramname"> <em>filter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if a vertex is filtered out. 
<p>
Returns true if the vertex would be filtered out by being rejected by the current vertex filter. 
<p>
Definition at line <a class="el" href="BinaryFunctionCall_8h-source.html#l00107">107</a> of file <a class="el" href="BinaryFunctionCall_8h-source.html">BinaryFunctionCall.h</a>.
<p>
Referenced by <a class="el" href="BinaryFunctionCall_8h-source.html#l00305">build_cg_from_ast()</a>, <a class="el" href="BinaryFunctionCall_8h-source.html#l00250">build_cg_from_cfg()</a>, <a class="el" href="BinaryFunctionCall_8h-source.html#l00238">cache_vertex_descriptors()</a>, <a class="el" href="BinaryFunctionCall_8h-source.html#l00380">copy()</a>, and <a class="el" href="BinaryFunctionCall_8h-source.html#l00110">is_vertex_filtered()</a>.
</div>
</div><p>
<a class="anchor" name="e236e4da49ba54eb2368913967ec9dcd"></a><!-- doxytag: member="BinaryAnalysis::FunctionCall::is_vertex_filtered" ref="e236e4da49ba54eb2368913967ec9dcd" args="(SgAsmFunction *func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BinaryAnalysis::FunctionCall::is_vertex_filtered           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if a vertex is filtered out. 
<p>
Returns true if the vertex would be filtered out by being rejected by the current vertex filter. 
<p>
Definition at line <a class="el" href="BinaryFunctionCall_8h-source.html#l00110">110</a> of file <a class="el" href="BinaryFunctionCall_8h-source.html">BinaryFunctionCall.h</a>.
<p>
References <a class="el" href="BinaryFunctionCall_8h-source.html#l00107">is_vertex_filtered()</a>, and <a class="el" href="BinaryFunctionCall_8h-source.html#l00129">vertex_filter</a>.
</div>
</div><p>
<a class="anchor" name="3db7e3b728529310098bc4218b618a80"></a><!-- doxytag: member="BinaryAnalysis::FunctionCall::is_edge_filtered" ref="3db7e3b728529310098bc4218b618a80" args="(SgAsmFunction *src, SgAsmFunction *dst, EdgeFilter *filter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BinaryAnalysis::FunctionCall::is_edge_filtered           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html">EdgeFilter</a> *&nbsp;</td>
          <td class="paramname"> <em>filter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if an edge is filtered out. 
<p>
Returns true if the edge would be filtered out by being rejected by the current edge filter. 
<p>
Definition at line <a class="el" href="BinaryFunctionCall_8h-source.html#l00120">120</a> of file <a class="el" href="BinaryFunctionCall_8h-source.html">BinaryFunctionCall.h</a>.
<p>
Referenced by <a class="el" href="BinaryFunctionCall_8h-source.html#l00305">build_cg_from_ast()</a>, <a class="el" href="BinaryFunctionCall_8h-source.html#l00250">build_cg_from_cfg()</a>, <a class="el" href="BinaryFunctionCall_8h-source.html#l00380">copy()</a>, and <a class="el" href="BinaryFunctionCall_8h-source.html#l00123">is_edge_filtered()</a>.
</div>
</div><p>
<a class="anchor" name="7e553622e6f012bfbee95a3e2f36b6ed"></a><!-- doxytag: member="BinaryAnalysis::FunctionCall::is_edge_filtered" ref="7e553622e6f012bfbee95a3e2f36b6ed" args="(SgAsmFunction *src, SgAsmFunction *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BinaryAnalysis::FunctionCall::is_edge_filtered           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if an edge is filtered out. 
<p>
Returns true if the edge would be filtered out by being rejected by the current edge filter. 
<p>
Definition at line <a class="el" href="BinaryFunctionCall_8h-source.html#l00123">123</a> of file <a class="el" href="BinaryFunctionCall_8h-source.html">BinaryFunctionCall.h</a>.
<p>
References <a class="el" href="BinaryFunctionCall_8h-source.html#l00130">edge_filter</a>, and <a class="el" href="BinaryFunctionCall_8h-source.html#l00120">is_edge_filtered()</a>.
</div>
</div><p>
<a class="anchor" name="2eba696d163fb97e4e08d26c62f92649"></a><!-- doxytag: member="BinaryAnalysis::FunctionCall::cache_vertex_descriptors" ref="2eba696d163fb97e4e08d26c62f92649" args="(const FunctionCallGraph &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionCallGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BinaryAnalysis::FunctionCall::cache_vertex_descriptors           </td>
          <td>(</td>
          <td class="paramtype">const FunctionCallGraph &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cache vertex descriptors in AST. 
<p>
The vertices of a function call graph are of type <a class="el" href="structVertex.html">Vertex</a>, and point at the functions (<a class="el" href="classSgAsmFunction.html">SgAsmFunction</a>) of the AST. Although most graph algorithms will only need to map <a class="el" href="structVertex.html">Vertex</a> to <a class="el" href="classSgAsmFunction.html">SgAsmFunction</a>, the inverse mapping is also sometimes useful. That mapping can be stored into an std::map via graph traversal, or stored in the AST itself attached to each <a class="el" href="classSgAsmFunction.html">SgAsmFunction</a>. Using an std::map requires an O(log N) lookup each time we need to get the vertex descriptor for a function, while storing the vertex descriptor in the AST requires O(1) lookup time.<p>
The vertex descriptors are available via <a class="el" href="classSgAsmFunction.html#49ea14c759abf045101dfc50de38f730">SgAsmFunction::get_cached_vertex()</a>. Other graph types (e.g., dominance graphs) might also use the same cache line. The cached vertex is stored as a size_t, which is the same underlying type for function call graph vertices.<p>
The current vertex filter determines which function nodes are modified. 
<p>
Definition at line <a class="el" href="BinaryFunctionCall_8h-source.html#l00238">238</a> of file <a class="el" href="BinaryFunctionCall_8h-source.html">BinaryFunctionCall.h</a>.
<p>
References <a class="el" href="BinaryFunctionCall_8h-source.html#l00107">is_vertex_filtered()</a>.
</div>
</div><p>
<a class="anchor" name="ccf917f4d9602275b854cc1cf0e2bf48"></a><!-- doxytag: member="BinaryAnalysis::FunctionCall::build_cg_from_cfg" ref="ccf917f4d9602275b854cc1cf0e2bf48" args="(const ControlFlowGraph &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionCallGraph, class ControlFlowGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FunctionCallGraph BinaryAnalysis::FunctionCall::build_cg_from_cfg           </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Build a function call graph from a control flow graph. 
<p>
Given a control flow graph (CFG) spanning multiple functions, create a function call graph (CG) by collapsing vertices in the CFG that belong to a common function. Any resulting self-loop edges will be removed unless the target of the corresponding edge in the CFG was the function entry block (i.e., intra-function CFG edges whose target is the function's entry block are assumed to be recursive calls, while all other intra-function CFG edges are omitted from the CG).<p>
The current vertex and edge filters are used to restrict which functions and calls make it into the graph. 
<p>
Definition at line <a class="el" href="BinaryFunctionCall_8h-source.html#l00296">296</a> of file <a class="el" href="BinaryFunctionCall_8h-source.html">BinaryFunctionCall.h</a>.
</div>
</div><p>
<a class="anchor" name="c878096df46fe62d3a8f7e05aa0c42cd"></a><!-- doxytag: member="BinaryAnalysis::FunctionCall::build_cg_from_cfg" ref="c878096df46fe62d3a8f7e05aa0c42cd" args="(const ControlFlowGraph &amp;cfg, FunctionCallGraph &amp;cg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph, class FunctionCallGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BinaryAnalysis::FunctionCall::build_cg_from_cfg           </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionCallGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Build a function call graph from a control flow graph. 
<p>
Given a control flow graph (CFG) spanning multiple functions, create a function call graph (CG) by collapsing vertices in the CFG that belong to a common function. Any resulting self-loop edges will be removed unless the target of the corresponding edge in the CFG was the function entry block (i.e., intra-function CFG edges whose target is the function's entry block are assumed to be recursive calls, while all other intra-function CFG edges are omitted from the CG).<p>
The current vertex and edge filters are used to restrict which functions and calls make it into the graph. 
<p>
Definition at line <a class="el" href="BinaryFunctionCall_8h-source.html#l00250">250</a> of file <a class="el" href="BinaryFunctionCall_8h-source.html">BinaryFunctionCall.h</a>.
<p>
References <a class="el" href="classSgAsmBlock.html#bdd6257d93832cc2b0dcbdf07f9ccd3c">SgAsmBlock::get_enclosing_function()</a>, <a class="el" href="SgAsmFunction_8C-source.html#l00192">SgAsmFunction::get_entry_block()</a>, <a class="el" href="BinaryFunctionCall_8h-source.html#l00120">is_edge_filtered()</a>, and <a class="el" href="BinaryFunctionCall_8h-source.html#l00107">is_vertex_filtered()</a>.
</div>
</div><p>
<a class="anchor" name="0a66374f57c8167400aeca97cfe83854"></a><!-- doxytag: member="BinaryAnalysis::FunctionCall::build_cg_from_ast" ref="0a66374f57c8167400aeca97cfe83854" args="(SgNode *root)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionCallGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FunctionCallGraph BinaryAnalysis::FunctionCall::build_cg_from_ast           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Build a function call graph from an AST. 
<p>
Given an AST, traverse the AST beginning at <code>root</code> and build a function call graph (CG). The function call graph will contain only <a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> vertices that are in the specified subtree and which are not filtered out by the current vertex filter. Edges also must pass the edge filter to be included in the graph.<p>
The following two methods of constructing a CG should result in identical graphs (although vertex and edge order may be different):<p>
<div class="fragment"><pre class="fragment">  <span class="keyword">using namespace </span>BinaryAnalysis;
  <span class="keyword">typedef</span> <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#2532d28ee1226ae45fd43cc6c660ceac">FunctionCall::Graph</a> CG;
  <span class="keyword">typedef</span> <a class="code" href="classBinaryAnalysis_1_1ControlFlow.html#d704a3d62401287d23f40c0aed8b70e8">ControlFlow::Graph</a>  CFG;
  <a class="code" href="classSgAsmNode.html">SgAsmNode</a> *node = ...;

  <span class="comment">// Method 1</span>
  CG cg1 = <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#b4f7f47cc9da605adb5822828d9b545f">FunctionCall</a>().build_cg_from_ast(node);

  <span class="comment">// Method 2</span>
  CFG cfg = ControlFlow().build_cfg_from_ast&lt;CFG&gt;(node);
  CG cg2 = <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#b4f7f47cc9da605adb5822828d9b545f">FunctionCall</a>().build_cg_from_cfg&lt;CG&gt;(cfg);
</pre></div><p>
In general, building the function call graph directly from the AST will be faster than first building the control flow graph. 
<p>
Definition at line <a class="el" href="BinaryFunctionCall_8h-source.html#l00371">371</a> of file <a class="el" href="BinaryFunctionCall_8h-source.html">BinaryFunctionCall.h</a>.
</div>
</div><p>
<a class="anchor" name="45bddd25d52248c3b72797696bf06dcb"></a><!-- doxytag: member="BinaryAnalysis::FunctionCall::build_cg_from_ast" ref="45bddd25d52248c3b72797696bf06dcb" args="(SgNode *root, FunctionCallGraph &amp;cg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionCallGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BinaryAnalysis::FunctionCall::build_cg_from_ast           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionCallGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Build a function call graph from an AST. 
<p>
Given an AST, traverse the AST beginning at <code>root</code> and build a function call graph (CG). The function call graph will contain only <a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> vertices that are in the specified subtree and which are not filtered out by the current vertex filter. Edges also must pass the edge filter to be included in the graph.<p>
The following two methods of constructing a CG should result in identical graphs (although vertex and edge order may be different):<p>
<div class="fragment"><pre class="fragment">  <span class="keyword">using namespace </span>BinaryAnalysis;
  <span class="keyword">typedef</span> <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#2532d28ee1226ae45fd43cc6c660ceac">FunctionCall::Graph</a> CG;
  <span class="keyword">typedef</span> <a class="code" href="classBinaryAnalysis_1_1ControlFlow.html#d704a3d62401287d23f40c0aed8b70e8">ControlFlow::Graph</a>  CFG;
  <a class="code" href="classSgAsmNode.html">SgAsmNode</a> *node = ...;

  <span class="comment">// Method 1</span>
  CG cg1 = <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#b4f7f47cc9da605adb5822828d9b545f">FunctionCall</a>().build_cg_from_ast(node);

  <span class="comment">// Method 2</span>
  CFG cfg = ControlFlow().build_cfg_from_ast&lt;CFG&gt;(node);
  CG cg2 = <a class="code" href="classBinaryAnalysis_1_1FunctionCall.html#b4f7f47cc9da605adb5822828d9b545f">FunctionCall</a>().build_cg_from_cfg&lt;CG&gt;(cfg);
</pre></div><p>
In general, building the function call graph directly from the AST will be faster than first building the control flow graph. 
<p>
Definition at line <a class="el" href="BinaryFunctionCall_8h-source.html#l00305">305</a> of file <a class="el" href="BinaryFunctionCall_8h-source.html">BinaryFunctionCall.h</a>.
<p>
References <a class="el" href="classSgAsmBlock.html#bdd6257d93832cc2b0dcbdf07f9ccd3c">SgAsmBlock::get_enclosing_function()</a>, <a class="el" href="SgAsmFunction_8C-source.html#l00192">SgAsmFunction::get_entry_block()</a>, <a class="el" href="classSgAsmBlock.html#0e798d793c22e6d6a63a526b6a18e7ce">SgAsmBlock::get_successors()</a>, <a class="el" href="BinaryFunctionCall_8h-source.html#l00120">is_edge_filtered()</a>, <a class="el" href="BinaryFunctionCall_8h-source.html#l00107">is_vertex_filtered()</a>, <a class="el" href="Cxx__Grammar_8h.html#0f21c6b7a4aede1900e16a5122233a83">isSgAsmBlock()</a>, <a class="el" href="Cxx__Grammar_8h.html#3374b86a87959b6a02d8ca8f792d693e">isSgAsmFunction()</a>, and <a class="el" href="Cxx__Grammar_8h.html#59f7fee88581c4dd75f5fb25dbefa29edefb5d09673c144dc5b4dc177e278696">preorder</a>.
</div>
</div><p>
<a class="anchor" name="6e95c76343bf40c6d438f41144073b39"></a><!-- doxytag: member="BinaryAnalysis::FunctionCall::copy" ref="6e95c76343bf40c6d438f41144073b39" args="(const FunctionCallGraph &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionCallGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FunctionCallGraph BinaryAnalysis::FunctionCall::copy           </td>
          <td>(</td>
          <td class="paramtype">const FunctionCallGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies a graph while filtering. 
<p>
Copies a graph while applying the current source and destination vertex and edge filters. If all vertices are selected by the vertex filter, then the desintation graph's vertex descriptors will correspond to the same vertices in the source graph (i.e., vertex V in the source will be the same basic block as vertex V in the destination).<p>
If an edge is unfiltered but one of its vertices is filtered, then the edge will not be included in the result. 
<p>
Definition at line <a class="el" href="BinaryFunctionCall_8h-source.html#l00410">410</a> of file <a class="el" href="BinaryFunctionCall_8h-source.html">BinaryFunctionCall.h</a>.
</div>
</div><p>
<a class="anchor" name="90912264c06269fdbee78f1399e6099b"></a><!-- doxytag: member="BinaryAnalysis::FunctionCall::copy" ref="90912264c06269fdbee78f1399e6099b" args="(const FunctionCallGraph &amp;src, FunctionCallGraph &amp;dst)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionCallGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BinaryAnalysis::FunctionCall::copy           </td>
          <td>(</td>
          <td class="paramtype">const FunctionCallGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionCallGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies a graph while filtering. 
<p>
Copies a graph while applying the current source and destination vertex and edge filters. If all vertices are selected by the vertex filter, then the desintation graph's vertex descriptors will correspond to the same vertices in the source graph (i.e., vertex V in the source will be the same basic block as vertex V in the destination).<p>
If an edge is unfiltered but one of its vertices is filtered, then the edge will not be included in the result. 
<p>
Definition at line <a class="el" href="BinaryFunctionCall_8h-source.html#l00380">380</a> of file <a class="el" href="BinaryFunctionCall_8h-source.html">BinaryFunctionCall.h</a>.
<p>
References <a class="el" href="BinaryFunctionCall_8h-source.html#l00120">is_edge_filtered()</a>, and <a class="el" href="BinaryFunctionCall_8h-source.html#l00107">is_vertex_filtered()</a>.
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="15c397e82988733b7c46d06448f12507"></a><!-- doxytag: member="BinaryAnalysis::FunctionCall::vertex_filter" ref="15c397e82988733b7c46d06448f12507" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBinaryAnalysis_1_1FunctionCall_1_1VertexFilter.html">VertexFilter</a>* <a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#15c397e82988733b7c46d06448f12507">BinaryAnalysis::FunctionCall::vertex_filter</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="BinaryFunctionCall_8h-source.html#l00129">129</a> of file <a class="el" href="BinaryFunctionCall_8h-source.html">BinaryFunctionCall.h</a>.
<p>
Referenced by <a class="el" href="BinaryFunctionCall_8h-source.html#l00089">get_vertex_filter()</a>, <a class="el" href="BinaryFunctionCall_8h-source.html#l00110">is_vertex_filtered()</a>, and <a class="el" href="BinaryFunctionCall_8h-source.html#l00088">set_vertex_filter()</a>.
</div>
</div><p>
<a class="anchor" name="bb01f23a6d097056b4503bf3246e5312"></a><!-- doxytag: member="BinaryAnalysis::FunctionCall::edge_filter" ref="bb01f23a6d097056b4503bf3246e5312" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBinaryAnalysis_1_1FunctionCall_1_1EdgeFilter.html">EdgeFilter</a>* <a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#bb01f23a6d097056b4503bf3246e5312">BinaryAnalysis::FunctionCall::edge_filter</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="BinaryFunctionCall_8h-source.html#l00130">130</a> of file <a class="el" href="BinaryFunctionCall_8h-source.html">BinaryFunctionCall.h</a>.
<p>
Referenced by <a class="el" href="BinaryFunctionCall_8h-source.html#l00099">get_edge_filter()</a>, <a class="el" href="BinaryFunctionCall_8h-source.html#l00123">is_edge_filtered()</a>, and <a class="el" href="BinaryFunctionCall_8h-source.html#l00098">set_edge_filter()</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="BinaryFunctionCall_8h-source.html">BinaryFunctionCall.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
