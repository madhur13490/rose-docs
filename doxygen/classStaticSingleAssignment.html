<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: StaticSingleAssignment Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>StaticSingleAssignment Class Reference</h1><!-- doxytag: class="StaticSingleAssignment" --><code>#include &lt;<a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a>&gt;</code>
<p>
Collaboration diagram for StaticSingleAssignment:<p><center><img src="classStaticSingleAssignment__coll__graph.png" border="0" usemap="#StaticSingleAssignment__coll__map" alt="Collaboration graph"></center>
<map name="StaticSingleAssignment__coll__map">
<area href="classSgProject.html" shape="rect" coords="299,369,379,396" alt="">
<area href="classSgSupport.html" shape="rect" coords="296,92,381,119" alt="">
<area href="classSgFileList.html" shape="rect" coords="224,188,301,215" alt="">
<area href="classSgDirectoryList.html" shape="rect" coords="376,188,493,215" alt="">
<area href="classSgNode.html" shape="rect" coords="304,9,373,36" alt="">
<area href="classAstAttributeMechanism.html" shape="rect" coords="5,92,171,119" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classStaticSingleAssignment-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Static single assignment analysis. 
<p>
Contains all the functionality to implement variable renaming on a given program. For this class, we do not actually transform the AST directly, rather we perform the analysis and add attributes to the AST nodes so that later optimizations can access the results of this analysis while still preserving the original AST. 
<p>

<p>
Definition at line <a class="el" href="staticSingleAssignment_8h-source.html#l00062">62</a> of file <a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a>.<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::vector&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A compound variable name as used by the variable renaming.  <a href="#c331e1110ecdbb40e8efee09b0284862"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef boost::unordered_map&lt;<br>
 <a class="el" href="classSgNode.html">SgNode</a> *, std::set&lt; <a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#dcb347322834917dd31dd57af44001f8">LocalDefUseTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes the defs or uses at each node.  <a href="#dcb347322834917dd31dd57af44001f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef FilteredCFGNode&lt; <a class="el" href="structssa__private_1_1DataflowCfgFilter.html">ssa_private::DataflowCfgFilter</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#c26931d0a5d15d7f85913020563f9dd7">FilteredCfgNode</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A filtered CFGNode that is used for DefUse traversal.  <a href="#c26931d0a5d15d7f85913020563f9dd7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef FilteredCFGEdge&lt; <a class="el" href="structssa__private_1_1DataflowCfgFilter.html">ssa_private::DataflowCfgFilter</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#aff056020ff2698604fdec2296405e8b">FilteredCfgEdge</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A filtered CFGEdge that is used for DefUse traversal.  <a href="#aff056020ff2698604fdec2296405e8b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef boost::shared_ptr&lt;<br>
 <a class="el" href="classReachingDef.html">ReachingDef</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#75967eb37074af951e85ad1142755b08">ReachingDefPtr</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map&lt; <a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a>,<br>
 <a class="el" href="classStaticSingleAssignment.html#75967eb37074af951e85ad1142755b08">ReachingDefPtr</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#a867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A map from each variable to its reaching definitions at the current node.  <a href="#a867994c56b8018439d2cc95d8ef4981"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef boost::unordered_map&lt;<br>
 <a class="el" href="classSgNode.html">SgNode</a> *, std::pair&lt; <a class="el" href="classStaticSingleAssignment.html#a867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a>,<br>
 <a class="el" href="classStaticSingleAssignment.html#a867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#aa29c315fbca6973d875f6832b62589f">GlobalReachingDefTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The first table is the IN table.  <a href="#aa29c315fbca6973d875f6832b62589f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef boost::unordered_map&lt;<br>
 <a class="el" href="classSgNode.html">SgNode</a> *, <a class="el" href="classStaticSingleAssignment.html#a867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#b9b42c79b83b951b9e29efc06a4e3bdb">UseTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Map from each node to the variables used at that node and their reaching definitions.  <a href="#b9b42c79b83b951b9e29efc06a4e3bdb"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#e66caa726cd1fd2741b71e015f383d55">StaticSingleAssignment</a> (<a class="el" href="classSgProject.html">SgProject</a> *proj)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#cdda8f8344e1c5a4f1e23e0f6ad173d3">~StaticSingleAssignment</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#7340f93af9c35d8231170dac4fdea47c">run</a> (bool interprocedural, bool treatPointersAsStructures)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Run the analysis.  <a href="#7340f93af9c35d8231170dac4fdea47c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#e22322f55e06b7df73fb590f0f748020">toDOT</a> (const std::string fileName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the CFG with any UniqueNames and Def/Use information visible.  <a href="#e22322f55e06b7df73fb590f0f748020"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#9774845d765b66e68b9016666f75cbaa">toFilteredDOT</a> (const std::string fileName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the CFG with any UniqueNames and Def/Use information visible.  <a href="#9774845d765b66e68b9016666f75cbaa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#e89656a0ff151efb144bd571106b0fb8">printOriginalDefs</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#9c2b0e5f5ed7a787a417a72097b5a732">printOriginalDefTable</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classStaticSingleAssignment.html#dcb347322834917dd31dd57af44001f8">LocalDefUseTable</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#9a73c5246f974e2a72e9df0fa25ebf9a">getOriginalDefTable</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the table of definitions for every node.  <a href="#9a73c5246f974e2a72e9df0fa25ebf9a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classStaticSingleAssignment.html#dcb347322834917dd31dd57af44001f8">LocalDefUseTable</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#8ab457322cb1f1c3031b82b9643f8b4f">getLocalUsesTable</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classStaticSingleAssignment.html#a867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#853bab80f278d557c92db0400df7409f">getOutgoingDefsAtNode</a> (<a class="el" href="classSgNode.html">SgNode</a> *node) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the definitions of all the variables right after the given node has executed.  <a href="#853bab80f278d557c92db0400df7409f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classStaticSingleAssignment.html#a867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#a8b248494b33c1373f903024cfed339b">getReachingDefsAtNode_</a> (<a class="el" href="classSgNode.html">SgNode</a> *node) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the definitions of all the variables immediately before the given node has executed.  <a href="#a8b248494b33c1373f903024cfed339b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classStaticSingleAssignment.html#a867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#1087b908d1defc3a747f757d5a84e1c4">getUsesAtNode</a> (<a class="el" href="classSgNode.html">SgNode</a> *node) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a list of all the variables used at this node.  <a href="#1087b908d1defc3a747f757d5a84e1c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classStaticSingleAssignment.html#a867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#aafe1b2e6f1af07bfb9a24b9785a9277">getDefsAtNode</a> (<a class="el" href="classSgNode.html">SgNode</a> *node) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a list of all the variables defined at the given node.  <a href="#aafe1b2e6f1af07bfb9a24b9785a9277"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::set&lt; <a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#0d107f4b5123d0b4f6540018dbba1c3b">getVarsUsedInSubtree</a> (<a class="el" href="classSgNode.html">SgNode</a> *root) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a set of all the variables names that have uses in the subtree.  <a href="#0d107f4b5123d0b4f6540018dbba1c3b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::set&lt; <a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#bd440e6d324ba45a9d0efa856f943584">getVarsDefinedInSubtree</a> (<a class="el" href="classSgNode.html">SgNode</a> *root) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a node, traverses all its children in the AST and collects all the variable names that have definitions in the subtree.  <a href="#bd440e6d324ba45a9d0efa856f943584"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::set&lt; <a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#03e2cec7e7e71270d955d9eee8cd666b">getOriginalVarsDefinedInSubtree</a> (<a class="el" href="classSgNode.html">SgNode</a> *root) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a node, traverses all its children in the AST and collects all the variable names that have original definitions in the subtree.  <a href="#03e2cec7e7e71270d955d9eee8cd666b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classStaticSingleAssignment.html#a867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#b11cdbbac55303995df15578ac0b3e29">getLastVersions</a> (<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *func) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the last encountered definition of every variable.  <a href="#b11cdbbac55303995df15578ac0b3e29"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#8d0b08bd7c2d47df3f932e4f9730ef4a">getDebug</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#8c2fb246c830ac4f68a16f64d7b50f6b">getDebugExtra</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#d431a7db92fca6b44e362d4a4cc380c4">isPrefixOfName</a> (<a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a> name, <a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a> prefix)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find if the given prefix is a prefix of the given name.  <a href="#d431a7db92fca6b44e362d4a4cc380c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classssa__private_1_1VarUniqueName.html">ssa_private::VarUniqueName</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#35267ee8644b19fca8cc573649fbb24b">getUniqueName</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the uniqueName attribute for the given node.  <a href="#35267ee8644b19fca8cc573649fbb24b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#976474bbfc0366540c0ca8ef0dab77d3">getVarName</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the variable name of the given node.  <a href="#976474bbfc0366540c0ca8ef0dab77d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#c0e4b36e017885f616cd6b391c5205f8">getVarForExpression</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If an expression evaluates to a reference of a variable, returns that variable.  <a href="#c0e4b36e017885f616cd6b391c5205f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#28ce0ed01016c6dea58c6be900d95d63">buildVariableReference</a> (const <a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a> &amp;var, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an AST fragment containing the appropriate varRefs and Dot/Arrow ops to access the given variable.  <a href="#28ce0ed01016c6dea58c6be900d95d63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#25e6ba89f1da6252d4518d73d091e4be">isVarInScope</a> (const <a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a> &amp;var, <a class="el" href="classSgNode.html">SgNode</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the scope of the given node, and returns true if the given variable is accessible there.  <a href="#25e6ba89f1da6252d4518d73d091e4be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#019e51da21fd909ef647f9692239751c">varnameToString</a> (const <a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a> &amp;vec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a string representation of a varName.  <a href="#019e51da21fd909ef647f9692239751c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#e782076117cc18412c3f276bd144ef33">printLocalDefUseTable</a> (const <a class="el" href="classStaticSingleAssignment.html#dcb347322834917dd31dd57af44001f8">LocalDefUseTable</a> &amp;table)</td></tr>

<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#56caa76396dd2ecaa37fddfbd441c228">emptyName</a></td></tr>

<tr><td colspan="2"><br><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#d1d5433e9310116529ac02f6c64e9ef3">runDefUseDataFlow</a> (<a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *func)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Once all the local definitions have been inserted in the ssaLocalDefsTable and phi functions have been inserted in the reaching defs table, propagate reaching definitions along the CFG.  <a href="#d1d5433e9310116529ac02f6c64e9ef3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#2a9cca75f429b64de3e0b65b9e9f157d">expandParentMemberDefinitions</a> (<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *function)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expand all member definitions (chained names) to define every name in the chain that is shorter than the originally defined name.  <a href="#2a9cca75f429b64de3e0b65b9e9f157d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#d798ae59ee10d220e1ca0abae690f238">expandParentMemberUses</a> (<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *function)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expand all member uses (chained names) to explicitly use every name in the chain that is a parent of the original use.  <a href="#d798ae59ee10d220e1ca0abae690f238"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#9ce45bb0b0c6cfa042c5a2999e7e0da0">insertDefsForChildMemberUses</a> (<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *function)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find all uses of compound variable names and insert expanded defs for them when their parents are defined.  <a href="#9ce45bb0b0c6cfa042c5a2999e7e0da0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#ea6d87a4babc43025e25987e58556670">insertDefsForExternalVariables</a> (<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *function)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert defs for functions that are declared outside the function scope.  <a href="#ea6d87a4babc43025e25987e58556670"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::multimap&lt; <a class="el" href="classStaticSingleAssignment.html#c26931d0a5d15d7f85913020563f9dd7">FilteredCfgNode</a>,<br>
 std::pair&lt; <a class="el" href="classStaticSingleAssignment.html#c26931d0a5d15d7f85913020563f9dd7">FilteredCfgNode</a>,<br>
 <a class="el" href="classStaticSingleAssignment.html#aff056020ff2698604fdec2296405e8b">FilteredCfgEdge</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#420e77b0306b73bf4c6372ae4f2cb84b">insertPhiFunctions</a> (<a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *function, const std::vector&lt; <a class="el" href="classStaticSingleAssignment.html#c26931d0a5d15d7f85913020563f9dd7">FilteredCfgNode</a> &gt; &amp;cfgNodesInPostOrder)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find where phi functions need to be inserted and insert empty phi functions at those nodes.  <a href="#420e77b0306b73bf4c6372ae4f2cb84b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#c9437742c77e4c305e45f81eeb4f25ae">populateLocalDefsTable</a> (<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *function)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create <a class="el" href="classReachingDef.html">ReachingDef</a> objects for each local def and insert them in the local def table.  <a href="#c9437742c77e4c305e45f81eeb4f25ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#47ef818b8f7792803415e451cd18547a">renumberAllDefinitions</a> (<a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *func, const std::vector&lt; <a class="el" href="classStaticSingleAssignment.html#c26931d0a5d15d7f85913020563f9dd7">FilteredCfgNode</a> &gt; &amp;cfgNodesInPostOrder)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Give numbers to all the reachingDef objects.  <a href="#47ef818b8f7792803415e451cd18547a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#06ba62b7680b0088f59439bf77ea88fa">updateIncomingPropagatedDefs</a> (<a class="el" href="classStaticSingleAssignment.html#c26931d0a5d15d7f85913020563f9dd7">FilteredCfgNode</a> cfgNode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take all the outgoing defs from previous nodes and merge them as the incoming defs of the current node.  <a href="#06ba62b7680b0088f59439bf77ea88fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#ec6aa55b711256c80e9d3e585479bf2c">propagateDefs</a> (<a class="el" href="classStaticSingleAssignment.html#c26931d0a5d15d7f85913020563f9dd7">FilteredCfgNode</a> cfgNode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs the data-flow update for one individual node, populating the reachingDefsTable for that node.  <a href="#ec6aa55b711256c80e9d3e585479bf2c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#e4bc850d4513744e799b1bb4e2f170bc">buildUseTable</a> (const std::vector&lt; <a class="el" href="classStaticSingleAssignment.html#c26931d0a5d15d7f85913020563f9dd7">FilteredCfgNode</a> &gt; &amp;cfgNodes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Once all the reaching def information has been propagated, uses the reaching def information and the local use information to match uses to their reaching defs.  <a href="#e4bc850d4513744e799b1bb4e2f170bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#56aa2bd82684a775a45fcf0bc04393b3">interproceduralDefPropagation</a> (const boost::unordered_set&lt; <a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> * &gt; &amp;interestingFunctions)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert definitions at function call sites for all variables defined interprocedurally.  <a href="#56aa2bd82684a775a45fcf0bc04393b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#673505410a5c884638b9c64d6bcc847e">calculateInterproceduralProcessingOrder</a> (const boost::unordered_set&lt; <a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> * &gt; &amp;interestingFunctions)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function returns the order in which functions should be processed so that callees are processed before callers whenever possible (this is sometimes not possible due to recursion).  <a href="#673505410a5c884638b9c64d6bcc847e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#3403440d64195cd2bfac0b92809870cf">processCalleesThenFunction</a> (<a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *targetFunction, <a class="el" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a> *callGraph, const boost::unordered_map&lt; <a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *, <a class="el" href="classSgGraphNode.html">SgGraphNode</a> * &gt; &amp;graphNodeToFunction, std::vector&lt; <a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> * &gt; &amp;processingOrder, std::set&lt; <a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> * &gt; visited)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add all the callees of the function to the processing list, then add the function itself.  <a href="#3403440d64195cd2bfac0b92809870cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#d8fd7953a095b2461471471ff3f4583d">insertInterproceduralDefs</a> (<a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *funcDef, const boost::unordered_set&lt; <a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> * &gt; &amp;processed, <a class="el" href="classClassHierarchyWrapper.html">ClassHierarchyWrapper</a> *classHierarchy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add definitions at function call expressions for variables that are modified interprocedurally.  <a href="#d8fd7953a095b2461471471ff3f4583d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#c2d58e6811de33364457696ce6c5e64c">processOneCallSite</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *callSite, <a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *callee, const boost::unordered_set&lt; <a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> * &gt; &amp;processed, <a class="el" href="classClassHierarchyWrapper.html">ClassHierarchyWrapper</a> *classHierarchy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert the interprocedural defs at a particular call site for a particular callee.  <a href="#c2d58e6811de33364457696ce6c5e64c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#45bd85ed0407c2e82c71f2287bb74457">printToDOT</a> (<a class="el" href="classSgSourceFile.html">SgSourceFile</a> *file, std::ofstream &amp;outFile)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#23a22b17aecbe0ddf07d99ecdc36360e">printToFilteredDOT</a> (<a class="el" href="classSgSourceFile.html">SgSourceFile</a> *file, std::ofstream &amp;outFile)</td></tr>

<tr><td colspan="2"><br><h2>Static Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#41200ad359c912b48caeb80a808024bf">isBuiltinVar</a> (const <a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a> &amp;var)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the variable is implicitly defined at the function entry by the compiler.  <a href="#41200ad359c912b48caeb80a808024bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static std::vector&lt; <a class="el" href="classStaticSingleAssignment.html#c26931d0a5d15d7f85913020563f9dd7">FilteredCfgNode</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#cbe63acd025b03fe95dc5030ad2dbc04">getCfgNodesInPostorder</a> (<a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *func)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterates all the CFG nodes in the function and returns them in postorder, according to depth-first search.  <a href="#cbe63acd025b03fe95dc5030ad2dbc04"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#e49a10f4288e22d2ed15a059390d0801">isVarAccessibleFromCaller</a> (const <a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a> &amp;var, <a class="el" href="classSgExpression.html">SgExpression</a> *callSite, <a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *callee)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a variable that is in a callee's scope, returns true if the caller can access the same variable, false otherwise.  <a href="#e49a10f4288e22d2ed15a059390d0801"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#8963e1d352848745110ef17498b41060">varRequiresThisPointer</a> (const <a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a> &amp;var)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the variable is a nonstatic class variable, so it hass to be accessed by the "this" pointer.  <a href="#8963e1d352848745110ef17498b41060"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#12d75a2881cc1716dbefe3f06fe0cb0d">isThisPointerSameInCallee</a> (<a class="el" href="classSgFunctionCallExp.html">SgFunctionCallExp</a> *callSite, <a class="el" href="classSgMemberFunctionDeclaration.html">SgMemberFunctionDeclaration</a> *callee)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the callee is acting on the same object instance as the caller.  <a href="#12d75a2881cc1716dbefe3f06fe0cb0d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#e0a3c3b0fe34ea42a5ffe9c34c13a564">isThisPointer</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *expression)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true of the given expression evaluates to the 'this' pointer.  <a href="#e0a3c3b0fe34ea42a5ffe9c34c13a564"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#a0349aec0508b35e369469073e064cc4">isDeepConstPointer</a> (<a class="el" href="classSgType.html">SgType</a> *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if the type is a const pointer pointing to a const object.  <a href="#a0349aec0508b35e369469073e064cc4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#dec244e853684b8fd4d1e65a48cbdd74">isPointerToDeepConst</a> (<a class="el" href="classSgType.html">SgType</a> *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if the type is a pointer pointing to a const object.  <a href="#dec244e853684b8fd4d1e65a48cbdd74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#36cd3e5596e53bac511df05e5e771d4a">isArgumentNonConstReferenceOrPointer</a> (<a class="el" href="classSgInitializedName.html">SgInitializedName</a> *formalArgument)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the given formal parameter is a reference or a nonconst pointer, so that it its value is aliased between function calls.  <a href="#36cd3e5596e53bac511df05e5e771d4a"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgProject.html">SgProject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#98dacdda77fbfbacb29125bceee6120e">project</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The project to perform SSA <a class="el" href="classAnalysis.html">Analysis</a> on.  <a href="#98dacdda77fbfbacb29125bceee6120e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classStaticSingleAssignment.html#dcb347322834917dd31dd57af44001f8">LocalDefUseTable</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#f101d71425909550364cfd9475b8d25f">originalDefTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the table of variable definition locations that is generated by the VarDefUseTraversal.  <a href="#f101d71425909550364cfd9475b8d25f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classStaticSingleAssignment.html#dcb347322834917dd31dd57af44001f8">LocalDefUseTable</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#74ca8f9eba22412e8ad4027c6fcc4b57">expandedDefTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the table of definitions that is expanded from the original table.  <a href="#74ca8f9eba22412e8ad4027c6fcc4b57"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classStaticSingleAssignment.html#aa29c315fbca6973d875f6832b62589f">GlobalReachingDefTable</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#07d2bdfe08d55fef9f28869cb8275283">reachingDefsTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maps each node to the reaching definitions at that node.  <a href="#07d2bdfe08d55fef9f28869cb8275283"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classStaticSingleAssignment.html#dcb347322834917dd31dd57af44001f8">LocalDefUseTable</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#78f003b7bd1fafd37c5a23e991931e08">localUsesTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the table that is populated with all the use information for all the variables at all the nodes.  <a href="#78f003b7bd1fafd37c5a23e991931e08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classStaticSingleAssignment.html#b9b42c79b83b951b9e29efc06a4e3bdb">UseTable</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#453f7bbefb66e63eabaf1fd71ce65a8b">useTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Map from each node to the variables used at that node and their reaching definitions.  <a href="#453f7bbefb66e63eabaf1fd71ce65a8b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::unordered_map&lt; <a class="el" href="classSgNode.html">SgNode</a> *,<br>
 <a class="el" href="classStaticSingleAssignment.html#a867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticSingleAssignment.html#58d0845bfd231f49dc3238a00ac13a21">ssaLocalDefTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Local definitions (actual definitions, not phi definitions).  <a href="#58d0845bfd231f49dc3238a00ac13a21"></a><br></td></tr>
</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="c331e1110ecdbb40e8efee09b0284862"></a><!-- doxytag: member="StaticSingleAssignment::VarName" ref="c331e1110ecdbb40e8efee09b0284862" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classSgInitializedName.html">SgInitializedName</a>*&gt; <a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">StaticSingleAssignment::VarName</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A compound variable name as used by the variable renaming. 
<p>

<p>
Definition at line <a class="el" href="staticSingleAssignment_8h-source.html#l00071">71</a> of file <a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a>.
</div>
</div><p>
<a class="anchor" name="dcb347322834917dd31dd57af44001f8"></a><!-- doxytag: member="StaticSingleAssignment::LocalDefUseTable" ref="dcb347322834917dd31dd57af44001f8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::unordered_map&lt;<a class="el" href="classSgNode.html">SgNode</a>*, std::set&lt;<a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a>&gt; &gt; <a class="el" href="classStaticSingleAssignment.html#dcb347322834917dd31dd57af44001f8">StaticSingleAssignment::LocalDefUseTable</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Describes the defs or uses at each node. 
<p>
This is for local, rather than propagated, information. 
<p>
Definition at line <a class="el" href="staticSingleAssignment_8h-source.html#l00074">74</a> of file <a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a>.
</div>
</div><p>
<a class="anchor" name="c26931d0a5d15d7f85913020563f9dd7"></a><!-- doxytag: member="StaticSingleAssignment::FilteredCfgNode" ref="c26931d0a5d15d7f85913020563f9dd7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FilteredCFGNode&lt;<a class="el" href="structssa__private_1_1DataflowCfgFilter.html">ssa_private::DataflowCfgFilter</a>&gt; <a class="el" href="classStaticSingleAssignment.html#c26931d0a5d15d7f85913020563f9dd7">StaticSingleAssignment::FilteredCfgNode</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A filtered CFGNode that is used for DefUse traversal. 
<p>

<p>
Definition at line <a class="el" href="staticSingleAssignment_8h-source.html#l00077">77</a> of file <a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a>.
</div>
</div><p>
<a class="anchor" name="aff056020ff2698604fdec2296405e8b"></a><!-- doxytag: member="StaticSingleAssignment::FilteredCfgEdge" ref="aff056020ff2698604fdec2296405e8b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FilteredCFGEdge&lt;<a class="el" href="structssa__private_1_1DataflowCfgFilter.html">ssa_private::DataflowCfgFilter</a>&gt; <a class="el" href="classStaticSingleAssignment.html#aff056020ff2698604fdec2296405e8b">StaticSingleAssignment::FilteredCfgEdge</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A filtered CFGEdge that is used for DefUse traversal. 
<p>

<p>
Definition at line <a class="el" href="staticSingleAssignment_8h-source.html#l00080">80</a> of file <a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a>.
</div>
</div><p>
<a class="anchor" name="75967eb37074af951e85ad1142755b08"></a><!-- doxytag: member="StaticSingleAssignment::ReachingDefPtr" ref="75967eb37074af951e85ad1142755b08" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="classReachingDef.html">ReachingDef</a>&gt; <a class="el" href="classStaticSingleAssignment.html#75967eb37074af951e85ad1142755b08">StaticSingleAssignment::ReachingDefPtr</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="staticSingleAssignment_8h-source.html#l00082">82</a> of file <a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a>.
</div>
</div><p>
<a class="anchor" name="a867994c56b8018439d2cc95d8ef4981"></a><!-- doxytag: member="StaticSingleAssignment::NodeReachingDefTable" ref="a867994c56b8018439d2cc95d8ef4981" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a>, <a class="el" href="classStaticSingleAssignment.html#75967eb37074af951e85ad1142755b08">ReachingDefPtr</a>&gt; <a class="el" href="classStaticSingleAssignment.html#a867994c56b8018439d2cc95d8ef4981">StaticSingleAssignment::NodeReachingDefTable</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A map from each variable to its reaching definitions at the current node. 
<p>

<p>
Definition at line <a class="el" href="staticSingleAssignment_8h-source.html#l00085">85</a> of file <a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a>.
</div>
</div><p>
<a class="anchor" name="aa29c315fbca6973d875f6832b62589f"></a><!-- doxytag: member="StaticSingleAssignment::GlobalReachingDefTable" ref="aa29c315fbca6973d875f6832b62589f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::unordered_map&lt;<a class="el" href="classSgNode.html">SgNode</a>*, std::pair&lt;<a class="el" href="classStaticSingleAssignment.html#a867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a>, <a class="el" href="classStaticSingleAssignment.html#a867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a>&gt; &gt; <a class="el" href="classStaticSingleAssignment.html#aa29c315fbca6973d875f6832b62589f">StaticSingleAssignment::GlobalReachingDefTable</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The first table is the IN table. 
<p>
The second table is the OUT table. 
<p>
Definition at line <a class="el" href="staticSingleAssignment_8h-source.html#l00088">88</a> of file <a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a>.
</div>
</div><p>
<a class="anchor" name="b9b42c79b83b951b9e29efc06a4e3bdb"></a><!-- doxytag: member="StaticSingleAssignment::UseTable" ref="b9b42c79b83b951b9e29efc06a4e3bdb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::unordered_map&lt;<a class="el" href="classSgNode.html">SgNode</a>*, <a class="el" href="classStaticSingleAssignment.html#a867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a>&gt; <a class="el" href="classStaticSingleAssignment.html#b9b42c79b83b951b9e29efc06a4e3bdb">StaticSingleAssignment::UseTable</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Map from each node to the variables used at that node and their reaching definitions. 
<p>

<p>
Definition at line <a class="el" href="staticSingleAssignment_8h-source.html#l00091">91</a> of file <a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a>.
</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="e66caa726cd1fd2741b71e015f383d55"></a><!-- doxytag: member="StaticSingleAssignment::StaticSingleAssignment" ref="e66caa726cd1fd2741b71e015f383d55" args="(SgProject *proj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StaticSingleAssignment::StaticSingleAssignment           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgProject.html">SgProject</a> *&nbsp;</td>
          <td class="paramname"> <em>proj</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="staticSingleAssignment_8h-source.html#l00131">131</a> of file <a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a>.
</div>
</div><p>
<a class="anchor" name="cdda8f8344e1c5a4f1e23e0f6ad173d3"></a><!-- doxytag: member="StaticSingleAssignment::~StaticSingleAssignment" ref="cdda8f8344e1c5a4f1e23e0f6ad173d3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StaticSingleAssignment::~StaticSingleAssignment           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="staticSingleAssignment_8h-source.html#l00135">135</a> of file <a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a>.
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="7340f93af9c35d8231170dac4fdea47c"></a><!-- doxytag: member="StaticSingleAssignment::run" ref="7340f93af9c35d8231170dac4fdea47c" args="(bool interprocedural, bool treatPointersAsStructures)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StaticSingleAssignment::run           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>interprocedural</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>treatPointersAsStructures</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Run the analysis. 
<p>
If interprocedural analysis is not enabled, functionc all expressions (<a class="el" href="classSgFunctionCallExp.html">SgFunctionCallExp</a>) will not count as definitions of any variables. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>interprocedural</em>&nbsp;</td><td>true to enable interprocedural analysis, false to perform no interprocedural analysis. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>treatPointersAsStructures</em>&nbsp;</td><td>if true, p-&gt;x is versioned as if it were the variable p.x. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8d0b08bd7c2d47df3f932e4f9730ef4a"></a><!-- doxytag: member="StaticSingleAssignment::getDebug" ref="8d0b08bd7c2d47df3f932e4f9730ef4a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool StaticSingleAssignment::getDebug           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="staticSingleAssignment_8h-source.html#l00145">145</a> of file <a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a>.
<p>
References <a class="el" href="classSgProject.html#cc4f5deea195f1967735d804d21cf379">SgProject::get_verbose()</a>.
</div>
</div><p>
<a class="anchor" name="8c2fb246c830ac4f68a16f64d7b50f6b"></a><!-- doxytag: member="StaticSingleAssignment::getDebugExtra" ref="8c2fb246c830ac4f68a16f64d7b50f6b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool StaticSingleAssignment::getDebugExtra           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="staticSingleAssignment_8h-source.html#l00150">150</a> of file <a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a>.
<p>
References <a class="el" href="classSgProject.html#cc4f5deea195f1967735d804d21cf379">SgProject::get_verbose()</a>.
<p>
Referenced by <a class="el" href="controlDependence_8h-source.html#l00019">ssa_private::calculateControlDependence()</a>.
</div>
</div><p>
<a class="anchor" name="d1d5433e9310116529ac02f6c64e9ef3"></a><!-- doxytag: member="StaticSingleAssignment::runDefUseDataFlow" ref="d1d5433e9310116529ac02f6c64e9ef3" args="(SgFunctionDefinition *func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StaticSingleAssignment::runDefUseDataFlow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Once all the local definitions have been inserted in the ssaLocalDefsTable and phi functions have been inserted in the reaching defs table, propagate reaching definitions along the CFG. 
<p>

</div>
</div><p>
<a class="anchor" name="41200ad359c912b48caeb80a808024bf"></a><!-- doxytag: member="StaticSingleAssignment::isBuiltinVar" ref="41200ad359c912b48caeb80a808024bf" args="(const VarName &amp;var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool StaticSingleAssignment::isBuiltinVar           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the variable is implicitly defined at the function entry by the compiler. 
<p>

</div>
</div><p>
<a class="anchor" name="2a9cca75f429b64de3e0b65b9e9f157d"></a><!-- doxytag: member="StaticSingleAssignment::expandParentMemberDefinitions" ref="2a9cca75f429b64de3e0b65b9e9f157d" args="(SgFunctionDeclaration *function)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StaticSingleAssignment::expandParentMemberDefinitions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>function</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Expand all member definitions (chained names) to define every name in the chain that is shorter than the originally defined name. 
<p>
When a member of a struct/class is referenced, this will insert definitions for every member referenced to access the currently referenced one.<p>
ex. Obj o; //Declare o of type Obj o.a.b = 5; //Def for o.a.b<p>
In the second line, this function will insert the following:<p>
o.a.b = 5; //Def for o.a.b, o.a, o 
</div>
</div><p>
<a class="anchor" name="d798ae59ee10d220e1ca0abae690f238"></a><!-- doxytag: member="StaticSingleAssignment::expandParentMemberUses" ref="d798ae59ee10d220e1ca0abae690f238" args="(SgFunctionDeclaration *function)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StaticSingleAssignment::expandParentMemberUses           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>function</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Expand all member uses (chained names) to explicitly use every name in the chain that is a parent of the original use. 
<p>
When a member of a struct/class is used, this will insert uses for every member referenced to access the currently used one.<p>
ex. Obj o; //Declare o of type Obj int i; //Declare i of type int i = o.a.b; //Def for i, use for o.a.b<p>
In the third line, this function will insert the following:<p>
i = o.a.b; //Def for i, use for o.a.b, o.a, o<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>curNode</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9ce45bb0b0c6cfa042c5a2999e7e0da0"></a><!-- doxytag: member="StaticSingleAssignment::insertDefsForChildMemberUses" ref="9ce45bb0b0c6cfa042c5a2999e7e0da0" args="(SgFunctionDeclaration *function)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StaticSingleAssignment::insertDefsForChildMemberUses           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>function</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find all uses of compound variable names and insert expanded defs for them when their parents are defined. 
<p>
E.g. for a.x, all defs of a will have a def of a.x inserted. Note that there might be other child expansions of a, such as a.y, that we do not insert since they have no uses. 
</div>
</div><p>
<a class="anchor" name="ea6d87a4babc43025e25987e58556670"></a><!-- doxytag: member="StaticSingleAssignment::insertDefsForExternalVariables" ref="ea6d87a4babc43025e25987e58556670" args="(SgFunctionDeclaration *function)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StaticSingleAssignment::insertDefsForExternalVariables           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>function</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert defs for functions that are declared outside the function scope. 
<p>

</div>
</div><p>
<a class="anchor" name="420e77b0306b73bf4c6372ae4f2cb84b"></a><!-- doxytag: member="StaticSingleAssignment::insertPhiFunctions" ref="420e77b0306b73bf4c6372ae4f2cb84b" args="(SgFunctionDefinition *function, const std::vector&lt; FilteredCfgNode &gt; &amp;cfgNodesInPostOrder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::multimap&lt; <a class="el" href="classStaticSingleAssignment.html#c26931d0a5d15d7f85913020563f9dd7">FilteredCfgNode</a>, std::pair&lt;<a class="el" href="classStaticSingleAssignment.html#c26931d0a5d15d7f85913020563f9dd7">FilteredCfgNode</a>, <a class="el" href="classStaticSingleAssignment.html#aff056020ff2698604fdec2296405e8b">FilteredCfgEdge</a>&gt; &gt; StaticSingleAssignment::insertPhiFunctions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classStaticSingleAssignment.html#c26931d0a5d15d7f85913020563f9dd7">FilteredCfgNode</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cfgNodesInPostOrder</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find where phi functions need to be inserted and insert empty phi functions at those nodes. 
<p>
This updates the IN part of the reaching def table with Phi functions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cfgNodesInPostOrder</em>&nbsp;</td><td>all the CFG nodes of the function </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the control dependencies. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c9437742c77e4c305e45f81eeb4f25ae"></a><!-- doxytag: member="StaticSingleAssignment::populateLocalDefsTable" ref="c9437742c77e4c305e45f81eeb4f25ae" args="(SgFunctionDeclaration *function)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StaticSingleAssignment::populateLocalDefsTable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>function</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create <a class="el" href="classReachingDef.html">ReachingDef</a> objects for each local def and insert them in the local def table. 
<p>

</div>
</div><p>
<a class="anchor" name="47ef818b8f7792803415e451cd18547a"></a><!-- doxytag: member="StaticSingleAssignment::renumberAllDefinitions" ref="47ef818b8f7792803415e451cd18547a" args="(SgFunctionDefinition *func, const std::vector&lt; FilteredCfgNode &gt; &amp;cfgNodesInPostOrder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StaticSingleAssignment::renumberAllDefinitions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classStaticSingleAssignment.html#c26931d0a5d15d7f85913020563f9dd7">FilteredCfgNode</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cfgNodesInPostOrder</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Give numbers to all the reachingDef objects. 
<p>
Should be called after phi functions are inserted and the local def table is populated, but before dataflow propagates the definitions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cfgNodesInPostOrder</em>&nbsp;</td><td>a list of all the CFG nodes in the function, in postorder. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="06ba62b7680b0088f59439bf77ea88fa"></a><!-- doxytag: member="StaticSingleAssignment::updateIncomingPropagatedDefs" ref="06ba62b7680b0088f59439bf77ea88fa" args="(FilteredCfgNode cfgNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StaticSingleAssignment::updateIncomingPropagatedDefs           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classStaticSingleAssignment.html#c26931d0a5d15d7f85913020563f9dd7">FilteredCfgNode</a>&nbsp;</td>
          <td class="paramname"> <em>cfgNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Take all the outgoing defs from previous nodes and merge them as the incoming defs of the current node. 
<p>

</div>
</div><p>
<a class="anchor" name="ec6aa55b711256c80e9d3e585479bf2c"></a><!-- doxytag: member="StaticSingleAssignment::propagateDefs" ref="ec6aa55b711256c80e9d3e585479bf2c" args="(FilteredCfgNode cfgNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StaticSingleAssignment::propagateDefs           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classStaticSingleAssignment.html#c26931d0a5d15d7f85913020563f9dd7">FilteredCfgNode</a>&nbsp;</td>
          <td class="paramname"> <em>cfgNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs the data-flow update for one individual node, populating the reachingDefsTable for that node. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>true if the OUT defs from the node changed, false if they stayed the same. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e4bc850d4513744e799b1bb4e2f170bc"></a><!-- doxytag: member="StaticSingleAssignment::buildUseTable" ref="e4bc850d4513744e799b1bb4e2f170bc" args="(const std::vector&lt; FilteredCfgNode &gt; &amp;cfgNodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StaticSingleAssignment::buildUseTable           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classStaticSingleAssignment.html#c26931d0a5d15d7f85913020563f9dd7">FilteredCfgNode</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cfgNodes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Once all the reaching def information has been propagated, uses the reaching def information and the local use information to match uses to their reaching defs. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cfgNodesInPostOrder</em>&nbsp;</td><td>all the nodes for which uses should be matched to defs </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cbe63acd025b03fe95dc5030ad2dbc04"></a><!-- doxytag: member="StaticSingleAssignment::getCfgNodesInPostorder" ref="cbe63acd025b03fe95dc5030ad2dbc04" args="(SgFunctionDefinition *func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;<a class="el" href="classStaticSingleAssignment.html#c26931d0a5d15d7f85913020563f9dd7">FilteredCfgNode</a>&gt; StaticSingleAssignment::getCfgNodesInPostorder           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterates all the CFG nodes in the function and returns them in postorder, according to depth-first search. 
<p>
Reverse postorder is the most efficient order for dataflow propagation. 
</div>
</div><p>
<a class="anchor" name="56aa2bd82684a775a45fcf0bc04393b3"></a><!-- doxytag: member="StaticSingleAssignment::interproceduralDefPropagation" ref="56aa2bd82684a775a45fcf0bc04393b3" args="(const boost::unordered_set&lt; SgFunctionDefinition * &gt; &amp;interestingFunctions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StaticSingleAssignment::interproceduralDefPropagation           </td>
          <td>(</td>
          <td class="paramtype">const boost::unordered_set&lt; <a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>interestingFunctions</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert definitions at function call sites for all variables defined interprocedurally. 
<p>
Iterates on the call graph until the definitions converge (hence it works with recursion). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>interestinFunctions</em>&nbsp;</td><td>all functions that should be analyzed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="673505410a5c884638b9c64d6bcc847e"></a><!-- doxytag: member="StaticSingleAssignment::calculateInterproceduralProcessingOrder" ref="673505410a5c884638b9c64d6bcc847e" args="(const boost::unordered_set&lt; SgFunctionDefinition * &gt; &amp;interestingFunctions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a>*&gt; StaticSingleAssignment::calculateInterproceduralProcessingOrder           </td>
          <td>(</td>
          <td class="paramtype">const boost::unordered_set&lt; <a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>interestingFunctions</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function returns the order in which functions should be processed so that callees are processed before callers whenever possible (this is sometimes not possible due to recursion). 
<p>
Internally, it builds a call graph and constructs a depth-first ordering of it. 
</div>
</div><p>
<a class="anchor" name="3403440d64195cd2bfac0b92809870cf"></a><!-- doxytag: member="StaticSingleAssignment::processCalleesThenFunction" ref="3403440d64195cd2bfac0b92809870cf" args="(SgFunctionDefinition *targetFunction, SgIncidenceDirectedGraph *callGraph, const boost::unordered_map&lt; SgFunctionDefinition *, SgGraphNode * &gt; &amp;graphNodeToFunction, std::vector&lt; SgFunctionDefinition * &gt; &amp;processingOrder, std::set&lt; SgFunctionDefinition * &gt; visited)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StaticSingleAssignment::processCalleesThenFunction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *&nbsp;</td>
          <td class="paramname"> <em>targetFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a> *&nbsp;</td>
          <td class="paramname"> <em>callGraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::unordered_map&lt; <a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *, <a class="el" href="classSgGraphNode.html">SgGraphNode</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>graphNodeToFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>processingOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> * &gt;&nbsp;</td>
          <td class="paramname"> <em>visited</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add all the callees of the function to the processing list, then add the function itself. 
<p>
Does nothing if the function is already in the list. 
</div>
</div><p>
<a class="anchor" name="d8fd7953a095b2461471471ff3f4583d"></a><!-- doxytag: member="StaticSingleAssignment::insertInterproceduralDefs" ref="d8fd7953a095b2461471471ff3f4583d" args="(SgFunctionDefinition *funcDef, const boost::unordered_set&lt; SgFunctionDefinition * &gt; &amp;processed, ClassHierarchyWrapper *classHierarchy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StaticSingleAssignment::insertInterproceduralDefs           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *&nbsp;</td>
          <td class="paramname"> <em>funcDef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::unordered_set&lt; <a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>processed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classClassHierarchyWrapper.html">ClassHierarchyWrapper</a> *&nbsp;</td>
          <td class="paramname"> <em>classHierarchy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add definitions at function call expressions for variables that are modified interprocedurally. 
<p>
The definitions are inserted in the original def table. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>funcDef</em>&nbsp;</td><td>function whose body should be queries for function calls </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>processed</em>&nbsp;</td><td>all the functions completely processed by SSA. If a callee is one of these functions, we can use exact information. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true if new defs were inserted, false otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c2d58e6811de33364457696ce6c5e64c"></a><!-- doxytag: member="StaticSingleAssignment::processOneCallSite" ref="c2d58e6811de33364457696ce6c5e64c" args="(SgExpression *callSite, SgFunctionDeclaration *callee, const boost::unordered_set&lt; SgFunctionDefinition * &gt; &amp;processed, ClassHierarchyWrapper *classHierarchy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StaticSingleAssignment::processOneCallSite           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>callSite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::unordered_set&lt; <a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>processed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classClassHierarchyWrapper.html">ClassHierarchyWrapper</a> *&nbsp;</td>
          <td class="paramname"> <em>classHierarchy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert the interprocedural defs at a particular call site for a particular callee. 
<p>
This function may be called multiple times for the same call site with different callees (e.g. in the case of virtual functions). The call site should either be a <a class="el" href="classSgFunctionCallExp.html">SgFunctionCallExp</a> or <a class="el" href="classSgConstructorInitializer.html">SgConstructorInitializer</a> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>processed</em>&nbsp;</td><td>functions already processed by SSA </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e49a10f4288e22d2ed15a059390d0801"></a><!-- doxytag: member="StaticSingleAssignment::isVarAccessibleFromCaller" ref="e49a10f4288e22d2ed15a059390d0801" args="(const VarName &amp;var, SgExpression *callSite, SgFunctionDeclaration *callee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool StaticSingleAssignment::isVarAccessibleFromCaller           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>callSite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>callee</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a variable that is in a callee's scope, returns true if the caller can access the same variable, false otherwise. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>callSite</em>&nbsp;</td><td>either a <a class="el" href="classSgFunctionCallExp.html">SgFunctionCallExp</a> or <a class="el" href="classSgConstructorInitializer.html">SgConstructorInitializer</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8963e1d352848745110ef17498b41060"></a><!-- doxytag: member="StaticSingleAssignment::varRequiresThisPointer" ref="8963e1d352848745110ef17498b41060" args="(const VarName &amp;var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool StaticSingleAssignment::varRequiresThisPointer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the variable is a nonstatic class variable, so it hass to be accessed by the "this" pointer. 
<p>

</div>
</div><p>
<a class="anchor" name="12d75a2881cc1716dbefe3f06fe0cb0d"></a><!-- doxytag: member="StaticSingleAssignment::isThisPointerSameInCallee" ref="12d75a2881cc1716dbefe3f06fe0cb0d" args="(SgFunctionCallExp *callSite, SgMemberFunctionDeclaration *callee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool StaticSingleAssignment::isThisPointerSameInCallee           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionCallExp.html">SgFunctionCallExp</a> *&nbsp;</td>
          <td class="paramname"> <em>callSite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgMemberFunctionDeclaration.html">SgMemberFunctionDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>callee</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the callee is acting on the same object instance as the caller. 
<p>

</div>
</div><p>
<a class="anchor" name="e0a3c3b0fe34ea42a5ffe9c34c13a564"></a><!-- doxytag: member="StaticSingleAssignment::isThisPointer" ref="e0a3c3b0fe34ea42a5ffe9c34c13a564" args="(SgExpression *expression)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool StaticSingleAssignment::isThisPointer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>expression</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true of the given expression evaluates to the 'this' pointer. 
<p>
False otherwise. This function is conservative; it will return false if it cannot statically determine that the expression is equivalent to the 'This' pointe. 
</div>
</div><p>
<a class="anchor" name="a0349aec0508b35e369469073e064cc4"></a><!-- doxytag: member="StaticSingleAssignment::isDeepConstPointer" ref="a0349aec0508b35e369469073e064cc4" args="(SgType *type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool StaticSingleAssignment::isDeepConstPointer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
True if the type is a const pointer pointing to a const object. 
<p>
Expanded recursively 
</div>
</div><p>
<a class="anchor" name="dec244e853684b8fd4d1e65a48cbdd74"></a><!-- doxytag: member="StaticSingleAssignment::isPointerToDeepConst" ref="dec244e853684b8fd4d1e65a48cbdd74" args="(SgType *type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool StaticSingleAssignment::isPointerToDeepConst           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
True if the type is a pointer pointing to a const object. 
<p>
Expanded recursively. 
</div>
</div><p>
<a class="anchor" name="36cd3e5596e53bac511df05e5e771d4a"></a><!-- doxytag: member="StaticSingleAssignment::isArgumentNonConstReferenceOrPointer" ref="36cd3e5596e53bac511df05e5e771d4a" args="(SgInitializedName *formalArgument)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool StaticSingleAssignment::isArgumentNonConstReferenceOrPointer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgInitializedName.html">SgInitializedName</a> *&nbsp;</td>
          <td class="paramname"> <em>formalArgument</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the given formal parameter is a reference or a nonconst pointer, so that it its value is aliased between function calls. 
<p>

</div>
</div><p>
<a class="anchor" name="45bd85ed0407c2e82c71f2287bb74457"></a><!-- doxytag: member="StaticSingleAssignment::printToDOT" ref="45bd85ed0407c2e82c71f2287bb74457" args="(SgSourceFile *file, std::ofstream &amp;outFile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StaticSingleAssignment::printToDOT           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgSourceFile.html">SgSourceFile</a> *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream &amp;&nbsp;</td>
          <td class="paramname"> <em>outFile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="23a22b17aecbe0ddf07d99ecdc36360e"></a><!-- doxytag: member="StaticSingleAssignment::printToFilteredDOT" ref="23a22b17aecbe0ddf07d99ecdc36360e" args="(SgSourceFile *file, std::ofstream &amp;outFile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StaticSingleAssignment::printToFilteredDOT           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgSourceFile.html">SgSourceFile</a> *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream &amp;&nbsp;</td>
          <td class="paramname"> <em>outFile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e22322f55e06b7df73fb590f0f748020"></a><!-- doxytag: member="StaticSingleAssignment::toDOT" ref="e22322f55e06b7df73fb590f0f748020" args="(const std::string fileName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StaticSingleAssignment::toDOT           </td>
          <td>(</td>
          <td class="paramtype">const std::string&nbsp;</td>
          <td class="paramname"> <em>fileName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print the CFG with any UniqueNames and Def/Use information visible. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fileName</em>&nbsp;</td><td>The filename to save graph as. Filenames will be prepended. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9774845d765b66e68b9016666f75cbaa"></a><!-- doxytag: member="StaticSingleAssignment::toFilteredDOT" ref="9774845d765b66e68b9016666f75cbaa" args="(const std::string fileName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StaticSingleAssignment::toFilteredDOT           </td>
          <td>(</td>
          <td class="paramtype">const std::string&nbsp;</td>
          <td class="paramname"> <em>fileName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print the CFG with any UniqueNames and Def/Use information visible. 
<p>
This will only print the nodes that are of interest to the filter function used by the def/use traversal.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fileName</em>&nbsp;</td><td>The filename to save graph as. Filenames will be prepended. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e89656a0ff151efb144bd571106b0fb8"></a><!-- doxytag: member="StaticSingleAssignment::printOriginalDefs" ref="e89656a0ff151efb144bd571106b0fb8" args="(SgNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StaticSingleAssignment::printOriginalDefs           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="9c2b0e5f5ed7a787a417a72097b5a732"></a><!-- doxytag: member="StaticSingleAssignment::printOriginalDefTable" ref="9c2b0e5f5ed7a787a417a72097b5a732" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StaticSingleAssignment::printOriginalDefTable           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="9a73c5246f974e2a72e9df0fa25ebf9a"></a><!-- doxytag: member="StaticSingleAssignment::getOriginalDefTable" ref="9a73c5246f974e2a72e9df0fa25ebf9a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStaticSingleAssignment.html#dcb347322834917dd31dd57af44001f8">LocalDefUseTable</a>&amp; StaticSingleAssignment::getOriginalDefTable           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the table of definitions for every node. 
<p>
These definitions are NOT propagated.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Definition table. </dd></dl>

<p>
Definition at line <a class="el" href="staticSingleAssignment_8h-source.html#l00342">342</a> of file <a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a>.
<p>
References <a class="el" href="staticSingleAssignment_8h-source.html#l00100">originalDefTable</a>.
</div>
</div><p>
<a class="anchor" name="8ab457322cb1f1c3031b82b9643f8b4f"></a><!-- doxytag: member="StaticSingleAssignment::getLocalUsesTable" ref="8ab457322cb1f1c3031b82b9643f8b4f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStaticSingleAssignment.html#dcb347322834917dd31dd57af44001f8">LocalDefUseTable</a>&amp; StaticSingleAssignment::getLocalUsesTable           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="staticSingleAssignment_8h-source.html#l00347">347</a> of file <a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a>.
<p>
References <a class="el" href="staticSingleAssignment_8h-source.html#l00119">localUsesTable</a>.
</div>
</div><p>
<a class="anchor" name="853bab80f278d557c92db0400df7409f"></a><!-- doxytag: member="StaticSingleAssignment::getOutgoingDefsAtNode" ref="853bab80f278d557c92db0400df7409f" args="(SgNode *node) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classStaticSingleAssignment.html#a867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a>&amp; StaticSingleAssignment::getOutgoingDefsAtNode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the definitions of all the variables right after the given node has executed. 
<p>
This function does not work correctly for "container" nodes such as <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, SgCommaOp, SgExprStmt. If there is a definition at the node itself, e.g. <a class="el" href="classSgAssignOp.html">SgAssignOp</a>, it is included in the outgoing defs. 
</div>
</div><p>
<a class="anchor" name="a8b248494b33c1373f903024cfed339b"></a><!-- doxytag: member="StaticSingleAssignment::getReachingDefsAtNode_" ref="a8b248494b33c1373f903024cfed339b" args="(SgNode *node) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classStaticSingleAssignment.html#a867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a>&amp; StaticSingleAssignment::getReachingDefsAtNode_           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the definitions of all the variables immediately before the given node has executed. 
<p>
If there is a definition at the node itself, e.g. <a class="el" href="classSgAssignOp.html">SgAssignOp</a>, it is not included in the reaching defs. 
</div>
</div><p>
<a class="anchor" name="1087b908d1defc3a747f757d5a84e1c4"></a><!-- doxytag: member="StaticSingleAssignment::getUsesAtNode" ref="1087b908d1defc3a747f757d5a84e1c4" args="(SgNode *node) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classStaticSingleAssignment.html#a867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a>&amp; StaticSingleAssignment::getUsesAtNode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a list of all the variables used at this node. 
<p>
Note that uses don't propagate past an <a class="el" href="classSgStatement.html">SgStatement</a>. Each use is mapped to the reaching definition to which the use corresponds. 
</div>
</div><p>
<a class="anchor" name="aafe1b2e6f1af07bfb9a24b9785a9277"></a><!-- doxytag: member="StaticSingleAssignment::getDefsAtNode" ref="aafe1b2e6f1af07bfb9a24b9785a9277" args="(SgNode *node) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classStaticSingleAssignment.html#a867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a>&amp; StaticSingleAssignment::getDefsAtNode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a list of all the variables defined at the given node. 
<p>
Note that this will return an empty collections for nodes that do not modify any variables. Compare this function to getReachingDefsAtNode. 
</div>
</div><p>
<a class="anchor" name="0d107f4b5123d0b4f6540018dbba1c3b"></a><!-- doxytag: member="StaticSingleAssignment::getVarsUsedInSubtree" ref="0d107f4b5123d0b4f6540018dbba1c3b" args="(SgNode *root) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a>&gt; StaticSingleAssignment::getVarsUsedInSubtree           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a set of all the variables names that have uses in the subtree. 
<p>

</div>
</div><p>
<a class="anchor" name="bd440e6d324ba45a9d0efa856f943584"></a><!-- doxytag: member="StaticSingleAssignment::getVarsDefinedInSubtree" ref="bd440e6d324ba45a9d0efa856f943584" args="(SgNode *root) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a>&gt; StaticSingleAssignment::getVarsDefinedInSubtree           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a node, traverses all its children in the AST and collects all the variable names that have definitions in the subtree. 
<p>

</div>
</div><p>
<a class="anchor" name="03e2cec7e7e71270d955d9eee8cd666b"></a><!-- doxytag: member="StaticSingleAssignment::getOriginalVarsDefinedInSubtree" ref="03e2cec7e7e71270d955d9eee8cd666b" args="(SgNode *root) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a>&gt; StaticSingleAssignment::getOriginalVarsDefinedInSubtree           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a node, traverses all its children in the AST and collects all the variable names that have original definitions in the subtree. 
<p>
Expanded definitions are not included - for example if p.x is defined, p is not included. 
</div>
</div><p>
<a class="anchor" name="b11cdbbac55303995df15578ac0b3e29"></a><!-- doxytag: member="StaticSingleAssignment::getLastVersions" ref="b11cdbbac55303995df15578ac0b3e29" args="(SgFunctionDeclaration *func) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStaticSingleAssignment.html#a867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a> StaticSingleAssignment::getLastVersions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the last encountered definition of every variable. 
<p>
Variables go out of scope, so quering for reaching definitions at the end of a function doesn't return the last versions of all variables. 
</div>
</div><p>
<a class="anchor" name="d431a7db92fca6b44e362d4a4cc380c4"></a><!-- doxytag: member="StaticSingleAssignment::isPrefixOfName" ref="d431a7db92fca6b44e362d4a4cc380c4" args="(VarName name, VarName prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool StaticSingleAssignment::isPrefixOfName           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a>&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a>&nbsp;</td>
          <td class="paramname"> <em>prefix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find if the given prefix is a prefix of the given name. 
<p>
This will return whether the given name has the given prefix inside it.<p>
ex. a.b.c has prefix a.b, but not a.c<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name to search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefix</em>&nbsp;</td><td>The prefix to search for. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Whether or not the prefix is in this name. </dd></dl>

</div>
</div><p>
<a class="anchor" name="35267ee8644b19fca8cc573649fbb24b"></a><!-- doxytag: member="StaticSingleAssignment::getUniqueName" ref="35267ee8644b19fca8cc573649fbb24b" args="(SgNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classssa__private_1_1VarUniqueName.html">ssa_private::VarUniqueName</a>* StaticSingleAssignment::getUniqueName           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the uniqueName attribute for the given node. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>Node to get the attribute from. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The attribute, or NULL. </dd></dl>

</div>
</div><p>
<a class="anchor" name="976474bbfc0366540c0ca8ef0dab77d3"></a><!-- doxytag: member="StaticSingleAssignment::getVarName" ref="976474bbfc0366540c0ca8ef0dab77d3" args="(SgNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a>&amp; StaticSingleAssignment::getVarName           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the variable name of the given node. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>The node to get the name for. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The name, or empty name. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c0e4b36e017885f616cd6b391c5205f8"></a><!-- doxytag: member="StaticSingleAssignment::getVarForExpression" ref="c0e4b36e017885f616cd6b391c5205f8" args="(SgNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a>&amp; StaticSingleAssignment::getVarForExpression           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If an expression evaluates to a reference of a variable, returns that variable. 
<p>
Handles casts, comma ops, address of ops, etc. For example, Given the expression (...., &amp;a), this method would return the VarName for a. 
</div>
</div><p>
<a class="anchor" name="28ce0ed01016c6dea58c6be900d95d63"></a><!-- doxytag: member="StaticSingleAssignment::buildVariableReference" ref="28ce0ed01016c6dea58c6be900d95d63" args="(const VarName &amp;var, SgScopeStatement *scope=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSgExpression.html">SgExpression</a>* StaticSingleAssignment::buildVariableReference           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an AST fragment containing the appropriate varRefs and Dot/Arrow ops to access the given variable. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable to construct access for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scope</em>&nbsp;</td><td>The scope within which to construct the access. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>An expression that access the given variable in the given scope. </dd></dl>

</div>
</div><p>
<a class="anchor" name="25e6ba89f1da6252d4518d73d091e4be"></a><!-- doxytag: member="StaticSingleAssignment::isVarInScope" ref="25e6ba89f1da6252d4518d73d091e4be" args="(const VarName &amp;var, SgNode *scope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool StaticSingleAssignment::isVarInScope           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds the scope of the given node, and returns true if the given variable is accessible there. 
<p>
False if the variable is not accessible. 
</div>
</div><p>
<a class="anchor" name="019e51da21fd909ef647f9692239751c"></a><!-- doxytag: member="StaticSingleAssignment::varnameToString" ref="019e51da21fd909ef647f9692239751c" args="(const VarName &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::string StaticSingleAssignment::varnameToString           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a string representation of a varName. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>varName to get string for. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>String for given varName. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e782076117cc18412c3f276bd144ef33"></a><!-- doxytag: member="StaticSingleAssignment::printLocalDefUseTable" ref="e782076117cc18412c3f276bd144ef33" args="(const LocalDefUseTable &amp;table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void StaticSingleAssignment::printLocalDefUseTable           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classStaticSingleAssignment.html#dcb347322834917dd31dd57af44001f8">LocalDefUseTable</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>table</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="98dacdda77fbfbacb29125bceee6120e"></a><!-- doxytag: member="StaticSingleAssignment::project" ref="98dacdda77fbfbacb29125bceee6120e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgProject.html">SgProject</a>* <a class="el" href="classStaticSingleAssignment.html#98dacdda77fbfbacb29125bceee6120e">StaticSingleAssignment::project</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The project to perform SSA <a class="el" href="classAnalysis.html">Analysis</a> on. 
<p>

<p>
Definition at line <a class="el" href="staticSingleAssignment_8h-source.html#l00066">66</a> of file <a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a>.
</div>
</div><p>
<a class="anchor" name="f101d71425909550364cfd9475b8d25f"></a><!-- doxytag: member="StaticSingleAssignment::originalDefTable" ref="f101d71425909550364cfd9475b8d25f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStaticSingleAssignment.html#dcb347322834917dd31dd57af44001f8">LocalDefUseTable</a> <a class="el" href="classStaticSingleAssignment.html#f101d71425909550364cfd9475b8d25f">StaticSingleAssignment::originalDefTable</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the table of variable definition locations that is generated by the VarDefUseTraversal. 
<p>
It is later used to populate the actual def/use table. It maps each node to the variable names that are defined inside that node. 
<p>
Definition at line <a class="el" href="staticSingleAssignment_8h-source.html#l00100">100</a> of file <a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a>.
<p>
Referenced by <a class="el" href="staticSingleAssignment_8h-source.html#l00342">getOriginalDefTable()</a>.
</div>
</div><p>
<a class="anchor" name="74ca8f9eba22412e8ad4027c6fcc4b57"></a><!-- doxytag: member="StaticSingleAssignment::expandedDefTable" ref="74ca8f9eba22412e8ad4027c6fcc4b57" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStaticSingleAssignment.html#dcb347322834917dd31dd57af44001f8">LocalDefUseTable</a> <a class="el" href="classStaticSingleAssignment.html#74ca8f9eba22412e8ad4027c6fcc4b57">StaticSingleAssignment::expandedDefTable</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the table of definitions that is expanded from the original table. 
<p>
It is used to populate the actual def/use table. It maps each node to the variable names that are defined inside that node. 
<p>
Definition at line <a class="el" href="staticSingleAssignment_8h-source.html#l00106">106</a> of file <a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a>.
</div>
</div><p>
<a class="anchor" name="07d2bdfe08d55fef9f28869cb8275283"></a><!-- doxytag: member="StaticSingleAssignment::reachingDefsTable" ref="07d2bdfe08d55fef9f28869cb8275283" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStaticSingleAssignment.html#aa29c315fbca6973d875f6832b62589f">GlobalReachingDefTable</a> <a class="el" href="classStaticSingleAssignment.html#07d2bdfe08d55fef9f28869cb8275283">StaticSingleAssignment::reachingDefsTable</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maps each node to the reaching definitions at that node. 
<p>
The table is populated with phi functions using iterated dominance frontiers, and then is filled through dataflow. 
<p>
Definition at line <a class="el" href="staticSingleAssignment_8h-source.html#l00111">111</a> of file <a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a>.
</div>
</div><p>
<a class="anchor" name="78f003b7bd1fafd37c5a23e991931e08"></a><!-- doxytag: member="StaticSingleAssignment::localUsesTable" ref="78f003b7bd1fafd37c5a23e991931e08" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStaticSingleAssignment.html#dcb347322834917dd31dd57af44001f8">LocalDefUseTable</a> <a class="el" href="classStaticSingleAssignment.html#78f003b7bd1fafd37c5a23e991931e08">StaticSingleAssignment::localUsesTable</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the table that is populated with all the use information for all the variables at all the nodes. 
<p>
It is populated during the runDefUse function, and is done with the steady-state dataflow algorithm. For each node, the table contains all the variables that were used at that node, and maps them to the reaching definitions for each use. 
<p>
Definition at line <a class="el" href="staticSingleAssignment_8h-source.html#l00119">119</a> of file <a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a>.
<p>
Referenced by <a class="el" href="staticSingleAssignment_8h-source.html#l00347">getLocalUsesTable()</a>.
</div>
</div><p>
<a class="anchor" name="453f7bbefb66e63eabaf1fd71ce65a8b"></a><!-- doxytag: member="StaticSingleAssignment::useTable" ref="453f7bbefb66e63eabaf1fd71ce65a8b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStaticSingleAssignment.html#b9b42c79b83b951b9e29efc06a4e3bdb">UseTable</a> <a class="el" href="classStaticSingleAssignment.html#453f7bbefb66e63eabaf1fd71ce65a8b">StaticSingleAssignment::useTable</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Map from each node to the variables used at that node and their reaching definitions. 
<p>

<p>
Definition at line <a class="el" href="staticSingleAssignment_8h-source.html#l00122">122</a> of file <a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a>.
</div>
</div><p>
<a class="anchor" name="58d0845bfd231f49dc3238a00ac13a21"></a><!-- doxytag: member="StaticSingleAssignment::ssaLocalDefTable" ref="58d0845bfd231f49dc3238a00ac13a21" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::unordered_map&lt;<a class="el" href="classSgNode.html">SgNode</a>*, <a class="el" href="classStaticSingleAssignment.html#a867994c56b8018439d2cc95d8ef4981">NodeReachingDefTable</a>&gt; <a class="el" href="classStaticSingleAssignment.html#58d0845bfd231f49dc3238a00ac13a21">StaticSingleAssignment::ssaLocalDefTable</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Local definitions (actual definitions, not phi definitions). 
<p>
This table does not get populated until AFTER interprocedural propagation; hence the values here cannot be used during interprocedural analysis. 
<p>
Definition at line <a class="el" href="staticSingleAssignment_8h-source.html#l00127">127</a> of file <a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a>.
</div>
</div><p>
<a class="anchor" name="56caa76396dd2ecaa37fddfbd441c228"></a><!-- doxytag: member="StaticSingleAssignment::emptyName" ref="56caa76396dd2ecaa37fddfbd441c228" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStaticSingleAssignment.html#c331e1110ecdbb40e8efee09b0284862">VarName</a> <a class="el" href="classStaticSingleAssignment.html#56caa76396dd2ecaa37fddfbd441c228">StaticSingleAssignment::emptyName</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="staticSingleAssignment_8h-source.html#l00310">310</a> of file <a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="staticSingleAssignment_8h-source.html">staticSingleAssignment.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
