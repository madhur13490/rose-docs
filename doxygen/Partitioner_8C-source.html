<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: Partitioner.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>Partitioner.C</h1><a href="Partitioner_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Algorithms to detect what instructions make up basic blocks and which blocks make up functions, and how to create the</span>
<a name="l00002"></a>00002 <span class="comment"> * necessary SgAsmBlock and SgAsmFunction IR nodes from this information. */</span>
<a name="l00003"></a>00003 <span class="preprocessor">#include "<a class="code" href="sage3basic_8h.html">sage3basic.h</a>"</span>
<a name="l00004"></a>00004 
<a name="l00005"></a>00005 <span class="preprocessor">#include "<a class="code" href="Partitioner_8h.html">Partitioner.h</a>"</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include "<a class="code" href="Assembler_8h.html">Assembler.h</a>"</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include "<a class="code" href="AssemblerX86_8h.html">AssemblerX86.h</a>"</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include "<a class="code" href="AsmUnparser__compat_8h.html">AsmUnparser_compat.h</a>"</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include "<a class="code" href="PartialSymbolicSemantics_8h.html">PartialSymbolicSemantics.h</a>"</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include "stringify.h"</span>
<a name="l00011"></a>00011 
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;errno.h&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 <span class="comment">/* See header file for full documentation. */</span>
<a name="l00018"></a>00018 
<a name="l00019"></a><a class="code" href="Partitioner_8C.html#09bcec30f23abd45160c6d7faa778dc1">00019</a> std::ostream&amp; <a class="code" href="Cxx__Grammar_8h.html#db4215b461ab8236ea979e9ab81c61ff">operator&lt;&lt;</a>(std::ostream &amp;o, <span class="keyword">const</span> <a class="code" href="structPartitioner_1_1Exception.html">Partitioner::Exception</a> &amp;e)
<a name="l00020"></a>00020 {
<a name="l00021"></a>00021     e.<a class="code" href="structPartitioner_1_1Exception.html#3f942618d4619383b4d199f27df68510">print</a>(o);
<a name="l00022"></a>00022     <span class="keywordflow">return</span> o;
<a name="l00023"></a>00023 }
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="comment">/* class method */</span>
<a name="l00026"></a>00026 <a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *
<a name="l00027"></a><a class="code" href="classPartitioner.html#9c2b4ede732f01bb1ce72270e0ee68da">00027</a> <a class="code" href="classPartitioner.html#9c2b4ede732f01bb1ce72270e0ee68da">Partitioner::isSgAsmInstruction</a>(<span class="keyword">const</span> <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a> *insn)
<a name="l00028"></a>00028 {
<a name="l00029"></a>00029     <span class="keywordflow">return</span> insn ? <a class="code" href="classPartitioner.html#9c2b4ede732f01bb1ce72270e0ee68da">isSgAsmInstruction</a>(insn-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#4b229dbd56516c2f986029271ea77b1a">node</a>) : NULL;
<a name="l00030"></a>00030 }
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="comment">/* class method */</span>
<a name="l00033"></a>00033 <a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *
<a name="l00034"></a><a class="code" href="classPartitioner.html#180324119e83339c19e88b0790dc0a5d">00034</a> <a class="code" href="classPartitioner.html#9c2b4ede732f01bb1ce72270e0ee68da">Partitioner::isSgAsmInstruction</a>(<a class="code" href="classSgNode.html">SgNode</a> *node)
<a name="l00035"></a>00035 {
<a name="l00036"></a>00036     <a class="code" href="Cxx__Grammar_8h.html#8ea3968ea14e6511567d5e5b654315f1">return ::isSgAsmInstruction</a>(node);
<a name="l00037"></a>00037 }
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="comment">/* class method */</span>
<a name="l00040"></a>00040 <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *
<a name="l00041"></a><a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">00041</a> <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">Partitioner::isSgAsmx86Instruction</a>(<span class="keyword">const</span> <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a> *insn)
<a name="l00042"></a>00042 {
<a name="l00043"></a>00043     <span class="keywordflow">return</span> insn ? <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(insn-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#4b229dbd56516c2f986029271ea77b1a">node</a>) : NULL;
<a name="l00044"></a>00044 }
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="comment">/* class method */</span>
<a name="l00047"></a>00047 <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *
<a name="l00048"></a><a class="code" href="classPartitioner.html#cd7ab5192dc3577d88a0f7d63ed548a7">00048</a> <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">Partitioner::isSgAsmx86Instruction</a>(<a class="code" href="classSgNode.html">SgNode</a> *node)
<a name="l00049"></a>00049 {
<a name="l00050"></a>00050     <a class="code" href="Cxx__Grammar_8h.html#a821b70974acc822c032fddf101296e9">return ::isSgAsmx86Instruction</a>(node);
<a name="l00051"></a>00051 }
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 <span class="comment">/* Progress report class variables. */</span>
<a name="l00054"></a>00054 time_t <a class="code" href="classPartitioner.html#2663919047a75925b65a999ab6ea2f40">Partitioner::progress_interval</a> = 10;
<a name="l00055"></a>00055 time_t <a class="code" href="classPartitioner.html#868d4534cf2da160c4ed12cb304323c9">Partitioner::progress_time</a> = 0;
<a name="l00056"></a>00056 FILE *<a class="code" href="classPartitioner.html#2b8e2de19780bf27ea1ab31b1b20f51a">Partitioner::progress_file</a> = stderr;
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 <span class="comment">/* Set progress reporting values. */</span>
<a name="l00059"></a>00059 <span class="keywordtype">void</span>
<a name="l00060"></a><a class="code" href="classPartitioner.html#072171925925389189b7206fd5897f3d">00060</a> <a class="code" href="classPartitioner.html#072171925925389189b7206fd5897f3d">Partitioner::set_progress_reporting</a>(FILE *<a class="code" href="IntelPinSupport_8C.html#0c56ec5eb0ac1eec6f0c42a439e9d24d">output</a>, <span class="keywordtype">unsigned</span> min_interval)
<a name="l00061"></a>00061 {
<a name="l00062"></a>00062     <a class="code" href="classPartitioner.html#2b8e2de19780bf27ea1ab31b1b20f51a">progress_file</a> = output;
<a name="l00063"></a>00063     <a class="code" href="classPartitioner.html#2663919047a75925b65a999ab6ea2f40">progress_interval</a> = min_interval;
<a name="l00064"></a>00064 }
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="comment">/* Produce a progress report if enabled. */</span>
<a name="l00067"></a>00067 <span class="keywordtype">void</span>
<a name="l00068"></a><a class="code" href="classPartitioner.html#044f608ba9d2cf1d4b9d22b2c53ccea9">00068</a> <a class="code" href="classPartitioner.html#044f608ba9d2cf1d4b9d22b2c53ccea9">Partitioner::progress</a>(FILE *debug, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...)<span class="keyword"> const</span>
<a name="l00069"></a>00069 <span class="keyword"></span>{
<a name="l00070"></a>00070     time_t now = time(NULL);
<a name="l00071"></a>00071 
<a name="l00072"></a>00072     <span class="keywordflow">if</span> (0==<a class="code" href="classPartitioner.html#868d4534cf2da160c4ed12cb304323c9">progress_time</a>)
<a name="l00073"></a>00073         <a class="code" href="classPartitioner.html#868d4534cf2da160c4ed12cb304323c9">progress_time</a> = now;
<a name="l00074"></a>00074 
<a name="l00075"></a>00075     <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#2b8e2de19780bf27ea1ab31b1b20f51a">progress_file</a>!=NULL &amp;&amp; now-<a class="code" href="classPartitioner.html#868d4534cf2da160c4ed12cb304323c9">progress_time</a> &gt;= <a class="code" href="classPartitioner.html#2663919047a75925b65a999ab6ea2f40">progress_interval</a>) {
<a name="l00076"></a>00076         <a class="code" href="classPartitioner.html#868d4534cf2da160c4ed12cb304323c9">progress_time</a> = now;
<a name="l00077"></a>00077         va_list ap;
<a name="l00078"></a>00078         va_start(ap, fmt);
<a name="l00079"></a>00079         vfprintf(<a class="code" href="classPartitioner.html#2b8e2de19780bf27ea1ab31b1b20f51a">progress_file</a>, fmt, ap);
<a name="l00080"></a>00080         va_end(ap);
<a name="l00081"></a>00081     }
<a name="l00082"></a>00082 
<a name="l00083"></a>00083     <span class="keywordflow">if</span> (debug!=NULL) {
<a name="l00084"></a>00084         va_list ap;
<a name="l00085"></a>00085         va_start(ap, fmt);
<a name="l00086"></a>00086         vfprintf(debug, fmt, ap);
<a name="l00087"></a>00087         va_end(ap);
<a name="l00088"></a>00088     }
<a name="l00089"></a>00089 }
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="comment">/* Parse argument for "-rose:partitioner_search" command-line swich. */</span>
<a name="l00092"></a>00092 <span class="keywordtype">unsigned</span>
<a name="l00093"></a><a class="code" href="classPartitioner.html#63758ffe8d586886ebfcdb2f69c7d107">00093</a> <a class="code" href="classPartitioner.html#63758ffe8d586886ebfcdb2f69c7d107">Partitioner::parse_switches</a>(<span class="keyword">const</span> std::string &amp;s, <span class="keywordtype">unsigned</span> flags)
<a name="l00094"></a>00094 {
<a name="l00095"></a>00095     size_t at=0;
<a name="l00096"></a>00096     <span class="keywordflow">while</span> (at&lt;s.size()) {
<a name="l00097"></a>00097         <span class="keyword">enum</span> { SET_BIT, CLEAR_BIT, SET_VALUE, NOT_SPECIFIED } howset = NOT_SPECIFIED;
<a name="l00098"></a>00098 
<a name="l00099"></a>00099         <span class="keywordflow">if</span> (s[at]==<span class="charliteral">'-'</span>) {
<a name="l00100"></a>00100             howset = CLEAR_BIT;
<a name="l00101"></a>00101             at++;
<a name="l00102"></a>00102         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s[at]==<span class="charliteral">'+'</span>) {
<a name="l00103"></a>00103             howset = SET_BIT;
<a name="l00104"></a>00104             at++;
<a name="l00105"></a>00105         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s[at]==<span class="charliteral">'='</span>) {
<a name="l00106"></a>00106             howset = SET_VALUE;
<a name="l00107"></a>00107             at++;
<a name="l00108"></a>00108         }
<a name="l00109"></a>00109         <span class="keywordflow">if</span> (at&gt;=s.size())
<a name="l00110"></a>00110             <span class="keywordflow">throw</span> <a class="code" href="structPartitioner_1_1Exception.html">Exception</a>(<span class="stringliteral">"heuristic name must follow qualifier"</span>);
<a name="l00111"></a>00111 
<a name="l00112"></a>00112         size_t comma = s.find(<span class="stringliteral">","</span>, at);
<a name="l00113"></a>00113         std::string word = std::string(s, at, comma-at);
<a name="l00114"></a>00114         <span class="keywordflow">if</span> (word.size()==0)
<a name="l00115"></a>00115             <span class="keywordflow">throw</span> <a class="code" href="structPartitioner_1_1Exception.html">Exception</a>(<span class="stringliteral">"heuristic name must follow comma"</span>);
<a name="l00116"></a>00116 
<a name="l00117"></a>00117         <span class="keywordtype">unsigned</span> bits = 0;
<a name="l00118"></a>00118         <span class="keywordflow">if</span> (word==<span class="stringliteral">"entry"</span> || word==<span class="stringliteral">"entry_point"</span>) {
<a name="l00119"></a>00119             bits = <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c2c1716e490136fddc09c145d8809ed64">SgAsmFunction::FUNC_ENTRY_POINT</a>;
<a name="l00120"></a>00120         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word==<span class="stringliteral">"call_target"</span>) {
<a name="l00121"></a>00121             bits = <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852ceea34044afa2b5415dad4b39cf2aa51d">SgAsmFunction::FUNC_CALL_TARGET</a>;
<a name="l00122"></a>00122         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word==<span class="stringliteral">"call_insn"</span>) {
<a name="l00123"></a>00123             bits = <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cbb9273d4d879614c52016694798c3143">SgAsmFunction::FUNC_CALL_INSN</a>;
<a name="l00124"></a>00124         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word==<span class="stringliteral">"call"</span>) {
<a name="l00125"></a>00125             bits = <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852ceea34044afa2b5415dad4b39cf2aa51d">SgAsmFunction::FUNC_CALL_TARGET</a> | <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cbb9273d4d879614c52016694798c3143">SgAsmFunction::FUNC_CALL_INSN</a>;
<a name="l00126"></a>00126         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word==<span class="stringliteral">"eh"</span> || word==<span class="stringliteral">"eh_frame"</span>) {
<a name="l00127"></a>00127             bits = <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cd7e1055f3974be70f4e4d88e758ed666">SgAsmFunction::FUNC_EH_FRAME</a>;
<a name="l00128"></a>00128         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word==<span class="stringliteral">"import"</span>) {
<a name="l00129"></a>00129             bits = <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c40c0ce88c447524963f4e8d7ef193cc7">SgAsmFunction::FUNC_IMPORT</a>;
<a name="l00130"></a>00130         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word==<span class="stringliteral">"symbol"</span>) {
<a name="l00131"></a>00131             bits = <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c10eee68a3ad870f7e48faef2639a853a">SgAsmFunction::FUNC_SYMBOL</a>;
<a name="l00132"></a>00132         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word==<span class="stringliteral">"pattern"</span>) {
<a name="l00133"></a>00133             bits = <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cd01f7a2ed6ff7e8a3e6c4550d0ccaa63">SgAsmFunction::FUNC_PATTERN</a>;
<a name="l00134"></a>00134         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word==<span class="stringliteral">"userdef"</span>) {
<a name="l00135"></a>00135             bits = <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c5f338fbf75bfacef4196e65ba5441767">SgAsmFunction::FUNC_USERDEF</a>;
<a name="l00136"></a>00136         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word==<span class="stringliteral">"pad"</span> || word==<span class="stringliteral">"padding"</span> || word==<span class="stringliteral">"interpad"</span>) {
<a name="l00137"></a>00137             bits = <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cdac33191eb0a658ed5382f9076595a28">SgAsmFunction::FUNC_PADDING</a>;
<a name="l00138"></a>00138         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word==<span class="stringliteral">"intrablock"</span>) {
<a name="l00139"></a>00139             bits = <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c78785310b2939c8834f597ef91fc17f4">SgAsmFunction::FUNC_INTRABLOCK</a>;
<a name="l00140"></a>00140         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word==<span class="stringliteral">"thunk"</span>) {
<a name="l00141"></a>00141             bits = <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c331ffe7c063699b34757276068c08d79">SgAsmFunction::FUNC_THUNK</a>;
<a name="l00142"></a>00142         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word==<span class="stringliteral">"misc"</span> || word==<span class="stringliteral">"miscellaneous"</span> || word==<span class="stringliteral">"interpadfunc"</span>) {
<a name="l00143"></a>00143             bits = <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852ccb6d9cc5789fcc0c98bb6e6894831228">SgAsmFunction::FUNC_MISCMASK</a>;
<a name="l00144"></a>00144         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word==<span class="stringliteral">"unassigned"</span> || word==<span class="stringliteral">"unclassified"</span> || word==<span class="stringliteral">"leftover"</span> || word==<span class="stringliteral">"leftovers"</span>) {
<a name="l00145"></a>00145             bits = <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c617301fe6a598b9c4afbde0aebcc8ad5">SgAsmFunction::FUNC_LEFTOVERS</a>;
<a name="l00146"></a>00146         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word==<span class="stringliteral">"default"</span>) {
<a name="l00147"></a>00147             bits = <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c385e7a83cce8b1ff004ec203c157785a">SgAsmFunction::FUNC_DEFAULT</a>;
<a name="l00148"></a>00148             <span class="keywordflow">if</span> (howset==NOT_SPECIFIED) howset = SET_VALUE;
<a name="l00149"></a>00149         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isdigit(word[0])) {
<a name="l00150"></a>00150             bits = strtol(word.c_str(), NULL, 0);
<a name="l00151"></a>00151         } <span class="keywordflow">else</span> {
<a name="l00152"></a>00152             <span class="keywordflow">throw</span> <a class="code" href="structPartitioner_1_1Exception.html">Exception</a>(<span class="stringliteral">"unknown partitioner heuristic: \""</span> + word + <span class="stringliteral">"\""</span>);
<a name="l00153"></a>00153         }
<a name="l00154"></a>00154 
<a name="l00155"></a>00155         <span class="keywordflow">switch</span> (howset) {
<a name="l00156"></a>00156             <span class="keywordflow">case</span> SET_VALUE:
<a name="l00157"></a>00157                 flags = 0;
<a name="l00158"></a>00158             <span class="keywordflow">case</span> NOT_SPECIFIED:
<a name="l00159"></a>00159             <span class="keywordflow">case</span> SET_BIT:
<a name="l00160"></a>00160                 flags |= bits;
<a name="l00161"></a>00161                 <span class="keywordflow">break</span>;
<a name="l00162"></a>00162             <span class="keywordflow">case</span> CLEAR_BIT:
<a name="l00163"></a>00163                 flags &amp;= ~bits;
<a name="l00164"></a>00164                 <span class="keywordflow">break</span>;
<a name="l00165"></a>00165         }
<a name="l00166"></a>00166 
<a name="l00167"></a>00167         at = comma==std::string::npos ? s.size() : comma+1;
<a name="l00168"></a>00168     }
<a name="l00169"></a>00169     <span class="keywordflow">return</span> flags;
<a name="l00170"></a>00170 }
<a name="l00171"></a>00171 
<a name="l00172"></a>00172 <span class="comment">/* Set disassembly and memory initialization maps. */</span>
<a name="l00173"></a>00173 <span class="keywordtype">void</span>
<a name="l00174"></a><a class="code" href="classPartitioner.html#3c46fdd567c72ad245ab7e2e6351a9d8">00174</a> <a class="code" href="classPartitioner.html#3c46fdd567c72ad245ab7e2e6351a9d8">Partitioner::set_map</a>(<a class="code" href="classMemoryMap.html">MemoryMap</a> *<a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>, <a class="code" href="classMemoryMap.html">MemoryMap</a> *<a class="code" href="classPartitioner.html#0b160d2ed1a5b32606e0deaf4c8cbb43">ro_map</a>)
<a name="l00175"></a>00175 {
<a name="l00176"></a>00176     this-&gt;<a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a> = <a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>;
<a name="l00177"></a>00177     <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>) {
<a name="l00178"></a>00178         <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#0b160d2ed1a5b32606e0deaf4c8cbb43">ro_map</a>) {
<a name="l00179"></a>00179             this-&gt;ro_map = *ro_map;
<a name="l00180"></a>00180         } <span class="keywordflow">else</span> {
<a name="l00181"></a>00181             this-&gt;ro_map = *<a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>;
<a name="l00182"></a>00182             this-&gt;ro_map.<a class="code" href="classMemoryMap.html#8e5d8580f91704ebfb5b28bcbd71c01a">prune</a>(<a class="code" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575721c493a6d527e717ffd911d2f18060f">MemoryMap::MM_PROT_READ</a>, <a class="code" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575ba37f8b609f7bd6bc6a454be584726df">MemoryMap::MM_PROT_WRITE</a>);
<a name="l00183"></a>00183         }
<a name="l00184"></a>00184     } <span class="keywordflow">else</span> {
<a name="l00185"></a>00185         this-&gt;<a class="code" href="classPartitioner.html#0b160d2ed1a5b32606e0deaf4c8cbb43">ro_map</a>.<a class="code" href="classMemoryMap.html#de35471bd24f46fc5099d8a6a97b0ddf">clear</a>();
<a name="l00186"></a>00186     }
<a name="l00187"></a>00187 }
<a name="l00188"></a>00188 
<a name="l00189"></a>00189 <span class="comment">/* Looks for a jump table. Documented in header file. */</span>
<a name="l00190"></a>00190 <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a>
<a name="l00191"></a><a class="code" href="classPartitioner.html#2a72cba4305db33a1086da011dab641b">00191</a> <a class="code" href="classPartitioner.html#2a72cba4305db33a1086da011dab641b">Partitioner::discover_jump_table</a>(<a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb, <span class="keywordtype">bool</span> do_create, <a class="code" href="classExtentMap.html">ExtentMap</a> *table_extent)
<a name="l00192"></a>00192 {
<a name="l00193"></a>00193     <span class="keyword">using namespace </span>BinaryAnalysis::InstructionSemantics;
<a name="l00194"></a>00194 
<a name="l00195"></a>00195     <span class="comment">/* Do some cheap up-front checks. */</span>
<a name="l00196"></a>00196     <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn_x86 = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#1ad984a08e9fb6cc311b0a2dc7951e49">last_insn</a>());
<a name="l00197"></a>00197     <span class="keywordflow">if</span> (!insn_x86 || (insn_x86-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()!=<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571ad03bc3cf5ca0f4918d34b66a2ae0b24">x86_jmp</a> &amp;&amp; insn_x86-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()==<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca557198fb4c6bacf21d45da2c1eb7380caccc">x86_farjmp</a>) ||
<a name="l00198"></a>00198         1!=insn_x86-&gt;<a class="code" href="classSgAsmInstruction.html#264e86d032b0a589d9dc520e79d09eb8">get_operandList</a>()-&gt;<a class="code" href="classSgAsmOperandList.html#bb5638c0533863030ad7acee019f1f17">get_operands</a>().size())
<a name="l00199"></a>00199         <span class="keywordflow">return</span> <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a>();
<a name="l00200"></a>00200     <a class="code" href="classSgAsmExpression.html">SgAsmExpression</a> *target_expr = insn_x86-&gt;<a class="code" href="classSgAsmInstruction.html#264e86d032b0a589d9dc520e79d09eb8">get_operandList</a>()-&gt;<a class="code" href="classSgAsmOperandList.html#bb5638c0533863030ad7acee019f1f17">get_operands</a>()[0];
<a name="l00201"></a>00201     <a class="code" href="classSgAsmMemoryReferenceExpression.html">SgAsmMemoryReferenceExpression</a> *mre = <a class="code" href="Cxx__Grammar_8h.html#de53c81adf2fb05def17e8e660ff4e18">isSgAsmMemoryReferenceExpression</a>(target_expr);
<a name="l00202"></a>00202     <a class="code" href="classSgAsmRegisterReferenceExpression.html">SgAsmRegisterReferenceExpression</a> *rre = <a class="code" href="Cxx__Grammar_8h.html#57c63c97527f4a655f21a06f0287b1fe">isSgAsmRegisterReferenceExpression</a>(target_expr);
<a name="l00203"></a>00203     <span class="keywordflow">if</span> (!mre &amp;&amp; !rre)
<a name="l00204"></a>00204         <span class="keywordflow">return</span> <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a>(); <span class="comment">// no indirection</span>
<a name="l00205"></a>00205 
<a name="l00206"></a>00206     <span class="comment">/* Evaluate the basic block semantically to get an expression for the final EIP. */</span>
<a name="l00207"></a>00207     <span class="keyword">typedef</span> PartialSymbolicSemantics::ValueType&lt;32&gt; RegisterValueType;
<a name="l00208"></a>00208     <span class="keyword">typedef</span> PartialSymbolicSemantics::Policy&lt;&gt; Policy;
<a name="l00209"></a>00209     <span class="keyword">typedef</span> X86InstructionSemantics&lt;Policy, PartialSymbolicSemantics::ValueType&gt; Semantics;
<a name="l00210"></a>00210     Policy policy;
<a name="l00211"></a>00211     policy.set_map(&amp;<a class="code" href="classPartitioner.html#0b160d2ed1a5b32606e0deaf4c8cbb43">ro_map</a>);
<a name="l00212"></a>00212     Semantics semantics(policy);
<a name="l00213"></a>00213     <span class="keywordflow">try</span> {
<a name="l00214"></a>00214         <span class="keywordflow">for</span> (size_t i=0; i&lt;bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.size(); ++i) {
<a name="l00215"></a>00215             insn_x86 = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>[i]-&gt;node);
<a name="l00216"></a>00216             assert(insn_x86); <span class="comment">// we know we're in a basic block of x86 instructions already</span>
<a name="l00217"></a>00217             policy.writeRegister(semantics.REG_EIP, policy.number&lt;32&gt;(insn_x86-&gt;<a class="code" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>()));
<a name="l00218"></a>00218             semantics.processInstruction(insn_x86);
<a name="l00219"></a>00219         }
<a name="l00220"></a>00220     } <span class="keywordflow">catch</span> (...) {
<a name="l00221"></a>00221         <span class="keywordflow">return</span> <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a>(); <span class="comment">// something went wrong, so just give up (e.g., unhandled instruction)</span>
<a name="l00222"></a>00222 
<a name="l00223"></a>00223     }
<a name="l00224"></a>00224 
<a name="l00225"></a>00225     <span class="comment">/* Scan through memory to find from whence the EIP value came.  There's no need to scan for an EIP which is a known value</span>
<a name="l00226"></a>00226 <span class="comment">     * since such control flow successors would be picked the usual way elsewhere.  It's also quite possible that the EIP value</span>
<a name="l00227"></a>00227 <span class="comment">     * is also stored at some other memory addresses outside the jump table (e.g., a function pointer argument stored on the</span>
<a name="l00228"></a>00228 <span class="comment">     * stack), so we also skip over any memory whose address is known. */</span>
<a name="l00229"></a>00229     Disassembler::AddressSet <a class="code" href="classPartitioner.html#e2e3e09e5194ba8c87bc968b65b63e3c">successors</a>;
<a name="l00230"></a>00230     RegisterValueType eip = policy.readRegister&lt;32&gt;(semantics.REG_EIP);
<a name="l00231"></a>00231     size_t entry_size = 4; <span class="comment">// FIXME: bytes per jump table entry</span>
<a name="l00232"></a>00232     <span class="keywordflow">if</span> (!eip.is_known()) {
<a name="l00233"></a>00233         <span class="keywordflow">for</span> (Policy::StateType::Memory::iterator mi=policy.get_state().memory.begin(); mi!=policy.get_state().memory.end(); ++mi) {
<a name="l00234"></a>00234             <span class="keywordflow">if</span> (mi-&gt;get_data()==eip &amp;&amp; !mi-&gt;get_address().is_known()) {
<a name="l00235"></a>00235                 <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> base_va = mi-&gt;get_address().offset;
<a name="l00236"></a>00236                 size_t nentries = 0;
<a name="l00237"></a>00237                 <span class="keywordflow">while</span> (1) {
<a name="l00238"></a>00238                     uint8_t buf[entry_size];
<a name="l00239"></a>00239                     size_t nread = <a class="code" href="classPartitioner.html#0b160d2ed1a5b32606e0deaf4c8cbb43">ro_map</a>.<a class="code" href="classMemoryMap.html#709a3ab13e92a0cbd4a12184e35d4941">read</a>(buf, base_va+nentries*entry_size, entry_size);
<a name="l00240"></a>00240                     <span class="keywordflow">if</span> (nread!=entry_size)
<a name="l00241"></a>00241                         <span class="keywordflow">break</span>;
<a name="l00242"></a>00242                     <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> target_va = 0;
<a name="l00243"></a>00243                     <span class="keywordflow">for</span> (size_t i=0; i&lt;entry_size; i++)
<a name="l00244"></a>00244                         target_va |= buf[i] &lt;&lt; (i*8);
<a name="l00245"></a>00245                     <span class="keywordflow">if</span> (!<a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>-&gt;<a class="code" href="classMemoryMap.html#372b80eef545c53a95b322c53e526e64">exists</a>(target_va, <a class="code" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575a061dc1ffe578fdaea067d730efb00ac">MemoryMap::MM_PROT_EXEC</a>))
<a name="l00246"></a>00246                         <span class="keywordflow">break</span>;
<a name="l00247"></a>00247                     successors.insert(target_va);
<a name="l00248"></a>00248                     ++nentries;
<a name="l00249"></a>00249                 }
<a name="l00250"></a>00250                 <span class="keywordflow">if</span> (nentries&gt;0) {
<a name="l00251"></a>00251                     <span class="keywordflow">if</span> (table_extent)
<a name="l00252"></a>00252                         table_extent-&gt;<a class="code" href="classRangeMap.html#df8ef8a1ea1d08b513487c6043ec0d8d">insert</a>(<a class="code" href="Cxx__Grammar_8h.html#d8e49820aaa106bb8a2dc17d9ad38d87">Extent</a>(base_va, nentries*entry_size));
<a name="l00253"></a>00253                     <span class="keywordflow">if</span> (do_create) {
<a name="l00254"></a>00254                         <a class="code" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *dblock = <a class="code" href="classPartitioner.html#72fe4f436de7235fa06629810a5f1494">find_db_starting</a>(base_va, nentries*entry_size);
<a name="l00255"></a>00255                         <a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">append</a>(bb, dblock, <a class="code" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48c1b1c894179759ed0bb4d6a76d54d90e3">SgAsmBlock::BLK_JUMPTABLE</a>);
<a name="l00256"></a>00256                     }
<a name="l00257"></a>00257                     <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>)
<a name="l00258"></a>00258                         fprintf(<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">"[jump table at 0x%08"</span>PRIx64<span class="stringliteral">"+%zu*%zu]"</span>, base_va, nentries, entry_size);
<a name="l00259"></a>00259                 }
<a name="l00260"></a>00260             }
<a name="l00261"></a>00261         }
<a name="l00262"></a>00262     }
<a name="l00263"></a>00263     <span class="keywordflow">return</span> successors;
<a name="l00264"></a>00264 }
<a name="l00265"></a>00265 
<a name="l00269"></a>00269 <span class="keywordtype">void</span>
<a name="l00270"></a><a class="code" href="classPartitioner.html#8652c15bcdd9d9dca2efb2d9f865f519">00270</a> <a class="code" href="classPartitioner.html#8652c15bcdd9d9dca2efb2d9f865f519">Partitioner::update_analyses</a>(<a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb)
<a name="l00271"></a>00271 {
<a name="l00272"></a>00272     assert(bb!=NULL &amp;&amp; !bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.empty());
<a name="l00273"></a>00273     <span class="keywordflow">if</span> (bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2cafe44b1ada952aee62894fabe14006">valid_cache</a>()) <span class="keywordflow">return</span>;
<a name="l00274"></a>00274 
<a name="l00275"></a>00275     <span class="comment">/* Successor analysis. */</span>
<a name="l00276"></a>00276     std::vector&lt;SgAsmInstruction*&gt; inodes;
<a name="l00277"></a>00277     <span class="keywordflow">for</span> (InstructionVector::const_iterator ii=bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.begin(); ii!=bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.end(); ++ii)
<a name="l00278"></a>00278         inodes.push_back(<a class="code" href="classPartitioner.html#9c2b4ede732f01bb1ce72270e0ee68da">isSgAsmInstruction</a>(*ii));
<a name="l00279"></a>00279     bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#a72f8961ccc40c25a9643634b35cd3cd">cache</a>.<a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#5d6d186d12ba71d10851ef6133350243">sucs</a> = bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.front()-&gt;node-&gt;get_successors(inodes, &amp;(bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#a72f8961ccc40c25a9643634b35cd3cd">cache</a>.<a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#f313f383147607c7dfb9f8ba84481c1c">sucs_complete</a>), &amp;<a class="code" href="classPartitioner.html#0b160d2ed1a5b32606e0deaf4c8cbb43">ro_map</a>);
<a name="l00280"></a>00280 
<a name="l00281"></a>00281     <span class="comment">/* Try to handle indirect jumps of the form "jmp ds:[BASE+REGISTER*WORDSIZE]".  The trick is to assume that some kind of</span>
<a name="l00282"></a>00282 <span class="comment">     * jump table exists beginning at address BASE, and that the table contains only addresses of valid code.  All we need to</span>
<a name="l00283"></a>00283 <span class="comment">     * do is look for the first entry in the table that doesn't point into an executable region of the disassembly memory</span>
<a name="l00284"></a>00284 <span class="comment">     * map. We use a "do" loop so the logic nesting doesn't get so deep: just break when we find that something doesn't match</span>
<a name="l00285"></a>00285 <span class="comment">     * what we expect. */</span>
<a name="l00286"></a>00286     <span class="keywordflow">if</span> (!bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#a72f8961ccc40c25a9643634b35cd3cd">cache</a>.<a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#f313f383147607c7dfb9f8ba84481c1c">sucs_complete</a> &amp;&amp; bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#a72f8961ccc40c25a9643634b35cd3cd">cache</a>.<a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#5d6d186d12ba71d10851ef6133350243">sucs</a>.empty()) {
<a name="l00287"></a>00287         <a class="code" href="classExtentMap.html">ExtentMap</a> table_extent;
<a name="l00288"></a>00288         <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> table_entries = <a class="code" href="classPartitioner.html#2a72cba4305db33a1086da011dab641b">discover_jump_table</a>(bb, <span class="keyword">true</span>, &amp;table_extent);
<a name="l00289"></a>00289         <span class="keywordflow">if</span> (!table_entries.empty()) {
<a name="l00290"></a>00290             bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#a72f8961ccc40c25a9643634b35cd3cd">cache</a>.<a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#5d6d186d12ba71d10851ef6133350243">sucs</a>.insert(table_entries.begin(), table_entries.end());
<a name="l00291"></a>00291             <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) {
<a name="l00292"></a>00292                 std::ostringstream ss;
<a name="l00293"></a>00293                 ss &lt;&lt;<span class="stringliteral">"[jump table at "</span> &lt;&lt;table_extent &lt;&lt;<span class="stringliteral">"]"</span>;
<a name="l00294"></a>00294                 fprintf(<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">"%s"</span>, ss.str().c_str());
<a name="l00295"></a>00295             }
<a name="l00296"></a>00296         }
<a name="l00297"></a>00297     }
<a name="l00298"></a>00298 
<a name="l00299"></a>00299     <span class="comment">/* Call target analysis. For x86, a function call is any CALL instruction except when the call target is the fall-through</span>
<a name="l00300"></a>00300 <span class="comment">     * address and the instruction at the fall-through address pops the top of the stack (this is how position independent</span>
<a name="l00301"></a>00301 <span class="comment">     * code loads EIP into a general-purpose register). FIXME: For now we'll assume that any call to the fall-through address</span>
<a name="l00302"></a>00302 <span class="comment">     * is not a function call. */</span>
<a name="l00303"></a>00303     <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> fallthrough_va = bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#1ad984a08e9fb6cc311b0a2dc7951e49">last_insn</a>()-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#a9c8dd5cf80780b59c4e74e4bb8b2811">get_address</a>() + bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#1ad984a08e9fb6cc311b0a2dc7951e49">last_insn</a>()-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#46940b414c39f0fd10186868d40715f7">get_size</a>();
<a name="l00304"></a>00304     <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> target_va = <a class="code" href="classPartitioner.html#7e4a76ae7ab4113b2ec7acf9093c3810">NO_TARGET</a>;
<a name="l00305"></a>00305     <span class="keywordtype">bool</span> looks_like_call = bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.front()-&gt;node-&gt;is_function_call(inodes, &amp;target_va);
<a name="l00306"></a>00306     <span class="keywordflow">if</span> (looks_like_call &amp;&amp; target_va!=fallthrough_va) {
<a name="l00307"></a>00307         bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#a72f8961ccc40c25a9643634b35cd3cd">cache</a>.<a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#bd097a4c305a32171e17b9052089982d">is_function_call</a> = <span class="keyword">true</span>;
<a name="l00308"></a>00308         bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#a72f8961ccc40c25a9643634b35cd3cd">cache</a>.<a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#4dc50b42608304f08524efc3c1952531">call_target</a> = target_va;
<a name="l00309"></a>00309     } <span class="keywordflow">else</span> {
<a name="l00310"></a>00310         bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#a72f8961ccc40c25a9643634b35cd3cd">cache</a>.<a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#bd097a4c305a32171e17b9052089982d">is_function_call</a> = <span class="keyword">false</span>;
<a name="l00311"></a>00311         bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#a72f8961ccc40c25a9643634b35cd3cd">cache</a>.<a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#4dc50b42608304f08524efc3c1952531">call_target</a> = <a class="code" href="classPartitioner.html#7e4a76ae7ab4113b2ec7acf9093c3810">NO_TARGET</a>;
<a name="l00312"></a>00312     }
<a name="l00313"></a>00313 
<a name="l00314"></a>00314     <span class="comment">/* Function return analysis */</span>
<a name="l00315"></a>00315     bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#a72f8961ccc40c25a9643634b35cd3cd">cache</a>.<a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#26b33ba9fb4b4fd4317f202e49c7fbf7">function_return</a> = !bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#a72f8961ccc40c25a9643634b35cd3cd">cache</a>.<a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#f313f383147607c7dfb9f8ba84481c1c">sucs_complete</a> &amp;&amp;
<a name="l00316"></a>00316                                 bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.front()-&gt;node-&gt;is_function_return(inodes);
<a name="l00317"></a>00317 
<a name="l00318"></a>00318     bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#f0030dfa1c05b84df2e7b095ae0a19a3">validate_cache</a>();
<a name="l00319"></a>00319 }
<a name="l00320"></a>00320 
<a name="l00324"></a>00324 <span class="keywordtype">bool</span>
<a name="l00325"></a><a class="code" href="classPartitioner.html#9c333715d5d353bab9fd4f46ce2c2d8d">00325</a> <a class="code" href="classPartitioner.html#9c333715d5d353bab9fd4f46ce2c2d8d">Partitioner::is_function_call</a>(<a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb, <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> *target_va)
<a name="l00326"></a>00326 {
<a name="l00327"></a>00327     <a class="code" href="classPartitioner.html#8652c15bcdd9d9dca2efb2d9f865f519">update_analyses</a>(bb); <span class="comment">/*make sure cache is current*/</span>
<a name="l00328"></a>00328     <span class="keywordflow">if</span> (target_va) *target_va = bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#a72f8961ccc40c25a9643634b35cd3cd">cache</a>.<a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#4dc50b42608304f08524efc3c1952531">call_target</a>;
<a name="l00329"></a>00329     <span class="keywordflow">return</span> bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#a72f8961ccc40c25a9643634b35cd3cd">cache</a>.<a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#bd097a4c305a32171e17b9052089982d">is_function_call</a>;
<a name="l00330"></a>00330 }
<a name="l00331"></a>00331 
<a name="l00344"></a>00344 <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a>
<a name="l00345"></a><a class="code" href="classPartitioner.html#e2e3e09e5194ba8c87bc968b65b63e3c">00345</a> <a class="code" href="classPartitioner.html#e2e3e09e5194ba8c87bc968b65b63e3c">Partitioner::successors</a>(<a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb, <span class="keywordtype">bool</span> *complete)
<a name="l00346"></a>00346 {
<a name="l00347"></a>00347     <a class="code" href="classPartitioner.html#8652c15bcdd9d9dca2efb2d9f865f519">update_analyses</a>(bb); <span class="comment">/*make sure cache is current*/</span>
<a name="l00348"></a>00348 
<a name="l00349"></a>00349     <span class="comment">/* Follow alias_for links. */</span>
<a name="l00350"></a>00350     <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> retval;
<a name="l00351"></a>00351     <span class="keywordflow">for</span> (Disassembler::AddressSet::const_iterator si=bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#a72f8961ccc40c25a9643634b35cd3cd">cache</a>.<a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#5d6d186d12ba71d10851ef6133350243">sucs</a>.begin(); si!=bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#a72f8961ccc40c25a9643634b35cd3cd">cache</a>.<a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#5d6d186d12ba71d10851ef6133350243">sucs</a>.end(); ++si)
<a name="l00352"></a>00352         retval.insert(<a class="code" href="classPartitioner.html#bd63242c67a32e6de5434d21956a01bf">canonic_block</a>(*si));
<a name="l00353"></a>00353     <span class="keywordflow">if</span> (complete) *complete = bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#a72f8961ccc40c25a9643634b35cd3cd">cache</a>.<a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#f313f383147607c7dfb9f8ba84481c1c">sucs_complete</a>;
<a name="l00354"></a>00354 
<a name="l00355"></a>00355     <span class="comment">/* Run non-local analyses if necessary. These are never cached here in this block. */</span>
<a name="l00356"></a>00356 
<a name="l00357"></a>00357     <span class="comment">/* If this block ends with what appears to be a function call then we should perhaps add the fall-through address as a</span>
<a name="l00358"></a>00358 <span class="comment">     * successor. */</span>
<a name="l00359"></a>00359     <span class="keywordflow">if</span> (bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#a72f8961ccc40c25a9643634b35cd3cd">cache</a>.<a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#bd097a4c305a32171e17b9052089982d">is_function_call</a>) {
<a name="l00360"></a>00360         <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> fall_through_va = <a class="code" href="classPartitioner.html#bd63242c67a32e6de5434d21956a01bf">canonic_block</a>(bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#1ad984a08e9fb6cc311b0a2dc7951e49">last_insn</a>()-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#a9c8dd5cf80780b59c4e74e4bb8b2811">get_address</a>() + bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#1ad984a08e9fb6cc311b0a2dc7951e49">last_insn</a>()-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#46940b414c39f0fd10186868d40715f7">get_size</a>());
<a name="l00361"></a>00361         <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> call_target_va = <a class="code" href="classPartitioner.html#5665dc5ef1c3aef6670dc6ab5d66815f">call_target</a>(bb);
<a name="l00362"></a>00362         <span class="keywordflow">if</span> (call_target_va!=<a class="code" href="classPartitioner.html#7e4a76ae7ab4113b2ec7acf9093c3810">NO_TARGET</a>) {
<a name="l00363"></a>00363             <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a> *target_insn = <a class="code" href="classPartitioner.html#1dcdd3e0993256cd5ed93fd4d178679f">find_instruction</a>(call_target_va, <span class="keyword">true</span>);
<a name="l00364"></a>00364             <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *target_bb = target_insn ? <a class="code" href="classPartitioner.html#67702e97dcbfb27fa18f6186fe30538a">find_bb_starting</a>(call_target_va, <span class="keyword">false</span>) : NULL;
<a name="l00365"></a>00365             <span class="keywordflow">if</span> (!target_insn) {
<a name="l00366"></a>00366                 <span class="comment">/* We know the call target, but could not obtain an instruction there.  The target might be a dynamically</span>
<a name="l00367"></a>00367 <span class="comment">                 * linked function that isn't mapped yet.  Assume it returns. */</span>
<a name="l00368"></a>00368                 retval.insert(fall_through_va);
<a name="l00369"></a>00369             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (target_bb &amp;&amp; target_bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a> &amp;&amp; target_bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>-&gt;<a class="code" href="classPartitioner_1_1Function.html#b2e8d9ad934f2c7736a50efadaca5e2a">possible_may_return</a>()) {
<a name="l00370"></a>00370                 <span class="comment">/* There's a function at the call target and that function might return. */</span>
<a name="l00371"></a>00371                 retval.insert(fall_through_va);
<a name="l00372"></a>00372             }
<a name="l00373"></a>00373         } <span class="keywordflow">else</span> {
<a name="l00374"></a>00374             retval.insert(fall_through_va); <span class="comment">/*true 99% of the time*/</span>
<a name="l00375"></a>00375         }
<a name="l00376"></a>00376     }
<a name="l00377"></a>00377 
<a name="l00378"></a>00378     <span class="keywordflow">return</span> retval;
<a name="l00379"></a>00379 }
<a name="l00380"></a>00380 
<a name="l00384"></a>00384 <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>
<a name="l00385"></a><a class="code" href="classPartitioner.html#5665dc5ef1c3aef6670dc6ab5d66815f">00385</a> <a class="code" href="classPartitioner.html#5665dc5ef1c3aef6670dc6ab5d66815f">Partitioner::call_target</a>(<a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb)
<a name="l00386"></a>00386 {
<a name="l00387"></a>00387     <a class="code" href="classPartitioner.html#8652c15bcdd9d9dca2efb2d9f865f519">update_analyses</a>(bb); <span class="comment">/*make sure cache is current*/</span>
<a name="l00388"></a>00388     <span class="keywordflow">if</span> (bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#a72f8961ccc40c25a9643634b35cd3cd">cache</a>.<a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#4dc50b42608304f08524efc3c1952531">call_target</a>==<a class="code" href="classPartitioner.html#7e4a76ae7ab4113b2ec7acf9093c3810">NO_TARGET</a>) <span class="keywordflow">return</span> <a class="code" href="classPartitioner.html#7e4a76ae7ab4113b2ec7acf9093c3810">NO_TARGET</a>;
<a name="l00389"></a>00389     <span class="keywordflow">return</span> <a class="code" href="classPartitioner.html#bd63242c67a32e6de5434d21956a01bf">canonic_block</a>(bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#a72f8961ccc40c25a9643634b35cd3cd">cache</a>.<a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#4dc50b42608304f08524efc3c1952531">call_target</a>);
<a name="l00390"></a>00390 }
<a name="l00391"></a>00391 
<a name="l00392"></a>00392 <span class="comment">/* Returns true if the basic block at the specified virtual address appears to pop the return address from the top of the</span>
<a name="l00393"></a>00393 <span class="comment"> * stack without returning.</span>
<a name="l00394"></a>00394 <span class="comment"> *</span>
<a name="l00395"></a>00395 <span class="comment"> * FIXME: This is far from perfect: it analyzes only the first basic block; it may have incomplete information about where the</span>
<a name="l00396"></a>00396 <span class="comment"> *        basic block ends due to not yet having discovered all incoming CFG edges; it doesn't consider cases where the return</span>
<a name="l00397"></a>00397 <span class="comment"> *        value is popped but saved and restored later; etc.  It also only handles x86 instructions at this time.</span>
<a name="l00398"></a>00398 <span class="comment"> *        [RPM 2010-04-30] */</span>
<a name="l00399"></a>00399 <span class="keywordtype">bool</span>
<a name="l00400"></a><a class="code" href="classPartitioner.html#6da761bf550bd07c05fa615f4091adba">00400</a> <a class="code" href="classPartitioner.html#6da761bf550bd07c05fa615f4091adba">Partitioner::pops_return_address</a>(<a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va)
<a name="l00401"></a>00401 {
<a name="l00402"></a>00402     <span class="keyword">using namespace </span>BinaryAnalysis::InstructionSemantics;
<a name="l00403"></a>00403 
<a name="l00404"></a>00404     <span class="keywordtype">bool</span> on_stack = <span class="keyword">true</span>; <span class="comment">/*assume return value stays on stack; prove otherwise*/</span>
<a name="l00405"></a>00405 
<a name="l00406"></a>00406     <span class="comment">/* Create the basic block if possible, but if we created it here then we should clear it below. */</span>
<a name="l00407"></a>00407     <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = <a class="code" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">find_bb_containing</a>(va, <span class="keyword">false</span>);
<a name="l00408"></a>00408     <span class="keywordtype">bool</span> preexisting = bb!=NULL;
<a name="l00409"></a>00409     <span class="keywordflow">if</span> (!bb) bb = <a class="code" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">find_bb_containing</a>(va);
<a name="l00410"></a>00410     <span class="keywordflow">if</span> (!bb) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00411"></a>00411     <span class="keywordflow">try</span> {
<a name="l00412"></a>00412 
<a name="l00413"></a>00413         <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *last_insn = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#1ad984a08e9fb6cc311b0a2dc7951e49">last_insn</a>());
<a name="l00414"></a>00414 
<a name="l00415"></a>00415         <span class="keyword">typedef</span> PartialSymbolicSemantics::Policy&lt;&gt; Policy;
<a name="l00416"></a>00416         <span class="keyword">typedef</span> X86InstructionSemantics&lt;Policy, PartialSymbolicSemantics::ValueType&gt; Semantics;
<a name="l00417"></a>00417         Policy policy;
<a name="l00418"></a>00418         policy.set_map(<a class="code" href="classPartitioner.html#697de2be7e07894883304357a546438b">get_map</a>());
<a name="l00419"></a>00419         PartialSymbolicSemantics::ValueType&lt;32&gt; orig_retaddr;
<a name="l00420"></a>00420         policy.writeMemory(<a class="code" href="InstructionEnumsX86_8h.html#0b09709b1ff4de1bbe47357b6d7b0e64ac8d2c21aff809a6d4a6303b051c88f7">x86_segreg_ss</a>, policy.readRegister&lt;32&gt;(<span class="stringliteral">"esp"</span>), orig_retaddr, policy.true_());
<a name="l00421"></a>00421         Semantics semantics(policy);
<a name="l00422"></a>00422 
<a name="l00423"></a>00423 <span class="preprocessor">#if 0</span>
<a name="l00424"></a>00424 <span class="preprocessor"></span>        fputs(<span class="stringliteral">"Partitioner::pops_return_address:\n"</span>, stderr);
<a name="l00425"></a>00425 <span class="preprocessor">#endif</span>
<a name="l00426"></a>00426 <span class="preprocessor"></span>        <span class="keywordflow">try</span> {
<a name="l00427"></a>00427             <span class="keywordflow">for</span> (InstructionVector::iterator ii=bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.begin(); ii!=bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.end(); ++ii) {
<a name="l00428"></a>00428                 <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(*ii);
<a name="l00429"></a>00429                 <span class="keywordflow">if</span> (!insn) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00430"></a>00430                 <span class="keywordflow">if</span> (insn==last_insn &amp;&amp; insn-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()==<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca557193febfccef733b633e7c6374ea207532">x86_ret</a>) <span class="keywordflow">break</span>;
<a name="l00431"></a>00431                 semantics.processInstruction(insn);
<a name="l00432"></a>00432 <span class="preprocessor">#if 0</span>
<a name="l00433"></a>00433 <span class="preprocessor"></span>                std::ostringstream s;
<a name="l00434"></a>00434                 s &lt;&lt; <span class="stringliteral">"Analysis for "</span> &lt;&lt;<a class="code" href="AsmUnparser__compat_8h.html#3b979292833b85f5b059b2893250453c">unparseInstructionWithAddress</a>(insn) &lt;&lt;std::endl
<a name="l00435"></a>00435                   &lt;&lt;policy.get_state()
<a name="l00436"></a>00436                 fputs(s.str().c_str(), stderr);
<a name="l00437"></a>00437 <span class="preprocessor">#endif</span>
<a name="l00438"></a>00438 <span class="preprocessor"></span>            }
<a name="l00439"></a>00439             on_stack = policy.on_stack(orig_retaddr);
<a name="l00440"></a>00440             <span class="keywordflow">if</span> (!on_stack &amp;&amp; <a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>)
<a name="l00441"></a>00441                 fprintf(<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">"[B%08"</span>PRIx64<span class="stringliteral">"#%zu discards return address]"</span>, va, bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.size());
<a name="l00442"></a>00442         } <span class="keywordflow">catch</span> (<span class="keyword">const</span> Semantics::Exception&amp;) {
<a name="l00443"></a>00443             <span class="comment">/*void*/</span>
<a name="l00444"></a>00444         } <span class="keywordflow">catch</span> (<span class="keyword">const</span> Policy::Exception&amp;) {
<a name="l00445"></a>00445             <span class="comment">/*void*/</span>
<a name="l00446"></a>00446         }
<a name="l00447"></a>00447 
<a name="l00448"></a>00448     } <span class="keywordflow">catch</span>(...) {
<a name="l00449"></a>00449         <span class="keywordflow">if</span> (!preexisting)
<a name="l00450"></a>00450             <a class="code" href="classPartitioner.html#8b679c9a4b6fb7a7f4f45900d10819c0">discard</a>(bb);
<a name="l00451"></a>00451         <span class="keywordflow">throw</span>;
<a name="l00452"></a>00452     }
<a name="l00453"></a>00453 
<a name="l00454"></a>00454     <span class="comment">/* We don't want to have a basic block created just because we did some analysis. */</span>
<a name="l00455"></a>00455     <span class="keywordflow">if</span> (!preexisting)
<a name="l00456"></a>00456         <a class="code" href="classPartitioner.html#8b679c9a4b6fb7a7f4f45900d10819c0">discard</a>(bb);
<a name="l00457"></a>00457 
<a name="l00458"></a>00458     <span class="comment">/* Is the original return value still on the stack? */</span>
<a name="l00459"></a>00459     <span class="keywordflow">return</span> !on_stack;
<a name="l00460"></a>00460 }
<a name="l00461"></a>00461 
<a name="l00464"></a>00464 <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>
<a name="l00465"></a><a class="code" href="structPartitioner_1_1BasicBlock.html#7e120c89ba03d66a308381c0b82173c9">00465</a> <a class="code" href="structPartitioner_1_1BasicBlock.html#7e120c89ba03d66a308381c0b82173c9">Partitioner::BasicBlock::address</a>()<span class="keyword"> const</span>
<a name="l00466"></a>00466 <span class="keyword"></span>{
<a name="l00467"></a>00467     assert(!<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.empty());
<a name="l00468"></a>00468     <span class="keywordflow">return</span> <a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.front()-&gt;get_address();
<a name="l00469"></a>00469 }
<a name="l00470"></a>00470 
<a name="l00473"></a>00473 <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>
<a name="l00474"></a><a class="code" href="structPartitioner_1_1DataBlock.html#30602458b400eee36e9c7b1298797250">00474</a> <a class="code" href="structPartitioner_1_1DataBlock.html#30602458b400eee36e9c7b1298797250">Partitioner::DataBlock::address</a>()<span class="keyword"> const</span>
<a name="l00475"></a>00475 <span class="keyword"></span>{
<a name="l00476"></a>00476     assert(!<a class="code" href="structPartitioner_1_1DataBlock.html#fdc2bd13ec3bc86896eebb7ac65fcd08">nodes</a>.empty());
<a name="l00477"></a>00477     <span class="keywordflow">return</span> <a class="code" href="structPartitioner_1_1DataBlock.html#fdc2bd13ec3bc86896eebb7ac65fcd08">nodes</a>.front()-&gt;get_address();
<a name="l00478"></a>00478 }
<a name="l00479"></a>00479 
<a name="l00483"></a>00483 <a class="code" href="classPartitioner_1_1Function.html">Partitioner::Function</a> *
<a name="l00484"></a><a class="code" href="classPartitioner.html#cd1de02179852d54139e2f4eb366ebdc">00484</a> <a class="code" href="classPartitioner.html#cd1de02179852d54139e2f4eb366ebdc">Partitioner::effective_function</a>(<a class="code" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *dblock)
<a name="l00485"></a>00485 {
<a name="l00486"></a>00486     <span class="keywordflow">if</span> (dblock-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#ef1d5b36cc38db48693a00b9de89ec1b">function</a>)
<a name="l00487"></a>00487         <span class="keywordflow">return</span> dblock-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#ef1d5b36cc38db48693a00b9de89ec1b">function</a>;
<a name="l00488"></a>00488     <span class="keywordflow">if</span> (dblock-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#00e9f5268dbd139a8f076452fde6efa2">basic_block</a>)
<a name="l00489"></a>00489         <span class="keywordflow">return</span> dblock-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#00e9f5268dbd139a8f076452fde6efa2">basic_block</a>-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>;
<a name="l00490"></a>00490     <span class="keywordflow">return</span> NULL;
<a name="l00491"></a>00491 }
<a name="l00492"></a>00492 
<a name="l00493"></a>00493 <span class="comment">/* Returns last instruction, the one that exits from the block. */</span>
<a name="l00494"></a>00494 <a class="code" href="classPartitioner_1_1Instruction.html">Partitioner::Instruction</a> *
<a name="l00495"></a><a class="code" href="structPartitioner_1_1BasicBlock.html#1ad984a08e9fb6cc311b0a2dc7951e49">00495</a> <a class="code" href="structPartitioner_1_1BasicBlock.html#1ad984a08e9fb6cc311b0a2dc7951e49">Partitioner::BasicBlock::last_insn</a>()<span class="keyword"> const</span>
<a name="l00496"></a>00496 <span class="keyword"></span>{
<a name="l00497"></a>00497     assert(<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.size()&gt;0);
<a name="l00498"></a>00498     <span class="keywordflow">return</span> <a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.back();
<a name="l00499"></a>00499 }
<a name="l00500"></a>00500 
<a name="l00501"></a>00501 <span class="comment">/* Removes association between data blocks and basic blocks. */</span>
<a name="l00502"></a>00502 <span class="keywordtype">void</span>
<a name="l00503"></a><a class="code" href="structPartitioner_1_1BasicBlock.html#23febe57dd258c7426a39980c2f1b511">00503</a> <a class="code" href="structPartitioner_1_1BasicBlock.html#23febe57dd258c7426a39980c2f1b511">Partitioner::BasicBlock::clear_data_blocks</a>()
<a name="l00504"></a>00504 {
<a name="l00505"></a>00505     <span class="keywordflow">for</span> (std::set&lt;DataBlock*&gt;::iterator di=<a class="code" href="structPartitioner_1_1BasicBlock.html#78c634ed49a131d7c2e6e302f78d0e55">data_blocks</a>.begin(); di!=<a class="code" href="structPartitioner_1_1BasicBlock.html#78c634ed49a131d7c2e6e302f78d0e55">data_blocks</a>.end(); ++di)
<a name="l00506"></a>00506         (*di)-&gt;basic_block = NULL;
<a name="l00507"></a>00507     <a class="code" href="structPartitioner_1_1BasicBlock.html#78c634ed49a131d7c2e6e302f78d0e55">data_blocks</a>.clear();
<a name="l00508"></a>00508 }
<a name="l00509"></a>00509 
<a name="l00510"></a>00510 <span class="comment">/* Release all basic blocks from a function. Do not delete the blocks. */</span>
<a name="l00511"></a>00511 <span class="keywordtype">void</span>
<a name="l00512"></a><a class="code" href="classPartitioner_1_1Function.html#ebb899dee2d38549d338e2ed9a11c63b">00512</a> <a class="code" href="classPartitioner_1_1Function.html#ebb899dee2d38549d338e2ed9a11c63b">Partitioner::Function::clear_basic_blocks</a>()
<a name="l00513"></a>00513 {
<a name="l00514"></a>00514     <span class="keywordflow">for</span> (BasicBlocks::iterator bi=<a class="code" href="classPartitioner_1_1Function.html#8bdb95ca10afda44f8dacb28248f5c6c">basic_blocks</a>.begin(); bi!=<a class="code" href="classPartitioner_1_1Function.html#8bdb95ca10afda44f8dacb28248f5c6c">basic_blocks</a>.end(); ++bi)
<a name="l00515"></a>00515         bi-&gt;second-&gt;function = NULL;
<a name="l00516"></a>00516     <a class="code" href="classPartitioner_1_1Function.html#8bdb95ca10afda44f8dacb28248f5c6c">basic_blocks</a>.clear();
<a name="l00517"></a>00517 }
<a name="l00518"></a>00518 
<a name="l00519"></a>00519 <span class="comment">/* Release all data blocks from a function. Do not delete the blocks. */</span>
<a name="l00520"></a>00520 <span class="keywordtype">void</span>
<a name="l00521"></a><a class="code" href="classPartitioner_1_1Function.html#49652421fa901651e9f1269369e2990c">00521</a> <a class="code" href="classPartitioner_1_1Function.html#49652421fa901651e9f1269369e2990c">Partitioner::Function::clear_data_blocks</a>()
<a name="l00522"></a>00522 {
<a name="l00523"></a>00523     <span class="keywordflow">for</span> (DataBlocks::iterator bi=<a class="code" href="classPartitioner_1_1Function.html#a4ec341f0aa8ef699a36dda8389036d8">data_blocks</a>.begin(); bi!=<a class="code" href="classPartitioner_1_1Function.html#a4ec341f0aa8ef699a36dda8389036d8">data_blocks</a>.end(); ++bi)
<a name="l00524"></a>00524         bi-&gt;second-&gt;function = NULL;
<a name="l00525"></a>00525     <a class="code" href="classPartitioner_1_1Function.html#a4ec341f0aa8ef699a36dda8389036d8">data_blocks</a>.clear();
<a name="l00526"></a>00526 }
<a name="l00527"></a>00527 
<a name="l00528"></a>00528 <span class="comment">/* Move basic blocks from the other function to this one. */</span>
<a name="l00529"></a>00529 <span class="keywordtype">void</span>
<a name="l00530"></a><a class="code" href="classPartitioner_1_1Function.html#ebc6491d5d1662d05d20fe11424ca87f">00530</a> <a class="code" href="classPartitioner_1_1Function.html#ebc6491d5d1662d05d20fe11424ca87f">Partitioner::Function::move_basic_blocks_from</a>(<a class="code" href="classPartitioner_1_1Function.html">Function</a> *other)
<a name="l00531"></a>00531 {
<a name="l00532"></a>00532     <span class="keywordflow">for</span> (BasicBlocks::iterator bbi=other-&gt;<a class="code" href="classPartitioner_1_1Function.html#8bdb95ca10afda44f8dacb28248f5c6c">basic_blocks</a>.begin(); bbi!=other-&gt;<a class="code" href="classPartitioner_1_1Function.html#8bdb95ca10afda44f8dacb28248f5c6c">basic_blocks</a>.end(); ++bbi) {
<a name="l00533"></a>00533         <a class="code" href="classPartitioner_1_1Function.html#8bdb95ca10afda44f8dacb28248f5c6c">basic_blocks</a>[bbi-&gt;first] = bbi-&gt;second;
<a name="l00534"></a>00534         bbi-&gt;second-&gt;function = <span class="keyword">this</span>;
<a name="l00535"></a>00535     }
<a name="l00536"></a>00536     other-&gt;<a class="code" href="classPartitioner_1_1Function.html#8bdb95ca10afda44f8dacb28248f5c6c">basic_blocks</a>.clear();
<a name="l00537"></a>00537 
<a name="l00538"></a>00538     <a class="code" href="classPartitioner_1_1Function.html#41ac95e38f7681fd66736276a833f931">heads</a>.insert(other-&gt;<a class="code" href="classPartitioner_1_1Function.html#41ac95e38f7681fd66736276a833f931">heads</a>.begin(), other-&gt;<a class="code" href="classPartitioner_1_1Function.html#41ac95e38f7681fd66736276a833f931">heads</a>.end());
<a name="l00539"></a>00539     other-&gt;<a class="code" href="classPartitioner_1_1Function.html#41ac95e38f7681fd66736276a833f931">heads</a>.clear();
<a name="l00540"></a>00540 }
<a name="l00541"></a>00541 
<a name="l00542"></a>00542 <span class="comment">/* Move data blocks from the other function to this one. */</span>
<a name="l00543"></a>00543 <span class="keywordtype">void</span>
<a name="l00544"></a><a class="code" href="classPartitioner_1_1Function.html#74ee36aae06ad156b40daa5bfa48afb1">00544</a> <a class="code" href="classPartitioner_1_1Function.html#74ee36aae06ad156b40daa5bfa48afb1">Partitioner::Function::move_data_blocks_from</a>(<a class="code" href="classPartitioner_1_1Function.html">Function</a> *other)
<a name="l00545"></a>00545 {
<a name="l00546"></a>00546     <span class="keywordflow">for</span> (DataBlocks::iterator dbi=other-&gt;<a class="code" href="classPartitioner_1_1Function.html#a4ec341f0aa8ef699a36dda8389036d8">data_blocks</a>.begin(); dbi!=other-&gt;<a class="code" href="classPartitioner_1_1Function.html#a4ec341f0aa8ef699a36dda8389036d8">data_blocks</a>.end(); ++dbi) {
<a name="l00547"></a>00547         <a class="code" href="classPartitioner_1_1Function.html#a4ec341f0aa8ef699a36dda8389036d8">data_blocks</a>[dbi-&gt;first] = dbi-&gt;second;
<a name="l00548"></a>00548         dbi-&gt;second-&gt;function = <span class="keyword">this</span>;
<a name="l00549"></a>00549     }
<a name="l00550"></a>00550     other-&gt;<a class="code" href="classPartitioner_1_1Function.html#a4ec341f0aa8ef699a36dda8389036d8">data_blocks</a>.clear();
<a name="l00551"></a>00551 }
<a name="l00552"></a>00552 
<a name="l00553"></a>00553 <span class="comment">/* Increase knowledge about may-return property. */</span>
<a name="l00554"></a>00554 <span class="keywordtype">void</span>
<a name="l00555"></a><a class="code" href="classPartitioner_1_1Function.html#aebf437238c29dadf3c29d078ed22549">00555</a> <a class="code" href="classPartitioner_1_1Function.html#aebf437238c29dadf3c29d078ed22549">Partitioner::Function::promote_may_return</a>(<a class="code" href="classSgAsmFunction.html#d1e0c37f9e507fc6acaf01dd0794a752">SgAsmFunction::MayReturn</a> new_value) {
<a name="l00556"></a>00556     <span class="keywordflow">switch</span> (<a class="code" href="classPartitioner_1_1Function.html#cca110ab4755cb256c8d5e1c338dea7f">get_may_return</a>()) {
<a name="l00557"></a>00557         <span class="keywordflow">case</span> <a class="code" href="classSgAsmFunction.html#d1e0c37f9e507fc6acaf01dd0794a7520d3fbe8fb9b711a6ca66ef2f09824496">SgAsmFunction::RET_UNKNOWN</a>:
<a name="l00558"></a>00558             <a class="code" href="classPartitioner_1_1Function.html#4325b671ee6d062df9dc9e4c8868ac4a">set_may_return</a>(new_value);
<a name="l00559"></a>00559             <span class="keywordflow">break</span>;
<a name="l00560"></a>00560         <span class="keywordflow">case</span> <a class="code" href="classSgAsmFunction.html#d1e0c37f9e507fc6acaf01dd0794a752921b64c76e93f8581fd16c205aac1516">SgAsmFunction::RET_SOMETIMES</a>:
<a name="l00561"></a>00561             <span class="keywordflow">if</span> (<a class="code" href="classSgAsmFunction.html#d1e0c37f9e507fc6acaf01dd0794a7528cf02b4f0b67544a9fafcf0fbc28ee19">SgAsmFunction::RET_ALWAYS</a>==new_value || <a class="code" href="classSgAsmFunction.html#d1e0c37f9e507fc6acaf01dd0794a752df440ebe371c3f4fdc1612448157f6bc">SgAsmFunction::RET_NEVER</a>==new_value)
<a name="l00562"></a>00562                 <a class="code" href="classPartitioner_1_1Function.html#4325b671ee6d062df9dc9e4c8868ac4a">set_may_return</a>(new_value);
<a name="l00563"></a>00563             <span class="keywordflow">break</span>;
<a name="l00564"></a>00564         <span class="keywordflow">case</span> <a class="code" href="classSgAsmFunction.html#d1e0c37f9e507fc6acaf01dd0794a7528cf02b4f0b67544a9fafcf0fbc28ee19">SgAsmFunction::RET_ALWAYS</a>:
<a name="l00565"></a>00565         <span class="keywordflow">case</span> <a class="code" href="classSgAsmFunction.html#d1e0c37f9e507fc6acaf01dd0794a752df440ebe371c3f4fdc1612448157f6bc">SgAsmFunction::RET_NEVER</a>:
<a name="l00566"></a>00566             <span class="keywordflow">break</span>;
<a name="l00567"></a>00567     }
<a name="l00568"></a>00568 }
<a name="l00569"></a>00569 
<a name="l00570"></a>00570 <span class="keywordtype">void</span>
<a name="l00571"></a><a class="code" href="classPartitioner_1_1Function.html#b18318f8abc47eddd8a95ac05fa4cddc">00571</a> <a class="code" href="classPartitioner_1_1Function.html#b18318f8abc47eddd8a95ac05fa4cddc">Partitioner::Function::show_properties</a>(FILE *<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>)<span class="keyword"> const</span>
<a name="l00572"></a>00572 <span class="keyword"></span>{
<a name="l00573"></a>00573     <span class="keywordflow">if</span> (debug) {
<a name="l00574"></a>00574         std::string may_return_str = <a class="code" href="stringify_8C.html#692e7def5e9278227f2264de7c44440c">stringifySgAsmFunctionMayReturn</a>(<a class="code" href="classPartitioner_1_1Function.html#cca110ab4755cb256c8d5e1c338dea7f">get_may_return</a>(), <span class="stringliteral">"RET_"</span>);
<a name="l00575"></a>00575         <span class="keywordflow">for</span> (size_t i=0; i&lt;may_return_str.size(); ++i)
<a name="l00576"></a>00576             may_return_str[i] = tolower(may_return_str[i]);
<a name="l00577"></a>00577         fprintf(debug, <span class="stringliteral">"{nbblocks=%zu, ndblocks=%zu, may-return=%s}"</span>,
<a name="l00578"></a>00578                 <a class="code" href="classPartitioner_1_1Function.html#8bdb95ca10afda44f8dacb28248f5c6c">basic_blocks</a>.size(), <a class="code" href="classPartitioner_1_1Function.html#a4ec341f0aa8ef699a36dda8389036d8">data_blocks</a>.size(), may_return_str.c_str());
<a name="l00579"></a>00579     }
<a name="l00580"></a>00580 }
<a name="l00581"></a>00581 
<a name="l00582"></a>00582 <span class="comment">/* Return partitioner to initial state */</span>
<a name="l00583"></a>00583 <span class="keywordtype">void</span>
<a name="l00584"></a><a class="code" href="classPartitioner.html#d64a57bb09ffe9557d1ad51f2ca30bf8">00584</a> <a class="code" href="classPartitioner.html#d64a57bb09ffe9557d1ad51f2ca30bf8">Partitioner::clear</a>()
<a name="l00585"></a>00585 {
<a name="l00586"></a>00586     <span class="comment">/* Delete all functions */</span>
<a name="l00587"></a>00587     <span class="keywordflow">for</span> (Functions::iterator fi=<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.begin(); fi!=<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.end(); ++fi) {
<a name="l00588"></a>00588         fi-&gt;second-&gt;clear_basic_blocks();
<a name="l00589"></a>00589         fi-&gt;second-&gt;clear_data_blocks();
<a name="l00590"></a>00590         <span class="keyword">delete</span> fi-&gt;second;
<a name="l00591"></a>00591     }
<a name="l00592"></a>00592     <a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.clear();
<a name="l00593"></a>00593 
<a name="l00594"></a>00594     <span class="comment">/* Delete all basic blocks. We don't need to call Partitioner::discard() to fix up ptrs because all functions that might</span>
<a name="l00595"></a>00595 <span class="comment">     * have pointed to this block have already been deleted. */</span>
<a name="l00596"></a>00596     <span class="keywordflow">for</span> (BasicBlocks::iterator bi=<a class="code" href="classPartitioner.html#1f1a02cff90220dd026d8a344404fbea">basic_blocks</a>.begin(); bi!=<a class="code" href="classPartitioner.html#1f1a02cff90220dd026d8a344404fbea">basic_blocks</a>.end(); ++bi)
<a name="l00597"></a>00597         <span class="keyword">delete</span> bi-&gt;second;
<a name="l00598"></a>00598     <a class="code" href="classPartitioner.html#1f1a02cff90220dd026d8a344404fbea">basic_blocks</a>.clear();
<a name="l00599"></a>00599 
<a name="l00600"></a>00600     <span class="comment">/* Delete all data blocks, but not the SgAsmStaticData nodes to which they point. */</span>
<a name="l00601"></a>00601     <span class="keywordflow">for</span> (DataBlocks::iterator bi=<a class="code" href="classPartitioner.html#b8b08dc01aab15b7ae2dff4af899046f">data_blocks</a>.begin(); bi!=<a class="code" href="classPartitioner.html#b8b08dc01aab15b7ae2dff4af899046f">data_blocks</a>.end(); ++bi)
<a name="l00602"></a>00602         <span class="keyword">delete</span> bi-&gt;second;
<a name="l00603"></a>00603     <a class="code" href="classPartitioner.html#b8b08dc01aab15b7ae2dff4af899046f">data_blocks</a>.clear();
<a name="l00604"></a>00604 
<a name="l00605"></a>00605     <span class="comment">/* Delete all block IPD configuration data. */</span>
<a name="l00606"></a>00606     <span class="keywordflow">for</span> (BlockConfigMap::iterator bci=<a class="code" href="classPartitioner.html#e4d5b142571b09b4cb8e77016991d3d0">block_config</a>.begin(); bci!=<a class="code" href="classPartitioner.html#e4d5b142571b09b4cb8e77016991d3d0">block_config</a>.end(); ++bci)
<a name="l00607"></a>00607         <span class="keyword">delete</span> bci-&gt;second;
<a name="l00608"></a>00608     <a class="code" href="classPartitioner.html#e4d5b142571b09b4cb8e77016991d3d0">block_config</a>.clear();
<a name="l00609"></a>00609 
<a name="l00610"></a>00610     <span class="comment">/* Delete all instructions by deleting the Partitioner::Instruction objects, but not the underlying SgAsmInstruction</span>
<a name="l00611"></a>00611 <span class="comment">     * objects because the latter might be used by whatever's calling the Partitioner. */</span>
<a name="l00612"></a>00612     <span class="keywordflow">for</span> (InstructionMap::iterator ii=<a class="code" href="classPartitioner.html#f9d5d92a9d9ca6a35ade7c5b3906ab97">insns</a>.begin(); ii!=<a class="code" href="classPartitioner.html#f9d5d92a9d9ca6a35ade7c5b3906ab97">insns</a>.end(); ++ii)
<a name="l00613"></a>00613         <span class="keyword">delete</span> ii-&gt;second;
<a name="l00614"></a>00614     <a class="code" href="classPartitioner.html#f9d5d92a9d9ca6a35ade7c5b3906ab97">insns</a>.clear();
<a name="l00615"></a>00615 
<a name="l00616"></a>00616     <span class="comment">/* Clear all disassembly failures from the cache. */</span>
<a name="l00617"></a>00617     <a class="code" href="classPartitioner.html#f993c26936e910eedaa5b433a74e70b3">clear_disassembler_errors</a>();
<a name="l00618"></a>00618 
<a name="l00619"></a>00619     <span class="comment">/* Clear statistics and code criteria.  This object manages memory for its statistics, but the caller manages the memory</span>
<a name="l00620"></a>00620 <span class="comment">     * for the code criteria. */</span>
<a name="l00621"></a>00621     <span class="keyword">delete</span> <a class="code" href="classPartitioner.html#4862f9ab22b50ad90a880ff7d16031ab">aggregate_mean</a>;           <a class="code" href="classPartitioner.html#4862f9ab22b50ad90a880ff7d16031ab">aggregate_mean</a>     = NULL;
<a name="l00622"></a>00622     <span class="keyword">delete</span> <a class="code" href="classPartitioner.html#a129e066f5e94444fb2a29b3d18bdf04">aggregate_variance</a>;       <a class="code" href="classPartitioner.html#a129e066f5e94444fb2a29b3d18bdf04">aggregate_variance</a> = NULL;
<a name="l00623"></a>00623     <a class="code" href="classPartitioner.html#068adcb53c802118a44b8d8fb0ee653c">code_criteria</a> = NULL; <span class="comment">// owned by user</span>
<a name="l00624"></a>00624 }
<a name="l00625"></a>00625 
<a name="l00626"></a>00626 <span class="keywordtype">void</span>
<a name="l00627"></a><a class="code" href="classPartitioner.html#7adb0e1cb0359b14d928ad1d7ffd0a03">00627</a> <a class="code" href="classPartitioner.html#7adb0e1cb0359b14d928ad1d7ffd0a03">Partitioner::load_config</a>(<span class="keyword">const</span> std::string &amp;filename) {
<a name="l00628"></a>00628     <span class="keywordflow">if</span> (filename.empty())
<a name="l00629"></a>00629         <span class="keywordflow">return</span>;
<a name="l00630"></a>00630 <span class="preprocessor">#ifdef _MSC_VER </span><span class="comment">/* tps (06/23/2010) : Does not work under Windows */</span>
<a name="l00631"></a>00631     <span class="keywordflow">throw</span> <a class="code" href="classPartitioner_1_1IPDParser_1_1Exception.html">IPDParser::Exception</a>(<span class="stringliteral">"IPD parsing not supported on Windows platforms"</span>);
<a name="l00632"></a>00632 <span class="preprocessor">#else</span>
<a name="l00633"></a>00633 <span class="preprocessor"></span>    <span class="keywordtype">int</span> fd = open(filename.c_str(), O_RDONLY);
<a name="l00634"></a>00634     <span class="keywordflow">if</span> (fd&lt;0)
<a name="l00635"></a>00635         <span class="keywordflow">throw</span> <a class="code" href="classPartitioner_1_1IPDParser_1_1Exception.html">IPDParser::Exception</a>(strerror(errno), filename);
<a name="l00636"></a>00636     <span class="keyword">struct </span>stat sb;
<a name="l00637"></a>00637     fstat(fd, &amp;sb);
<a name="l00638"></a>00638     <span class="keywordtype">char</span> *config = <span class="keyword">new</span> <span class="keywordtype">char</span>[sb.st_size];
<a name="l00639"></a>00639     ssize_t nread = read(fd, config, sb.st_size);
<a name="l00640"></a>00640     <span class="keywordflow">if</span> (nread&lt;0 || nread&lt;sb.st_size) {
<a name="l00641"></a>00641         <span class="keyword">delete</span>[] config;
<a name="l00642"></a>00642         close(fd);
<a name="l00643"></a>00643         <span class="keywordflow">throw</span> <a class="code" href="classPartitioner_1_1IPDParser_1_1Exception.html">IPDParser::Exception</a>(strerror(errno), filename);
<a name="l00644"></a>00644     }
<a name="l00645"></a>00645     <a class="code" href="classPartitioner_1_1IPDParser.html">IPDParser</a>(<span class="keyword">this</span>, config, sb.st_size, filename).parse();
<a name="l00646"></a>00646     <span class="keyword">delete</span>[] config;
<a name="l00647"></a>00647     close(fd);
<a name="l00648"></a>00648 <span class="preprocessor">#endif</span>
<a name="l00649"></a>00649 <span class="preprocessor"></span>}
<a name="l00650"></a>00650 
<a name="l00658"></a>00658 <span class="keywordtype">void</span>
<a name="l00659"></a><a class="code" href="classPartitioner.html#a1fd20a852585175fc0be71ef5bd97bd">00659</a> <a class="code" href="classPartitioner.html#a1fd20a852585175fc0be71ef5bd97bd">Partitioner::truncate</a>(<a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a>* bb, <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va)
<a name="l00660"></a>00660 {
<a name="l00661"></a>00661     assert(bb);
<a name="l00662"></a>00662     assert(bb==<a class="code" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">find_bb_containing</a>(va));
<a name="l00663"></a>00663 
<a name="l00664"></a>00664     <span class="comment">/* Find the cut point in the instruction vector. I.e., the first instruction to remove from the vector. */</span>
<a name="l00665"></a>00665     InstructionVector::iterator cut = bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.begin();
<a name="l00666"></a>00666     <span class="keywordflow">while</span> (cut!=bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.end() &amp;&amp; (*cut)-&gt;get_address()!=va) ++cut;
<a name="l00667"></a>00667     assert(cut!=bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.begin()); <span class="comment">/*we can't remove them all since basic blocks are never empty*/</span>
<a name="l00668"></a>00668 
<a name="l00669"></a>00669     <span class="comment">/* Remove instructions (from the cut point and beyond) and all the data blocks. */</span>
<a name="l00670"></a>00670     <span class="keywordflow">for</span> (InstructionVector::iterator ii=cut; ii!=bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.end(); ++ii) {
<a name="l00671"></a>00671         <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a> *insn = *ii;
<a name="l00672"></a>00672         assert(insn-&gt;bblock==bb);
<a name="l00673"></a>00673         insn-&gt;bblock = NULL;
<a name="l00674"></a>00674     }
<a name="l00675"></a>00675     <span class="keywordflow">if</span> (cut!=bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.end()) {
<a name="l00676"></a>00676         bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.erase(cut, bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.end());
<a name="l00677"></a>00677         bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#23febe57dd258c7426a39980c2f1b511">clear_data_blocks</a>();
<a name="l00678"></a>00678     }
<a name="l00679"></a>00679 }
<a name="l00680"></a>00680 
<a name="l00681"></a>00681 <span class="comment">/* Append instruction to basic block */</span>
<a name="l00682"></a>00682 <span class="keywordtype">void</span>
<a name="l00683"></a><a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">00683</a> <a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">Partitioner::append</a>(<a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a>* bb, <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a>* insn)
<a name="l00684"></a>00684 {
<a name="l00685"></a>00685     assert(bb);
<a name="l00686"></a>00686     assert(insn);
<a name="l00687"></a>00687     assert(NULL==insn-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#4ca5b571a28bd3a9fb719baec4b99777">bblock</a>); <span class="comment">/* insn must not have already belonged to a basic block */</span>
<a name="l00688"></a>00688     insn-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#4ca5b571a28bd3a9fb719baec4b99777">bblock</a> = bb;
<a name="l00689"></a>00689     bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.push_back(insn);
<a name="l00690"></a>00690 }
<a name="l00691"></a>00691 
<a name="l00701"></a>00701 <span class="keywordtype">void</span>
<a name="l00702"></a><a class="code" href="classPartitioner.html#ba38c7356f1455b1eafdfdfdfba7ec80">00702</a> <a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">Partitioner::append</a>(<a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb, <a class="code" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *db, <span class="keywordtype">unsigned</span> reason)
<a name="l00703"></a>00703 {
<a name="l00704"></a>00704     assert(bb!=NULL);
<a name="l00705"></a>00705     assert(db!=NULL);
<a name="l00706"></a>00706     db-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#024f1606c04323776f0958542e451ac2">reason</a> |= reason;
<a name="l00707"></a>00707 
<a name="l00708"></a>00708     <span class="keywordflow">if</span> (db-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#00e9f5268dbd139a8f076452fde6efa2">basic_block</a>!=NULL)
<a name="l00709"></a>00709         db-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#00e9f5268dbd139a8f076452fde6efa2">basic_block</a>-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#78c634ed49a131d7c2e6e302f78d0e55">data_blocks</a>.erase(db);
<a name="l00710"></a>00710 
<a name="l00711"></a>00711     bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#78c634ed49a131d7c2e6e302f78d0e55">data_blocks</a>.insert(db);
<a name="l00712"></a>00712     db-&gt;basic_block = bb;
<a name="l00713"></a>00713 }
<a name="l00714"></a>00714 
<a name="l00726"></a>00726 <span class="keywordtype">void</span>
<a name="l00727"></a><a class="code" href="classPartitioner.html#30f511a1deeb308d57ec9bcec8d16f0f">00727</a> <a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">Partitioner::append</a>(<a class="code" href="classPartitioner_1_1Function.html">Function</a>* f, <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb, <span class="keywordtype">unsigned</span> reason, <span class="keywordtype">bool</span> keep<span class="comment">/*=false*/</span>)
<a name="l00728"></a>00728 {
<a name="l00729"></a>00729     assert(f);
<a name="l00730"></a>00730     assert(bb);
<a name="l00731"></a>00731 
<a name="l00732"></a>00732     <span class="keywordflow">if</span> (keep)
<a name="l00733"></a>00733         f-&gt;<a class="code" href="classPartitioner_1_1Function.html#41ac95e38f7681fd66736276a833f931">heads</a>.insert(bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#7e120c89ba03d66a308381c0b82173c9">address</a>());
<a name="l00734"></a>00734     bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#601ae03fbe778f2497dea0e5a3493cf9">reason</a> |= reason;
<a name="l00735"></a>00735 
<a name="l00736"></a>00736     <span class="keywordflow">if</span> (bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>==f)
<a name="l00737"></a>00737         <span class="keywordflow">return</span>;
<a name="l00738"></a>00738 
<a name="l00739"></a>00739     assert(bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>==NULL);
<a name="l00740"></a>00740     bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a> = f;
<a name="l00741"></a>00741     f-&gt;<a class="code" href="classPartitioner_1_1Function.html#8bdb95ca10afda44f8dacb28248f5c6c">basic_blocks</a>[bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#7e120c89ba03d66a308381c0b82173c9">address</a>()] = bb;
<a name="l00742"></a>00742 
<a name="l00743"></a>00743     <span class="comment">/* If the block is a function return then mark the function as returning.  On a transition from a non-returning function</span>
<a name="l00744"></a>00744 <span class="comment">     * to a returning function, we must mark all calling functions as pending so that the fall-through address of their</span>
<a name="l00745"></a>00745 <span class="comment">     * function calls to this function are eventually discovered.  This includes recursive calls since we may have already</span>
<a name="l00746"></a>00746 <span class="comment">     * discovered the recursive call but not followed the fall-through address.  Marking callers as "pending" happens in the</span>
<a name="l00747"></a>00747 <span class="comment">     * analyze_cfg() method, were we can handle all the calls at the same time (more efficient than doing one at a time right</span>
<a name="l00748"></a>00748 <span class="comment">     * here). */</span>
<a name="l00749"></a>00749     <a class="code" href="classPartitioner.html#8652c15bcdd9d9dca2efb2d9f865f519">update_analyses</a>(bb);
<a name="l00750"></a>00750     <span class="keywordflow">if</span> (bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#a72f8961ccc40c25a9643634b35cd3cd">cache</a>.<a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#26b33ba9fb4b4fd4317f202e49c7fbf7">function_return</a>)
<a name="l00751"></a>00751         f-&gt;<a class="code" href="classPartitioner_1_1Function.html#aebf437238c29dadf3c29d078ed22549">promote_may_return</a>(<a class="code" href="classSgAsmFunction.html#d1e0c37f9e507fc6acaf01dd0794a752921b64c76e93f8581fd16c205aac1516">SgAsmFunction::RET_SOMETIMES</a>);
<a name="l00752"></a>00752 }
<a name="l00753"></a>00753 
<a name="l00763"></a>00763 <span class="keywordtype">void</span>
<a name="l00764"></a><a class="code" href="classPartitioner.html#7d6d934c7fe0e273e8edd1b4ecc5e36e">00764</a> <a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">Partitioner::append</a>(<a class="code" href="classPartitioner_1_1Function.html">Function</a> *func, <a class="code" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *block, <span class="keywordtype">unsigned</span> reason, <span class="keywordtype">bool</span> force)
<a name="l00765"></a>00765 {
<a name="l00766"></a>00766     assert(func);
<a name="l00767"></a>00767     assert(block);
<a name="l00768"></a>00768 
<a name="l00769"></a>00769     <span class="keywordflow">if</span> (force) {
<a name="l00770"></a>00770         <span class="keywordflow">if</span> (block-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#ef1d5b36cc38db48693a00b9de89ec1b">function</a>)
<a name="l00771"></a>00771             <a class="code" href="classPartitioner.html#7a886afe82a7fc7171bdc64ecfd379fb">remove</a>(block-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#ef1d5b36cc38db48693a00b9de89ec1b">function</a>, block);
<a name="l00772"></a>00772         <span class="keywordflow">if</span> (block-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#00e9f5268dbd139a8f076452fde6efa2">basic_block</a>)
<a name="l00773"></a>00773             <a class="code" href="classPartitioner.html#7a886afe82a7fc7171bdc64ecfd379fb">remove</a>(block-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#00e9f5268dbd139a8f076452fde6efa2">basic_block</a>, block);
<a name="l00774"></a>00774     }
<a name="l00775"></a>00775 
<a name="l00776"></a>00776     block-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#024f1606c04323776f0958542e451ac2">reason</a> |= reason;
<a name="l00777"></a>00777     <span class="keywordflow">if</span> (block-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#ef1d5b36cc38db48693a00b9de89ec1b">function</a>==func)
<a name="l00778"></a>00778         <span class="keywordflow">return</span>;
<a name="l00779"></a>00779 
<a name="l00780"></a>00780     assert(block-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#ef1d5b36cc38db48693a00b9de89ec1b">function</a>==NULL);
<a name="l00781"></a>00781     block-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#ef1d5b36cc38db48693a00b9de89ec1b">function</a> = func;
<a name="l00782"></a>00782     func-&gt;<a class="code" href="classPartitioner_1_1Function.html#a4ec341f0aa8ef699a36dda8389036d8">data_blocks</a>[block-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#30602458b400eee36e9c7b1298797250">address</a>()] = block;
<a name="l00783"></a>00783 }
<a name="l00784"></a>00784 
<a name="l00787"></a>00787 <span class="keywordtype">void</span>
<a name="l00788"></a><a class="code" href="classPartitioner.html#7a886afe82a7fc7171bdc64ecfd379fb">00788</a> <a class="code" href="classPartitioner.html#7a886afe82a7fc7171bdc64ecfd379fb">Partitioner::remove</a>(<a class="code" href="classPartitioner_1_1Function.html">Function</a>* f, <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a>* bb)
<a name="l00789"></a>00789 {
<a name="l00790"></a>00790     assert(f);
<a name="l00791"></a>00791     assert(bb);
<a name="l00792"></a>00792     assert(bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>==f);
<a name="l00793"></a>00793     bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a> = NULL;
<a name="l00794"></a>00794     f-&gt;<a class="code" href="classPartitioner_1_1Function.html#8bdb95ca10afda44f8dacb28248f5c6c">basic_blocks</a>.erase(bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#7e120c89ba03d66a308381c0b82173c9">address</a>());
<a name="l00795"></a>00795 }
<a name="l00796"></a>00796 
<a name="l00800"></a>00800 <span class="keywordtype">void</span>
<a name="l00801"></a><a class="code" href="classPartitioner.html#780baf904faf5b5eb57eec90b1b6c16b">00801</a> <a class="code" href="classPartitioner.html#7a886afe82a7fc7171bdc64ecfd379fb">Partitioner::remove</a>(<a class="code" href="classPartitioner_1_1Function.html">Function</a> *f, <a class="code" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *db)
<a name="l00802"></a>00802 {
<a name="l00803"></a>00803     assert(f);
<a name="l00804"></a>00804     assert(db);
<a name="l00805"></a>00805     assert(db-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#ef1d5b36cc38db48693a00b9de89ec1b">function</a>==f);
<a name="l00806"></a>00806     db-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#ef1d5b36cc38db48693a00b9de89ec1b">function</a> = NULL;
<a name="l00807"></a>00807     f-&gt;<a class="code" href="classPartitioner_1_1Function.html#a4ec341f0aa8ef699a36dda8389036d8">data_blocks</a>.erase(db-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#30602458b400eee36e9c7b1298797250">address</a>());
<a name="l00808"></a>00808 }
<a name="l00809"></a>00809 
<a name="l00812"></a>00812 <span class="keywordtype">void</span>
<a name="l00813"></a><a class="code" href="classPartitioner.html#7578d7e4a6ba2612a608fd19a550178e">00813</a> <a class="code" href="classPartitioner.html#7a886afe82a7fc7171bdc64ecfd379fb">Partitioner::remove</a>(<a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb, <a class="code" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *db)
<a name="l00814"></a>00814 {
<a name="l00815"></a>00815     assert(bb!=NULL);
<a name="l00816"></a>00816     <span class="keywordflow">if</span> (db &amp;&amp; db-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#00e9f5268dbd139a8f076452fde6efa2">basic_block</a>==bb) {
<a name="l00817"></a>00817         bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#78c634ed49a131d7c2e6e302f78d0e55">data_blocks</a>.erase(db);
<a name="l00818"></a>00818         db-&gt;basic_block = NULL;
<a name="l00819"></a>00819     }
<a name="l00820"></a>00820 }
<a name="l00821"></a>00821 
<a name="l00822"></a>00822 <span class="comment">/* Remove instruction from consideration. */</span>
<a name="l00823"></a>00823 <a class="code" href="classPartitioner_1_1Instruction.html">Partitioner::Instruction</a> *
<a name="l00824"></a><a class="code" href="classPartitioner.html#8b679c9a4b6fb7a7f4f45900d10819c0">00824</a> <a class="code" href="classPartitioner.html#8b679c9a4b6fb7a7f4f45900d10819c0">Partitioner::discard</a>(<a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a> *insn, <span class="keywordtype">bool</span> discard_entire_block)
<a name="l00825"></a>00825 {
<a name="l00826"></a>00826     <span class="keywordflow">if</span> (insn) {
<a name="l00827"></a>00827         <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va = insn-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#a9c8dd5cf80780b59c4e74e4bb8b2811">get_address</a>();
<a name="l00828"></a>00828         <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = <a class="code" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">find_bb_containing</a>(va, <span class="keyword">false</span>);
<a name="l00829"></a>00829         <span class="keywordflow">if</span> (bb) {
<a name="l00830"></a>00830             <span class="keywordflow">if</span> (discard_entire_block) {
<a name="l00831"></a>00831                 <a class="code" href="classPartitioner.html#8b679c9a4b6fb7a7f4f45900d10819c0">discard</a>(bb);
<a name="l00832"></a>00832             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.front()==insn) {
<a name="l00833"></a>00833                 <a class="code" href="classPartitioner.html#8b679c9a4b6fb7a7f4f45900d10819c0">discard</a>(bb);
<a name="l00834"></a>00834             } <span class="keywordflow">else</span> {
<a name="l00835"></a>00835                 <a class="code" href="classPartitioner.html#a1fd20a852585175fc0be71ef5bd97bd">truncate</a>(bb, va);
<a name="l00836"></a>00836             }
<a name="l00837"></a>00837         }
<a name="l00838"></a>00838         <a class="code" href="classPartitioner.html#f9d5d92a9d9ca6a35ade7c5b3906ab97">insns</a>.erase(va);
<a name="l00839"></a>00839     }
<a name="l00840"></a>00840     <span class="keywordflow">return</span> NULL;
<a name="l00841"></a>00841 }
<a name="l00842"></a>00842 
<a name="l00843"></a>00843 <span class="comment">/* Delete block, returning its instructions back to the (implied) list of free instructions. */</span>
<a name="l00844"></a>00844 <a class="code" href="structPartitioner_1_1BasicBlock.html">Partitioner::BasicBlock</a> *
<a name="l00845"></a><a class="code" href="classPartitioner.html#1ea949dc4beeb1444894ed978931e7b2">00845</a> <a class="code" href="classPartitioner.html#8b679c9a4b6fb7a7f4f45900d10819c0">Partitioner::discard</a>(<a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb)
<a name="l00846"></a>00846 {
<a name="l00847"></a>00847     <span class="keywordflow">if</span> (bb) {
<a name="l00848"></a>00848         assert(NULL==bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>);
<a name="l00849"></a>00849 
<a name="l00850"></a>00850         <span class="comment">/* Remove instructions from the block, returning them to the (implied) list of free instructions. */</span>
<a name="l00851"></a>00851         <span class="keywordflow">for</span> (InstructionVector::iterator ii=bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.begin(); ii!=bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.end(); ++ii) {
<a name="l00852"></a>00852             <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a> *insn = *ii;
<a name="l00853"></a>00853             assert(insn-&gt;bblock==bb);
<a name="l00854"></a>00854             insn-&gt;bblock = NULL;
<a name="l00855"></a>00855         }
<a name="l00856"></a>00856 
<a name="l00857"></a>00857         <span class="comment">/* Remove the association between data blocks and this basic block. */</span>
<a name="l00858"></a>00858         bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#23febe57dd258c7426a39980c2f1b511">clear_data_blocks</a>();
<a name="l00859"></a>00859 
<a name="l00860"></a>00860         <span class="comment">/* Remove the block from the partitioner. */</span>
<a name="l00861"></a>00861         <a class="code" href="classPartitioner.html#1f1a02cff90220dd026d8a344404fbea">basic_blocks</a>.erase(bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#7e120c89ba03d66a308381c0b82173c9">address</a>());
<a name="l00862"></a>00862         <span class="keyword">delete</span> bb;
<a name="l00863"></a>00863     }
<a name="l00864"></a>00864     <span class="keywordflow">return</span> NULL;
<a name="l00865"></a>00865 }
<a name="l00866"></a>00866 
<a name="l00867"></a>00867 <span class="comment">/* Finds (or possibly creates) an instruction beginning at the specified address. */</span>
<a name="l00868"></a>00868 <a class="code" href="classPartitioner_1_1Instruction.html">Partitioner::Instruction</a> *
<a name="l00869"></a><a class="code" href="classPartitioner.html#1dcdd3e0993256cd5ed93fd4d178679f">00869</a> <a class="code" href="classPartitioner.html#1dcdd3e0993256cd5ed93fd4d178679f">Partitioner::find_instruction</a>(<a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va, <span class="keywordtype">bool</span> create<span class="comment">/*=true*/</span>)
<a name="l00870"></a>00870 {
<a name="l00871"></a>00871     InstructionMap::iterator ii = <a class="code" href="classPartitioner.html#f9d5d92a9d9ca6a35ade7c5b3906ab97">insns</a>.find(va);
<a name="l00872"></a>00872     <span class="keywordflow">if</span> (create &amp;&amp; <a class="code" href="classPartitioner.html#320e02804f0d9ae5bc55e1ba26791a72">disassembler</a> &amp;&amp; ii==<a class="code" href="classPartitioner.html#f9d5d92a9d9ca6a35ade7c5b3906ab97">insns</a>.end() &amp;&amp; <a class="code" href="classPartitioner.html#44a78932a6c3307dbdd9d9327bbb3eba">bad_insns</a>.find(va)==<a class="code" href="classPartitioner.html#44a78932a6c3307dbdd9d9327bbb3eba">bad_insns</a>.end()) {
<a name="l00873"></a>00873         <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a> *insn = NULL;
<a name="l00874"></a>00874         <span class="keywordflow">try</span> {
<a name="l00875"></a>00875             insn = <span class="keyword">new</span> <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a>(<a class="code" href="classPartitioner.html#320e02804f0d9ae5bc55e1ba26791a72">disassembler</a>-&gt;<a class="code" href="classDisassembler.html#d765ce924af663d75b9ce5915d658d7c">disassembleOne</a>(<a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>, va, NULL));
<a name="l00876"></a>00876             ii = <a class="code" href="classPartitioner.html#f9d5d92a9d9ca6a35ade7c5b3906ab97">insns</a>.insert(std::make_pair(va, insn)).first;
<a name="l00877"></a>00877         } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classDisassembler_1_1Exception.html">Disassembler::Exception</a> &amp;e) {
<a name="l00878"></a>00878             <a class="code" href="classPartitioner.html#44a78932a6c3307dbdd9d9327bbb3eba">bad_insns</a>.insert(std::make_pair(va, e));
<a name="l00879"></a>00879         }
<a name="l00880"></a>00880     }
<a name="l00881"></a>00881     <span class="keywordflow">return</span> ii==<a class="code" href="classPartitioner.html#f9d5d92a9d9ca6a35ade7c5b3906ab97">insns</a>.end() ? NULL : ii-&gt;second;
<a name="l00882"></a>00882 }
<a name="l00883"></a>00883 
<a name="l00903"></a>00903 <a class="code" href="structPartitioner_1_1BasicBlock.html">Partitioner::BasicBlock</a> *
<a name="l00904"></a><a class="code" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">00904</a> <a class="code" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">Partitioner::find_bb_containing</a>(<a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va, <span class="keywordtype">bool</span> create<span class="comment">/*true*/</span>)
<a name="l00905"></a>00905 {
<a name="l00906"></a>00906     <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a> *insn = <a class="code" href="classPartitioner.html#1dcdd3e0993256cd5ed93fd4d178679f">find_instruction</a>(va);
<a name="l00907"></a>00907     <span class="keywordflow">if</span> (!insn)
<a name="l00908"></a>00908         <span class="keywordflow">return</span> NULL;
<a name="l00909"></a>00909     <span class="keywordflow">if</span> (!create || insn-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#4ca5b571a28bd3a9fb719baec4b99777">bblock</a>!=NULL)
<a name="l00910"></a>00910         <span class="keywordflow">return</span> insn-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#4ca5b571a28bd3a9fb719baec4b99777">bblock</a>;
<a name="l00911"></a>00911     <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = insn-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#4ca5b571a28bd3a9fb719baec4b99777">bblock</a>;
<a name="l00912"></a>00912     <span class="keywordflow">if</span> (!bb) {
<a name="l00913"></a>00913         bb = <span class="keyword">new</span> <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a>;
<a name="l00914"></a>00914         <a class="code" href="classPartitioner.html#1f1a02cff90220dd026d8a344404fbea">basic_blocks</a>.insert(std::make_pair(va, bb));
<a name="l00915"></a>00915     }
<a name="l00916"></a>00916 
<a name="l00917"></a>00917     <span class="keywordflow">while</span> (1) {
<a name="l00918"></a>00918         <a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">append</a>(bb, insn);
<a name="l00919"></a>00919 
<a name="l00920"></a>00920         <span class="comment">/* Find address of next instruction, or whether this insn is the end of the block */</span>
<a name="l00921"></a>00921         va += insn-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#46940b414c39f0fd10186868d40715f7">get_size</a>();
<a name="l00922"></a>00922         <span class="keywordflow">if</span> (insn-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#024965895dbe27a542b72c4900595120">terminatesBasicBlock</a>()) { <span class="comment">/*naively terminates?*/</span>
<a name="l00923"></a>00923             <span class="keywordtype">bool</span> complete;
<a name="l00924"></a>00924             <span class="keyword">const</span> <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a>&amp; sucs = <a class="code" href="classPartitioner.html#e2e3e09e5194ba8c87bc968b65b63e3c">successors</a>(bb, &amp;complete);
<a name="l00925"></a>00925             <span class="keywordflow">if</span> ((<a class="code" href="classPartitioner.html#61a820e23e3d57c012d0928aa9c4d1a2">func_heuristics</a> &amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852ceea34044afa2b5415dad4b39cf2aa51d">SgAsmFunction::FUNC_CALL_TARGET</a>) &amp;&amp; <a class="code" href="classPartitioner.html#9c333715d5d353bab9fd4f46ce2c2d8d">is_function_call</a>(bb, NULL)) {
<a name="l00926"></a>00926                 <span class="comment">/* When we are detecting functions based on x86 CALL instructions (or similar for other architectures) then</span>
<a name="l00927"></a>00927 <span class="comment">                 * the instruction after the CALL should never be part of this basic block. Otherwise allow the call to be</span>
<a name="l00928"></a>00928 <span class="comment">                 * part of the basic block initially and we'll split the block later if we need to. */</span>
<a name="l00929"></a>00929                 <span class="keywordflow">break</span>;
<a name="l00930"></a>00930             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#a89d8e06b1a855108422287a46b63b04">allow_discont_blocks</a>) {
<a name="l00931"></a>00931                 <span class="keywordflow">if</span> (!complete || sucs.size()!=1)
<a name="l00932"></a>00932                     <span class="keywordflow">break</span>;
<a name="l00933"></a>00933                 va = *(sucs.begin());
<a name="l00934"></a>00934             } <span class="keywordflow">else</span> {
<a name="l00935"></a>00935                 <span class="keywordflow">if</span> (!complete || sucs.size()!=1 || *(sucs.begin())!=va)
<a name="l00936"></a>00936                     <span class="keywordflow">break</span>;
<a name="l00937"></a>00937             }
<a name="l00938"></a>00938         }
<a name="l00939"></a>00939 
<a name="l00940"></a>00940         <span class="comment">/* Get the next instruction */</span>
<a name="l00941"></a>00941         insn = <a class="code" href="classPartitioner.html#1dcdd3e0993256cd5ed93fd4d178679f">find_instruction</a>(va);
<a name="l00942"></a>00942         <span class="keywordflow">if</span> (!insn || insn-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#4ca5b571a28bd3a9fb719baec4b99777">bblock</a>)
<a name="l00943"></a>00943             <span class="keywordflow">break</span>;
<a name="l00944"></a>00944     }
<a name="l00945"></a>00945     <span class="keywordflow">return</span> bb;
<a name="l00946"></a>00946 }
<a name="l00947"></a>00947 
<a name="l00951"></a>00951 <a class="code" href="structPartitioner_1_1BasicBlock.html">Partitioner::BasicBlock</a> *
<a name="l00952"></a><a class="code" href="classPartitioner.html#67702e97dcbfb27fa18f6186fe30538a">00952</a> <a class="code" href="classPartitioner.html#67702e97dcbfb27fa18f6186fe30538a">Partitioner::find_bb_starting</a>(<a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va, <span class="keywordtype">bool</span> create<span class="comment">/*true*/</span>)
<a name="l00953"></a>00953 {
<a name="l00954"></a>00954     <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = <a class="code" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">find_bb_containing</a>(va, create);
<a name="l00955"></a>00955     <span class="keywordflow">if</span> (!bb)
<a name="l00956"></a>00956         <span class="keywordflow">return</span> NULL;
<a name="l00957"></a>00957     <span class="keywordflow">if</span> (va==bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#7e120c89ba03d66a308381c0b82173c9">address</a>())
<a name="l00958"></a>00958         <span class="keywordflow">return</span> bb;
<a name="l00959"></a>00959     <span class="keywordflow">if</span> (!create)
<a name="l00960"></a>00960         <span class="keywordflow">return</span> NULL;
<a name="l00961"></a>00961     <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>)
<a name="l00962"></a>00962         fprintf(<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">"[split from B%08"</span>PRIx64<span class="stringliteral">"#%zu]"</span>, bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#7e120c89ba03d66a308381c0b82173c9">address</a>(), bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.size());
<a name="l00963"></a>00963     <span class="keywordflow">if</span> (bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>!=NULL)
<a name="l00964"></a>00964         bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>-&gt;<a class="code" href="classPartitioner_1_1Function.html#d433af52820775a021eeae99f8e31ff2">pending</a> = <span class="keyword">true</span>;
<a name="l00965"></a>00965     <a class="code" href="classPartitioner.html#a1fd20a852585175fc0be71ef5bd97bd">truncate</a>(bb, va);
<a name="l00966"></a>00966     bb = <a class="code" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">find_bb_containing</a>(va);
<a name="l00967"></a>00967     assert(bb!=NULL);
<a name="l00968"></a>00968     assert(va==bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#7e120c89ba03d66a308381c0b82173c9">address</a>());
<a name="l00969"></a>00969     <span class="keywordflow">return</span> bb;
<a name="l00970"></a>00970 }
<a name="l00971"></a>00971 
<a name="l00975"></a>00975 <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>
<a name="l00976"></a><a class="code" href="classPartitioner.html#bd63242c67a32e6de5434d21956a01bf">00976</a> <a class="code" href="classPartitioner.html#bd63242c67a32e6de5434d21956a01bf">Partitioner::canonic_block</a>(<a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va)
<a name="l00977"></a>00977 {
<a name="l00978"></a>00978     <span class="keywordflow">for</span> (size_t i=0; i&lt;100; i++) {
<a name="l00979"></a>00979         <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = <a class="code" href="classPartitioner.html#67702e97dcbfb27fa18f6186fe30538a">find_bb_starting</a>(va, <span class="keyword">false</span>);
<a name="l00980"></a>00980         <span class="keywordflow">if</span> (!bb || !bb-&gt;cache.alias_for) <span class="keywordflow">return</span> va;
<a name="l00981"></a>00981         if (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) fprintf(debug, <span class="stringliteral">"[B%08"</span>PRIx64<span class="stringliteral">"-&gt;B%08"</span>PRIx64<span class="stringliteral">"]"</span>, va, bb-&gt;cache.alias_for);
<a name="l00982"></a>00982         va = bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#a72f8961ccc40c25a9643634b35cd3cd">cache</a>.<a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#f467853c71f06381965defc324078562">alias_for</a>;
<a name="l00983"></a>00983     }
<a name="l00984"></a>00984     assert(!<span class="stringliteral">"possible alias loop"</span>);
<a name="l00985"></a>00985     <span class="keywordflow">return</span> va;
<a name="l00986"></a>00986 }
<a name="l00987"></a>00987 
<a name="l00988"></a>00988 <span class="comment">/* Finds an existing function definition. */</span>
<a name="l00989"></a>00989 <a class="code" href="classPartitioner_1_1Function.html">Partitioner::Function</a> *
<a name="l00990"></a><a class="code" href="classPartitioner.html#e9238319a8257ac90435cce78d96dc9d">00990</a> <a class="code" href="classPartitioner.html#e9238319a8257ac90435cce78d96dc9d">Partitioner::find_function</a>(<a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> entry_va)
<a name="l00991"></a>00991 {
<a name="l00992"></a>00992     Functions::iterator fi = <a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.find(entry_va);
<a name="l00993"></a>00993     <span class="keywordflow">if</span> (fi==<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.end()) <span class="keywordflow">return</span> NULL;
<a name="l00994"></a>00994     <span class="keywordflow">return</span> fi-&gt;second;
<a name="l00995"></a>00995 }
<a name="l00996"></a>00996 
<a name="l00997"></a>00997 <span class="comment">/* Adds or updates a function definition. */</span>
<a name="l00998"></a>00998 <a class="code" href="classPartitioner_1_1Function.html">Partitioner::Function</a> *
<a name="l00999"></a><a class="code" href="classPartitioner.html#91e9b8ad59e4657d6f3dbece95752a4e">00999</a> <a class="code" href="classPartitioner.html#91e9b8ad59e4657d6f3dbece95752a4e">Partitioner::add_function</a>(<a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> entry_va, <span class="keywordtype">unsigned</span> reasons, std::string name)
<a name="l01000"></a>01000 {
<a name="l01001"></a>01001     <a class="code" href="classPartitioner_1_1Function.html">Function</a> *f = NULL;
<a name="l01002"></a>01002     Functions::iterator fi = <a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.find(entry_va);
<a name="l01003"></a>01003     <span class="keywordflow">if</span> (fi==<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.end()) {
<a name="l01004"></a>01004         f = <span class="keyword">new</span> <a class="code" href="classPartitioner_1_1Function.html">Function</a>(entry_va, reasons, name);
<a name="l01005"></a>01005         <a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>[entry_va] = f;
<a name="l01006"></a>01006     } <span class="keywordflow">else</span> {
<a name="l01007"></a>01007         f = fi-&gt;second;
<a name="l01008"></a>01008         assert(f-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>==entry_va);
<a name="l01009"></a>01009         <span class="keywordflow">if</span> (reasons &amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852ccb6d9cc5789fcc0c98bb6e6894831228">SgAsmFunction::FUNC_MISCMASK</a>)
<a name="l01010"></a>01010             f-&gt;<a class="code" href="classPartitioner_1_1Function.html#84232118f03482d3eb09c76063ef73ef">reason</a> &amp;= ~<a class="code" href="classSgAsmFunction.html">SgAsmFunction</a>::FUNC_MISCMASK;
<a name="l01011"></a>01011         f-&gt;<a class="code" href="classPartitioner_1_1Function.html#84232118f03482d3eb09c76063ef73ef">reason</a> |= reasons;
<a name="l01012"></a>01012         <span class="keywordflow">if</span> (name!=<span class="stringliteral">""</span>) f-&gt;<a class="code" href="classPartitioner_1_1Function.html#3445a927f772aa09859896fa5681eb62">name</a> = name;
<a name="l01013"></a>01013     }
<a name="l01014"></a>01014     <span class="keywordflow">return</span> f;
<a name="l01015"></a>01015 }
<a name="l01016"></a>01016 
<a name="l01017"></a>01017 <span class="comment">/* Do whatever's necessary to finish loading IPD configuration. */</span>
<a name="l01018"></a>01018 <span class="keywordtype">void</span>
<a name="l01019"></a><a class="code" href="classPartitioner.html#fd2b60293bc45d47e74befebde631533">01019</a> <a class="code" href="classPartitioner.html#fd2b60293bc45d47e74befebde631533">Partitioner::mark_ipd_configuration</a>()
<a name="l01020"></a>01020 {
<a name="l01021"></a>01021     <span class="keyword">using namespace </span>BinaryAnalysis::InstructionSemantics;
<a name="l01022"></a>01022 
<a name="l01023"></a>01023     <span class="keywordflow">for</span> (BlockConfigMap::iterator bci=<a class="code" href="classPartitioner.html#e4d5b142571b09b4cb8e77016991d3d0">block_config</a>.begin(); bci!=<a class="code" href="classPartitioner.html#e4d5b142571b09b4cb8e77016991d3d0">block_config</a>.end(); ++bci) {
<a name="l01024"></a>01024         <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va = bci-&gt;first;
<a name="l01025"></a>01025         <a class="code" href="structPartitioner_1_1BlockConfig.html">BlockConfig</a> *bconf = bci-&gt;second;
<a name="l01026"></a>01026 
<a name="l01027"></a>01027         <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = <a class="code" href="classPartitioner.html#67702e97dcbfb27fa18f6186fe30538a">find_bb_starting</a>(va);
<a name="l01028"></a>01028         <span class="keywordflow">if</span> (!bb)
<a name="l01029"></a>01029             <span class="keywordflow">throw</span> <a class="code" href="structPartitioner_1_1Exception.html">Exception</a>(<span class="stringliteral">"cannot obtain IPD-specified basic block at "</span> + <a class="code" href="namespaceStringUtility.html#b07dfdb6df484680f9a29ad4fcf79f80">StringUtility::addrToString</a>(va));
<a name="l01030"></a>01030         <span class="keywordflow">if</span> (bb-&gt;insns.size()&lt;bconf-&gt;ninsns)
<a name="l01031"></a>01031             <span class="keywordflow">throw</span> <a class="code" href="structPartitioner_1_1Exception.html">Exception</a>(<span class="stringliteral">"cannot obtain "</span> + <a class="code" href="namespaceStringUtility.html#e60d57efaa1e2a94776bd42908d62de5">StringUtility::numberToString</a>(bconf-&gt;ninsns) + <span class="stringliteral">"-instruction basic block at "</span> +
<a name="l01032"></a>01032                             <a class="code" href="namespaceStringUtility.html#b07dfdb6df484680f9a29ad4fcf79f80">StringUtility::addrToString</a>(va) + <span class="stringliteral">" (only "</span> + <a class="code" href="namespaceStringUtility.html#e60d57efaa1e2a94776bd42908d62de5">StringUtility::numberToString</a>(bb-&gt;insns.size()) +
<a name="l01033"></a>01033                             <span class="stringliteral">" available)"</span>);
<a name="l01034"></a>01034         <span class="keywordflow">if</span> (bb-&gt;insns.size()&gt;bconf-&gt;ninsns)
<a name="l01035"></a>01035             <a class="code" href="classPartitioner.html#a1fd20a852585175fc0be71ef5bd97bd">truncate</a>(bb, bb-&gt;insns[bconf-&gt;ninsns]-&gt;get_address());
<a name="l01036"></a>01036 
<a name="l01037"></a>01037         <span class="comment">/* Initial analysis followed augmented by settings from the configuration. */</span>
<a name="l01038"></a>01038         <a class="code" href="classPartitioner.html#8652c15bcdd9d9dca2efb2d9f865f519">update_analyses</a>(bb);
<a name="l01039"></a>01039         bb-&gt;cache.alias_for = bconf-&gt;alias_for;
<a name="l01040"></a>01040         <span class="keywordflow">if</span> (bconf-&gt;sucs_specified) {
<a name="l01041"></a>01041             bb-&gt;cache.sucs = bconf-&gt;sucs;
<a name="l01042"></a>01042             bb-&gt;cache.sucs_complete = bconf-&gt;sucs_complete;
<a name="l01043"></a>01043         }
<a name="l01044"></a>01044         <span class="keywordflow">if</span> (!bconf-&gt;sucs_program.empty()) {
<a name="l01045"></a>01045             <span class="comment">/* "Execute" the program that will detect successors. We do this by interpreting the basic block to initialize</span>
<a name="l01046"></a>01046 <span class="comment">             * registers, loading the successor program, pushing some arguments onto the program's stack, interpreting the</span>
<a name="l01047"></a>01047 <span class="comment">             * program, extracting return values from memory, and unloading the program. */</span>
<a name="l01048"></a>01048             <span class="keywordtype">bool</span> <a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a> = <span class="keyword">false</span>;
<a name="l01049"></a>01049             <span class="keywordtype">char</span> block_name_str[64];
<a name="l01050"></a>01050             sprintf(block_name_str, <span class="stringliteral">"B%08"</span>PRIx64, va);
<a name="l01051"></a>01051             std::string block_name = block_name_str;
<a name="l01052"></a>01052             <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) fprintf(stderr, <span class="stringliteral">"running successors program for %s\n"</span>, block_name_str);
<a name="l01053"></a>01053 
<a name="l01054"></a>01054             <span class="comment">// FIXME: Use a copy (COW) version of the map so we don't need to modify the real map and so that the simulated</span>
<a name="l01055"></a>01055             <span class="comment">// program can't accidentally modify the stuff being disassembled. [RPM 2012-05-07]</span>
<a name="l01056"></a>01056             <a class="code" href="classMemoryMap.html">MemoryMap</a> *<a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a> = <a class="code" href="classPartitioner.html#697de2be7e07894883304357a546438b">get_map</a>();
<a name="l01057"></a>01057             assert(<a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>!=NULL);
<a name="l01058"></a>01058             <span class="keyword">typedef</span> PartialSymbolicSemantics::Policy&lt;&gt; Policy;
<a name="l01059"></a>01059             <span class="keyword">typedef</span> X86InstructionSemantics&lt;Policy, PartialSymbolicSemantics::ValueType&gt; Semantics;
<a name="l01060"></a>01060             Policy policy;
<a name="l01061"></a>01061             policy.set_map(<a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>);
<a name="l01062"></a>01062             Semantics semantics(policy);
<a name="l01063"></a>01063 
<a name="l01064"></a>01064             <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) fprintf(stderr, <span class="stringliteral">"  running semantics for the basic block...\n"</span>);
<a name="l01065"></a>01065             <span class="keywordflow">for</span> (InstructionVector::iterator ii=bb-&gt;insns.begin(); ii!=bb-&gt;insns.end(); ++ii) {
<a name="l01066"></a>01066                 <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(*ii);
<a name="l01067"></a>01067                 assert(insn!=NULL);
<a name="l01068"></a>01068                 semantics.processInstruction(insn);
<a name="l01069"></a>01069             }
<a name="l01070"></a>01070 
<a name="l01071"></a>01071             <span class="comment">/* Load the program. Keep at least one unmapped byte between the program text, stack, and svec areas in order to</span>
<a name="l01072"></a>01072 <span class="comment">             * help with debugging. */</span>
<a name="l01073"></a>01073             <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) fprintf(stderr, <span class="stringliteral">"  loading the program...\n"</span>);
<a name="l01074"></a>01074 
<a name="l01075"></a>01075             <span class="comment">/* Load the instructions to execute */</span>
<a name="l01076"></a>01076             <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> text_va = <a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>-&gt;<a class="code" href="classMemoryMap.html#99e2f3d47ce36283671962e5f6ee93f5">find_free</a>(0, bconf-&gt;sucs_program.size(), 4096);
<a name="l01077"></a>01077             <a class="code" href="classMemoryMap_1_1Segment.html">MemoryMap::Segment</a> text_sgmt(<a class="code" href="classMemoryMap_1_1ExternBuffer.html#84cf5d396b6cca4a0f4289b6f80e7982">MemoryMap::ExternBuffer::create</a>(&amp;(bconf-&gt;sucs_program[0]), bconf-&gt;sucs_program.size()),
<a name="l01078"></a>01078                                          0, <a class="code" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd57589290f94ccb75d2e8b659c4ef50bb700">MemoryMap::MM_PROT_RX</a>, block_name + <span class="stringliteral">" successors program text"</span>);
<a name="l01079"></a>01079             <a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>-&gt;<a class="code" href="classMemoryMap.html#d8b51b8c73d8bb8d5922cbf1360800ef">insert</a>(<a class="code" href="Cxx__Grammar_8h.html#d8e49820aaa106bb8a2dc17d9ad38d87">Extent</a>(text_va, bconf-&gt;sucs_program.size()), text_sgmt);
<a name="l01080"></a>01080 
<a name="l01081"></a>01081             <span class="comment">/* Create a stack */</span>
<a name="l01082"></a>01082             <span class="keyword">static</span> <span class="keyword">const</span> size_t stack_size = 8192;
<a name="l01083"></a>01083             <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> stack_va = <a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>-&gt;<a class="code" href="classMemoryMap.html#99e2f3d47ce36283671962e5f6ee93f5">find_free</a>(text_va+bconf-&gt;sucs_program.size()+1, stack_size, 4096);
<a name="l01084"></a>01084             <a class="code" href="classMemoryMap_1_1Segment.html">MemoryMap::Segment</a> stack_sgmt(<a class="code" href="classMemoryMap_1_1AnonymousBuffer.html#c505a126ddae1c6be6630c47b69b8fad">MemoryMap::AnonymousBuffer::create</a>(stack_size), 0,
<a name="l01085"></a>01085                                           <a class="code" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd5757928ac57b8a90b020a73405a03fdfe3d">MemoryMap::MM_PROT_RW</a>, block_name + <span class="stringliteral">" successors stack"</span>);
<a name="l01086"></a>01086             <a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>-&gt;<a class="code" href="classMemoryMap.html#d8b51b8c73d8bb8d5922cbf1360800ef">insert</a>(<a class="code" href="Cxx__Grammar_8h.html#d8e49820aaa106bb8a2dc17d9ad38d87">Extent</a>(stack_va, stack_size), stack_sgmt);
<a name="l01087"></a>01087             <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> stack_ptr = stack_va + stack_size;
<a name="l01088"></a>01088 
<a name="l01089"></a>01089             <span class="comment">/* Create an area for the returned vector of successors */</span>
<a name="l01090"></a>01090             <span class="keyword">static</span> <span class="keyword">const</span> size_t svec_size = 8192;
<a name="l01091"></a>01091             <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> svec_va = <a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>-&gt;<a class="code" href="classMemoryMap.html#99e2f3d47ce36283671962e5f6ee93f5">find_free</a>(stack_va+stack_size+1, svec_size, 4096);
<a name="l01092"></a>01092             <a class="code" href="classMemoryMap_1_1Segment.html">MemoryMap::Segment</a> svec_sgmt(<a class="code" href="classMemoryMap_1_1AnonymousBuffer.html#c505a126ddae1c6be6630c47b69b8fad">MemoryMap::AnonymousBuffer::create</a>(svec_size), 0,
<a name="l01093"></a>01093                                          <a class="code" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd5757928ac57b8a90b020a73405a03fdfe3d">MemoryMap::MM_PROT_RW</a>, block_name + <span class="stringliteral">" successors vector"</span>);
<a name="l01094"></a>01094             <a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>-&gt;<a class="code" href="classMemoryMap.html#d8b51b8c73d8bb8d5922cbf1360800ef">insert</a>(<a class="code" href="Cxx__Grammar_8h.html#d8e49820aaa106bb8a2dc17d9ad38d87">Extent</a>(svec_va, svec_size), svec_sgmt);
<a name="l01095"></a>01095 
<a name="l01096"></a>01096             <span class="comment">/* What is the "return" address. Eventually the successors program will execute a "RET" instruction that will</span>
<a name="l01097"></a>01097 <span class="comment">             * return to this address.  We can choose something arbitrary as long as it doesn't conflict with anything else.</span>
<a name="l01098"></a>01098 <span class="comment">             * We'll use the first byte past the end of the successor program, which gives the added benefit that the</span>
<a name="l01099"></a>01099 <span class="comment">             * successor program doesn't actually have to even return -- it can just fall off the end. */</span>
<a name="l01100"></a>01100             <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> return_va = text_va + bconf-&gt;sucs_program.size();
<a name="l01101"></a>01101             <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) {
<a name="l01102"></a>01102                 fprintf(stderr, <span class="stringliteral">"    memory map after program is loaded:\n"</span>);
<a name="l01103"></a>01103                 <a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>-&gt;<a class="code" href="classMemoryMap.html#c45b1135441de2185b0b72c858066911">dump</a>(stderr, <span class="stringliteral">"      "</span>);
<a name="l01104"></a>01104             }
<a name="l01105"></a>01105 
<a name="l01106"></a>01106             <span class="comment">/* Push arguments onto the stack in reverse order. */</span>
<a name="l01107"></a>01107             <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) fprintf(stderr, <span class="stringliteral">"  setting up the call frame...\n"</span>);
<a name="l01108"></a>01108 
<a name="l01109"></a>01109             <span class="comment">/* old stack pointer */</span>
<a name="l01110"></a>01110             stack_ptr -= 4;
<a name="l01111"></a>01111             policy.writeMemory&lt;32&gt;(<a class="code" href="InstructionEnumsX86_8h.html#0b09709b1ff4de1bbe47357b6d7b0e64ac8d2c21aff809a6d4a6303b051c88f7">x86_segreg_ss</a>, policy.number&lt;32&gt;(stack_ptr),
<a name="l01112"></a>01112                                    policy.readRegister&lt;32&gt;(<span class="stringliteral">"esp"</span>), policy.true_());
<a name="l01113"></a>01113 
<a name="l01114"></a>01114             <span class="comment">/* address past the basic block's last instruction */</span>
<a name="l01115"></a>01115             stack_ptr -= 4;
<a name="l01116"></a>01116             policy.writeMemory&lt;32&gt;(<a class="code" href="InstructionEnumsX86_8h.html#0b09709b1ff4de1bbe47357b6d7b0e64ac8d2c21aff809a6d4a6303b051c88f7">x86_segreg_ss</a>, policy.number&lt;32&gt;(stack_ptr),
<a name="l01117"></a>01117                                    policy.number&lt;32&gt;(bb-&gt;insns.back()-&gt;get_address()+bb-&gt;insns.back()-&gt;get_size()),
<a name="l01118"></a>01118                                    policy.true_());
<a name="l01119"></a>01119 
<a name="l01120"></a>01120             <span class="comment">/* address of basic block's first instruction */</span>
<a name="l01121"></a>01121             stack_ptr -= 4;
<a name="l01122"></a>01122             policy.writeMemory&lt;32&gt;(<a class="code" href="InstructionEnumsX86_8h.html#0b09709b1ff4de1bbe47357b6d7b0e64ac8d2c21aff809a6d4a6303b051c88f7">x86_segreg_ss</a>, policy.number&lt;32&gt;(stack_ptr),
<a name="l01123"></a>01123                                    policy.number&lt;32&gt;(bb-&gt;insns.front()-&gt;get_address()), policy.true_());
<a name="l01124"></a>01124 
<a name="l01125"></a>01125             <span class="comment">/* size of svec in bytes */</span>
<a name="l01126"></a>01126             stack_ptr -= 4;
<a name="l01127"></a>01127             policy.writeMemory&lt;32&gt;(<a class="code" href="InstructionEnumsX86_8h.html#0b09709b1ff4de1bbe47357b6d7b0e64ac8d2c21aff809a6d4a6303b051c88f7">x86_segreg_ss</a>, policy.number&lt;32&gt;(stack_ptr),
<a name="l01128"></a>01128                                    policy.number&lt;32&gt;(svec_size), policy.true_());
<a name="l01129"></a>01129 
<a name="l01130"></a>01130             <span class="comment">/* address of svec */</span>
<a name="l01131"></a>01131             stack_ptr -= 4;
<a name="l01132"></a>01132             policy.writeMemory&lt;32&gt;(<a class="code" href="InstructionEnumsX86_8h.html#0b09709b1ff4de1bbe47357b6d7b0e64ac8d2c21aff809a6d4a6303b051c88f7">x86_segreg_ss</a>, policy.number&lt;32&gt;(stack_ptr),
<a name="l01133"></a>01133                                    policy.number&lt;32&gt;(svec_va), policy.true_());
<a name="l01134"></a>01134 
<a name="l01135"></a>01135             <span class="comment">/* return address for successors program */</span>
<a name="l01136"></a>01136             stack_ptr -= 4;
<a name="l01137"></a>01137             policy.writeMemory&lt;32&gt;(<a class="code" href="InstructionEnumsX86_8h.html#0b09709b1ff4de1bbe47357b6d7b0e64ac8d2c21aff809a6d4a6303b051c88f7">x86_segreg_ss</a>, policy.number&lt;32&gt;(stack_ptr),
<a name="l01138"></a>01138                                    policy.number&lt;32&gt;(return_va), policy.true_());
<a name="l01139"></a>01139 
<a name="l01140"></a>01140             <span class="comment">/* Adjust policy stack pointer */</span>
<a name="l01141"></a>01141             policy.writeRegister(<span class="stringliteral">"esp"</span>, policy.number&lt;32&gt;(stack_ptr));
<a name="l01142"></a>01142 
<a name="l01143"></a>01143             <span class="comment">/* Interpret the program */</span>
<a name="l01144"></a>01144             <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) fprintf(stderr, <span class="stringliteral">"  running the program...\n"</span>);
<a name="l01145"></a>01145             <a class="code" href="classDisassembler.html">Disassembler</a> *<a class="code" href="classPartitioner.html#320e02804f0d9ae5bc55e1ba26791a72">disassembler</a> = <a class="code" href="classDisassembler.html#80b0e8a12a159d85c9ad2813ed1559c4">Disassembler::lookup</a>(<span class="keyword">new</span> <a class="code" href="classSgAsmPEFileHeader.html">SgAsmPEFileHeader</a>(<span class="keyword">new</span> <a class="code" href="classSgAsmGenericFile.html">SgAsmGenericFile</a>()));
<a name="l01146"></a>01146             assert(<a class="code" href="classPartitioner.html#320e02804f0d9ae5bc55e1ba26791a72">disassembler</a>!=NULL);
<a name="l01147"></a>01147             policy.writeRegister(<span class="stringliteral">"eip"</span>, policy.number&lt;32&gt;(text_va));
<a name="l01148"></a>01148             <span class="keywordflow">while</span> (1) {
<a name="l01149"></a>01149                 <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> ip = policy.readRegister&lt;32&gt;(<span class="stringliteral">"eip"</span>).known_value();
<a name="l01150"></a>01150                 <span class="keywordflow">if</span> (ip==return_va) <span class="keywordflow">break</span>;
<a name="l01151"></a>01151                 <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(<a class="code" href="classPartitioner.html#320e02804f0d9ae5bc55e1ba26791a72">disassembler</a>-&gt;<a class="code" href="classDisassembler.html#d765ce924af663d75b9ce5915d658d7c">disassembleOne</a>(<a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>, ip));
<a name="l01152"></a>01152                 <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) fprintf(stderr, <span class="stringliteral">"    0x%08"</span>PRIx64<span class="stringliteral">": %s\n"</span>, ip, insn?<a class="code" href="AsmUnparser__compat_8h.html#30492a6c8df6a943ca55224e62c322c8">unparseInstruction</a>(insn).c_str():<span class="stringliteral">"&lt;null&gt;"</span>);
<a name="l01153"></a>01153                 assert(insn!=NULL);
<a name="l01154"></a>01154                 semantics.processInstruction(insn);
<a name="l01155"></a>01155                 assert(policy.readRegister&lt;32&gt;(<span class="stringliteral">"eip"</span>).is_known());
<a name="l01156"></a>01156                 <a class="code" href="namespaceSageInterface.html#57437bbbb806858dda0cea7444fbafef">SageInterface::deleteAST</a>(insn);
<a name="l01157"></a>01157             }
<a name="l01158"></a>01158 
<a name="l01159"></a>01159             <span class="comment">/* Extract the list of successors. The number of successors is the first element of the list. */</span>
<a name="l01160"></a>01160             <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) fprintf(stderr, <span class="stringliteral">"  extracting program return values...\n"</span>);
<a name="l01161"></a>01161             PartialSymbolicSemantics::ValueType&lt;32&gt; nsucs = policy.readMemory&lt;32&gt;(<a class="code" href="InstructionEnumsX86_8h.html#0b09709b1ff4de1bbe47357b6d7b0e64ac8d2c21aff809a6d4a6303b051c88f7">x86_segreg_ss</a>, policy.number&lt;32&gt;(svec_va),
<a name="l01162"></a>01162                                                                                   policy.true_());
<a name="l01163"></a>01163             assert(nsucs.is_known());
<a name="l01164"></a>01164             <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) fprintf(stderr, <span class="stringliteral">"    number of successors: %"</span>PRId64<span class="stringliteral">"\n"</span>, nsucs.known_value());
<a name="l01165"></a>01165             assert(nsucs.known_value()*4 &lt;= svec_size-4); <span class="comment">/*first entry is size*/</span>
<a name="l01166"></a>01166             <span class="keywordflow">for</span> (size_t i=0; i&lt;nsucs.known_value(); i++) {
<a name="l01167"></a>01167                 PartialSymbolicSemantics::ValueType&lt;32&gt; suc_va = policy.readMemory&lt;32&gt;(<a class="code" href="InstructionEnumsX86_8h.html#0b09709b1ff4de1bbe47357b6d7b0e64ac8d2c21aff809a6d4a6303b051c88f7">x86_segreg_ss</a>,
<a name="l01168"></a>01168                                                                                        policy.number&lt;32&gt;(svec_va+4+i*4),
<a name="l01169"></a>01169                                                                                        policy.true_());
<a name="l01170"></a>01170                 <span class="keywordflow">if</span> (suc_va.is_known()) {
<a name="l01171"></a>01171                     <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) fprintf(stderr, <span class="stringliteral">"    #%zu: 0x%08"</span>PRIx64<span class="stringliteral">"\n"</span>, i, suc_va.known_value());
<a name="l01172"></a>01172                     bb-&gt;cache.sucs.insert(suc_va.known_value());
<a name="l01173"></a>01173                 } <span class="keywordflow">else</span> {
<a name="l01174"></a>01174                     <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) fprintf(stderr, <span class="stringliteral">"    #%zu: unknown\n"</span>, i);
<a name="l01175"></a>01175                     bb-&gt;cache.sucs_complete = <span class="keyword">false</span>;
<a name="l01176"></a>01176                 }
<a name="l01177"></a>01177             }
<a name="l01178"></a>01178 
<a name="l01179"></a>01179             <span class="comment">/* Unmap the program */</span>
<a name="l01180"></a>01180             <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) fprintf(stderr, <span class="stringliteral">"  unmapping the program...\n"</span>);
<a name="l01181"></a>01181             <a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>-&gt;<a class="code" href="classMemoryMap.html#497cf700231115f91e5627a11c166653">erase</a>(text_sgmt);
<a name="l01182"></a>01182             <a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>-&gt;<a class="code" href="classMemoryMap.html#497cf700231115f91e5627a11c166653">erase</a>(stack_sgmt);
<a name="l01183"></a>01183             <a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>-&gt;<a class="code" href="classMemoryMap.html#497cf700231115f91e5627a11c166653">erase</a>(svec_sgmt);
<a name="l01184"></a>01184 
<a name="l01185"></a>01185             <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) fprintf(stderr, <span class="stringliteral">"  done.\n"</span>);
<a name="l01186"></a>01186         }
<a name="l01187"></a>01187     }
<a name="l01188"></a>01188 }
<a name="l01189"></a>01189 
<a name="l01190"></a>01190 <span class="comment">/* Marks program entry addresses as functions. */</span>
<a name="l01191"></a>01191 <span class="keywordtype">void</span>
<a name="l01192"></a><a class="code" href="classPartitioner.html#1f7de70089099ce3d31af5ed455fc9b7">01192</a> <a class="code" href="classPartitioner.html#1f7de70089099ce3d31af5ed455fc9b7">Partitioner::mark_entry_targets</a>(<a class="code" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *fhdr)
<a name="l01193"></a>01193 {
<a name="l01194"></a>01194     <a class="code" href="Cxx__Grammar_8h.html#58a225317d7a3fabc34e22bda238c740">SgRVAList</a> entries = fhdr-&gt;<a class="code" href="classSgAsmGenericHeader.html#a6d2b0b9c6469a2ff98bb9021a41cc9e">get_entry_rvas</a>();
<a name="l01195"></a>01195     <span class="keywordflow">for</span> (size_t i=0; i&lt;entries.size(); i++) {
<a name="l01196"></a>01196         <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> entry_va = entries[i].get_rva() + fhdr-&gt;<a class="code" href="classSgAsmGenericHeader.html#fb6c62c0fdc956105bfae2263617446e">get_base_va</a>();
<a name="l01197"></a>01197         <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#1dcdd3e0993256cd5ed93fd4d178679f">find_instruction</a>(entry_va))
<a name="l01198"></a>01198             <a class="code" href="classPartitioner.html#91e9b8ad59e4657d6f3dbece95752a4e">add_function</a>(entry_va, <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c2c1716e490136fddc09c145d8809ed64">SgAsmFunction::FUNC_ENTRY_POINT</a>);
<a name="l01199"></a>01199     }
<a name="l01200"></a>01200 }
<a name="l01201"></a>01201 
<a name="l01202"></a>01202 <span class="comment">/* Use the Frame Descriptor Entry Records of the ELF .eh_frame section to mark functions. */</span>
<a name="l01203"></a>01203 <span class="keywordtype">void</span>
<a name="l01204"></a><a class="code" href="classPartitioner.html#167cda7ee682478117f8480d86815efc">01204</a> <a class="code" href="classPartitioner.html#167cda7ee682478117f8480d86815efc">Partitioner::mark_eh_frames</a>(<a class="code" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *fhdr)
<a name="l01205"></a>01205 {
<a name="l01206"></a>01206     <a class="code" href="classSgAsmGenericSectionList.html">SgAsmGenericSectionList</a> *sections = fhdr-&gt;<a class="code" href="classSgAsmGenericHeader.html#5cefae0c9db1832cd75642799bc33762">get_sections</a>();
<a name="l01207"></a>01207     <span class="keywordflow">for</span> (size_t i=0; i&lt;sections-&gt;<a class="code" href="classSgAsmGenericSectionList.html#239d407e4df928777b992e8fdfc6e685">get_sections</a>().size(); i++) {
<a name="l01208"></a>01208         <a class="code" href="classSgAsmElfEHFrameSection.html">SgAsmElfEHFrameSection</a> *ehframe = <a class="code" href="Cxx__Grammar_8h.html#d08e263414ec2d08e4a09aa531be9b91">isSgAsmElfEHFrameSection</a>(sections-&gt;<a class="code" href="classSgAsmGenericSectionList.html#239d407e4df928777b992e8fdfc6e685">get_sections</a>()[i]);
<a name="l01209"></a>01209         <span class="keywordflow">if</span> (ehframe!=NULL) {
<a name="l01210"></a>01210             <a class="code" href="classSgAsmElfEHFrameEntryCIList.html">SgAsmElfEHFrameEntryCIList</a> *ci_entries = ehframe-&gt;<a class="code" href="classSgAsmElfEHFrameSection.html#d7939c95532f3e26e6693ffead3293f6">get_ci_entries</a>();
<a name="l01211"></a>01211             <span class="keywordflow">for</span> (size_t j=0; j&lt;ci_entries-&gt;<a class="code" href="classSgAsmElfEHFrameEntryCIList.html#2f2fc1a72617b1a793d4c0107f06d82c">get_entries</a>().size(); j++) {
<a name="l01212"></a>01212                 <a class="code" href="classSgAsmElfEHFrameEntryCI.html">SgAsmElfEHFrameEntryCI</a> *cie = ci_entries-&gt;<a class="code" href="classSgAsmElfEHFrameEntryCIList.html#2f2fc1a72617b1a793d4c0107f06d82c">get_entries</a>()[j];
<a name="l01213"></a>01213                 <a class="code" href="classSgAsmElfEHFrameEntryFDList.html">SgAsmElfEHFrameEntryFDList</a> *fd_entries = cie-&gt;get_fd_entries();
<a name="l01214"></a>01214                 <span class="keywordflow">for</span> (size_t k=0; k&lt;fd_entries-&gt;<a class="code" href="classSgAsmElfEHFrameEntryFDList.html#857b7f91ee69de6582eee3bc38336368">get_entries</a>().size(); k++) {
<a name="l01215"></a>01215                     <a class="code" href="classSgAsmElfEHFrameEntryFD.html">SgAsmElfEHFrameEntryFD</a> *fde = fd_entries-&gt;<a class="code" href="classSgAsmElfEHFrameEntryFDList.html#857b7f91ee69de6582eee3bc38336368">get_entries</a>()[k];
<a name="l01216"></a>01216                     <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> target = fde-&gt;get_begin_rva().get_rva();
<a name="l01217"></a>01217                     <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#1dcdd3e0993256cd5ed93fd4d178679f">find_instruction</a>(target))
<a name="l01218"></a>01218                         <a class="code" href="classPartitioner.html#91e9b8ad59e4657d6f3dbece95752a4e">add_function</a>(target, <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cd7e1055f3974be70f4e4d88e758ed666">SgAsmFunction::FUNC_EH_FRAME</a>);
<a name="l01219"></a>01219                 }
<a name="l01220"></a>01220             }
<a name="l01221"></a>01221         }
<a name="l01222"></a>01222     }
<a name="l01223"></a>01223 }
<a name="l01224"></a>01224 
<a name="l01225"></a>01225 <span class="comment">/* Adds each entry of the ELF procedure lookup table (.plt section) to the list of functions. */</span>
<a name="l01226"></a>01226 <span class="keywordtype">void</span>
<a name="l01227"></a><a class="code" href="classPartitioner.html#20bab02d75f2c49035e63dc029635698">01227</a> <a class="code" href="classPartitioner.html#20bab02d75f2c49035e63dc029635698">Partitioner::mark_elf_plt_entries</a>(<a class="code" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *fhdr)
<a name="l01228"></a>01228 {
<a name="l01229"></a>01229     <span class="comment">/* This function is ELF, x86 specific. */</span>
<a name="l01230"></a>01230     <a class="code" href="classSgAsmElfFileHeader.html">SgAsmElfFileHeader</a> *elf = <a class="code" href="Cxx__Grammar_8h.html#634969907f40ab0a68fa945423fc355a">isSgAsmElfFileHeader</a>(fhdr);
<a name="l01231"></a>01231     <span class="keywordflow">if</span> (!elf) <span class="keywordflow">return</span>;
<a name="l01232"></a>01232 
<a name="l01233"></a>01233     <span class="comment">/* Find important sections */</span>
<a name="l01234"></a>01234     <a class="code" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *plt = elf-&gt;<a class="code" href="classSgAsmGenericHeader.html#374afd170f81cad885729210130cb45b">get_section_by_name</a>(<span class="stringliteral">".plt"</span>);
<a name="l01235"></a>01235     <span class="keywordflow">if</span> (!plt || !plt-&gt;<a class="code" href="classSgAsmGenericSection.html#104f95720dd8a1b1cc458c8c651943cb">is_mapped</a>()) <span class="keywordflow">return</span>;
<a name="l01236"></a>01236     <a class="code" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *gotplt = elf-&gt;<a class="code" href="classSgAsmGenericHeader.html#374afd170f81cad885729210130cb45b">get_section_by_name</a>(<span class="stringliteral">".got.plt"</span>);
<a name="l01237"></a>01237     <span class="keywordflow">if</span> (!gotplt || !gotplt-&gt;<a class="code" href="classSgAsmGenericSection.html#104f95720dd8a1b1cc458c8c651943cb">is_mapped</a>()) <span class="keywordflow">return</span>;
<a name="l01238"></a>01238 
<a name="l01239"></a>01239     <span class="comment">/* Find all relocation sections */</span>
<a name="l01240"></a>01240     std::set&lt;SgAsmElfRelocSection*&gt; rsects;
<a name="l01241"></a>01241     <span class="keyword">const</span> <a class="code" href="Cxx__Grammar_8h.html#af7ee9051414ea5a9e6e9697fe2cc6e2">SgAsmGenericSectionPtrList</a> &amp;sections = elf-&gt;<a class="code" href="classSgAsmGenericHeader.html#5cefae0c9db1832cd75642799bc33762">get_sections</a>()-&gt;<a class="code" href="classSgAsmGenericSectionList.html#239d407e4df928777b992e8fdfc6e685">get_sections</a>();
<a name="l01242"></a>01242     <span class="keywordflow">for</span> (SgAsmGenericSectionPtrList::const_iterator si=sections.begin(); si!=sections.end(); ++si) {
<a name="l01243"></a>01243         <a class="code" href="classSgAsmElfRelocSection.html">SgAsmElfRelocSection</a> *reloc_section = <a class="code" href="Cxx__Grammar_8h.html#659c355083a0fd75c56da2364ae4f08b">isSgAsmElfRelocSection</a>(*si);
<a name="l01244"></a>01244         <span class="keywordflow">if</span> (reloc_section)
<a name="l01245"></a>01245             rsects.insert(reloc_section);
<a name="l01246"></a>01246     }
<a name="l01247"></a>01247     <span class="keywordflow">if</span> (rsects.empty()) <span class="keywordflow">return</span>;
<a name="l01248"></a>01248 
<a name="l01249"></a>01249     <span class="comment">/* Look at each instruction in the .plt section. If the instruction is a computed jump to an address stored in the</span>
<a name="l01250"></a>01250 <span class="comment">     * .got.plt then we've found the beginning of a plt trampoline. */</span>
<a name="l01251"></a>01251     <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> plt_offset = 14; <span class="comment">/* skip the first entry (PUSH ds:XXX; JMP ds:YYY; 0x00; 0x00)--the JMP is not a function*/</span>
<a name="l01252"></a>01252     <span class="keywordflow">while</span> (plt_offset&lt;plt-&gt;get_mapped_size()) {
<a name="l01253"></a>01253 
<a name="l01254"></a>01254         <span class="comment">/* Find an x86 instruction */</span>
<a name="l01255"></a>01255         <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a> *insn = <a class="code" href="classPartitioner.html#1dcdd3e0993256cd5ed93fd4d178679f">find_instruction</a>(plt-&gt;<a class="code" href="classSgAsmGenericSection.html#ea9f50c4b61b494c81f6f2d1382f3de5">get_mapped_actual_va</a>()+plt_offset);
<a name="l01256"></a>01256         <span class="keywordflow">if</span> (!insn) {
<a name="l01257"></a>01257             ++plt_offset;
<a name="l01258"></a>01258             <span class="keywordflow">continue</span>;
<a name="l01259"></a>01259         }
<a name="l01260"></a>01260         plt_offset += insn-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#46940b414c39f0fd10186868d40715f7">get_size</a>();
<a name="l01261"></a>01261         <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn_x86 = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(insn);
<a name="l01262"></a>01262         <span class="keywordflow">if</span> (!insn_x86) <span class="keywordflow">continue</span>;
<a name="l01263"></a>01263 
<a name="l01264"></a>01264         <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> gotplt_va = <a class="code" href="classPartitioner.html#a4ec978230e19cc6bd34d60be7801452">get_indirection_addr</a>(insn_x86);
<a name="l01265"></a>01265         <span class="keywordflow">if</span> (gotplt_va &lt;  elf-&gt;get_base_va() + gotplt-&gt;<a class="code" href="classSgAsmGenericSection.html#5196f7cd5b28560a8b959b1e3228c079">get_mapped_preferred_rva</a>() ||
<a name="l01266"></a>01266             gotplt_va &gt;= elf-&gt;<a class="code" href="classSgAsmGenericHeader.html#fb6c62c0fdc956105bfae2263617446e">get_base_va</a>() + gotplt-&gt;<a class="code" href="classSgAsmGenericSection.html#5196f7cd5b28560a8b959b1e3228c079">get_mapped_preferred_rva</a>() + gotplt-&gt;<a class="code" href="classSgAsmGenericSection.html#8d1fa091242ab088e3cbe50d87fc25ba">get_mapped_size</a>()) {
<a name="l01267"></a>01267             <span class="keywordflow">continue</span>; <span class="comment">/* jump is not indirect through the .got.plt section */</span>
<a name="l01268"></a>01268         }
<a name="l01269"></a>01269 
<a name="l01270"></a>01270         <span class="comment">/* Find the relocation entry whose offset is the gotplt_va and use that entry's symbol for the function name. */</span>
<a name="l01271"></a>01271         std::string name;
<a name="l01272"></a>01272         <span class="keywordflow">for</span> (std::set&lt;SgAsmElfRelocSection*&gt;::iterator ri=rsects.begin(); ri!=rsects.end() &amp;&amp; name.empty(); ++ri) {
<a name="l01273"></a>01273             <a class="code" href="classSgAsmElfRelocEntryList.html">SgAsmElfRelocEntryList</a> *entries = (*ri)-&gt;get_entries();
<a name="l01274"></a>01274             <a class="code" href="classSgAsmElfSymbolSection.html">SgAsmElfSymbolSection</a> *symbol_section = <a class="code" href="Cxx__Grammar_8h.html#faaae5166c764907865b84e4aca5f2be">isSgAsmElfSymbolSection</a>((*ri)-&gt;get_linked_section());
<a name="l01275"></a>01275             <a class="code" href="classSgAsmElfSymbolList.html">SgAsmElfSymbolList</a> *symbols = symbol_section ? symbol_section-&gt;<a class="code" href="classSgAsmElfSymbolSection.html#68c30567293ca0163f091dd2c8c19e8c">get_symbols</a>() : NULL;
<a name="l01276"></a>01276             <span class="keywordflow">for</span> (size_t ei=0; ei&lt;entries-&gt;get_entries().size() &amp;&amp; name.empty() &amp;&amp; symbols; ++ei) {
<a name="l01277"></a>01277                 <a class="code" href="classSgAsmElfRelocEntry.html">SgAsmElfRelocEntry</a> *rel = entries-&gt;get_entries()[ei];
<a name="l01278"></a>01278                 <span class="keywordflow">if</span> (rel-&gt;get_r_offset()==gotplt_va) {
<a name="l01279"></a>01279                     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> symbol_idx = rel-&gt;get_sym();
<a name="l01280"></a>01280                     <span class="keywordflow">if</span> (symbol_idx &lt; symbols-&gt;get_symbols().size()) {
<a name="l01281"></a>01281                         <a class="code" href="classSgAsmElfSymbol.html">SgAsmElfSymbol</a> *symbol = symbols-&gt;<a class="code" href="classSgAsmElfSymbolList.html#f0bad6ae664035299ed6102dce7cd4e3">get_symbols</a>()[symbol_idx];
<a name="l01282"></a>01282                         name = symbol-&gt;<a class="code" href="classSgAsmGenericSymbol.html#8cef0d96af06bb5e741df6a332c67e2c">get_name</a>()-&gt;<a class="code" href="classSgAsmGenericString.html#ba8bc51c8d891e4f8e8e87c45c62f7d5">get_string</a>() + <span class="stringliteral">"@plt"</span>;
<a name="l01283"></a>01283                     }
<a name="l01284"></a>01284                 }
<a name="l01285"></a>01285             }
<a name="l01286"></a>01286         }
<a name="l01287"></a>01287 
<a name="l01288"></a>01288         <a class="code" href="classPartitioner_1_1Function.html">Function</a> *plt_func = <a class="code" href="classPartitioner.html#91e9b8ad59e4657d6f3dbece95752a4e">add_function</a>(insn-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#a9c8dd5cf80780b59c4e74e4bb8b2811">get_address</a>(), <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c40c0ce88c447524963f4e8d7ef193cc7">SgAsmFunction::FUNC_IMPORT</a>, name);
<a name="l01289"></a>01289 
<a name="l01290"></a>01290         <span class="comment">/* FIXME: Assume that most PLT functions return. We make this assumption for now because the PLT table contains an</span>
<a name="l01291"></a>01291 <span class="comment">         *        indirect jump through the .plt.got data area and we don't yet do static analysis of the data.  Because of</span>
<a name="l01292"></a>01292 <span class="comment">         *        that, all the PLT functons will contain only a basic block with the single indirect jump, and no return</span>
<a name="l01293"></a>01293 <span class="comment">         *        (e.g., x86 RET or RETF) instruction, and therefore the function would not normally be marked as returning.</span>
<a name="l01294"></a>01294 <span class="comment">         *        [RPM 2010-05-11] */</span>
<a name="l01295"></a>01295         <span class="keywordflow">if</span> (<span class="stringliteral">"abort@plt"</span>!=name &amp;&amp; <span class="stringliteral">"execl@plt"</span>!=name &amp;&amp; <span class="stringliteral">"execlp@plt"</span>!=name &amp;&amp; <span class="stringliteral">"execv@plt"</span>!=name &amp;&amp; <span class="stringliteral">"execvp@plt"</span>!=name &amp;&amp;
<a name="l01296"></a>01296             <span class="stringliteral">"exit@plt"</span>!=name &amp;&amp; <span class="stringliteral">"_exit@plt"</span>!=name &amp;&amp; <span class="stringliteral">"fexecve@plt"</span>!=name &amp;&amp;
<a name="l01297"></a>01297             <span class="stringliteral">"longjmp@plt"</span>!=name &amp;&amp; <span class="stringliteral">"__longjmp@plt"</span>!=name &amp;&amp; <span class="stringliteral">"siglongjmp@plt"</span>!=name) {
<a name="l01298"></a>01298             plt_func-&gt;<a class="code" href="classPartitioner_1_1Function.html#4325b671ee6d062df9dc9e4c8868ac4a">set_may_return</a>(<a class="code" href="classSgAsmFunction.html#d1e0c37f9e507fc6acaf01dd0794a7528cf02b4f0b67544a9fafcf0fbc28ee19">SgAsmFunction::RET_ALWAYS</a>);
<a name="l01299"></a>01299         } <span class="keywordflow">else</span> {
<a name="l01300"></a>01300             plt_func-&gt;<a class="code" href="classPartitioner_1_1Function.html#4325b671ee6d062df9dc9e4c8868ac4a">set_may_return</a>(<a class="code" href="classSgAsmFunction.html#d1e0c37f9e507fc6acaf01dd0794a752df440ebe371c3f4fdc1612448157f6bc">SgAsmFunction::RET_NEVER</a>);
<a name="l01301"></a>01301         }
<a name="l01302"></a>01302     }
<a name="l01303"></a>01303 }
<a name="l01304"></a>01304 
<a name="l01305"></a>01305 <span class="comment">/* Use symbol tables to determine function entry points. */</span>
<a name="l01306"></a>01306 <span class="keywordtype">void</span>
<a name="l01307"></a><a class="code" href="classPartitioner.html#5856443d8da3aeb540e193491619dab8">01307</a> <a class="code" href="classPartitioner.html#5856443d8da3aeb540e193491619dab8">Partitioner::mark_func_symbols</a>(<a class="code" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *fhdr)
<a name="l01308"></a>01308 {
<a name="l01309"></a>01309     <a class="code" href="classSgAsmGenericSectionList.html">SgAsmGenericSectionList</a> *sections = fhdr-&gt;<a class="code" href="classSgAsmGenericHeader.html#5cefae0c9db1832cd75642799bc33762">get_sections</a>();
<a name="l01310"></a>01310     <span class="keywordflow">for</span> (size_t i=0; i&lt;sections-&gt;<a class="code" href="classSgAsmGenericSectionList.html#239d407e4df928777b992e8fdfc6e685">get_sections</a>().size(); i++) {
<a name="l01311"></a>01311 
<a name="l01312"></a>01312         <span class="comment">/* If this is a symbol table of some sort, then get the list of symbols. */</span>
<a name="l01313"></a>01313         std::vector&lt;SgAsmGenericSymbol*&gt; symbols;
<a name="l01314"></a>01314         <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#faaae5166c764907865b84e4aca5f2be">isSgAsmElfSymbolSection</a>(sections-&gt;<a class="code" href="classSgAsmGenericSectionList.html#239d407e4df928777b992e8fdfc6e685">get_sections</a>()[i])) {
<a name="l01315"></a>01315             <a class="code" href="classSgAsmElfSymbolList.html">SgAsmElfSymbolList</a> *elf_symbols = <a class="code" href="Cxx__Grammar_8h.html#faaae5166c764907865b84e4aca5f2be">isSgAsmElfSymbolSection</a>(sections-&gt;<a class="code" href="classSgAsmGenericSectionList.html#239d407e4df928777b992e8fdfc6e685">get_sections</a>()[i])-&gt;get_symbols();
<a name="l01316"></a>01316             <span class="keywordflow">for</span> (size_t j=0; j&lt;elf_symbols-&gt;<a class="code" href="classSgAsmElfSymbolList.html#f0bad6ae664035299ed6102dce7cd4e3">get_symbols</a>().size(); j++) {
<a name="l01317"></a>01317                 symbols.push_back(elf_symbols-&gt;<a class="code" href="classSgAsmElfSymbolList.html#f0bad6ae664035299ed6102dce7cd4e3">get_symbols</a>()[j]);
<a name="l01318"></a>01318             }
<a name="l01319"></a>01319         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#3784b7e019b3c0e729e465249b471c4f">isSgAsmCoffSymbolTable</a>(sections-&gt;<a class="code" href="classSgAsmGenericSectionList.html#239d407e4df928777b992e8fdfc6e685">get_sections</a>()[i])) {
<a name="l01320"></a>01320             <a class="code" href="classSgAsmCoffSymbolList.html">SgAsmCoffSymbolList</a> *coff_symbols = <a class="code" href="Cxx__Grammar_8h.html#3784b7e019b3c0e729e465249b471c4f">isSgAsmCoffSymbolTable</a>(sections-&gt;<a class="code" href="classSgAsmGenericSectionList.html#239d407e4df928777b992e8fdfc6e685">get_sections</a>()[i])-&gt;get_symbols();
<a name="l01321"></a>01321             <span class="keywordflow">for</span> (size_t j=0; j&lt;coff_symbols-&gt;<a class="code" href="classSgAsmCoffSymbolList.html#99bdd0304e1061727edc840ca884aeed">get_symbols</a>().size(); j++) {
<a name="l01322"></a>01322                 symbols.push_back(coff_symbols-&gt;<a class="code" href="classSgAsmCoffSymbolList.html#99bdd0304e1061727edc840ca884aeed">get_symbols</a>()[j]);
<a name="l01323"></a>01323             }
<a name="l01324"></a>01324         }
<a name="l01325"></a>01325 
<a name="l01326"></a>01326         <span class="keywordflow">for</span> (size_t j=0; j&lt;symbols.size(); j++) {
<a name="l01327"></a>01327             <a class="code" href="classSgAsmGenericSymbol.html">SgAsmGenericSymbol</a> *symbol = symbols[j];
<a name="l01328"></a>01328             <span class="keywordflow">if</span> (symbol-&gt;get_def_state()==<a class="code" href="classSgAsmGenericSymbol.html#e64e9dd59a83e83566671d7cad4432ef16df55db1f93a2213909c5106c310824">SgAsmGenericSymbol::SYM_DEFINED</a> &amp;&amp;
<a name="l01329"></a>01329                 symbol-&gt;get_type()==<a class="code" href="classSgAsmGenericSymbol.html#25348ff5aed9d9e7c581db9d610f955cf63811b9d936e39b907895e2565b553f">SgAsmGenericSymbol::SYM_FUNC</a> &amp;&amp;
<a name="l01330"></a>01330                 symbol-&gt;get_value()!=0) {
<a name="l01331"></a>01331                 <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> value = symbol-&gt;get_value();
<a name="l01332"></a>01332                 <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#1dcdd3e0993256cd5ed93fd4d178679f">find_instruction</a>(value))
<a name="l01333"></a>01333                     <a class="code" href="classPartitioner.html#91e9b8ad59e4657d6f3dbece95752a4e">add_function</a>(value, <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c10eee68a3ad870f7e48faef2639a853a">SgAsmFunction::FUNC_SYMBOL</a>, symbol-&gt;get_name()-&gt;get_string());
<a name="l01334"></a>01334 
<a name="l01335"></a>01335                 <span class="comment">/* Sometimes weak symbol values are offsets from a section (this code handles that), but other times they're</span>
<a name="l01336"></a>01336 <span class="comment">                 * the value is used directly (the above code handled that case). */</span>
<a name="l01337"></a>01337                 <a class="code" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *section = symbol-&gt;get_bound();
<a name="l01338"></a>01338                 <span class="keywordflow">if</span> (section &amp;&amp; symbol-&gt;get_binding()==<a class="code" href="classSgAsmGenericSymbol.html#4957aa9672fd1498b565c12b6691d5c00d7c5f0c368b014a3c762f7ad408eabd">SgAsmGenericSymbol::SYM_WEAK</a>)
<a name="l01339"></a>01339                     value += section-&gt;get_mapped_actual_va();
<a name="l01340"></a>01340                 <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#1dcdd3e0993256cd5ed93fd4d178679f">find_instruction</a>(value))
<a name="l01341"></a>01341                     <a class="code" href="classPartitioner.html#91e9b8ad59e4657d6f3dbece95752a4e">add_function</a>(value, <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c10eee68a3ad870f7e48faef2639a853a">SgAsmFunction::FUNC_SYMBOL</a>, symbol-&gt;get_name()-&gt;get_string());
<a name="l01342"></a>01342             }
<a name="l01343"></a>01343         }
<a name="l01344"></a>01344     }
<a name="l01345"></a>01345 }
<a name="l01346"></a>01346 
<a name="l01347"></a>01347 <span class="comment">/* Tries to match "(mov rdi,rdi)?; push rbp; mov rbp,rsp" (or the 32-bit equivalent). */</span>
<a name="l01348"></a>01348 Partitioner::InstructionMap::const_iterator
<a name="l01349"></a><a class="code" href="classPartitioner.html#211865359a987a4e353615bb427bda34">01349</a> <a class="code" href="classPartitioner.html#211865359a987a4e353615bb427bda34">Partitioner::pattern1</a>(<span class="keyword">const</span> InstructionMap&amp; insns, InstructionMap::const_iterator first, <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> &amp;exclude)
<a name="l01350"></a>01350 {
<a name="l01351"></a>01351     InstructionMap::const_iterator ii = first;
<a name="l01352"></a>01352     <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> matches;
<a name="l01353"></a>01353 
<a name="l01354"></a>01354     <span class="comment">/* Look for optional "mov rdi, rdi"; if found, advance ii iterator to fall-through instruction */</span>
<a name="l01355"></a>01355     <span class="keywordflow">do</span> {
<a name="l01356"></a>01356         <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(ii-&gt;second);
<a name="l01357"></a>01357         <span class="keywordflow">if</span> (!insn || insn-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()!=<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca55716425893a9bd36fb1384ff05ba92096b7">x86_mov</a>)
<a name="l01358"></a>01358             <span class="keywordflow">break</span>;
<a name="l01359"></a>01359         <span class="keyword">const</span> <a class="code" href="Cxx__Grammar_8h.html#5ba40394e1b351b2d55384ed355a4077">SgAsmExpressionPtrList</a> &amp;opands = insn-&gt;<a class="code" href="classSgAsmInstruction.html#264e86d032b0a589d9dc520e79d09eb8">get_operandList</a>()-&gt;<a class="code" href="classSgAsmOperandList.html#bb5638c0533863030ad7acee019f1f17">get_operands</a>();
<a name="l01360"></a>01360         <span class="keywordflow">if</span> (opands.size()!=2)
<a name="l01361"></a>01361             <span class="keywordflow">break</span>;
<a name="l01362"></a>01362         <a class="code" href="classSgAsmx86RegisterReferenceExpression.html">SgAsmx86RegisterReferenceExpression</a> *rre = <a class="code" href="Cxx__Grammar_8h.html#5e5ead71a8653e1d062d92582359e574">isSgAsmx86RegisterReferenceExpression</a>(opands[0]);
<a name="l01363"></a>01363         <span class="keywordflow">if</span> (!rre ||
<a name="l01364"></a>01364             rre-&gt;<a class="code" href="classSgAsmRegisterReferenceExpression.html#e4a2ae3037e897d983674a61bbf16ec0">get_descriptor</a>().<a class="code" href="structRegisterDescriptor.html#00a1b8b124f547095b6409606276a65c">get_major</a>()!=<a class="code" href="InstructionEnumsX86_8h.html#12229bfc0029dbc592944d1d6514e30fbcab68a004f857b0eb9dc6a5b736b1ec">x86_regclass_gpr</a> ||
<a name="l01365"></a>01365             rre-&gt;<a class="code" href="classSgAsmRegisterReferenceExpression.html#e4a2ae3037e897d983674a61bbf16ec0">get_descriptor</a>().<a class="code" href="structRegisterDescriptor.html#2e01183db39faae43a9d6671dd27a12b">get_minor</a>()!=<a class="code" href="InstructionEnumsX86_8h.html#5069ca462f85d162797843f48bc6bced4e00b4b002bfe801084a2c7648bf884e">x86_gpr_di</a>)
<a name="l01366"></a>01366             <span class="keywordflow">break</span>;
<a name="l01367"></a>01367         rre = <a class="code" href="Cxx__Grammar_8h.html#5e5ead71a8653e1d062d92582359e574">isSgAsmx86RegisterReferenceExpression</a>(opands[1]);
<a name="l01368"></a>01368         <span class="keywordflow">if</span> (!rre ||
<a name="l01369"></a>01369             rre-&gt;<a class="code" href="classSgAsmRegisterReferenceExpression.html#e4a2ae3037e897d983674a61bbf16ec0">get_descriptor</a>().<a class="code" href="structRegisterDescriptor.html#00a1b8b124f547095b6409606276a65c">get_major</a>()!=<a class="code" href="InstructionEnumsX86_8h.html#12229bfc0029dbc592944d1d6514e30fbcab68a004f857b0eb9dc6a5b736b1ec">x86_regclass_gpr</a> ||
<a name="l01370"></a>01370             rre-&gt;<a class="code" href="classSgAsmRegisterReferenceExpression.html#e4a2ae3037e897d983674a61bbf16ec0">get_descriptor</a>().<a class="code" href="structRegisterDescriptor.html#2e01183db39faae43a9d6671dd27a12b">get_minor</a>()!=<a class="code" href="InstructionEnumsX86_8h.html#5069ca462f85d162797843f48bc6bced4e00b4b002bfe801084a2c7648bf884e">x86_gpr_di</a>)
<a name="l01371"></a>01371             <span class="keywordflow">break</span>;
<a name="l01372"></a>01372         matches.insert(ii-&gt;first);
<a name="l01373"></a>01373         ii = insns.find(ii-&gt;first + insn-&gt;<a class="code" href="classSgAsmInstruction.html#6adcc4eb7c725185baa3a2425a57843c">get_size</a>());
<a name="l01374"></a>01374     } <span class="keywordflow">while</span> (0);
<a name="l01375"></a>01375 
<a name="l01376"></a>01376     <span class="comment">/* Look for "push rbp" */</span>
<a name="l01377"></a>01377     {
<a name="l01378"></a>01378         <span class="keywordflow">if</span> (ii==insns.end())
<a name="l01379"></a>01379             <span class="keywordflow">return</span> insns.end();
<a name="l01380"></a>01380         <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(ii-&gt;second);
<a name="l01381"></a>01381         <span class="keywordflow">if</span> (!insn || insn-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()!=<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571618cb96107e08a8518c194668a9bb9c2">x86_push</a>)
<a name="l01382"></a>01382             <span class="keywordflow">return</span> insns.end();
<a name="l01383"></a>01383         <span class="keyword">const</span> <a class="code" href="Cxx__Grammar_8h.html#5ba40394e1b351b2d55384ed355a4077">SgAsmExpressionPtrList</a> &amp;opands = insn-&gt;<a class="code" href="classSgAsmInstruction.html#264e86d032b0a589d9dc520e79d09eb8">get_operandList</a>()-&gt;<a class="code" href="classSgAsmOperandList.html#bb5638c0533863030ad7acee019f1f17">get_operands</a>();
<a name="l01384"></a>01384         <span class="keywordflow">if</span> (opands.size()!=1)
<a name="l01385"></a>01385             <span class="keywordflow">return</span> insns.end();
<a name="l01386"></a>01386         <a class="code" href="classSgAsmx86RegisterReferenceExpression.html">SgAsmx86RegisterReferenceExpression</a> *rre = <a class="code" href="Cxx__Grammar_8h.html#5e5ead71a8653e1d062d92582359e574">isSgAsmx86RegisterReferenceExpression</a>(opands[0]);
<a name="l01387"></a>01387         <span class="keywordflow">if</span> (!rre ||
<a name="l01388"></a>01388             rre-&gt;<a class="code" href="classSgAsmRegisterReferenceExpression.html#e4a2ae3037e897d983674a61bbf16ec0">get_descriptor</a>().<a class="code" href="structRegisterDescriptor.html#00a1b8b124f547095b6409606276a65c">get_major</a>()!=<a class="code" href="InstructionEnumsX86_8h.html#12229bfc0029dbc592944d1d6514e30fbcab68a004f857b0eb9dc6a5b736b1ec">x86_regclass_gpr</a> ||
<a name="l01389"></a>01389             rre-&gt;<a class="code" href="classSgAsmRegisterReferenceExpression.html#e4a2ae3037e897d983674a61bbf16ec0">get_descriptor</a>().<a class="code" href="structRegisterDescriptor.html#2e01183db39faae43a9d6671dd27a12b">get_minor</a>()!=<a class="code" href="InstructionEnumsX86_8h.html#5069ca462f85d162797843f48bc6bceda9ec94ced24945de2d3e64be23e8a19b">x86_gpr_bp</a>)
<a name="l01390"></a>01390             <span class="keywordflow">return</span> insns.end();
<a name="l01391"></a>01391         matches.insert(ii-&gt;first);
<a name="l01392"></a>01392         ii = insns.find(ii-&gt;first + insn-&gt;<a class="code" href="classSgAsmInstruction.html#6adcc4eb7c725185baa3a2425a57843c">get_size</a>());
<a name="l01393"></a>01393     }
<a name="l01394"></a>01394 
<a name="l01395"></a>01395     <span class="comment">/* Look for "mov rbp,rsp" */</span>
<a name="l01396"></a>01396     {
<a name="l01397"></a>01397         <span class="keywordflow">if</span> (ii==insns.end())
<a name="l01398"></a>01398             <span class="keywordflow">return</span> insns.end();
<a name="l01399"></a>01399         <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(ii-&gt;second);
<a name="l01400"></a>01400         <span class="keywordflow">if</span> (!insn || insn-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()!=<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca55716425893a9bd36fb1384ff05ba92096b7">x86_mov</a>)
<a name="l01401"></a>01401             <span class="keywordflow">return</span> insns.end();
<a name="l01402"></a>01402         <span class="keyword">const</span> <a class="code" href="Cxx__Grammar_8h.html#5ba40394e1b351b2d55384ed355a4077">SgAsmExpressionPtrList</a> &amp;opands = insn-&gt;<a class="code" href="classSgAsmInstruction.html#264e86d032b0a589d9dc520e79d09eb8">get_operandList</a>()-&gt;<a class="code" href="classSgAsmOperandList.html#bb5638c0533863030ad7acee019f1f17">get_operands</a>();
<a name="l01403"></a>01403         <span class="keywordflow">if</span> (opands.size()!=2)
<a name="l01404"></a>01404             <span class="keywordflow">return</span> insns.end();
<a name="l01405"></a>01405         <a class="code" href="classSgAsmx86RegisterReferenceExpression.html">SgAsmx86RegisterReferenceExpression</a> *rre = <a class="code" href="Cxx__Grammar_8h.html#5e5ead71a8653e1d062d92582359e574">isSgAsmx86RegisterReferenceExpression</a>(opands[0]);
<a name="l01406"></a>01406         <span class="keywordflow">if</span> (!rre ||
<a name="l01407"></a>01407             rre-&gt;<a class="code" href="classSgAsmRegisterReferenceExpression.html#e4a2ae3037e897d983674a61bbf16ec0">get_descriptor</a>().<a class="code" href="structRegisterDescriptor.html#00a1b8b124f547095b6409606276a65c">get_major</a>()!=<a class="code" href="InstructionEnumsX86_8h.html#12229bfc0029dbc592944d1d6514e30fbcab68a004f857b0eb9dc6a5b736b1ec">x86_regclass_gpr</a> ||
<a name="l01408"></a>01408             rre-&gt;<a class="code" href="classSgAsmRegisterReferenceExpression.html#e4a2ae3037e897d983674a61bbf16ec0">get_descriptor</a>().<a class="code" href="structRegisterDescriptor.html#2e01183db39faae43a9d6671dd27a12b">get_minor</a>()!=<a class="code" href="InstructionEnumsX86_8h.html#5069ca462f85d162797843f48bc6bceda9ec94ced24945de2d3e64be23e8a19b">x86_gpr_bp</a>)
<a name="l01409"></a>01409             <span class="keywordflow">return</span> insns.end();
<a name="l01410"></a>01410         rre = <a class="code" href="Cxx__Grammar_8h.html#5e5ead71a8653e1d062d92582359e574">isSgAsmx86RegisterReferenceExpression</a>(opands[1]);
<a name="l01411"></a>01411         <span class="keywordflow">if</span> (!rre ||
<a name="l01412"></a>01412             rre-&gt;<a class="code" href="classSgAsmRegisterReferenceExpression.html#e4a2ae3037e897d983674a61bbf16ec0">get_descriptor</a>().<a class="code" href="structRegisterDescriptor.html#00a1b8b124f547095b6409606276a65c">get_major</a>()!=<a class="code" href="InstructionEnumsX86_8h.html#12229bfc0029dbc592944d1d6514e30fbcab68a004f857b0eb9dc6a5b736b1ec">x86_regclass_gpr</a> ||
<a name="l01413"></a>01413             rre-&gt;<a class="code" href="classSgAsmRegisterReferenceExpression.html#e4a2ae3037e897d983674a61bbf16ec0">get_descriptor</a>().<a class="code" href="structRegisterDescriptor.html#2e01183db39faae43a9d6671dd27a12b">get_minor</a>()!=<a class="code" href="InstructionEnumsX86_8h.html#5069ca462f85d162797843f48bc6bced1f5849637e513ff627dc7360562d1ca0">x86_gpr_sp</a>)
<a name="l01414"></a>01414             <span class="keywordflow">return</span> insns.end();
<a name="l01415"></a>01415         matches.insert(ii-&gt;first);
<a name="l01416"></a>01416     }
<a name="l01417"></a>01417 
<a name="l01418"></a>01418     exclude.insert(matches.begin(), matches.end());
<a name="l01419"></a>01419     <span class="keywordflow">return</span> first;
<a name="l01420"></a>01420 }
<a name="l01421"></a>01421 
<a name="l01422"></a>01422 <span class="preprocessor">#if 0 </span><span class="comment">/*commented out in Partitioner::mark_func_patterns()*/</span>
<a name="l01423"></a>01423 <span class="comment">/* Tries to match "nop;nop;nop" followed by something that's not a nop. */</span>
<a name="l01424"></a>01424 Partitioner::InstructionMap::const_iterator
<a name="l01425"></a>01425 Partitioner::pattern2(<span class="keyword">const</span> InstructionMap&amp; insns, InstructionMap::const_iterator first, <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> &amp;exclude)
<a name="l01426"></a>01426 {
<a name="l01427"></a>01427     InstructionMap::const_iterator ii = first;
<a name="l01428"></a>01428     <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> matches;
<a name="l01429"></a>01429 
<a name="l01430"></a>01430     <span class="comment">/* Look for three "nop" instructions */</span>
<a name="l01431"></a>01431     <span class="keywordflow">for</span> (size_t i=0; i&lt;3; i++) {
<a name="l01432"></a>01432         <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *nop = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(ii-&gt;second);
<a name="l01433"></a>01433         if (!nop) <span class="keywordflow">return</span> insns.end();
<a name="l01434"></a>01434         <span class="keywordflow">if</span> (nop-&gt;get_kind()!=<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571d63adb2e8d2f87a48d9eb1b067862d9a">x86_nop</a>) <span class="keywordflow">return</span> insns.end();
<a name="l01435"></a>01435         <span class="keywordflow">if</span> (nop-&gt;get_operandList()-&gt;get_operands().size()!=0) <span class="keywordflow">return</span> insns.end(); <span class="comment">/*only zero-arg NOPs allowed*/</span>
<a name="l01436"></a>01436         matches.insert(ii-&gt;first);
<a name="l01437"></a>01437         ii = insns.find(ii-&gt;first + nop-&gt;get_size());
<a name="l01438"></a>01438         <span class="keywordflow">if</span> (ii==insns.end()) <span class="keywordflow">return</span> insns.end();
<a name="l01439"></a>01439     }
<a name="l01440"></a>01440 
<a name="l01441"></a>01441     <span class="comment">/* Look for something that's not a "nop"; this is the function entry point. */</span>
<a name="l01442"></a>01442     <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *notnop = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(ii-&gt;second);
<a name="l01443"></a>01443     <span class="keywordflow">if</span> (!notnop) <span class="keywordflow">return</span> insns.end();
<a name="l01444"></a>01444     <span class="keywordflow">if</span> (notnop-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()==<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571d63adb2e8d2f87a48d9eb1b067862d9a">x86_nop</a>) <span class="keywordflow">return</span> insns.end();
<a name="l01445"></a>01445     matches.insert(ii-&gt;first);
<a name="l01446"></a>01446 
<a name="l01447"></a>01447     exclude.insert(matches.begin(), matches.end());
<a name="l01448"></a>01448     <span class="keywordflow">return</span> ii;
<a name="l01449"></a>01449 }
<a name="l01450"></a>01450 <span class="preprocessor">#endif</span>
<a name="l01451"></a>01451 <span class="preprocessor"></span>
<a name="l01452"></a>01452 <span class="preprocessor">#if 0 </span><span class="comment">/* commented out in Partitioner::mark_func_patterns() */</span>
<a name="l01453"></a>01453 <span class="comment">/* Tries to match "leave;ret" followed by one or more "nop" followed by a non-nop */</span>
<a name="l01454"></a>01454 Partitioner::InstructionMap::const_iterator
<a name="l01455"></a>01455 Partitioner::pattern3(<span class="keyword">const</span> InstructionMap&amp; insns, InstructionMap::const_iterator first, <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> &amp;exclude)
<a name="l01456"></a>01456 {
<a name="l01457"></a>01457     InstructionMap::const_iterator ii = first;
<a name="l01458"></a>01458     <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> matches;
<a name="l01459"></a>01459 
<a name="l01460"></a>01460     <span class="comment">/* leave; ret; nop */</span>
<a name="l01461"></a>01461     <span class="keywordflow">for</span> (size_t i=0; i&lt;3; i++) {
<a name="l01462"></a>01462         <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(ii-&gt;second);
<a name="l01463"></a>01463         if (!insn) <span class="keywordflow">return</span> insns.end();
<a name="l01464"></a>01464         <span class="keywordflow">if</span> ((i==0 &amp;&amp; insn-&gt;get_kind()!=<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571584c818c922167d8537ee8eb6e0f1cf8">x86_leave</a>) ||
<a name="l01465"></a>01465             (i==1 &amp;&amp; insn-&gt;get_kind()!=<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca557193febfccef733b633e7c6374ea207532">x86_ret</a>)   ||
<a name="l01466"></a>01466             (i==2 &amp;&amp; insn-&gt;get_kind()!=<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571d63adb2e8d2f87a48d9eb1b067862d9a">x86_nop</a>))
<a name="l01467"></a>01467             <span class="keywordflow">return</span> insns.end();
<a name="l01468"></a>01468         matches.insert(ii-&gt;first);
<a name="l01469"></a>01469         ii = insns.find(ii-&gt;first + insn-&gt;get_size());
<a name="l01470"></a>01470         <span class="keywordflow">if</span> (ii==insns.end()) <span class="keywordflow">return</span> insns.end();
<a name="l01471"></a>01471     }
<a name="l01472"></a>01472 
<a name="l01473"></a>01473     <span class="comment">/* Zero or more "nop" instructions */</span>
<a name="l01474"></a>01474     <span class="keywordflow">while</span> (1) {
<a name="l01475"></a>01475         <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(ii-&gt;second);
<a name="l01476"></a>01476         <span class="keywordflow">if</span> (!insn) <span class="keywordflow">return</span> insns.end();
<a name="l01477"></a>01477         <span class="keywordflow">if</span> (insn-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()!=<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571d63adb2e8d2f87a48d9eb1b067862d9a">x86_nop</a>) <span class="keywordflow">break</span>;
<a name="l01478"></a>01478         matches.insert(ii-&gt;first);
<a name="l01479"></a>01479         ii = insns.find(ii-&gt;first + insn-&gt;<a class="code" href="classSgAsmInstruction.html#6adcc4eb7c725185baa3a2425a57843c">get_size</a>());
<a name="l01480"></a>01480         <span class="keywordflow">if</span> (ii==insns.end()) <span class="keywordflow">return</span> insns.end();
<a name="l01481"></a>01481     }
<a name="l01482"></a>01482 
<a name="l01483"></a>01483     <span class="comment">/* This must be something that's not a "nop", but make sure it's an x86 instruction anyway. */</span>
<a name="l01484"></a>01484     <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(ii-&gt;second);
<a name="l01485"></a>01485     <span class="keywordflow">if</span> (!insn) <span class="keywordflow">return</span> insns.end();
<a name="l01486"></a>01486     matches.insert(ii-&gt;first);
<a name="l01487"></a>01487 
<a name="l01488"></a>01488     exclude.insert(matches.begin(), matches.end());
<a name="l01489"></a>01489     <span class="keywordflow">return</span> ii;
<a name="l01490"></a>01490 }
<a name="l01491"></a>01491 <span class="preprocessor">#endif</span>
<a name="l01492"></a>01492 <span class="preprocessor"></span>
<a name="l01496"></a>01496 <span class="keywordtype">void</span>
<a name="l01497"></a><a class="code" href="classPartitioner.html#608c32001c0e56d18e41ce2d77976f9d">01497</a> <a class="code" href="classPartitioner.html#608c32001c0e56d18e41ce2d77976f9d">Partitioner::mark_func_patterns</a>()
<a name="l01498"></a>01498 {
<a name="l01499"></a>01499     <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> exclude;
<a name="l01500"></a>01500     InstructionMap::const_iterator found;
<a name="l01501"></a>01501 
<a name="l01502"></a>01502     <span class="keywordflow">for</span> (InstructionMap::const_iterator ii=insns.begin(); ii!=insns.end(); ++ii) {
<a name="l01503"></a>01503         <span class="keywordflow">if</span> (exclude.find(ii-&gt;first)==exclude.end() &amp;&amp; (found=<a class="code" href="classPartitioner.html#211865359a987a4e353615bb427bda34">pattern1</a>(insns, ii, exclude))!=insns.end())
<a name="l01504"></a>01504             <a class="code" href="classPartitioner.html#91e9b8ad59e4657d6f3dbece95752a4e">add_function</a>(found-&gt;first, <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cd01f7a2ed6ff7e8a3e6c4550d0ccaa63">SgAsmFunction::FUNC_PATTERN</a>);
<a name="l01505"></a>01505     }
<a name="l01506"></a>01506 <span class="preprocessor">#if 0 </span><span class="comment">/* Disabled because NOPs sometimes legitimately appear inside functions */</span>
<a name="l01507"></a>01507     <span class="keywordflow">for</span> (InstructionMap::const_iterator ii=insns.begin(); ii!=insns.end(); ++ii) {
<a name="l01508"></a>01508         <span class="keywordflow">if</span> (exclude.find(ii-&gt;first)==exclude.end() &amp;&amp; (found=pattern2(insns, ii, exclude))!=insns.end())
<a name="l01509"></a>01509             <a class="code" href="classPartitioner.html#91e9b8ad59e4657d6f3dbece95752a4e">add_function</a>(found-&gt;first, <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cd01f7a2ed6ff7e8a3e6c4550d0ccaa63">SgAsmFunction::FUNC_PATTERN</a>);
<a name="l01510"></a>01510     }
<a name="l01511"></a>01511 <span class="preprocessor">#endif</span>
<a name="l01512"></a>01512 <span class="preprocessor"></span><span class="preprocessor">#if 0 </span><span class="comment">/* Disabled because NOPs sometimes follow "leave;ret" for functions with multiple returns. */</span>
<a name="l01513"></a>01513     <span class="keywordflow">for</span> (InstructionMap::const_iterator ii=insns.begin(); ii!=insns.end(); ++ii) {
<a name="l01514"></a>01514         <span class="keywordflow">if</span> (exclude.find(ii-&gt;first)==exclude.end() &amp;&amp; (found=pattern3(insns, ii, exclude))!=insns.end())
<a name="l01515"></a>01515             <a class="code" href="classPartitioner.html#91e9b8ad59e4657d6f3dbece95752a4e">add_function</a>(found-&gt;first, <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cd01f7a2ed6ff7e8a3e6c4550d0ccaa63">SgAsmFunction::FUNC_PATTERN</a>);
<a name="l01516"></a>01516     }
<a name="l01517"></a>01517 <span class="preprocessor">#endif</span>
<a name="l01518"></a>01518 <span class="preprocessor"></span>}
<a name="l01519"></a>01519 
<a name="l01520"></a>01520 <span class="comment">/* Make all CALL/FARCALL targets functions.  This is a naive approach that won't work for some obfuscated software. A more</span>
<a name="l01521"></a>01521 <span class="comment"> * thorough approach considers only those calls that are reachable.  A CALL whose target is the address following the CALL</span>
<a name="l01522"></a>01522 <span class="comment"> * instruction is not counted as a function call. */</span>
<a name="l01523"></a>01523 <span class="keywordtype">void</span>
<a name="l01524"></a><a class="code" href="classPartitioner.html#e9e536212c2e5efdf21ad22993d5c888">01524</a> <a class="code" href="classPartitioner.html#e9e536212c2e5efdf21ad22993d5c888">Partitioner::mark_call_insns</a>()
<a name="l01525"></a>01525 {
<a name="l01526"></a>01526     <span class="keywordflow">for</span> (InstructionMap::const_iterator ii=insns.begin(); ii!=insns.end(); ++ii) {
<a name="l01527"></a>01527         std::vector&lt;SgAsmInstruction*&gt; iv;
<a name="l01528"></a>01528         iv.push_back(ii-&gt;second-&gt;node);
<a name="l01529"></a>01529         <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> target_va=<a class="code" href="classPartitioner.html#7e4a76ae7ab4113b2ec7acf9093c3810">NO_TARGET</a>;
<a name="l01530"></a>01530         <span class="keywordflow">if</span> (ii-&gt;second-&gt;node-&gt;is_function_call(iv, &amp;target_va) &amp;&amp; target_va!=<a class="code" href="classPartitioner.html#7e4a76ae7ab4113b2ec7acf9093c3810">NO_TARGET</a> &amp;&amp;
<a name="l01531"></a>01531             target_va!=ii-&gt;first + ii-&gt;second-&gt;get_size()) {
<a name="l01532"></a>01532             <a class="code" href="classPartitioner.html#91e9b8ad59e4657d6f3dbece95752a4e">add_function</a>(target_va, <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852ceea34044afa2b5415dad4b39cf2aa51d">SgAsmFunction::FUNC_CALL_TARGET</a>, <span class="stringliteral">""</span>);
<a name="l01533"></a>01533         }
<a name="l01534"></a>01534     }
<a name="l01535"></a>01535 }
<a name="l01536"></a>01536 
<a name="l01537"></a>01537 <span class="comment">/* Scan through ranges of contiguous instructions */</span>
<a name="l01538"></a>01538 <span class="keywordtype">void</span>
<a name="l01539"></a><a class="code" href="classPartitioner.html#128338b3c819f629c68058ca40545c18">01539</a> <a class="code" href="classPartitioner.html#128338b3c819f629c68058ca40545c18">Partitioner::scan_contiguous_insns</a>(InstructionMap insns, <a class="code" href="classROSE__Callbacks_1_1List.html">InsnRangeCallbacks</a> &amp;cblist,
<a name="l01540"></a>01540                                    <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a> *prev, <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a> *end)
<a name="l01541"></a>01541 {
<a name="l01542"></a>01542     <span class="keywordflow">while</span> (!insns.empty()) {
<a name="l01543"></a>01543         <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a> *first = insns.begin()-&gt;second;
<a name="l01544"></a>01544         <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va = first-&gt;get_address();
<a name="l01545"></a>01545         InstructionMap::iterator ii = insns.find(va);
<a name="l01546"></a>01546         <a class="code" href="classPartitioner.html#8a540a6d610b0b6746bdb3900842fec7">InstructionVector</a> contig;
<a name="l01547"></a>01547         <span class="keywordflow">while</span> (ii!=insns.end()) {
<a name="l01548"></a>01548             contig.push_back(ii-&gt;second);
<a name="l01549"></a>01549             va += ii-&gt;second-&gt;get_size();
<a name="l01550"></a>01550             ii = insns.find(va);
<a name="l01551"></a>01551         }
<a name="l01552"></a>01552         cblist.<a class="code" href="classROSE__Callbacks_1_1List.html#63489d992c7057770eeb5558bcf681aa">apply</a>(<span class="keyword">true</span>, <a class="code" href="structPartitioner_1_1InsnRangeCallback_1_1Args.html">InsnRangeCallback::Args</a>(<span class="keyword">this</span>, prev, first, end, contig.size()));
<a name="l01553"></a>01553         <span class="keywordflow">for</span> (size_t i=0; i&lt;contig.size(); i++)
<a name="l01554"></a>01554             insns.erase(contig[i]-&gt;get_address());
<a name="l01555"></a>01555     }
<a name="l01556"></a>01556 }
<a name="l01557"></a>01557 
<a name="l01558"></a>01558 <span class="comment">/* Scan through all unassigned instructions */</span>
<a name="l01559"></a>01559 <span class="keywordtype">void</span>
<a name="l01560"></a><a class="code" href="classPartitioner.html#296180568b4a21d4435f264a05f1837f">01560</a> <a class="code" href="classPartitioner.html#296180568b4a21d4435f264a05f1837f">Partitioner::scan_unassigned_insns</a>(<a class="code" href="classROSE__Callbacks_1_1List.html">InsnRangeCallbacks</a> &amp;cblist)
<a name="l01561"></a>01561 {
<a name="l01562"></a>01562     <span class="keywordflow">if</span> (cblist.<a class="code" href="classROSE__Callbacks_1_1List.html#bff578d0b0455e649e0651d1eb8a6b57">empty</a>())
<a name="l01563"></a>01563         <span class="keywordflow">return</span>;
<a name="l01564"></a>01564 
<a name="l01565"></a>01565     <span class="comment">/* We can't iterate over the instruction list while invoking callbacks because one of them might change the instruction</span>
<a name="l01566"></a>01566 <span class="comment">     * list.  Therefore, iterate over a copy of the list.  Instructions are never deleted by the partitioner (only added), so</span>
<a name="l01567"></a>01567 <span class="comment">     * this is safe to do. */</span>
<a name="l01568"></a>01568     <a class="code" href="classPartitioner.html#cff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a> all = this-&gt;insns;
<a name="l01569"></a>01569     <a class="code" href="classPartitioner.html#cff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a> range;
<a name="l01570"></a>01570     <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a> *prev = NULL;
<a name="l01571"></a>01571     <span class="keywordflow">for</span> (InstructionMap::iterator ai=all.begin(); ai!=all.end(); ++ai) {
<a name="l01572"></a>01572         <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = <a class="code" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">find_bb_containing</a>(ai-&gt;first, <span class="keyword">false</span>);
<a name="l01573"></a>01573         <a class="code" href="classPartitioner_1_1Function.html">Function</a> *func = bb ? bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a> : NULL;
<a name="l01574"></a>01574         <span class="keywordflow">if</span> (func) {
<a name="l01575"></a>01575             <span class="keywordflow">if</span> (!range.empty()) {
<a name="l01576"></a>01576                 <a class="code" href="classPartitioner.html#128338b3c819f629c68058ca40545c18">scan_contiguous_insns</a>(range, cblist, prev, ai-&gt;second);
<a name="l01577"></a>01577                 range.clear();
<a name="l01578"></a>01578             }
<a name="l01579"></a>01579             prev = ai-&gt;second;
<a name="l01580"></a>01580         } <span class="keywordflow">else</span> {
<a name="l01581"></a>01581             range.insert(*ai);
<a name="l01582"></a>01582         }
<a name="l01583"></a>01583     }
<a name="l01584"></a>01584     <span class="keywordflow">if</span> (!range.empty())
<a name="l01585"></a>01585         <a class="code" href="classPartitioner.html#128338b3c819f629c68058ca40545c18">scan_contiguous_insns</a>(range, cblist, prev, NULL);
<a name="l01586"></a>01586 }
<a name="l01587"></a>01587 
<a name="l01588"></a>01588 <span class="comment">/* Similar to scan_unassigned_insns except only invokes callbacks when the "prev" and "end" instructions belong to different</span>
<a name="l01589"></a>01589 <span class="comment"> * functions or one of them doesn't exist. */</span>
<a name="l01590"></a>01590 <span class="keywordtype">void</span>
<a name="l01591"></a><a class="code" href="classPartitioner.html#ff3f578d277b534b4e2e703a39414e73">01591</a> <a class="code" href="classPartitioner.html#ff3f578d277b534b4e2e703a39414e73">Partitioner::scan_interfunc_insns</a>(<a class="code" href="classROSE__Callbacks_1_1List.html">InsnRangeCallbacks</a> &amp;cblist)
<a name="l01592"></a>01592 {
<a name="l01593"></a>01593     <span class="keywordflow">if</span> (cblist.<a class="code" href="classROSE__Callbacks_1_1List.html#bff578d0b0455e649e0651d1eb8a6b57">empty</a>())
<a name="l01594"></a>01594         <span class="keywordflow">return</span>;
<a name="l01595"></a>01595 
<a name="l01596"></a>01596     <span class="keyword">struct </span>Filter: <span class="keyword">public</span> <a class="code" href="classPartitioner_1_1InsnRangeCallback.html">InsnRangeCallback</a> {
<a name="l01597"></a>01597         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> operator()(<span class="keywordtype">bool</span> enabled, <span class="keyword">const</span> Args &amp;args) {
<a name="l01598"></a>01598             <span class="keywordflow">if</span> (enabled) {
<a name="l01599"></a>01599                 <span class="keywordflow">if</span> (!args.insn_prev || !args.insn_end)
<a name="l01600"></a>01600                     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01601"></a>01601                 <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb_lt = args.partitioner-&gt;find_bb_containing(args.insn_prev-&gt;get_address(), <span class="keyword">false</span>);
<a name="l01602"></a>01602                 <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb_rt = args.partitioner-&gt;find_bb_containing(args.insn_end-&gt;get_address(), <span class="keyword">false</span>);
<a name="l01603"></a>01603                 assert(bb_lt &amp;&amp; bb_lt-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>); <span class="comment">// because we're invoked from scan_unassigned_insns</span>
<a name="l01604"></a>01604                 assert(bb_rt &amp;&amp; bb_rt-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>); <span class="comment">// ditto</span>
<a name="l01605"></a>01605                 enabled = bb_lt-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a> != bb_rt-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>;
<a name="l01606"></a>01606             }
<a name="l01607"></a>01607             <span class="keywordflow">return</span> enabled;
<a name="l01608"></a>01608         }
<a name="l01609"></a>01609     } filter;
<a name="l01610"></a>01610     <a class="code" href="classROSE__Callbacks_1_1List.html">InsnRangeCallbacks</a> cblist2 = cblist;
<a name="l01611"></a>01611     cblist2.<a class="code" href="classROSE__Callbacks_1_1List.html#d37c05ffc1d74c823990adf35771518e">prepend</a>(&amp;filter);
<a name="l01612"></a>01612     <a class="code" href="classPartitioner.html#296180568b4a21d4435f264a05f1837f">scan_unassigned_insns</a>(cblist2);
<a name="l01613"></a>01613 }
<a name="l01614"></a>01614 
<a name="l01615"></a>01615 <span class="comment">/* Similar to scan_unassigned_insns except only invokes callbacks when "prev" and "end" instructions belong to the same</span>
<a name="l01616"></a>01616 <span class="comment"> * function. */</span>
<a name="l01617"></a>01617 <span class="keywordtype">void</span>
<a name="l01618"></a><a class="code" href="classPartitioner.html#6d6f280eb993c9ec09c0b79d1ae790f7">01618</a> <a class="code" href="classPartitioner.html#6d6f280eb993c9ec09c0b79d1ae790f7">Partitioner::scan_intrafunc_insns</a>(<a class="code" href="classROSE__Callbacks_1_1List.html">InsnRangeCallbacks</a> &amp;cblist)
<a name="l01619"></a>01619 {
<a name="l01620"></a>01620     <span class="keywordflow">if</span> (cblist.<a class="code" href="classROSE__Callbacks_1_1List.html#bff578d0b0455e649e0651d1eb8a6b57">empty</a>())
<a name="l01621"></a>01621         <span class="keywordflow">return</span>;
<a name="l01622"></a>01622 
<a name="l01623"></a>01623     <span class="keyword">struct </span>Filter: <span class="keyword">public</span> <a class="code" href="classPartitioner_1_1InsnRangeCallback.html">InsnRangeCallback</a> {
<a name="l01624"></a>01624         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> operator()(<span class="keywordtype">bool</span> enabled, <span class="keyword">const</span> Args &amp;args) {
<a name="l01625"></a>01625             <span class="keywordflow">if</span> (enabled) {
<a name="l01626"></a>01626                 <span class="keywordflow">if</span> (!args.insn_prev || !args.insn_end)
<a name="l01627"></a>01627                     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01628"></a>01628                 <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb_lt = args.partitioner-&gt;find_bb_containing(args.insn_prev-&gt;get_address(), <span class="keyword">false</span>);
<a name="l01629"></a>01629                 <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb_rt = args.partitioner-&gt;find_bb_containing(args.insn_end-&gt;get_address(), <span class="keyword">false</span>);
<a name="l01630"></a>01630                 assert(bb_lt &amp;&amp; bb_lt-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>); <span class="comment">// because we're invoked from scan_unassigned_insns</span>
<a name="l01631"></a>01631                 assert(bb_rt &amp;&amp; bb_rt-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>); <span class="comment">// ditto</span>
<a name="l01632"></a>01632                 enabled = bb_lt-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a> == bb_rt-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>;
<a name="l01633"></a>01633             }
<a name="l01634"></a>01634             <span class="keywordflow">return</span> enabled;
<a name="l01635"></a>01635         }
<a name="l01636"></a>01636     } filter;
<a name="l01637"></a>01637     <a class="code" href="classROSE__Callbacks_1_1List.html">InsnRangeCallbacks</a> cblist2 = cblist;
<a name="l01638"></a>01638     cblist2.<a class="code" href="classROSE__Callbacks_1_1List.html#d37c05ffc1d74c823990adf35771518e">prepend</a>(&amp;filter);
<a name="l01639"></a>01639     <a class="code" href="classPartitioner.html#296180568b4a21d4435f264a05f1837f">scan_unassigned_insns</a>(cblist2);
<a name="l01640"></a>01640 }
<a name="l01641"></a>01641 
<a name="l01642"></a>01642 <span class="keywordtype">void</span>
<a name="l01643"></a><a class="code" href="classPartitioner.html#9fa138686f888f9a51e6e798a550a285">01643</a> <a class="code" href="classPartitioner.html#9fa138686f888f9a51e6e798a550a285">Partitioner::scan_unassigned_bytes</a>(<a class="code" href="classROSE__Callbacks_1_1List.html">ByteRangeCallbacks</a> &amp;cblist, <a class="code" href="classMemoryMap.html">MemoryMap</a> *restrict_map<span class="comment">/*=NULL*/</span>)
<a name="l01644"></a>01644 {
<a name="l01645"></a>01645     <span class="keywordflow">if</span> (cblist.<a class="code" href="classROSE__Callbacks_1_1List.html#bff578d0b0455e649e0651d1eb8a6b57">empty</a>())
<a name="l01646"></a>01646         <span class="keywordflow">return</span>;
<a name="l01647"></a>01647 
<a name="l01648"></a>01648     <span class="comment">/* Get range map for addresses assigned to functions (function instructions and data w/ function pointers). */</span>
<a name="l01649"></a>01649     <a class="code" href="classRangeMap.html">FunctionRangeMap</a> assigned;
<a name="l01650"></a>01650     <a class="code" href="classPartitioner.html#3a1386d81012e94a46184c4703fd9e40">function_extent</a>(&amp;assigned);
<a name="l01651"></a>01651 
<a name="l01652"></a>01652     <span class="comment">/* Unassigned ranges are the inverse of everything assigned.  Then further restrict the unassigned range map according to</span>
<a name="l01653"></a>01653 <span class="comment">     * the supplied memory map. */</span>
<a name="l01654"></a>01654     <a class="code" href="classExtentMap.html">ExtentMap</a> unassigned = assigned.<a class="code" href="classRangeMap.html#19f65661f7cda3080ef227a72f5833a1">invert</a>&lt;<a class="code" href="classExtentMap.html">ExtentMap</a>&gt;();
<a name="l01655"></a>01655     <span class="keywordflow">if</span> (restrict_map)
<a name="l01656"></a>01656         unassigned.<a class="code" href="classRangeMap.html#00d59a4700389b0d1c2e8b66457db06b">erase_ranges</a>(restrict_map-&gt;<a class="code" href="classMemoryMap.html#8ffed06efb5ddeb4c08c3fcafcc08c20">va_extents</a>().<a class="code" href="classRangeMap.html#19f65661f7cda3080ef227a72f5833a1">invert</a>&lt;<a class="code" href="classExtentMap.html">ExtentMap</a>&gt;());
<a name="l01657"></a>01657 
<a name="l01658"></a>01658     <span class="comment">/* Traverse the unassigned map, invoking the callbacks for each range. */</span>
<a name="l01659"></a>01659     <span class="keywordflow">for</span> (<a class="code" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">ExtentMap::iterator</a> ri=unassigned.<a class="code" href="classRangeMap.html#09ef36a75655f2a1cbb74e60e34df930">begin</a>(); ri!=unassigned.<a class="code" href="classRangeMap.html#db1c2cb143b8d68961dbaf7debbf84e5">end</a>(); ++ri)
<a name="l01660"></a>01660         cblist.<a class="code" href="classROSE__Callbacks_1_1List.html#63489d992c7057770eeb5558bcf681aa">apply</a>(<span class="keyword">true</span>, <a class="code" href="structPartitioner_1_1ByteRangeCallback_1_1Args.html">ByteRangeCallback::Args</a>(<span class="keyword">this</span>, restrict_map, assigned, ri-&gt;first));
<a name="l01661"></a>01661 }
<a name="l01662"></a>01662 
<a name="l01663"></a>01663 <span class="keywordtype">void</span>
<a name="l01664"></a><a class="code" href="classPartitioner.html#a262ad7bb16670512ea037eb06b0ed15">01664</a> <a class="code" href="classPartitioner.html#a262ad7bb16670512ea037eb06b0ed15">Partitioner::scan_intrafunc_bytes</a>(<a class="code" href="classROSE__Callbacks_1_1List.html">ByteRangeCallbacks</a> &amp;cblist, <a class="code" href="classMemoryMap.html">MemoryMap</a> *restrict_map<span class="comment">/*=NULL*/</span>)
<a name="l01665"></a>01665 {
<a name="l01666"></a>01666     <span class="keywordflow">if</span> (cblist.<a class="code" href="classROSE__Callbacks_1_1List.html#bff578d0b0455e649e0651d1eb8a6b57">empty</a>())
<a name="l01667"></a>01667         <span class="keywordflow">return</span>;
<a name="l01668"></a>01668 
<a name="l01669"></a>01669     <span class="keyword">struct </span>Filter: <span class="keyword">public</span> <a class="code" href="classPartitioner_1_1ByteRangeCallback.html">ByteRangeCallback</a> {
<a name="l01670"></a>01670         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> operator()(<span class="keywordtype">bool</span> enabled, <span class="keyword">const</span> Args &amp;args) {
<a name="l01671"></a>01671             <span class="keywordflow">if</span> (enabled) {
<a name="l01672"></a>01672                 <span class="keywordflow">if</span> (args.range.first()&lt;=<a class="code" href="classRange.html#01f96080d72cc93eb611df9032539f6c">Extent::minimum</a>() || args.range.last()&gt;=<a class="code" href="classRange.html#71ec8b29f10d748e6c9548e1b38c2d6f">Extent::maximum</a>())
<a name="l01673"></a>01673                     <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// nothing before and/or after</span>
<a name="l01674"></a>01674 
<a name="l01675"></a>01675                 <span class="comment">/* Find the closest function before this range. */</span>
<a name="l01676"></a>01676                 <a class="code" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">FunctionRangeMap::const_iterator</a> prev = args.ranges.find_prior(args.range.first()-1);
<a name="l01677"></a>01677                 <span class="keywordflow">if</span> (prev==args.ranges.end())
<a name="l01678"></a>01678                     <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// nothing before this range</span>
<a name="l01679"></a>01679 
<a name="l01680"></a>01680                 <span class="comment">/* Find the closest function above this range. */</span>
<a name="l01681"></a>01681                 <a class="code" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">FunctionRangeMap::const_iterator</a> next = args.ranges.lower_bound(args.range.last()+1);
<a name="l01682"></a>01682                 <span class="keywordflow">if</span> (next==args.ranges.end())
<a name="l01683"></a>01683                     <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// nothing after this range</span>
<a name="l01684"></a>01684 
<a name="l01685"></a>01685                 <span class="comment">/* Continue only if this range is between two of the same functions. */</span>
<a name="l01686"></a>01686                 enabled = prev-&gt;second.get()==next-&gt;second.get();
<a name="l01687"></a>01687             }
<a name="l01688"></a>01688             <span class="keywordflow">return</span> enabled;
<a name="l01689"></a>01689         }
<a name="l01690"></a>01690     } filter;
<a name="l01691"></a>01691     <a class="code" href="classROSE__Callbacks_1_1List.html">ByteRangeCallbacks</a> cblist2 = cblist;
<a name="l01692"></a>01692     cblist2.<a class="code" href="classROSE__Callbacks_1_1List.html#d37c05ffc1d74c823990adf35771518e">prepend</a>(&amp;filter);
<a name="l01693"></a>01693     <a class="code" href="classPartitioner.html#9fa138686f888f9a51e6e798a550a285">scan_unassigned_bytes</a>(cblist2, restrict_map);
<a name="l01694"></a>01694 }
<a name="l01695"></a>01695 
<a name="l01696"></a>01696 <span class="keywordtype">void</span>
<a name="l01697"></a><a class="code" href="classPartitioner.html#7f593939f5d8fa66b5e38a25183b4b8f">01697</a> <a class="code" href="classPartitioner.html#7f593939f5d8fa66b5e38a25183b4b8f">Partitioner::scan_interfunc_bytes</a>(<a class="code" href="classROSE__Callbacks_1_1List.html">ByteRangeCallbacks</a> &amp;cblist, <a class="code" href="classMemoryMap.html">MemoryMap</a> *restrict_map<span class="comment">/*=NULL*/</span>)
<a name="l01698"></a>01698 {
<a name="l01699"></a>01699     <span class="keywordflow">if</span> (cblist.<a class="code" href="classROSE__Callbacks_1_1List.html#bff578d0b0455e649e0651d1eb8a6b57">empty</a>())
<a name="l01700"></a>01700         <span class="keywordflow">return</span>;
<a name="l01701"></a>01701 
<a name="l01702"></a>01702     <span class="keyword">struct </span>Filter: <span class="keyword">public</span> <a class="code" href="classPartitioner_1_1ByteRangeCallback.html">ByteRangeCallback</a> {
<a name="l01703"></a>01703         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> operator()(<span class="keywordtype">bool</span> enabled, <span class="keyword">const</span> Args &amp;args) {
<a name="l01704"></a>01704             <span class="keywordflow">if</span> (enabled) {
<a name="l01705"></a>01705                 <span class="keywordflow">if</span> (args.range.first()&lt;=<a class="code" href="classRange.html#01f96080d72cc93eb611df9032539f6c">Extent::minimum</a>() || args.range.last()&gt;=<a class="code" href="classRange.html#71ec8b29f10d748e6c9548e1b38c2d6f">Extent::maximum</a>())
<a name="l01706"></a>01706                     <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// nothing before and/or after</span>
<a name="l01707"></a>01707 
<a name="l01708"></a>01708                 <span class="comment">/* Find the closest function before this range. */</span>
<a name="l01709"></a>01709                 <a class="code" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">FunctionRangeMap::const_iterator</a> prev = args.ranges.find_prior(args.range.first()-1);
<a name="l01710"></a>01710                 <span class="keywordflow">if</span> (prev==args.ranges.end())
<a name="l01711"></a>01711                     <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// nothing before this range</span>
<a name="l01712"></a>01712 
<a name="l01713"></a>01713                 <span class="comment">/* Find the closest function above this range. */</span>
<a name="l01714"></a>01714                 <a class="code" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">FunctionRangeMap::const_iterator</a> next = args.ranges.lower_bound(args.range.last()+1);
<a name="l01715"></a>01715                 <span class="keywordflow">if</span> (next==args.ranges.end())
<a name="l01716"></a>01716                     <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// nothing after this range</span>
<a name="l01717"></a>01717 
<a name="l01718"></a>01718                 <span class="comment">/* Continue only if this range is between two different functions. */</span>
<a name="l01719"></a>01719                 enabled = prev-&gt;second.get()!=next-&gt;second.get();
<a name="l01720"></a>01720             }
<a name="l01721"></a>01721             <span class="keywordflow">return</span> enabled;
<a name="l01722"></a>01722         }
<a name="l01723"></a>01723     } filter;
<a name="l01724"></a>01724     <a class="code" href="classROSE__Callbacks_1_1List.html">ByteRangeCallbacks</a> cblist2 = cblist;
<a name="l01725"></a>01725     cblist2.<a class="code" href="classROSE__Callbacks_1_1List.html#d37c05ffc1d74c823990adf35771518e">prepend</a>(&amp;filter);
<a name="l01726"></a>01726     <a class="code" href="classPartitioner.html#9fa138686f888f9a51e6e798a550a285">scan_unassigned_bytes</a>(cblist2, restrict_map);
<a name="l01727"></a>01727 }
<a name="l01728"></a>01728 
<a name="l01729"></a>01729 <span class="keywordtype">bool</span>
<a name="l01730"></a><a class="code" href="structPartitioner_1_1FindDataPadding.html#65b0ed5e516b2077a0a342452ad1cf18">01730</a> <a class="code" href="structPartitioner_1_1FindDataPadding.html#65b0ed5e516b2077a0a342452ad1cf18">Partitioner::FindDataPadding::operator()</a>(<span class="keywordtype">bool</span> enabled, <span class="keyword">const</span> Args &amp;args)
<a name="l01731"></a>01731 {
<a name="l01732"></a>01732     <span class="keywordflow">if</span> (!enabled)
<a name="l01733"></a>01733         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01734"></a>01734     <a class="code" href="classPartitioner.html">Partitioner</a> *p = args.partitioner;
<a name="l01735"></a>01735     <a class="code" href="classRange.html">Extent</a> range = args.range;
<a name="l01736"></a>01736 
<a name="l01737"></a>01737     <span class="comment">/* What is the maximum pattern length in bytes? */</span>
<a name="l01738"></a>01738     <span class="keywordflow">if</span> (<a class="code" href="structPartitioner_1_1FindDataPadding.html#feb31329993876d61d1911a020ced648">patterns</a>.empty())
<a name="l01739"></a>01739         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01740"></a>01740     size_t max_psize = <a class="code" href="structPartitioner_1_1FindDataPadding.html#feb31329993876d61d1911a020ced648">patterns</a>[0].size();
<a name="l01741"></a>01741     <span class="keywordflow">for</span> (size_t pi=1; pi&lt;<a class="code" href="structPartitioner_1_1FindDataPadding.html#feb31329993876d61d1911a020ced648">patterns</a>.size(); ++pi)
<a name="l01742"></a>01742         max_psize = std::max(max_psize, <a class="code" href="structPartitioner_1_1FindDataPadding.html#feb31329993876d61d1911a020ced648">patterns</a>[pi].size());
<a name="l01743"></a>01743 
<a name="l01744"></a>01744     <span class="comment">/* What is the previous function?  The one to which padding is to be attached. */</span>
<a name="l01745"></a>01745     <span class="keywordflow">if</span> (range.<a class="code" href="classRange.html#130cadb6ba89a4777ca44fa1a6489f27">first</a>()&lt;=<a class="code" href="classRange.html#01f96080d72cc93eb611df9032539f6c">Extent::minimum</a>())
<a name="l01746"></a>01746         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01747"></a>01747     <a class="code" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">FunctionRangeMap::const_iterator</a> prev = <a class="code" href="structPartitioner_1_1FindDataPadding.html#6b5d276a6335acb237a5fac292ed3fd1">begins_contiguously</a> ?
<a name="l01748"></a>01748                                             args.ranges.find(range.<a class="code" href="classRange.html#130cadb6ba89a4777ca44fa1a6489f27">first</a>()-1) :
<a name="l01749"></a>01749                                             args.ranges.find_prior(range.<a class="code" href="classRange.html#130cadb6ba89a4777ca44fa1a6489f27">first</a>()-1);
<a name="l01750"></a>01750     <span class="keywordflow">if</span> (prev==args.ranges.end())
<a name="l01751"></a>01751         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01752"></a>01752     <a class="code" href="classPartitioner_1_1Function.html">Function</a> *func = prev-&gt;second.get();
<a name="l01753"></a>01753     assert(func!=NULL);
<a name="l01754"></a>01754 
<a name="l01755"></a>01755     <span class="comment">/* Do we need to be contiguous with a following function?  This only checks whether the incoming range ends at the</span>
<a name="l01756"></a>01756 <span class="comment">     * beginning of a function.  We'll check below whether a padding sequence also ends at the end of this range. */</span>
<a name="l01757"></a>01757     <span class="keywordflow">if</span> (<a class="code" href="structPartitioner_1_1FindDataPadding.html#bf467f8bd8fe421c05aa827ff2c3ff83">ends_contiguously</a>) {
<a name="l01758"></a>01758         <span class="keywordflow">if</span> (max_psize*<a class="code" href="structPartitioner_1_1FindDataPadding.html#66f37c43985eaece53973cbd448fed23">maximum_nrep</a> &lt; range.<a class="code" href="classRange.html#d2aea45d89cade181ad89a7b75756bf9">size</a>())
<a name="l01759"></a>01759             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01760"></a>01760         <span class="keywordflow">if</span> (range.<a class="code" href="classRange.html#347c0e723bcd929107dc0fffe31478f2">last</a>()&gt;=<a class="code" href="classRange.html#71ec8b29f10d748e6c9548e1b38c2d6f">Extent::maximum</a>())
<a name="l01761"></a>01761             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01762"></a>01762         <a class="code" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">FunctionRangeMap::const_iterator</a> next = args.ranges.find(range.<a class="code" href="classRange.html#347c0e723bcd929107dc0fffe31478f2">last</a>()+1);
<a name="l01763"></a>01763         <span class="keywordflow">if</span> (next==args.ranges.end())
<a name="l01764"></a>01764             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01765"></a>01765     }
<a name="l01766"></a>01766 
<a name="l01767"></a>01767     <span class="comment">/* To keep things simple, we read the entire range (which might not be contigous in the MemoryMap) into a contiguous</span>
<a name="l01768"></a>01768 <span class="comment">     * buffer.  However, that means we had better not try to read huge, anonymous ranges.   Also handle the case of a short</span>
<a name="l01769"></a>01769 <span class="comment">     * read, although this shouldn't happen if the caller supplied the correct memory map to the scan_*_bytes() method. */</span>
<a name="l01770"></a>01770     <span class="keywordflow">if</span> (range.<a class="code" href="classRange.html#d2aea45d89cade181ad89a7b75756bf9">size</a>() &gt; <a class="code" href="structPartitioner_1_1FindDataPadding.html#684ff3383631bc64fdc48a1d56fda272">maximum_range_size</a>)
<a name="l01771"></a>01771         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01772"></a>01772     <a class="code" href="classMemoryMap.html">MemoryMap</a> *<a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a> = args.restrict_map ? args.restrict_map : &amp;p-&gt;<a class="code" href="classPartitioner.html#0b160d2ed1a5b32606e0deaf4c8cbb43">ro_map</a>;
<a name="l01773"></a>01773     <a class="code" href="Cxx__Grammar_8h.html#4f57773a5fc8d0d005f7553cd47cbc4e">SgUnsignedCharList</a> buf = <a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>-&gt;<a class="code" href="classMemoryMap.html#709a3ab13e92a0cbd4a12184e35d4941">read</a>(range.<a class="code" href="classRange.html#130cadb6ba89a4777ca44fa1a6489f27">first</a>(), range.<a class="code" href="classRange.html#d2aea45d89cade181ad89a7b75756bf9">size</a>());
<a name="l01774"></a>01774     <span class="keywordflow">if</span> (<a class="code" href="structPartitioner_1_1FindDataPadding.html#bf467f8bd8fe421c05aa827ff2c3ff83">ends_contiguously</a> &amp;&amp; buf.size()&lt;range.<a class="code" href="classRange.html#d2aea45d89cade181ad89a7b75756bf9">size</a>())
<a name="l01775"></a>01775         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01776"></a>01776     range.<a class="code" href="classRange.html#6d27e17fadca79e6f3851c60ee50d12c">resize</a>(buf.size());
<a name="l01777"></a>01777 
<a name="l01778"></a>01778     <span class="comment">/* There might be more than one sequence of padding bytes.  Look for all of them, but constrained according to</span>
<a name="l01779"></a>01779 <span class="comment">     * begins_contiguously and ends_contiguously. */</span>
<a name="l01780"></a>01780     size_t nblocks = 0; <span class="comment">// number of blocks added to function</span>
<a name="l01781"></a>01781     <span class="keywordflow">while</span> (!range.<a class="code" href="classRange.html#26b4e8bd476025dc8569512b9d27474f">empty</a>()) {
<a name="l01782"></a>01782         <span class="keywordflow">if</span> (<a class="code" href="structPartitioner_1_1FindDataPadding.html#6b5d276a6335acb237a5fac292ed3fd1">begins_contiguously</a> &amp;&amp; range.<a class="code" href="classRange.html#130cadb6ba89a4777ca44fa1a6489f27">first</a>()&gt;args.range.first())
<a name="l01783"></a>01783             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01784"></a>01784         <span class="keywordflow">for</span> (size_t pi=0; pi&lt;<a class="code" href="structPartitioner_1_1FindDataPadding.html#feb31329993876d61d1911a020ced648">patterns</a>.size(); ++pi) {
<a name="l01785"></a>01785             size_t psize = <a class="code" href="structPartitioner_1_1FindDataPadding.html#feb31329993876d61d1911a020ced648">patterns</a>[pi].size();
<a name="l01786"></a>01786             assert(psize&gt;0);
<a name="l01787"></a>01787             size_t nrep = 0;
<a name="l01788"></a>01788             <span class="keywordflow">for</span> (size_t offset=range.<a class="code" href="classRange.html#130cadb6ba89a4777ca44fa1a6489f27">first</a>()-args.range.first();
<a name="l01789"></a>01789                  offset+psize&lt;=buf.size() &amp;&amp; nrep&lt;<a class="code" href="structPartitioner_1_1FindDataPadding.html#66f37c43985eaece53973cbd448fed23">maximum_nrep</a>;
<a name="l01790"></a>01790                  offset+=psize, ++nrep) {
<a name="l01791"></a>01791                 <span class="keywordflow">if</span> (memcmp(&amp;buf[offset], &amp;<a class="code" href="structPartitioner_1_1FindDataPadding.html#feb31329993876d61d1911a020ced648">patterns</a>[pi][0], psize))
<a name="l01792"></a>01792                     <span class="keywordflow">break</span>;
<a name="l01793"></a>01793             }
<a name="l01794"></a>01794             <span class="keywordflow">if</span> (nrep&gt;0 &amp;&amp; nrep&gt;=<a class="code" href="structPartitioner_1_1FindDataPadding.html#33a6ebd0a32698893da1fe3969473314">minimum_nrep</a> &amp;&amp; (!<a class="code" href="structPartitioner_1_1FindDataPadding.html#bf467f8bd8fe421c05aa827ff2c3ff83">ends_contiguously</a> || nrep*psize==range.<a class="code" href="classRange.html#d2aea45d89cade181ad89a7b75756bf9">size</a>())) {
<a name="l01795"></a>01795                 <span class="comment">/* Found a matching repeated pattern.  Add data block to function. */</span>
<a name="l01796"></a>01796                 <a class="code" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *dblock = p-&gt;<a class="code" href="classPartitioner.html#72fe4f436de7235fa06629810a5f1494">find_db_starting</a>(range.<a class="code" href="classRange.html#130cadb6ba89a4777ca44fa1a6489f27">first</a>(), nrep*psize);
<a name="l01797"></a>01797                 assert(dblock!=NULL);
<a name="l01798"></a>01798                 p-&gt;<a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">append</a>(func, dblock, <a class="code" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48c155cde4b70560fc1bf7c615263adf0b0">SgAsmBlock::BLK_PADDING</a>);
<a name="l01799"></a>01799                 ++nblocks;
<a name="l01800"></a>01800                 ++<a class="code" href="structPartitioner_1_1FindDataPadding.html#e069737f1ad1f17a7eb96420bed7c139">nfound</a>;
<a name="l01801"></a>01801                 <span class="keywordflow">if</span> (p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) {
<a name="l01802"></a>01802                     <span class="keywordflow">if</span> (1==nblocks)
<a name="l01803"></a>01803                         fprintf(p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">"Partitioner::FindDataPadding for F%08"</span>PRIx64<span class="stringliteral">": added"</span>, func-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>);
<a name="l01804"></a>01804                     fprintf(p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">" D%08"</span>PRIx64, range.<a class="code" href="classRange.html#130cadb6ba89a4777ca44fa1a6489f27">first</a>());
<a name="l01805"></a>01805                 }
<a name="l01806"></a>01806                 range.<a class="code" href="classRange.html#130cadb6ba89a4777ca44fa1a6489f27">first</a>(range.<a class="code" href="classRange.html#130cadb6ba89a4777ca44fa1a6489f27">first</a>()+nrep*psize-1); <span class="comment">// will be incremented after break</span>
<a name="l01807"></a>01807                 <span class="keywordflow">break</span>;
<a name="l01808"></a>01808             }
<a name="l01809"></a>01809         }
<a name="l01810"></a>01810         <span class="keywordflow">if</span> (!range.<a class="code" href="classRange.html#26b4e8bd476025dc8569512b9d27474f">empty</a>())
<a name="l01811"></a>01811             range.<a class="code" href="classRange.html#130cadb6ba89a4777ca44fa1a6489f27">first</a>(range.<a class="code" href="classRange.html#130cadb6ba89a4777ca44fa1a6489f27">first</a>()+1);
<a name="l01812"></a>01812     }
<a name="l01813"></a>01813     <span class="keywordflow">if</span> (p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a> &amp;&amp; nblocks&gt;0)
<a name="l01814"></a>01814         fprintf(p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">"\n"</span>);
<a name="l01815"></a>01815 
<a name="l01816"></a>01816     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01817"></a>01817 }
<a name="l01818"></a>01818 
<a name="l01819"></a>01819 <span class="keywordtype">bool</span>
<a name="l01820"></a><a class="code" href="structPartitioner_1_1FindData.html#29a959188e5df3c25a0897b0ab9002b6">01820</a> <a class="code" href="structPartitioner_1_1FindData.html#29a959188e5df3c25a0897b0ab9002b6">Partitioner::FindData::operator()</a>(<span class="keywordtype">bool</span> enabled, <span class="keyword">const</span> Args &amp;args)
<a name="l01821"></a>01821 {
<a name="l01822"></a>01822     <span class="keywordflow">if</span> (!enabled)
<a name="l01823"></a>01823         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01824"></a>01824     <a class="code" href="classPartitioner.html">Partitioner</a> *p = args.partitioner;
<a name="l01825"></a>01825 
<a name="l01826"></a>01826     <span class="comment">/* We must have a function immediately before this range and to which this range's data can be attached. */</span>
<a name="l01827"></a>01827     <span class="keywordflow">if</span> (args.range.first()&lt;=<a class="code" href="classRange.html#01f96080d72cc93eb611df9032539f6c">Extent::minimum</a>())
<a name="l01828"></a>01828         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01829"></a>01829     <a class="code" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">FunctionRangeMap::const_iterator</a> prev = args.ranges.find(args.range.first()-1);
<a name="l01830"></a>01830     <span class="keywordflow">if</span> (prev==args.ranges.end())
<a name="l01831"></a>01831         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01832"></a>01832     <a class="code" href="classPartitioner_1_1Function.html">Function</a> *func = prev-&gt;second.get();
<a name="l01833"></a>01833     assert(func!=NULL);
<a name="l01834"></a>01834 
<a name="l01835"></a>01835     <span class="comment">/* Don't append data to non-functions. */</span>
<a name="l01836"></a>01836     <span class="keywordflow">if</span> (0!=(func-&gt;<a class="code" href="classPartitioner_1_1Function.html#84232118f03482d3eb09c76063ef73ef">reason</a> &amp; <a class="code" href="structPartitioner_1_1FindData.html#8a92b8c0d8a8e3bdd6e8820b2f74fcf0">excluded_reasons</a>))
<a name="l01837"></a>01837         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01838"></a>01838 
<a name="l01839"></a>01839     <span class="comment">/* Padding ranges are computed once and cached. */</span>
<a name="l01840"></a>01840     <span class="keywordflow">if</span> (NULL==<a class="code" href="structPartitioner_1_1FindData.html#d9f6d1ebce605c312597fc6f5b04bad2">padding_ranges</a>) {
<a name="l01841"></a>01841         <a class="code" href="structPartitioner_1_1FindData.html#d9f6d1ebce605c312597fc6f5b04bad2">padding_ranges</a> = <span class="keyword">new</span> <a class="code" href="classRangeMap.html">DataRangeMap</a>;
<a name="l01842"></a>01842         p-&gt;<a class="code" href="classPartitioner.html#af310f1d4a77ace2f3b3ecc05e376c20">padding_extent</a>(<a class="code" href="structPartitioner_1_1FindData.html#d9f6d1ebce605c312597fc6f5b04bad2">padding_ranges</a>);
<a name="l01843"></a>01843     }
<a name="l01844"></a>01844 
<a name="l01845"></a>01845     <span class="comment">/* Don't append data if the previous thing is padding. */</span>
<a name="l01846"></a>01846     <span class="keywordflow">if</span> (<a class="code" href="structPartitioner_1_1FindData.html#d9f6d1ebce605c312597fc6f5b04bad2">padding_ranges</a>-&gt;<a class="code" href="classRangeMap.html#3fd9ee5ddde9ab9a00270a47ac2a6055">find</a>(args.range.first()-1)!=<a class="code" href="structPartitioner_1_1FindData.html#d9f6d1ebce605c312597fc6f5b04bad2">padding_ranges</a>-&gt;<a class="code" href="classRangeMap.html#db1c2cb143b8d68961dbaf7debbf84e5">end</a>())
<a name="l01847"></a>01847         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01848"></a>01848 
<a name="l01849"></a>01849     <span class="comment">/* Create a data block and add it to the previous function. */</span>
<a name="l01850"></a>01850     <a class="code" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *dblock = p-&gt;<a class="code" href="classPartitioner.html#72fe4f436de7235fa06629810a5f1494">find_db_starting</a>(args.range.first(), args.range.size());
<a name="l01851"></a>01851     assert(dblock!=NULL);
<a name="l01852"></a>01852     p-&gt;<a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">append</a>(func, dblock, <a class="code" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48c144a1ee419a758d16c0ab329a45c0cda">SgAsmBlock::BLK_FINDDATA</a>);
<a name="l01853"></a>01853     ++<a class="code" href="structPartitioner_1_1FindData.html#744d7c19ffb8d8c80d6a506cedef0645">nfound</a>;
<a name="l01854"></a>01854     <span class="keywordflow">if</span> (p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>)
<a name="l01855"></a>01855         fprintf(p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">"Partitioner::FindData: for F%08"</span>PRIx64<span class="stringliteral">": added D%08"</span>PRIx64<span class="stringliteral">"\n"</span>,
<a name="l01856"></a>01856                 func-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>, args.range.first());
<a name="l01857"></a>01857     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01858"></a>01858 }
<a name="l01859"></a>01859 
<a name="l01860"></a>01860 <span class="comment">/* Create functions or data for inter-function padding instruction sequences.  Returns true if we did not find interfunction</span>
<a name="l01861"></a>01861 <span class="comment"> * padding and other padding callbacks should proceed; returns false if we did find padding and the others should be skipped. */</span>
<a name="l01862"></a>01862 <span class="keywordtype">bool</span>
<a name="l01863"></a><a class="code" href="structPartitioner_1_1FindInsnPadding.html#3571a91a3b823eb2de2c1a2a8a4d6a98">01863</a> <a class="code" href="structPartitioner_1_1FindInsnPadding.html#3571a91a3b823eb2de2c1a2a8a4d6a98">Partitioner::FindInsnPadding::operator()</a>(<span class="keywordtype">bool</span> enabled, <span class="keyword">const</span> Args &amp;args)
<a name="l01864"></a>01864 {
<a name="l01865"></a>01865     <span class="keywordflow">if</span> (!enabled)
<a name="l01866"></a>01866         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01867"></a>01867     <span class="keywordflow">if</span> (!args.insn_prev)
<a name="l01868"></a>01868         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01869"></a>01869     assert(args.ninsns&gt;0);
<a name="l01870"></a>01870     assert(args.insn_prev!=NULL);
<a name="l01871"></a>01871     assert(args.insn_begin!=NULL);
<a name="l01872"></a>01872 
<a name="l01873"></a>01873     <span class="keywordflow">if</span> (<a class="code" href="structPartitioner_1_1FindInsnPadding.html#ef820cd1b1c4009b0d09fb53627a0329">begins_contiguously</a> &amp;&amp;
<a name="l01874"></a>01874         args.insn_begin-&gt;get_address()!=args.insn_prev-&gt;get_address()+args.insn_prev-&gt;get_size())
<a name="l01875"></a>01875         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01876"></a>01876 
<a name="l01877"></a>01877     <span class="comment">/* The preceding function.  We'll add the padding as data to this function, unless we're creating explicity padding</span>
<a name="l01878"></a>01878 <span class="comment">     * functions. */</span>
<a name="l01879"></a>01879     <a class="code" href="classPartitioner.html">Partitioner</a> *p = args.partitioner;
<a name="l01880"></a>01880     <a class="code" href="classPartitioner_1_1Function.html">Function</a> *prev_func = NULL;
<a name="l01881"></a>01881     {
<a name="l01882"></a>01882         <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *last_block = p-&gt;<a class="code" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">find_bb_containing</a>(args.insn_prev-&gt;get_address(), <span class="keyword">false</span>);
<a name="l01883"></a>01883         assert(last_block!=NULL);
<a name="l01884"></a>01884         prev_func = last_block-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>;
<a name="l01885"></a>01885     }
<a name="l01886"></a>01886 
<a name="l01887"></a>01887     <span class="comment">/* Loop over the inter-function instructions and accumulate contiguous ranges of padding. */</span>
<a name="l01888"></a>01888     <span class="keywordtype">bool</span> retval = <span class="keyword">true</span>;
<a name="l01889"></a>01889     <a class="code" href="classPartitioner.html#8a540a6d610b0b6746bdb3900842fec7">InstructionVector</a> padding;
<a name="l01890"></a>01890     <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va = args.insn_begin-&gt;get_address();
<a name="l01891"></a>01891     <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a> *insn = p-&gt;<a class="code" href="classPartitioner.html#1dcdd3e0993256cd5ed93fd4d178679f">find_instruction</a>(va);
<a name="l01892"></a>01892     <span class="keywordflow">for</span> (size_t i=0; i&lt;args.ninsns &amp;&amp; insn!=NULL; i++) {
<a name="l01893"></a>01893 
<a name="l01894"></a>01894         <span class="comment">/* Does this instruction match? */</span>
<a name="l01895"></a>01895         <span class="keywordtype">bool</span> matches = <span class="keyword">false</span>;
<a name="l01896"></a>01896         assert(insn!=NULL); <span class="comment">// callback is being invoked over instructions</span>
<a name="l01897"></a>01897         <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = p-&gt;<a class="code" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">find_bb_containing</a>(va, <span class="keyword">false</span>);
<a name="l01898"></a>01898         <span class="keywordflow">if</span> (bb &amp;&amp; bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>)
<a name="l01899"></a>01899             <span class="keywordflow">break</span>; <span class="comment">// insn is already assigned to a function</span>
<a name="l01900"></a>01900 
<a name="l01901"></a>01901         <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn_x86 = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(p-&gt;<a class="code" href="classPartitioner.html#1dcdd3e0993256cd5ed93fd4d178679f">find_instruction</a>(va));
<a name="l01902"></a>01902         <span class="keywordflow">if</span> (!matches &amp;&amp; insn_x86) {
<a name="l01903"></a>01903             <span class="keywordflow">if</span> (<a class="code" href="structPartitioner_1_1FindInsnPadding.html#880dadbb6d82ff55d32b6478cc39ea6d">x86_kinds</a>.find(insn_x86-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>())!=<a class="code" href="structPartitioner_1_1FindInsnPadding.html#880dadbb6d82ff55d32b6478cc39ea6d">x86_kinds</a>.end())
<a name="l01904"></a>01904                 matches = <span class="keyword">true</span>;
<a name="l01905"></a>01905         }
<a name="l01906"></a>01906 
<a name="l01907"></a>01907         <span class="keywordflow">for</span> (size_t j=0; !matches &amp;&amp; j&lt;<a class="code" href="structPartitioner_1_1FindInsnPadding.html#89ef0d1a8eb2880399ee134de94bc698">byte_patterns</a>.size(); j++) {
<a name="l01908"></a>01908             <span class="keywordflow">if</span> (<a class="code" href="structPartitioner_1_1FindInsnPadding.html#89ef0d1a8eb2880399ee134de94bc698">byte_patterns</a>[j]==insn-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#cafbaec42b52828d4f51e5b579728782">get_raw_bytes</a>())
<a name="l01909"></a>01909                 matches = <span class="keyword">true</span>;
<a name="l01910"></a>01910         }
<a name="l01911"></a>01911 
<a name="l01912"></a>01912 
<a name="l01913"></a>01913         <span class="comment">/* Advance to next instruction, or null. We do this inside the loop so we only need one copy of the code that inserts</span>
<a name="l01914"></a>01914 <span class="comment">         * the basic blocks for padding. */</span>
<a name="l01915"></a>01915         va += insn-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#46940b414c39f0fd10186868d40715f7">get_size</a>();
<a name="l01916"></a>01916         <span class="keywordflow">if</span> (matches)
<a name="l01917"></a>01917             padding.push_back(insn);
<a name="l01918"></a>01918         insn = i+1&lt;args.ninsns ? p-&gt;<a class="code" href="classPartitioner.html#1dcdd3e0993256cd5ed93fd4d178679f">find_instruction</a>(va) : NULL;
<a name="l01919"></a>01919 
<a name="l01920"></a>01920         <span class="comment">/* Do we have padding to insert, and are we at the end of that padding? If not, then continue looping. */</span>
<a name="l01921"></a>01921         <span class="keywordflow">if</span> ((matches &amp;&amp; insn) || padding.empty())
<a name="l01922"></a>01922             <span class="keywordflow">continue</span>; <span class="comment">// try to grab more padding instructions</span>
<a name="l01923"></a>01923         <span class="keywordflow">if</span> (<a class="code" href="structPartitioner_1_1FindInsnPadding.html#ef820cd1b1c4009b0d09fb53627a0329">begins_contiguously</a> &amp;&amp;
<a name="l01924"></a>01924             padding.front()-&gt;get_address()!=args.insn_prev-&gt;get_address()+args.insn_prev-&gt;get_size())
<a name="l01925"></a>01925             <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// no point in even continuing the loop, since we're already past the first instruction now.</span>
<a name="l01926"></a>01926         <span class="keywordflow">if</span> (<a class="code" href="structPartitioner_1_1FindInsnPadding.html#29652be29e0a267cba0d1102d620d475">ends_contiguously</a>) {
<a name="l01927"></a>01927             <span class="keywordflow">if</span> (!matches) {
<a name="l01928"></a>01928                 padding.clear();
<a name="l01929"></a>01929                 <span class="keywordflow">continue</span>;
<a name="l01930"></a>01930             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (args.insn_end) {
<a name="l01931"></a>01931                 <span class="keywordflow">if</span> (padding.back()-&gt;get_address()+padding.back()-&gt;get_size() != args.insn_end-&gt;get_address()) {
<a name="l01932"></a>01932                     padding.clear();
<a name="l01933"></a>01933                     <span class="keywordflow">continue</span>;
<a name="l01934"></a>01934                 }
<a name="l01935"></a>01935             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i+1&lt;args.ninsns) {
<a name="l01936"></a>01936                 padding.clear();
<a name="l01937"></a>01937                 <span class="keywordflow">continue</span>;
<a name="l01938"></a>01938             }
<a name="l01939"></a>01939         }
<a name="l01940"></a>01940 
<a name="l01941"></a>01941         <span class="comment">/* Make sure we got enough bytes.  We can subtract first from last since we know they're contiguous in memory. */</span>
<a name="l01942"></a>01942         <span class="keywordflow">if</span> (padding.back()-&gt;get_address()+padding.back()-&gt;get_size() - padding.front()-&gt;get_address() &lt; <a class="code" href="structPartitioner_1_1FindInsnPadding.html#f0b52f591caf8383d070bdf3107f20cc">minimum_size</a>) {
<a name="l01943"></a>01943             padding.clear();
<a name="l01944"></a>01944             <span class="keywordflow">continue</span>;
<a name="l01945"></a>01945         }
<a name="l01946"></a>01946 
<a name="l01947"></a>01947         <span class="comment">/* If we get here, then we have padding instructions.  Either create a data block to hold the padding, or a new</span>
<a name="l01948"></a>01948 <span class="comment">         * function to hold the padding.  When creating a function, the basic blocks are added as CFG heads, which cause the</span>
<a name="l01949"></a>01949 <span class="comment">         * block to remain with the function even though it might not be reachable by the CFG starting from the function's</span>
<a name="l01950"></a>01950 <span class="comment">         * entry point.  This is especially true for padding like x86 INT3 instructions, which have no known CFG successors and</span>
<a name="l01951"></a>01951 <span class="comment">         * occupy singleton basic blocks. */</span>
<a name="l01952"></a>01952         ++<a class="code" href="structPartitioner_1_1FindInsnPadding.html#3ee7941ea138ffb8442ff5d1d8cd2c5f">nfound</a>;
<a name="l01953"></a>01953         assert(!padding.empty());
<a name="l01954"></a>01954         <span class="keywordflow">if</span> (<a class="code" href="structPartitioner_1_1FindInsnPadding.html#186bf3385d4220cacc90c1b8e0887f66">add_as_data</a>) {
<a name="l01955"></a>01955             assert(prev_func!=NULL);
<a name="l01956"></a>01956             <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> begin_va = padding.front()-&gt;get_address();
<a name="l01957"></a>01957             <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> end_va = padding.back()-&gt;get_address() + padding.back()-&gt;get_size();
<a name="l01958"></a>01958             assert(end_va&gt;begin_va);
<a name="l01959"></a>01959             size_t size = end_va - begin_va;
<a name="l01960"></a>01960             <a class="code" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *dblock = p-&gt;<a class="code" href="classPartitioner.html#72fe4f436de7235fa06629810a5f1494">find_db_starting</a>(begin_va, size);
<a name="l01961"></a>01961             assert(dblock!=NULL);
<a name="l01962"></a>01962             p-&gt;<a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">append</a>(prev_func, dblock, <a class="code" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48c155cde4b70560fc1bf7c615263adf0b0">SgAsmBlock::BLK_PADDING</a>);
<a name="l01963"></a>01963             <span class="keywordflow">for</span> (size_t i=0; i&lt;padding.size(); i++)
<a name="l01964"></a>01964                 p-&gt;<a class="code" href="classPartitioner.html#8b679c9a4b6fb7a7f4f45900d10819c0">discard</a>(padding[i]);
<a name="l01965"></a>01965             <span class="keywordflow">if</span> (p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>)
<a name="l01966"></a>01966                 fprintf(p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">"Partitioner::FindInsnPadding: for F%08"</span>PRIx64<span class="stringliteral">": added D%08"</span>PRIx64<span class="stringliteral">"\n"</span>,
<a name="l01967"></a>01967                         prev_func-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>, begin_va);
<a name="l01968"></a>01968         } <span class="keywordflow">else</span> {
<a name="l01969"></a>01969             <a class="code" href="classPartitioner_1_1Function.html">Function</a> *new_func = p-&gt;<a class="code" href="classPartitioner.html#91e9b8ad59e4657d6f3dbece95752a4e">add_function</a>(padding.front()-&gt;get_address(), <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cdac33191eb0a658ed5382f9076595a28">SgAsmFunction::FUNC_PADDING</a>);
<a name="l01970"></a>01970             p-&gt;<a class="code" href="classPartitioner.html#67702e97dcbfb27fa18f6186fe30538a">find_bb_starting</a>(padding.front()-&gt;get_address()); <span class="comment">// split first block if necessary</span>
<a name="l01971"></a>01971             p-&gt;<a class="code" href="classPartitioner.html#67702e97dcbfb27fa18f6186fe30538a">find_bb_starting</a>(va); <span class="comment">// split last block if necessary</span>
<a name="l01972"></a>01972             <span class="keywordflow">if</span> (p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>)
<a name="l01973"></a>01973                 fprintf(p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">"Partitioner::FindInsnPadding: for F%08"</span>PRIx64<span class="stringliteral">": added"</span>, new_func-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>);
<a name="l01974"></a>01974             <span class="keywordflow">for</span> (size_t i=0; i&lt;padding.size(); i++) {
<a name="l01975"></a>01975                 <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = p-&gt;<a class="code" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">find_bb_containing</a>(padding[i]-&gt;get_address());
<a name="l01976"></a>01976                 <span class="keywordflow">if</span> (bb &amp;&amp; !bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>) {
<a name="l01977"></a>01977                     p-&gt;<a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">append</a>(new_func, bb, <a class="code" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48c155cde4b70560fc1bf7c615263adf0b0">SgAsmBlock::BLK_PADDING</a>, <span class="keyword">true</span><span class="comment">/*head of CFG subgraph*/</span>);
<a name="l01978"></a>01978                     <span class="keywordflow">if</span> (p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>)
<a name="l01979"></a>01979                         fprintf(p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">" B%08"</span>PRIx64<span class="stringliteral">"#%zu"</span>, bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#7e120c89ba03d66a308381c0b82173c9">address</a>(), bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.size());
<a name="l01980"></a>01980                 }
<a name="l01981"></a>01981             }
<a name="l01982"></a>01982             <span class="keywordflow">if</span> (p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>)
<a name="l01983"></a>01983                 fprintf(p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">"\n"</span>);
<a name="l01984"></a>01984         }
<a name="l01985"></a>01985 
<a name="l01986"></a>01986         retval = padding.size()!=args.ninsns; <span class="comment">// allow other callbacks to run only if we didn't suck up all the instructions</span>
<a name="l01987"></a>01987         padding.clear();
<a name="l01988"></a>01988     }
<a name="l01989"></a>01989     <span class="keywordflow">return</span> retval;
<a name="l01990"></a>01990 }
<a name="l01991"></a>01991 
<a name="l01997"></a>01997 <a class="code" href="structPartitioner_1_1DataBlock.html">Partitioner::DataBlock</a> *
<a name="l01998"></a><a class="code" href="classPartitioner.html#72fe4f436de7235fa06629810a5f1494">01998</a> <a class="code" href="classPartitioner.html#72fe4f436de7235fa06629810a5f1494">Partitioner::find_db_starting</a>(<a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> start_va, size_t size<span class="comment">/*=0*/</span>)
<a name="l01999"></a>01999 {
<a name="l02000"></a>02000     <a class="code" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *db = NULL;
<a name="l02001"></a>02001     DataBlocks::iterator dbi = <a class="code" href="classPartitioner.html#b8b08dc01aab15b7ae2dff4af899046f">data_blocks</a>.find(start_va);
<a name="l02002"></a>02002     <span class="keywordflow">if</span> (dbi!=<a class="code" href="classPartitioner.html#b8b08dc01aab15b7ae2dff4af899046f">data_blocks</a>.end()) {
<a name="l02003"></a>02003         db = dbi-&gt;second;
<a name="l02004"></a>02004         if (0==size)
<a name="l02005"></a>02005             <span class="keywordflow">return</span> db; <span class="comment">/* caller doesn't care about the size, only whether the block is present. */</span>
<a name="l02006"></a>02006 
<a name="l02007"></a>02007         <span class="comment">/* Check whether the block contains all the addresses we want. They might not all be in the first node. */</span>
<a name="l02008"></a>02008         <a class="code" href="classRangeMap.html">DataRangeMap</a> want; want.<a class="code" href="classRangeMap.html#df8ef8a1ea1d08b513487c6043ec0d8d">insert</a>(<a class="code" href="Cxx__Grammar_8h.html#d8e49820aaa106bb8a2dc17d9ad38d87">Extent</a>(start_va, size));
<a name="l02009"></a>02009         <a class="code" href="classRangeMap.html">DataRangeMap</a> have; <a class="code" href="classPartitioner.html#b887328bc3f2afab215f8c0e7e5603c9">datablock_extent</a>(db, &amp;have);
<a name="l02010"></a>02010         want.<a class="code" href="classRangeMap.html#00d59a4700389b0d1c2e8b66457db06b">erase_ranges</a>(have);
<a name="l02011"></a>02011         <span class="keywordflow">if</span> (want.<a class="code" href="classRangeMap.html#c8b0d162d933083b16e68f519eb7f953">empty</a>())
<a name="l02012"></a>02012             <span class="keywordflow">return</span> db;
<a name="l02013"></a>02013     }
<a name="l02014"></a>02014     <span class="keywordflow">if</span> (0==size)
<a name="l02015"></a>02015         <span class="keywordflow">return</span> NULL;
<a name="l02016"></a>02016 
<a name="l02017"></a>02017     <span class="comment">/* Create a new SgAsmStaticData node to represent the entire address range and add it to the (possibly new) data block.</span>
<a name="l02018"></a>02018 <span class="comment">     * When adding to an existing block, the new SgAsmStaticData node will overlap with at least the initial node, and possibly</span>
<a name="l02019"></a>02019 <span class="comment">     * others. */</span>
<a name="l02020"></a>02020     <span class="keywordflow">if</span> (!db) {
<a name="l02021"></a>02021         db = <span class="keyword">new</span> <a class="code" href="structPartitioner_1_1DataBlock.html">DataBlock</a>;
<a name="l02022"></a>02022         <a class="code" href="classPartitioner.html#b8b08dc01aab15b7ae2dff4af899046f">data_blocks</a>[start_va] = db;
<a name="l02023"></a>02023     }
<a name="l02024"></a>02024 
<a name="l02025"></a>02025     <a class="code" href="Cxx__Grammar_8h.html#4f57773a5fc8d0d005f7553cd47cbc4e">SgUnsignedCharList</a> raw_bytes = <a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>-&gt;<a class="code" href="classMemoryMap.html#709a3ab13e92a0cbd4a12184e35d4941">read</a>(start_va, size, <a class="code" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd57544ce6196a00fe1b9a997bbd34b607f12">MemoryMap::MM_PROT_NONE</a>);
<a name="l02026"></a>02026     assert(raw_bytes.size()==size);
<a name="l02027"></a>02027     <a class="code" href="classSgAsmStaticData.html">SgAsmStaticData</a> *datum = <span class="keyword">new</span> <a class="code" href="classSgAsmStaticData.html">SgAsmStaticData</a>;
<a name="l02028"></a>02028     datum-&gt;set_address(start_va);
<a name="l02029"></a>02029     datum-&gt;set_raw_bytes(raw_bytes);
<a name="l02030"></a>02030     db-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#fdc2bd13ec3bc86896eebb7ac65fcd08">nodes</a>.push_back(datum);
<a name="l02031"></a>02031 
<a name="l02032"></a>02032     <span class="keywordflow">return</span> db;
<a name="l02033"></a>02033 }
<a name="l02034"></a>02034 
<a name="l02035"></a>02035 <span class="keywordtype">bool</span>
<a name="l02036"></a><a class="code" href="structPartitioner_1_1FindFunctionFragments.html#6a5a21b56c396c822f18d4c693f83ed3">02036</a> <a class="code" href="structPartitioner_1_1FindFunctionFragments.html#6a5a21b56c396c822f18d4c693f83ed3">Partitioner::FindFunctionFragments::operator()</a>(<span class="keywordtype">bool</span> enabled, <span class="keyword">const</span> Args &amp;args)
<a name="l02037"></a>02037 {
<a name="l02038"></a>02038     <span class="keywordflow">if</span> (!enabled)
<a name="l02039"></a>02039         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02040"></a>02040     <a class="code" href="classPartitioner.html">Partitioner</a> *p = args.partitioner;
<a name="l02041"></a>02041 
<a name="l02042"></a>02042     <span class="comment">/* Compute and cache the extents of all known functions. */</span>
<a name="l02043"></a>02043     <span class="keywordflow">if</span> (!<a class="code" href="structPartitioner_1_1FindFunctionFragments.html#8b69cf7285f4a315b39bd128d5d2ab45">function_extents</a>) {
<a name="l02044"></a>02044         <a class="code" href="structPartitioner_1_1FindFunctionFragments.html#8b69cf7285f4a315b39bd128d5d2ab45">function_extents</a> = <span class="keyword">new</span> <a class="code" href="classRangeMap.html">FunctionRangeMap</a>;
<a name="l02045"></a>02045         p-&gt;<a class="code" href="classPartitioner.html#3a1386d81012e94a46184c4703fd9e40">function_extent</a>(<a class="code" href="structPartitioner_1_1FindFunctionFragments.html#8b69cf7285f4a315b39bd128d5d2ab45">function_extents</a>);
<a name="l02046"></a>02046     }
<a name="l02047"></a>02047 
<a name="l02048"></a>02048     <span class="comment">/* Compute and cache code criteria. */</span>
<a name="l02049"></a>02049     <span class="keywordflow">if</span> (!<a class="code" href="structPartitioner_1_1FindFunctionFragments.html#d5b247c8c2f44e4a3cba007a6ebc1c4d">code_criteria</a>) {
<a name="l02050"></a>02050         <a class="code" href="classPartitioner_1_1RegionStats.html">RegionStats</a> *mean = p-&gt;<a class="code" href="classPartitioner.html#b611787b2c6ef70f765031acde40fdd2">aggregate_statistics</a>();
<a name="l02051"></a>02051         <a class="code" href="classPartitioner_1_1RegionStats.html">RegionStats</a> *variance = p-&gt;<a class="code" href="classPartitioner.html#6618693bfecf89c45fdf92a3b4b72cf3">get_aggregate_variance</a>();
<a name="l02052"></a>02052         <a class="code" href="structPartitioner_1_1FindFunctionFragments.html#d5b247c8c2f44e4a3cba007a6ebc1c4d">code_criteria</a> = p-&gt;<a class="code" href="classPartitioner.html#54cffacaad0e5f8d0eb9195a9f9ba7bb">new_code_criteria</a>(mean, variance, <a class="code" href="structPartitioner_1_1FindFunctionFragments.html#c8d84eb37b797f8abdd00cb5e1a66196">threshold</a>);
<a name="l02053"></a>02053     }
<a name="l02054"></a>02054 
<a name="l02055"></a>02055     <span class="comment">/* This range must begin contiguously with a valid function. */</span>
<a name="l02056"></a>02056     <span class="keywordflow">if</span> (args.range.first()&lt;=<a class="code" href="classRange.html#01f96080d72cc93eb611df9032539f6c">Extent::minimum</a>())
<a name="l02057"></a>02057         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02058"></a>02058     <a class="code" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">FunctionRangeMap::iterator</a> prev = <a class="code" href="structPartitioner_1_1FindFunctionFragments.html#8b69cf7285f4a315b39bd128d5d2ab45">function_extents</a>-&gt;<a class="code" href="classRangeMap.html#3fd9ee5ddde9ab9a00270a47ac2a6055">find</a>(args.range.first()-1);
<a name="l02059"></a>02059     <span class="keywordflow">if</span> (prev==<a class="code" href="structPartitioner_1_1FindFunctionFragments.html#8b69cf7285f4a315b39bd128d5d2ab45">function_extents</a>-&gt;<a class="code" href="classRangeMap.html#db1c2cb143b8d68961dbaf7debbf84e5">end</a>())
<a name="l02060"></a>02060         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02061"></a>02061     <a class="code" href="classPartitioner_1_1Function.html">Function</a> *func = prev-&gt;second.get();
<a name="l02062"></a>02062     <span class="keywordflow">if</span> (0!=(func-&gt;<a class="code" href="classPartitioner_1_1Function.html#84232118f03482d3eb09c76063ef73ef">reason</a> &amp; <a class="code" href="structPartitioner_1_1FindFunctionFragments.html#44c5f6559f82db97e7ea6315c70e5ea1">excluded_reasons</a>))
<a name="l02063"></a>02063         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02064"></a>02064 
<a name="l02065"></a>02065     <span class="comment">/* Should this range end contiguously with the same function?  Perhaps we should relax this and only require that the</span>
<a name="l02066"></a>02066 <span class="comment">     * preceding function has an address after this range? [RPM 2011-11-25] */</span>
<a name="l02067"></a>02067     <span class="keywordflow">if</span> (<a class="code" href="structPartitioner_1_1FindFunctionFragments.html#647fe83474ee41f12efc4bd2ba53c079">require_intrafunction</a>) {
<a name="l02068"></a>02068         <span class="keywordflow">if</span> (args.range.last()&gt;=<a class="code" href="classRange.html#71ec8b29f10d748e6c9548e1b38c2d6f">Extent::maximum</a>())
<a name="l02069"></a>02069             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02070"></a>02070         <a class="code" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">FunctionRangeMap::iterator</a> next = <a class="code" href="structPartitioner_1_1FindFunctionFragments.html#8b69cf7285f4a315b39bd128d5d2ab45">function_extents</a>-&gt;<a class="code" href="classRangeMap.html#3fd9ee5ddde9ab9a00270a47ac2a6055">find</a>(args.range.last()+1);
<a name="l02071"></a>02071         <span class="keywordflow">if</span> (next==<a class="code" href="structPartitioner_1_1FindFunctionFragments.html#8b69cf7285f4a315b39bd128d5d2ab45">function_extents</a>-&gt;<a class="code" href="classRangeMap.html#db1c2cb143b8d68961dbaf7debbf84e5">end</a>() || next-&gt;second.get()!=func)
<a name="l02072"></a>02072             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02073"></a>02073     }
<a name="l02074"></a>02074 
<a name="l02075"></a>02075     <span class="comment">/* If the preceding function is interleaved with another then how can we know that the instructions in question should</span>
<a name="l02076"></a>02076 <span class="comment">     * actually belong to this function?  If we're interleaved with one other function, then we could very easily be</span>
<a name="l02077"></a>02077 <span class="comment">     * interleaved with additional functions and this address region could belong to any of them. */</span>
<a name="l02078"></a>02078     <span class="keywordflow">if</span> (<a class="code" href="structPartitioner_1_1FindFunctionFragments.html#0968ba912f25c7f9b8bb92dbadeb2aeb">require_noninterleaved</a> &amp;&amp; !p-&gt;<a class="code" href="classPartitioner.html#8e3fb4de9cbbd0a0bba2c3392f3361f9">is_contiguous</a>(func, <span class="keyword">false</span>))
<a name="l02079"></a>02079         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02080"></a>02080 
<a name="l02081"></a>02081     <span class="comment">/* Bail unless the region statistically looks like code. */</span>
<a name="l02082"></a>02082     <a class="code" href="classExtentMap.html">ExtentMap</a> pending;
<a name="l02083"></a>02083     pending.<a class="code" href="classRangeMap.html#df8ef8a1ea1d08b513487c6043ec0d8d">insert</a>(args.range);
<a name="l02084"></a>02084     <a class="code" href="classPartitioner_1_1RegionStats.html">RegionStats</a> *stats = p-&gt;<a class="code" href="classPartitioner.html#a268f3ccba22f976fa0439a88e77594d">region_statistics</a>(pending);
<a name="l02085"></a>02085     <span class="keywordtype">double</span> raw_vote;
<a name="l02086"></a>02086     <span class="keywordflow">if</span> (!<a class="code" href="structPartitioner_1_1FindFunctionFragments.html#d5b247c8c2f44e4a3cba007a6ebc1c4d">code_criteria</a>-&gt;<a class="code" href="classPartitioner_1_1CodeCriteria.html#9277e67866de503934606ea6d1b7e08e">satisfied_by</a>(stats, &amp;raw_vote))
<a name="l02087"></a>02087         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02088"></a>02088     
<a name="l02089"></a>02089     <span class="comment">/* Get the list of basic blocks for the instructions in this range and their address extents.  Bail if a basic block</span>
<a name="l02090"></a>02090 <span class="comment">     * extends beyond the address ranges we're considering, rather than splitting the block.  Also bail if we encounter two or</span>
<a name="l02091"></a>02091 <span class="comment">     * more instructions that overlap since that's a pretty strong indication that this isn't code. */</span>
<a name="l02092"></a>02092     std::set&lt;BasicBlock*&gt; bblocks;
<a name="l02093"></a>02093     <span class="keywordflow">while</span> (!pending.<a class="code" href="classRangeMap.html#c8b0d162d933083b16e68f519eb7f953">empty</a>()) {
<a name="l02094"></a>02094         <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va = pending.<a class="code" href="classRangeMap.html#edffcf3e970c3707f06b053808dcf9ff">min</a>();
<a name="l02095"></a>02095         <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = va==args.range.first() ? p-&gt;<a class="code" href="classPartitioner.html#67702e97dcbfb27fa18f6186fe30538a">find_bb_starting</a>(va) : p-&gt;<a class="code" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">find_bb_containing</a>(va);
<a name="l02096"></a>02096         <span class="keywordflow">if</span> (!bb || bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>)
<a name="l02097"></a>02097             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02098"></a>02098         <span class="keywordflow">if</span> (bblocks.find(bb)==bblocks.end()) {
<a name="l02099"></a>02099             bblocks.insert(bb);
<a name="l02100"></a>02100             <span class="keywordflow">for</span> (InstructionVector::iterator ii=bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.begin(); ii!=bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.end(); ++ii) {
<a name="l02101"></a>02101                 <a class="code" href="classRange.html">Extent</a> ie((*ii)-&gt;get_address(), (*ii)-&gt;get_size());
<a name="l02102"></a>02102                 <span class="keywordflow">if</span> (!pending.<a class="code" href="classRangeMap.html#cb7a2bd99750f3b48f7667d5f01fe083">contains</a>(ie))
<a name="l02103"></a>02103                     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02104"></a>02104                 pending.<a class="code" href="classRangeMap.html#a601374137845507fa80c404308ac426">erase</a>(ie);
<a name="l02105"></a>02105             }
<a name="l02106"></a>02106         }
<a name="l02107"></a>02107     }
<a name="l02108"></a>02108 
<a name="l02109"></a>02109     <span class="comment">/* All looks good.  Add the basic blocks to the preceding function. */</span>
<a name="l02110"></a>02110     <span class="keywordflow">for</span> (std::set&lt;BasicBlock*&gt;::iterator bi=bblocks.begin(); bi!=bblocks.end(); ++bi) {
<a name="l02111"></a>02111         (*bi)-&gt;code_likelihood = raw_vote;
<a name="l02112"></a>02112         p-&gt;<a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">append</a>(func, *bi, <a class="code" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48c61fa96cc0a9691d08835052ede5b4963">SgAsmBlock::BLK_FRAGMENT</a>, <span class="keyword">true</span><span class="comment">/*CFG head*/</span>);
<a name="l02113"></a>02113         ++<a class="code" href="structPartitioner_1_1FindFunctionFragments.html#1734067dc542497676a1a46ded749112">nfound</a>;
<a name="l02114"></a>02114     }
<a name="l02115"></a>02115 
<a name="l02116"></a>02116     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02117"></a>02117 }
<a name="l02118"></a>02118 
<a name="l02119"></a>02119 <span class="comment">/* Create functions for any basic blocks that consist of only a JMP to another function. */</span>
<a name="l02120"></a>02120 <span class="keywordtype">bool</span>
<a name="l02121"></a><a class="code" href="structPartitioner_1_1FindThunks.html#bcaf0f2a7797f23d60bdbff4f355bc0c">02121</a> <a class="code" href="structPartitioner_1_1FindThunks.html#bcaf0f2a7797f23d60bdbff4f355bc0c">Partitioner::FindThunks::operator()</a>(<span class="keywordtype">bool</span> enabled, <span class="keyword">const</span> Args &amp;args)
<a name="l02122"></a>02122 {
<a name="l02123"></a>02123     <span class="keywordflow">if</span> (!enabled)
<a name="l02124"></a>02124         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02125"></a>02125 
<a name="l02126"></a>02126     <a class="code" href="classPartitioner.html">Partitioner</a> *p = args.partitioner;
<a name="l02127"></a>02127     <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va = args.insn_begin-&gt;get_address();
<a name="l02128"></a>02128     <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> next_va = 0;
<a name="l02129"></a>02129     <span class="keywordflow">for</span> (size_t i=0; i&lt;args.ninsns; i++, va=next_va) {
<a name="l02130"></a>02130         <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a> *insn = p-&gt;<a class="code" href="classPartitioner.html#1dcdd3e0993256cd5ed93fd4d178679f">find_instruction</a>(va);
<a name="l02131"></a>02131         assert(insn);
<a name="l02132"></a>02132         next_va = va + insn-&gt;<a class="code" href="classSgAsmInstruction.html#6adcc4eb7c725185baa3a2425a57843c">get_size</a>();
<a name="l02133"></a>02133 
<a name="l02134"></a>02134         <span class="comment">/* Instruction must be an x86 JMP */</span>
<a name="l02135"></a>02135         <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn_x86 = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(insn);
<a name="l02136"></a>02136         <span class="keywordflow">if</span> (!insn_x86 || (insn_x86-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()!=<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571ad03bc3cf5ca0f4918d34b66a2ae0b24">x86_jmp</a> &amp;&amp; insn_x86-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()!=<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca557198fb4c6bacf21d45da2c1eb7380caccc">x86_farjmp</a>))
<a name="l02137"></a>02137             <span class="keywordflow">continue</span>;
<a name="l02138"></a>02138 
<a name="l02139"></a>02139         <span class="comment">/* Instruction must not be in the middle of an existing basic block. */</span>
<a name="l02140"></a>02140         <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = p-&gt;<a class="code" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">find_bb_containing</a>(va, <span class="keyword">false</span>);
<a name="l02141"></a>02141         <span class="keywordflow">if</span> (bb &amp;&amp; bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#7e120c89ba03d66a308381c0b82173c9">address</a>()!=va)
<a name="l02142"></a>02142             <span class="keywordflow">continue</span>;
<a name="l02143"></a>02143 
<a name="l02144"></a>02144         <span class="keywordflow">if</span> (<a class="code" href="structPartitioner_1_1FindThunks.html#0e586c0af4c138b3f6c35de5f9901a49">validate_targets</a>) {
<a name="l02145"></a>02145             <span class="comment">/* Instruction must have a single successor */</span>
<a name="l02146"></a>02146             <span class="keywordtype">bool</span> complete;
<a name="l02147"></a>02147             <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> succs = insn-&gt;<a class="code" href="classSgAsmx86Instruction.html#e43b0ae94f1e860f93fd9a17300a6ef5">get_successors</a>(&amp;complete);
<a name="l02148"></a>02148             <span class="keywordflow">if</span> (!complete &amp;&amp; 1!=succs.size())
<a name="l02149"></a>02149                 <span class="keywordflow">continue</span>;
<a name="l02150"></a>02150             <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> target_va = *succs.begin();
<a name="l02151"></a>02151 
<a name="l02152"></a>02152             <span class="comment">/* The target (single successor) must be a known function which is not padding. */</span>
<a name="l02153"></a>02153             Functions::iterator fi = p-&gt;<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.find(target_va);
<a name="l02154"></a>02154             <span class="keywordflow">if</span> (fi==p-&gt;<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.end() || 0!=(fi-&gt;second-&gt;reason &amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cdac33191eb0a658ed5382f9076595a28">SgAsmFunction::FUNC_PADDING</a>))
<a name="l02155"></a>02155                 <span class="keywordflow">continue</span>;
<a name="l02156"></a>02156         }
<a name="l02157"></a>02157 
<a name="l02158"></a>02158         <span class="comment">/* Create the basic block for the JMP instruction.  This block must be a single instruction, which it should be since</span>
<a name="l02159"></a>02159 <span class="comment">         * we already checked that its only successor is another function. */</span>
<a name="l02160"></a>02160         <span class="keywordflow">if</span> (!bb)
<a name="l02161"></a>02161             bb = p-&gt;<a class="code" href="classPartitioner.html#67702e97dcbfb27fa18f6186fe30538a">find_bb_starting</a>(va);
<a name="l02162"></a>02162         assert(bb!=NULL);
<a name="l02163"></a>02163         assert(1==bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.size());
<a name="l02164"></a>02164         <a class="code" href="classPartitioner_1_1Function.html">Function</a> *thunk = p-&gt;<a class="code" href="classPartitioner.html#91e9b8ad59e4657d6f3dbece95752a4e">add_function</a>(va, <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c331ffe7c063699b34757276068c08d79">SgAsmFunction::FUNC_THUNK</a>);
<a name="l02165"></a>02165         p-&gt;<a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">append</a>(thunk, bb, <a class="code" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48ccb1cb50df0cb421e21b3ca064d1122e0">SgAsmBlock::BLK_ENTRY_POINT</a>);
<a name="l02166"></a>02166         ++<a class="code" href="structPartitioner_1_1FindThunks.html#2689fcf231b7a9657169b8e3c369bc71">nfound</a>;
<a name="l02167"></a>02167 
<a name="l02168"></a>02168         <span class="keywordflow">if</span> (p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>)
<a name="l02169"></a>02169             fprintf(p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">"Partitioner::FindThunks: found F%08"</span>PRIx64<span class="stringliteral">"\n"</span>, va);
<a name="l02170"></a>02170     }
<a name="l02171"></a>02171 
<a name="l02172"></a>02172     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02173"></a>02173 }
<a name="l02174"></a>02174 
<a name="l02175"></a>02175 <span class="keywordtype">bool</span>
<a name="l02176"></a><a class="code" href="structPartitioner_1_1FindInterPadFunctions.html#76b72a15ad3f327dab06f1a3804a2835">02176</a> <a class="code" href="structPartitioner_1_1FindInterPadFunctions.html#76b72a15ad3f327dab06f1a3804a2835">Partitioner::FindInterPadFunctions::operator()</a>(<span class="keywordtype">bool</span> enabled, <span class="keyword">const</span> Args &amp;args)
<a name="l02177"></a>02177 {
<a name="l02178"></a>02178     <span class="keywordflow">if</span> (!enabled)
<a name="l02179"></a>02179         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02180"></a>02180     <a class="code" href="classPartitioner.html">Partitioner</a> *p = args.partitioner;
<a name="l02181"></a>02181 
<a name="l02182"></a>02182     <span class="comment">/* Initialize the data block ranges once and cache it in this object. */</span>
<a name="l02183"></a>02183     <span class="keywordflow">if</span> (!<a class="code" href="structPartitioner_1_1FindInterPadFunctions.html#77e8b4c3c10e7614c46d3596e95fe53c">padding_ranges</a>) {
<a name="l02184"></a>02184         <a class="code" href="structPartitioner_1_1FindInterPadFunctions.html#77e8b4c3c10e7614c46d3596e95fe53c">padding_ranges</a> = <span class="keyword">new</span> <a class="code" href="classRangeMap.html">DataRangeMap</a>;
<a name="l02185"></a>02185         p-&gt;<a class="code" href="classPartitioner.html#af310f1d4a77ace2f3b3ecc05e376c20">padding_extent</a>(<a class="code" href="structPartitioner_1_1FindInterPadFunctions.html#77e8b4c3c10e7614c46d3596e95fe53c">padding_ranges</a>);
<a name="l02186"></a>02186     }
<a name="l02187"></a>02187 
<a name="l02188"></a>02188     <span class="comment">/* Range must be immediately preceded by a padding block. */</span>
<a name="l02189"></a>02189     <span class="keywordflow">if</span> (args.range.first()&lt;=<a class="code" href="classRange.html#01f96080d72cc93eb611df9032539f6c">Extent::minimum</a>())
<a name="l02190"></a>02190         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02191"></a>02191     <span class="keywordflow">if</span> (<a class="code" href="structPartitioner_1_1FindInterPadFunctions.html#77e8b4c3c10e7614c46d3596e95fe53c">padding_ranges</a>-&gt;<a class="code" href="classRangeMap.html#3fd9ee5ddde9ab9a00270a47ac2a6055">find</a>(args.range.first()-1) == <a class="code" href="structPartitioner_1_1FindInterPadFunctions.html#77e8b4c3c10e7614c46d3596e95fe53c">padding_ranges</a>-&gt;<a class="code" href="classRangeMap.html#db1c2cb143b8d68961dbaf7debbf84e5">end</a>())
<a name="l02192"></a>02192         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02193"></a>02193 
<a name="l02194"></a>02194     <span class="comment">/* Range must be immediately followed by a padding block. */</span>
<a name="l02195"></a>02195     <span class="keywordflow">if</span> (args.range.last()&gt;=<a class="code" href="classRange.html#71ec8b29f10d748e6c9548e1b38c2d6f">Extent::maximum</a>())
<a name="l02196"></a>02196         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02197"></a>02197     <a class="code" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">DataRangeMap::iterator</a> next = <a class="code" href="structPartitioner_1_1FindInterPadFunctions.html#77e8b4c3c10e7614c46d3596e95fe53c">padding_ranges</a>-&gt;<a class="code" href="classRangeMap.html#3fd9ee5ddde9ab9a00270a47ac2a6055">find</a>(args.range.last()+1);
<a name="l02198"></a>02198     <span class="keywordflow">if</span> (next==<a class="code" href="structPartitioner_1_1FindInterPadFunctions.html#77e8b4c3c10e7614c46d3596e95fe53c">padding_ranges</a>-&gt;<a class="code" href="classRangeMap.html#db1c2cb143b8d68961dbaf7debbf84e5">end</a>())
<a name="l02199"></a>02199         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02200"></a>02200     <a class="code" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *next_dblock = next-&gt;second.get();
<a name="l02201"></a>02201 
<a name="l02202"></a>02202     <span class="comment">/* Create a new function and move the following padding to the new function. */</span>
<a name="l02203"></a>02203     <a class="code" href="classPartitioner_1_1Function.html">Function</a> *new_func = p-&gt;<a class="code" href="classPartitioner.html#91e9b8ad59e4657d6f3dbece95752a4e">add_function</a>(args.range.first(), <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cd44eac551768752e50ac7d0b02beab24">SgAsmFunction::FUNC_INTERPADFUNC</a>);
<a name="l02204"></a>02204     p-&gt;<a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">append</a>(new_func, next_dblock, <a class="code" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48c155cde4b70560fc1bf7c615263adf0b0">SgAsmBlock::BLK_PADDING</a>, <span class="keyword">true</span><span class="comment">/*force*/</span>);
<a name="l02205"></a>02205     ++<a class="code" href="structPartitioner_1_1FindInterPadFunctions.html#75adb69d444a81663e01ae0f6b9d4f5c">nfound</a>;
<a name="l02206"></a>02206 
<a name="l02207"></a>02207     <span class="keywordflow">if</span> (p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>)
<a name="l02208"></a>02208         fprintf(p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">"Partitioner::FindInterPadFunctions: added F%08"</span>PRIx64<span class="stringliteral">"\n"</span>, new_func-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>);
<a name="l02209"></a>02209     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02210"></a>02210 }
<a name="l02211"></a>02211 
<a name="l02212"></a>02212 <span class="keywordtype">bool</span>
<a name="l02213"></a><a class="code" href="structPartitioner_1_1FindThunkTables.html#6b04620cb35e22eefbda50f1e2c3e14c">02213</a> <a class="code" href="structPartitioner_1_1FindThunkTables.html#6b04620cb35e22eefbda50f1e2c3e14c">Partitioner::FindThunkTables::operator()</a>(<span class="keywordtype">bool</span> enabled, <span class="keyword">const</span> Args &amp;args)
<a name="l02214"></a>02214 {
<a name="l02215"></a>02215     <span class="keywordflow">if</span> (!enabled)
<a name="l02216"></a>02216         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02217"></a>02217     <a class="code" href="classPartitioner.html">Partitioner</a> *p = args.partitioner;
<a name="l02218"></a>02218     <a class="code" href="classRange.html">Extent</a> range = args.range;
<a name="l02219"></a>02219 
<a name="l02220"></a>02220     <span class="keywordflow">while</span> (!range.<a class="code" href="classRange.html#26b4e8bd476025dc8569512b9d27474f">empty</a>()) {
<a name="l02221"></a>02221 
<a name="l02222"></a>02222         <span class="comment">/* Find a single, contiguous thunk table. */</span>
<a name="l02223"></a>02223         <a class="code" href="classPartitioner.html#cff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a> thunks; <span class="comment">// each thunk is a single JMP instruction</span>
<a name="l02224"></a>02224         <span class="keywordtype">bool</span> in_table = <span class="keyword">false</span>;
<a name="l02225"></a>02225         <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va;
<a name="l02226"></a>02226         <span class="keywordflow">for</span> (va=range.<a class="code" href="classRange.html#130cadb6ba89a4777ca44fa1a6489f27">first</a>(); va&lt;=range.<a class="code" href="classRange.html#347c0e723bcd929107dc0fffe31478f2">last</a>() &amp;&amp; (in_table || thunks.empty()); va++) {
<a name="l02227"></a>02227             <span class="keywordflow">if</span> (<a class="code" href="structPartitioner_1_1FindThunkTables.html#7fc8dd4714f84b8ba2654e5a8d2cacd2">begins_contiguously</a> &amp;&amp; !in_table &amp;&amp; va&gt;args.range.first())
<a name="l02228"></a>02228                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02229"></a>02229 
<a name="l02230"></a>02230             <span class="comment">/* Must be a JMP instruction. */</span>
<a name="l02231"></a>02231             <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a> *insn = p-&gt;<a class="code" href="classPartitioner.html#1dcdd3e0993256cd5ed93fd4d178679f">find_instruction</a>(va);
<a name="l02232"></a>02232             <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn_x86 = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(insn);
<a name="l02233"></a>02233             <span class="keywordflow">if</span> (!insn_x86 || (insn_x86-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()!=<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571ad03bc3cf5ca0f4918d34b66a2ae0b24">x86_jmp</a> &amp;&amp; insn_x86-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()!=<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca557198fb4c6bacf21d45da2c1eb7380caccc">x86_farjmp</a>)) {
<a name="l02234"></a>02234                 in_table = <span class="keyword">false</span>;
<a name="l02235"></a>02235                 <span class="keywordflow">continue</span>;
<a name="l02236"></a>02236             }
<a name="l02237"></a>02237 
<a name="l02238"></a>02238             <span class="comment">/* Instruction must not be part of a larger basic block. Be careful not to create basic blocks unecessarily. */</span>
<a name="l02239"></a>02239             <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = p-&gt;<a class="code" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">find_bb_containing</a>(va, <span class="keyword">false</span>);
<a name="l02240"></a>02240             <span class="keywordflow">if</span> (bb &amp;&amp; bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.size()&gt;1) {
<a name="l02241"></a>02241                 in_table = <span class="keyword">false</span>;
<a name="l02242"></a>02242                 <span class="keywordflow">continue</span>;
<a name="l02243"></a>02243             }
<a name="l02244"></a>02244             <span class="keywordflow">if</span> (!bb)
<a name="l02245"></a>02245                 bb = p-&gt;<a class="code" href="classPartitioner.html#67702e97dcbfb27fa18f6186fe30538a">find_bb_starting</a>(va);
<a name="l02246"></a>02246             assert(bb!=NULL);
<a name="l02247"></a>02247 
<a name="l02248"></a>02248             <span class="keywordflow">if</span> (<a class="code" href="structPartitioner_1_1FindThunkTables.html#6af964ccb6b86516db4cf1b1577cfbd8">validate_targets</a>) {
<a name="l02249"></a>02249                 <span class="comment">/* Find successors of the JMP instruction. */</span>
<a name="l02250"></a>02250                 <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> succs;
<a name="l02251"></a>02251                 <span class="keywordtype">bool</span> complete;
<a name="l02252"></a>02252                 <span class="keywordflow">if</span> (bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.size()&gt;1) {
<a name="l02253"></a>02253                     succs.insert(bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>[1]-&gt;get_address());
<a name="l02254"></a>02254                     complete = <span class="keyword">true</span>;
<a name="l02255"></a>02255                 } <span class="keywordflow">else</span> {
<a name="l02256"></a>02256                     succs = p-&gt;<a class="code" href="classPartitioner.html#e2e3e09e5194ba8c87bc968b65b63e3c">successors</a>(bb, &amp;complete);
<a name="l02257"></a>02257                 }
<a name="l02258"></a>02258 
<a name="l02259"></a>02259                 <span class="comment">/* If the successor is known, it should point to another instruction. */</span>
<a name="l02260"></a>02260                 <span class="keywordtype">bool</span> points_to_insn = <span class="keyword">true</span>;
<a name="l02261"></a>02261                 <span class="keywordflow">for</span> (Disassembler::AddressSet::iterator si=succs.begin(); si!=succs.end() &amp;&amp; points_to_insn; ++si)
<a name="l02262"></a>02262                     points_to_insn = NULL != p-&gt;<a class="code" href="classPartitioner.html#1dcdd3e0993256cd5ed93fd4d178679f">find_instruction</a>(*si);
<a name="l02263"></a>02263                 <span class="keywordflow">if</span> (!points_to_insn) {
<a name="l02264"></a>02264                     in_table = <span class="keyword">false</span>;
<a name="l02265"></a>02265                     <span class="keywordflow">continue</span>;
<a name="l02266"></a>02266                 }
<a name="l02267"></a>02267             }
<a name="l02268"></a>02268 
<a name="l02269"></a>02269             <span class="comment">/* This is a thunk. Save it and skip ahead to the start of the following instruction. */</span>
<a name="l02270"></a>02270             in_table = <span class="keyword">true</span>;
<a name="l02271"></a>02271             thunks[insn-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#a9c8dd5cf80780b59c4e74e4bb8b2811">get_address</a>()] = insn;
<a name="l02272"></a>02272             va += insn-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#46940b414c39f0fd10186868d40715f7">get_size</a>() - 1; <span class="comment">// also incremented by loop</span>
<a name="l02273"></a>02273         }
<a name="l02274"></a>02274 
<a name="l02275"></a>02275         <span class="comment">/* This is only a thunk table if we found enough thunks and (if appropriate) ends at the end of the range. */</span>
<a name="l02276"></a>02276         <span class="keywordflow">if</span> (thunks.size()&gt;<a class="code" href="structPartitioner_1_1FindThunkTables.html#87b2107fff1914c79e5419cf3a710a28">minimum_nthunks</a> &amp;&amp; (!<a class="code" href="structPartitioner_1_1FindThunkTables.html#07e2f8dd5c208907265a831aed2edb24">ends_contiguously</a> || va==args.range.last()+1)) {
<a name="l02277"></a>02277             <span class="keywordflow">for</span> (InstructionMap::iterator ii=thunks.begin(); ii!=thunks.end(); ++ii) {
<a name="l02278"></a>02278                 <a class="code" href="classPartitioner_1_1Function.html">Function</a> *thunk = p-&gt;<a class="code" href="classPartitioner.html#91e9b8ad59e4657d6f3dbece95752a4e">add_function</a>(ii-&gt;first, <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c331ffe7c063699b34757276068c08d79">SgAsmFunction::FUNC_THUNK</a>);
<a name="l02279"></a>02279                 <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = p-&gt;<a class="code" href="classPartitioner.html#67702e97dcbfb27fa18f6186fe30538a">find_bb_starting</a>(ii-&gt;first);
<a name="l02280"></a>02280                 p-&gt;<a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">append</a>(thunk, bb, <a class="code" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48ccb1cb50df0cb421e21b3ca064d1122e0">SgAsmBlock::BLK_ENTRY_POINT</a>);
<a name="l02281"></a>02281                 ++<a class="code" href="structPartitioner_1_1FindThunkTables.html#5e5cdbe0703bb2c1d3b0daabba654ac7">nfound</a>;
<a name="l02282"></a>02282                 <span class="keywordflow">if</span> (p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>)
<a name="l02283"></a>02283                     fprintf(p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">"Partitioner::FindThunkTable: thunk F%08"</span>PRIx64<span class="stringliteral">"\n"</span>, thunk-&gt;entry_va);
<a name="l02284"></a>02284             }
<a name="l02285"></a>02285         }
<a name="l02286"></a>02286 
<a name="l02287"></a>02287         range.<a class="code" href="classRange.html#130cadb6ba89a4777ca44fa1a6489f27">first</a>(va);
<a name="l02288"></a>02288     }
<a name="l02289"></a>02289     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02290"></a>02290 }
<a name="l02291"></a>02291 
<a name="l02299"></a>02299 <span class="keywordtype">bool</span>
<a name="l02300"></a><a class="code" href="classPartitioner.html#64d3ebb83d085cd1709305c13a2bbd7d">02300</a> <a class="code" href="classPartitioner.html#64d3ebb83d085cd1709305c13a2bbd7d">Partitioner::is_thunk</a>(<a class="code" href="classPartitioner_1_1Function.html">Function</a> *func)
<a name="l02301"></a>02301 {
<a name="l02302"></a>02302     assert(func);
<a name="l02303"></a>02303     <span class="keywordflow">if</span> (1!=func-&gt;<a class="code" href="classPartitioner_1_1Function.html#8bdb95ca10afda44f8dacb28248f5c6c">basic_blocks</a>.size())
<a name="l02304"></a>02304         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02305"></a>02305 
<a name="l02306"></a>02306     <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = func-&gt;<a class="code" href="classPartitioner_1_1Function.html#8bdb95ca10afda44f8dacb28248f5c6c">basic_blocks</a>.begin()-&gt;second;
<a name="l02307"></a>02307     <span class="keywordflow">if</span> (1!=bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.size())
<a name="l02308"></a>02308         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02309"></a>02309 
<a name="l02310"></a>02310     <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a> *insn = bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.front();
<a name="l02311"></a>02311     <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn_x86 = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(insn);
<a name="l02312"></a>02312     <span class="keywordflow">if</span> (!insn_x86 || (insn_x86-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()!=<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571ad03bc3cf5ca0f4918d34b66a2ae0b24">x86_jmp</a> &amp;&amp; insn_x86-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()!=<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca557198fb4c6bacf21d45da2c1eb7380caccc">x86_farjmp</a>))
<a name="l02313"></a>02313         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02314"></a>02314 
<a name="l02315"></a>02315     <span class="keywordtype">bool</span> complete;
<a name="l02316"></a>02316     <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> succs = <a class="code" href="classPartitioner.html#e2e3e09e5194ba8c87bc968b65b63e3c">successors</a>(bb, &amp;complete);
<a name="l02317"></a>02317     <span class="keywordflow">if</span> (!complete || 1!=succs.size())
<a name="l02318"></a>02318         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02319"></a>02319 
<a name="l02320"></a>02320     <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> target_va = *succs.begin();
<a name="l02321"></a>02321     Functions::iterator fi = <a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.find(target_va);
<a name="l02322"></a>02322     <a class="code" href="classPartitioner_1_1Function.html">Function</a> *target_func = fi==<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.end() ? NULL : fi-&gt;second;
<a name="l02323"></a>02323     <span class="keywordflow">if</span> (!target_func)
<a name="l02324"></a>02324         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02325"></a>02325 
<a name="l02326"></a>02326     <span class="keywordflow">if</span> (0!=(target_func-&gt;<a class="code" href="classPartitioner_1_1Function.html#84232118f03482d3eb09c76063ef73ef">reason</a> &amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c617301fe6a598b9c4afbde0aebcc8ad5">SgAsmFunction::FUNC_LEFTOVERS</a>) ||
<a name="l02327"></a>02327         0!=(fi-&gt;second-&gt;reason &amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cdac33191eb0a658ed5382f9076595a28">SgAsmFunction::FUNC_PADDING</a>))
<a name="l02328"></a>02328         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02329"></a>02329 
<a name="l02330"></a>02330     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02331"></a>02331 }
<a name="l02332"></a>02332 
<a name="l02333"></a>02333 <span class="keywordtype">bool</span>
<a name="l02334"></a><a class="code" href="structPartitioner_1_1FindPostFunctionInsns.html#fa973ec4096b5c4f1e20f1257ca805f9">02334</a> <a class="code" href="structPartitioner_1_1FindPostFunctionInsns.html#fa973ec4096b5c4f1e20f1257ca805f9">Partitioner::FindPostFunctionInsns::operator()</a>(<span class="keywordtype">bool</span> enabled, <span class="keyword">const</span> Args &amp;args)
<a name="l02335"></a>02335 {
<a name="l02336"></a>02336     <span class="keywordflow">if</span> (!enabled)
<a name="l02337"></a>02337         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02338"></a>02338     <span class="keywordflow">if</span> (!args.insn_prev || args.insn_begin-&gt;get_address()!=args.insn_prev-&gt;get_address()+args.insn_prev-&gt;get_size())
<a name="l02339"></a>02339         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02340"></a>02340     <a class="code" href="classPartitioner.html">Partitioner</a> *p = args.partitioner;
<a name="l02341"></a>02341     <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = p-&gt;<a class="code" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">find_bb_containing</a>(args.insn_prev-&gt;get_address());
<a name="l02342"></a>02342     <span class="keywordflow">if</span> (!bb || !bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>)
<a name="l02343"></a>02343         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02344"></a>02344     <a class="code" href="classPartitioner_1_1Function.html">Function</a> *func = bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>;
<a name="l02345"></a>02345     <span class="keywordflow">if</span> (0!=(func-&gt;<a class="code" href="classPartitioner_1_1Function.html#84232118f03482d3eb09c76063ef73ef">reason</a> &amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cdac33191eb0a658ed5382f9076595a28">SgAsmFunction::FUNC_PADDING</a>) ||
<a name="l02346"></a>02346         0!=(func-&gt;<a class="code" href="classPartitioner_1_1Function.html#84232118f03482d3eb09c76063ef73ef">reason</a> &amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c331ffe7c063699b34757276068c08d79">SgAsmFunction::FUNC_THUNK</a>))
<a name="l02347"></a>02347         <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// don't append instructions to certain "functions"</span>
<a name="l02348"></a>02348 
<a name="l02349"></a>02349     size_t nadded = 0;
<a name="l02350"></a>02350     <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va = args.insn_begin-&gt;get_address();
<a name="l02351"></a>02351     <span class="keywordflow">for</span> (size_t i=0; i&lt;args.ninsns; i++) {
<a name="l02352"></a>02352         bb = p-&gt;<a class="code" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">find_bb_containing</a>(va);
<a name="l02353"></a>02353         assert(bb!=NULL); <span class="comment">// because we know va is an instruction</span>
<a name="l02354"></a>02354         <span class="keywordflow">if</span> (!bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>) {
<a name="l02355"></a>02355             <span class="keywordflow">if</span> (p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) {
<a name="l02356"></a>02356                 <span class="keywordflow">if</span> (0==nadded)
<a name="l02357"></a>02357                     fprintf(p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">"Partitioner::PostFunctionBlocks: for F%08"</span>PRIx64<span class="stringliteral">": added"</span>, func-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>);
<a name="l02358"></a>02358                 fprintf(p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">" B%08"</span>PRIx64<span class="stringliteral">"#%zu"</span>, bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#7e120c89ba03d66a308381c0b82173c9">address</a>(), bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.size());
<a name="l02359"></a>02359             }
<a name="l02360"></a>02360             p-&gt;<a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">append</a>(func, bb, <a class="code" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48c75de8219893819926c67e11e1c4db317">SgAsmBlock::BLK_POSTFUNC</a>, <span class="keyword">true</span><span class="comment">/*head of CFG subgraph*/</span>);
<a name="l02361"></a>02361             func-&gt;<a class="code" href="classPartitioner_1_1Function.html#d433af52820775a021eeae99f8e31ff2">pending</a> = <span class="keyword">true</span>;
<a name="l02362"></a>02362             ++nadded;
<a name="l02363"></a>02363             ++<a class="code" href="structPartitioner_1_1FindPostFunctionInsns.html#c32280f2603e5d95de59a540b2c46d9a">nfound</a>;
<a name="l02364"></a>02364         }
<a name="l02365"></a>02365 
<a name="l02366"></a>02366         <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a> *insn = p-&gt;<a class="code" href="classPartitioner.html#1dcdd3e0993256cd5ed93fd4d178679f">find_instruction</a>(va);
<a name="l02367"></a>02367         assert(insn!=NULL);
<a name="l02368"></a>02368         va += insn-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#46940b414c39f0fd10186868d40715f7">get_size</a>();
<a name="l02369"></a>02369     }
<a name="l02370"></a>02370     <span class="keywordflow">if</span> (p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a> &amp;&amp; nadded)
<a name="l02371"></a>02371         fprintf(p-&gt;<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">"\n"</span>);
<a name="l02372"></a>02372 
<a name="l02373"></a>02373     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02374"></a>02374 }
<a name="l02375"></a>02375 
<a name="l02376"></a>02376 <span class="comment">/* class method */</span>
<a name="l02377"></a>02377 <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>
<a name="l02378"></a><a class="code" href="classPartitioner.html#36e3aa4734377dacea3614c7dd5fd5e6">02378</a> <a class="code" href="classPartitioner.html#36e3aa4734377dacea3614c7dd5fd5e6">Partitioner::value_of</a>(<a class="code" href="classSgAsmValueExpression.html">SgAsmValueExpression</a> *e)
<a name="l02379"></a>02379 {
<a name="l02380"></a>02380     <span class="keywordflow">if</span> (!e) {
<a name="l02381"></a>02381         <span class="keywordflow">return</span> 0;
<a name="l02382"></a>02382     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#69220e527d62b6b2df9e5a6321ac0f7d">isSgAsmByteValueExpression</a>(e)) {
<a name="l02383"></a>02383         <span class="keywordflow">return</span> <a class="code" href="Cxx__Grammar_8h.html#69220e527d62b6b2df9e5a6321ac0f7d">isSgAsmByteValueExpression</a>(e)-&gt;<a class="code" href="classSgAsmByteValueExpression.html#8e415b17e97de40bc5e3b790d5805b58">get_value</a>();
<a name="l02384"></a>02384     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#26f8959436fc609bf33bb645b4e41bed">isSgAsmWordValueExpression</a>(e)) {
<a name="l02385"></a>02385         <span class="keywordflow">return</span> <a class="code" href="Cxx__Grammar_8h.html#26f8959436fc609bf33bb645b4e41bed">isSgAsmWordValueExpression</a>(e)-&gt;<a class="code" href="classSgAsmWordValueExpression.html#ec7880171b93b65b8b4fd9b39846d17b">get_value</a>();
<a name="l02386"></a>02386     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#da4951b2a5743765b3427d5ea4057e48">isSgAsmDoubleWordValueExpression</a>(e)) {
<a name="l02387"></a>02387         <span class="keywordflow">return</span> <a class="code" href="Cxx__Grammar_8h.html#da4951b2a5743765b3427d5ea4057e48">isSgAsmDoubleWordValueExpression</a>(e)-&gt;<a class="code" href="classSgAsmDoubleWordValueExpression.html#0776831c616546c0a277f1b5ce2782f7">get_value</a>();
<a name="l02388"></a>02388     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#86d1906725133b85b9114c14572db22b">isSgAsmQuadWordValueExpression</a>(e)) {
<a name="l02389"></a>02389         <span class="keywordflow">return</span> <a class="code" href="Cxx__Grammar_8h.html#86d1906725133b85b9114c14572db22b">isSgAsmQuadWordValueExpression</a>(e)-&gt;<a class="code" href="classSgAsmQuadWordValueExpression.html#51cd0cde04f955e1c111da2fb4fa1c84">get_value</a>();
<a name="l02390"></a>02390     } <span class="keywordflow">else</span> {
<a name="l02391"></a>02391         <span class="keywordflow">return</span> 0;
<a name="l02392"></a>02392     }
<a name="l02393"></a>02393 }
<a name="l02394"></a>02394 
<a name="l02395"></a>02395 <span class="comment">/* class method */</span>
<a name="l02396"></a>02396 <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>
<a name="l02397"></a><a class="code" href="classPartitioner.html#a4ec978230e19cc6bd34d60be7801452">02397</a> <a class="code" href="classPartitioner.html#a4ec978230e19cc6bd34d60be7801452">Partitioner::get_indirection_addr</a>(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *g_insn)
<a name="l02398"></a>02398 {
<a name="l02399"></a>02399     <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> retval = 0;
<a name="l02400"></a>02400 
<a name="l02401"></a>02401     <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(g_insn);
<a name="l02402"></a>02402     <span class="keywordflow">if</span> (!insn ||
<a name="l02403"></a>02403         !x86InstructionIsUnconditionalBranch(insn) ||
<a name="l02404"></a>02404         1!=insn-&gt;<a class="code" href="classSgAsmInstruction.html#264e86d032b0a589d9dc520e79d09eb8">get_operandList</a>()-&gt;<a class="code" href="classSgAsmOperandList.html#bb5638c0533863030ad7acee019f1f17">get_operands</a>().size())
<a name="l02405"></a>02405         <span class="keywordflow">return</span> retval;
<a name="l02406"></a>02406 
<a name="l02407"></a>02407     <a class="code" href="classSgAsmMemoryReferenceExpression.html">SgAsmMemoryReferenceExpression</a> *mref = <a class="code" href="Cxx__Grammar_8h.html#de53c81adf2fb05def17e8e660ff4e18">isSgAsmMemoryReferenceExpression</a>(insn-&gt;<a class="code" href="classSgAsmInstruction.html#264e86d032b0a589d9dc520e79d09eb8">get_operandList</a>()-&gt;<a class="code" href="classSgAsmOperandList.html#bb5638c0533863030ad7acee019f1f17">get_operands</a>()[0]);
<a name="l02408"></a>02408     <span class="keywordflow">if</span> (!mref)
<a name="l02409"></a>02409         <span class="keywordflow">return</span> retval;
<a name="l02410"></a>02410 
<a name="l02411"></a>02411     <a class="code" href="classSgAsmExpression.html">SgAsmExpression</a> *mref_addr = mref-&gt;<a class="code" href="classSgAsmMemoryReferenceExpression.html#b5e0f8d74e3aa16aeef0ac063d6a112c">get_address</a>();
<a name="l02412"></a>02412     <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#b168edf9057af44e40677187242cfca5">isSgAsmBinaryExpression</a>(mref_addr)) {
<a name="l02413"></a>02413         <a class="code" href="classSgAsmBinaryExpression.html">SgAsmBinaryExpression</a> *mref_bin = <a class="code" href="Cxx__Grammar_8h.html#b168edf9057af44e40677187242cfca5">isSgAsmBinaryExpression</a>(mref_addr);
<a name="l02414"></a>02414         <a class="code" href="classSgAsmx86RegisterReferenceExpression.html">SgAsmx86RegisterReferenceExpression</a> *reg = <a class="code" href="Cxx__Grammar_8h.html#5e5ead71a8653e1d062d92582359e574">isSgAsmx86RegisterReferenceExpression</a>(mref_bin-&gt;<a class="code" href="classSgAsmBinaryExpression.html#14af858f7b9e4bd5de65982c9080688f">get_lhs</a>());
<a name="l02415"></a>02415         <a class="code" href="classSgAsmValueExpression.html">SgAsmValueExpression</a> *val = <a class="code" href="Cxx__Grammar_8h.html#4f477d8260444d2a9e08132c691d25a8">isSgAsmValueExpression</a>(mref_bin-&gt;<a class="code" href="classSgAsmBinaryExpression.html#39bf53f0b93068e84075ce17526e845b">get_rhs</a>());
<a name="l02416"></a>02416         <span class="keywordflow">if</span> (reg-&gt;<a class="code" href="classSgAsmRegisterReferenceExpression.html#e4a2ae3037e897d983674a61bbf16ec0">get_descriptor</a>().<a class="code" href="structRegisterDescriptor.html#00a1b8b124f547095b6409606276a65c">get_major</a>()==<a class="code" href="InstructionEnumsX86_8h.html#12229bfc0029dbc592944d1d6514e30f7d690d572a18c19f87bfb2cb0d2b490c">x86_regclass_ip</a> &amp;&amp; val!=NULL) {
<a name="l02417"></a>02417             retval = <a class="code" href="classPartitioner.html#36e3aa4734377dacea3614c7dd5fd5e6">value_of</a>(val) + insn-&gt;<a class="code" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>() + insn-&gt;<a class="code" href="classSgAsmInstruction.html#6adcc4eb7c725185baa3a2425a57843c">get_size</a>();
<a name="l02418"></a>02418         }
<a name="l02419"></a>02419     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#4f477d8260444d2a9e08132c691d25a8">isSgAsmValueExpression</a>(mref_addr)) {
<a name="l02420"></a>02420         retval = <a class="code" href="classPartitioner.html#36e3aa4734377dacea3614c7dd5fd5e6">value_of</a>(<a class="code" href="Cxx__Grammar_8h.html#4f477d8260444d2a9e08132c691d25a8">isSgAsmValueExpression</a>(mref_addr));
<a name="l02421"></a>02421     }
<a name="l02422"></a>02422 
<a name="l02423"></a>02423     <span class="keywordflow">return</span> retval; <span class="comment">/*calculated value, or defaults to zero*/</span>
<a name="l02424"></a>02424 }
<a name="l02425"></a>02425 
<a name="l02430"></a>02430 <span class="keywordtype">void</span>
<a name="l02431"></a><a class="code" href="classPartitioner.html#17cac3fb6a8a12bf633c70e4640728ff">02431</a> <a class="code" href="classPartitioner.html#17cac3fb6a8a12bf633c70e4640728ff">Partitioner::name_plt_entries</a>(<a class="code" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *fhdr)
<a name="l02432"></a>02432 {
<a name="l02433"></a>02433     <span class="comment">/* This function is ELF, x86 specific. [FIXME RPM 2009-02-06] */</span>
<a name="l02434"></a>02434     <a class="code" href="classSgAsmElfFileHeader.html">SgAsmElfFileHeader</a> *elf = <a class="code" href="Cxx__Grammar_8h.html#634969907f40ab0a68fa945423fc355a">isSgAsmElfFileHeader</a>(fhdr);
<a name="l02435"></a>02435     <span class="keywordflow">if</span> (!elf) <span class="keywordflow">return</span>;
<a name="l02436"></a>02436 
<a name="l02437"></a>02437     <span class="comment">/* Find important sections */</span>
<a name="l02438"></a>02438     <a class="code" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *plt = elf-&gt;<a class="code" href="classSgAsmGenericHeader.html#374afd170f81cad885729210130cb45b">get_section_by_name</a>(<span class="stringliteral">".plt"</span>);
<a name="l02439"></a>02439     <span class="keywordflow">if</span> (!plt || !plt-&gt;<a class="code" href="classSgAsmGenericSection.html#104f95720dd8a1b1cc458c8c651943cb">is_mapped</a>()) <span class="keywordflow">return</span>;
<a name="l02440"></a>02440     <a class="code" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *gotplt = elf-&gt;<a class="code" href="classSgAsmGenericHeader.html#374afd170f81cad885729210130cb45b">get_section_by_name</a>(<span class="stringliteral">".got.plt"</span>);
<a name="l02441"></a>02441     <span class="keywordflow">if</span> (!gotplt || !gotplt-&gt;<a class="code" href="classSgAsmGenericSection.html#104f95720dd8a1b1cc458c8c651943cb">is_mapped</a>()) <span class="keywordflow">return</span>;
<a name="l02442"></a>02442 
<a name="l02443"></a>02443     <span class="comment">/* Find all relocation sections */</span>
<a name="l02444"></a>02444     std::set&lt;SgAsmElfRelocSection*&gt; rsects;
<a name="l02445"></a>02445     <span class="keywordflow">for</span> (SgAsmGenericSectionPtrList::iterator si=elf-&gt;<a class="code" href="classSgAsmGenericHeader.html#5cefae0c9db1832cd75642799bc33762">get_sections</a>()-&gt;<a class="code" href="classSgAsmGenericSectionList.html#239d407e4df928777b992e8fdfc6e685">get_sections</a>().begin();
<a name="l02446"></a>02446          si!=elf-&gt;<a class="code" href="classSgAsmGenericHeader.html#5cefae0c9db1832cd75642799bc33762">get_sections</a>()-&gt;<a class="code" href="classSgAsmGenericSectionList.html#239d407e4df928777b992e8fdfc6e685">get_sections</a>().end();
<a name="l02447"></a>02447          si++) {
<a name="l02448"></a>02448         <a class="code" href="classSgAsmElfRelocSection.html">SgAsmElfRelocSection</a> *reloc_section = <a class="code" href="Cxx__Grammar_8h.html#659c355083a0fd75c56da2364ae4f08b">isSgAsmElfRelocSection</a>(*si);
<a name="l02449"></a>02449         <span class="keywordflow">if</span> (reloc_section)
<a name="l02450"></a>02450             rsects.insert(reloc_section);
<a name="l02451"></a>02451     }
<a name="l02452"></a>02452     <span class="keywordflow">if</span> (rsects.empty()) <span class="keywordflow">return</span>;
<a name="l02453"></a>02453 
<a name="l02454"></a>02454     <span class="comment">/* Process each .plt trampoline */</span>
<a name="l02455"></a>02455     <span class="keywordflow">for</span> (Functions::iterator fi=<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.begin(); fi!=<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.end(); fi++) {
<a name="l02456"></a>02456         <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> func_addr = fi-&gt;first;
<a name="l02457"></a>02457 
<a name="l02458"></a>02458         if (fi-&gt;second-&gt;name!=<span class="stringliteral">""</span>)
<a name="l02459"></a>02459             <span class="keywordflow">continue</span>; <span class="comment">/* function already has a name */</span>
<a name="l02460"></a>02460 
<a name="l02461"></a>02461         <span class="keywordflow">if</span> (func_addr &lt;  elf-&gt;get_base_va() + plt-&gt;<a class="code" href="classSgAsmGenericSection.html#5196f7cd5b28560a8b959b1e3228c079">get_mapped_preferred_rva</a>() ||
<a name="l02462"></a>02462             func_addr &gt;= elf-&gt;<a class="code" href="classSgAsmGenericHeader.html#fb6c62c0fdc956105bfae2263617446e">get_base_va</a>() + plt-&gt;<a class="code" href="classSgAsmGenericSection.html#5196f7cd5b28560a8b959b1e3228c079">get_mapped_preferred_rva</a>() + plt-&gt;<a class="code" href="classSgAsmGenericSection.html#8d1fa091242ab088e3cbe50d87fc25ba">get_mapped_size</a>())
<a name="l02463"></a>02463             <span class="keywordflow">continue</span>; <span class="comment">/* function is not in the .plt section */</span>
<a name="l02464"></a>02464 
<a name="l02465"></a>02465         <span class="comment">/* Sometimes the first instruction of a basic block cannot be disassembled and the basic block will have a different</span>
<a name="l02466"></a>02466 <span class="comment">         * starting address than its first instruction.  If that basic block is also the start of a function then the</span>
<a name="l02467"></a>02467 <span class="comment">         * function also will have no initial instruction. */</span>
<a name="l02468"></a>02468         <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a> *insn = <a class="code" href="classPartitioner.html#1dcdd3e0993256cd5ed93fd4d178679f">find_instruction</a>(func_addr);
<a name="l02469"></a>02469         <span class="keywordflow">if</span> (NULL==insn)
<a name="l02470"></a>02470             <span class="keywordflow">continue</span>;
<a name="l02471"></a>02471 
<a name="l02472"></a>02472         <span class="comment">/* The target in the ".plt" section will be an indirect (through the .got.plt section) jump to the actual dynamically</span>
<a name="l02473"></a>02473 <span class="comment">         * linked function (or to the dynamic linker itself). The .got.plt address is what we're really interested in. */</span>
<a name="l02474"></a>02474         <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn_x86 = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(insn);
<a name="l02475"></a>02475         assert(insn_x86!=NULL);
<a name="l02476"></a>02476         <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> gotplt_va = <a class="code" href="classPartitioner.html#a4ec978230e19cc6bd34d60be7801452">get_indirection_addr</a>(insn_x86);
<a name="l02477"></a>02477 
<a name="l02478"></a>02478         <span class="keywordflow">if</span> (gotplt_va &lt;  elf-&gt;get_base_va() + gotplt-&gt;<a class="code" href="classSgAsmGenericSection.html#5196f7cd5b28560a8b959b1e3228c079">get_mapped_preferred_rva</a>() ||
<a name="l02479"></a>02479             gotplt_va &gt;= elf-&gt;<a class="code" href="classSgAsmGenericHeader.html#fb6c62c0fdc956105bfae2263617446e">get_base_va</a>() + gotplt-&gt;<a class="code" href="classSgAsmGenericSection.html#5196f7cd5b28560a8b959b1e3228c079">get_mapped_preferred_rva</a>() + gotplt-&gt;<a class="code" href="classSgAsmGenericSection.html#8d1fa091242ab088e3cbe50d87fc25ba">get_mapped_size</a>())
<a name="l02480"></a>02480             <span class="keywordflow">continue</span>; <span class="comment">/* PLT entry doesn't dereference a value in the .got.plt section */</span>
<a name="l02481"></a>02481 
<a name="l02482"></a>02482         <span class="comment">/* Find the relocation entry whose offset is the gotplt_rva and use that entry's symbol for the function name. */</span>
<a name="l02483"></a>02483         <span class="keywordflow">for</span> (std::set&lt;SgAsmElfRelocSection*&gt;::iterator ri=rsects.begin(); ri!=rsects.end() &amp;&amp; fi-&gt;second-&gt;name==<span class="stringliteral">""</span>; ri++) {
<a name="l02484"></a>02484             <a class="code" href="classSgAsmElfRelocEntryList.html">SgAsmElfRelocEntryList</a> *entries = (*ri)-&gt;get_entries();
<a name="l02485"></a>02485             <a class="code" href="classSgAsmElfSymbolSection.html">SgAsmElfSymbolSection</a> *symbol_section = <a class="code" href="Cxx__Grammar_8h.html#faaae5166c764907865b84e4aca5f2be">isSgAsmElfSymbolSection</a>((*ri)-&gt;get_linked_section());
<a name="l02486"></a>02486             <span class="keywordflow">if</span> (symbol_section) {
<a name="l02487"></a>02487                 <a class="code" href="classSgAsmElfSymbolList.html">SgAsmElfSymbolList</a> *symbols = symbol_section-&gt;<a class="code" href="classSgAsmElfSymbolSection.html#68c30567293ca0163f091dd2c8c19e8c">get_symbols</a>();
<a name="l02488"></a>02488                 <span class="keywordflow">for</span> (size_t ei=0; ei&lt;entries-&gt;get_entries().size() &amp;&amp; fi-&gt;second-&gt;name==<span class="stringliteral">""</span>; ei++) {
<a name="l02489"></a>02489                     <a class="code" href="classSgAsmElfRelocEntry.html">SgAsmElfRelocEntry</a> *rel = entries-&gt;get_entries()[ei];
<a name="l02490"></a>02490                     <span class="keywordflow">if</span> (rel-&gt;get_r_offset()==gotplt_va) {
<a name="l02491"></a>02491                         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> symbol_idx = rel-&gt;get_sym();
<a name="l02492"></a>02492                         assert(symbol_idx &lt; symbols-&gt;get_symbols().size());
<a name="l02493"></a>02493                         <a class="code" href="classSgAsmElfSymbol.html">SgAsmElfSymbol</a> *symbol = symbols-&gt;<a class="code" href="classSgAsmElfSymbolList.html#f0bad6ae664035299ed6102dce7cd4e3">get_symbols</a>()[symbol_idx];
<a name="l02494"></a>02494                         fi-&gt;second-&gt;name = symbol-&gt;<a class="code" href="classSgAsmGenericSymbol.html#8cef0d96af06bb5e741df6a332c67e2c">get_name</a>()-&gt;<a class="code" href="classSgAsmGenericString.html#ba8bc51c8d891e4f8e8e87c45c62f7d5">get_string</a>() + <span class="stringliteral">"@plt"</span>;
<a name="l02495"></a>02495                     }
<a name="l02496"></a>02496                 }
<a name="l02497"></a>02497             }
<a name="l02498"></a>02498         }
<a name="l02499"></a>02499     }
<a name="l02500"></a>02500 }
<a name="l02501"></a>02501 
<a name="l02509"></a>02509 <span class="keywordtype">void</span>
<a name="l02510"></a><a class="code" href="classPartitioner.html#dc7b9b7851ee14847eed8454619cb505">02510</a> <a class="code" href="classPartitioner.html#dc7b9b7851ee14847eed8454619cb505">Partitioner::name_import_entries</a>(<a class="code" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *fhdr)
<a name="l02511"></a>02511 {
<a name="l02512"></a>02512     <span class="comment">/* This function is PE x86 specific */</span>
<a name="l02513"></a>02513     <a class="code" href="classSgAsmPEFileHeader.html">SgAsmPEFileHeader</a> *pe = <a class="code" href="Cxx__Grammar_8h.html#f17b1e963bc0432adc451e9785358e37">isSgAsmPEFileHeader</a>(fhdr);
<a name="l02514"></a>02514     <span class="keywordflow">if</span> (!pe)
<a name="l02515"></a>02515         <span class="keywordflow">return</span>;
<a name="l02516"></a>02516 
<a name="l02517"></a>02517     <span class="comment">/* Build an index mapping memory addresses to function names.  The addresses are the virtual address through which an</span>
<a name="l02518"></a>02518 <span class="comment">     * indirect jump would go when calling an imported function. */</span>
<a name="l02519"></a>02519     <span class="keyword">struct </span>ImportIndexBuilder: <span class="keyword">public</span> <a class="code" href="classAstSimpleProcessing.html">AstSimpleProcessing</a> {
<a name="l02520"></a>02520         <span class="keyword">typedef</span> std::map&lt;rose_addr_t, std::string&gt; Index;
<a name="l02521"></a>02521         <span class="keyword">typedef</span> Index::iterator iterator;
<a name="l02522"></a>02522         <a class="code" href="classPartitioner.html">Partitioner</a> *partitioner;
<a name="l02523"></a>02523         Index index;
<a name="l02524"></a>02524         <a class="code" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *fhdr;
<a name="l02525"></a>02525         ImportIndexBuilder(<a class="code" href="classPartitioner.html">Partitioner</a> *partitioner, <a class="code" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *fhdr): partitioner(partitioner), fhdr(fhdr) {
<a name="l02526"></a>02526             traverse(fhdr, <a class="code" href="Cxx__Grammar_8h.html#59f7fee88581c4dd75f5fb25dbefa29edefb5d09673c144dc5b4dc177e278696">preorder</a>);
<a name="l02527"></a>02527         }
<a name="l02528"></a>02528         <span class="keywordtype">void</span> visit(<a class="code" href="classSgNode.html">SgNode</a> *node) {
<a name="l02529"></a>02529             <a class="code" href="classSgAsmPEImportItem.html">SgAsmPEImportItem</a> *<span class="keyword">import</span> = <a class="code" href="Cxx__Grammar_8h.html#e223cffb51a81e8cd4506c2dffc3382f">isSgAsmPEImportItem</a>(node);
<a name="l02530"></a>02530             <span class="keywordflow">if</span> (<span class="keyword">import</span>) {
<a name="l02531"></a>02531                 std::string name = <span class="keyword">import</span>-&gt;get_name()-&gt;get_string();
<a name="l02532"></a>02532                 <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va = <span class="keyword">import</span>-&gt;get_bound_rva().get_va();
<a name="l02533"></a>02533                 <span class="keywordflow">if</span> (va!=0 &amp;&amp; !name.empty())
<a name="l02534"></a>02534                     index[va] = name;
<a name="l02535"></a>02535             }
<a name="l02536"></a>02536         }
<a name="l02537"></a>02537     } imports(<span class="keyword">this</span>, fhdr);
<a name="l02538"></a>02538 
<a name="l02539"></a>02539     <span class="comment">/* Look for functions whose first instruction is an indirect jump through one of the memory addresses we indexed above. */</span>
<a name="l02540"></a>02540     <span class="keywordflow">for</span> (Functions::iterator fi=<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.begin(); fi!=<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.end(); ++fi) {
<a name="l02541"></a>02541         <a class="code" href="classPartitioner_1_1Function.html">Function</a> *func = fi-&gt;second;
<a name="l02542"></a>02542         if (!func-&gt;name.empty())
<a name="l02543"></a>02543             <span class="keywordflow">continue</span>;
<a name="l02544"></a>02544         <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a> *insn = <a class="code" href="classPartitioner.html#1dcdd3e0993256cd5ed93fd4d178679f">find_instruction</a>(func-&gt;entry_va);
<a name="l02545"></a>02545         <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn_x86 = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(insn);
<a name="l02546"></a>02546         <span class="keywordflow">if</span> (!insn_x86 ||
<a name="l02547"></a>02547             (insn_x86-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()!=<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571ad03bc3cf5ca0f4918d34b66a2ae0b24">x86_jmp</a> &amp;&amp; insn_x86-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()!=<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca557198fb4c6bacf21d45da2c1eb7380caccc">x86_farjmp</a>) ||
<a name="l02548"></a>02548             1!=insn_x86-&gt;<a class="code" href="classSgAsmInstruction.html#264e86d032b0a589d9dc520e79d09eb8">get_operandList</a>()-&gt;<a class="code" href="classSgAsmOperandList.html#bb5638c0533863030ad7acee019f1f17">get_operands</a>().size())
<a name="l02549"></a>02549             <span class="keywordflow">continue</span>;
<a name="l02550"></a>02550         <a class="code" href="classSgAsmMemoryReferenceExpression.html">SgAsmMemoryReferenceExpression</a> *mre = <a class="code" href="Cxx__Grammar_8h.html#de53c81adf2fb05def17e8e660ff4e18">isSgAsmMemoryReferenceExpression</a>(insn_x86-&gt;<a class="code" href="classSgAsmInstruction.html#264e86d032b0a589d9dc520e79d09eb8">get_operandList</a>()-&gt;<a class="code" href="classSgAsmOperandList.html#bb5638c0533863030ad7acee019f1f17">get_operands</a>()[0]);
<a name="l02551"></a>02551         <span class="keywordflow">if</span> (!mre)
<a name="l02552"></a>02552             <span class="keywordflow">continue</span>;
<a name="l02553"></a>02553         <a class="code" href="classSgAsmValueExpression.html">SgAsmValueExpression</a> *base = <a class="code" href="Cxx__Grammar_8h.html#4f477d8260444d2a9e08132c691d25a8">isSgAsmValueExpression</a>(mre-&gt;<a class="code" href="classSgAsmMemoryReferenceExpression.html#b5e0f8d74e3aa16aeef0ac063d6a112c">get_address</a>());
<a name="l02554"></a>02554         <span class="keywordflow">if</span> (!base)
<a name="l02555"></a>02555             <span class="keywordflow">continue</span>;
<a name="l02556"></a>02556         <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> base_va = <a class="code" href="classPartitioner.html#36e3aa4734377dacea3614c7dd5fd5e6">value_of</a>(base);
<a name="l02557"></a>02557 
<a name="l02558"></a>02558         ImportIndexBuilder::iterator found = imports.index.find(base_va);
<a name="l02559"></a>02559         <span class="keywordflow">if</span> (found==imports.index.end())
<a name="l02560"></a>02560             <span class="keywordflow">continue</span>;
<a name="l02561"></a>02561         func-&gt;name = found-&gt;second + <span class="stringliteral">"@import"</span>;
<a name="l02562"></a>02562         <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>)
<a name="l02563"></a>02563             fprintf(<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">"Partitioner::name_import_entries: F%08"</span>PRIx64<span class="stringliteral">": named \"%s\"\n"</span>, func-&gt;entry_va, func-&gt;name.c_str());
<a name="l02564"></a>02564     }
<a name="l02565"></a>02565 }
<a name="l02566"></a>02566 
<a name="l02567"></a>02567 <span class="comment">/* Seed function starts based on criteria other than control flow graph. */</span>
<a name="l02568"></a>02568 <span class="keywordtype">void</span>
<a name="l02569"></a><a class="code" href="classPartitioner.html#815304b7ef093a74bc419662d54df49b">02569</a> <a class="code" href="classPartitioner.html#815304b7ef093a74bc419662d54df49b">Partitioner::pre_cfg</a>(<a class="code" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *interp<span class="comment">/*=NULL*/</span>)
<a name="l02570"></a>02570 {
<a name="l02571"></a>02571     <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) {
<a name="l02572"></a>02572         fprintf(<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">"Function reasons referenced by Partitioner debugging output:\n%s"</span>,
<a name="l02573"></a>02573                 <a class="code" href="classSgAsmFunction.html#0e676a720e09614a8adf9e02ec282216">SgAsmFunction::reason_key</a>(<span class="stringliteral">"  "</span>).c_str());
<a name="l02574"></a>02574     }
<a name="l02575"></a>02575 
<a name="l02576"></a>02576     <a class="code" href="classPartitioner.html#fd2b60293bc45d47e74befebde631533">mark_ipd_configuration</a>();   <span class="comment">/*seed partitioner based on IPD configuration information*/</span>
<a name="l02577"></a>02577 
<a name="l02578"></a>02578     <span class="keywordflow">if</span> (interp) {
<a name="l02579"></a>02579         <span class="keyword">const</span> <a class="code" href="Cxx__Grammar_8h.html#2b92a9464e206badb3c042fe0456d37e">SgAsmGenericHeaderPtrList</a> &amp;headers = interp-&gt;<a class="code" href="classSgAsmInterpretation.html#5d116938aaa9da9f3e27ca598965c77b">get_headers</a>()-&gt;<a class="code" href="classSgAsmGenericHeaderList.html#c3d9878c64af6c90e2d52988f8578b36">get_headers</a>();
<a name="l02580"></a>02580         <span class="keywordflow">for</span> (size_t i=0; i&lt;headers.size(); i++) {
<a name="l02581"></a>02581             <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#61a820e23e3d57c012d0928aa9c4d1a2">func_heuristics</a> &amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c2c1716e490136fddc09c145d8809ed64">SgAsmFunction::FUNC_ENTRY_POINT</a>)
<a name="l02582"></a>02582                 <a class="code" href="classPartitioner.html#1f7de70089099ce3d31af5ed455fc9b7">mark_entry_targets</a>(headers[i]);
<a name="l02583"></a>02583             <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#61a820e23e3d57c012d0928aa9c4d1a2">func_heuristics</a> &amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cd7e1055f3974be70f4e4d88e758ed666">SgAsmFunction::FUNC_EH_FRAME</a>)
<a name="l02584"></a>02584                 <a class="code" href="classPartitioner.html#167cda7ee682478117f8480d86815efc">mark_eh_frames</a>(headers[i]);
<a name="l02585"></a>02585             <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#61a820e23e3d57c012d0928aa9c4d1a2">func_heuristics</a> &amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c10eee68a3ad870f7e48faef2639a853a">SgAsmFunction::FUNC_SYMBOL</a>)
<a name="l02586"></a>02586                 <a class="code" href="classPartitioner.html#5856443d8da3aeb540e193491619dab8">mark_func_symbols</a>(headers[i]);
<a name="l02587"></a>02587             <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#61a820e23e3d57c012d0928aa9c4d1a2">func_heuristics</a> &amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c40c0ce88c447524963f4e8d7ef193cc7">SgAsmFunction::FUNC_IMPORT</a>)
<a name="l02588"></a>02588                 <a class="code" href="classPartitioner.html#20bab02d75f2c49035e63dc029635698">mark_elf_plt_entries</a>(headers[i]);
<a name="l02589"></a>02589         }
<a name="l02590"></a>02590     }
<a name="l02591"></a>02591     <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#61a820e23e3d57c012d0928aa9c4d1a2">func_heuristics</a> &amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cd01f7a2ed6ff7e8a3e6c4550d0ccaa63">SgAsmFunction::FUNC_PATTERN</a>)
<a name="l02592"></a>02592         <a class="code" href="classPartitioner.html#608c32001c0e56d18e41ce2d77976f9d">mark_func_patterns</a>();
<a name="l02593"></a>02593     <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#61a820e23e3d57c012d0928aa9c4d1a2">func_heuristics</a> &amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cbb9273d4d879614c52016694798c3143">SgAsmFunction::FUNC_CALL_INSN</a>)
<a name="l02594"></a>02594         <a class="code" href="classPartitioner.html#e9e536212c2e5efdf21ad22993d5c888">mark_call_insns</a>();
<a name="l02595"></a>02595 
<a name="l02596"></a>02596     <span class="comment">/* Run user-defined function detectors, making sure that the basic block starts are up-to-date for each call. */</span>
<a name="l02597"></a>02597     <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#61a820e23e3d57c012d0928aa9c4d1a2">func_heuristics</a> &amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c5f338fbf75bfacef4196e65ba5441767">SgAsmFunction::FUNC_USERDEF</a>) {
<a name="l02598"></a>02598         <span class="keywordflow">if</span> (interp) {
<a name="l02599"></a>02599             <span class="keyword">const</span> <a class="code" href="Cxx__Grammar_8h.html#2b92a9464e206badb3c042fe0456d37e">SgAsmGenericHeaderPtrList</a> &amp;headers = interp-&gt;get_headers()-&gt;get_headers();
<a name="l02600"></a>02600             <span class="keywordflow">for</span> (size_t i=0; i&lt;<a class="code" href="classPartitioner.html#e8ccefb002c5a4bea6abc98c226d19d6">user_detectors</a>.size(); i++) {
<a name="l02601"></a>02601                 <span class="keywordflow">for</span> (size_t j=0; j&lt;=headers.size(); j++) {
<a name="l02602"></a>02602                     <a class="code" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *hdr = 0==j ? NULL : headers[j-1];
<a name="l02603"></a>02603                     <a class="code" href="classPartitioner.html#e8ccefb002c5a4bea6abc98c226d19d6">user_detectors</a>[i](<span class="keyword">this</span>, hdr);
<a name="l02604"></a>02604                 }
<a name="l02605"></a>02605             }
<a name="l02606"></a>02606         } <span class="keywordflow">else</span> {
<a name="l02607"></a>02607             <span class="keywordflow">for</span> (size_t i=0; i&lt;<a class="code" href="classPartitioner.html#e8ccefb002c5a4bea6abc98c226d19d6">user_detectors</a>.size(); i++) {
<a name="l02608"></a>02608                 <a class="code" href="classPartitioner.html#e8ccefb002c5a4bea6abc98c226d19d6">user_detectors</a>[i](<span class="keyword">this</span>, NULL);
<a name="l02609"></a>02609             }
<a name="l02610"></a>02610         }
<a name="l02611"></a>02611     }
<a name="l02612"></a>02612 }
<a name="l02613"></a>02613 
<a name="l02631"></a>02631 <span class="keywordtype">void</span>
<a name="l02632"></a><a class="code" href="classPartitioner.html#810bddfe83b19037ed710bdb98a34f50">02632</a> <a class="code" href="classPartitioner.html#810bddfe83b19037ed710bdb98a34f50">Partitioner::discover_first_block</a>(<a class="code" href="classPartitioner_1_1Function.html">Function</a> *func)
<a name="l02633"></a>02633 {
<a name="l02634"></a>02634     <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) {
<a name="l02635"></a>02635         fprintf(<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">"1st block %s F%08"</span>PRIx64<span class="stringliteral">" \"%s\": B%08"</span>PRIx64<span class="stringliteral">" "</span>,
<a name="l02636"></a>02636                 <a class="code" href="classSgAsmFunction.html#86f4c5774c3b7aac2a21c7d6790a7baa">SgAsmFunction::reason_str</a>(<span class="keyword">true</span>, func-&gt;<a class="code" href="classPartitioner_1_1Function.html#84232118f03482d3eb09c76063ef73ef">reason</a>).c_str(),
<a name="l02637"></a>02637                 func-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>, func-&gt;<a class="code" href="classPartitioner_1_1Function.html#3445a927f772aa09859896fa5681eb62">name</a>.c_str(), func-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>);
<a name="l02638"></a>02638     }
<a name="l02639"></a>02639     <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = <a class="code" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">find_bb_containing</a>(func-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>);
<a name="l02640"></a>02640 
<a name="l02641"></a>02641     <span class="comment">/* If this function's entry block collides with some other function, then truncate that other function's block and</span>
<a name="l02642"></a>02642 <span class="comment">     * subsume part of it into this function. Mark the other function as pending because its block may have new</span>
<a name="l02643"></a>02643 <span class="comment">     * successors now. */</span>
<a name="l02644"></a>02644     <span class="keywordflow">if</span> (bb &amp;&amp; func-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>!=bb-&gt;address()) {
<a name="l02645"></a>02645         assert(bb-&gt;function!=func);
<a name="l02646"></a>02646         <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) fprintf(<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">"[split from B%08"</span>PRIx64, bb-&gt;address());
<a name="l02647"></a>02647         <span class="keywordflow">if</span> (bb-&gt;function) {
<a name="l02648"></a>02648             <span class="keywordflow">if</span> (debug) fprintf(debug, <span class="stringliteral">" in F%08"</span>PRIx64<span class="stringliteral">" \"%s\""</span>, bb-&gt;address(), bb-&gt;function-&gt;name.c_str());
<a name="l02649"></a>02649             bb-&gt;function-&gt;pending = <span class="keyword">true</span>;
<a name="l02650"></a>02650         }
<a name="l02651"></a>02651         <span class="keywordflow">if</span> (debug) fprintf(debug, <span class="stringliteral">"] "</span>);
<a name="l02652"></a>02652         <a class="code" href="classPartitioner.html#a1fd20a852585175fc0be71ef5bd97bd">truncate</a>(bb, func-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>);
<a name="l02653"></a>02653         bb = <a class="code" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">find_bb_containing</a>(func-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>);
<a name="l02654"></a>02654         assert(bb!=NULL);
<a name="l02655"></a>02655         assert(func-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>==bb-&gt;address());
<a name="l02656"></a>02656     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bb &amp;&amp; bb-&gt;function!=NULL &amp;&amp; bb-&gt;function!=func) {
<a name="l02657"></a>02657         <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) fprintf(debug, <span class="stringliteral">"[removing B%08"</span>PRIx64<span class="stringliteral">" from F%08"</span>PRIx64<span class="stringliteral">"]"</span>, func-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>, bb-&gt;function-&gt;entry_va);
<a name="l02658"></a>02658         bb-&gt;function-&gt;pending = <span class="keyword">true</span>;
<a name="l02659"></a>02659         <a class="code" href="classPartitioner.html#7a886afe82a7fc7171bdc64ecfd379fb">remove</a>(bb-&gt;function, bb);
<a name="l02660"></a>02660     }
<a name="l02661"></a>02661 
<a name="l02662"></a>02662     <span class="keywordflow">if</span> (bb) {
<a name="l02663"></a>02663         <a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">append</a>(func, bb, <a class="code" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48ccb1cb50df0cb421e21b3ca064d1122e0">SgAsmBlock::BLK_ENTRY_POINT</a>);
<a name="l02664"></a>02664         <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>)
<a name="l02665"></a>02665             fprintf(<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">"#%zu "</span>, bb-&gt;insns.size());
<a name="l02666"></a>02666     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) {
<a name="l02667"></a>02667         fprintf(<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">"no instruction at function entry address "</span>);
<a name="l02668"></a>02668     }
<a name="l02669"></a>02669     <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) {
<a name="l02670"></a>02670         func-&gt;<a class="code" href="classPartitioner_1_1Function.html#b18318f8abc47eddd8a95ac05fa4cddc">show_properties</a>(<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>);
<a name="l02671"></a>02671         fputc(<span class="charliteral">'\n'</span>, debug);
<a name="l02672"></a>02672     }
<a name="l02673"></a>02673 }
<a name="l02674"></a>02674 
<a name="l02679"></a>02679 <span class="keywordtype">void</span>
<a name="l02680"></a><a class="code" href="classPartitioner.html#9bc4921fd2eefd0a2eb4f8eeaa2b2f2f">02680</a> <a class="code" href="classPartitioner.html#354aa1fce4dcbc80c99038829a3ddb76">Partitioner::discover_blocks</a>(<a class="code" href="classPartitioner_1_1Function.html">Function</a> *f, <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va, <span class="keywordtype">unsigned</span> reason)
<a name="l02681"></a>02681 {
<a name="l02682"></a>02682     <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) fprintf(<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">" B%08"</span>PRIx64, va);
<a name="l02683"></a>02683     <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a> *insn = <a class="code" href="classPartitioner.html#1dcdd3e0993256cd5ed93fd4d178679f">find_instruction</a>(va);
<a name="l02684"></a>02684     <span class="keywordflow">if</span> (!insn) <span class="keywordflow">return</span>; <span class="comment">/* No instruction at this address. */</span>
<a name="l02685"></a>02685     <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> target_va = <a class="code" href="classPartitioner.html#7e4a76ae7ab4113b2ec7acf9093c3810">NO_TARGET</a>; <span class="comment">/*target of function call instructions (e.g., x86 CALL and FARCALL)*/</span>
<a name="l02686"></a>02686 
<a name="l02687"></a>02687     <span class="comment">/* This block might be the entry address of a function even before that function has any basic blocks assigned to it. This</span>
<a name="l02688"></a>02688 <span class="comment">     * can happen when a new function was discovered during the current pass. It can't happen for functions discovered in a</span>
<a name="l02689"></a>02689 <span class="comment">     * previous pass since we would have called discover_first_block() by now for any such functions. */</span>
<a name="l02690"></a>02690     Functions::iterator fi = <a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.find(va);
<a name="l02691"></a>02691     <span class="keywordflow">if</span> (fi!=<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.end() &amp;&amp; fi-&gt;second!=f) {
<a name="l02692"></a>02692         <span class="keywordflow">if</span> (debug) fprintf(debug, <span class="stringliteral">"[entry \"%s\"]"</span>, fi-&gt;second-&gt;name.c_str());
<a name="l02693"></a>02693         <span class="keywordflow">return</span>;
<a name="l02694"></a>02694     }
<a name="l02695"></a>02695 
<a name="l02696"></a>02696     <span class="comment">/* Find basic block at address, creating it if necessary. */</span>
<a name="l02697"></a>02697     <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = <a class="code" href="classPartitioner.html#67702e97dcbfb27fa18f6186fe30538a">find_bb_starting</a>(va);
<a name="l02698"></a>02698     assert(bb!=NULL);
<a name="l02699"></a>02699     <span class="keywordflow">if</span> (debug) fprintf(debug, <span class="stringliteral">"#%zu"</span>, bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.size());
<a name="l02700"></a>02700 
<a name="l02701"></a>02701     <span class="comment">/* If the current function has been somehow marked as pending then we might as well give up discovering its blocks because</span>
<a name="l02702"></a>02702 <span class="comment">     * some of its blocks' successors may have changed.  This can happen, for instance, if the create_bb() called above had to</span>
<a name="l02703"></a>02703 <span class="comment">     * split one of this function's blocks. */</span>
<a name="l02704"></a>02704     <span class="keywordflow">if</span> (f-&gt;<a class="code" href="classPartitioner_1_1Function.html#d433af52820775a021eeae99f8e31ff2">pending</a>) {
<a name="l02705"></a>02705         <span class="keywordflow">if</span> (debug) fprintf(debug, <span class="stringliteral">" abandon"</span>);
<a name="l02706"></a>02706         <span class="keywordflow">throw</span> <a class="code" href="structPartitioner_1_1AbandonFunctionDiscovery.html">AbandonFunctionDiscovery</a>();
<a name="l02707"></a>02707     }
<a name="l02708"></a>02708 
<a name="l02709"></a>02709     <span class="comment">/* Don't reprocess blocks for this function. However, we need to reprocess the first block because it was added by</span>
<a name="l02710"></a>02710 <span class="comment">     * discover_first_block(), which is not recursive.  Care should be taken so none of the recursive calls below are invoked</span>
<a name="l02711"></a>02711 <span class="comment">     * for the first block, or we'll have infinite recurision! */</span>
<a name="l02712"></a>02712     <span class="keywordflow">if</span> (bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>==f &amp;&amp; bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#7e120c89ba03d66a308381c0b82173c9">address</a>()!=f-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>)
<a name="l02713"></a>02713         <span class="keywordflow">return</span>;
<a name="l02714"></a>02714 
<a name="l02715"></a>02715     <span class="keywordflow">if</span> (bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a> &amp;&amp; bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>!=f) {
<a name="l02716"></a>02716         <span class="keywordflow">if</span> (va==bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>) {
<a name="l02717"></a>02717             <span class="comment">/* This is a call to some other existing function. Do not add it to the current function. */</span>
<a name="l02718"></a>02718             <span class="keywordflow">if</span> (debug) fprintf(debug, <span class="stringliteral">"[entry \"%s\"]"</span>, bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>-&gt;<a class="code" href="classPartitioner_1_1Function.html#3445a927f772aa09859896fa5681eb62">name</a>.c_str());
<a name="l02719"></a>02719         } <span class="keywordflow">else</span> {
<a name="l02720"></a>02720             <span class="comment">/* This block belongs internally to some other function. Since ROSE requires that blocks be owned by exactly one</span>
<a name="l02721"></a>02721 <span class="comment">             * function (the function/block relationship is an edge in the abstract syntax tree), we have to remove this block</span>
<a name="l02722"></a>02722 <span class="comment">             * from the other function.  We'll mark both the other function and this function as being in conflict and try</span>
<a name="l02723"></a>02723 <span class="comment">             * again later.</span>
<a name="l02724"></a>02724 <span class="comment">             *</span>
<a name="l02725"></a>02725 <span class="comment">             * However, there is a special case we need to watch out for: the case when the block in conflict is no longer</span>
<a name="l02726"></a>02726 <span class="comment">             * reachable from the original function due to having made changes to other blocks in the original function. For</span>
<a name="l02727"></a>02727 <span class="comment">             * instance, consider the following sequence of events:</span>
<a name="l02728"></a>02728 <span class="comment">             *     F000 contains B000 (the entry block) and B010</span>
<a name="l02729"></a>02729 <span class="comment">             *          B000 has 10 instructions, and ends with a call to F100 which returns</span>
<a name="l02730"></a>02730 <span class="comment">             *          B010 is the fall-through address of B000</span>
<a name="l02731"></a>02731 <span class="comment">             * We then begin to discover F005 whose entry address is the fifth instruction of B000, so</span>
<a name="l02732"></a>02732 <span class="comment">             *     B000 is split into B000 containing the first five instrucitons and B005 containing the second five</span>
<a name="l02733"></a>02733 <span class="comment">             *     F000 is marked as pending due to the splitting of its B000 block</span>
<a name="l02734"></a>02734 <span class="comment">             *     B005 is added to F005 as its entry block</span>
<a name="l02735"></a>02735 <span class="comment">             *     B005 calls F100 which returns to B010, so we want to add B010 to F005</span>
<a name="l02736"></a>02736 <span class="comment">             * So we have a conflict:</span>
<a name="l02737"></a>02737 <span class="comment">             *     B010 belongs to F000 because we never removed it, but we need B010 also in F005.</span>
<a name="l02738"></a>02738 <span class="comment">             * In this example, the only CFG edge to B010 inside F000 was the fall-through edge from the call to F100, which</span>
<a name="l02739"></a>02739 <span class="comment">             * no longer exists in F000. Unfortunately we have no way of knowing (short of doing a CFG analysis in F000) that</span>
<a name="l02740"></a>02740 <span class="comment">             * the last edge was removed. Even if we did a CFG analysis, we may be working with incomplete information (F000</span>
<a name="l02741"></a>02741 <span class="comment">             * might not be fully discovered yet).</span>
<a name="l02742"></a>02742 <span class="comment">             *</span>
<a name="l02743"></a>02743 <span class="comment">             * The way we handle this special case is as follows:</span>
<a name="l02744"></a>02744 <span class="comment">             *     If the original function (F000 in the example) is marked as pending then the blocks it currently owns might</span>
<a name="l02745"></a>02745 <span class="comment">             *     not actually belong to the function anymore. Therefore we will not create a new FUNC_GRAPH function for the</span>
<a name="l02746"></a>02746 <span class="comment">             *     block in conflict, but rather mark both functions as pending and abandon until the next pass.  Otherwise we</span>
<a name="l02747"></a>02747 <span class="comment">             *     assume the block in conflict really is in conflict and we'll create a FUNC_GRAPH function. */</span>
<a name="l02748"></a>02748             <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.find(va)==<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.end() &amp;&amp; !bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>-&gt;<a class="code" href="classPartitioner_1_1Function.html#d433af52820775a021eeae99f8e31ff2">pending</a>) {
<a name="l02749"></a>02749                 <a class="code" href="classPartitioner.html#91e9b8ad59e4657d6f3dbece95752a4e">add_function</a>(va, <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c9c6f61a9e05594d28378f6130c1d59cf">SgAsmFunction::FUNC_GRAPH</a>);
<a name="l02750"></a>02750                 <span class="keywordflow">if</span> (debug) fprintf(debug, <span class="stringliteral">"[conflict F%08"</span>PRIx64<span class="stringliteral">" \"%s\"]"</span>, bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>, bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>-&gt;<a class="code" href="classPartitioner_1_1Function.html#3445a927f772aa09859896fa5681eb62">name</a>.c_str());
<a name="l02751"></a>02751             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (debug) {
<a name="l02752"></a>02752                 fprintf(debug, <span class="stringliteral">"[possible conflict F%08"</span>PRIx64<span class="stringliteral">" \"%s\"]"</span>, bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>, bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>-&gt;<a class="code" href="classPartitioner_1_1Function.html#3445a927f772aa09859896fa5681eb62">name</a>.c_str());
<a name="l02753"></a>02753             }
<a name="l02754"></a>02754             bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>-&gt;<a class="code" href="classPartitioner_1_1Function.html#d433af52820775a021eeae99f8e31ff2">pending</a> = f-&gt;<a class="code" href="classPartitioner_1_1Function.html#d433af52820775a021eeae99f8e31ff2">pending</a> = <span class="keyword">true</span>;
<a name="l02755"></a>02755             <span class="keywordflow">if</span> (debug) fprintf(debug, <span class="stringliteral">" abandon"</span>);
<a name="l02756"></a>02756             <span class="keywordflow">throw</span> <a class="code" href="structPartitioner_1_1AbandonFunctionDiscovery.html">AbandonFunctionDiscovery</a>();
<a name="l02757"></a>02757         }
<a name="l02758"></a>02758     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((target_va=<a class="code" href="classPartitioner.html#5665dc5ef1c3aef6670dc6ab5d66815f">call_target</a>(bb))!=<a class="code" href="classPartitioner.html#7e4a76ae7ab4113b2ec7acf9093c3810">NO_TARGET</a>) {
<a name="l02759"></a>02759         <span class="comment">/* Call to a known target */</span>
<a name="l02760"></a>02760         <span class="keywordflow">if</span> (debug) fprintf(debug, <span class="stringliteral">"[call F%08"</span>PRIx64<span class="stringliteral">"]"</span>, target_va);
<a name="l02761"></a>02761 
<a name="l02762"></a>02762         <a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">append</a>(f, bb, reason);
<a name="l02763"></a>02763         <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *target_bb = <a class="code" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">find_bb_containing</a>(target_va);
<a name="l02764"></a>02764 
<a name="l02765"></a>02765         <span class="comment">/* Optionally create or add reason flags to called function. */</span>
<a name="l02766"></a>02766         <a class="code" href="classPartitioner_1_1Function.html">Function</a> *new_function = NULL;
<a name="l02767"></a>02767         <span class="keywordflow">if</span> ((<a class="code" href="classPartitioner.html#61a820e23e3d57c012d0928aa9c4d1a2">func_heuristics</a> &amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852ceea34044afa2b5415dad4b39cf2aa51d">SgAsmFunction::FUNC_CALL_TARGET</a>)) {
<a name="l02768"></a>02768             new_function = <a class="code" href="classPartitioner.html#91e9b8ad59e4657d6f3dbece95752a4e">add_function</a>(target_va, SgAsmFunction::FUNC_CALL_TARGET);
<a name="l02769"></a>02769         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#e9238319a8257ac90435cce78d96dc9d">find_function</a>(target_va)!=NULL) {
<a name="l02770"></a>02770             <a class="code" href="classPartitioner.html#e9238319a8257ac90435cce78d96dc9d">find_function</a>(target_va)-&gt;<a class="code" href="classPartitioner_1_1Function.html#84232118f03482d3eb09c76063ef73ef">reason</a> |= SgAsmFunction::FUNC_CALL_TARGET;
<a name="l02771"></a>02771         }
<a name="l02772"></a>02772 
<a name="l02773"></a>02773         <span class="comment">/* If the call target is part of a function (the current function or some other) and it's not the entry block then we</span>
<a name="l02774"></a>02774 <span class="comment">         * might need to rediscover the blocks of that function.   We don't need to rediscover the blocks of that function if</span>
<a name="l02775"></a>02775 <span class="comment">         * that function is the current function and should remain in the current function (i.e., we didn't create a new</span>
<a name="l02776"></a>02776 <span class="comment">         * function). */</span>
<a name="l02777"></a>02777         <span class="keywordflow">if</span> (target_bb &amp;&amp; target_bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a> &amp;&amp; target_va!=target_bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a> &amp;&amp;
<a name="l02778"></a>02778             (target_bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>!=f || new_function!=NULL))
<a name="l02779"></a>02779             target_bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>-&gt;<a class="code" href="classPartitioner_1_1Function.html#d433af52820775a021eeae99f8e31ff2">pending</a> = <span class="keyword">true</span>;
<a name="l02780"></a>02780 
<a name="l02781"></a>02781         <span class="comment">/* Discovery continues at the successors. */</span>
<a name="l02782"></a>02782         <span class="keyword">const</span> <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> &amp;suc = <a class="code" href="classPartitioner.html#e2e3e09e5194ba8c87bc968b65b63e3c">successors</a>(bb);
<a name="l02783"></a>02783         <span class="keywordflow">for</span> (Disassembler::AddressSet::const_iterator si=suc.begin(); si!=suc.end(); ++si) {
<a name="l02784"></a>02784             <span class="keywordflow">if</span> (*si!=f-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>)
<a name="l02785"></a>02785                 <a class="code" href="classPartitioner.html#354aa1fce4dcbc80c99038829a3ddb76">discover_blocks</a>(f, *si, reason);
<a name="l02786"></a>02786         }
<a name="l02787"></a>02787 
<a name="l02788"></a>02788     } <span class="keywordflow">else</span> {
<a name="l02789"></a>02789         <a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">append</a>(f, bb, reason);
<a name="l02790"></a>02790         <span class="keyword">const</span> <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a>&amp; suc = <a class="code" href="classPartitioner.html#e2e3e09e5194ba8c87bc968b65b63e3c">successors</a>(bb);
<a name="l02791"></a>02791         <span class="keywordflow">for</span> (Disassembler::AddressSet::const_iterator si=suc.begin(); si!=suc.end(); ++si) {
<a name="l02792"></a>02792             <span class="keywordflow">if</span> (*si!=f-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>)
<a name="l02793"></a>02793                 <a class="code" href="classPartitioner.html#354aa1fce4dcbc80c99038829a3ddb76">discover_blocks</a>(f, *si, reason);
<a name="l02794"></a>02794         }
<a name="l02795"></a>02795     }
<a name="l02796"></a>02796 }
<a name="l02797"></a>02797 
<a name="l02798"></a>02798 <span class="keywordtype">void</span>
<a name="l02799"></a><a class="code" href="classPartitioner.html#354aa1fce4dcbc80c99038829a3ddb76">02799</a> <a class="code" href="classPartitioner.html#354aa1fce4dcbc80c99038829a3ddb76">Partitioner::discover_blocks</a>(<a class="code" href="classPartitioner_1_1Function.html">Function</a> *f, <span class="keywordtype">unsigned</span> reason)
<a name="l02800"></a>02800 {
<a name="l02801"></a>02801     <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> heads = f-&gt;<a class="code" href="classPartitioner_1_1Function.html#41ac95e38f7681fd66736276a833f931">heads</a>;
<a name="l02802"></a>02802     heads.insert(f-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>);
<a name="l02803"></a>02803     <span class="keywordflow">for</span> (Disassembler::AddressSet::iterator hi=heads.begin(); hi!=heads.end(); ++hi)
<a name="l02804"></a>02804         <a class="code" href="classPartitioner.html#354aa1fce4dcbc80c99038829a3ddb76">discover_blocks</a>(f, *hi, reason);
<a name="l02805"></a>02805 }
<a name="l02806"></a>02806 
<a name="l02807"></a>02807 <span class="keywordtype">void</span>
<a name="l02808"></a><a class="code" href="classPartitioner.html#19725656eaa83118d75bdd77c617cef4">02808</a> <a class="code" href="classPartitioner.html#19725656eaa83118d75bdd77c617cef4">Partitioner::analyze_cfg</a>(<a class="code" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48c">SgAsmBlock::Reason</a> reason)
<a name="l02809"></a>02809 {
<a name="l02810"></a>02810     <span class="keywordflow">for</span> (size_t pass=1; <span class="keyword">true</span>; pass++) {
<a name="l02811"></a>02811         <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) fprintf(debug, <span class="stringliteral">"\n========== Partitioner::analyze_cfg() pass %zu ==========\n"</span>, pass);
<a name="l02812"></a>02812         <a class="code" href="classPartitioner.html#044f608ba9d2cf1d4b9d22b2c53ccea9">progress</a>(debug, <span class="stringliteral">"Partitioner: starting %s pass %zu: "</span>
<a name="l02813"></a>02813                  <span class="stringliteral">"%zu function%s, %zu insn%s, %zu block%s\n"</span>,
<a name="l02814"></a>02814                  <a class="code" href="stringify_8C.html#b126d8ccdc9431bdf919cf3337c44100">stringifySgAsmBlockReason</a>(reason, <span class="stringliteral">"BLK_"</span>).c_str(), pass,
<a name="l02815"></a>02815                  <a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.size(), 1==<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.size()?<span class="stringliteral">""</span>:<span class="stringliteral">"s"</span>, insns.size(), 1==insns.size()?<span class="stringliteral">""</span>:<span class="stringliteral">"s"</span>,
<a name="l02816"></a>02816                  <a class="code" href="classPartitioner.html#1f1a02cff90220dd026d8a344404fbea">basic_blocks</a>.size(), 1==<a class="code" href="classPartitioner.html#1f1a02cff90220dd026d8a344404fbea">basic_blocks</a>.size()?<span class="stringliteral">""</span>:<span class="stringliteral">"s"</span>);
<a name="l02817"></a>02817 
<a name="l02818"></a>02818         <span class="comment">/* Analyze function return characteristics. */</span>
<a name="l02819"></a>02819         <span class="keywordflow">for</span> (BasicBlocks::iterator bi=<a class="code" href="classPartitioner.html#1f1a02cff90220dd026d8a344404fbea">basic_blocks</a>.begin(); bi!=<a class="code" href="classPartitioner.html#1f1a02cff90220dd026d8a344404fbea">basic_blocks</a>.end(); ++bi) {
<a name="l02820"></a>02820             <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = bi-&gt;second;
<a name="l02821"></a>02821             if (!bb-&gt;function)
<a name="l02822"></a>02822                 <span class="keywordflow">continue</span>;
<a name="l02823"></a>02823 
<a name="l02824"></a>02824             <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> target_va = <a class="code" href="classPartitioner.html#7e4a76ae7ab4113b2ec7acf9093c3810">NO_TARGET</a>; <span class="comment">/*call target*/</span>
<a name="l02825"></a>02825             <span class="keywordtype">bool</span> iscall = <a class="code" href="classPartitioner.html#9c333715d5d353bab9fd4f46ce2c2d8d">is_function_call</a>(bb, &amp;target_va);
<a name="l02826"></a>02826             <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> return_va = <a class="code" href="classPartitioner.html#bd63242c67a32e6de5434d21956a01bf">canonic_block</a>(bb-&gt;last_insn()-&gt;get_address() + bb-&gt;last_insn()-&gt;get_size()); <span class="comment">// fall through</span>
<a name="l02827"></a>02827             <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *return_bb = NULL, *target_bb = NULL; <span class="comment">/* computed only if needed since they might split basic blocks */</span>
<a name="l02828"></a>02828             <span class="keywordtype">bool</span> succs_complete;
<a name="l02829"></a>02829             <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> succs = <a class="code" href="classPartitioner.html#e2e3e09e5194ba8c87bc968b65b63e3c">successors</a>(bb, &amp;succs_complete);
<a name="l02830"></a>02830 
<a name="l02831"></a>02831             <span class="keywordflow">if</span> (iscall &amp;&amp; target_va!=<a class="code" href="classPartitioner.html#7e4a76ae7ab4113b2ec7acf9093c3810">NO_TARGET</a> &amp;&amp;
<a name="l02832"></a>02832                 NULL!=(return_bb=<a class="code" href="classPartitioner.html#67702e97dcbfb27fa18f6186fe30538a">find_bb_starting</a>(return_va)) &amp;&amp;
<a name="l02833"></a>02833                 NULL!=(target_bb=<a class="code" href="classPartitioner.html#67702e97dcbfb27fa18f6186fe30538a">find_bb_starting</a>(target_va, <span class="keyword">false</span>)) &amp;&amp;
<a name="l02834"></a>02834                 target_bb-&gt;function &amp;&amp; target_bb-&gt;function-&gt;possible_may_return()) {
<a name="l02835"></a>02835                 <span class="keywordflow">if</span> (return_bb-&gt;function &amp;&amp; return_va==target_bb-&gt;function-&gt;entry_va &amp;&amp; !bb-&gt;function-&gt;possible_may_return()) {
<a name="l02836"></a>02836                     <span class="comment">/* This handles the case when function A's return from B falls through into B. In this case, since B</span>
<a name="l02837"></a>02837 <span class="comment">                     * returns then A also returns.  We mark A as returning.</span>
<a name="l02838"></a>02838 <span class="comment">                     *    function_A:</span>
<a name="l02839"></a>02839 <span class="comment">                     *        ...</span>
<a name="l02840"></a>02840 <span class="comment">                     *        CALL function_B</span>
<a name="l02841"></a>02841 <span class="comment">                     *    function_B:</span>
<a name="l02842"></a>02842 <span class="comment">                     *        RET</span>
<a name="l02843"></a>02843 <span class="comment">                     */</span>
<a name="l02844"></a>02844                     bb-&gt;function-&gt;promote_may_return(<a class="code" href="classSgAsmFunction.html#d1e0c37f9e507fc6acaf01dd0794a752921b64c76e93f8581fd16c205aac1516">SgAsmFunction::RET_SOMETIMES</a>);
<a name="l02845"></a>02845                     <span class="keywordflow">if</span> (debug) {
<a name="l02846"></a>02846                         fprintf(debug, <span class="stringliteral">"  Function F%08"</span>PRIx64<span class="stringliteral">" may return by virtue of call fall-through at B%08"</span>PRIx64<span class="stringliteral">"\n"</span>,
<a name="l02847"></a>02847                                 bb-&gt;function-&gt;entry_va, bb-&gt;address());
<a name="l02848"></a>02848                     }
<a name="l02849"></a>02849                 }
<a name="l02850"></a>02850             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!bb-&gt;function-&gt;possible_may_return() &amp;&amp; !<a class="code" href="classPartitioner.html#9c333715d5d353bab9fd4f46ce2c2d8d">is_function_call</a>(bb, NULL) &amp;&amp; succs_complete) {
<a name="l02851"></a>02851                 <span class="keywordflow">for</span> (Disassembler::AddressSet::iterator si=succs.begin();
<a name="l02852"></a>02852                      si!=succs.end() &amp;&amp; !bb-&gt;function-&gt;possible_may_return();
<a name="l02853"></a>02853                      ++si) {
<a name="l02854"></a>02854                     <span class="keywordflow">if</span> (0!=(target_va=*si) &amp;&amp; NULL!=(target_bb=<a class="code" href="classPartitioner.html#67702e97dcbfb27fa18f6186fe30538a">find_bb_starting</a>(target_va, <span class="keyword">false</span>)) &amp;&amp;
<a name="l02855"></a>02855                         target_bb-&gt;function &amp;&amp; target_bb-&gt;function!=bb-&gt;function &amp;&amp;
<a name="l02856"></a>02856                         target_va==target_bb-&gt;function-&gt;entry_va &amp;&amp; target_bb-&gt;function-&gt;possible_may_return()) {
<a name="l02857"></a>02857                         <span class="comment">/* The block bb isn't a function call, but branches to the entry point of another function.  If that</span>
<a name="l02858"></a>02858 <span class="comment">                         * function returns then so does this one.  This handles situations like:</span>
<a name="l02859"></a>02859 <span class="comment">                         *      function_A:</span>
<a name="l02860"></a>02860 <span class="comment">                         *          ...</span>
<a name="l02861"></a>02861 <span class="comment">                         *          JMP function_B</span>
<a name="l02862"></a>02862 <span class="comment">                         *      ...</span>
<a name="l02863"></a>02863 <span class="comment">                         *      function_B:</span>
<a name="l02864"></a>02864 <span class="comment">                         *          RET</span>
<a name="l02865"></a>02865 <span class="comment">                         * We don't need to set function_A-&gt;pending because the reachability of the instruction after its JMP</span>
<a name="l02866"></a>02866 <span class="comment">                         * won't change regardless of whether the "called" function returns (i.e., the return is to the caller</span>
<a name="l02867"></a>02867 <span class="comment">                         * of function_A, not to function_A itself. */</span>
<a name="l02868"></a>02868                         bb-&gt;function-&gt;promote_may_return(<a class="code" href="classSgAsmFunction.html#d1e0c37f9e507fc6acaf01dd0794a752921b64c76e93f8581fd16c205aac1516">SgAsmFunction::RET_SOMETIMES</a>);
<a name="l02869"></a>02869                         <span class="keywordflow">if</span> (debug) {
<a name="l02870"></a>02870                             fprintf(debug, <span class="stringliteral">"  F%08"</span>PRIx64<span class="stringliteral">" may return by virtue of branching to function F%08"</span>PRIx64
<a name="l02871"></a>02871                                     <span class="stringliteral">" which may return\n"</span>, bb-&gt;function-&gt;entry_va, target_bb-&gt;function-&gt;entry_va);
<a name="l02872"></a>02872                         }
<a name="l02873"></a>02873                     }
<a name="l02874"></a>02874                 }
<a name="l02875"></a>02875             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!bb-&gt;function-&gt;possible_may_return() &amp;&amp; !<a class="code" href="classPartitioner.html#9c333715d5d353bab9fd4f46ce2c2d8d">is_function_call</a>(bb, NULL) &amp;&amp; !succs_complete) {
<a name="l02876"></a>02876                 <span class="comment">/* If the basic block's successor is not known, then we must assume that it branches to something that could</span>
<a name="l02877"></a>02877 <span class="comment">                 * return. */</span>
<a name="l02878"></a>02878                 bb-&gt;function-&gt;promote_may_return(<a class="code" href="classSgAsmFunction.html#d1e0c37f9e507fc6acaf01dd0794a752921b64c76e93f8581fd16c205aac1516">SgAsmFunction::RET_SOMETIMES</a>);
<a name="l02879"></a>02879                 <span class="keywordflow">if</span> (debug) {
<a name="l02880"></a>02880                     fprintf(debug, <span class="stringliteral">"  F%08"</span>PRIx64<span class="stringliteral">" may return by virtue of incomplete successors\n"</span>,
<a name="l02881"></a>02881                             bb-&gt;function-&gt;entry_va);
<a name="l02882"></a>02882                 }
<a name="l02883"></a>02883             }
<a name="l02884"></a>02884         }
<a name="l02885"></a>02885 
<a name="l02886"></a>02886         <span class="comment">/* Which functions did we think didn't return but now think they might return? */</span>
<a name="l02887"></a>02887         <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> might_now_return;
<a name="l02888"></a>02888         <span class="keywordflow">for</span> (Functions::iterator fi=<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.begin(); fi!=<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.end(); ++fi) {
<a name="l02889"></a>02889             <a class="code" href="classPartitioner_1_1Function.html">Function</a> *func = fi-&gt;second;
<a name="l02890"></a>02890             if (func-&gt;changed_may_return() &amp;&amp; func-&gt;possible_may_return()) {
<a name="l02891"></a>02891                 <span class="keywordflow">if</span> (debug)
<a name="l02892"></a>02892                     fprintf(debug, <span class="stringliteral">"%s F%08"</span>PRIx64, might_now_return.empty()?<span class="stringliteral">"newly returning functions:"</span>:<span class="stringliteral">""</span>, func-&gt;entry_va);
<a name="l02893"></a>02893                 might_now_return.insert(func-&gt;entry_va);
<a name="l02894"></a>02894                 func-&gt;commit_may_return();
<a name="l02895"></a>02895             }
<a name="l02896"></a>02896         }
<a name="l02897"></a>02897         <span class="keywordflow">if</span> (debug &amp;&amp; !might_now_return.empty())
<a name="l02898"></a>02898             fprintf(debug, <span class="stringliteral">"\n"</span>);
<a name="l02899"></a>02899 
<a name="l02900"></a>02900         <span class="comment">/* If we previously thought a function didn't return, but now we think it might return, we need to mark as pending all</span>
<a name="l02901"></a>02901 <span class="comment">         * callers if the return address in that caller isn't already part of the caller function.   There's no need to do this</span>
<a name="l02902"></a>02902 <span class="comment">         * fairly expensive loop of we didn't transition any functions from does-not-return to may-return.  We use the</span>
<a name="l02903"></a>02903 <span class="comment">         * might_now_return set rather than looking up functions with find_function() because the former is probably faster,</span>
<a name="l02904"></a>02904 <span class="comment">         * especially if we have lots of functions but only a few transitioned from does-not-return to may-return, which is the</span>
<a name="l02905"></a>02905 <span class="comment">         * common case. */</span>
<a name="l02906"></a>02906         <span class="keywordflow">if</span> (!might_now_return.empty()) {
<a name="l02907"></a>02907             <span class="keywordflow">for</span> (BasicBlocks::iterator bi=<a class="code" href="classPartitioner.html#1f1a02cff90220dd026d8a344404fbea">basic_blocks</a>.begin(); bi!=<a class="code" href="classPartitioner.html#1f1a02cff90220dd026d8a344404fbea">basic_blocks</a>.end(); ++bi) {
<a name="l02908"></a>02908                 <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = bi-&gt;second;
<a name="l02909"></a>02909                 if (bb-&gt;function &amp;&amp; !bb-&gt;function-&gt;pending) {
<a name="l02910"></a>02910                     <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> succs = <a class="code" href="classPartitioner.html#e2e3e09e5194ba8c87bc968b65b63e3c">successors</a>(bb, NULL);
<a name="l02911"></a>02911                     <span class="keywordflow">for</span> (Disassembler::AddressSet::iterator si=succs.begin(); si!=succs.end(); ++si) {
<a name="l02912"></a>02912                         <span class="keywordflow">if</span> (might_now_return.find(*si)!=might_now_return.end()) {
<a name="l02913"></a>02913                             <span class="comment">// This is a call from a basic block (bb) to a function that we now think might return.  If the</span>
<a name="l02914"></a>02914                             <span class="comment">// return-to block is not already part of the calling function, then we should mark the calling</span>
<a name="l02915"></a>02915                             <span class="comment">// function as pending.</span>
<a name="l02916"></a>02916                             <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> return_va = <a class="code" href="classPartitioner.html#bd63242c67a32e6de5434d21956a01bf">canonic_block</a>(bb-&gt;last_insn()-&gt;get_address() + bb-&gt;last_insn()-&gt;get_size());
<a name="l02917"></a>02917                             <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *return_bb = <a class="code" href="classPartitioner.html#67702e97dcbfb27fa18f6186fe30538a">find_bb_starting</a>(return_va, <span class="keyword">false</span>); <span class="comment">// do not create the block</span>
<a name="l02918"></a>02918                             <span class="keywordflow">if</span> (return_bb &amp;&amp; return_bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>!=bb-&gt;function) {
<a name="l02919"></a>02919                                 bb-&gt;function-&gt;pending = <span class="keyword">true</span>;
<a name="l02920"></a>02920                                 <span class="keywordflow">if</span> (debug) {
<a name="l02921"></a>02921                                     <a class="code" href="classPartitioner_1_1Function.html">Function</a> *called_func = <a class="code" href="classPartitioner.html#e9238319a8257ac90435cce78d96dc9d">find_function</a>(*si); <span class="comment">// don't call this unless debugging (performance)</span>
<a name="l02922"></a>02922                                     assert(called_func!=NULL);
<a name="l02923"></a>02923                                     fprintf(debug,
<a name="l02924"></a>02924                                             <span class="stringliteral">"newreturn %s F%08"</span>PRIx64<span class="stringliteral">" \"%s\" returns to B%08"</span>PRIx64<span class="stringliteral">" in F%08"</span>PRIx64<span class="stringliteral">"\n"</span>,
<a name="l02925"></a>02925                                             <a class="code" href="classSgAsmFunction.html#86f4c5774c3b7aac2a21c7d6790a7baa">SgAsmFunction::reason_str</a>(<span class="keyword">true</span>, called_func-&gt;<a class="code" href="classPartitioner_1_1Function.html#84232118f03482d3eb09c76063ef73ef">reason</a>).c_str(), called_func-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>,
<a name="l02926"></a>02926                                             called_func-&gt;<a class="code" href="classPartitioner_1_1Function.html#3445a927f772aa09859896fa5681eb62">name</a>.c_str(), return_bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#7e120c89ba03d66a308381c0b82173c9">address</a>(), bb-&gt;function-&gt;entry_va);
<a name="l02927"></a>02927                                 }
<a name="l02928"></a>02928                             }
<a name="l02929"></a>02929                         }
<a name="l02930"></a>02930                     }
<a name="l02931"></a>02931                 }
<a name="l02932"></a>02932             }
<a name="l02933"></a>02933         }
<a name="l02934"></a>02934 
<a name="l02935"></a>02935         <span class="comment">/* Get a list of functions we need to analyze because they're marked as pending. */</span>
<a name="l02936"></a>02936         std::vector&lt;Function*&gt; pending;
<a name="l02937"></a>02937         <span class="keywordflow">for</span> (Functions::iterator fi=<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.begin(); fi!=<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.end(); ++fi) {
<a name="l02938"></a>02938             assert(fi-&gt;second-&gt;entry_va==fi-&gt;first);
<a name="l02939"></a>02939             <span class="keywordflow">if</span> (fi-&gt;second-&gt;pending) {
<a name="l02940"></a>02940                 fi-&gt;second-&gt;clear_basic_blocks();
<a name="l02941"></a>02941                 fi-&gt;second-&gt;pending = <span class="keyword">false</span>; <span class="comment">/*might be set back to true by discover_blocks() in loop below*/</span>
<a name="l02942"></a>02942                 pending.push_back(fi-&gt;second);
<a name="l02943"></a>02943             }
<a name="l02944"></a>02944         }
<a name="l02945"></a>02945 
<a name="l02946"></a>02946         <span class="keywordflow">if</span> (pending.size()==0) {
<a name="l02947"></a>02947             <span class="keywordflow">if</span> (debug)
<a name="l02948"></a>02948                 fprintf(debug, <span class="stringliteral">"finished for %s"</span>, <a class="code" href="stringify_8C.html#b126d8ccdc9431bdf919cf3337c44100">stringifySgAsmBlockReason</a>(reason, <span class="stringliteral">"BLK_"</span>).c_str());
<a name="l02949"></a>02949             <span class="keywordflow">break</span>;
<a name="l02950"></a>02950         }
<a name="l02951"></a>02951 
<a name="l02952"></a>02952         <span class="comment">/* Make sure all functions have an initial basic block if possible. */</span>
<a name="l02953"></a>02953         <span class="keywordflow">for</span> (size_t i=0; i&lt;pending.size(); ++i)
<a name="l02954"></a>02954             <a class="code" href="classPartitioner.html#810bddfe83b19037ed710bdb98a34f50">discover_first_block</a>(pending[i]);
<a name="l02955"></a>02955 
<a name="l02956"></a>02956         <span class="comment">/* (Re)discover each function's blocks starting with the function entry point */</span>
<a name="l02957"></a>02957         <span class="keywordflow">for</span> (size_t i=0; i&lt;pending.size(); ++i) {
<a name="l02958"></a>02958             <span class="keywordflow">if</span> (debug) {
<a name="l02959"></a>02959                 fprintf(debug, <span class="stringliteral">"analyzing %s F%08"</span>PRIx64<span class="stringliteral">" \"%s\" pass %zu: "</span>,
<a name="l02960"></a>02960                         <a class="code" href="classSgAsmFunction.html#86f4c5774c3b7aac2a21c7d6790a7baa">SgAsmFunction::reason_str</a>(<span class="keyword">true</span>, pending[i]-&gt;reason).c_str(),
<a name="l02961"></a>02961                         pending[i]-&gt;entry_va, pending[i]-&gt;name.c_str(), pass);
<a name="l02962"></a>02962             }
<a name="l02963"></a>02963             <span class="keywordflow">try</span> {
<a name="l02964"></a>02964                 <a class="code" href="classPartitioner.html#354aa1fce4dcbc80c99038829a3ddb76">discover_blocks</a>(pending[i], reason);
<a name="l02965"></a>02965             } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="structPartitioner_1_1AbandonFunctionDiscovery.html">AbandonFunctionDiscovery</a>&amp;) {
<a name="l02966"></a>02966                 <span class="comment">/* thrown when discover_blocks() decides it needs to start over on a function */</span>
<a name="l02967"></a>02967             }
<a name="l02968"></a>02968             <span class="keywordflow">if</span> (debug) {
<a name="l02969"></a>02969                 fputc(<span class="charliteral">' '</span>, <a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>);
<a name="l02970"></a>02970                 pending[i]-&gt;show_properties(<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>);
<a name="l02971"></a>02971                 fputc(<span class="charliteral">'\n'</span>, <a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>);
<a name="l02972"></a>02972             }
<a name="l02973"></a>02973         }
<a name="l02974"></a>02974     }
<a name="l02975"></a>02975 }
<a name="l02976"></a>02976 
<a name="l02977"></a>02977 size_t
<a name="l02978"></a><a class="code" href="classPartitioner.html#50ae683bbc187c44dc13dcac778fd502">02978</a> <a class="code" href="classPartitioner.html#50ae683bbc187c44dc13dcac778fd502">Partitioner::detach_thunks</a>()
<a name="l02979"></a>02979 {
<a name="l02980"></a>02980     size_t retval = 0;
<a name="l02981"></a>02981     <a class="code" href="classPartitioner.html#d68aee879b03b498c5d988d7fdfd6ae8">Functions</a> <a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a> = this-&gt;functions; <span class="comment">// so iterators remain valid inside the loop</span>
<a name="l02982"></a>02982     <span class="keywordflow">for</span> (Functions::iterator fi=functions.begin(); fi!=functions.end(); ++fi) {
<a name="l02983"></a>02983         <span class="keywordflow">while</span> (<a class="code" href="classPartitioner.html#b6d3411d68e7aa9a994850b672f01af0">detach_thunk</a>(fi-&gt;second))
<a name="l02984"></a>02984             ++retval;
<a name="l02985"></a>02985     }
<a name="l02986"></a>02986     <span class="keywordflow">return</span> retval;
<a name="l02987"></a>02987 }
<a name="l02988"></a>02988 
<a name="l02989"></a>02989 <span class="keywordtype">bool</span>
<a name="l02990"></a><a class="code" href="classPartitioner.html#b6d3411d68e7aa9a994850b672f01af0">02990</a> <a class="code" href="classPartitioner.html#b6d3411d68e7aa9a994850b672f01af0">Partitioner::detach_thunk</a>(<a class="code" href="classPartitioner_1_1Function.html">Function</a> *func)
<a name="l02991"></a>02991 {
<a name="l02992"></a>02992     <span class="comment">/* Don't split functions if it has only zero or one instruction. */</span>
<a name="l02993"></a>02993     <span class="keywordflow">if</span> (func-&gt;<a class="code" href="classPartitioner_1_1Function.html#8bdb95ca10afda44f8dacb28248f5c6c">basic_blocks</a>.empty())
<a name="l02994"></a>02994         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02995"></a>02995     <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *entry_bb = <a class="code" href="classPartitioner.html#67702e97dcbfb27fa18f6186fe30538a">find_bb_starting</a>(func-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>, <span class="keyword">false</span>);
<a name="l02996"></a>02996     <span class="keywordflow">if</span> (NULL==entry_bb || entry_bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>!=func)
<a name="l02997"></a>02997         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02998"></a>02998     <span class="keywordflow">if</span> (func-&gt;<a class="code" href="classPartitioner_1_1Function.html#8bdb95ca10afda44f8dacb28248f5c6c">basic_blocks</a>.size()==1 &amp;&amp; entry_bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.size()==1)
<a name="l02999"></a>02999         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03000"></a>03000 
<a name="l03001"></a>03001     <span class="comment">/* Don't split function whose first instruction is not an x86 JMP. */</span>
<a name="l03002"></a>03002     <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn_x86 = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(entry_bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>[0]);
<a name="l03003"></a>03003     <span class="keywordflow">if</span> (!insn_x86 || (insn_x86-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()!=<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571ad03bc3cf5ca0f4918d34b66a2ae0b24">x86_jmp</a> &amp;&amp; insn_x86-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()!=<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca557198fb4c6bacf21d45da2c1eb7380caccc">x86_farjmp</a>))
<a name="l03004"></a>03004         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03005"></a>03005 
<a name="l03006"></a>03006     <span class="comment">/* The JMP must have a single target. */</span>
<a name="l03007"></a>03007     <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> second_va = 0;
<a name="l03008"></a>03008     <span class="keywordflow">if</span> (entry_bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.size()&gt;1) {
<a name="l03009"></a>03009         second_va = entry_bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>[1]-&gt;get_address();
<a name="l03010"></a>03010     } <span class="keywordflow">else</span> {
<a name="l03011"></a>03011         <span class="keywordtype">bool</span> complete;
<a name="l03012"></a>03012         <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> succs = <a class="code" href="classPartitioner.html#e2e3e09e5194ba8c87bc968b65b63e3c">successors</a>(entry_bb, &amp;complete);
<a name="l03013"></a>03013         <span class="keywordflow">if</span> (!complete || succs.size()!=1)
<a name="l03014"></a>03014             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03015"></a>03015         second_va = *(succs.begin());
<a name="l03016"></a>03016     }
<a name="l03017"></a>03017 
<a name="l03018"></a>03018     <span class="comment">/* Don't split the function if the first instruction is a successor of any of the function's blocks. */</span>
<a name="l03019"></a>03019     <span class="keywordflow">for</span> (BasicBlocks::iterator bi=func-&gt;<a class="code" href="classPartitioner_1_1Function.html#8bdb95ca10afda44f8dacb28248f5c6c">basic_blocks</a>.begin(); bi!=func-&gt;<a class="code" href="classPartitioner_1_1Function.html#8bdb95ca10afda44f8dacb28248f5c6c">basic_blocks</a>.end(); ++bi) {
<a name="l03020"></a>03020         <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = bi-&gt;second;
<a name="l03021"></a>03021         <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> succs = <a class="code" href="classPartitioner.html#e2e3e09e5194ba8c87bc968b65b63e3c">successors</a>(bb, NULL);
<a name="l03022"></a>03022         <span class="keywordflow">if</span> (<a class="code" href="namespaceSageInterface.html#ff5394b21cf11cd338671af3a11a7f92">std::find</a>(succs.begin(), succs.end(), func-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>) != succs.end())
<a name="l03023"></a>03023             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03024"></a>03024     }
<a name="l03025"></a>03025 
<a name="l03026"></a>03026     <span class="comment">/* Create a new function to hold everything but the entry instruction */</span>
<a name="l03027"></a>03027     <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>)
<a name="l03028"></a>03028         fprintf(debug, <span class="stringliteral">"Partitioner::detach_thunk: detaching thunk F%08"</span>PRIx64<span class="stringliteral">" from body F%08"</span>PRIx64<span class="stringliteral">"\n"</span>,
<a name="l03029"></a>03029                 func-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>, second_va);
<a name="l03030"></a>03030     <a class="code" href="classPartitioner_1_1Function.html">Function</a> *new_func = <a class="code" href="classPartitioner.html#91e9b8ad59e4657d6f3dbece95752a4e">add_function</a>(second_va, func-&gt;<a class="code" href="classPartitioner_1_1Function.html#84232118f03482d3eb09c76063ef73ef">reason</a>);
<a name="l03031"></a>03031     new_func-&gt;<a class="code" href="classPartitioner_1_1Function.html#3445a927f772aa09859896fa5681eb62">name</a> = func-&gt;<a class="code" href="classPartitioner_1_1Function.html#3445a927f772aa09859896fa5681eb62">name</a>;
<a name="l03032"></a>03032     new_func-&gt;<a class="code" href="classPartitioner_1_1Function.html#4325b671ee6d062df9dc9e4c8868ac4a">set_may_return</a>(func-&gt;<a class="code" href="classPartitioner_1_1Function.html#cca110ab4755cb256c8d5e1c338dea7f">get_may_return</a>());
<a name="l03033"></a>03033 
<a name="l03034"></a>03034     <span class="comment">/* Adjust the old function, which now represents the thunk. */</span>
<a name="l03035"></a>03035     func-&gt;<a class="code" href="classPartitioner_1_1Function.html#84232118f03482d3eb09c76063ef73ef">reason</a> |= <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c331ffe7c063699b34757276068c08d79">SgAsmFunction::FUNC_THUNK</a>;
<a name="l03036"></a>03036     func-&gt;<a class="code" href="classPartitioner_1_1Function.html#d433af52820775a021eeae99f8e31ff2">pending</a> = <span class="keyword">false</span>;
<a name="l03037"></a>03037     <span class="keywordflow">if</span> (!func-&gt;<a class="code" href="classPartitioner_1_1Function.html#3445a927f772aa09859896fa5681eb62">name</a>.empty() &amp;&amp; std::string::npos==func-&gt;<a class="code" href="classPartitioner_1_1Function.html#3445a927f772aa09859896fa5681eb62">name</a>.find(<span class="stringliteral">"-thunk"</span>))
<a name="l03038"></a>03038         func-&gt;<a class="code" href="classPartitioner_1_1Function.html#3445a927f772aa09859896fa5681eb62">name</a> += <span class="stringliteral">"-thunk"</span>;
<a name="l03039"></a>03039     
<a name="l03040"></a>03040     <span class="comment">/* Transfer all instructions (except the thunk itself) to new_func. */</span>
<a name="l03041"></a>03041     new_func-&gt;<a class="code" href="classPartitioner_1_1Function.html#41ac95e38f7681fd66736276a833f931">heads</a> = func-&gt;<a class="code" href="classPartitioner_1_1Function.html#41ac95e38f7681fd66736276a833f931">heads</a>;
<a name="l03042"></a>03042     func-&gt;<a class="code" href="classPartitioner_1_1Function.html#41ac95e38f7681fd66736276a833f931">heads</a>.clear();
<a name="l03043"></a>03043     new_func-&gt;<a class="code" href="classPartitioner_1_1Function.html#41ac95e38f7681fd66736276a833f931">heads</a>.erase(func-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>);
<a name="l03044"></a>03044     <a class="code" href="classPartitioner.html#a3a62d239fd07ca47ffc37dd21b74006">BasicBlocks</a> bblocks = func-&gt;<a class="code" href="classPartitioner_1_1Function.html#8bdb95ca10afda44f8dacb28248f5c6c">basic_blocks</a>;
<a name="l03045"></a>03045     <span class="keywordflow">for</span> (BasicBlocks::iterator bi=bblocks.begin(); bi!=bblocks.end(); ++bi) {
<a name="l03046"></a>03046         <span class="keywordflow">if</span> (bi-&gt;first==func-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>) {
<a name="l03047"></a>03047             <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *new_bb = <a class="code" href="classPartitioner.html#67702e97dcbfb27fa18f6186fe30538a">find_bb_starting</a>(second_va);
<a name="l03048"></a>03048             <span class="keywordflow">if</span> (new_bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>==func) {
<a name="l03049"></a>03049                 <a class="code" href="classPartitioner.html#7a886afe82a7fc7171bdc64ecfd379fb">remove</a>(func, new_bb);
<a name="l03050"></a>03050                 <a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">append</a>(new_func, new_bb, <a class="code" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48ccb1cb50df0cb421e21b3ca064d1122e0">SgAsmBlock::BLK_ENTRY_POINT</a>);
<a name="l03051"></a>03051             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (new_bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>==new_func) {
<a name="l03052"></a>03052                 <span class="comment">/*void*/</span>
<a name="l03053"></a>03053             } <span class="keywordflow">else</span> {
<a name="l03054"></a>03054                 assert(NULL==new_bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>);
<a name="l03055"></a>03055                 <a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">append</a>(new_func, new_bb, <a class="code" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48ccb1cb50df0cb421e21b3ca064d1122e0">SgAsmBlock::BLK_ENTRY_POINT</a>);
<a name="l03056"></a>03056             }
<a name="l03057"></a>03057             <a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">append</a>(new_func, new_bb, <a class="code" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48ccb1cb50df0cb421e21b3ca064d1122e0">SgAsmBlock::BLK_ENTRY_POINT</a>);
<a name="l03058"></a>03058         } <span class="keywordflow">else</span> {
<a name="l03059"></a>03059             <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = bi-&gt;second;
<a name="l03060"></a>03060             <span class="keywordflow">if</span> (bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>!=new_func) {
<a name="l03061"></a>03061                 assert(bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>==func);
<a name="l03062"></a>03062                 <a class="code" href="classPartitioner.html#7a886afe82a7fc7171bdc64ecfd379fb">remove</a>(func, bb);
<a name="l03063"></a>03063                 <a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">append</a>(new_func, bb, bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#601ae03fbe778f2497dea0e5a3493cf9">reason</a>);
<a name="l03064"></a>03064             }
<a name="l03065"></a>03065         }
<a name="l03066"></a>03066     }
<a name="l03067"></a>03067 
<a name="l03068"></a>03068     <span class="comment">/* Transfer all data blocks to new_func. */</span>
<a name="l03069"></a>03069     <a class="code" href="classPartitioner.html#c9034b33e56a9e1d2e95dcd9c97cf431">DataBlocks</a> dblocks = func-&gt;<a class="code" href="classPartitioner_1_1Function.html#a4ec341f0aa8ef699a36dda8389036d8">data_blocks</a>;
<a name="l03070"></a>03070     <span class="keywordflow">for</span> (DataBlocks::iterator di=dblocks.begin(); di!=dblocks.end(); ++di) {
<a name="l03071"></a>03071         <a class="code" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *dblock = di-&gt;second;
<a name="l03072"></a>03072         <a class="code" href="classPartitioner.html#7a886afe82a7fc7171bdc64ecfd379fb">remove</a>(func, dblock);
<a name="l03073"></a>03073         <a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">append</a>(new_func, dblock, dblock-&gt;<a class="code" href="classPartitioner_1_1Function.html#84232118f03482d3eb09c76063ef73ef">reason</a>);
<a name="l03074"></a>03074     }
<a name="l03075"></a>03075     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03076"></a>03076 }
<a name="l03077"></a>03077 
<a name="l03078"></a>03078 <span class="comment">/* Moves padding blocks to correct functions. */</span>
<a name="l03079"></a>03079 <span class="keywordtype">void</span>
<a name="l03080"></a><a class="code" href="classPartitioner.html#6280eae4362e64e6b5df4ed55fc17c91">03080</a> <a class="code" href="classPartitioner.html#6280eae4362e64e6b5df4ed55fc17c91">Partitioner::adjust_padding</a>()
<a name="l03081"></a>03081 {
<a name="l03082"></a>03082     <span class="comment">/* Compute two maps: one for non-padding bytes belonging to functions, and one for the padding bytes. */</span>
<a name="l03083"></a>03083     <a class="code" href="classRangeMap.html">FunctionRangeMap</a> nonpadding_ranges;
<a name="l03084"></a>03084     <a class="code" href="classPartitioner.html#3a1386d81012e94a46184c4703fd9e40">function_extent</a>(&amp;nonpadding_ranges);
<a name="l03085"></a>03085     <a class="code" href="classRangeMap.html">DataRangeMap</a> padding_ranges;
<a name="l03086"></a>03086     <a class="code" href="classPartitioner.html#af310f1d4a77ace2f3b3ecc05e376c20">padding_extent</a>(&amp;padding_ranges);
<a name="l03087"></a>03087     <span class="keywordflow">for</span> (<a class="code" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">DataRangeMap::iterator</a> pi=padding_ranges.<a class="code" href="classRangeMap.html#09ef36a75655f2a1cbb74e60e34df930">begin</a>(); pi!=padding_ranges.<a class="code" href="classRangeMap.html#db1c2cb143b8d68961dbaf7debbf84e5">end</a>(); ++pi)
<a name="l03088"></a>03088         nonpadding_ranges.<a class="code" href="classRangeMap.html#a601374137845507fa80c404308ac426">erase</a>(pi-&gt;first);
<a name="l03089"></a>03089 
<a name="l03090"></a>03090     <span class="comment">/* For each padding block, find the closest prior function and make that the owner of the padding. */</span>
<a name="l03091"></a>03091     <span class="keywordflow">for</span> (<a class="code" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">DataRangeMap::iterator</a> pi=padding_ranges.<a class="code" href="classRangeMap.html#09ef36a75655f2a1cbb74e60e34df930">begin</a>(); pi!=padding_ranges.<a class="code" href="classRangeMap.html#db1c2cb143b8d68961dbaf7debbf84e5">end</a>(); ++pi) {
<a name="l03092"></a>03092         <a class="code" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *padding = pi-&gt;second.get();
<a name="l03093"></a>03093         <a class="code" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">FunctionRangeMap::iterator</a> npi = nonpadding_ranges.<a class="code" href="classRangeMap.html#0b5025ec1244eeec2619e2cc02cd8868">find_prior</a>(pi-&gt;first.first());
<a name="l03094"></a>03094         <span class="keywordflow">if</span> (npi==nonpadding_ranges.<a class="code" href="classRangeMap.html#db1c2cb143b8d68961dbaf7debbf84e5">end</a>())
<a name="l03095"></a>03095             <span class="keywordflow">continue</span>;
<a name="l03096"></a>03096         <a class="code" href="classPartitioner_1_1Function.html">Function</a> *func = npi-&gt;second.get();
<a name="l03097"></a>03097         <span class="keywordflow">if</span> (func!=<a class="code" href="classPartitioner.html#cd1de02179852d54139e2f4eb366ebdc">effective_function</a>(padding))
<a name="l03098"></a>03098             <a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">append</a>(func, padding, padding-&gt;<a class="code" href="classPartitioner_1_1Function.html#84232118f03482d3eb09c76063ef73ef">reason</a>, <span class="keyword">true</span><span class="comment">/*force*/</span>);
<a name="l03099"></a>03099     }
<a name="l03100"></a>03100 }
<a name="l03101"></a>03101 
<a name="l03102"></a>03102 <span class="comment">/* Merge function fragments when possible. */</span>
<a name="l03103"></a>03103 <span class="keywordtype">void</span>
<a name="l03104"></a><a class="code" href="classPartitioner.html#c0755f9cbb352919fe0d275cb8f4bd9a">03104</a> <a class="code" href="classPartitioner.html#c0755f9cbb352919fe0d275cb8f4bd9a">Partitioner::merge_function_fragments</a>()
<a name="l03105"></a>03105 {
<a name="l03106"></a>03106     <span class="comment">// Find connected components of the control flow graph, but only considering function fragments.  We do this in a single</span>
<a name="l03107"></a>03107     <span class="comment">// pass, and at the end of this loop each function fragment, F, will have group number group_number[traversal_number[F]].</span>
<a name="l03108"></a>03108     <span class="keyword">typedef</span> std::map&lt;Function*, size_t&gt; TravNumMap;
<a name="l03109"></a>03109     TravNumMap traversal_number;       <span class="comment">// which DFS traversal first visited the function?</span>
<a name="l03110"></a>03110     std::vector&lt;size_t&gt; group_number;  <span class="comment">// group number for each traversal (indexed by traversal number)</span>
<a name="l03111"></a>03111     <span class="keywordflow">for</span> (Functions::iterator fi=<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.begin(); fi!=<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.end(); ++fi) {
<a name="l03112"></a>03112         <span class="keywordflow">if</span> (<a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c9c6f61a9e05594d28378f6130c1d59cf">SgAsmFunction::FUNC_GRAPH</a>!=fi-&gt;second-&gt;reason)
<a name="l03113"></a>03113             <span class="keywordflow">continue</span>; <span class="comment">// only consider functions that are strictly fragments</span>
<a name="l03114"></a>03114         <span class="keywordflow">if</span> (traversal_number.find(fi-&gt;second)!=traversal_number.end())
<a name="l03115"></a>03115             <span class="keywordflow">continue</span>; <span class="comment">// we already visited this function</span>
<a name="l03116"></a>03116 
<a name="l03117"></a>03117         size_t tnum = group_number.size();
<a name="l03118"></a>03118         group_number.push_back(tnum);
<a name="l03119"></a>03119         traversal_number[fi-&gt;second] = tnum;
<a name="l03120"></a>03120 
<a name="l03121"></a>03121         <span class="comment">// Depth first search considering only function fragments</span>
<a name="l03122"></a>03122         std::vector&lt;Function*&gt; dfs_functions;
<a name="l03123"></a>03123         dfs_functions.push_back(fi-&gt;second);
<a name="l03124"></a>03124         <span class="keywordflow">while</span> (!dfs_functions.empty()) {
<a name="l03125"></a>03125             <a class="code" href="classPartitioner_1_1Function.html">Function</a> *source_func = dfs_functions.back(); dfs_functions.pop_back();
<a name="l03126"></a>03126             <span class="keywordflow">for</span> (BasicBlocks::iterator bi=source_func-&gt;basic_blocks.begin(); bi!=source_func-&gt;basic_blocks.end(); ++bi) {
<a name="l03127"></a>03127                 <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *source_bb = bi-&gt;second;
<a name="l03128"></a>03128                 <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> succs = <a class="code" href="classPartitioner.html#e2e3e09e5194ba8c87bc968b65b63e3c">successors</a>(source_bb);
<a name="l03129"></a>03129                 <span class="keywordflow">for</span> (Disassembler::AddressSet::iterator si=succs.begin(); si!=succs.end(); ++si) {
<a name="l03130"></a>03130                     <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *target_bb = <a class="code" href="classPartitioner.html#67702e97dcbfb27fa18f6186fe30538a">find_bb_starting</a>(*si, <span class="keyword">false</span>); <span class="comment">// do not create the block</span>
<a name="l03131"></a>03131                     <a class="code" href="classPartitioner_1_1Function.html">Function</a> *target_func = target_bb ? target_bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a> : NULL;
<a name="l03132"></a>03132                     <span class="keywordflow">if</span> (target_func &amp;&amp; target_func!=source_func &amp;&amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c9c6f61a9e05594d28378f6130c1d59cf">SgAsmFunction::FUNC_GRAPH</a>==target_func-&gt;<a class="code" href="classPartitioner_1_1Function.html#84232118f03482d3eb09c76063ef73ef">reason</a>) {
<a name="l03133"></a>03133                         <span class="keywordtype">bool</span> inserted = traversal_number.insert(std::make_pair(target_func, tnum)).second;
<a name="l03134"></a>03134                         <span class="keywordflow">if</span> (inserted) {
<a name="l03135"></a>03135                             dfs_functions.push_back(target_func);
<a name="l03136"></a>03136                         } <span class="keywordflow">else</span> {
<a name="l03137"></a>03137                             group_number[traversal_number[target_func]] = tnum;
<a name="l03138"></a>03138                         }
<a name="l03139"></a>03139                     }
<a name="l03140"></a>03140                 }
<a name="l03141"></a>03141             }
<a name="l03142"></a>03142         }
<a name="l03143"></a>03143     }
<a name="l03144"></a>03144 
<a name="l03145"></a>03145     <span class="comment">/* Reorganize so that we have lists of function fragments by group number. */</span>
<a name="l03146"></a>03146     <span class="keyword">typedef</span> std::vector&lt;std::vector&lt;Function*&gt; &gt; FragmentIndex;
<a name="l03147"></a>03147     FragmentIndex fragment_index(group_number.size(), std::vector&lt;Function*&gt;());
<a name="l03148"></a>03148     <span class="keywordflow">for</span> (Functions::iterator fi=<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.begin(); fi!=<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.end(); ++fi) {
<a name="l03149"></a>03149         TravNumMap::iterator tn_found = traversal_number.find(fi-&gt;second);
<a name="l03150"></a>03150         <span class="keywordflow">if</span> (tn_found!=traversal_number.end()) {
<a name="l03151"></a>03151             size_t gnum = group_number[tn_found-&gt;second];
<a name="l03152"></a>03152             fragment_index[gnum].push_back(fi-&gt;second);
<a name="l03153"></a>03153         }
<a name="l03154"></a>03154     }
<a name="l03155"></a>03155 <span class="preprocessor">#if 0 </span><span class="comment">/* DEBUGGING [RPM 2012-04-18] */</span>
<a name="l03156"></a>03156     fprintf(stderr, <span class="stringliteral">"Partitioner::merge_function_fragments: fragment index: \n"</span>);
<a name="l03157"></a>03157     <span class="keywordflow">for</span> (size_t gnum=0; gnum&lt;fragment_index.size(); gnum++) {
<a name="l03158"></a>03158         fprintf(stderr, <span class="stringliteral">"  group-%zu:"</span>, gnum);
<a name="l03159"></a>03159         <span class="keywordflow">for</span> (std::vector&lt;Function*&gt;::iterator fi=fragment_index[gnum].begin(); fi!=fragment_index[gnum].end(); ++fi)
<a name="l03160"></a>03160             fprintf(stderr, <span class="stringliteral">" F%08"</span>PRIx64, (*fi)-&gt;entry_va);
<a name="l03161"></a>03161         fprintf(stderr, <span class="stringliteral">"\n"</span>);
<a name="l03162"></a>03162     }
<a name="l03163"></a>03163 <span class="preprocessor">#endif</span>
<a name="l03164"></a>03164 <span class="preprocessor"></span>            
<a name="l03165"></a>03165     <span class="comment">/* Find the non-fragment predecessors of each fragment group. A fragment group can be merged into another function only if</span>
<a name="l03166"></a>03166 <span class="comment">     * the fragment group has a single predecessor. */</span>
<a name="l03167"></a>03167     std::vector&lt;Function*&gt; parent(fragment_index.size(), NULL);
<a name="l03168"></a>03168     <span class="keywordflow">for</span> (Functions::iterator fi=<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.begin(); fi!=<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.end(); ++fi) {
<a name="l03169"></a>03169         <a class="code" href="classPartitioner_1_1Function.html">Function</a> *source_func = fi-&gt;second;
<a name="l03170"></a>03170         if (<a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c9c6f61a9e05594d28378f6130c1d59cf">SgAsmFunction::FUNC_GRAPH</a>!=source_func-&gt;reason) {
<a name="l03171"></a>03171             <span class="keywordtype">bool</span> multi_parents = <span class="keyword">false</span>;
<a name="l03172"></a>03172             <span class="keywordflow">for</span> (BasicBlocks::iterator bi=source_func-&gt;basic_blocks.begin();
<a name="l03173"></a>03173                  bi!=source_func-&gt;basic_blocks.end() &amp;&amp; !multi_parents;
<a name="l03174"></a>03174                  ++bi) {
<a name="l03175"></a>03175                 <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> succs = <a class="code" href="classPartitioner.html#e2e3e09e5194ba8c87bc968b65b63e3c">successors</a>(bi-&gt;second);
<a name="l03176"></a>03176                 <span class="keywordflow">for</span> (Disassembler::AddressSet::iterator si=succs.begin(); si!=succs.end() &amp;&amp; !multi_parents; ++si) {
<a name="l03177"></a>03177                     <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *target_bb = <a class="code" href="classPartitioner.html#67702e97dcbfb27fa18f6186fe30538a">find_bb_starting</a>(*si, <span class="keyword">false</span><span class="comment">/*do not create*/</span>);
<a name="l03178"></a>03178                     <a class="code" href="classPartitioner_1_1Function.html">Function</a> *target_func = target_bb ? target_bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a> : NULL;
<a name="l03179"></a>03179                     TravNumMap::iterator tn_found = target_func ? traversal_number.find(target_func) : traversal_number.end();
<a name="l03180"></a>03180                     size_t gnum = tn_found!=traversal_number.end() ? group_number[tn_found-&gt;second] : (size_t)(-1);
<a name="l03181"></a>03181                     <span class="keywordflow">if</span> (gnum!=(size_t)(-1)) {
<a name="l03182"></a>03182                         <span class="comment">/* source_func (non-fragment) branches to fragment group number &lt;gnum&gt; */</span>
<a name="l03183"></a>03183                         <span class="keywordflow">if</span> (parent[gnum]) {
<a name="l03184"></a>03184                             parent[gnum] = NULL;
<a name="l03185"></a>03185                             fragment_index[gnum].clear(); <span class="comment">// multiple non-fragment predecessors of this group; discard group</span>
<a name="l03186"></a>03186                             multi_parents = <span class="keyword">true</span>;
<a name="l03187"></a>03187                         } <span class="keywordflow">else</span> {
<a name="l03188"></a>03188                             parent[gnum] = source_func;
<a name="l03189"></a>03189                         }
<a name="l03190"></a>03190                     }
<a name="l03191"></a>03191                 }
<a name="l03192"></a>03192             }
<a name="l03193"></a>03193         }
<a name="l03194"></a>03194     }
<a name="l03195"></a>03195 
<a name="l03196"></a>03196     <span class="comment">/* Merge functions */</span>
<a name="l03197"></a>03197     <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>)
<a name="l03198"></a>03198         fprintf(<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>, <span class="stringliteral">"Partitioner::merge_function_fragments...\n"</span>);
<a name="l03199"></a>03199     <span class="keywordflow">for</span> (size_t gnum=0; gnum&lt;fragment_index.size(); ++gnum) {
<a name="l03200"></a>03200         <span class="keywordflow">if</span> (parent[gnum]!=NULL &amp;&amp; !fragment_index[gnum].empty()) {
<a name="l03201"></a>03201             <span class="keywordflow">if</span> (debug) {
<a name="l03202"></a>03202                 fprintf(debug, <span class="stringliteral">"fragments %s F%08"</span>PRIx64<span class="stringliteral">" \"%s\" merging"</span>,
<a name="l03203"></a>03203                         <a class="code" href="classSgAsmFunction.html#86f4c5774c3b7aac2a21c7d6790a7baa">SgAsmFunction::reason_str</a>(<span class="keyword">true</span>, parent[gnum]-&gt;reason).c_str(),
<a name="l03204"></a>03204                         parent[gnum]-&gt;entry_va, parent[gnum]-&gt;name.c_str());
<a name="l03205"></a>03205             }
<a name="l03206"></a>03206             <span class="keywordflow">for</span> (std::vector&lt;Function*&gt;::iterator fi=fragment_index[gnum].begin(); fi!=fragment_index[gnum].end(); ++fi) {
<a name="l03207"></a>03207                 <span class="keywordflow">if</span> (debug)
<a name="l03208"></a>03208                     fprintf(debug, <span class="stringliteral">" F0x%08"</span>PRIx64, (*fi)-&gt;entry_va);
<a name="l03209"></a>03209                 <a class="code" href="classPartitioner.html#ffa6af5890f1034b4b6cd59779492e23">merge_functions</a>(parent[gnum], *fi); *fi = NULL;
<a name="l03210"></a>03210                 parent[gnum]-&gt;reason &amp;= ~<a class="code" href="classSgAsmFunction.html">SgAsmFunction</a>::FUNC_GRAPH;
<a name="l03211"></a>03211             }
<a name="l03212"></a>03212             <span class="keywordflow">if</span> (debug) {
<a name="l03213"></a>03213                 fputc(<span class="charliteral">' '</span>, debug);
<a name="l03214"></a>03214                 parent[gnum]-&gt;show_properties(debug);
<a name="l03215"></a>03215                 fputc(<span class="charliteral">'\n'</span>, debug);
<a name="l03216"></a>03216             }
<a name="l03217"></a>03217         }
<a name="l03218"></a>03218     }
<a name="l03219"></a>03219 }
<a name="l03220"></a>03220 
<a name="l03221"></a>03221 <span class="keywordtype">void</span>
<a name="l03222"></a><a class="code" href="classPartitioner.html#ffa6af5890f1034b4b6cd59779492e23">03222</a> <a class="code" href="classPartitioner.html#ffa6af5890f1034b4b6cd59779492e23">Partitioner::merge_functions</a>(<a class="code" href="classPartitioner_1_1Function.html">Function</a> *parent, <a class="code" href="classPartitioner_1_1Function.html">Function</a> *other)
<a name="l03223"></a>03223 {
<a name="l03224"></a>03224     parent-&gt;<a class="code" href="classPartitioner_1_1Function.html#84232118f03482d3eb09c76063ef73ef">reason</a> |= other-&gt;<a class="code" href="classPartitioner_1_1Function.html#84232118f03482d3eb09c76063ef73ef">reason</a>;
<a name="l03225"></a>03225 
<a name="l03226"></a>03226     <span class="keywordflow">if</span> (parent-&gt;<a class="code" href="classPartitioner_1_1Function.html#3445a927f772aa09859896fa5681eb62">name</a>.empty()) {
<a name="l03227"></a>03227         parent-&gt;<a class="code" href="classPartitioner_1_1Function.html#3445a927f772aa09859896fa5681eb62">name</a> = other-&gt;<a class="code" href="classPartitioner_1_1Function.html#3445a927f772aa09859896fa5681eb62">name</a>;
<a name="l03228"></a>03228     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!other-&gt;<a class="code" href="classPartitioner_1_1Function.html#3445a927f772aa09859896fa5681eb62">name</a>.empty() &amp;&amp; 0!=parent-&gt;<a class="code" href="classPartitioner_1_1Function.html#3445a927f772aa09859896fa5681eb62">name</a>.compare(other-&gt;<a class="code" href="classPartitioner_1_1Function.html#3445a927f772aa09859896fa5681eb62">name</a>)) {
<a name="l03229"></a>03229         parent-&gt;<a class="code" href="classPartitioner_1_1Function.html#3445a927f772aa09859896fa5681eb62">name</a> += <span class="stringliteral">"+"</span> + other-&gt;<a class="code" href="classPartitioner_1_1Function.html#3445a927f772aa09859896fa5681eb62">name</a>;
<a name="l03230"></a>03230     }
<a name="l03231"></a>03231 
<a name="l03232"></a>03232     parent-&gt;<a class="code" href="classPartitioner_1_1Function.html#ebc6491d5d1662d05d20fe11424ca87f">move_basic_blocks_from</a>(other);
<a name="l03233"></a>03233     parent-&gt;<a class="code" href="classPartitioner_1_1Function.html#74ee36aae06ad156b40daa5bfa48afb1">move_data_blocks_from</a>(other);
<a name="l03234"></a>03234 
<a name="l03235"></a>03235     <span class="keywordflow">if</span> (other-&gt;<a class="code" href="classPartitioner_1_1Function.html#d433af52820775a021eeae99f8e31ff2">pending</a>)
<a name="l03236"></a>03236         parent-&gt;<a class="code" href="classPartitioner_1_1Function.html#d433af52820775a021eeae99f8e31ff2">pending</a> = <span class="keyword">true</span>;
<a name="l03237"></a>03237 
<a name="l03238"></a>03238     parent-&gt;<a class="code" href="classPartitioner_1_1Function.html#aebf437238c29dadf3c29d078ed22549">promote_may_return</a>(other-&gt;<a class="code" href="classPartitioner_1_1Function.html#cca110ab4755cb256c8d5e1c338dea7f">get_may_return</a>());
<a name="l03239"></a>03239 
<a name="l03240"></a>03240     <a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.erase(other-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>);
<a name="l03241"></a>03241     <span class="keyword">delete</span> other;
<a name="l03242"></a>03242 }
<a name="l03243"></a>03243 
<a name="l03244"></a>03244 <span class="keywordtype">void</span>
<a name="l03245"></a><a class="code" href="classPartitioner.html#48a2e4d8bd6d15fb31a0ae8e41a747a3">03245</a> <a class="code" href="classPartitioner.html#48a2e4d8bd6d15fb31a0ae8e41a747a3">Partitioner::post_cfg</a>(<a class="code" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *interp<span class="comment">/*=NULL*/</span>)
<a name="l03246"></a>03246 {
<a name="l03247"></a>03247     <span class="comment">/* Obtain aggregate statistics over all the functions, and cache them. These statistics describe code, so we want to do</span>
<a name="l03248"></a>03248 <span class="comment">     * this before we add data blocks to the functions.  Any statistics already cached should be considered outdated. */</span>
<a name="l03249"></a>03249     <a class="code" href="classPartitioner.html#adaa21925ebc452fcac317509cfe84d9">clear_aggregate_statistics</a>();
<a name="l03250"></a>03250     <a class="code" href="classPartitioner_1_1RegionStats.html">RegionStats</a> *mean = <a class="code" href="classPartitioner.html#b611787b2c6ef70f765031acde40fdd2">aggregate_statistics</a>();
<a name="l03251"></a>03251     <a class="code" href="classPartitioner_1_1RegionStats.html">RegionStats</a> *variance = <a class="code" href="classPartitioner.html#6618693bfecf89c45fdf92a3b4b72cf3">get_aggregate_variance</a>();
<a name="l03252"></a>03252     <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>) {
<a name="l03253"></a>03253         std::ostringstream s;
<a name="l03254"></a>03254         s &lt;&lt;<span class="stringliteral">"=== Mean ===\n"</span> &lt;&lt;*mean &lt;&lt;<span class="stringliteral">"\n"</span>
<a name="l03255"></a>03255           &lt;&lt;<span class="stringliteral">"=== Variance ===\n"</span> &lt;&lt;*variance &lt;&lt;<span class="stringliteral">"\n"</span>;
<a name="l03256"></a>03256         fputs(s.str().c_str(), <a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>);
<a name="l03257"></a>03257     }
<a name="l03258"></a>03258 
<a name="l03259"></a>03259     <span class="comment">/* A memory map that contains only the executable regions.  I.e., those that might contain instructions. */</span>
<a name="l03260"></a>03260     <a class="code" href="classMemoryMap.html">MemoryMap</a> exe_map = *<a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>;
<a name="l03261"></a>03261     exe_map.<a class="code" href="classMemoryMap.html#8e5d8580f91704ebfb5b28bcbd71c01a">prune</a>(<a class="code" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575a061dc1ffe578fdaea067d730efb00ac">MemoryMap::MM_PROT_EXEC</a>);
<a name="l03262"></a>03262 
<a name="l03263"></a>03263     <span class="comment">/* Add unassigned intra-function blocks to the surrounding function.  This needs to come before detecting inter-function</span>
<a name="l03264"></a>03264 <span class="comment">     * padding, otherwise it will also try to add the stuff between the true function and its following padding. */</span>
<a name="l03265"></a>03265     <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#61a820e23e3d57c012d0928aa9c4d1a2">func_heuristics</a> &amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c78785310b2939c8834f597ef91fc17f4">SgAsmFunction::FUNC_INTRABLOCK</a>) {
<a name="l03266"></a>03266         <a class="code" href="structPartitioner_1_1FindFunctionFragments.html">FindFunctionFragments</a> fff;
<a name="l03267"></a>03267         fff.<a class="code" href="structPartitioner_1_1FindFunctionFragments.html#0968ba912f25c7f9b8bb92dbadeb2aeb">require_noninterleaved</a> = <span class="keyword">true</span>;
<a name="l03268"></a>03268         fff.<a class="code" href="structPartitioner_1_1FindFunctionFragments.html#647fe83474ee41f12efc4bd2ba53c079">require_intrafunction</a> = <span class="keyword">true</span>;
<a name="l03269"></a>03269         fff.<a class="code" href="structPartitioner_1_1FindFunctionFragments.html#c8d84eb37b797f8abdd00cb5e1a66196">threshold</a> = 0; <span class="comment">// treat all intra-function regions as code</span>
<a name="l03270"></a>03270         <a class="code" href="classPartitioner.html#9fa138686f888f9a51e6e798a550a285">scan_unassigned_bytes</a>(&amp;fff, &amp;exe_map);
<a name="l03271"></a>03271     }
<a name="l03272"></a>03272 
<a name="l03273"></a>03273     <span class="comment">/* Detect inter-function padding */</span>
<a name="l03274"></a>03274     <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#61a820e23e3d57c012d0928aa9c4d1a2">func_heuristics</a> &amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cdac33191eb0a658ed5382f9076595a28">SgAsmFunction::FUNC_PADDING</a>) {
<a name="l03275"></a>03275         <a class="code" href="structPartitioner_1_1FindDataPadding.html">FindDataPadding</a> cb;
<a name="l03276"></a>03276         cb.<a class="code" href="structPartitioner_1_1FindDataPadding.html#33a6ebd0a32698893da1fe3969473314">minimum_nrep</a> = 2;
<a name="l03277"></a>03277         cb.<a class="code" href="structPartitioner_1_1FindDataPadding.html#66f37c43985eaece53973cbd448fed23">maximum_nrep</a> = 1024*1024;
<a name="l03278"></a>03278         cb.<a class="code" href="structPartitioner_1_1FindDataPadding.html#6b5d276a6335acb237a5fac292ed3fd1">begins_contiguously</a> = <span class="keyword">false</span>;
<a name="l03279"></a>03279         cb.<a class="code" href="structPartitioner_1_1FindDataPadding.html#bf467f8bd8fe421c05aa827ff2c3ff83">ends_contiguously</a> = <span class="keyword">false</span>;
<a name="l03280"></a>03280 
<a name="l03281"></a>03281         <a class="code" href="Cxx__Grammar_8h.html#4f57773a5fc8d0d005f7553cd47cbc4e">SgUnsignedCharList</a> pattern;
<a name="l03282"></a>03282         pattern.push_back(0x90);                <span class="comment">/* x68 NOP */</span>
<a name="l03283"></a>03283         cb.<a class="code" href="structPartitioner_1_1FindDataPadding.html#feb31329993876d61d1911a020ced648">patterns</a>.push_back(pattern);
<a name="l03284"></a>03284 
<a name="l03285"></a>03285         pattern.clear();
<a name="l03286"></a>03286         pattern.push_back(0xcc);                <span class="comment">/* x86 INT3 */</span>
<a name="l03287"></a>03287         cb.<a class="code" href="structPartitioner_1_1FindDataPadding.html#feb31329993876d61d1911a020ced648">patterns</a>.push_back(pattern);
<a name="l03288"></a>03288 
<a name="l03289"></a>03289         <span class="comment">/* Scan only executable regions of memory. */</span>
<a name="l03290"></a>03290         <a class="code" href="classMemoryMap.html">MemoryMap</a> exe_map = *<a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>;
<a name="l03291"></a>03291         exe_map.<a class="code" href="classMemoryMap.html#8e5d8580f91704ebfb5b28bcbd71c01a">prune</a>(<a class="code" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575a061dc1ffe578fdaea067d730efb00ac">MemoryMap::MM_PROT_EXEC</a>);
<a name="l03292"></a>03292         <a class="code" href="classPartitioner.html#7f593939f5d8fa66b5e38a25183b4b8f">scan_interfunc_bytes</a>(&amp;cb, &amp;exe_map);
<a name="l03293"></a>03293     }
<a name="l03294"></a>03294 
<a name="l03295"></a>03295     <span class="comment">/* Find thunks.  First use FindThunkTables, which has a more relaxed definition of a "thunk" but requires some minimum</span>
<a name="l03296"></a>03296 <span class="comment">     * number of consecutive thunks in order to trigger.  Then use FindThunks, which has a strict definition including that the</span>
<a name="l03297"></a>03297 <span class="comment">     * thunk target must be a function.  By running the latter in a loop, we can find thunks that branch to other thunks. */</span>
<a name="l03298"></a>03298     <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#61a820e23e3d57c012d0928aa9c4d1a2">func_heuristics</a> &amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c331ffe7c063699b34757276068c08d79">SgAsmFunction::FUNC_THUNK</a>) {
<a name="l03299"></a>03299         <a class="code" href="structPartitioner_1_1FindThunkTables.html">FindThunkTables</a> find_thunk_tables;
<a name="l03300"></a>03300         find_thunk_tables.<a class="code" href="structPartitioner_1_1FindThunkTables.html#87b2107fff1914c79e5419cf3a710a28">minimum_nthunks</a> = 3; <span class="comment">// at least this many JMPs per table</span>
<a name="l03301"></a>03301         find_thunk_tables.<a class="code" href="structPartitioner_1_1FindThunkTables.html#6af964ccb6b86516db4cf1b1577cfbd8">validate_targets</a> = <span class="keyword">false</span>;
<a name="l03302"></a>03302         <a class="code" href="classPartitioner.html#9fa138686f888f9a51e6e798a550a285">scan_unassigned_bytes</a>(&amp;find_thunk_tables, &amp;exe_map);
<a name="l03303"></a>03303         <span class="keywordflow">for</span> (size_t npasses=0; npasses&lt;5; ++npasses) {
<a name="l03304"></a>03304             <a class="code" href="structPartitioner_1_1FindThunks.html">FindThunks</a> find_thunks;
<a name="l03305"></a>03305             <a class="code" href="classPartitioner.html#296180568b4a21d4435f264a05f1837f">scan_unassigned_insns</a>(&amp;find_thunks);
<a name="l03306"></a>03306             <span class="keywordflow">if</span> (0==find_thunks.nfound)
<a name="l03307"></a>03307                 <span class="keywordflow">break</span>;
<a name="l03308"></a>03308         }
<a name="l03309"></a>03309     }
<a name="l03310"></a>03310 
<a name="l03311"></a>03311     <span class="comment">/* Find functions that we missed between inter-function padding. */</span>
<a name="l03312"></a>03312     <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#61a820e23e3d57c012d0928aa9c4d1a2">func_heuristics</a> &amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852ccb6d9cc5789fcc0c98bb6e6894831228">SgAsmFunction::FUNC_MISCMASK</a>) {
<a name="l03313"></a>03313         <a class="code" href="structPartitioner_1_1FindInterPadFunctions.html">FindInterPadFunctions</a> find_interpad_functions;
<a name="l03314"></a>03314         <a class="code" href="classPartitioner.html#9fa138686f888f9a51e6e798a550a285">scan_unassigned_bytes</a>(&amp;find_interpad_functions, &amp;exe_map);
<a name="l03315"></a>03315     }
<a name="l03316"></a>03316 
<a name="l03317"></a>03317     <span class="comment">/* Find code fragments that appear after a function. */</span>
<a name="l03318"></a>03318     <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#61a820e23e3d57c012d0928aa9c4d1a2">func_heuristics</a> &amp; SgAsmFunction::FUNC_INTRABLOCK) {
<a name="l03319"></a>03319         <a class="code" href="structPartitioner_1_1FindFunctionFragments.html">FindFunctionFragments</a> fff;
<a name="l03320"></a>03320         fff.<a class="code" href="structPartitioner_1_1FindFunctionFragments.html#0968ba912f25c7f9b8bb92dbadeb2aeb">require_noninterleaved</a> = <span class="keyword">false</span>;
<a name="l03321"></a>03321         fff.<a class="code" href="structPartitioner_1_1FindFunctionFragments.html#647fe83474ee41f12efc4bd2ba53c079">require_intrafunction</a> = <span class="keyword">false</span>;
<a name="l03322"></a>03322         fff.<a class="code" href="structPartitioner_1_1FindFunctionFragments.html#c8d84eb37b797f8abdd00cb5e1a66196">threshold</a> = 0.7;
<a name="l03323"></a>03323         <a class="code" href="classPartitioner.html#9fa138686f888f9a51e6e798a550a285">scan_unassigned_bytes</a>(&amp;fff, &amp;exe_map);
<a name="l03324"></a>03324     }
<a name="l03325"></a>03325 
<a name="l03326"></a>03326     <span class="comment">/* Run another analysis of the CFG because we may need to fix some things up after having added more blocks from the</span>
<a name="l03327"></a>03327 <span class="comment">     * post-cfg analyses we did above. If nothing happened above, then analyze_cfg() should be fast. */</span>
<a name="l03328"></a>03328     <a class="code" href="classPartitioner.html#19725656eaa83118d75bdd77c617cef4">analyze_cfg</a>(<a class="code" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48c98cf079ce3d66b38c6d7f9f25eea9f73">SgAsmBlock::BLK_GRAPH2</a>);
<a name="l03329"></a>03329 
<a name="l03330"></a>03330     <span class="comment">/* Split thunks off from their jumped-to function.  Not really necessary, but the result is more like other common</span>
<a name="l03331"></a>03331 <span class="comment">     * disassemblers and also more closely matches what would happen if we had debugging information in the executable.  This</span>
<a name="l03332"></a>03332 <span class="comment">     * should only run after analyze_cfg() because it assumes that a function's blocks have all been discovered -- it does some</span>
<a name="l03333"></a>03333 <span class="comment">     * analysis on the function's internal control flow. */</span>
<a name="l03334"></a>03334     <span class="keywordflow">if</span> (0!=(<a class="code" href="classPartitioner.html#61a820e23e3d57c012d0928aa9c4d1a2">func_heuristics</a> &amp; SgAsmFunction::FUNC_THUNK) &amp;&amp; <a class="code" href="classPartitioner.html#50ae683bbc187c44dc13dcac778fd502">detach_thunks</a>()&gt;0)
<a name="l03335"></a>03335         <a class="code" href="classPartitioner.html#19725656eaa83118d75bdd77c617cef4">analyze_cfg</a>(<a class="code" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48c6dc92f7eb3987dc543ca9e14b415b141">SgAsmBlock::BLK_GRAPH3</a>);
<a name="l03336"></a>03336 
<a name="l03337"></a>03337     <span class="comment">/* Find thunks again.  We might have more things satisfying the relatively strict thunk definition. */</span>
<a name="l03338"></a>03338     <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#61a820e23e3d57c012d0928aa9c4d1a2">func_heuristics</a> &amp; SgAsmFunction::FUNC_THUNK) {
<a name="l03339"></a>03339         <span class="keywordflow">for</span> (size_t npasses=0; npasses&lt;5; ++npasses) {
<a name="l03340"></a>03340             <a class="code" href="structPartitioner_1_1FindThunks.html">FindThunks</a> find_thunks;
<a name="l03341"></a>03341             <a class="code" href="classPartitioner.html#296180568b4a21d4435f264a05f1837f">scan_unassigned_insns</a>(&amp;find_thunks);
<a name="l03342"></a>03342             <span class="keywordflow">if</span> (0==find_thunks.nfound)
<a name="l03343"></a>03343                 <span class="keywordflow">break</span>;
<a name="l03344"></a>03344         }
<a name="l03345"></a>03345     }
<a name="l03346"></a>03346 
<a name="l03347"></a>03347     <span class="comment">/* Append data to the end(s) of each normal function. */</span>
<a name="l03348"></a>03348     <a class="code" href="structPartitioner_1_1FindData.html">FindData</a> find_data;
<a name="l03349"></a>03349     <a class="code" href="classPartitioner.html#9fa138686f888f9a51e6e798a550a285">scan_unassigned_bytes</a>(&amp;find_data, &amp;<a class="code" href="classPartitioner.html#0b160d2ed1a5b32606e0deaf4c8cbb43">ro_map</a>);
<a name="l03350"></a>03350 
<a name="l03351"></a>03351     <span class="comment">/* Make sure padding is back where it belongs. */</span>
<a name="l03352"></a>03352     <a class="code" href="classPartitioner.html#6280eae4362e64e6b5df4ed55fc17c91">adjust_padding</a>();
<a name="l03353"></a>03353 
<a name="l03354"></a>03354     <span class="comment">/* Merge extra functions that we might have created.  Sometimes it's possible that we break a function into too many parts,</span>
<a name="l03355"></a>03355 <span class="comment">     * and we can recombine those parts now. */</span>
<a name="l03356"></a>03356     <a class="code" href="classPartitioner.html#c0755f9cbb352919fe0d275cb8f4bd9a">merge_function_fragments</a>();
<a name="l03357"></a>03357 
<a name="l03358"></a>03358     <span class="comment">/* Give existing functions names from symbol tables. Don't create more functions. */</span>
<a name="l03359"></a>03359     <span class="keywordflow">if</span> (interp &amp;&amp; 0!=(<a class="code" href="classPartitioner.html#61a820e23e3d57c012d0928aa9c4d1a2">func_heuristics</a> &amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c40c0ce88c447524963f4e8d7ef193cc7">SgAsmFunction::FUNC_IMPORT</a>)) {
<a name="l03360"></a>03360         <span class="keyword">const</span> <a class="code" href="Cxx__Grammar_8h.html#2b92a9464e206badb3c042fe0456d37e">SgAsmGenericHeaderPtrList</a> &amp;headers = interp-&gt;<a class="code" href="classSgAsmInterpretation.html#5d116938aaa9da9f3e27ca598965c77b">get_headers</a>()-&gt;<a class="code" href="classSgAsmGenericHeaderList.html#c3d9878c64af6c90e2d52988f8578b36">get_headers</a>();
<a name="l03361"></a>03361         <span class="keywordflow">for</span> (size_t i=0; i&lt;headers.size(); i++) {
<a name="l03362"></a>03362             <a class="code" href="classPartitioner.html#17cac3fb6a8a12bf633c70e4640728ff">name_plt_entries</a>(headers[i]); <span class="comment">// give names to ELF .plt trampolines</span>
<a name="l03363"></a>03363             <a class="code" href="classPartitioner.html#dc7b9b7851ee14847eed8454619cb505">name_import_entries</a>(headers[i]); <span class="comment">// give names to PE import thunks</span>
<a name="l03364"></a>03364         }
<a name="l03365"></a>03365     }
<a name="l03366"></a>03366 
<a name="l03367"></a>03367     <span class="comment">/* Add the BLK_CFGHEAD reason to all blocks that are also in the function's CFG head list.  We do this once here rather</span>
<a name="l03368"></a>03368 <span class="comment">     * than searching the heads list in each pass of analyze_cfg(). */</span>
<a name="l03369"></a>03369     <span class="keywordflow">for</span> (BasicBlocks::iterator bi=<a class="code" href="classPartitioner.html#1f1a02cff90220dd026d8a344404fbea">basic_blocks</a>.begin(); bi!=<a class="code" href="classPartitioner.html#1f1a02cff90220dd026d8a344404fbea">basic_blocks</a>.end(); ++bi) {
<a name="l03370"></a>03370         <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = bi-&gt;second;
<a name="l03371"></a>03371         if (bb-&gt;function &amp;&amp; 0==(bb-&gt;function-&gt;reason &amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c617301fe6a598b9c4afbde0aebcc8ad5">SgAsmFunction::FUNC_LEFTOVERS</a>) &amp;&amp;
<a name="l03372"></a>03372             bb-&gt;function-&gt;heads.find(bb-&gt;address())!=bb-&gt;function-&gt;heads.end())
<a name="l03373"></a>03373             bb-&gt;reason |= <a class="code" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48cf717779cc969a0f357ac6dae8fa2ddfa">SgAsmBlock::BLK_CFGHEAD</a>;
<a name="l03374"></a>03374     }
<a name="l03375"></a>03375 
<a name="l03376"></a>03376     <a class="code" href="classPartitioner.html#044f608ba9d2cf1d4b9d22b2c53ccea9">progress</a>(<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>,
<a name="l03377"></a>03377              <span class="stringliteral">"Partitioner completed: %zu function%s, %zu insn%s, %zu block%s\n"</span>,
<a name="l03378"></a>03378              <a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.size(), 1==<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.size()?<span class="stringliteral">""</span>:<span class="stringliteral">"s"</span>, insns.size(), 1==insns.size()?<span class="stringliteral">""</span>:<span class="stringliteral">"s"</span>,
<a name="l03379"></a>03379              <a class="code" href="classPartitioner.html#1f1a02cff90220dd026d8a344404fbea">basic_blocks</a>.size(), 1==<a class="code" href="classPartitioner.html#1f1a02cff90220dd026d8a344404fbea">basic_blocks</a>.size()?<span class="stringliteral">""</span>:<span class="stringliteral">"s"</span>);
<a name="l03380"></a>03380 }
<a name="l03381"></a>03381 
<a name="l03382"></a>03382 size_t
<a name="l03383"></a><a class="code" href="classPartitioner.html#3a1386d81012e94a46184c4703fd9e40">03383</a> <a class="code" href="classPartitioner.html#3a1386d81012e94a46184c4703fd9e40">Partitioner::function_extent</a>(<a class="code" href="classRangeMap.html">FunctionRangeMap</a> *extents)
<a name="l03384"></a>03384 {
<a name="l03385"></a>03385     size_t retval = 0;
<a name="l03386"></a>03386     <span class="keywordflow">for</span> (Functions::iterator fi=<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.begin(); fi!=<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.end(); ++fi)
<a name="l03387"></a>03387         retval += <a class="code" href="classPartitioner.html#3a1386d81012e94a46184c4703fd9e40">function_extent</a>(fi-&gt;second, extents);
<a name="l03388"></a>03388     <span class="keywordflow">return</span> retval;
<a name="l03389"></a>03389 }
<a name="l03390"></a>03390 
<a name="l03391"></a>03391 size_t
<a name="l03392"></a><a class="code" href="classPartitioner.html#4e30200e210edc6193cc8d4edd873607">03392</a> <a class="code" href="classPartitioner.html#3a1386d81012e94a46184c4703fd9e40">Partitioner::function_extent</a>(<a class="code" href="classPartitioner_1_1Function.html">Function</a> *func,
<a name="l03393"></a>03393                              <a class="code" href="classRangeMap.html">FunctionRangeMap</a> *extents<span class="comment">/*out*/</span>,
<a name="l03394"></a>03394                              <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> *lo_addr_ptr<span class="comment">/*out*/</span>, <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> *hi_addr_ptr<span class="comment">/*out*/</span>)
<a name="l03395"></a>03395 {
<a name="l03396"></a>03396     size_t nnodes=0;
<a name="l03397"></a>03397     <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> lo_addr=0, hi_addr=0;
<a name="l03398"></a>03398     std::set&lt;DataBlock*&gt; my_dblocks;
<a name="l03399"></a>03399 
<a name="l03400"></a>03400     <span class="keywordflow">for</span> (BasicBlocks::iterator bi=func-&gt;<a class="code" href="classPartitioner_1_1Function.html#8bdb95ca10afda44f8dacb28248f5c6c">basic_blocks</a>.begin(); bi!=func-&gt;<a class="code" href="classPartitioner_1_1Function.html#8bdb95ca10afda44f8dacb28248f5c6c">basic_blocks</a>.end(); ++bi) {
<a name="l03401"></a>03401         <span class="comment">/* Find the extents for all the instructions in this basic block. */</span>
<a name="l03402"></a>03402         <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = bi-&gt;second;
<a name="l03403"></a>03403         for (InstructionVector::iterator ii=bb-&gt;insns.begin(); ii!=bb-&gt;insns.end(); ++ii) {
<a name="l03404"></a>03404             <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> start = (*ii)-&gt;get_address();
<a name="l03405"></a>03405             size_t size = (*ii)-&gt;get_size();
<a name="l03406"></a>03406             <span class="keywordflow">if</span> (0==nnodes++) {
<a name="l03407"></a>03407                 lo_addr = start;
<a name="l03408"></a>03408                 hi_addr = start + size;
<a name="l03409"></a>03409             } <span class="keywordflow">else</span> {
<a name="l03410"></a>03410                 lo_addr = std::min(lo_addr, start);
<a name="l03411"></a>03411                 hi_addr = std::max(hi_addr, start + size);
<a name="l03412"></a>03412             }
<a name="l03413"></a>03413             <span class="keywordflow">if</span> (extents)
<a name="l03414"></a>03414                 extents-&gt;<a class="code" href="classRangeMap.html#df8ef8a1ea1d08b513487c6043ec0d8d">insert</a>(<a class="code" href="Cxx__Grammar_8h.html#d8e49820aaa106bb8a2dc17d9ad38d87">Extent</a>(start, size), func);
<a name="l03415"></a>03415         }
<a name="l03416"></a>03416 
<a name="l03417"></a>03417         <span class="comment">/* Gather data blocks associated with this basic block, but only if they aren't explicitly assigned to a function. */</span>
<a name="l03418"></a>03418         <span class="keywordflow">for</span> (std::set&lt;DataBlock*&gt;::iterator di=bb-&gt;data_blocks.begin(); di!=bb-&gt;data_blocks.end(); ++di) {
<a name="l03419"></a>03419             <span class="keywordflow">if</span> (NULL==(*di)-&gt;function)
<a name="l03420"></a>03420                 my_dblocks.insert(*di);
<a name="l03421"></a>03421         }
<a name="l03422"></a>03422     }
<a name="l03423"></a>03423 
<a name="l03424"></a>03424     <span class="comment">/* Gather the data blocks associated with this function. */</span>
<a name="l03425"></a>03425     <span class="keywordflow">for</span> (DataBlocks::iterator bi=func-&gt;<a class="code" href="classPartitioner_1_1Function.html#a4ec341f0aa8ef699a36dda8389036d8">data_blocks</a>.begin(); bi!=func-&gt;<a class="code" href="classPartitioner_1_1Function.html#a4ec341f0aa8ef699a36dda8389036d8">data_blocks</a>.end(); ++bi)
<a name="l03426"></a>03426         my_dblocks.insert(bi-&gt;second);
<a name="l03427"></a>03427 
<a name="l03428"></a>03428     <span class="comment">/* Add the extents of all this function's data blocks. */</span>
<a name="l03429"></a>03429     <span class="keywordflow">for</span> (std::set&lt;DataBlock*&gt;::iterator di=my_dblocks.begin(); di!=my_dblocks.end(); ++di) {
<a name="l03430"></a>03430         <a class="code" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *dblock = *di;
<a name="l03431"></a>03431         <a class="code" href="classRangeMap.html">DataRangeMap</a> data_extents;
<a name="l03432"></a>03432         <a class="code" href="classRangeMap.html">DataRangeMap</a> *data_extents_ptr = extents ? &amp;data_extents : NULL;
<a name="l03433"></a>03433         <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> lo, hi;
<a name="l03434"></a>03434         size_t n = <a class="code" href="classPartitioner.html#b887328bc3f2afab215f8c0e7e5603c9">datablock_extent</a>(dblock, data_extents_ptr, &amp;lo, &amp;hi);
<a name="l03435"></a>03435         <span class="keywordflow">if</span> (n&gt;0) {
<a name="l03436"></a>03436             <span class="keywordflow">if</span> (0==nnodes) {
<a name="l03437"></a>03437                 lo_addr = lo;
<a name="l03438"></a>03438                 hi_addr = hi;
<a name="l03439"></a>03439             } <span class="keywordflow">else</span> {
<a name="l03440"></a>03440                 lo_addr = std::min(lo_addr, lo);
<a name="l03441"></a>03441                 hi_addr = std::max(hi_addr, hi);
<a name="l03442"></a>03442             }
<a name="l03443"></a>03443             nnodes += n;
<a name="l03444"></a>03444             <span class="keywordflow">if</span> (extents) {
<a name="l03445"></a>03445                 <span class="keywordflow">for</span> (<a class="code" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">DataRangeMap::iterator</a> di2=data_extents.<a class="code" href="classRangeMap.html#09ef36a75655f2a1cbb74e60e34df930">begin</a>(); di2!=data_extents.<a class="code" href="classRangeMap.html#db1c2cb143b8d68961dbaf7debbf84e5">end</a>(); ++di2)
<a name="l03446"></a>03446                     extents-&gt;<a class="code" href="classRangeMap.html#df8ef8a1ea1d08b513487c6043ec0d8d">insert</a>(di2-&gt;first, func);
<a name="l03447"></a>03447             }
<a name="l03448"></a>03448         }
<a name="l03449"></a>03449     }
<a name="l03450"></a>03450 
<a name="l03451"></a>03451     <span class="comment">/* Return values */</span>
<a name="l03452"></a>03452     <span class="keywordflow">if</span> (lo_addr_ptr)
<a name="l03453"></a>03453         *lo_addr_ptr = lo_addr;
<a name="l03454"></a>03454     <span class="keywordflow">if</span> (hi_addr_ptr)
<a name="l03455"></a>03455         *hi_addr_ptr = hi_addr;
<a name="l03456"></a>03456     <span class="keywordflow">return</span> nnodes;
<a name="l03457"></a>03457 }
<a name="l03458"></a>03458 
<a name="l03459"></a>03459 size_t
<a name="l03460"></a><a class="code" href="classPartitioner.html#af310f1d4a77ace2f3b3ecc05e376c20">03460</a> <a class="code" href="classPartitioner.html#af310f1d4a77ace2f3b3ecc05e376c20">Partitioner::padding_extent</a>(<a class="code" href="classRangeMap.html">DataRangeMap</a> *extents<span class="comment">/*in,out*/</span>)
<a name="l03461"></a>03461 {
<a name="l03462"></a>03462     size_t nblocks = 0;
<a name="l03463"></a>03463     <span class="keywordflow">for</span> (DataBlocks::const_iterator di=<a class="code" href="classPartitioner.html#b8b08dc01aab15b7ae2dff4af899046f">data_blocks</a>.begin(); di!=<a class="code" href="classPartitioner.html#b8b08dc01aab15b7ae2dff4af899046f">data_blocks</a>.end(); ++di) {
<a name="l03464"></a>03464         <a class="code" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *dblock = di-&gt;second;
<a name="l03465"></a>03465         if (0!=(dblock-&gt;reason &amp; <a class="code" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48c155cde4b70560fc1bf7c615263adf0b0">SgAsmBlock::BLK_PADDING</a>) &amp;&amp; NULL!=<a class="code" href="classPartitioner.html#cd1de02179852d54139e2f4eb366ebdc">effective_function</a>(dblock)) {
<a name="l03466"></a>03466             <a class="code" href="classPartitioner.html#b887328bc3f2afab215f8c0e7e5603c9">datablock_extent</a>(dblock, extents);
<a name="l03467"></a>03467             ++nblocks;
<a name="l03468"></a>03468         }
<a name="l03469"></a>03469     }
<a name="l03470"></a>03470     <span class="keywordflow">return</span> nblocks;
<a name="l03471"></a>03471 }
<a name="l03472"></a>03472 
<a name="l03473"></a>03473 size_t
<a name="l03474"></a><a class="code" href="classPartitioner.html#481f8f89f2c2427ef13f3a737448c927">03474</a> <a class="code" href="classPartitioner.html#b887328bc3f2afab215f8c0e7e5603c9">Partitioner::datablock_extent</a>(<a class="code" href="classRangeMap.html">DataRangeMap</a> *extents<span class="comment">/*in,out*/</span>)
<a name="l03475"></a>03475 {
<a name="l03476"></a>03476     size_t nblocks = 0;
<a name="l03477"></a>03477     <span class="keywordflow">for</span> (DataBlocks::const_iterator di=<a class="code" href="classPartitioner.html#b8b08dc01aab15b7ae2dff4af899046f">data_blocks</a>.begin(); di!=<a class="code" href="classPartitioner.html#b8b08dc01aab15b7ae2dff4af899046f">data_blocks</a>.end(); ++di) {
<a name="l03478"></a>03478         <a class="code" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *dblock = di-&gt;second;
<a name="l03479"></a>03479         if (NULL!=<a class="code" href="classPartitioner.html#cd1de02179852d54139e2f4eb366ebdc">effective_function</a>(dblock)) {
<a name="l03480"></a>03480             <a class="code" href="classPartitioner.html#b887328bc3f2afab215f8c0e7e5603c9">datablock_extent</a>(dblock, extents);
<a name="l03481"></a>03481             ++nblocks;
<a name="l03482"></a>03482         }
<a name="l03483"></a>03483     }
<a name="l03484"></a>03484     <span class="keywordflow">return</span> nblocks;
<a name="l03485"></a>03485 }
<a name="l03486"></a>03486 
<a name="l03487"></a>03487 size_t
<a name="l03488"></a><a class="code" href="classPartitioner.html#b887328bc3f2afab215f8c0e7e5603c9">03488</a> <a class="code" href="classPartitioner.html#b887328bc3f2afab215f8c0e7e5603c9">Partitioner::datablock_extent</a>(<a class="code" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *db,
<a name="l03489"></a>03489                               <a class="code" href="classRangeMap.html">DataRangeMap</a> *extents<span class="comment">/*in,out*/</span>,
<a name="l03490"></a>03490                               <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> *lo_addr_ptr<span class="comment">/*out*/</span>, <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> *hi_addr_ptr<span class="comment">/*out*/</span>)
<a name="l03491"></a>03491 {
<a name="l03492"></a>03492     <span class="keywordflow">if</span> (db-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#fdc2bd13ec3bc86896eebb7ac65fcd08">nodes</a>.empty()) {
<a name="l03493"></a>03493         <span class="keywordflow">if</span> (lo_addr_ptr)
<a name="l03494"></a>03494             *lo_addr_ptr = 0;
<a name="l03495"></a>03495         <span class="keywordflow">if</span> (hi_addr_ptr)
<a name="l03496"></a>03496             *hi_addr_ptr = 0;
<a name="l03497"></a>03497     } <span class="keywordflow">else</span> {
<a name="l03498"></a>03498         <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> start = db-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#fdc2bd13ec3bc86896eebb7ac65fcd08">nodes</a>.front()-&gt;get_address();
<a name="l03499"></a>03499         size_t size = db-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#fdc2bd13ec3bc86896eebb7ac65fcd08">nodes</a>.front()-&gt;get_size();
<a name="l03500"></a>03500         <span class="keywordflow">if</span> (lo_addr_ptr)
<a name="l03501"></a>03501             *lo_addr_ptr = start;
<a name="l03502"></a>03502         <span class="keywordflow">if</span> (hi_addr_ptr)
<a name="l03503"></a>03503             *hi_addr_ptr = start+size;
<a name="l03504"></a>03504         <span class="keywordflow">if</span> (extents)
<a name="l03505"></a>03505             extents-&gt;<a class="code" href="classRangeMap.html#df8ef8a1ea1d08b513487c6043ec0d8d">insert</a>(<a class="code" href="Cxx__Grammar_8h.html#d8e49820aaa106bb8a2dc17d9ad38d87">Extent</a>(start, size), db);
<a name="l03506"></a>03506     }
<a name="l03507"></a>03507 
<a name="l03508"></a>03508     <span class="keywordflow">for</span> (size_t i=1; i&lt;db-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#fdc2bd13ec3bc86896eebb7ac65fcd08">nodes</a>.size(); i++) {
<a name="l03509"></a>03509         <a class="code" href="classSgAsmStaticData.html">SgAsmStaticData</a> *node = db-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#fdc2bd13ec3bc86896eebb7ac65fcd08">nodes</a>[i];
<a name="l03510"></a>03510         <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> start = node-&gt;get_address();
<a name="l03511"></a>03511         size_t size = node-&gt;get_size();
<a name="l03512"></a>03512 
<a name="l03513"></a>03513         <span class="keywordflow">if</span> (lo_addr_ptr)
<a name="l03514"></a>03514             *lo_addr_ptr = std::min(*lo_addr_ptr, start);
<a name="l03515"></a>03515         <span class="keywordflow">if</span> (hi_addr_ptr)
<a name="l03516"></a>03516             *hi_addr_ptr = std::max(*hi_addr_ptr, start+size);
<a name="l03517"></a>03517         <span class="keywordflow">if</span> (extents)
<a name="l03518"></a>03518             extents-&gt;<a class="code" href="classRangeMap.html#df8ef8a1ea1d08b513487c6043ec0d8d">insert</a>(<a class="code" href="Cxx__Grammar_8h.html#d8e49820aaa106bb8a2dc17d9ad38d87">Extent</a>(start, size), db);
<a name="l03519"></a>03519     }
<a name="l03520"></a>03520     <span class="keywordflow">return</span> db-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#fdc2bd13ec3bc86896eebb7ac65fcd08">nodes</a>.size();
<a name="l03521"></a>03521 }
<a name="l03522"></a>03522 
<a name="l03523"></a>03523 <span class="comment">/* The function is contiguous if the stuff between its extent doesn't belong to any other function. */</span>
<a name="l03524"></a>03524 <span class="keywordtype">bool</span>
<a name="l03525"></a><a class="code" href="classPartitioner.html#8e3fb4de9cbbd0a0bba2c3392f3361f9">03525</a> <a class="code" href="classPartitioner.html#8e3fb4de9cbbd0a0bba2c3392f3361f9">Partitioner::is_contiguous</a>(<a class="code" href="classPartitioner_1_1Function.html">Function</a> *func, <span class="keywordtype">bool</span> strict)
<a name="l03526"></a>03526 {
<a name="l03527"></a>03527     <a class="code" href="classRangeMap.html">FunctionRangeMap</a> extents;
<a name="l03528"></a>03528     <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> lo_addr, hi_addr;
<a name="l03529"></a>03529     <span class="keywordflow">if</span> (0==<a class="code" href="classPartitioner.html#3a1386d81012e94a46184c4703fd9e40">function_extent</a>(func, &amp;extents, &amp;lo_addr, &amp;hi_addr) || 1==extents.<a class="code" href="classRangeMap.html#2b3a6c7d061eee298faab8a21c33cca1">size</a>())
<a name="l03530"></a>03530         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03531"></a>03531     <span class="keywordflow">if</span> (strict)
<a name="l03532"></a>03532         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03533"></a>03533 
<a name="l03534"></a>03534     <span class="comment">/* Check for instructions belonging to other functions. */</span>
<a name="l03535"></a>03535     <span class="keyword">const</span> <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> max_insn_size = 16; <span class="comment">/* FIXME: This is a kludge, but should work 99% of the time [RPM 2011-09-16] */</span>
<a name="l03536"></a>03536     InstructionMap::iterator ii = insns.lower_bound(std::max(lo_addr,max_insn_size)-max_insn_size);
<a name="l03537"></a>03537     <span class="keywordflow">for</span> (<span class="comment">/*void*/</span>; ii!=insns.end() &amp;&amp; ii-&gt;first&lt;hi_addr; ++ii) {
<a name="l03538"></a>03538         <span class="keywordflow">if</span> (ii-&gt;first&gt;=lo_addr) {
<a name="l03539"></a>03539             <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = <a class="code" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">find_bb_containing</a>(ii-&gt;first, <span class="keyword">false</span>);
<a name="l03540"></a>03540             <span class="keywordflow">if</span> (bb &amp;&amp; bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a> &amp;&amp; bb-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>!=func)
<a name="l03541"></a>03541                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03542"></a>03542         }
<a name="l03543"></a>03543     }
<a name="l03544"></a>03544 
<a name="l03545"></a>03545     <span class="comment">/* Check for data belonging to other functions.</span>
<a name="l03546"></a>03546 <span class="comment">     * FIXME: we could use a faster method of doing this! [RPM 2011-09-29] */</span>
<a name="l03547"></a>03547     <span class="keywordflow">for</span> (DataBlocks::iterator dbi=<a class="code" href="classPartitioner.html#b8b08dc01aab15b7ae2dff4af899046f">data_blocks</a>.begin(); dbi!=<a class="code" href="classPartitioner.html#b8b08dc01aab15b7ae2dff4af899046f">data_blocks</a>.end(); ++dbi) {
<a name="l03548"></a>03548         <a class="code" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *block = dbi-&gt;second;
<a name="l03549"></a>03549         <a class="code" href="classPartitioner_1_1Function.html">Function</a> *block_func = <a class="code" href="classPartitioner.html#cd1de02179852d54139e2f4eb366ebdc">effective_function</a>(block);
<a name="l03550"></a>03550         <span class="keywordflow">if</span> (block_func!=NULL &amp;&amp; block_func!=func) {
<a name="l03551"></a>03551             <span class="keywordflow">for</span> (size_t i=0; i&lt;block-&gt;nodes.size(); i++) {
<a name="l03552"></a>03552                 <span class="keywordflow">if</span> (block-&gt;nodes[i]-&gt;get_address() &lt; hi_addr &amp;&amp;
<a name="l03553"></a>03553                     block-&gt;nodes[i]-&gt;get_address() + block-&gt;nodes[i]-&gt;get_size() &gt; lo_addr)
<a name="l03554"></a>03554                     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03555"></a>03555             }
<a name="l03556"></a>03556         }
<a name="l03557"></a>03557     }
<a name="l03558"></a>03558 
<a name="l03559"></a>03559     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03560"></a>03560 }
<a name="l03561"></a>03561 
<a name="l03562"></a>03562 <span class="comment">/* Update CFG edge nodes. */</span>
<a name="l03563"></a>03563 <span class="keywordtype">void</span>
<a name="l03564"></a><a class="code" href="classPartitioner.html#416452ab2d4ffc7df788c078421c4848">03564</a> <a class="code" href="classPartitioner.html#416452ab2d4ffc7df788c078421c4848">Partitioner::fixup_cfg_edges</a>(<a class="code" href="classSgNode.html">SgNode</a> *ast)
<a name="l03565"></a>03565 {
<a name="l03566"></a>03566     <span class="keyword">typedef</span> std::map&lt;rose_addr_t, SgAsmBlock*&gt; BlockMap;
<a name="l03567"></a>03567 
<a name="l03568"></a>03568     <span class="comment">/* Build a map from address to SgAsmBlock so we can do lookups quickly. */</span>
<a name="l03569"></a>03569     <span class="keyword">struct </span>BlockMapBuilder: <span class="keyword">public</span> <a class="code" href="classSgSimpleProcessing.html">SgSimpleProcessing</a> {
<a name="l03570"></a>03570         BlockMap *block_map;
<a name="l03571"></a>03571         BlockMapBuilder(<a class="code" href="classSgNode.html">SgNode</a> *ast, BlockMap *block_map): block_map(block_map) {
<a name="l03572"></a>03572             traverse(ast, <a class="code" href="Cxx__Grammar_8h.html#59f7fee88581c4dd75f5fb25dbefa29edefb5d09673c144dc5b4dc177e278696">preorder</a>);
<a name="l03573"></a>03573         }
<a name="l03574"></a>03574         <span class="keywordtype">void</span> visit(<a class="code" href="classSgNode.html">SgNode</a> *node) {
<a name="l03575"></a>03575             <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *block = <a class="code" href="Cxx__Grammar_8h.html#0f21c6b7a4aede1900e16a5122233a83">isSgAsmBlock</a>(node);
<a name="l03576"></a>03576             <span class="keywordflow">if</span> (block!=NULL) {
<a name="l03577"></a>03577                 <span class="keyword">const</span> <a class="code" href="Cxx__Grammar_8h.html#480a753ed3621cdcf18d7fd5ebacb3e3">SgAsmStatementPtrList</a> &amp;stmts = block-&gt;<a class="code" href="classSgAsmBlock.html#c19627b98d9cee481b9c533ad21ac755">get_statementList</a>();
<a name="l03578"></a>03578                 <a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn = stmts.empty() ? NULL : <a class="code" href="classPartitioner.html#9c2b4ede732f01bb1ce72270e0ee68da">isSgAsmInstruction</a>(stmts.front());
<a name="l03579"></a>03579                 <span class="keywordflow">if</span> (insn)
<a name="l03580"></a>03580                     block_map-&gt;insert(std::make_pair(insn-&gt;<a class="code" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>(), block));
<a name="l03581"></a>03581             }
<a name="l03582"></a>03582         }
<a name="l03583"></a>03583     };
<a name="l03584"></a>03584 
<a name="l03585"></a>03585     <span class="comment">/* Now add block pointers to the successor targets. */</span>
<a name="l03586"></a>03586     <span class="keyword">struct </span>TargetPopulator: <span class="keyword">public</span> <a class="code" href="classSgSimpleProcessing.html">SgSimpleProcessing</a> {
<a name="l03587"></a>03587         <span class="keyword">const</span> BlockMap &amp;block_map;
<a name="l03588"></a>03588         TargetPopulator(<a class="code" href="classSgNode.html">SgNode</a> *ast, <span class="keyword">const</span> BlockMap &amp;block_map): block_map(block_map) {
<a name="l03589"></a>03589             traverse(ast, <a class="code" href="Cxx__Grammar_8h.html#59f7fee88581c4dd75f5fb25dbefa29edefb5d09673c144dc5b4dc177e278696">preorder</a>);
<a name="l03590"></a>03590         }
<a name="l03591"></a>03591         <span class="keywordtype">void</span> visit(<a class="code" href="classSgNode.html">SgNode</a> *node) {
<a name="l03592"></a>03592             <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *block = <a class="code" href="Cxx__Grammar_8h.html#0f21c6b7a4aede1900e16a5122233a83">isSgAsmBlock</a>(node);
<a name="l03593"></a>03593             <span class="keywordflow">if</span> (block) {
<a name="l03594"></a>03594                 <span class="keywordflow">for</span> (size_t i=0; i&lt;block-&gt;<a class="code" href="classSgAsmBlock.html#0e798d793c22e6d6a63a526b6a18e7ce">get_successors</a>().size(); i++) {
<a name="l03595"></a>03595                     <a class="code" href="classSgAsmIntegerValueExpression.html">SgAsmIntegerValueExpression</a> *target = block-&gt;<a class="code" href="classSgAsmBlock.html#0e798d793c22e6d6a63a526b6a18e7ce">get_successors</a>()[i];
<a name="l03596"></a>03596                     <span class="keywordflow">if</span> (target &amp;&amp; NULL==target-&gt;get_base_node()) {
<a name="l03597"></a>03597                         BlockMap::const_iterator bi=block_map.find(target-&gt;get_absolute_value());
<a name="l03598"></a>03598                         <span class="keywordflow">if</span> (bi!=block_map.end())
<a name="l03599"></a>03599                             target-&gt;make_relative_to(bi-&gt;second);
<a name="l03600"></a>03600                     }
<a name="l03601"></a>03601                 }
<a name="l03602"></a>03602             }
<a name="l03603"></a>03603         }
<a name="l03604"></a>03604     };
<a name="l03605"></a>03605 
<a name="l03606"></a>03606     BlockMap block_map;
<a name="l03607"></a>03607     BlockMapBuilder(ast, &amp;block_map);
<a name="l03608"></a>03608     TargetPopulator(ast, block_map);
<a name="l03609"></a>03609 }
<a name="l03610"></a>03610 
<a name="l03611"></a>03611 <span class="comment">/* Make pointers relative to what they point into. */</span>
<a name="l03612"></a>03612 <span class="keywordtype">void</span>
<a name="l03613"></a><a class="code" href="classPartitioner.html#ea4ea9a5b5238c91b86b226fb04708c1">03613</a> <a class="code" href="classPartitioner.html#ea4ea9a5b5238c91b86b226fb04708c1">Partitioner::fixup_pointers</a>(<a class="code" href="classSgNode.html">SgNode</a> *ast, <a class="code" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *interp<span class="comment">/*=NULL*/</span>)
<a name="l03614"></a>03614 {
<a name="l03615"></a>03615 
<a name="l03616"></a>03616     <span class="keyword">struct </span>FixerUpper: <span class="keyword">public</span> <a class="code" href="classAstPrePostProcessing.html">AstPrePostProcessing</a> {
<a name="l03617"></a>03617         <a class="code" href="classPartitioner.html">Partitioner</a> *p;
<a name="l03618"></a>03618         <a class="code" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *interp;
<a name="l03619"></a>03619         <a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn;
<a name="l03620"></a>03620         <a class="code" href="Cxx__Grammar_8h.html#af7ee9051414ea5a9e6e9697fe2cc6e2">SgAsmGenericSectionPtrList</a> mapped_sections;
<a name="l03621"></a>03621         <a class="code" href="classRangeMap.html">DataRangeMap</a> static_data;
<a name="l03622"></a>03622 
<a name="l03623"></a>03623         FixerUpper(<a class="code" href="classPartitioner.html">Partitioner</a> *p, <a class="code" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *interp)
<a name="l03624"></a>03624             : p(p), interp(interp), insn(NULL) {}
<a name="l03625"></a>03625 
<a name="l03626"></a>03626         <span class="keywordtype">void</span> atTraversalStart() {
<a name="l03627"></a>03627             <span class="comment">/* Get a list of all memory-mapped sections in the interpretation. */</span>
<a name="l03628"></a>03628             <span class="keywordflow">if</span> (interp) {
<a name="l03629"></a>03629                 <span class="keyword">const</span> <a class="code" href="Cxx__Grammar_8h.html#2b92a9464e206badb3c042fe0456d37e">SgAsmGenericHeaderPtrList</a> &amp;headers = interp-&gt;<a class="code" href="classSgAsmInterpretation.html#5d116938aaa9da9f3e27ca598965c77b">get_headers</a>()-&gt;<a class="code" href="classSgAsmGenericHeaderList.html#c3d9878c64af6c90e2d52988f8578b36">get_headers</a>();
<a name="l03630"></a>03630                 <span class="keywordflow">for</span> (SgAsmGenericHeaderPtrList::const_iterator hi=headers.begin(); hi!=headers.end(); ++hi) {
<a name="l03631"></a>03631                     <span class="keywordflow">if</span> ((*hi)-&gt;is_mapped())
<a name="l03632"></a>03632                         mapped_sections.push_back(*hi);
<a name="l03633"></a>03633                     <a class="code" href="Cxx__Grammar_8h.html#af7ee9051414ea5a9e6e9697fe2cc6e2">SgAsmGenericSectionPtrList</a> file_sections = (*hi)-&gt;get_mapped_sections();
<a name="l03634"></a>03634                     mapped_sections.insert(mapped_sections.end(), file_sections.begin(), file_sections.end());
<a name="l03635"></a>03635                 }
<a name="l03636"></a>03636             }
<a name="l03637"></a>03637 
<a name="l03638"></a>03638             <span class="comment">/* Get a list of all static data blocks */</span>
<a name="l03639"></a>03639             p-&gt;<a class="code" href="classPartitioner.html#b887328bc3f2afab215f8c0e7e5603c9">datablock_extent</a>(&amp;static_data);
<a name="l03640"></a>03640         }
<a name="l03641"></a>03641 
<a name="l03642"></a>03642         <span class="keywordtype">void</span> preOrderVisit(<a class="code" href="classSgNode.html">SgNode</a> *node) {
<a name="l03643"></a>03643             <span class="keywordflow">if</span> (!insn) {
<a name="l03644"></a>03644                 insn = <a class="code" href="classPartitioner.html#9c2b4ede732f01bb1ce72270e0ee68da">isSgAsmInstruction</a>(node);
<a name="l03645"></a>03645             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#1f84547c1be282455b89ec1ef75f834d">isSgAsmIntegerValueExpression</a>(node)) {
<a name="l03646"></a>03646                 <a class="code" href="classSgAsmIntegerValueExpression.html">SgAsmIntegerValueExpression</a> *ival = <a class="code" href="Cxx__Grammar_8h.html#1f84547c1be282455b89ec1ef75f834d">isSgAsmIntegerValueExpression</a>(node);
<a name="l03647"></a>03647 
<a name="l03648"></a>03648                 <span class="comment">/* Don't monkey with constants that are already relative to some other node.  These are things that have been</span>
<a name="l03649"></a>03649 <span class="comment">                 * already fixed up by other methods. */</span>
<a name="l03650"></a>03650                 <span class="keywordflow">if</span> (ival-&gt;<a class="code" href="classSgAsmIntegerValueExpression.html#03a85d1a7c86cb075adaef1aaf77d4aa">get_base_node</a>()!=NULL)
<a name="l03651"></a>03651                     <span class="keywordflow">return</span>;
<a name="l03652"></a>03652                 <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va = ival-&gt;<a class="code" href="classSgAsmIntegerValueExpression.html#6f34176790d22016a331452ef071bb12">get_absolute_value</a>();
<a name="l03653"></a>03653 
<a name="l03654"></a>03654                 <span class="comment">/* If this constant is a code pointer, then make the pointer relative to the instruction it points to.  If that</span>
<a name="l03655"></a>03655 <span class="comment">                 * instruction is the entry instruction of a function, then point to the function instead.  A value is</span>
<a name="l03656"></a>03656 <span class="comment">                 * considered a code pointer only if it points to an existing instruction that's contained in a basic block,</span>
<a name="l03657"></a>03657 <span class="comment">                 * and that basic block is part of a valid function.  This constraint weeds out pointers to code that was</span>
<a name="l03658"></a>03658 <span class="comment">                 * disassembled but later discarded. */</span>
<a name="l03659"></a>03659                 <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a> *target_insn = p-&gt;<a class="code" href="classPartitioner.html#1dcdd3e0993256cd5ed93fd4d178679f">find_instruction</a>(va, <span class="keyword">false</span><span class="comment">/*do not create*/</span>);
<a name="l03660"></a>03660                 <span class="keywordflow">if</span> (target_insn &amp;&amp; target_insn-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#4ca5b571a28bd3a9fb719baec4b99777">bblock</a> &amp;&amp; target_insn-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#4ca5b571a28bd3a9fb719baec4b99777">bblock</a>-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a> &amp;&amp;
<a name="l03661"></a>03661                     0==(target_insn-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#4ca5b571a28bd3a9fb719baec4b99777">bblock</a>-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#aa4f8d6ea142164591d7c86c1cf18718">function</a>-&gt;<a class="code" href="classPartitioner_1_1Function.html#84232118f03482d3eb09c76063ef73ef">reason</a> &amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c617301fe6a598b9c4afbde0aebcc8ad5">SgAsmFunction::FUNC_LEFTOVERS</a>)) {
<a name="l03662"></a>03662                     <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *target_func = SageInterface::getEnclosingNode&lt;SgAsmFunction&gt;(target_insn-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#4b229dbd56516c2f986029271ea77b1a">node</a>);
<a name="l03663"></a>03663                     <span class="keywordflow">if</span> (target_func &amp;&amp; target_func-&gt;<a class="code" href="classSgAsmFunction.html#6edeeb78e01e2af6e59a5c6f7b0088af">get_entry_va</a>()==target_insn-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#a9c8dd5cf80780b59c4e74e4bb8b2811">get_address</a>()) {
<a name="l03664"></a>03664                         ival-&gt;<a class="code" href="classSgAsmIntegerValueExpression.html#b0e0e47f36d6ff9077fe8a54f6c7fede">make_relative_to</a>(target_func);
<a name="l03665"></a>03665                     } <span class="keywordflow">else</span> {
<a name="l03666"></a>03666                         ival-&gt;<a class="code" href="classSgAsmIntegerValueExpression.html#b0e0e47f36d6ff9077fe8a54f6c7fede">make_relative_to</a>(target_insn-&gt;<a class="code" href="classPartitioner_1_1Instruction.html#4b229dbd56516c2f986029271ea77b1a">node</a>);
<a name="l03667"></a>03667                     }
<a name="l03668"></a>03668                     <span class="keywordflow">return</span>;
<a name="l03669"></a>03669                 }
<a name="l03670"></a>03670 
<a name="l03671"></a>03671                 <span class="comment">/* If this constant points into a static data block, then make it relative to that block. */</span>
<a name="l03672"></a>03672                 <a class="code" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">DataRangeMap::iterator</a> dbi = static_data.find(va);
<a name="l03673"></a>03673                 <span class="keywordflow">if</span> (dbi!=static_data.end()) {
<a name="l03674"></a>03674                     <a class="code" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *dblock = dbi-&gt;second.get();
<a name="l03675"></a>03675                     <span class="keywordflow">for</span> (size_t i=0; i&lt;dblock-&gt;nodes.size(); ++i) {
<a name="l03676"></a>03676                         <a class="code" href="classSgAsmStaticData.html">SgAsmStaticData</a> *sd = dblock-&gt;nodes[i];
<a name="l03677"></a>03677                         if (va&gt;=sd-&gt;get_address() &amp;&amp; va&lt;sd-&gt;get_address()+sd-&gt;get_size()) {
<a name="l03678"></a>03678                             ival-&gt;<a class="code" href="classSgAsmIntegerValueExpression.html#b0e0e47f36d6ff9077fe8a54f6c7fede">make_relative_to</a>(sd);
<a name="l03679"></a>03679                             <span class="keywordflow">return</span>;
<a name="l03680"></a>03680                         }
<a name="l03681"></a>03681                     }
<a name="l03682"></a>03682                 }
<a name="l03683"></a>03683                 
<a name="l03684"></a>03684                 <span class="comment">/* If this constant points into a non-executable data segment, then make the pointer relative to that data</span>
<a name="l03685"></a>03685 <span class="comment">                 * segment. */</span>
<a name="l03686"></a>03686                 <a class="code" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *section = <a class="code" href="classSgAsmGenericFile.html#9a65609d2960d613ffff8257e73a7e52">SgAsmGenericFile::best_section_by_va</a>(mapped_sections, ival-&gt;<a class="code" href="classSgAsmIntegerValueExpression.html#6f34176790d22016a331452ef071bb12">get_absolute_value</a>());
<a name="l03687"></a>03687                 <span class="keywordflow">if</span> (section &amp;&amp; !section-&gt;<a class="code" href="classSgAsmGenericSection.html#a7213f04087f77affd6b85ef55dfc864">get_mapped_xperm</a>()) {
<a name="l03688"></a>03688                     ival-&gt;<a class="code" href="classSgAsmIntegerValueExpression.html#b0e0e47f36d6ff9077fe8a54f6c7fede">make_relative_to</a>(section);
<a name="l03689"></a>03689                     <span class="keywordflow">return</span>;
<a name="l03690"></a>03690                 }
<a name="l03691"></a>03691             }
<a name="l03692"></a>03692         }
<a name="l03693"></a>03693 
<a name="l03694"></a>03694         <span class="keywordtype">void</span> postOrderVisit(<a class="code" href="classSgNode.html">SgNode</a> *node) {
<a name="l03695"></a>03695             <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#9c2b4ede732f01bb1ce72270e0ee68da">isSgAsmInstruction</a>(node))
<a name="l03696"></a>03696                 insn = NULL;
<a name="l03697"></a>03697         }
<a name="l03698"></a>03698     };
<a name="l03699"></a>03699 
<a name="l03700"></a>03700     FixerUpper(<span class="keyword">this</span>, interp).traverse(ast);
<a name="l03701"></a>03701 }
<a name="l03702"></a>03702 
<a name="l03703"></a>03703 <span class="comment">/* Build the global block containing all functions. */</span>
<a name="l03704"></a>03704 <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *
<a name="l03705"></a><a class="code" href="classPartitioner.html#d94b1f74e750728b71d1726330786506">03705</a> <a class="code" href="classPartitioner.html#d94b1f74e750728b71d1726330786506">Partitioner::build_ast</a>(<a class="code" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *interp<span class="comment">/*=NULL*/</span>)
<a name="l03706"></a>03706 {
<a name="l03707"></a>03707     <span class="comment">/* Build a function to hold all the unassigned instructions.  Update documentation if changing the name of</span>
<a name="l03708"></a>03708 <span class="comment">     * this generated function!  We do this by traversing the instructions and obtaining a basic block for each one.  If the</span>
<a name="l03709"></a>03709 <span class="comment">     * basic block doesn't belong to a function yet, we add it to this special one.  Note that we cannot traverse the list of</span>
<a name="l03710"></a>03710 <span class="comment">     * instructions directly because creating the basic block might cause additional instructions to be created.</span>
<a name="l03711"></a>03711 <span class="comment">     *</span>
<a name="l03712"></a>03712 <span class="comment">     * Do not include the instruction in the leftovers functions if that instruction is completely overlapped by the bytes of</span>
<a name="l03713"></a>03713 <span class="comment">     * an existing, non-leftovers function. */</span>
<a name="l03714"></a>03714     <a class="code" href="classPartitioner_1_1Function.html">Function</a> *catchall = NULL;
<a name="l03715"></a>03715     <span class="keywordflow">if</span> ((<a class="code" href="classPartitioner.html#61a820e23e3d57c012d0928aa9c4d1a2">func_heuristics</a> &amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c617301fe6a598b9c4afbde0aebcc8ad5">SgAsmFunction::FUNC_LEFTOVERS</a>)) {
<a name="l03716"></a>03716 
<a name="l03717"></a>03717         <span class="comment">/* List of all bytes occupied by functions. */</span>
<a name="l03718"></a>03718         <a class="code" href="classRangeMap.html">FunctionRangeMap</a> existing;
<a name="l03719"></a>03719         <a class="code" href="classPartitioner.html#3a1386d81012e94a46184c4703fd9e40">function_extent</a>(&amp;existing);
<a name="l03720"></a>03720 
<a name="l03721"></a>03721         <span class="comment">/* Repeatedly add unassigned instructions to the leftovers function. */</span>
<a name="l03722"></a>03722         <span class="keywordtype">bool</span> process_instructions;
<a name="l03723"></a>03723         <span class="keywordflow">do</span> {
<a name="l03724"></a>03724             process_instructions = <span class="keyword">false</span>;
<a name="l03725"></a>03725             <a class="code" href="classPartitioner.html#cff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a> insns_copy = insns;
<a name="l03726"></a>03726             <span class="keywordflow">for</span> (InstructionMap::iterator ii=insns_copy.begin(); ii!=insns_copy.end(); ++ii) {
<a name="l03727"></a>03727                 <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va = ii-&gt;first;
<a name="l03728"></a>03728                 size_t size = ii-&gt;second-&gt;get_size();
<a name="l03729"></a>03729                 <span class="keywordflow">if</span> (!existing.<a class="code" href="classRangeMap.html#cb7a2bd99750f3b48f7667d5f01fe083">contains</a>(<a class="code" href="classRange.html">Extent</a>(va, size))) {
<a name="l03730"></a>03730                     <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb = <a class="code" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">find_bb_containing</a>(ii-&gt;first);
<a name="l03731"></a>03731                     assert(bb!=NULL);
<a name="l03732"></a>03732                     <span class="keywordflow">if</span> (!bb-&gt;function) {
<a name="l03733"></a>03733                         <span class="keywordflow">if</span> (!catchall)
<a name="l03734"></a>03734                             catchall = <a class="code" href="classPartitioner.html#91e9b8ad59e4657d6f3dbece95752a4e">add_function</a>(ii-&gt;first, SgAsmFunction::FUNC_LEFTOVERS, <span class="stringliteral">"***uncategorized blocks***"</span>);
<a name="l03735"></a>03735                         <a class="code" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">append</a>(catchall, bb, <a class="code" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48c7545b24fc1b6a1b274ed67a17e074707">SgAsmBlock::BLK_LEFTOVERS</a>);
<a name="l03736"></a>03736                         process_instructions = <span class="keyword">true</span>;
<a name="l03737"></a>03737                     }
<a name="l03738"></a>03738                 }
<a name="l03739"></a>03739             }
<a name="l03740"></a>03740         } <span class="keywordflow">while</span> (process_instructions);
<a name="l03741"></a>03741     }
<a name="l03742"></a>03742 
<a name="l03743"></a>03743     <span class="comment">/* Build the AST */</span>
<a name="l03744"></a>03744     <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *retval = <span class="keyword">new</span> <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a>;
<a name="l03745"></a>03745     <span class="keywordflow">for</span> (Functions::const_iterator fi=<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.begin(); fi!=<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.end(); ++fi) {
<a name="l03746"></a>03746         <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *func_decl = <a class="code" href="classPartitioner.html#d94b1f74e750728b71d1726330786506">build_ast</a>(fi-&gt;second);
<a name="l03747"></a>03747         <span class="keywordflow">if</span> (!func_decl) <span class="keywordflow">continue</span>;
<a name="l03748"></a>03748         retval-&gt;<a class="code" href="classSgAsmBlock.html#c19627b98d9cee481b9c533ad21ac755">get_statementList</a>().push_back(func_decl);
<a name="l03749"></a>03749         func_decl-&gt;set_parent(retval);
<a name="l03750"></a>03750     }
<a name="l03751"></a>03751 
<a name="l03752"></a>03752     <span class="comment">/* Return catchall blocks to the free pool */</span>
<a name="l03753"></a>03753     <span class="keywordflow">if</span> (catchall) {
<a name="l03754"></a>03754         catchall-&gt;<a class="code" href="classPartitioner_1_1Function.html#ebb899dee2d38549d338e2ed9a11c63b">clear_basic_blocks</a>();
<a name="l03755"></a>03755         catchall-&gt;<a class="code" href="classPartitioner_1_1Function.html#49652421fa901651e9f1269369e2990c">clear_data_blocks</a>();
<a name="l03756"></a>03756         <a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.erase(catchall-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>);
<a name="l03757"></a>03757         <span class="keyword">delete</span> catchall;
<a name="l03758"></a>03758     }
<a name="l03759"></a>03759 
<a name="l03760"></a>03760     <span class="comment">/* Make pointers relative to the thing into which they point. */</span>
<a name="l03761"></a>03761     <a class="code" href="classPartitioner.html#416452ab2d4ffc7df788c078421c4848">fixup_cfg_edges</a>(retval);
<a name="l03762"></a>03762     <a class="code" href="classPartitioner.html#ea4ea9a5b5238c91b86b226fb04708c1">fixup_pointers</a>(retval, interp);
<a name="l03763"></a>03763     <span class="keywordflow">return</span> retval;
<a name="l03764"></a>03764 }
<a name="l03765"></a>03765 
<a name="l03766"></a>03766 <span class="comment">/* Build a function node containing all basic blocks and data blocks of the function. */</span>
<a name="l03767"></a>03767 <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *
<a name="l03768"></a><a class="code" href="classPartitioner.html#2f7da41ef6f3e3d1e11146ecc4c75a61">03768</a> <a class="code" href="classPartitioner.html#d94b1f74e750728b71d1726330786506">Partitioner::build_ast</a>(<a class="code" href="classPartitioner_1_1Function.html">Function</a>* f)
<a name="l03769"></a>03769 {
<a name="l03770"></a>03770     <span class="keywordflow">if</span> (f-&gt;<a class="code" href="classPartitioner_1_1Function.html#8bdb95ca10afda44f8dacb28248f5c6c">basic_blocks</a>.empty()) {
<a name="l03771"></a>03771         <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>)
<a name="l03772"></a>03772             fprintf(debug, <span class="stringliteral">"function F%08"</span>PRIx64<span class="stringliteral">" \"%s\" has no basic blocks!\n"</span>, f-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>, f-&gt;<a class="code" href="classPartitioner_1_1Function.html#3445a927f772aa09859896fa5681eb62">name</a>.c_str());
<a name="l03773"></a>03773         <span class="keywordflow">return</span> NULL;
<a name="l03774"></a>03774     }
<a name="l03775"></a>03775 
<a name="l03776"></a>03776     <span class="comment">/* Get the list of basic blocks and data blocks.  We'll want them to be added to the function in order of their starting</span>
<a name="l03777"></a>03777 <span class="comment">     * address, with basic blocks and data blocks interleaved. */</span>
<a name="l03778"></a>03778     <span class="keyword">typedef</span> std::multimap&lt;rose_addr_t, SgAsmStatement*&gt; NodeMap;
<a name="l03779"></a>03779     std::set&lt;DataBlock*&gt; my_data_blocks;
<a name="l03780"></a>03780     NodeMap nodes;
<a name="l03781"></a>03781     <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *first_basic_block = NULL;
<a name="l03782"></a>03782     <span class="keywordflow">for</span> (BasicBlocks::iterator bi=f-&gt;<a class="code" href="classPartitioner_1_1Function.html#8bdb95ca10afda44f8dacb28248f5c6c">basic_blocks</a>.begin(); bi!=f-&gt;<a class="code" href="classPartitioner_1_1Function.html#8bdb95ca10afda44f8dacb28248f5c6c">basic_blocks</a>.end(); ++bi) {
<a name="l03783"></a>03783         <a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bblock = bi-&gt;second;
<a name="l03784"></a>03784         if (!first_basic_block)
<a name="l03785"></a>03785             first_basic_block = bblock;
<a name="l03786"></a>03786 
<a name="l03787"></a>03787         <span class="comment">/* The instructions for this basic block */</span>
<a name="l03788"></a>03788         <a class="code" href="classSgAsmStatement.html">SgAsmStatement</a> *node = <a class="code" href="classPartitioner.html#d94b1f74e750728b71d1726330786506">build_ast</a>(bblock);
<a name="l03789"></a>03789         nodes.insert(std::make_pair(bblock-&gt;address(), node));
<a name="l03790"></a>03790 
<a name="l03791"></a>03791         <span class="comment">/* The data associated with this basic block */</span>
<a name="l03792"></a>03792         <span class="keywordflow">for</span> (std::set&lt;DataBlock*&gt;::iterator di=bblock-&gt;data_blocks.begin(); di!=bblock-&gt;data_blocks.end(); ++di) {
<a name="l03793"></a>03793             <a class="code" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *dblock = *di;
<a name="l03794"></a>03794             <a class="code" href="classPartitioner_1_1Function.html">Function</a> *dblock_func = <a class="code" href="classPartitioner.html#cd1de02179852d54139e2f4eb366ebdc">effective_function</a>(dblock);
<a name="l03795"></a>03795             <span class="keywordflow">if</span> (dblock_func==f)
<a name="l03796"></a>03796                 my_data_blocks.insert(dblock);
<a name="l03797"></a>03797         }
<a name="l03798"></a>03798     }
<a name="l03799"></a>03799 
<a name="l03800"></a>03800     <span class="keywordflow">for</span> (DataBlocks::iterator di=f-&gt;<a class="code" href="classPartitioner_1_1Function.html#a4ec341f0aa8ef699a36dda8389036d8">data_blocks</a>.begin(); di!=f-&gt;<a class="code" href="classPartitioner_1_1Function.html#a4ec341f0aa8ef699a36dda8389036d8">data_blocks</a>.end(); ++di) {
<a name="l03801"></a>03801         <a class="code" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *dblock = di-&gt;second;
<a name="l03802"></a>03802         assert(dblock-&gt;function==f);
<a name="l03803"></a>03803         my_data_blocks.insert(dblock);
<a name="l03804"></a>03804     }
<a name="l03805"></a>03805 
<a name="l03806"></a>03806     <span class="keywordflow">for</span> (std::set&lt;DataBlock*&gt;::iterator di=my_data_blocks.begin(); di!=my_data_blocks.end(); ++di) {
<a name="l03807"></a>03807         <a class="code" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *dblock = *di;
<a name="l03808"></a>03808         <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *ast_block = <a class="code" href="classPartitioner.html#d94b1f74e750728b71d1726330786506">build_ast</a>(dblock);
<a name="l03809"></a>03809         nodes.insert(std::make_pair(dblock-&gt;address(), ast_block));
<a name="l03810"></a>03810     }
<a name="l03811"></a>03811 
<a name="l03812"></a>03812     <span class="comment">/* Create the AST function node. */</span>
<a name="l03813"></a>03813     <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *retval = <span class="keyword">new</span> <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a>;
<a name="l03814"></a>03814     retval-&gt;<a class="code" href="classSgAsmFunction.html#22eb36588afcbeff004768b4598f8aed">set_entry_va</a>(f-&gt;<a class="code" href="classPartitioner_1_1Function.html#f9e0fcf754bb14416253d5b873f25cd1">entry_va</a>);
<a name="l03815"></a>03815     retval-&gt;<a class="code" href="classSgAsmFunction.html#91f84d1eb4822282467425d403c6e99c">set_name</a>(f-&gt;<a class="code" href="classPartitioner_1_1Function.html#3445a927f772aa09859896fa5681eb62">name</a>);
<a name="l03816"></a>03816     retval-&gt;<a class="code" href="classSgAsmStatement.html#628c9fd41d1b6d1cfcd94cddc0b117bb">set_address</a>(first_basic_block-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#7e120c89ba03d66a308381c0b82173c9">address</a>());
<a name="l03817"></a>03817 
<a name="l03818"></a>03818     <span class="comment">/* Set the SgAsmFunction::can_return property.  If we've never indicated that a function might return then assume it</span>
<a name="l03819"></a>03819 <span class="comment">     * doesn't return.  We're all done with analysis now, so it must not return. */</span>
<a name="l03820"></a>03820     <span class="keywordflow">if</span> (<a class="code" href="classSgAsmFunction.html#d1e0c37f9e507fc6acaf01dd0794a7520d3fbe8fb9b711a6ca66ef2f09824496">SgAsmFunction::RET_UNKNOWN</a>==f-&gt;<a class="code" href="classPartitioner_1_1Function.html#cca110ab4755cb256c8d5e1c338dea7f">get_may_return</a>()) {
<a name="l03821"></a>03821         retval-&gt;<a class="code" href="classSgAsmFunction.html#e30a4cf2e729eaf2f5e1599e85e5b722">set_may_return</a>(<a class="code" href="classSgAsmFunction.html#d1e0c37f9e507fc6acaf01dd0794a752df440ebe371c3f4fdc1612448157f6bc">SgAsmFunction::RET_NEVER</a>);
<a name="l03822"></a>03822     } <span class="keywordflow">else</span> {
<a name="l03823"></a>03823         retval-&gt;<a class="code" href="classSgAsmFunction.html#e30a4cf2e729eaf2f5e1599e85e5b722">set_may_return</a>(f-&gt;<a class="code" href="classPartitioner_1_1Function.html#cca110ab4755cb256c8d5e1c338dea7f">get_may_return</a>());
<a name="l03824"></a>03824     }
<a name="l03825"></a>03825 
<a name="l03826"></a>03826     <span class="keywordflow">for</span> (NodeMap::iterator ni=nodes.begin(); ni!=nodes.end(); ++ni) {
<a name="l03827"></a>03827         retval-&gt;<a class="code" href="classSgAsmFunction.html#08fe036249766f5c7bca4403851f9cab">get_statementList</a>().push_back(ni-&gt;second);
<a name="l03828"></a>03828         ni-&gt;second-&gt;set_parent(retval);
<a name="l03829"></a>03829     }
<a name="l03830"></a>03830 
<a name="l03831"></a>03831     <span class="keywordtype">unsigned</span> reasons = f-&gt;<a class="code" href="classPartitioner_1_1Function.html#84232118f03482d3eb09c76063ef73ef">reason</a>;
<a name="l03832"></a>03832     <span class="keywordflow">if</span> (0==(reasons &amp; <a class="code" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cb8251be92d0c4b04f5da036ebeef5bc5">SgAsmFunction::FUNC_DISCONT</a>)) {
<a name="l03833"></a>03833         <a class="code" href="classRangeMap.html">FunctionRangeMap</a> extent;
<a name="l03834"></a>03834         <a class="code" href="classPartitioner.html#3a1386d81012e94a46184c4703fd9e40">function_extent</a>(f, &amp;extent);
<a name="l03835"></a>03835         <span class="keywordflow">if</span> (extent.<a class="code" href="classRangeMap.html#ffe28d68866b20d3510f312ab1ed91a2">nranges</a>()&gt;1)
<a name="l03836"></a>03836             reasons |= SgAsmFunction::FUNC_DISCONT;
<a name="l03837"></a>03837     }
<a name="l03838"></a>03838     retval-&gt;<a class="code" href="classSgAsmFunction.html#90c5ce34a89fd36621a3b80ffacfb3fc">set_reason</a>(reasons);
<a name="l03839"></a>03839     <span class="keywordflow">return</span> retval;
<a name="l03840"></a>03840 }
<a name="l03841"></a>03841 
<a name="l03842"></a>03842 <span class="comment">/* Build a basic block node containing all instructions for the basic block. */</span>
<a name="l03843"></a>03843 <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *
<a name="l03844"></a><a class="code" href="classPartitioner.html#ed7ad33de4977b27a12453e6c37b8288">03844</a> <a class="code" href="classPartitioner.html#d94b1f74e750728b71d1726330786506">Partitioner::build_ast</a>(<a class="code" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a>* block)
<a name="l03845"></a>03845 {
<a name="l03846"></a>03846     <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *retval = <span class="keyword">new</span> <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a>;
<a name="l03847"></a>03847     retval-&gt;<a class="code" href="classSgAsmBlock.html#49da239fdc05d676519696e3e94370a5">set_id</a>(block-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#7e120c89ba03d66a308381c0b82173c9">address</a>());
<a name="l03848"></a>03848     retval-&gt;<a class="code" href="classSgAsmStatement.html#628c9fd41d1b6d1cfcd94cddc0b117bb">set_address</a>(block-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#7e120c89ba03d66a308381c0b82173c9">address</a>());
<a name="l03849"></a>03849     retval-&gt;<a class="code" href="classSgAsmBlock.html#b18c973e10efc4c6dd6d47990edb779a">set_reason</a>(block-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#601ae03fbe778f2497dea0e5a3493cf9">reason</a>);
<a name="l03850"></a>03850     retval-&gt;<a class="code" href="classSgAsmBlock.html#fa70ebec2668c1614e76b742587f1e22">set_code_likelihood</a>(block-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#d526588712ffd4ec7ca739fd7979130d">code_likelihood</a>);
<a name="l03851"></a>03851 
<a name="l03852"></a>03852     <span class="keywordflow">for</span> (InstructionVector::const_iterator ii=block-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.begin(); ii!=block-&gt;<a class="code" href="structPartitioner_1_1BasicBlock.html#2101ed1bd314a6279a3f07c04d5e0a2e">insns</a>.end(); ++ii) {
<a name="l03853"></a>03853         <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a> *insn = *ii;
<a name="l03854"></a>03854         retval-&gt;<a class="code" href="classSgAsmBlock.html#c19627b98d9cee481b9c533ad21ac755">get_statementList</a>().push_back(insn-&gt;node);
<a name="l03855"></a>03855         insn-&gt;node-&gt;<a class="code" href="classSgNode.html#83017efa378d75b031330739c963749d">set_parent</a>(retval);
<a name="l03856"></a>03856     }
<a name="l03857"></a>03857 
<a name="l03858"></a>03858     <span class="comment">/* Cache block successors so other layers don't have to constantly compute them.  We fill in the successor</span>
<a name="l03859"></a>03859 <span class="comment">     * SgAsmIntegerValueExpression objects with only the address and not pointers to blocks since we don't have all the blocks</span>
<a name="l03860"></a>03860 <span class="comment">     * yet.  The pointers will be initialized in the no-argument version build_ast() higher up on the stack. */</span>
<a name="l03861"></a>03861     <span class="keywordtype">bool</span> complete;
<a name="l03862"></a>03862     <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> successor_addrs = <a class="code" href="classPartitioner.html#e2e3e09e5194ba8c87bc968b65b63e3c">successors</a>(block, &amp;complete);
<a name="l03863"></a>03863     <span class="keywordflow">for</span> (Disassembler::AddressSet::iterator si=successor_addrs.begin(); si!=successor_addrs.end(); ++si) {
<a name="l03864"></a>03864         <a class="code" href="classSgAsmIntegerValueExpression.html">SgAsmIntegerValueExpression</a> *value = <span class="keyword">new</span> <a class="code" href="classSgAsmIntegerValueExpression.html">SgAsmIntegerValueExpression</a>(*si);
<a name="l03865"></a>03865         value-&gt;set_parent(retval);
<a name="l03866"></a>03866         retval-&gt;<a class="code" href="classSgAsmBlock.html#0e798d793c22e6d6a63a526b6a18e7ce">get_successors</a>().push_back(value);
<a name="l03867"></a>03867     }
<a name="l03868"></a>03868     retval-&gt;<a class="code" href="classSgAsmBlock.html#5bc8828b73e2e1695e336a618ca3213b">set_successors_complete</a>(complete);
<a name="l03869"></a>03869     <span class="keywordflow">return</span> retval;
<a name="l03870"></a>03870 }
<a name="l03871"></a>03871 
<a name="l03872"></a>03872 <span class="comment">/* Buid a data block node for each data block. */</span>
<a name="l03873"></a>03873 <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *
<a name="l03874"></a><a class="code" href="classPartitioner.html#ca294bc7e7ed85d40465d7d7c346bd49">03874</a> <a class="code" href="classPartitioner.html#d94b1f74e750728b71d1726330786506">Partitioner::build_ast</a>(<a class="code" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *block)
<a name="l03875"></a>03875 {
<a name="l03876"></a>03876     <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *retval = <span class="keyword">new</span> <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a>;
<a name="l03877"></a>03877     retval-&gt;<a class="code" href="classSgAsmBlock.html#49da239fdc05d676519696e3e94370a5">set_id</a>(block-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#30602458b400eee36e9c7b1298797250">address</a>());
<a name="l03878"></a>03878     retval-&gt;<a class="code" href="classSgAsmStatement.html#628c9fd41d1b6d1cfcd94cddc0b117bb">set_address</a>(block-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#30602458b400eee36e9c7b1298797250">address</a>());
<a name="l03879"></a>03879     retval-&gt;<a class="code" href="classSgAsmBlock.html#b18c973e10efc4c6dd6d47990edb779a">set_reason</a>(block-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#024f1606c04323776f0958542e451ac2">reason</a>);
<a name="l03880"></a>03880 
<a name="l03881"></a>03881     <span class="keywordflow">for</span> (std::vector&lt;SgAsmStaticData*&gt;::const_iterator ni=block-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#fdc2bd13ec3bc86896eebb7ac65fcd08">nodes</a>.begin(); ni!=block-&gt;<a class="code" href="structPartitioner_1_1DataBlock.html#fdc2bd13ec3bc86896eebb7ac65fcd08">nodes</a>.end(); ++ni) {
<a name="l03882"></a>03882         retval-&gt;<a class="code" href="classSgAsmBlock.html#c19627b98d9cee481b9c533ad21ac755">get_statementList</a>().push_back(*ni);
<a name="l03883"></a>03883         assert(NULL==(*ni)-&gt;get_parent());
<a name="l03884"></a>03884         (*ni)-&gt;set_parent(retval);
<a name="l03885"></a>03885     }
<a name="l03886"></a>03886     <span class="keywordflow">return</span> retval;
<a name="l03887"></a>03887 }
<a name="l03888"></a>03888 
<a name="l03889"></a>03889 <span class="comment">/* Top-level function to run the partitioner in passive mode. */</span>
<a name="l03890"></a>03890 <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *
<a name="l03891"></a><a class="code" href="classPartitioner.html#d8d4292001cbf0490676f8bc148c1a24">03891</a> <a class="code" href="classPartitioner.html#d8d4292001cbf0490676f8bc148c1a24">Partitioner::partition</a>(<a class="code" href="classSgAsmInterpretation.html">SgAsmInterpretation</a>* interp<span class="comment">/*=NULL*/</span>, <span class="keyword">const</span> <a class="code" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">Disassembler::InstructionMap</a>&amp; insns, <a class="code" href="classMemoryMap.html">MemoryMap</a> *map)
<a name="l03892"></a>03892 {
<a name="l03893"></a>03893     <a class="code" href="classPartitioner.html#320e02804f0d9ae5bc55e1ba26791a72">disassembler</a> = NULL;
<a name="l03894"></a>03894     <a class="code" href="classPartitioner.html#33a895f0f8724262d24404a67be98a2f">add_instructions</a>(insns);
<a name="l03895"></a>03895 
<a name="l03896"></a>03896     <a class="code" href="classMemoryMap.html">MemoryMap</a> *old_map = <a class="code" href="classPartitioner.html#697de2be7e07894883304357a546438b">get_map</a>();
<a name="l03897"></a>03897     <a class="code" href="classMemoryMap.html">MemoryMap</a> old_ro_map = <a class="code" href="classPartitioner.html#0b160d2ed1a5b32606e0deaf4c8cbb43">ro_map</a>;
<a name="l03898"></a>03898     <span class="keywordflow">if</span> (!<a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a> &amp;&amp; !old_map)
<a name="l03899"></a>03899         <span class="keywordflow">throw</span> <a class="code" href="structPartitioner_1_1Exception.html">Exception</a>(<span class="stringliteral">"no memory map"</span>);
<a name="l03900"></a>03900     <span class="keywordflow">if</span> (<a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>)
<a name="l03901"></a>03901         <a class="code" href="classPartitioner.html#3c46fdd567c72ad245ab7e2e6351a9d8">set_map</a>(<a class="code" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a>);
<a name="l03902"></a>03902 
<a name="l03903"></a>03903     <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *retval = NULL;
<a name="l03904"></a>03904     <span class="keywordflow">try</span> {
<a name="l03905"></a>03905         <a class="code" href="classPartitioner.html#815304b7ef093a74bc419662d54df49b">pre_cfg</a>(interp);
<a name="l03906"></a>03906         <a class="code" href="classPartitioner.html#19725656eaa83118d75bdd77c617cef4">analyze_cfg</a>(<a class="code" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48ce4246f5b8a05009b72d727573c3f9a28">SgAsmBlock::BLK_GRAPH1</a>);
<a name="l03907"></a>03907         <a class="code" href="classPartitioner.html#48a2e4d8bd6d15fb31a0ae8e41a747a3">post_cfg</a>(interp);
<a name="l03908"></a>03908         retval = <a class="code" href="classPartitioner.html#d94b1f74e750728b71d1726330786506">build_ast</a>(interp);
<a name="l03909"></a>03909         <a class="code" href="classPartitioner.html#3c46fdd567c72ad245ab7e2e6351a9d8">set_map</a>(old_map, &amp;old_ro_map);
<a name="l03910"></a>03910     } <span class="keywordflow">catch</span> (...) {
<a name="l03911"></a>03911         <a class="code" href="classPartitioner.html#3c46fdd567c72ad245ab7e2e6351a9d8">set_map</a>(old_map, &amp;old_ro_map);
<a name="l03912"></a>03912         <span class="keywordflow">throw</span>;
<a name="l03913"></a>03913     }
<a name="l03914"></a>03914 
<a name="l03915"></a>03915     <span class="keywordflow">return</span> retval;
<a name="l03916"></a>03916 }
<a name="l03917"></a>03917 
<a name="l03918"></a>03918 <span class="comment">/* Top-level function to run the partitioner in active mode. */</span>
<a name="l03919"></a>03919 <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *
<a name="l03920"></a><a class="code" href="classPartitioner.html#ec5dbc10e96f8e3d26f58294945c2f9d">03920</a> <a class="code" href="classPartitioner.html#d8d4292001cbf0490676f8bc148c1a24">Partitioner::partition</a>(<a class="code" href="classSgAsmInterpretation.html">SgAsmInterpretation</a>* interp<span class="comment">/*=NULL*/</span>, <a class="code" href="classDisassembler.html">Disassembler</a> *d, <a class="code" href="classMemoryMap.html">MemoryMap</a> *m)
<a name="l03921"></a>03921 {
<a name="l03922"></a>03922     assert(d!=NULL);
<a name="l03923"></a>03923     <a class="code" href="classPartitioner.html#320e02804f0d9ae5bc55e1ba26791a72">disassembler</a> = d;
<a name="l03924"></a>03924     assert(m!=NULL);
<a name="l03925"></a>03925     <a class="code" href="classPartitioner.html#3c46fdd567c72ad245ab7e2e6351a9d8">set_map</a>(m);
<a name="l03926"></a>03926     <a class="code" href="classPartitioner.html#815304b7ef093a74bc419662d54df49b">pre_cfg</a>(interp);
<a name="l03927"></a>03927     <a class="code" href="classPartitioner.html#19725656eaa83118d75bdd77c617cef4">analyze_cfg</a>(<a class="code" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48ce4246f5b8a05009b72d727573c3f9a28">SgAsmBlock::BLK_GRAPH1</a>);
<a name="l03928"></a>03928     <a class="code" href="classPartitioner.html#48a2e4d8bd6d15fb31a0ae8e41a747a3">post_cfg</a>(interp);
<a name="l03929"></a>03929     <span class="keywordflow">return</span> <a class="code" href="classPartitioner.html#d94b1f74e750728b71d1726330786506">build_ast</a>(interp);
<a name="l03930"></a>03930 }
<a name="l03931"></a>03931 
<a name="l03932"></a>03932 <span class="keywordtype">void</span>
<a name="l03933"></a><a class="code" href="classPartitioner.html#33a895f0f8724262d24404a67be98a2f">03933</a> <a class="code" href="classPartitioner.html#33a895f0f8724262d24404a67be98a2f">Partitioner::add_instructions</a>(<span class="keyword">const</span> <a class="code" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">Disassembler::InstructionMap</a>&amp; insns)
<a name="l03934"></a>03934 {
<a name="l03935"></a>03935     <span class="keywordflow">for</span> (Disassembler::InstructionMap::const_iterator ii=insns.begin(); ii!=insns.end(); ++ii) {
<a name="l03936"></a>03936         <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a> *insn = <span class="keyword">new</span> <a class="code" href="classPartitioner_1_1Instruction.html">Instruction</a>(ii-&gt;second);
<a name="l03937"></a>03937         this-&gt;insns.insert(std::make_pair(ii-&gt;first, insn));
<a name="l03938"></a>03938     }
<a name="l03939"></a>03939 }
<a name="l03940"></a>03940 
<a name="l03941"></a>03941 <a class="code" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">Disassembler::InstructionMap</a>
<a name="l03942"></a><a class="code" href="classPartitioner.html#45a9d059b28d95033aa343fd4689ac0e">03942</a> <a class="code" href="classPartitioner.html#45a9d059b28d95033aa343fd4689ac0e">Partitioner::get_instructions</a>()<span class="keyword"> const</span>
<a name="l03943"></a>03943 <span class="keyword"></span>{
<a name="l03944"></a>03944     <a class="code" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">Disassembler::InstructionMap</a> retval;
<a name="l03945"></a>03945     <span class="keywordflow">for</span> (InstructionMap::const_iterator ii=insns.begin(); ii!=insns.end(); ++ii) {
<a name="l03946"></a>03946         <a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn = ii-&gt;second-&gt;node;
<a name="l03947"></a>03947         retval.insert(std::make_pair(ii-&gt;first, insn));
<a name="l03948"></a>03948     }
<a name="l03949"></a>03949     <span class="keywordflow">return</span> retval;
<a name="l03950"></a>03950 }
<a name="l03951"></a>03951 
<a name="l03952"></a>03952 <span class="comment">/* FIXME: Deprecated 2010-01-01 */</span>
<a name="l03953"></a>03953 <a class="code" href="classPartitioner.html#9a75d765cbfecc297f7d47063095a3c5">Partitioner::BasicBlockStarts</a>
<a name="l03954"></a><a class="code" href="classPartitioner.html#4812db8f83f8858ae85b382cc3a6acdc">03954</a> <a class="code" href="classPartitioner.html#4812db8f83f8858ae85b382cc3a6acdc">Partitioner::detectBasicBlocks</a>(<span class="keyword">const</span> <a class="code" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">Disassembler::InstructionMap</a> &amp;insns)<span class="keyword"> const</span>
<a name="l03955"></a>03955 <span class="keyword"></span>{
<a name="l03956"></a>03956     <a class="code" href="classPartitioner.html#9a75d765cbfecc297f7d47063095a3c5">BasicBlockStarts</a> bb_starts;
<a name="l03957"></a>03957 
<a name="l03958"></a>03958     <span class="comment">/* The first instruction always starts a basic block. */</span>
<a name="l03959"></a>03959     <span class="keywordflow">if</span> (insns.size()&gt;0) {
<a name="l03960"></a>03960         <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> insn_va = insns.begin()-&gt;first;
<a name="l03961"></a>03961         bb_starts[insn_va] = BasicBlockStarts::mapped_type();
<a name="l03962"></a>03962     }
<a name="l03963"></a>03963 
<a name="l03964"></a>03964     <span class="keywordflow">for</span> (Disassembler::InstructionMap::const_iterator ii=insns.begin(); ii!=insns.end(); ++ii) {
<a name="l03965"></a>03965         <a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn = ii-&gt;second;
<a name="l03966"></a>03966         <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> insn_va = insn-&gt;<a class="code" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>();
<a name="l03967"></a>03967         <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> next_va = insn-&gt;<a class="code" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>() + insn-&gt;<a class="code" href="classSgAsmInstruction.html#6adcc4eb7c725185baa3a2425a57843c">get_size</a>();
<a name="l03968"></a>03968 
<a name="l03969"></a>03969         <span class="comment">/* If this instruction is one which terminates a basic block then make the next instruction (if any) the beginning of</span>
<a name="l03970"></a>03970 <span class="comment">         * a basic block. However, a sequence like the following should not be a basic block boundary because the CALL is</span>
<a name="l03971"></a>03971 <span class="comment">         * acting more like a "PUSH EIP" (we should probably just look at the CALL instruction itself rather than also looking</span>
<a name="l03972"></a>03972 <span class="comment">         * for the following POP, but since ROSE doesn't currently apply the relocation tables before disassembling, the CALL</span>
<a name="l03973"></a>03973 <span class="comment">         * with a zero offset is quite common. [RPM 2009-08-24] */</span>
<a name="l03974"></a>03974         <span class="keywordflow">if</span> (insn-&gt;<a class="code" href="classSgAsmx86Instruction.html#d3f2d2701a70a7f93194befbbe795031">terminatesBasicBlock</a>()) {
<a name="l03975"></a>03975             Disassembler::InstructionMap::const_iterator found = insns.find(next_va);
<a name="l03976"></a>03976             <span class="keywordflow">if</span> (found!=insns.end()) {
<a name="l03977"></a>03977                 <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn_x86 = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(insn);
<a name="l03978"></a>03978                 <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn2_x86 = <a class="code" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a>(found-&gt;second);
<a name="l03979"></a>03979                 <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> branch_target_va;
<a name="l03980"></a>03980                 <span class="keywordflow">if</span> (insn_x86 &amp;&amp;
<a name="l03981"></a>03981                     (insn_x86-&gt;get_kind()==<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571221e4d163bb7557e57e351140aa7855e">x86_call</a> || insn_x86-&gt;get_kind()==<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca55714edb34feaf8cb03afb49361a9a0b26c4">x86_farcall</a>) &amp;&amp;
<a name="l03982"></a>03982                     x86GetKnownBranchTarget(insn_x86, branch_target_va) &amp;&amp;
<a name="l03983"></a>03983                     branch_target_va==next_va &amp;&amp; insn2_x86-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()==<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571c3721979ec7e0215f81e281e07f66229">x86_pop</a>) {
<a name="l03984"></a>03984                     <span class="comment">/* The CALL is acting more like a "PUSH EIP" and should not end the basic block. */</span>
<a name="l03985"></a>03985                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bb_starts.find(next_va)==bb_starts.end()) {
<a name="l03986"></a>03986                     bb_starts[next_va] = BasicBlockStarts::mapped_type();
<a name="l03987"></a>03987                 }
<a name="l03988"></a>03988             }
<a name="l03989"></a>03989         }
<a name="l03990"></a>03990 
<a name="l03991"></a>03991         <span class="comment">/* If this instruction has multiple known successors then make each of those successors the beginning of a basic</span>
<a name="l03992"></a>03992 <span class="comment">         * block (provided there's an instruction at that address). However, if there's only one successor and it's the</span>
<a name="l03993"></a>03993 <span class="comment">         * fall-through address then ignore it. */</span>
<a name="l03994"></a>03994         <span class="keywordtype">bool</span> complete;
<a name="l03995"></a>03995         <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> <a class="code" href="classPartitioner.html#e2e3e09e5194ba8c87bc968b65b63e3c">successors</a> = insn-&gt;<a class="code" href="classSgAsmx86Instruction.html#e43b0ae94f1e860f93fd9a17300a6ef5">get_successors</a>(&amp;complete);
<a name="l03996"></a>03996         <span class="keywordflow">for</span> (Disassembler::AddressSet::const_iterator si=successors.begin(); si!=successors.end(); ++si) {
<a name="l03997"></a>03997             <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> successor_va = *si;
<a name="l03998"></a>03998             <span class="keywordflow">if</span> ((successor_va != next_va || successors.size()&gt;1) &amp;&amp; insns.find(successor_va)!=insns.end())
<a name="l03999"></a>03999                 bb_starts[successor_va].insert(insn_va);
<a name="l04000"></a>04000         }
<a name="l04001"></a>04001     }
<a name="l04002"></a>04002     <span class="keywordflow">return</span> bb_starts;
<a name="l04003"></a>04003 }
<a name="l04004"></a>04004 
<a name="l04005"></a>04005 <span class="comment">/* FIXME: Deprecated 2010-01-01 */</span>
<a name="l04006"></a>04006 <a class="code" href="classPartitioner.html#b8bf5254df78bd41a374776dc956c0b0">Partitioner::FunctionStarts</a>
<a name="l04007"></a><a class="code" href="classPartitioner.html#2661469599426a48867a62e649c3585b">04007</a> <a class="code" href="classPartitioner.html#2661469599426a48867a62e649c3585b">Partitioner::detectFunctions</a>(<a class="code" href="classSgAsmInterpretation.html">SgAsmInterpretation</a>*, <span class="keyword">const</span> <a class="code" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">Disassembler::InstructionMap</a> &amp;insns,
<a name="l04008"></a>04008                              <a class="code" href="classPartitioner.html#9a75d765cbfecc297f7d47063095a3c5">BasicBlockStarts</a> &amp;bb_starts<span class="comment">/*out*/</span>)<span class="keyword"> const</span>
<a name="l04009"></a>04009 <span class="keyword"></span>{
<a name="l04010"></a>04010     <a class="code" href="classPartitioner.html#b8bf5254df78bd41a374776dc956c0b0">FunctionStarts</a> retval;
<a name="l04011"></a>04011     <span class="keywordflow">for</span> (Functions::const_iterator fi=<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.begin(); fi!=<a class="code" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a>.end(); ++fi)
<a name="l04012"></a>04012         retval.insert(std::make_pair(fi-&gt;first, <a class="code" href="structPartitioner_1_1FunctionStart.html">FunctionStart</a>(fi-&gt;second-&gt;reason, fi-&gt;second-&gt;name)));
<a name="l04013"></a>04013     <span class="keywordflow">return</span> retval;
<a name="l04014"></a>04014 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
