<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: sageInterface.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>sageInterface.h</h1><a href="sageInterface_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef ROSE_SAGE_INTERFACE</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define ROSE_SAGE_INTERFACE</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="preprocessor">#include "sage3basic.hhh"</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &lt;stdint.h&gt;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;utility&gt;</span>
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 <span class="preprocessor">#if 0   // FMZ(07/07/2010): the argument "nextErrorCode" should be call-by-reference</span>
<a name="l00009"></a>00009 <span class="preprocessor"></span><a class="code" href="classSgFile.html">SgFile</a>* <a class="code" href="sageInterface_8h.html#335d6f76b9197fefa4d538cd26675c37">determineFileType</a> ( std::vector&lt;std::string&gt; argv, <span class="keywordtype">int</span> nextErrorCode, <a class="code" href="classSgProject.html">SgProject</a>* <a class="code" href="namespacecfgUtils.html#ce4abf2beca5826144d69d3a0283050f">project</a> );
<a name="l00010"></a>00010 <span class="preprocessor">#else</span>
<a name="l00011"></a>00011 <span class="preprocessor"></span><a class="code" href="classSgFile.html">SgFile</a>* <a class="code" href="sageInterface_8h.html#335d6f76b9197fefa4d538cd26675c37">determineFileType</a> ( std::vector&lt;std::string&gt; argv, <span class="keywordtype">int</span>&amp; nextErrorCode, <a class="code" href="classSgProject.html">SgProject</a>* <a class="code" href="namespacecfgUtils.html#ce4abf2beca5826144d69d3a0283050f">project</a> );
<a name="l00012"></a>00012 <span class="preprocessor">#endif</span>
<a name="l00013"></a>00013 <span class="preprocessor"></span>
<a name="l00014"></a>00014 <span class="preprocessor">#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</span>
<a name="l00015"></a>00015 <span class="preprocessor"></span><span class="preprocessor">#include "rewrite.h"</span>
<a name="l00016"></a>00016 <span class="preprocessor">#endif</span>
<a name="l00017"></a>00017 <span class="preprocessor"></span>
<a name="l00018"></a>00018 <span class="comment">// DQ (7/20/2008): Added support for unparsing abitrary strings in the unparser.</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include "astUnparseAttribute.h"</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;set&gt;</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span><span class="preprocessor">#include "LivenessAnalysis.h"</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include "abstract_handle.h"</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include "<a class="code" href="ClassHierarchyGraph_8h.html">ClassHierarchyGraph.h</a>"</span>
<a name="l00026"></a>00026 <span class="preprocessor">#endif</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span>
<a name="l00028"></a>00028 <span class="comment">// DQ (8/19/2004): Moved from ROSE/src/midend/astRewriteMechanism/rewrite.h</span>
<a name="l00030"></a>00030 <span class="comment"></span>std::string <a class="code" href="sageInterface_8h.html#6d0cd96704022f21e971666b81840682">getVariantName</a> (<a class="code" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a> v);
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="comment">// DQ (12/9/2004): Qing, Rich and Dan have decided to start this namespace within ROSE</span>
<a name="l00033"></a>00033 <span class="comment">// This namespace is specific to interface functions that operate on the Sage III AST.</span>
<a name="l00034"></a>00034 <span class="comment">// The name was chosen so as not to conflict with other classes within ROSE.</span>
<a name="l00035"></a>00035 <span class="comment">// This will become the future home of many interface functions which operate on</span>
<a name="l00036"></a>00036 <span class="comment">// the AST and which are generally useful to users.  As a namespace multiple files can be used</span>
<a name="l00037"></a>00037 <span class="comment">// to represent the compete interface and different developers may contribute interface</span>
<a name="l00038"></a>00038 <span class="comment">// functions easily.</span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="comment">// Constructor handling: (We have sageBuilder.h now for this purpose, Liao 2/1/2008)</span>
<a name="l00041"></a>00041 <span class="comment">//     We could add simpler layers of support for construction of IR nodes by</span>
<a name="l00042"></a>00042 <span class="comment">// hiding many details in "makeSg***()" functions. Such functions would</span>
<a name="l00043"></a>00043 <span class="comment">// return pointers to the associated Sg*** objects and would be able to hide</span>
<a name="l00044"></a>00044 <span class="comment">// many IR specific details, including:</span>
<a name="l00045"></a>00045 <span class="comment">//      memory handling</span>
<a name="l00046"></a>00046 <span class="comment">//      optional parameter settings not often required</span>
<a name="l00047"></a>00047 <span class="comment">//      use of Sg_File_Info objects (and setting them as transformations)</span>
<a name="l00048"></a>00048 <span class="comment">//</span>
<a name="l00049"></a>00049 <span class="comment">// namespace AST_Interface  (this name is taken already by some of Qing's work :-)</span>
<a name="l00050"></a>00050 
<a name="l00052"></a><a class="code" href="sageInterface_8h.html#0f29691a809d5f799ffb9f3369dab99a">00052</a> <span class="preprocessor">#define TRANS_FILE Sg_File_Info::generateDefaultFileInfoForTransformationNode()</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span>
<a name="l00054"></a>00054 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l00084"></a><a class="code" href="namespaceSageInterface.html">00084</a> <span class="comment"></span><span class="keyword">namespace </span>SageInterface
<a name="l00085"></a>00085 {
<a name="l00087"></a>00087 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="namespaceSageInterface.html#c634a179b840b4d55d9b32e0288fb1b4">gensym_counter</a>;
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 <span class="comment">// tps : 28 Oct 2008 - support for finding the main interpretation</span>
<a name="l00090"></a>00090  <a class="code" href="classSgAsmInterpretation.html">SgAsmInterpretation</a>* <a class="code" href="namespaceSageInterface.html#a6670cd18aab211b99ab001c9e150575">getMainInterpretation</a>(<a class="code" href="classSgAsmGenericFile.html">SgAsmGenericFile</a>* file);
<a name="l00091"></a>00091 
<a name="l00093"></a>00093 uint64_t <a class="code" href="namespaceSageInterface.html#20574ec78dea1f96ddfc689dcd6da9be">getAsmConstant</a>(<a class="code" href="classSgAsmValueExpression.html">SgAsmValueExpression</a>* e);
<a name="l00094"></a>00094 
<a name="l00096"></a>00096 int64_t <a class="code" href="namespaceSageInterface.html#789ac1ef29111e96bf87fbd789dea421">getAsmSignedConstant</a>(<a class="code" href="classSgAsmValueExpression.html">SgAsmValueExpression</a> *e);
<a name="l00097"></a>00097 
<a name="l00099"></a>00099  <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#21d19eaa21c197ce5c65363d225eb31d">addMessageStatement</a>( <a class="code" href="classSgStatement.html">SgStatement</a>* stmt, std::string message );
<a name="l00100"></a>00100 
<a name="l00102"></a><a class="code" href="classSageInterface_1_1UniqueNameAttribute.html">00102</a>   <span class="keyword">class </span><a class="code" href="classSageInterface_1_1UniqueNameAttribute.html">UniqueNameAttribute</a> : <span class="keyword">public</span> <a class="code" href="classAstAttribute.html">AstAttribute</a>
<a name="l00103"></a>00103   {
<a name="l00104"></a>00104     <span class="keyword">private</span>:
<a name="l00105"></a><a class="code" href="classSageInterface_1_1UniqueNameAttribute.html#92ab3aef197c9f7d7a4cd64892fad82d">00105</a>      std::string <a class="code" href="classSageInterface_1_1UniqueNameAttribute.html#92ab3aef197c9f7d7a4cd64892fad82d">name</a>;
<a name="l00106"></a>00106     <span class="keyword">public</span>:
<a name="l00107"></a><a class="code" href="classSageInterface_1_1UniqueNameAttribute.html#0adc3a07f918f7c57e689b01d85bb451">00107</a>      <a class="code" href="classSageInterface_1_1UniqueNameAttribute.html#0adc3a07f918f7c57e689b01d85bb451">UniqueNameAttribute</a>(std::string n=<span class="stringliteral">""</span>) {<a class="code" href="classSageInterface_1_1UniqueNameAttribute.html#92ab3aef197c9f7d7a4cd64892fad82d">name</a> =n; };
<a name="l00108"></a><a class="code" href="classSageInterface_1_1UniqueNameAttribute.html#9155e16a989b0b98164217a97636f908">00108</a>      <span class="keywordtype">void</span> <a class="code" href="classSageInterface_1_1UniqueNameAttribute.html#9155e16a989b0b98164217a97636f908">set_name</a> (std::string n) {<a class="code" href="classSageInterface_1_1UniqueNameAttribute.html#92ab3aef197c9f7d7a4cd64892fad82d">name</a> = n;};
<a name="l00109"></a><a class="code" href="classSageInterface_1_1UniqueNameAttribute.html#f9922ce8c009b2ad3934c126fda8c8eb">00109</a>      std::string <a class="code" href="classSageInterface_1_1UniqueNameAttribute.html#f9922ce8c009b2ad3934c126fda8c8eb">get_name</a> () {<span class="keywordflow">return</span> <a class="code" href="classSageInterface_1_1UniqueNameAttribute.html#92ab3aef197c9f7d7a4cd64892fad82d">name</a>;};
<a name="l00110"></a>00110   };
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 <span class="comment">// DQ (3/2/2009): Added support for collectiong an merging the referenced symbols in the outlined</span>
<a name="l00113"></a>00113 <span class="comment">// function into the list used to edit the outlined code subtree to fixup references (from symbols</span>
<a name="l00114"></a>00114 <span class="comment">// in the original file to the symbols in the newer separate file).</span>
<a name="l00115"></a>00115 <span class="comment">// typedef rose_hash::unordered_map&lt;SgNode*, SgNode*, hash_nodeptr&gt; ReplacementMapType;</span>
<a name="l00116"></a>00116 <span class="comment">// void supplementReplacementSymbolMap ( const ReplacementMapTraversal::ReplacementMapType &amp; inputReplacementMap );</span>
<a name="l00117"></a>00117 
<a name="l00118"></a>00118 <span class="comment">// CH (4/9/2010): Use boost::hash instead</span>
<a name="l00119"></a>00119 <span class="comment">//#ifdef _MSC_VER</span>
<a name="l00120"></a>00120 <span class="preprocessor">#if 0</span>
<a name="l00121"></a>00121 <span class="preprocessor"></span><span class="keyword">inline</span> size_t hash_value(<a class="code" href="classSgNode.html">SgNode</a>* t) {<span class="keywordflow">return</span> (size_t)t;}
<a name="l00122"></a>00122 <span class="preprocessor">#endif</span>
<a name="l00123"></a>00123 <span class="preprocessor"></span>
<a name="l00124"></a><a class="code" href="structSageInterface_1_1hash__nodeptr.html">00124</a> <span class="keyword">struct </span><a class="code" href="structSageInterface_1_1hash__nodeptr.html">hash_nodeptr</a>
<a name="l00125"></a>00125    {
<a name="l00126"></a>00126 <span class="comment">// CH (4/9/2010): Use boost::hash instead</span>
<a name="l00127"></a>00127 <span class="comment">//#ifndef _MSC_VER</span>
<a name="l00128"></a>00128 <span class="preprocessor">#if 0</span>
<a name="l00129"></a>00129 <span class="preprocessor"></span>           <span class="comment">//rose_hash::hash&lt;char*&gt; hasher;</span>
<a name="l00130"></a>00130 <span class="preprocessor">#endif</span>
<a name="l00131"></a>00131 <span class="preprocessor"></span>     <span class="keyword">public</span>:
<a name="l00132"></a><a class="code" href="structSageInterface_1_1hash__nodeptr.html#1f20e3b1c64f3ce6692294a2328d1d06">00132</a>           size_t <a class="code" href="structSageInterface_1_1hash__nodeptr.html#1f20e3b1c64f3ce6692294a2328d1d06">operator()</a>(<a class="code" href="classSgNode.html">SgNode</a>* node)<span class="keyword"> const</span>
<a name="l00133"></a>00133 <span class="keyword">             </span>{
<a name="l00134"></a>00134 <span class="comment">// CH (4/9/2010): Use boost::hash instead</span>
<a name="l00135"></a>00135 <span class="comment">//#ifdef _MSC_VER</span>
<a name="l00136"></a>00136 <span class="preprocessor"> #if 0</span>
<a name="l00137"></a>00137 <span class="preprocessor"></span>                                  <span class="keywordflow">return</span> (size_t) hash_value(node);
<a name="l00138"></a>00138 <span class="preprocessor"> #else</span>
<a name="l00139"></a>00139 <span class="preprocessor"></span>                                  <span class="keywordflow">return</span> (size_t) node;
<a name="l00140"></a>00140 <span class="preprocessor"> #endif</span>
<a name="l00141"></a>00141 <span class="preprocessor"></span>                   }
<a name="l00142"></a>00142     };
<a name="l00143"></a>00143 
<a name="l00144"></a>00144   <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#732c7df1845f9c11495227cd9fa9e1e1">supplementReplacementSymbolMap</a> ( rose_hash::unordered_map&lt;SgNode*, SgNode*, hash_nodeptr&gt; &amp; inputReplacementMap );
<a name="l00145"></a>00145 
<a name="l00146"></a>00146  <span class="comment">//------------------------------------------------------------------------</span>
<a name="l00148"></a>00148 <span class="comment"></span>
<a name="l00151"></a>00151    <span class="comment">// Liao 1/22/2008, used for get symbols for generating variable reference nodes</span>
<a name="l00152"></a>00152    <span class="comment">// ! Find a variable symbol in current and ancestor scopes for a given name</span>
<a name="l00153"></a>00153    <a class="code" href="classSgVariableSymbol.html">SgVariableSymbol</a> *<a class="code" href="namespaceSageInterface.html#10bd491911b4d8d441c2b0f8d8542f50">lookupVariableSymbolInParentScopes</a> (<span class="keyword">const</span> <a class="code" href="classSgName.html">SgName</a> &amp; name,
<a name="l00154"></a>00154                                                          <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope=NULL);
<a name="l00156"></a>00156    <a class="code" href="classSgSymbol.html">SgSymbol</a> *<a class="code" href="namespaceSageInterface.html#fbbf691f4ff947b83e93db1e9622a5a3">lookupSymbolInParentScopes</a> (<span class="keyword">const</span> <a class="code" href="classSgName.html">SgName</a> &amp; name,
<a name="l00157"></a>00157                                                          <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope=NULL);
<a name="l00158"></a>00158 
<a name="l00159"></a>00159    <span class="comment">// DQ (11/24/2007): Functions moved from the Fortran support so that they could be called from within astPostProcessing.</span>
<a name="l00161"></a>00161 <span class="comment"></span>   <a class="code" href="classSgFunctionSymbol.html">SgFunctionSymbol</a> *<a class="code" href="namespaceSageInterface.html#c149a8d976bc90e89fed4d9d6cd3f34a">lookupFunctionSymbolInParentScopes</a> (<span class="keyword">const</span> <a class="code" href="classSgName.html">SgName</a> &amp; functionName,
<a name="l00162"></a>00162                                                          <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope=NULL);
<a name="l00163"></a>00163 
<a name="l00164"></a>00164    <span class="comment">// Liao, 1/24/2008, find exact match for a function</span>
<a name="l00166"></a>00166 <span class="comment"></span>   <a class="code" href="classSgFunctionSymbol.html">SgFunctionSymbol</a> *<a class="code" href="namespaceSageInterface.html#c149a8d976bc90e89fed4d9d6cd3f34a">lookupFunctionSymbolInParentScopes</a> (<span class="keyword">const</span> <a class="code" href="classSgName.html">SgName</a> &amp;  functionName,
<a name="l00167"></a>00167                                                          <span class="keyword">const</span> <a class="code" href="classSgType.html">SgType</a>* t,
<a name="l00168"></a>00168                                                          <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope=NULL);
<a name="l00169"></a>00169 
<a name="l00170"></a>00170 <span class="comment">// DQ (5/7/2011): Added support for SgClassSymbol (used in name qualification support).</span>
<a name="l00171"></a>00171    <a class="code" href="classSgClassSymbol.html">SgClassSymbol</a>*     <a class="code" href="namespaceSageInterface.html#4d0c71bada31301e6bd1a569965cdad6">lookupClassSymbolInParentScopes</a>    (<span class="keyword">const</span> <a class="code" href="classSgName.html">SgName</a> &amp; name, <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope = NULL);
<a name="l00172"></a>00172    <a class="code" href="classSgTypedefSymbol.html">SgTypedefSymbol</a>*   <a class="code" href="namespaceSageInterface.html#f2272608021e9538be091a4f23ecfc6b">lookupTypedefSymbolInParentScopes</a>  (<span class="keyword">const</span> <a class="code" href="classSgName.html">SgName</a> &amp; name, <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope = NULL);
<a name="l00173"></a>00173    <a class="code" href="classSgTemplateSymbol.html">SgTemplateSymbol</a>*  <a class="code" href="namespaceSageInterface.html#15bf8b9e0d05ab2441dfab12f4e0b8af">lookupTemplateSymbolInParentScopes</a> (<span class="keyword">const</span> <a class="code" href="classSgName.html">SgName</a> &amp; name, <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope = NULL);
<a name="l00174"></a>00174    <a class="code" href="classSgEnumSymbol.html">SgEnumSymbol</a>*      <a class="code" href="namespaceSageInterface.html#c5944800817c61bf404f7948d0e9431c">lookupEnumSymbolInParentScopes</a>     (<span class="keyword">const</span> <a class="code" href="classSgName.html">SgName</a> &amp; name, <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope = NULL);
<a name="l00175"></a>00175    <a class="code" href="classSgNamespaceSymbol.html">SgNamespaceSymbol</a>* <a class="code" href="namespaceSageInterface.html#9f057986db266f3d6cc83fd8edbab917">lookupNamespaceSymbolInParentScopes</a>(<span class="keyword">const</span> <a class="code" href="classSgName.html">SgName</a> &amp; name, <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope = NULL);
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 <span class="comment">// DQ (7/17/2011): Added function from cxx branch that I need here for the Java support.</span>
<a name="l00178"></a>00178 <span class="comment">// SgClassSymbol* lookupClassSymbolInParentScopes (const SgName &amp;  name, SgScopeStatement *cscope);</span>
<a name="l00179"></a>00179 
<a name="l00188"></a>00188    <span class="comment">// DQ (12/9/2004): Moved this function (by Alin Jula) from being a member of SgInitializedName</span>
<a name="l00189"></a>00189    <span class="comment">// to this location where it can be a part of the interface for the Sage III AST.</span>
<a name="l00190"></a>00190    <span class="keywordtype">int</span> <a class="code" href="namespaceSageInterface.html#1bbf335d0e6ee069e94e73a62660b8da">set_name</a> (<a class="code" href="classSgInitializedName.html">SgInitializedName</a> * initializedNameNode, <a class="code" href="classSgName.html">SgName</a> new_name);
<a name="l00191"></a>00191 
<a name="l00194"></a>00194    <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#a3fbb86d0df5900f41a2b63a81b4355e">outputGlobalFunctionTypeSymbolTable</a> ();
<a name="l00195"></a>00195 
<a name="l00196"></a>00196    <span class="comment">// DQ (6/27/2005):</span>
<a name="l00201"></a>00201 <span class="comment"></span>   <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#ab1b30cc17b041079ccd395c0f48d9a4">outputLocalSymbolTables</a> (<a class="code" href="classSgNode.html">SgNode</a> * node);
<a name="l00202"></a>00202 
<a name="l00203"></a><a class="code" href="classSageInterface_1_1OutputLocalSymbolTables.html">00203</a>    <span class="keyword">class </span><a class="code" href="classSageInterface_1_1OutputLocalSymbolTables.html">OutputLocalSymbolTables</a>:<span class="keyword">public</span> <a class="code" href="classAstSimpleProcessing.html">AstSimpleProcessing</a>
<a name="l00204"></a>00204          {
<a name="l00205"></a>00205            <span class="keyword">public</span>:
<a name="l00206"></a>00206      <span class="keywordtype">void</span> <a class="code" href="classSageInterface_1_1OutputLocalSymbolTables.html#7fa7b3615d6ae57518c2bf14ece4215b">visit</a> (<a class="code" href="classSgNode.html">SgNode</a> * node);
<a name="l00207"></a>00207          };
<a name="l00213"></a>00213    <span class="comment">// DQ (9/28/2005):</span>
<a name="l00214"></a>00214    <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#f77c4adbf8e70c2904f5c95f80aa32b4">rebuildSymbolTable</a> (<a class="code" href="classSgScopeStatement.html">SgScopeStatement</a> * scope);
<a name="l00215"></a>00215 
<a name="l00218"></a>00218    <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#72448c95af84d803ee677e49650cec12">clearUnusedVariableSymbols</a> ();
<a name="l00219"></a>00219 
<a name="l00220"></a>00220    <span class="comment">// DQ (3/1/2009):</span>
<a name="l00222"></a>00222 <span class="comment"></span>   <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#8dd3faa8aa1e1a39859ed2f4046db4c2">fixupReferencesToSymbols</a>( <span class="keyword">const</span> <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* this_scope,  <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* copy_scope, <a class="code" href="classSgCopyHelp.html">SgCopyHelp</a> &amp; help );
<a name="l00223"></a>00223 
<a name="l00225"></a>00225 
<a name="l00226"></a>00226  <span class="comment">//------------------------------------------------------------------------</span>
<a name="l00228"></a>00228 <span class="comment"></span>
<a name="l00235"></a>00235    <span class="comment">// DQ (9/21/2005): General function for extracting the name of declarations (when they have names)</span>
<a name="l00236"></a>00236      std::string <a class="code" href="namespaceSageInterface.html#d8c38176c2d0e4d2bc851e70007902f9">get_name</a> (<span class="keyword">const</span> <a class="code" href="classSgNode.html">SgNode</a> * node);
<a name="l00237"></a>00237 
<a name="l00242"></a>00242    <span class="comment">// DQ (6/13/2005): General function for extracting the name of declarations (when they have names)</span>
<a name="l00243"></a>00243      std::string <a class="code" href="namespaceSageInterface.html#d8c38176c2d0e4d2bc851e70007902f9">get_name</a> (<span class="keyword">const</span> <a class="code" href="classSgStatement.html">SgStatement</a> * stmt);
<a name="l00244"></a>00244 
<a name="l00249"></a>00249      std::string <a class="code" href="namespaceSageInterface.html#d8c38176c2d0e4d2bc851e70007902f9">get_name</a> (<span class="keyword">const</span> <a class="code" href="classSgExpression.html">SgExpression</a> * expr);
<a name="l00250"></a>00250 
<a name="l00255"></a>00255    <span class="comment">// DQ (6/13/2005): General function for extracting the name of declarations (when they have names)</span>
<a name="l00256"></a>00256      std::string <a class="code" href="namespaceSageInterface.html#d8c38176c2d0e4d2bc851e70007902f9">get_name</a> (<span class="keyword">const</span> <a class="code" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> * declaration);
<a name="l00257"></a>00257 
<a name="l00262"></a>00262    <span class="comment">// DQ (6/13/2005): General function for extracting the name of declarations (when they have names)</span>
<a name="l00263"></a>00263      std::string <a class="code" href="namespaceSageInterface.html#d8c38176c2d0e4d2bc851e70007902f9">get_name</a> (<span class="keyword">const</span> <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a> * scope);
<a name="l00264"></a>00264 
<a name="l00269"></a>00269    <span class="comment">// DQ (2/11/2007): Added this function to make debugging support more complete (useful for symbol table debugging support).</span>
<a name="l00270"></a>00270      std::string <a class="code" href="namespaceSageInterface.html#d8c38176c2d0e4d2bc851e70007902f9">get_name</a> (<span class="keyword">const</span> <a class="code" href="classSgSymbol.html">SgSymbol</a> * symbol);
<a name="l00271"></a>00271 
<a name="l00276"></a>00276      std::string <a class="code" href="namespaceSageInterface.html#d8c38176c2d0e4d2bc851e70007902f9">get_name</a> (<span class="keyword">const</span> <a class="code" href="classSgType.html">SgType</a> * type);
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 
<a name="l00281"></a>00281      std::string <a class="code" href="namespaceSageInterface.html#d8c38176c2d0e4d2bc851e70007902f9">get_name</a> (<span class="keyword">const</span> <a class="code" href="classSgSupport.html">SgSupport</a> * node);
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 
<a name="l00286"></a>00286      std::string <a class="code" href="namespaceSageInterface.html#d8c38176c2d0e4d2bc851e70007902f9">get_name</a> (<span class="keyword">const</span> <a class="code" href="classSgLocatedNodeSupport.html">SgLocatedNodeSupport</a> * node);
<a name="l00287"></a>00287 
<a name="l00290"></a>00290      std::string <a class="code" href="namespaceSageInterface.html#d8c38176c2d0e4d2bc851e70007902f9">get_name</a> ( <span class="keyword">const</span> <a class="code" href="classSgC__PreprocessorDirectiveStatement.html">SgC_PreprocessorDirectiveStatement</a>* directive );
<a name="l00291"></a>00291 
<a name="l00294"></a>00294      std::string <a class="code" href="namespaceSageInterface.html#d8c38176c2d0e4d2bc851e70007902f9">get_name</a> ( <span class="keyword">const</span> <a class="code" href="classSgToken.html">SgToken</a>* token );
<a name="l00295"></a>00295 
<a name="l00297"></a>00297 
<a name="l00298"></a>00298  <span class="comment">//------------------------------------------------------------------------</span>
<a name="l00300"></a>00300 <span class="comment"></span>
<a name="l00305"></a>00305    <span class="comment">// DQ (6/21/2005): Get the default destructor from the class declaration</span>
<a name="l00306"></a>00306    <a class="code" href="classSgMemberFunctionDeclaration.html">SgMemberFunctionDeclaration</a> *<a class="code" href="namespaceSageInterface.html#b5161d0357f41bada1b0528284efc66e">getDefaultDestructor</a> (<a class="code" href="classSgClassDeclaration.html">SgClassDeclaration</a> *
<a name="l00307"></a>00307                                                       classDeclaration);
<a name="l00308"></a>00308 
<a name="l00311"></a>00311    <span class="comment">// DQ (6/22/2005): Get the default constructor from the class declaration</span>
<a name="l00312"></a>00312    <a class="code" href="classSgMemberFunctionDeclaration.html">SgMemberFunctionDeclaration</a> *<a class="code" href="namespaceSageInterface.html#44d0f9a4a27a11112c175c114165c5bc">getDefaultConstructor</a> (<a class="code" href="classSgClassDeclaration.html">SgClassDeclaration</a> *
<a name="l00313"></a>00313                                                        classDeclaration);
<a name="l00316"></a>00316    <span class="comment">// DQ (8/27/2005):</span>
<a name="l00317"></a>00317    <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#d800514689507e16297989c211bd1d46">templateDefinitionIsInClass</a> (<a class="code" href="classSgTemplateInstantiationMemberFunctionDecl.html">SgTemplateInstantiationMemberFunctionDecl</a>
<a name="l00318"></a>00318                                      * memberFunctionDeclaration);
<a name="l00319"></a>00319 
<a name="l00324"></a>00324    <span class="comment">// DQ (9/17/2005):</span>
<a name="l00325"></a>00325       <a class="code" href="classSgTemplateInstantiationMemberFunctionDecl.html">SgTemplateInstantiationMemberFunctionDecl</a>*
<a name="l00326"></a>00326       <a class="code" href="namespaceSageInterface.html#05cf8a0be6e549502d66723997d7a1d6">buildForwardFunctionDeclaration</a>
<a name="l00327"></a>00327          (<a class="code" href="classSgTemplateInstantiationMemberFunctionDecl.html">SgTemplateInstantiationMemberFunctionDecl</a> * memberFunctionInstantiation);
<a name="l00328"></a>00328 
<a name="l00330"></a>00330    <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#2bd323ff608813e595cf631ec1f6c620">isStructDeclaration</a>(<a class="code" href="classSgNode.html">SgNode</a> * node);
<a name="l00331"></a>00331 <span class="preprocessor"> #if 0</span>
<a name="l00332"></a>00332 <span class="preprocessor"></span> <span class="comment">// DQ (8/28/2005): This is already a member function of the SgFunctionDeclaration</span>
<a name="l00333"></a>00333  <span class="comment">// (so that it can handle template functions and member functions)</span>
<a name="l00334"></a>00334 
<a name="l00338"></a>00338     <span class="comment">// DQ (8/27/2005):</span>
<a name="l00339"></a>00339    <span class="keywordtype">bool</span> isTemplateMemberFunction (<a class="code" href="classSgTemplateInstantiationMemberFunctionDecl.html">SgTemplateInstantiationMemberFunctionDecl</a> *
<a name="l00340"></a>00340                                   memberFunctionDeclaration);
<a name="l00341"></a>00341 <span class="preprocessor"> #endif</span>
<a name="l00342"></a>00342 <span class="preprocessor"></span>
<a name="l00344"></a>00344 
<a name="l00345"></a>00345  <span class="comment">//------------------------------------------------------------------------</span>
<a name="l00347"></a>00347 <span class="comment"></span>
<a name="l00351"></a>00351 
<a name="l00352"></a>00352    std::string <a class="code" href="namespaceSageInterface.html#9cfd9f42a896937c833851eeba3b1228">extractPragmaKeyword</a>(<span class="keyword">const</span> <a class="code" href="classSgPragmaDeclaration.html">SgPragmaDeclaration</a> *);
<a name="l00353"></a>00353 
<a name="l00355"></a>00355    <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#cd2e56dc7614b724718c8c8bbd75f5d1">isOmpStatement</a>(<a class="code" href="classSgNode.html">SgNode</a>* );
<a name="l00358"></a>00358    <span class="comment">// DQ (8/27/2005):</span>
<a name="l00359"></a>00359    <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#1a75ef1b6fc0708f3a2791d5198bdf19">isOverloaded</a> (<a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> * functionDeclaration);
<a name="l00360"></a>00360 
<a name="l00362"></a>00362   <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#041d0ad3164d050320ad7181d0aacd64">annotateExpressionsWithUniqueNames</a> (<a class="code" href="classSgProject.html">SgProject</a>* <a class="code" href="namespacecfgUtils.html#ce4abf2beca5826144d69d3a0283050f">project</a>);
<a name="l00363"></a>00363 
<a name="l00365"></a>00365    <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#4d55ef6edf8eebf6577aca1e1fe0de6e">isMain</a> (<span class="keyword">const</span> <a class="code" href="classSgNode.html">SgNode</a>* node);
<a name="l00366"></a>00366    <span class="comment">// DQ (6/22/2005):</span>
<a name="l00377"></a>00377 <span class="comment"></span>    std::string <a class="code" href="namespaceSageInterface.html#c088828a4143b77fa9e3b11ba6b40a0e">generateUniqueName</a> ( <span class="keyword">const</span> <a class="code" href="classSgNode.html">SgNode</a> * node, <span class="keywordtype">bool</span> ignoreDifferenceBetweenDefiningAndNondefiningDeclarations);
<a name="l00378"></a>00378 
<a name="l00381"></a>00381     std::string <a class="code" href="namespaceSageInterface.html#6401801005892a56b2f337d0ce501eb7">generateUniqueVariableName</a>(<a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* scope, std::string baseName = <span class="stringliteral">"temp"</span>);
<a name="l00382"></a>00382 
<a name="l00383"></a>00383   <span class="comment">// DQ (8/10/2010): Added const to first parameter.</span>
<a name="l00384"></a>00384   <span class="comment">// DQ (3/10/2007):</span>
<a name="l00386"></a>00386 <span class="comment"></span>    std::string <a class="code" href="namespaceSageInterface.html#322a03f1d6ed3713ed72abcedeb8a51d">declarationPositionString</a> (<span class="keyword">const</span> <a class="code" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> * declaration);
<a name="l00387"></a>00387 
<a name="l00388"></a>00388   <span class="comment">// DQ (1/20/2007):</span>
<a name="l00390"></a>00390 <span class="comment"></span>    std::string <a class="code" href="namespaceSageInterface.html#90ebac1577ef2a31448937b60c3c09d1">generateProjectName</a> (<span class="keyword">const</span> <a class="code" href="classSgProject.html">SgProject</a> * <a class="code" href="namespacecfgUtils.html#ce4abf2beca5826144d69d3a0283050f">project</a>, <span class="keywordtype">bool</span> supressSuffix = <span class="keyword">false</span> );
<a name="l00391"></a>00391 
<a name="l00394"></a>00394   <a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>* <a class="code" href="namespaceSageInterface.html#92c54986b591707f089705085a7b962e">getDeclarationOfNamedFunction</a>(<a class="code" href="classSgExpression.html">SgExpression</a>* func);
<a name="l00395"></a>00395 
<a name="l00397"></a>00397   <a class="code" href="classSgExpression.html">SgExpression</a>* <a class="code" href="namespaceSageInterface.html#ba53ce71d9c07fc4912d08bfa14aa6c0">forallMaskExpression</a>(<a class="code" href="classSgForAllStatement.html">SgForAllStatement</a>* stmt);
<a name="l00398"></a>00398 
<a name="l00400"></a>00400   <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#bebf0874533c9176d3dbe203c110d2b6">addVarRefExpFromArrayDimInfo</a>(<a class="code" href="classSgNode.html">SgNode</a> * astNode, Rose_STL_Container&lt;SgNode *&gt;&amp; NodeList_t);
<a name="l00401"></a>00401 
<a name="l00402"></a>00402   <span class="comment">// DQ (10/6/2006): Added support for faster mangled name generation (caching avoids recomputation).</span>
<a name="l00406"></a>00406 <span class="comment"></span>  <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#2e2c09133334d2db043980411ad65a7c">clearMangledNameCache</a> (<a class="code" href="classSgGlobal.html">SgGlobal</a> * globalScope);
<a name="l00407"></a>00407   <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#939718eb45951e2200eeb23bc903ee40">resetMangledNameCache</a> (<a class="code" href="classSgGlobal.html">SgGlobal</a> * globalScope);
<a name="l00408"></a>00408   std::string <a class="code" href="namespaceSageInterface.html#fec2eead58f0854713f92c73989787ea">getMangledNameFromCache</a> (<a class="code" href="classSgNode.html">SgNode</a> * astNode);
<a name="l00409"></a>00409   std::string <a class="code" href="namespaceSageInterface.html#cd868f709a4ba10cc7e5367b51033e21">addMangledNameToCache</a> (<a class="code" href="classSgNode.html">SgNode</a> * astNode, <span class="keyword">const</span> std::string &amp; mangledName);
<a name="l00410"></a>00410 
<a name="l00411"></a>00411   <a class="code" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> * <a class="code" href="namespaceSageInterface.html#ea729c0291d71f4b0f34192c4e42f974">getNonInstantiatonDeclarationForClass</a> (<a class="code" href="classSgTemplateInstantiationMemberFunctionDecl.html">SgTemplateInstantiationMemberFunctionDecl</a> * memberFunctionInstantiation);
<a name="l00412"></a>00412 
<a name="l00415"></a>00415   <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#f7e85358ccd85bb87b78259de8f4d549">setBaseTypeDefiningDeclaration</a>(<a class="code" href="classSgVariableDeclaration.html">SgVariableDeclaration</a>* var_decl, <a class="code" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *base_decl);
<a name="l00416"></a>00416 
<a name="l00417"></a>00417   <span class="comment">// DQ (10/14/2006): This function tests the AST to see if for a non-defining declaration, the</span>
<a name="l00418"></a>00418   <span class="comment">// bool declarationPreceedsDefinition ( SgClassDeclaration* classNonDefiningDeclaration, SgClassDeclaration* classDefiningDeclaration );</span>
<a name="l00420"></a>00420 <span class="comment"></span>  <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#2ad11c9bbccfc5c65ebd5a1e63df8457">declarationPreceedsDefinition</a> (<a class="code" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *nonDefiningDeclaration, <a class="code" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *definingDeclaration);
<a name="l00421"></a>00421 
<a name="l00422"></a>00422   <span class="comment">// DQ (10/19/2006): Function calls have interesting context dependent rules to determine if</span>
<a name="l00423"></a>00423   <span class="comment">// they are output with a global qualifier or not.  Were this is true we have to avoid global</span>
<a name="l00424"></a>00424   <span class="comment">// qualifiers, since the function's scope has not been defined.  This is an example of where</span>
<a name="l00425"></a>00425   <span class="comment">// qualification of function names in function calls are context dependent; an interesting</span>
<a name="l00426"></a>00426   <span class="comment">// example of where the C++ language is not friendly to source-to-source processing :-).</span>
<a name="l00427"></a>00427   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#a7b0761edf91357c7d6b1820f18f95d0">functionCallExpressionPreceedsDeclarationWhichAssociatesScope</a> (<a class="code" href="classSgFunctionCallExp.html">SgFunctionCallExp</a> * functionCall);
<a name="l00428"></a>00428 
<a name="l00433"></a>00433     std::vector &lt; SgNode * &gt;<a class="code" href="namespaceSageInterface.html#771883836d967b53906ffba1966f6f2c">astIntersection</a> (<a class="code" href="classSgNode.html">SgNode</a> * original, <a class="code" href="classSgNode.html">SgNode</a> * copy, <a class="code" href="classSgCopyHelp.html">SgCopyHelp</a> * help = NULL);
<a name="l00434"></a>00434 
<a name="l00436"></a>00436    <a class="code" href="classSgNode.html">SgNode</a>* <a class="code" href="namespaceSageInterface.html#9fcc4b40da8ae6daa5f50df366350861">deepCopyNode</a> (<span class="keyword">const</span> <a class="code" href="classSgNode.html">SgNode</a>* subtree);
<a name="l00437"></a>00437 
<a name="l00439"></a>00439    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NodeType&gt;
<a name="l00440"></a><a class="code" href="namespaceSageInterface.html#3a89292adcceeeda5391c5f67857251d">00440</a>    NodeType* <a class="code" href="namespaceSageInterface.html#3a89292adcceeeda5391c5f67857251d">deepCopy</a> (<span class="keyword">const</span> NodeType* subtree) {
<a name="l00441"></a>00441      <span class="keywordflow">return</span> dynamic_cast&lt;NodeType*&gt;(<a class="code" href="namespaceSageInterface.html#9fcc4b40da8ae6daa5f50df366350861">deepCopyNode</a>(subtree));
<a name="l00442"></a>00442    }
<a name="l00443"></a>00443 
<a name="l00445"></a>00445    <a class="code" href="classSgExpression.html">SgExpression</a>* <a class="code" href="namespaceSageInterface.html#b716e78a9af76b8ace53782ce98938f8">copyExpression</a>(<a class="code" href="classSgExpression.html">SgExpression</a>* e);
<a name="l00446"></a>00446 
<a name="l00448"></a>00448    <a class="code" href="classSgStatement.html">SgStatement</a>* <a class="code" href="namespaceSageInterface.html#ccb4140d5bad66ff517c5171a8e23790">copyStatement</a>(<a class="code" href="classSgStatement.html">SgStatement</a>* s);
<a name="l00449"></a>00449 
<a name="l00450"></a>00450 <span class="comment">// from VarSym.cc in src/midend/astOutlining/src/ASTtools</span>
<a name="l00452"></a>00452 <span class="comment"></span>  <a class="code" href="classSgVariableSymbol.html">SgVariableSymbol</a>* <a class="code" href="namespaceSageInterface.html#2e4a80143b2c610c87c8ec6c8ae1a4f6">getFirstVarSym</a> (<a class="code" href="classSgVariableDeclaration.html">SgVariableDeclaration</a>* decl);
<a name="l00453"></a>00453 
<a name="l00455"></a>00455   <a class="code" href="classSgInitializedName.html">SgInitializedName</a>* <a class="code" href="namespaceSageInterface.html#13d0ecca52ba48d86e137017800ace85">getFirstInitializedName</a> (<a class="code" href="classSgVariableDeclaration.html">SgVariableDeclaration</a>* decl);
<a name="l00456"></a>00456 
<a name="l00458"></a>00458 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#f2a313ede41c7b731cb61c355d1c55e0">myRemoveStatement</a>(<a class="code" href="classSgStatement.html">SgStatement</a>* stmt);
<a name="l00459"></a>00459 
<a name="l00460"></a>00460 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#8b764061b63990cb9a90a2e8fba1cd9e">isConstantTrue</a>(<a class="code" href="classSgExpression.html">SgExpression</a>* e);
<a name="l00461"></a>00461 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#aabc058b0a469b383db6dae596659b1e">isConstantFalse</a>(<a class="code" href="classSgExpression.html">SgExpression</a>* e);
<a name="l00462"></a>00462 
<a name="l00463"></a>00463 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#eb16538d6d56b5b2ef2960c7f8c1ed9c">isCallToParticularFunction</a>(<a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>* decl, <a class="code" href="classSgExpression.html">SgExpression</a>* e);
<a name="l00464"></a>00464 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#eb16538d6d56b5b2ef2960c7f8c1ed9c">isCallToParticularFunction</a>(<span class="keyword">const</span> std::string&amp; qualifiedName, size_t arity, <a class="code" href="classSgExpression.html">SgExpression</a>* e);
<a name="l00465"></a>00465 
<a name="l00467"></a>00467 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#345dac5d75b2039d24e0a4f9820d7b7c">isStatic</a>(<a class="code" href="classSgDeclarationStatement.html">SgDeclarationStatement</a>* stmt);
<a name="l00468"></a>00468 
<a name="l00470"></a>00470 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#7133b3ef7857297f8fe4cbbdc0757259">setStatic</a>(<a class="code" href="classSgDeclarationStatement.html">SgDeclarationStatement</a>* stmt);
<a name="l00471"></a>00471 
<a name="l00473"></a>00473 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#9ccb65716fdfa5b17abb793584b76a40">isExtern</a>(<a class="code" href="classSgDeclarationStatement.html">SgDeclarationStatement</a>* stmt);
<a name="l00474"></a>00474 
<a name="l00476"></a>00476 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#5a4e98c40873b96844edc32c7b2604e7">setExtern</a>(<a class="code" href="classSgDeclarationStatement.html">SgDeclarationStatement</a>* stmt);
<a name="l00477"></a>00477 
<a name="l00480"></a><a class="code" href="classSageInterface_1_1StatementGenerator.html">00480</a> <span class="keyword">class </span><a class="code" href="classSageInterface_1_1StatementGenerator.html">StatementGenerator</a> {
<a name="l00481"></a>00481   <span class="keyword">public</span>:
<a name="l00482"></a><a class="code" href="classSageInterface_1_1StatementGenerator.html#23b5345933c1055260f762fc83017c0e">00482</a>   <span class="keyword">virtual</span> <a class="code" href="classSageInterface_1_1StatementGenerator.html#23b5345933c1055260f762fc83017c0e">~StatementGenerator</a>() {};
<a name="l00483"></a>00483   <span class="keyword">virtual</span> <a class="code" href="classSgStatement.html">SgStatement</a>* <a class="code" href="classSageInterface_1_1StatementGenerator.html#1caa09f7eea6f64b44f85e9538974364">generate</a>(<a class="code" href="classSgExpression.html">SgExpression</a>* where_to_write_answer) = 0;
<a name="l00484"></a>00484 };
<a name="l00485"></a>00485 
<a name="l00489"></a>00489   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#746a92a94fcc6190e015e74aa1c911e8">isAssignmentStatement</a>(<a class="code" href="classSgNode.html">SgNode</a>* _s, <a class="code" href="classSgExpression.html">SgExpression</a>** lhs=NULL, <a class="code" href="classSgExpression.html">SgExpression</a>** rhs=NULL, <span class="keywordtype">bool</span>* readlhs=NULL);
<a name="l00490"></a>00490 
<a name="l00492"></a>00492 <a class="code" href="classSgInitializedName.html">SgInitializedName</a>* <a class="code" href="namespaceSageInterface.html#549a580089fff36d4184a4341cc08525">convertRefToInitializedName</a>(<a class="code" href="classSgNode.html">SgNode</a>* current);
<a name="l00493"></a>00493 
<a name="l00495"></a>00495 <a class="code" href="classSgNode.html">SgNode</a>* <a class="code" href="namespaceSageInterface.html#e96f2137bb71d4484508452e554e1ae6">getSgNodeFromAbstractHandleString</a>(<span class="keyword">const</span> std::string&amp; input_string);
<a name="l00496"></a>00496 
<a name="l00498"></a>00498 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#db3bd3c96f7ee7b03abc333cf2d14d96">dumpInfo</a>(<a class="code" href="classSgNode.html">SgNode</a>* node, std::string desc=<span class="stringliteral">""</span>);
<a name="l00499"></a>00499 
<a name="l00501"></a>00501 std::vector&lt;SgDeclarationStatement*&gt;
<a name="l00502"></a>00502 <a class="code" href="namespaceSageInterface.html#74263a872d82b1b9f570120aad9205a8">sortSgNodeListBasedOnAppearanceOrderInSource</a>(<span class="keyword">const</span> std::vector&lt;SgDeclarationStatement*&gt;&amp; nodevec);
<a name="l00503"></a>00503 
<a name="l00505"></a>00505 
<a name="l00506"></a>00506 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l00508"></a>00508 <span class="comment"></span>
<a name="l00512"></a>00512 <span class="comment">//  std::string version();  // utility_functions.h, version number</span>
<a name="l00515"></a>00515 <span class="comment"></span>  <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#566a32e0c20fd3f5622ea88542e15fc1">is_C_language</a> ();
<a name="l00516"></a>00516   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#a60da61c638f8a24154b5825a61c6cd2">is_OpenMP_language</a> ();
<a name="l00517"></a>00517   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#b0e18374a0ed7b0e6316a99024f3d463">is_UPC_language</a> ();
<a name="l00519"></a>00519   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#8ec5479617b0522a268f633eae672480">is_UPC_dynamic_threads</a>();
<a name="l00520"></a>00520   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#886098c3840ecd5cd66dc1407dd43276">is_C99_language</a> ();
<a name="l00521"></a>00521   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#f05a80a2ebfff2af0adea468853b95c8">is_Cxx_language</a> ();
<a name="l00522"></a>00522   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#49a362a0ab0c9d904277c2110b3ad49c">is_Java_language</a> ();
<a name="l00523"></a>00523   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#83cad0fd2592f95e81d55335eb6b71c0">is_Fortran_language</a> ();
<a name="l00524"></a>00524   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#92b55e430cd48fbaf0549c18346a5143">is_CAF_language</a> ();
<a name="l00525"></a>00525   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#1d36075c44838671db22569634aa2938">is_PHP_language</a>();
<a name="l00526"></a>00526   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#23d423a93f8f98375f0d6270830945a2">is_Python_language</a>();
<a name="l00527"></a>00527   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#bac39765f90bd8e44841f94da97b0983">is_Cuda_language</a>();
<a name="l00528"></a>00528   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#8adea0a7bcd9c553286b10558f39dc88">is_binary_executable</a>();
<a name="l00529"></a>00529   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#6321d2c29de36e4e3b13d5ad2f05360f">is_mixed_C_and_Cxx_language</a> ();
<a name="l00530"></a>00530   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#0c24f014eaa02cc009e4d5b4e82317b0">is_mixed_Fortran_and_C_language</a> ();
<a name="l00531"></a>00531   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#8400c6f481f8578f7cd13c62abdc0e20">is_mixed_Fortran_and_Cxx_language</a> ();
<a name="l00532"></a>00532   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#c403d067f7bef971b67d9a1c4a78d50e">is_mixed_Fortran_and_C_and_Cxx_language</a> ();
<a name="l00534"></a>00534 
<a name="l00535"></a>00535 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l00537"></a>00537 <span class="comment"></span>
<a name="l00541"></a>00541   <span class="comment">// DQ (10/5/2006): Added support for faster (non-quadratic) computation of unique</span>
<a name="l00542"></a>00542   <span class="comment">// labels for scopes in a function (as required for name mangling).</span>
<a name="l00548"></a>00548 <span class="comment"></span>  <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#1035757c3d70027ffd221d21b36af053">resetScopeNumbers</a> (<a class="code" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> * functionDeclaration);
<a name="l00549"></a>00549 
<a name="l00550"></a>00550   <span class="comment">// DQ (10/5/2006): Added support for faster (non-quadratic) computation of unique</span>
<a name="l00551"></a>00551   <span class="comment">// labels for scopes in a function (as required for name mangling).</span>
<a name="l00560"></a>00560 <span class="comment"></span>  <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#d3cad455182a3615812ac2597a50bd09">clearScopeNumbers</a> (<a class="code" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> * functionDefinition);
<a name="l00561"></a>00561 
<a name="l00562"></a>00562 
<a name="l00564"></a>00564   <a class="code" href="classSgNamespaceDefinitionStatement.html">SgNamespaceDefinitionStatement</a> * <a class="code" href="namespaceSageInterface.html#a192374d0f4322f7c91324938c6b8894">enclosingNamespaceScope</a> (<a class="code" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> * declaration);
<a name="l00565"></a>00565 <span class="comment">//  SgNamespaceDefinitionStatement * getEnclosingNamespaceScope (SgNode * node);</span>
<a name="l00566"></a>00566 
<a name="l00567"></a>00567   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#b456db305882bbb6be21968b59fc865c">isPrototypeInScope</a> (<a class="code" href="classSgScopeStatement.html">SgScopeStatement</a> * scope,
<a name="l00568"></a>00568                            <a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> * functionDeclaration,
<a name="l00569"></a>00569                            <a class="code" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> * startingAtDeclaration);
<a name="l00570"></a>00570 
<a name="l00572"></a>00572   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#74b3faa5cdda97afa174085b4a34a2f1">isAncestor</a>(<a class="code" href="classSgNode.html">SgNode</a>* node1, <a class="code" href="classSgNode.html">SgNode</a>* node2);
<a name="l00574"></a>00574 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l00576"></a>00576 <span class="comment"></span>
<a name="l00580"></a>00580 
<a name="l00581"></a>00581   <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#8d27ee1ca1349f91dc8a18d1aa6cc403">dumpPreprocInfo</a> (<a class="code" href="classSgLocatedNode.html">SgLocatedNode</a>* locatedNode);
<a name="l00582"></a>00582 
<a name="l00584"></a>00584 <a class="code" href="classPreprocessingInfo.html">PreprocessingInfo</a>* <a class="code" href="namespaceSageInterface.html#56f045ed55445883dc3fc798738580a2">insertHeader</a>(<span class="keyword">const</span> std::string&amp; filename, <a class="code" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> position=<a class="code" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1076a17cd5e07b4ff81ddb379ab11d9ac">PreprocessingInfo::after</a>, <span class="keywordtype">bool</span> isSystemHeader=<span class="keyword">false</span>, <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* scope=NULL);
<a name="l00585"></a>00585 
<a name="l00587"></a>00587 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#283532aef637c65f6d103afc09d5fd71">moveUpPreprocessingInfo</a> (<a class="code" href="classSgStatement.html">SgStatement</a>* stmt_dst, <a class="code" href="classSgStatement.html">SgStatement</a>* stmt_src, <a class="code" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> src_position=<a class="code" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1175d8b75ca880c7d45167587b72dff1b">PreprocessingInfo::undef</a>,  <a class="code" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> dst_position=<a class="code" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1175d8b75ca880c7d45167587b72dff1b">PreprocessingInfo::undef</a>, <span class="keywordtype">bool</span> usePrepend= <span class="keyword">false</span>);
<a name="l00588"></a>00588 
<a name="l00590"></a>00590 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#b6bc0e31d1ae1be2e221bb8ddbe1e098">movePreprocessingInfo</a> (<a class="code" href="classSgStatement.html">SgStatement</a>* stmt_src, <a class="code" href="classSgStatement.html">SgStatement</a>* stmt_dst,  <a class="code" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> src_position=<a class="code" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1175d8b75ca880c7d45167587b72dff1b">PreprocessingInfo::undef</a>,
<a name="l00591"></a>00591                              <a class="code" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> dst_position=<a class="code" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1175d8b75ca880c7d45167587b72dff1b">PreprocessingInfo::undef</a>, <span class="keywordtype">bool</span> usePrepend= <span class="keyword">false</span>);
<a name="l00592"></a>00592 
<a name="l00593"></a>00593 
<a name="l00595"></a>00595 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#29f09cd84a8eadc2e1c0524898973233">cutPreprocessingInfo</a> (<a class="code" href="classSgLocatedNode.html">SgLocatedNode</a>* src_node, <a class="code" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> pos, <a class="code" href="rose__attributes__list_8h.html#d4b5f34bc0846e58b38e0ba5e8aac8b0">AttachedPreprocessingInfoType</a>&amp; save_buf);
<a name="l00596"></a>00596 
<a name="l00598"></a>00598 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#fa35ff298b746401f5f535de8a9c3f99">pastePreprocessingInfo</a> (<a class="code" href="classSgLocatedNode.html">SgLocatedNode</a>* dst_node, <a class="code" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> pos, <a class="code" href="rose__attributes__list_8h.html#d4b5f34bc0846e58b38e0ba5e8aac8b0">AttachedPreprocessingInfoType</a>&amp; saved_buf);
<a name="l00599"></a>00599 
<a name="l00601"></a>00601 <a class="code" href="classPreprocessingInfo.html">PreprocessingInfo</a>* <a class="code" href="namespaceSageInterface.html#a5cdee81732f9fb464a0239093275d86">attachArbitraryText</a>(<a class="code" href="classSgLocatedNode.html">SgLocatedNode</a>* target,
<a name="l00602"></a>00602                 <span class="keyword">const</span> std::string &amp; text,
<a name="l00603"></a>00603                <a class="code" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> position=<a class="code" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1106a7c55bcc9c92144c8d1c152cd5d22">PreprocessingInfo::before</a>);
<a name="l00604"></a>00604 
<a name="l00606"></a>00606 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#3bf4efffda1365f130307b6581dcc5c9">replaceMacroCallsWithExpandedStrings</a>(<a class="code" href="classSgPragmaDeclaration.html">SgPragmaDeclaration</a>* target);
<a name="l00608"></a>00608 
<a name="l00609"></a>00609 
<a name="l00610"></a>00610 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l00612"></a>00612 <span class="comment"></span>
<a name="l00615"></a>00615 
<a name="l00616"></a>00616    <a class="code" href="classPreprocessingInfo.html">PreprocessingInfo</a>* <a class="code" href="namespaceSageInterface.html#67b0e2f8c62c2a8858340e7f90605bc3">attachComment</a>(<a class="code" href="classSgLocatedNode.html">SgLocatedNode</a>* target, <span class="keyword">const</span> std::string &amp; content,
<a name="l00617"></a>00617                <a class="code" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> position=<a class="code" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1106a7c55bcc9c92144c8d1c152cd5d22">PreprocessingInfo::before</a>,
<a name="l00618"></a>00618                <a class="code" href="classPreprocessingInfo.html#e789144105bc700862c47070f4380064">PreprocessingInfo::DirectiveType</a> dtype= <a class="code" href="classPreprocessingInfo.html#e789144105bc700862c47070f43800641f2c3b6fe3b514e09f51a602e2bff0a9">PreprocessingInfo::CpreprocessorUnknownDeclaration</a>);
<a name="l00619"></a>00619 
<a name="l00620"></a>00620 <span class="comment">// DQ (11/25/2009): Added matching support for adding comments to SgAsm nodes.</span>
<a name="l00621"></a>00621 <span class="comment">// Build and attach comment</span>
<a name="l00622"></a>00622 <span class="comment">// void attachComment(SgAsmStatement* target, const std::string &amp; content );</span>
<a name="l00623"></a>00623 
<a name="l00624"></a>00624 <span class="comment">// DQ (7/20/2008): I am not clear were I should put this function, candidates include: SgLocatedNode or SgInterface</span>
<a name="l00626"></a>00626 <span class="comment"></span>  <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#0c8fca7b7763fe18fe2e65b7a3cf3ebe">addTextForUnparser</a> ( <a class="code" href="classSgNode.html">SgNode</a>* astNode, std::string s, AstUnparseAttribute::RelativePositionType inputlocation );
<a name="l00627"></a>00627 
<a name="l00628"></a>00628 
<a name="l00629"></a>00629   <span class="comment">// Liao, 1/8/2007, set file info. for a whole subtree as transformation generated</span>
<a name="l00631"></a>00631 <span class="comment"></span>  <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#2d9f0cac1a208b285896a8f38d24910c">setOneSourcePositionForTransformation</a>(<a class="code" href="classSgNode.html">SgNode</a> *node);
<a name="l00632"></a>00632 
<a name="l00634"></a>00634   <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#c2dd84efb4bec39069ab07683078e29c">setOneSourcePositionNull</a>(<a class="code" href="classSgNode.html">SgNode</a> *node);
<a name="l00635"></a>00635 
<a name="l00637"></a>00637   <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#4a000085908cd7fe8ab8cf07856b00fe">setSourcePositionForTransformation</a> (<a class="code" href="classSgNode.html">SgNode</a> * root);
<a name="l00638"></a>00638 
<a name="l00640"></a>00640   <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#6bd0bf1527ae929472afba8b567fa808">setSourcePositionForTransformation_memoryPool</a>();
<a name="l00641"></a>00641 
<a name="l00643"></a>00643   <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#bf0f6c68d90fe1d08e382fe8342b3992">setSourcePosition</a> (<a class="code" href="classSgLocatedNode.html">SgLocatedNode</a> * locatedNode);
<a name="l00644"></a>00644 
<a name="l00646"></a>00646 
<a name="l00647"></a>00647 
<a name="l00648"></a>00648 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l00650"></a>00650 <span class="comment"></span>
<a name="l00654"></a>00654 <span class="comment">// from src/midend/astInlining/typeTraits.h</span>
<a name="l00655"></a>00655 <span class="comment">// src/midend/astUtil/astInterface/AstInterface.h</span>
<a name="l00656"></a>00656 
<a name="l00658"></a>00658 <a class="code" href="classSgType.html">SgType</a>* <a class="code" href="namespaceSageInterface.html#5eb80ef8782c559e7721b5724889bdbe">getBoolType</a>(<a class="code" href="classSgNode.html">SgNode</a>* n);
<a name="l00659"></a>00659 
<a name="l00660"></a>00660 
<a name="l00664"></a>00664 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#dbfdb7a0b32ca452c00f5e92c67ab504">isStrictIntegerType</a>(<a class="code" href="classSgType.html">SgType</a>* t);
<a name="l00666"></a>00666 <a class="code" href="classSgType.html">SgType</a>* <a class="code" href="namespaceSageInterface.html#da61c82df82783bc236b9fb30fbd74fd">getFirstVarType</a>(<a class="code" href="classSgVariableDeclaration.html">SgVariableDeclaration</a>* decl);
<a name="l00667"></a>00667 
<a name="l00669"></a>00669 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#009d6a3353b70c4ccbe95c6f7625afc1">isDefaultConstructible</a>(<a class="code" href="classSgType.html">SgType</a>* type);
<a name="l00670"></a>00670 
<a name="l00672"></a>00672 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#32b9be9817f0b51872d3fcb8318ae729">isCopyConstructible</a>(<a class="code" href="classSgType.html">SgType</a>* type);
<a name="l00673"></a>00673 
<a name="l00675"></a>00675 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#7a37edbdd90a230a51fc90448994cb8b">isAssignable</a>(<a class="code" href="classSgType.html">SgType</a>* type);
<a name="l00676"></a>00676 
<a name="l00677"></a>00677 <span class="preprocessor">#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</span>
<a name="l00681"></a>00681 <span class="preprocessor">bool isPureVirtualClass(SgType* type, const ClassHierarchyWrapper&amp; classHierarchy);</span>
<a name="l00682"></a>00682 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00683"></a>00683 <span class="preprocessor"></span>
<a name="l00685"></a>00685 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#756c8b08ca6df604e0e474ce92520240">hasTrivialDestructor</a>(<a class="code" href="classSgType.html">SgType</a>* t);
<a name="l00686"></a>00686 
<a name="l00688"></a>00688 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#82f20af57da57491b26e6028fc4949c7">isNonconstReference</a>(<a class="code" href="classSgType.html">SgType</a>* t);
<a name="l00689"></a>00689 
<a name="l00691"></a>00691 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#82448abd826a63fbf74cabde856223ec">isReferenceType</a>(<a class="code" href="classSgType.html">SgType</a>* t);
<a name="l00692"></a>00692 
<a name="l00694"></a>00694 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#370c189fab51b8d9a5871c569fe2ae76">isPointerType</a>(<a class="code" href="classSgType.html">SgType</a>* t);
<a name="l00695"></a>00695 
<a name="l00701"></a>00701 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#e88d4c976002995bdc89629bf5942812">isPointerToNonConstType</a>(<a class="code" href="classSgType.html">SgType</a>* type);
<a name="l00702"></a>00702 
<a name="l00704"></a>00704 <span class="comment">/* const char* p = "aa"; is not treated as having a const type. It is a pointer to const char.</span>
<a name="l00705"></a>00705 <span class="comment"> * Similarly, neither for const int b[10]; or const int &amp; c =10;</span>
<a name="l00706"></a>00706 <span class="comment"> * The standard says, "A compound type is not cv-qualified by the cv-qualifiers (if any) of</span>
<a name="l00707"></a>00707 <span class="comment">the types from which it is compounded. Any cv-qualifiers applied to an array type affect the array element type, not the array type".</span>
<a name="l00708"></a>00708 <span class="comment"> */</span>
<a name="l00709"></a>00709 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#3a8271b0d66df14cd687c3367c3530cc">isConstType</a>(<a class="code" href="classSgType.html">SgType</a>* t);
<a name="l00710"></a>00710 
<a name="l00712"></a>00712 <a class="code" href="classSgType.html">SgType</a>* <a class="code" href="namespaceSageInterface.html#aad366e0a9271f41b1273169032163a9">removeConst</a>(<a class="code" href="classSgType.html">SgType</a>* t);
<a name="l00713"></a>00713 
<a name="l00715"></a>00715 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#bfdc4703511f9477641338f374d2efea">isVolatileType</a>(<a class="code" href="classSgType.html">SgType</a>* t);
<a name="l00716"></a>00716 
<a name="l00718"></a>00718 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#9bb1cf771b3824b61f450868a4a37014">isRestrictType</a>(<a class="code" href="classSgType.html">SgType</a>* t);
<a name="l00719"></a>00719 
<a name="l00721"></a>00721 
<a name="l00723"></a>00723 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#383e9d7c3a5ecf90215dc596491cb748">isScalarType</a>(<a class="code" href="classSgType.html">SgType</a>* t);
<a name="l00724"></a>00724 
<a name="l00728"></a>00728 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#dbfdb7a0b32ca452c00f5e92c67ab504">isStrictIntegerType</a>(<a class="code" href="classSgType.html">SgType</a>* t);
<a name="l00729"></a>00729 
<a name="l00731"></a>00731 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#0c1abd9fda12ecad049dc846ab65dd99">isStructType</a>(<a class="code" href="classSgType.html">SgType</a>* t);
<a name="l00732"></a>00732 
<a name="l00734"></a>00734 std::string <a class="code" href="namespaceSageInterface.html#42c6089ca6226d5f96cc54164a8c2dec">mangleType</a>(<a class="code" href="classSgType.html">SgType</a>* type);
<a name="l00735"></a>00735 
<a name="l00737"></a>00737   std::string <a class="code" href="namespaceSageInterface.html#4ba1a020452edc07be8aefe8f87c7a52">mangleScalarType</a>(<a class="code" href="classSgType.html">SgType</a>* type);
<a name="l00738"></a>00738 
<a name="l00740"></a>00740   std::string <a class="code" href="namespaceSageInterface.html#181e5d76b90b579ffe02ce67a9a0ef8b">mangleModifierType</a>(<a class="code" href="classSgModifierType.html">SgModifierType</a>* type);
<a name="l00741"></a>00741 
<a name="l00743"></a>00743 size_t <a class="code" href="namespaceSageInterface.html#d41b5baa74591e80698884761377ab6b">getArrayElementCount</a>(<a class="code" href="classSgArrayType.html">SgArrayType</a>* t);
<a name="l00744"></a>00744 
<a name="l00746"></a>00746 <span class="keywordtype">int</span> <a class="code" href="namespaceSageInterface.html#8a2ff021fc68f7aa3af9427133e94663">getDimensionCount</a>(<a class="code" href="classSgType.html">SgType</a>* t);
<a name="l00747"></a>00747 
<a name="l00749"></a>00749 <a class="code" href="classSgType.html">SgType</a>* <a class="code" href="namespaceSageInterface.html#4be15625c027455c3ba044dbeff24f05">getArrayElementType</a>(<a class="code" href="classSgType.html">SgType</a>* t);
<a name="l00750"></a>00750 
<a name="l00752"></a>00752 <a class="code" href="classSgType.html">SgType</a>* <a class="code" href="namespaceSageInterface.html#5eaa89e50137b40aab59321dcfed8d81">getElementType</a>(<a class="code" href="classSgType.html">SgType</a>* t);
<a name="l00753"></a>00753 
<a name="l00754"></a>00754 
<a name="l00771"></a>00771 std::vector&lt;SgExpression*&gt;
<a name="l00772"></a>00772 <a class="code" href="namespaceSageInterface.html#4f543ac715559ff0b76bdf8fd004fc09">get_C_array_dimensions</a>(<span class="keyword">const</span> <a class="code" href="classSgArrayType.html">SgArrayType</a>&amp; arrtype);
<a name="l00773"></a>00773 
<a name="l00794"></a>00794 std::vector&lt;SgExpression*&gt;
<a name="l00795"></a>00795 <a class="code" href="namespaceSageInterface.html#4f543ac715559ff0b76bdf8fd004fc09">get_C_array_dimensions</a>(<span class="keyword">const</span> <a class="code" href="classSgArrayType.html">SgArrayType</a>&amp; arrtype, <span class="keyword">const</span> <a class="code" href="classSgVarRefExp.html">SgVarRefExp</a>&amp; varref);
<a name="l00796"></a>00796 
<a name="l00800"></a>00800 std::vector&lt;SgExpression*&gt;
<a name="l00801"></a>00801 <a class="code" href="namespaceSageInterface.html#4f543ac715559ff0b76bdf8fd004fc09">get_C_array_dimensions</a>(<span class="keyword">const</span> <a class="code" href="classSgArrayType.html">SgArrayType</a>&amp; arrtype, <a class="code" href="classSgInitializedName.html">SgInitializedName</a>&amp; initname);
<a name="l00802"></a>00802 
<a name="l00803"></a>00803 
<a name="l00805"></a>00805 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#084d7c6b763876564745cdf9a33a65a3">isArrayReference</a>(<a class="code" href="classSgExpression.html">SgExpression</a>* ref, <a class="code" href="classSgExpression.html">SgExpression</a>** arrayNameExp=NULL, std::vector&lt;SgExpression*&gt;** subscripts=NULL);
<a name="l00806"></a>00806 
<a name="l00807"></a>00807 
<a name="l00809"></a>00809 
<a name="l00818"></a>00818 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#de40549fd13e8fe367b099dca26b05e9">hasUpcSharedType</a>(<a class="code" href="classSgType.html">SgType</a>* t, <a class="code" href="classSgModifierType.html">SgModifierType</a> ** mod_type_out = NULL  );
<a name="l00819"></a>00819 
<a name="l00821"></a>00821 
<a name="l00824"></a>00824 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#b376d542cfdc22ae95a4396a13f4bc93">isUpcSharedType</a>(<a class="code" href="classSgType.html">SgType</a>* t, <a class="code" href="classSgModifierType.html">SgModifierType</a> ** mod_type_out = NULL);
<a name="l00825"></a>00825 
<a name="l00827"></a>00827 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#d54acda16a47a2c0cfbf2cfb9acbe8ee">isUpcSharedModifierType</a> (<a class="code" href="classSgModifierType.html">SgModifierType</a>* mod_type);
<a name="l00828"></a>00828 
<a name="l00830"></a>00830 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#4d265b598c37bc424f98b5a95573ff15">isUpcSharedArrayType</a> (<a class="code" href="classSgArrayType.html">SgArrayType</a>* array_type);
<a name="l00831"></a>00831 
<a name="l00833"></a>00833 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#3a8ddc7cf87c39a61529012d179d3dbe">isUpcStrictSharedModifierType</a>(<a class="code" href="classSgModifierType.html">SgModifierType</a>* mode_type);
<a name="l00834"></a>00834 
<a name="l00836"></a>00836 size_t <a class="code" href="namespaceSageInterface.html#ad5db4074aa860d969211e082b1fda2a">getUpcSharedBlockSize</a>(<a class="code" href="classSgModifierType.html">SgModifierType</a>* mod_type);
<a name="l00837"></a>00837 
<a name="l00839"></a>00839 size_t <a class="code" href="namespaceSageInterface.html#ad5db4074aa860d969211e082b1fda2a">getUpcSharedBlockSize</a>(<a class="code" href="classSgType.html">SgType</a>* t);
<a name="l00840"></a>00840 
<a name="l00842"></a>00842 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#78e18bb017714a961c89e99658deaf62">isUpcPhaseLessSharedType</a> (<a class="code" href="classSgType.html">SgType</a>* t);
<a name="l00843"></a>00843 
<a name="l00845"></a>00845 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#a8dfe505ebec9aa2cc591ab6abd2eee6">isUpcPrivateToSharedType</a>(<a class="code" href="classSgType.html">SgType</a>* t);
<a name="l00846"></a>00846 
<a name="l00848"></a>00848 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#c9d12d48cbb70bd32351ef1d11bf8a03">isUpcArrayWithThreads</a>(<a class="code" href="classSgArrayType.html">SgArrayType</a>* t);
<a name="l00849"></a>00849 
<a name="l00851"></a>00851 <a class="code" href="classSgType.html">SgType</a>* <a class="code" href="namespaceSageInterface.html#ef8c45dd50e90745d7a58043ff115b59">lookupNamedTypeInParentScopes</a>(<span class="keyword">const</span> std::string&amp; type_name, <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* scope=NULL);
<a name="l00852"></a>00852 
<a name="l00854"></a>00854 
<a name="l00855"></a>00855 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l00857"></a>00857 <span class="comment"></span>
<a name="l00861"></a>00861 <span class="comment">// by Jeremiah</span>
<a name="l00870"></a>00870 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#08fe811227383a60a96a1f35e33d58c7">addStepToLoopBody</a>(<a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* loopStmt, <a class="code" href="classSgStatement.html">SgStatement</a>* step);
<a name="l00871"></a>00871 
<a name="l00872"></a>00872 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#8350cdaa61eb225618e5d32d1d6ead35">moveForStatementIncrementIntoBody</a>(<a class="code" href="classSgForStatement.html">SgForStatement</a>* f);
<a name="l00873"></a>00873 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#d8b390197b2be6ccda0b4cd5f5db5924">convertForToWhile</a>(<a class="code" href="classSgForStatement.html">SgForStatement</a>* f);
<a name="l00874"></a>00874 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#a952504e784c3893ff962859c02db863">convertAllForsToWhiles</a>(<a class="code" href="classSgNode.html">SgNode</a>* top);
<a name="l00876"></a>00876 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#a3c334c13af3f52296a321d7c35baa23">changeContinuesToGotos</a>(<a class="code" href="classSgStatement.html">SgStatement</a>* stmt, <a class="code" href="classSgLabelStatement.html">SgLabelStatement</a>* label);
<a name="l00877"></a>00877 
<a name="l00879"></a>00879 <a class="code" href="classSgInitializedName.html">SgInitializedName</a>* <a class="code" href="namespaceSageInterface.html#a665b7831b78df5befccba361619e346">getLoopIndexVariable</a>(<a class="code" href="classSgNode.html">SgNode</a>* loop);
<a name="l00880"></a>00880 
<a name="l00883"></a>00883 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#21ef5a8bfe9a660dbe9206d50f1750ce">isLoopIndexVariable</a>(<a class="code" href="classSgInitializedName.html">SgInitializedName</a>* ivar, <a class="code" href="classSgNode.html">SgNode</a>* subtree_root);
<a name="l00884"></a>00884 
<a name="l00886"></a>00886 <a class="code" href="classSgStatement.html">SgStatement</a>* <a class="code" href="namespaceSageInterface.html#cdd84b0f648aacdf4d31692bbff98c42">getLoopBody</a>(<a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* loop);
<a name="l00887"></a>00887 
<a name="l00888"></a>00888 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#e79df849100431065061cb615b27b5e7">setLoopBody</a>(<a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* loop, <a class="code" href="classSgStatement.html">SgStatement</a>* body);
<a name="l00889"></a>00889 
<a name="l00891"></a>00891 <a class="code" href="classSgStatement.html">SgStatement</a>* <a class="code" href="namespaceSageInterface.html#8a48fa3afe244bdceaf9201f217d9873">getLoopCondition</a>(<a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* loop);
<a name="l00892"></a>00892 
<a name="l00894"></a>00894 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#3368c7c03cdd8fad0ff4dde8ac17a7bc">setLoopCondition</a>(<a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* loop, <a class="code" href="classSgStatement.html">SgStatement</a>* cond);
<a name="l00895"></a>00895 
<a name="l00899"></a>00899 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#8fee9383277837dceac3130968eb447a">isCanonicalForLoop</a>(<a class="code" href="classSgNode.html">SgNode</a>* loop, <a class="code" href="classSgInitializedName.html">SgInitializedName</a>** ivar=NULL, <a class="code" href="classSgExpression.html">SgExpression</a>** lb=NULL, <a class="code" href="classSgExpression.html">SgExpression</a>** ub=NULL, <a class="code" href="classSgExpression.html">SgExpression</a>** step=NULL, <a class="code" href="classSgStatement.html">SgStatement</a>** body=NULL, <span class="keywordtype">bool</span> *hasIncrementalIterationSpace = NULL, <span class="keywordtype">bool</span>* isInclusiveUpperBound = NULL);
<a name="l00900"></a>00900 
<a name="l00902"></a>00902 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#25ecfa1b43bb6bef8e6f0c4217206638">isCanonicalDoLoop</a>(<a class="code" href="classSgFortranDo.html">SgFortranDo</a>* loop,<a class="code" href="classSgInitializedName.html">SgInitializedName</a>** ivar<span class="comment">/*=NULL*/</span>, <a class="code" href="classSgExpression.html">SgExpression</a>** lb<span class="comment">/*=NULL*/</span>, <a class="code" href="classSgExpression.html">SgExpression</a>** ub<span class="comment">/*=NULL*/</span>, <a class="code" href="classSgExpression.html">SgExpression</a>** step<span class="comment">/*=NULL*/</span>, <a class="code" href="classSgStatement.html">SgStatement</a>** body<span class="comment">/*=NULL*/</span>, <span class="keywordtype">bool</span> *hasIncrementalIterationSpace<span class="comment">/*= NULL*/</span>, <span class="keywordtype">bool</span>* isInclusiveUpperBound<span class="comment">/*=NULL*/</span>);
<a name="l00903"></a>00903 
<a name="l00905"></a>00905 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#9def1f61dcf1d975ebd823f921dc4a92">setLoopLowerBound</a>(<a class="code" href="classSgNode.html">SgNode</a>* loop, <a class="code" href="classSgExpression.html">SgExpression</a>* lb);
<a name="l00906"></a>00906 
<a name="l00908"></a>00908 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#cc572630786f0e865742cc8274992e8b">setLoopUpperBound</a>(<a class="code" href="classSgNode.html">SgNode</a>* loop, <a class="code" href="classSgExpression.html">SgExpression</a>* ub);
<a name="l00909"></a>00909 
<a name="l00911"></a>00911 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#7ad626782e4cd15b81d486f1012e3944">setLoopStride</a>(<a class="code" href="classSgNode.html">SgNode</a>* loop, <a class="code" href="classSgExpression.html">SgExpression</a>* stride);
<a name="l00912"></a>00912 
<a name="l00913"></a>00913 
<a name="l00915"></a>00915 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#56ad0d54049c684d5af206864adf7390">normalizeForLoopInitDeclaration</a>(<a class="code" href="classSgForStatement.html">SgForStatement</a>* loop);
<a name="l00916"></a>00916 
<a name="l00928"></a>00928 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#a500ce86ded48ff840d829a33e08b0d6">forLoopNormalization</a>(<a class="code" href="classSgForStatement.html">SgForStatement</a>* loop);
<a name="l00929"></a>00929 
<a name="l00931"></a>00931 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#714c3bd1a8ad05aefd0a374f5449a975">doLoopNormalization</a>(<a class="code" href="classSgFortranDo.html">SgFortranDo</a>* loop);
<a name="l00932"></a>00932 
<a name="l00934"></a>00934 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#32c1cd741a34e12e81515e3e6e3ce6a1">loopUnrolling</a>(<a class="code" href="classSgForStatement.html">SgForStatement</a>* loop, size_t unrolling_factor);
<a name="l00935"></a>00935 
<a name="l00937"></a>00937 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#69c06c565033135bf031e02547d7ffd7">loopInterchange</a>(<a class="code" href="classSgForStatement.html">SgForStatement</a>* loop, size_t depth, size_t lexicoOrder);
<a name="l00938"></a>00938 
<a name="l00940"></a>00940 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#bf67276dd03b4d83fd53e8d17cfee342">loopTiling</a>(<a class="code" href="classSgForStatement.html">SgForStatement</a>* loopNest, size_t targetLevel, size_t tileSize);
<a name="l00941"></a>00941 
<a name="l00943"></a>00943 
<a name="l00944"></a>00944 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l00946"></a>00946 <span class="comment"></span>
<a name="l00950"></a>00950 
<a name="l00951"></a>00951 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NodeType&gt;
<a name="l00952"></a><a class="code" href="namespaceSageInterface.html#1123219ebb32a1140a1c10e73b97ca22">00952</a> std::vector&lt;NodeType*&gt; <a class="code" href="namespaceSageInterface.html#1123219ebb32a1140a1c10e73b97ca22">querySubTree</a>(<a class="code" href="classSgNode.html">SgNode</a>* top, <a class="code" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a> variant = (<a class="code" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a>)NodeType::static_variant)
<a name="l00953"></a>00953 {
<a name="l00954"></a>00954   Rose_STL_Container&lt;SgNode*&gt; nodes = <a class="code" href="namespaceSageInterface.html#1123219ebb32a1140a1c10e73b97ca22">NodeQuery::querySubTree</a>(top,variant);
<a name="l00955"></a>00955   std::vector&lt;NodeType*&gt; result(nodes.size(), NULL);
<a name="l00956"></a>00956   <span class="keywordtype">int</span> count = 0;
<a name="l00957"></a>00957   <span class="keywordflow">for</span> (Rose_STL_Container&lt;SgNode*&gt;::const_iterator i = nodes.begin();
<a name="l00958"></a>00958        i != nodes.end(); ++i, ++count) {
<a name="l00959"></a>00959     NodeType* node = dynamic_cast&lt;NodeType*&gt;(*i);
<a name="l00960"></a>00960     ROSE_ASSERT (node);
<a name="l00961"></a>00961     result[count] = node;
<a name="l00962"></a>00962   }
<a name="l00963"></a>00963   <span class="keywordflow">return</span> result;
<a name="l00964"></a>00964 }
<a name="l00969"></a>00969     std::vector &lt; SgFile * &gt;<a class="code" href="namespaceSageInterface.html#e033e337d88d92aa952932fdb077cbe4">generateFileList</a> ();
<a name="l00970"></a>00970 
<a name="l00972"></a>00972   <a class="code" href="classSgProject.html">SgProject</a> * <a class="code" href="namespaceSageInterface.html#c2c6c9fdb8ba0b9a21677e11014216cf">getProject</a>();
<a name="l00973"></a>00973 
<a name="l00975"></a>00975 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NodeType&gt;
<a name="l00976"></a><a class="code" href="namespaceSageInterface.html#71fa312dbb8ef1d9a37f6897de49fcce">00976</a> <span class="keyword">static</span> std::vector&lt;NodeType*&gt; <a class="code" href="namespaceSageInterface.html#71fa312dbb8ef1d9a37f6897de49fcce">getSgNodeListFromMemoryPool</a>()
<a name="l00977"></a>00977 {
<a name="l00978"></a>00978   <span class="comment">// This function uses a memory pool traversal specific to the SgFile IR nodes</span>
<a name="l00979"></a>00979   <span class="keyword">class </span>MyTraversal : <span class="keyword">public</span> <a class="code" href="classROSE__VisitTraversal.html">ROSE_VisitTraversal</a>
<a name="l00980"></a>00980   {
<a name="l00981"></a>00981     <span class="keyword">public</span>:
<a name="l00982"></a>00982       std::vector&lt;NodeType*&gt; resultlist;
<a name="l00983"></a>00983       <span class="keywordtype">void</span> visit ( <a class="code" href="classSgNode.html">SgNode</a>* node)
<a name="l00984"></a>00984       {
<a name="l00985"></a>00985         NodeType* result = dynamic_cast&lt;NodeType* &gt; (node);
<a name="l00986"></a>00986         ROSE_ASSERT(result!= NULL);
<a name="l00987"></a>00987         <span class="keywordflow">if</span> (result!= NULL)
<a name="l00988"></a>00988         {
<a name="l00989"></a>00989           resultlist.push_back(result);
<a name="l00990"></a>00990         }
<a name="l00991"></a>00991       };
<a name="l00992"></a>00992       <span class="keyword">virtual</span> ~MyTraversal() {}
<a name="l00993"></a>00993   };
<a name="l00994"></a>00994 
<a name="l00995"></a>00995   MyTraversal my_traversal;
<a name="l00996"></a>00996   NodeType::visitRepresentativeNode(my_traversal);
<a name="l00997"></a>00997   <span class="keywordflow">return</span> my_traversal.resultlist;
<a name="l00998"></a>00998 }
<a name="l00999"></a>00999 
<a name="l01000"></a>01000 
<a name="l01003"></a>01003 <a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>* <a class="code" href="namespaceSageInterface.html#0c4e4490c4d20ef7f32dd2d6459c7548">findMain</a>(<a class="code" href="classSgNode.html">SgNode</a>* currentNode);
<a name="l01004"></a>01004 
<a name="l01006"></a>01006 <a class="code" href="classSgStatement.html">SgStatement</a>* <a class="code" href="namespaceSageInterface.html#81e9af0e07a7ba45455e3a463d43ed9f">findLastDeclarationStatement</a>(<a class="code" href="classSgScopeStatement.html">SgScopeStatement</a> * scope);
<a name="l01007"></a>01007 
<a name="l01008"></a>01008           <span class="comment">//midend/programTransformation/partialRedundancyElimination/pre.h</span>
<a name="l01010"></a>01010 <span class="comment"></span>std::vector&lt;SgVariableSymbol*&gt; <a class="code" href="namespaceSageInterface.html#be2c3ab6716f418f4706960427c71545">getSymbolsUsedInExpression</a>(<a class="code" href="classSgExpression.html">SgExpression</a>* expr);
<a name="l01011"></a>01011 
<a name="l01013"></a>01013 
<a name="l01018"></a>01018 std::vector&lt;SgBreakStmt*&gt; <a class="code" href="namespaceSageInterface.html#b3fd7caa53c4504d7d668336d4be8097">findBreakStmts</a>(<a class="code" href="classSgStatement.html">SgStatement</a>* code, <span class="keyword">const</span> std::string&amp; fortranLabel = <span class="stringliteral">""</span>);
<a name="l01019"></a>01019 
<a name="l01021"></a>01021 
<a name="l01026"></a>01026   std::vector&lt;SgContinueStmt*&gt; <a class="code" href="namespaceSageInterface.html#d8f642bb83545acd486c40aeb6f3093f">findContinueStmts</a>(<a class="code" href="classSgStatement.html">SgStatement</a>* code, <span class="keyword">const</span> std::string&amp; fortranLabel = <span class="stringliteral">""</span>);
<a name="l01027"></a>01027   std::vector&lt;SgGotoStatement*&gt; <a class="code" href="namespaceSageInterface.html#c7ba7b7b9738ec66d5e39a0beb16e900">findGotoStmts</a>(<a class="code" href="classSgStatement.html">SgStatement</a>* scope, <a class="code" href="classSgLabelStatement.html">SgLabelStatement</a>* l);
<a name="l01028"></a>01028   std::vector&lt;SgStatement*&gt; <a class="code" href="namespaceSageInterface.html#51e681c5508ac6c664ed3dabdd230323">getSwitchCases</a>(<a class="code" href="classSgSwitchStatement.html">SgSwitchStatement</a>* sw);
<a name="l01029"></a>01029 
<a name="l01031"></a>01031   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01032"></a><a class="code" href="namespaceSageInterface.html#b36728bc3a9ee699fb33c04efbb1b553">01032</a>   T* <a class="code" href="namespaceSageInterface.html#b36728bc3a9ee699fb33c04efbb1b553">findDeclarationStatement</a>(<a class="code" href="classSgNode.html">SgNode</a>* root, std::string name, <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* scope, <span class="keywordtype">bool</span> isDefining)
<a name="l01033"></a>01033   {
<a name="l01034"></a>01034     <span class="keywordflow">if</span> (!root) <span class="keywordflow">return</span> 0;
<a name="l01035"></a>01035     T* decl = dynamic_cast&lt;T*&gt;(root);
<a name="l01036"></a>01036     <span class="keywordflow">if</span> (decl!=NULL)
<a name="l01037"></a>01037     {
<a name="l01038"></a>01038       <span class="keywordflow">if</span> (scope)
<a name="l01039"></a>01039       {
<a name="l01040"></a>01040         <span class="keywordflow">if</span> ((decl-&gt;get_scope() == scope)&amp;&amp;
<a name="l01041"></a>01041             (decl-&gt;search_for_symbol_from_symbol_table()-&gt;get_name()==name))
<a name="l01042"></a>01042           <span class="keywordflow">return</span> decl;
<a name="l01043"></a>01043       }
<a name="l01044"></a>01044       <span class="keywordflow">else</span> <span class="comment">// Liao 2/9/2010. We should allow NULL scope</span>
<a name="l01045"></a>01045       {
<a name="l01046"></a>01046         <span class="keywordflow">if</span>(decl-&gt;search_for_symbol_from_symbol_table()-&gt;get_name()==name)
<a name="l01047"></a>01047           <span class="keywordflow">return</span> decl;
<a name="l01048"></a>01048       }
<a name="l01049"></a>01049     }
<a name="l01050"></a>01050 
<a name="l01051"></a>01051     std::vector&lt;SgNode*&gt; children = root-&gt;<a class="code" href="classSgNode.html#8f2fdab2e0a2561e9cb2d783703a8598">get_traversalSuccessorContainer</a>();
<a name="l01052"></a>01052     <span class="keywordflow">for</span> (std::vector&lt;SgNode*&gt;::const_iterator i = children.begin();
<a name="l01053"></a>01053             i != children.end(); ++i)
<a name="l01054"></a>01054     {
<a name="l01055"></a>01055      T* target= findDeclarationStatement&lt;T&gt; (*i,name, scope, isDefining);
<a name="l01056"></a>01056      <span class="keywordflow">if</span> (target)
<a name="l01057"></a>01057        <span class="keywordflow">return</span> target;
<a name="l01058"></a>01058     }
<a name="l01059"></a>01059     <span class="keywordflow">return</span> 0;
<a name="l01060"></a>01060   }
<a name="l01062"></a>01062   <a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>* <a class="code" href="namespaceSageInterface.html#25ba093b55f9983f1f3c385563e1b880">findFunctionDeclaration</a>(<a class="code" href="classSgNode.html">SgNode</a>* root, std::string name, <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* scope, <span class="keywordtype">bool</span> isDefining);
<a name="l01063"></a>01063 
<a name="l01064"></a>01064 <span class="preprocessor">#if 0 //TODO</span>
<a name="l01065"></a>01065 <span class="preprocessor"></span>  <span class="comment">// 1. preorder traversal from current SgNode till find next SgNode of type V_SgXXX</span>
<a name="l01066"></a>01066   <span class="comment">//    until reach the end node</span>
<a name="l01067"></a>01067   <a class="code" href="classSgNode.html">SgNode</a>* getNextSgNode( <span class="keyword">const</span> <a class="code" href="classSgNode.html">SgNode</a>* astSourceNode, <a class="code" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a>=<a class="code" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e34648062f2aa917e9ced3b1ec2be779f40f2">V_SgNode</a>, <a class="code" href="classSgNode.html">SgNode</a>* astEndNode=NULL);
<a name="l01068"></a>01068 
<a name="l01069"></a>01069   <span class="comment">// 2. return all nodes of type VariantT following the source node</span>
<a name="l01070"></a>01070   std::vector&lt;SgNode*&gt; getAllNextSgNode( <span class="keyword">const</span> <a class="code" href="classSgNode.html">SgNode</a>* astSourceNode, <a class="code" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a>=<a class="code" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e34648062f2aa917e9ced3b1ec2be779f40f2">V_SgNode</a>, <a class="code" href="classSgNode.html">SgNode</a>* astEndNode=NULL);
<a name="l01071"></a>01071 <span class="preprocessor">#endif</span>
<a name="l01072"></a>01072 <span class="preprocessor"></span>
<a name="l01074"></a>01074 
<a name="l01075"></a>01075 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l01077"></a>01077 <span class="comment"></span>
<a name="l01080"></a>01080 <span class="comment">// remember to put const to all arguments.</span>
<a name="l01081"></a>01081 
<a name="l01082"></a>01082 
<a name="l01093"></a>01093 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NodeType&gt;
<a name="l01094"></a><a class="code" href="namespaceSageInterface.html#0e13c06070acba9a4028596b14df37c0">01094</a> NodeType* <a class="code" href="namespaceSageInterface.html#0e13c06070acba9a4028596b14df37c0">getEnclosingNode</a>(<span class="keyword">const</span> <a class="code" href="classSgNode.html">SgNode</a>* astNode, <span class="keyword">const</span> <span class="keywordtype">bool</span> includingSelf=<span class="keyword">false</span>)
<a name="l01095"></a>01095 {
<a name="l01096"></a>01096   <span class="keywordflow">if</span> (NULL==astNode)
<a name="l01097"></a>01097     <span class="keywordflow">return</span> NULL;
<a name="l01098"></a>01098   <span class="keywordflow">if</span> ((includingSelf)&amp;&amp;(dynamic_cast&lt;const NodeType*&gt;(astNode)))
<a name="l01099"></a>01099     <span class="keywordflow">return</span> const_cast&lt;NodeType*&gt;(dynamic_cast&lt;const NodeType*&gt; (astNode));
<a name="l01100"></a>01100 
<a name="l01101"></a>01101   <a class="code" href="classSgNode.html">SgNode</a>* parent = astNode-&gt;get_parent();
<a name="l01102"></a>01102   <span class="keywordflow">while</span> ((parent!=NULL)&amp;&amp;(!dynamic_cast&lt;const NodeType*&gt;(parent)))
<a name="l01103"></a>01103     parent = parent-&gt;get_parent();
<a name="l01104"></a>01104 
<a name="l01105"></a>01105   <span class="keywordflow">return</span> const_cast&lt;NodeType*&gt;(dynamic_cast&lt;const NodeType*&gt; (parent));
<a name="l01106"></a>01106 }
<a name="l01107"></a>01107 
<a name="l01109"></a>01109 <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* <a class="code" href="namespaceSageInterface.html#6ec13831a4d9c0142db2f595d56ce862">getScope</a>(<span class="keyword">const</span> <a class="code" href="classSgNode.html">SgNode</a>* astNode);
<a name="l01110"></a>01110 
<a name="l01112"></a>01112   <a class="code" href="classSgGlobal.html">SgGlobal</a>* <a class="code" href="namespaceSageInterface.html#108fb9317605cd9d1228cb156993e34d">getGlobalScope</a>( <span class="keyword">const</span> <a class="code" href="classSgNode.html">SgNode</a>* astNode);
<a name="l01113"></a>01113 
<a name="l01114"></a>01114 
<a name="l01116"></a>01116   <a class="code" href="classSgFunctionDefinition.html">SgFunctionDefinition</a>* <a class="code" href="namespaceSageInterface.html#3d1cde13da7917ba2ac6005d266f934d">getEnclosingProcedure</a>(<a class="code" href="classSgNode.html">SgNode</a>* n, <span class="keyword">const</span> <span class="keywordtype">bool</span> includingSelf=<span class="keyword">false</span>);
<a name="l01117"></a>01117 
<a name="l01118"></a>01118   <a class="code" href="classSgFunctionDefinition.html">SgFunctionDefinition</a>* <a class="code" href="namespaceSageInterface.html#89a3cd0446fb308e841a8844ec69f96e">getEnclosingFunctionDefinition</a>(<a class="code" href="classSgNode.html">SgNode</a>* astNode, <span class="keyword">const</span> <span class="keywordtype">bool</span> includingSelf=<span class="keyword">false</span>);
<a name="l01119"></a>01119 
<a name="l01121"></a>01121   <a class="code" href="classSgStatement.html">SgStatement</a>* <a class="code" href="namespaceSageInterface.html#5717c88c4a9675c30069319cfe913127">getEnclosingStatement</a>(<a class="code" href="classSgNode.html">SgNode</a>* n);
<a name="l01122"></a>01122 
<a name="l01124"></a>01124   <a class="code" href="classSgSwitchStatement.html">SgSwitchStatement</a>* <a class="code" href="namespaceSageInterface.html#ac586c26b215b6fb86a99370905e2044">findEnclosingSwitch</a>(<a class="code" href="classSgStatement.html">SgStatement</a>* s);
<a name="l01125"></a>01125 
<a name="l01127"></a>01127   <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* <a class="code" href="namespaceSageInterface.html#9fc733ce75b79e34e7c85c0e5b5b1d1a">findEnclosingLoop</a>(<a class="code" href="classSgStatement.html">SgStatement</a>* s, <span class="keyword">const</span> std::string&amp; fortranLabel = <span class="stringliteral">""</span>, <span class="keywordtype">bool</span> stopOnSwitches = <span class="keyword">false</span>);
<a name="l01128"></a>01128 
<a name="l01130"></a>01130   <a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> * <a class="code" href="namespaceSageInterface.html#ac9b45bdb148ec342cf14c95f39e64f9">getEnclosingFunctionDeclaration</a> (<a class="code" href="classSgNode.html">SgNode</a> * astNode, <span class="keyword">const</span> <span class="keywordtype">bool</span> includingSelf=<span class="keyword">false</span>);
<a name="l01131"></a>01131    <span class="comment">//roseSupport/utility_functions.h</span>
<a name="l01133"></a>01133 <span class="comment"></span>  <a class="code" href="classSgFile.html">SgFile</a>* <a class="code" href="namespaceSageInterface.html#73600ebdd020f6ffed566018c22e20b8">getEnclosingFileNode</a> (<a class="code" href="classSgNode.html">SgNode</a>* astNode );
<a name="l01134"></a>01134 
<a name="l01136"></a>01136   <a class="code" href="classSgInitializer.html">SgInitializer</a>* <a class="code" href="namespaceSageInterface.html#a7ab26b36b4ddffb9db2c7f2160322c8">getInitializerOfExpression</a>(<a class="code" href="classSgExpression.html">SgExpression</a>* n);
<a name="l01137"></a>01137 
<a name="l01139"></a>01139   <a class="code" href="classSgClassDefinition.html">SgClassDefinition</a>* <a class="code" href="namespaceSageInterface.html#f3212dbf1eb743a7f9cd2ed35142cd5f">getEnclosingClassDefinition</a>(<a class="code" href="classSgNode.html">SgNode</a>* astnode, <span class="keyword">const</span> <span class="keywordtype">bool</span> includingSelf=<span class="keyword">false</span>);
<a name="l01140"></a>01140 
<a name="l01141"></a>01141 <span class="comment">// TODO</span>
<a name="l01142"></a>01142 <span class="preprocessor">#if 0</span>
<a name="l01143"></a>01143 <span class="preprocessor"></span>   <a class="code" href="classSgNode.html">SgNode</a> * getEnclosingSgNode(<a class="code" href="classSgNode.html">SgNode</a>* source,<a class="code" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a>, <a class="code" href="classSgNode.html">SgNode</a>* endNode=NULL);
<a name="l01144"></a>01144    std::vector&lt;SgNode *&gt;  getAllEnclosingSgNode(<a class="code" href="classSgNode.html">SgNode</a>* source,<a class="code" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a>, <a class="code" href="classSgNode.html">SgNode</a>* endNode=NULL);
<a name="l01145"></a>01145    <a class="code" href="classSgVariableDeclaration.html">SgVariableDeclaration</a>* findVariableDeclaratin( <span class="keyword">const</span> string&amp; varname)
<a name="l01146"></a>01146 
<a name="l01147"></a>01147    <a class="code" href="classSgClassDeclaration.html">SgClassDeclaration</a>* getEnclosingClassDeclaration( <span class="keyword">const</span> <a class="code" href="classSgNode.html">SgNode</a>* astNode);
<a name="l01148"></a>01148 
<a name="l01149"></a>01149    <span class="comment">// e.g. for some expression, find its parent statement</span>
<a name="l01150"></a>01150    <a class="code" href="classSgStatement.html">SgStatement</a>* <a class="code" href="namespaceSageInterface.html#5717c88c4a9675c30069319cfe913127">getEnclosingStatement</a>(<span class="keyword">const</span> <a class="code" href="classSgNode.html">SgNode</a>* astNode);
<a name="l01151"></a>01151 
<a name="l01152"></a>01152    <a class="code" href="classSgSwitchStatement.html">SgSwitchStatement</a>* getEnclosingSwitch(<a class="code" href="classSgStatement.html">SgStatement</a>* s);
<a name="l01153"></a>01153    <a class="code" href="classSgModuleStatement.html">SgModuleStatement</a>* getEnclosingModuleStatement( <span class="keyword">const</span> <a class="code" href="classSgNode.html">SgNode</a>* astNode);
<a name="l01154"></a>01154 
<a name="l01155"></a>01155   <span class="comment">// used to build a variable reference for compiler generated code in current scope</span>
<a name="l01156"></a>01156    <a class="code" href="classSgSymbol.html">SgSymbol</a> * findReachingDefinition (<a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* startScope, <a class="code" href="classSgName.html">SgName</a> &amp;name);
<a name="l01157"></a>01157 <span class="preprocessor">#endif</span>
<a name="l01158"></a>01158 <span class="preprocessor"></span>
<a name="l01159"></a>01159 
<a name="l01160"></a>01160 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l01162"></a>01162 <span class="comment"></span>
<a name="l01165"></a>01165   <span class="comment">// Liao, 1/9/2008</span>
<a name="l01169"></a>01169 <span class="comment"></span>  <a class="code" href="classSgGlobal.html">SgGlobal</a> * <a class="code" href="namespaceSageInterface.html#b45dc06ff0224928a1ae1da997e52b08">getFirstGlobalScope</a>(<a class="code" href="classSgProject.html">SgProject</a> *<a class="code" href="namespacecfgUtils.html#ce4abf2beca5826144d69d3a0283050f">project</a>);
<a name="l01170"></a>01170 
<a name="l01174"></a>01174   <a class="code" href="classSgStatement.html">SgStatement</a>* <a class="code" href="namespaceSageInterface.html#4ad89114f9b3edc1d78c4ed0361b7b8c">getLastStatement</a>(<a class="code" href="classSgScopeStatement.html">SgScopeStatement</a> *scope);
<a name="l01175"></a>01175 
<a name="l01177"></a>01177   <a class="code" href="classSgStatement.html">SgStatement</a>* <a class="code" href="namespaceSageInterface.html#2b15b529d2da9a8b370adc56def709fb">getFirstStatement</a>(<a class="code" href="classSgScopeStatement.html">SgScopeStatement</a> *scope,<span class="keywordtype">bool</span> includingCompilerGenerated=<span class="keyword">false</span>);
<a name="l01179"></a>01179   <a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>* <a class="code" href="namespaceSageInterface.html#d3bb1a781eb5b2ece057e620dcc3f83c">findFirstDefiningFunctionDecl</a>(<a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* scope);
<a name="l01180"></a>01180 
<a name="l01182"></a>01182   <a class="code" href="classSgStatement.html">SgStatement</a>* <a class="code" href="namespaceSageInterface.html#514decfd76850247d4e84d54f88ce1c9">getNextStatement</a>(<a class="code" href="classSgStatement.html">SgStatement</a> * currentStmt);
<a name="l01183"></a>01183 
<a name="l01185"></a>01185   <a class="code" href="classSgStatement.html">SgStatement</a>* <a class="code" href="namespaceSageInterface.html#1f85e0ded2e249c9e54b4204eeeed113">getPreviousStatement</a>(<a class="code" href="classSgStatement.html">SgStatement</a> * currentStmt);
<a name="l01186"></a>01186 <span class="preprocessor">#if 0 //TODO</span>
<a name="l01187"></a>01187 <span class="preprocessor"></span>  <span class="comment">// preorder traversal from current SgNode till find next SgNode of type V_SgXXX</span>
<a name="l01188"></a>01188   <a class="code" href="classSgNode.html">SgNode</a>* getNextSgNode( <span class="keyword">const</span> <a class="code" href="classSgNode.html">SgNode</a>* currentNode, <a class="code" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a>=<a class="code" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e34648062f2aa917e9ced3b1ec2be779f40f2">V_SgNode</a>);
<a name="l01189"></a>01189 <span class="preprocessor">#endif</span>
<a name="l01190"></a>01190 <span class="preprocessor"></span>
<a name="l01191"></a>01191 
<a name="l01192"></a>01192 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l01194"></a>01194 <span class="comment"></span>
<a name="l01197"></a>01197 
<a name="l01198"></a>01198  <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#6b16a27989aff98b861e3a677563ae42">isEqualToIntConst</a>(<a class="code" href="classSgExpression.html">SgExpression</a>* e, <span class="keywordtype">int</span> value);
<a name="l01199"></a>01199 
<a name="l01201"></a>01201 
<a name="l01204"></a>01204  <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#2ad29ecfbbcca49188ceb7468e91ae74">isSameFunction</a>(<a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>* func1, <a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>* func2);
<a name="l01205"></a>01205 
<a name="l01207"></a>01207  <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#01df9113c49dfbd3f7145e9a8259d125">isLastStatement</a>(<a class="code" href="classSgStatement.html">SgStatement</a>* stmt);
<a name="l01208"></a>01208 
<a name="l01210"></a>01210 
<a name="l01211"></a>01211 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l01213"></a>01213 <span class="comment"></span>
<a name="l01219"></a>01219 <span class="comment">// DQ (2/24/2009): Simple function to delete an AST subtree (used in outlining).</span>
<a name="l01221"></a>01221 <span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#57437bbbb806858dda0cea7444fbafef">deleteAST</a>(<a class="code" href="classSgNode.html">SgNode</a>* node);
<a name="l01222"></a>01222 
<a name="l01224"></a>01224  <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#062f0bab3b5deef80a101471d2bc0c0e">deleteExpressionTreeWithOriginalExpressionSubtrees</a>(<a class="code" href="classSgNode.html">SgNode</a>* root);
<a name="l01225"></a>01225 
<a name="l01226"></a>01226 <span class="comment">// DQ (2/25/2009): Added new function to support outliner.</span>
<a name="l01228"></a>01228 <span class="comment"></span> <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#d74e38bddc8dc4d5d0506102782680ef">moveStatementsBetweenBlocks</a> ( <a class="code" href="classSgBasicBlock.html">SgBasicBlock</a>* sourceBlock, <a class="code" href="classSgBasicBlock.html">SgBasicBlock</a>* targetBlock );
<a name="l01229"></a>01229 
<a name="l01230"></a>01230 
<a name="l01232"></a>01232 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#bd2b74fa3c7de0b27066790dfba32ab7">appendStatement</a>(<a class="code" href="classSgStatement.html">SgStatement</a> *stmt, <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* scope=NULL);
<a name="l01233"></a>01233 
<a name="l01235"></a>01235 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#dc3d212ae841c07933c40e4235b4f0a9">appendStatementList</a>(<span class="keyword">const</span> std::vector&lt;SgStatement*&gt;&amp; stmt, <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* scope=NULL);
<a name="l01236"></a>01236 
<a name="l01237"></a>01237 <span class="comment">// DQ (2/6/2009): Added function to support outlining into separate file.</span>
<a name="l01239"></a>01239 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#6d20d118b27ab3675c748d6adb2ac467">appendStatementWithDependentDeclaration</a>( <a class="code" href="classSgDeclarationStatement.html">SgDeclarationStatement</a>* decl, <a class="code" href="classSgGlobal.html">SgGlobal</a>* scope, <a class="code" href="classSgStatement.html">SgStatement</a>* original_statement, <span class="keywordtype">bool</span> excludeHeaderFiles );
<a name="l01240"></a>01240 
<a name="l01243"></a>01243 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#e9c30cd9d9c2589e9534638c7a79e731">prependStatement</a>(<a class="code" href="classSgStatement.html">SgStatement</a> *stmt, <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* scope=NULL);
<a name="l01244"></a>01244 
<a name="l01247"></a>01247 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#150082ead31a73a3cd272f7428521823">prependStatementList</a>(<span class="keyword">const</span> std::vector&lt;SgStatement*&gt;&amp; stmt, <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* scope=NULL);
<a name="l01248"></a>01248 
<a name="l01252"></a>01252 <span class="keywordtype">bool</span>  <a class="code" href="namespaceSageInterface.html#e41c86d0aefd60c26c60bd6f0ec4b76b">hasSimpleChildrenList</a> (<a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* scope);
<a name="l01253"></a>01253 
<a name="l01255"></a>01255 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#54e6780cc15a76ce7bc37a1212452e66">insertStatement</a>(<a class="code" href="classSgStatement.html">SgStatement</a> *targetStmt, <a class="code" href="classSgStatement.html">SgStatement</a>* newStmt, <span class="keywordtype">bool</span> insertBefore= <span class="keyword">true</span>, <span class="keywordtype">bool</span> autoMovePreprocessingInfo = <span class="keyword">true</span>);
<a name="l01256"></a>01256 
<a name="l01258"></a>01258 <span class="comment">//target's scope</span>
<a name="l01259"></a>01259 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#07fb69a12095f93a9cbe325fe5a8b7d2">insertStatementList</a>(<a class="code" href="classSgStatement.html">SgStatement</a> *targetStmt, <span class="keyword">const</span> std::vector&lt;SgStatement*&gt;&amp; newStmts, <span class="keywordtype">bool</span> insertBefore= <span class="keyword">true</span>);
<a name="l01260"></a>01260 
<a name="l01262"></a>01262 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#dab9927218b2709b3d99544db4386dc2">insertStatementBefore</a>(<a class="code" href="classSgStatement.html">SgStatement</a> *targetStmt, <a class="code" href="classSgStatement.html">SgStatement</a>* newStmt, <span class="keywordtype">bool</span> autoMovePreprocessingInfo = <span class="keyword">true</span>);
<a name="l01263"></a>01263 
<a name="l01265"></a>01265 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#193b6b847675d342d37b9917bf0a3f43">insertStatementListBefore</a>(<a class="code" href="classSgStatement.html">SgStatement</a> *targetStmt, <span class="keyword">const</span> std::vector&lt;SgStatement*&gt;&amp; newStmts);
<a name="l01266"></a>01266 
<a name="l01268"></a>01268 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#f43f1edd321a11e4a9d6fd6cf8b4bcd6">insertStatementAfter</a>(<a class="code" href="classSgStatement.html">SgStatement</a> *targetStmt, <a class="code" href="classSgStatement.html">SgStatement</a>* newStmt, <span class="keywordtype">bool</span> autoMovePreprocessingInfo = <span class="keyword">true</span>);
<a name="l01269"></a>01269 
<a name="l01271"></a>01271 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#4c7e8d91522f9c76e28d35bcd76a07e6">insertStatementListAfter</a>(<a class="code" href="classSgStatement.html">SgStatement</a> *targetStmt, <span class="keyword">const</span> std::vector&lt;SgStatement*&gt;&amp; newStmt);
<a name="l01272"></a>01272 
<a name="l01274"></a>01274 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#918939111ad1510bfc0c520156e8d9e9">insertStatementAfterLastDeclaration</a>(<a class="code" href="classSgStatement.html">SgStatement</a>* stmt, <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* scope);
<a name="l01275"></a>01275 
<a name="l01277"></a>01277 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#918939111ad1510bfc0c520156e8d9e9">insertStatementAfterLastDeclaration</a>(std::vector&lt;SgStatement*&gt; stmt_list, <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* scope);
<a name="l01278"></a>01278 
<a name="l01280"></a>01280 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#f5972a33cb2e9b5723e50ceccdaccb9f">removeStatement</a>(<a class="code" href="classSgStatement.html">SgStatement</a>* stmt, <span class="keywordtype">bool</span> autoRelocatePreprocessingInfo = <span class="keyword">true</span>);
<a name="l01281"></a>01281 
<a name="l01283"></a>01283 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#03bd60c658db463cfc3791a7bba5017a">deepDelete</a>(<a class="code" href="classSgNode.html">SgNode</a>* root);
<a name="l01284"></a>01284 
<a name="l01286"></a>01286 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#69827cb64e737fdc661a48871c92ec96">replaceStatement</a>(<a class="code" href="classSgStatement.html">SgStatement</a>* oldStmt, <a class="code" href="classSgStatement.html">SgStatement</a>* newStmt, <span class="keywordtype">bool</span> movePreprocessinInfo = <span class="keyword">false</span>);
<a name="l01287"></a>01287 
<a name="l01289"></a>01289 <a class="code" href="classSgNode.html">SgNode</a>* <a class="code" href="namespaceSageInterface.html#40eb9c7f467b4e0830bae948562d2d89">replaceWithPattern</a> (<a class="code" href="classSgNode.html">SgNode</a> * anchor, <a class="code" href="classSgNode.html">SgNode</a>* new_pattern);
<a name="l01290"></a>01290 
<a name="l01301"></a>01301 std::pair&lt;SgVariableDeclaration*, SgExpression* &gt; <a class="code" href="namespaceSageInterface.html#8b8089083afe0aca12b1c9ba64d4ddc6">createTempVariableForExpression</a>(<a class="code" href="classSgExpression.html">SgExpression</a>* expression,
<a name="l01302"></a>01302         <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* scope, <span class="keywordtype">bool</span> initializeInDeclaration, <a class="code" href="classSgAssignOp.html">SgAssignOp</a>** reEvaluate = NULL);
<a name="l01303"></a>01303 
<a name="l01305"></a>01305 
<a name="l01309"></a>01309 <a class="code" href="classSgVariableSymbol.html">SgVariableSymbol</a>* <a class="code" href="namespaceSageInterface.html#ef8223b9741c08bb50c4ee85e04bbe16">appendArg</a>(<a class="code" href="classSgFunctionParameterList.html">SgFunctionParameterList</a> *, <a class="code" href="classSgInitializedName.html">SgInitializedName</a>*);
<a name="l01311"></a>01311 <a class="code" href="classSgVariableSymbol.html">SgVariableSymbol</a>* <a class="code" href="namespaceSageInterface.html#e997b353e050f84a2e1663e2b0945efa">prependArg</a>(<a class="code" href="classSgFunctionParameterList.html">SgFunctionParameterList</a> *, <a class="code" href="classSgInitializedName.html">SgInitializedName</a>*);
<a name="l01312"></a>01312 
<a name="l01314"></a>01314 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#e81668e6c7307d8cc9ad38de73282102">appendExpression</a>(<a class="code" href="classSgExprListExp.html">SgExprListExp</a> *, <a class="code" href="classSgExpression.html">SgExpression</a>*);
<a name="l01315"></a>01315 
<a name="l01317"></a>01317 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#19c6d987024cdb9c93f33181928beaff">appendExpressionList</a>(<a class="code" href="classSgExprListExp.html">SgExprListExp</a> *, <span class="keyword">const</span> std::vector&lt;SgExpression*&gt;&amp;);
<a name="l01318"></a>01318 
<a name="l01320"></a>01320 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#e4200b6d287e2c5b2d7a4d382f110863">setParameterList</a>(<a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *func,<a class="code" href="classSgFunctionParameterList.html">SgFunctionParameterList</a> *paralist);
<a name="l01321"></a>01321 
<a name="l01323"></a>01323 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#60d9ec8400d43be2985ea888afb69989">setPragma</a>(<a class="code" href="classSgPragmaDeclaration.html">SgPragmaDeclaration</a>* decl, <a class="code" href="classSgPragma.html">SgPragma</a> *pragma);
<a name="l01324"></a>01324 
<a name="l01326"></a>01326 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#ba697ba095a90c110e020e411fd8158f">replaceExpression</a>(<a class="code" href="classSgExpression.html">SgExpression</a>* oldExp, <a class="code" href="classSgExpression.html">SgExpression</a>* newExp, <span class="keywordtype">bool</span> keepOldExp=<span class="keyword">false</span>);
<a name="l01327"></a>01327 
<a name="l01329"></a>01329 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#d85460fd6c32e78e4dda28984b0ab541">replaceExpressionWithStatement</a>(<a class="code" href="classSgExpression.html">SgExpression</a>* from,
<a name="l01330"></a>01330                                     <a class="code" href="classSageInterface_1_1StatementGenerator.html">SageInterface::StatementGenerator</a>* to);
<a name="l01333"></a>01333 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#c8ce4794f2e0212a315bceb252fe93f2">replaceSubexpressionWithStatement</a>(<a class="code" href="classSgExpression.html">SgExpression</a>* from,
<a name="l01334"></a>01334                                       <a class="code" href="classSageInterface_1_1StatementGenerator.html">SageInterface::StatementGenerator</a>* to);
<a name="l01335"></a>01335 
<a name="l01337"></a>01337 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#abfd7a4f3af02dea61f7f808d0e60783">setOperand</a>(<a class="code" href="classSgExpression.html">SgExpression</a>* target, <a class="code" href="classSgExpression.html">SgExpression</a>* operand);
<a name="l01338"></a>01338 
<a name="l01340"></a>01340 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#78098fceed35539df0aa51de3baba983">setLhsOperand</a>(<a class="code" href="classSgExpression.html">SgExpression</a>* target, <a class="code" href="classSgExpression.html">SgExpression</a>* lhs);
<a name="l01341"></a>01341 
<a name="l01343"></a>01343 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#c30b58bb417c3b495f24207c81966716">setRhsOperand</a>(<a class="code" href="classSgExpression.html">SgExpression</a>* target, <a class="code" href="classSgExpression.html">SgExpression</a>* rhs);
<a name="l01344"></a>01344 
<a name="l01346"></a>01346 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#76cf388fb6b43807542edf737bb97a96">removeAllOriginalExpressionTrees</a>(<a class="code" href="classSgNode.html">SgNode</a>* top);
<a name="l01347"></a>01347 
<a name="l01348"></a>01348 <span class="comment">// DQ (1/25/2010): Added support for directories</span>
<a name="l01350"></a>01350 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#e348901720d34fdb3f333e552bcd5253">moveToSubdirectory</a> ( std::string directoryName, <a class="code" href="classSgFile.html">SgFile</a>* file );
<a name="l01351"></a>01351 
<a name="l01353"></a>01353 <a class="code" href="classSgStatement.html">SgStatement</a>* <a class="code" href="namespaceSageInterface.html#5b68578da4f96a5e644cfcb129a7e3dd">findSurroundingStatementFromSameFile</a>(<a class="code" href="classSgStatement.html">SgStatement</a>* targetStmt, <span class="keywordtype">bool</span> &amp; surroundingStatementPreceedsTargetStatement);
<a name="l01354"></a>01354 
<a name="l01356"></a>01356    <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#accbb223ed5b025766c10745793d39c6">moveCommentsToNewStatement</a>(<a class="code" href="classSgStatement.html">SgStatement</a>* sourceStatement, <span class="keyword">const</span> std::vector&lt;int&gt; &amp; indexList, <a class="code" href="classSgStatement.html">SgStatement</a>* targetStatement, <span class="keywordtype">bool</span> surroundingStatementPreceedsTargetStatement);
<a name="l01357"></a>01357 
<a name="l01359"></a>01359 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l01361"></a>01361 <span class="comment"></span>
<a name="l01368"></a>01368 
<a name="l01369"></a>01369 
<a name="l01374"></a>01374 <span class="keywordtype">int</span> <a class="code" href="namespaceSageInterface.html#bc07365980c33e6d4f3cca65b2e73970">fixVariableReferences</a>(<a class="code" href="classSgNode.html">SgNode</a>* root);
<a name="l01375"></a>01375 
<a name="l01377"></a>01377 
<a name="l01381"></a>01381 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#c56e358f18815a86ca4c9ad738733d37">fixVariableDeclaration</a>(<a class="code" href="classSgVariableDeclaration.html">SgVariableDeclaration</a>* varDecl, <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* scope);
<a name="l01382"></a>01382 
<a name="l01384"></a>01384 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#198dfdbeffb7cb4e282c0045de88b29d">fixStructDeclaration</a>(<a class="code" href="classSgClassDeclaration.html">SgClassDeclaration</a>* structDecl, <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* scope);
<a name="l01386"></a>01386 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#4e2216ac11843189037ddb386cadbe9f">fixClassDeclaration</a>(<a class="code" href="classSgClassDeclaration.html">SgClassDeclaration</a>* classDecl, <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* scope);
<a name="l01387"></a>01387 
<a name="l01389"></a>01389 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#0605947f38a73309b695c2511a6a008b">fixNamespaceDeclaration</a>(<a class="code" href="classSgNamespaceDeclarationStatement.html">SgNamespaceDeclarationStatement</a>* structDecl, <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* scope);
<a name="l01390"></a>01390 
<a name="l01391"></a>01391 
<a name="l01393"></a>01393 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#d8449795585ef098dedd58658b4ea265">fixLabelStatement</a>(<a class="code" href="classSgLabelStatement.html">SgLabelStatement</a>* label_stmt, <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* scope);
<a name="l01394"></a>01394 
<a name="l01396"></a>01396 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#221ee5cf1957c22f8e37d2fa1ab96c68">setFortranNumericLabel</a>(<a class="code" href="classSgStatement.html">SgStatement</a>* stmt, <span class="keywordtype">int</span> label_value);
<a name="l01397"></a>01397 
<a name="l01399"></a>01399 <span class="keywordtype">int</span>  <a class="code" href="namespaceSageInterface.html#79b07f8a7d66fc51a0648df2940a5bf4">suggestNextNumericLabel</a>(<a class="code" href="classSgFunctionDefinition.html">SgFunctionDefinition</a>* func_def);
<a name="l01400"></a>01400 
<a name="l01402"></a>01402 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#2410a8e2fc7310bd63c24d10b91594a3">fixStatement</a>(<a class="code" href="classSgStatement.html">SgStatement</a>* stmt, <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* scope);
<a name="l01404"></a>01404 
<a name="l01406"></a>01406 
<a name="l01411"></a>01411 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#7ee71882b367869506de6382d1b09cc2">updateDefiningNondefiningLinks</a>(<a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>* func, <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* scope);
<a name="l01412"></a>01412 
<a name="l01413"></a>01413 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l01415"></a>01415 <span class="comment"></span>
<a name="l01419"></a>01419 
<a name="l01420"></a>01420 <span class="keywordtype">bool</span>
<a name="l01421"></a>01421 <a class="code" href="namespaceSageInterface.html#2f9dadd01d12ecdc779071da95843b83">collectReadWriteRefs</a>(<a class="code" href="classSgStatement.html">SgStatement</a>* stmt, std::vector&lt;SgNode*&gt;&amp; readRefs, std::vector&lt;SgNode*&gt;&amp; writeRefs);
<a name="l01422"></a>01422 
<a name="l01424"></a>01424 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#11498284f603a3a574f02df0f44216b8">collectReadWriteVariables</a>(<a class="code" href="classSgStatement.html">SgStatement</a>* stmt, std::set&lt;SgInitializedName*&gt;&amp; readVars, std::set&lt;SgInitializedName*&gt;&amp; writeVars);
<a name="l01425"></a>01425 
<a name="l01427"></a>01427 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#3dc3524267c97a90f85d723b462e4e8a">collectReadOnlyVariables</a>(<a class="code" href="classSgStatement.html">SgStatement</a>* stmt, std::set&lt;SgInitializedName*&gt;&amp; readOnlyVars);
<a name="l01428"></a>01428 
<a name="l01430"></a>01430 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#7b50fd79f9c2175fea1fcfd8d66e8a7d">collectReadOnlySymbols</a>(<a class="code" href="classSgStatement.html">SgStatement</a>* stmt, std::set&lt;SgVariableSymbol*&gt;&amp; readOnlySymbols);
<a name="l01431"></a>01431 
<a name="l01433"></a>01433 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#b854982b76a15a37881e460327d45b63">isUseByAddressVariableRef</a>(<a class="code" href="classSgVarRefExp.html">SgVarRefExp</a>* ref);
<a name="l01434"></a>01434 
<a name="l01436"></a>01436 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#cff1c2e7a141a6360ad735dbe7d4dec8">collectUseByAddressVariableRefs</a> (<span class="keyword">const</span> <a class="code" href="classSgStatement.html">SgStatement</a>* s, std::set&lt;SgVarRefExp* &gt;&amp; varSetB);
<a name="l01437"></a>01437 
<a name="l01438"></a>01438 <span class="preprocessor">#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT</span>
<a name="l01440"></a>01440 <span class="preprocessor">LivenessAnalysis * call_liveness_analysis(SgProject* project, bool debug=false);</span>
<a name="l01441"></a>01441 <span class="preprocessor"></span>
<a name="l01443"></a>01443 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#7f94ad31631659aacacfe540a97bcb11">getLiveVariables</a>(LivenessAnalysis * liv, <a class="code" href="classSgForStatement.html">SgForStatement</a>* loop, std::set&lt;SgInitializedName*&gt;&amp; liveIns, std::set&lt;SgInitializedName*&gt; &amp; liveOuts);
<a name="l01444"></a>01444 <span class="preprocessor">#endif</span>
<a name="l01445"></a>01445 <span class="preprocessor"></span>
<a name="l01447"></a>01447 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#a3155e7a4a833e87637709baecd5638d">ReductionRecognition</a>(<a class="code" href="classSgForStatement.html">SgForStatement</a>* loop, std::set&lt; std::pair &lt;SgInitializedName*, VariantT&gt; &gt; &amp; results);
<a name="l01448"></a>01448 
<a name="l01450"></a>01450 
<a name="l01451"></a>01451 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#6f1a171284027fd38c91507a33a12023">constantFolding</a>(<a class="code" href="classSgNode.html">SgNode</a>* r);
<a name="l01452"></a>01452 
<a name="l01454"></a>01454 
<a name="l01456"></a>01456 <span class="keywordtype">int</span> <a class="code" href="namespaceSageInterface.html#4087541939de003c4cfb4a51e8ae4737">instrumentEndOfFunction</a>(<a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> * func, <a class="code" href="classSgStatement.html">SgStatement</a>* s);
<a name="l01457"></a>01457 
<a name="l01459"></a>01459 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#b3b17e2ceead1e6fcbe2671d795859e0">removeJumpsToNextStatement</a>(<a class="code" href="classSgNode.html">SgNode</a>*);
<a name="l01460"></a>01460 
<a name="l01462"></a>01462 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#1cf3641ce21620223f92f3b00477a50b">removeUnusedLabels</a>(<a class="code" href="classSgNode.html">SgNode</a>* top);
<a name="l01463"></a>01463 
<a name="l01465"></a>01465 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#e674125d5affe065c68f6540217b544c">removeConsecutiveLabels</a>(<a class="code" href="classSgNode.html">SgNode</a>* top);
<a name="l01466"></a>01466 
<a name="l01468"></a>01468 
<a name="l01475"></a>01475  <a class="code" href="classSgAssignInitializer.html">SgAssignInitializer</a>* <a class="code" href="namespaceSageInterface.html#9a28f3454dc1161d208d0eafa27267d5">splitExpression</a>(<a class="code" href="classSgExpression.html">SgExpression</a>* from, std::string newName = <span class="stringliteral">""</span>);
<a name="l01476"></a>01476 
<a name="l01478"></a>01478 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#c6a4105eaf9ecae213078b24d5dfc69f">splitExpressionIntoBasicBlock</a>(<a class="code" href="classSgExpression.html">SgExpression</a>* expr);
<a name="l01479"></a>01479 
<a name="l01481"></a>01481 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#72277a774aaa30427c7ba19a5ae0e64e">removeLabeledGotos</a>(<a class="code" href="classSgNode.html">SgNode</a>* top);
<a name="l01482"></a>01482 
<a name="l01484"></a>01484 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#2e6c3a91ffcb6a4a8e0a26dd39170498">changeBreakStatementsToGotos</a>(<a class="code" href="classSgStatement.html">SgStatement</a>* loopOrSwitch);
<a name="l01485"></a>01485 
<a name="l01487"></a>01487 <a class="code" href="classSgBasicBlock.html">SgBasicBlock</a>* <a class="code" href="namespaceSageInterface.html#a9363b5ef0fa341b6a69f3143010d03f">ensureBasicBlockAsBodyOfFor</a>(<a class="code" href="classSgForStatement.html">SgForStatement</a>* fs);
<a name="l01488"></a>01488 
<a name="l01490"></a>01490 <a class="code" href="classSgBasicBlock.html">SgBasicBlock</a>* <a class="code" href="namespaceSageInterface.html#4b91f29c299fd9d36d23215caca641a9">ensureBasicBlockAsBodyOfUpcForAll</a>(<a class="code" href="classSgUpcForAllStatement.html">SgUpcForAllStatement</a>* fs);
<a name="l01491"></a>01491 
<a name="l01493"></a>01493 <a class="code" href="classSgBasicBlock.html">SgBasicBlock</a>* <a class="code" href="namespaceSageInterface.html#b420709b668cbcb97caaa2ba7a311047">ensureBasicBlockAsBodyOfWhile</a>(<a class="code" href="classSgWhileStmt.html">SgWhileStmt</a>* ws);
<a name="l01494"></a>01494 
<a name="l01496"></a>01496 <a class="code" href="classSgBasicBlock.html">SgBasicBlock</a>* <a class="code" href="namespaceSageInterface.html#10f7e44426ec5cc6cf4878a9f8f3737b">ensureBasicBlockAsBodyOfDoWhile</a>(<a class="code" href="classSgDoWhileStmt.html">SgDoWhileStmt</a>* ws);
<a name="l01497"></a>01497 
<a name="l01499"></a>01499 <a class="code" href="classSgBasicBlock.html">SgBasicBlock</a>* <a class="code" href="namespaceSageInterface.html#2ee0c40fe00b9aa2e33f07a1f63d1c78">ensureBasicBlockAsBodyOfSwitch</a>(<a class="code" href="classSgSwitchStatement.html">SgSwitchStatement</a>* ws);
<a name="l01500"></a>01500 
<a name="l01502"></a>01502 <a class="code" href="classSgBasicBlock.html">SgBasicBlock</a>* <a class="code" href="namespaceSageInterface.html#5dddc30ac598e407d4b675b48817321a">ensureBasicBlockAsTrueBodyOfIf</a>(<a class="code" href="classSgIfStmt.html">SgIfStmt</a>* ifs);
<a name="l01503"></a>01503 
<a name="l01505"></a>01505 <a class="code" href="classSgBasicBlock.html">SgBasicBlock</a>* <a class="code" href="namespaceSageInterface.html#a0d91d1274666339221f3186847d220a">ensureBasicBlockAsFalseBodyOfIf</a>(<a class="code" href="classSgIfStmt.html">SgIfStmt</a>* ifs);
<a name="l01506"></a>01506 
<a name="l01508"></a>01508 <a class="code" href="classSgBasicBlock.html">SgBasicBlock</a>* <a class="code" href="namespaceSageInterface.html#273d390c4b54e9dc4c02c4806b3747a5">ensureBasicBlockAsBodyOfCatch</a>(<a class="code" href="classSgCatchOptionStmt.html">SgCatchOptionStmt</a>* cos);
<a name="l01509"></a>01509 
<a name="l01511"></a>01511 <a class="code" href="classSgBasicBlock.html">SgBasicBlock</a>* <a class="code" href="namespaceSageInterface.html#0434e3f30f7426d0ff371c936b2f1e5e">ensureBasicBlockAsBodyOfOmpBodyStmt</a>(<a class="code" href="classSgOmpBodyStatement.html">SgOmpBodyStatement</a>* ompbodyStmt);
<a name="l01512"></a>01512 
<a name="l01513"></a>01513 
<a name="l01516"></a>01516 <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#a72050df89f2aa4351288454d544b695">isBodyStatement</a> (<a class="code" href="classSgStatement.html">SgStatement</a>* s);
<a name="l01517"></a>01517 
<a name="l01519"></a>01519 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#f052fc07989bd2870022a0aa4f075d53">changeAllBodiesToBlocks</a>(<a class="code" href="classSgNode.html">SgNode</a>* top);
<a name="l01520"></a>01520 
<a name="l01522"></a>01522 <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#fd793e1727df3c73fbd8384ccc604272">changeAllLoopBodiesToBlocks</a>(<a class="code" href="classSgNode.html">SgNode</a>* top);
<a name="l01523"></a>01523 
<a name="l01525"></a>01525 <a class="code" href="classSgBasicBlock.html">SgBasicBlock</a> * <a class="code" href="namespaceSageInterface.html#f3cb2f040226ce2af1234b4e94a60d15">makeSingleStatementBodyToBlock</a>(<a class="code" href="classSgStatement.html">SgStatement</a>* singleStmt);
<a name="l01526"></a>01526 
<a name="l01527"></a>01527 <span class="preprocessor">#if 0</span>
<a name="l01528"></a>01528 <span class="preprocessor"></span>
<a name="l01531"></a>01531 <a class="code" href="classSgLocatedNode.html">SgLocatedNode</a>* ensureBasicBlockAsParent(<a class="code" href="classSgStatement.html">SgStatement</a>* s);
<a name="l01532"></a>01532 <span class="preprocessor">#endif</span>
<a name="l01533"></a>01533 <span class="preprocessor"></span>
<a name="l01536"></a>01536 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <a class="code" href="namespaceSageInterface.html#7c34b2c7c9c66106eb13c6d253217b5e">getIntegerConstantValue</a>(<a class="code" href="classSgValueExp.html">SgValueExp</a>* expr);
<a name="l01537"></a>01537 
<a name="l01539"></a>01539 std::vector&lt;SgDeclarationStatement*&gt; <a class="code" href="namespaceSageInterface.html#318f7cf455f620d5deecb5f37d41f4fe">getDependentDeclarations</a> (<a class="code" href="classSgStatement.html">SgStatement</a>* stmt );
<a name="l01540"></a>01540 
<a name="l01541"></a>01541 
<a name="l01543"></a>01543 <a class="code" href="classSgCommaOpExp.html">SgCommaOpExp</a> *<a class="code" href="namespaceSageInterface.html#88ea6b1684ee9c306a48e10e8a13910b">insertBeforeUsingCommaOp</a> (<a class="code" href="classSgExpression.html">SgExpression</a>* new_exp, <a class="code" href="classSgExpression.html">SgExpression</a>* anchor_exp);
<a name="l01544"></a>01544 
<a name="l01546"></a>01546 <a class="code" href="classSgCommaOpExp.html">SgCommaOpExp</a> *<a class="code" href="namespaceSageInterface.html#57851892650845148e67407bf2389fd2">insertAfterUsingCommaOp</a> (<a class="code" href="classSgExpression.html">SgExpression</a>* new_exp, <a class="code" href="classSgExpression.html">SgExpression</a>* anchor_exp, <a class="code" href="classSgStatement.html">SgStatement</a>** temp_decl = NULL, <a class="code" href="classSgVarRefExp.html">SgVarRefExp</a>** temp_ref = NULL);
<a name="l01547"></a>01547 
<a name="l01548"></a>01548 
<a name="l01578"></a>01578 std::pair&lt;SgStatement*, SgInitializedName*&gt;
<a name="l01579"></a>01579 <a class="code" href="namespaceSageInterface.html#db9d4a03d11809413cca4cac1dfc18a7">wrapFunction</a>(<a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>&amp; definingDeclaration, <a class="code" href="classSgName.html">SgName</a> newName);
<a name="l01580"></a>01580 
<a name="l01586"></a>01586 <span class="keyword">template</span> &lt;<span class="keyword">class</span> NameGen&gt;
<a name="l01587"></a>01587 std::pair&lt;SgStatement*, SgInitializedName*&gt;
<a name="l01588"></a><a class="code" href="namespaceSageInterface.html#10d65c1ab5842a8ecb88b24abf0b562c">01588</a> <a class="code" href="namespaceSageInterface.html#db9d4a03d11809413cca4cac1dfc18a7">wrapFunction</a>(<a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>&amp; definingDeclaration, NameGen nameGen)
<a name="l01589"></a>01589 {
<a name="l01590"></a>01590   <span class="keywordflow">return</span> <a class="code" href="namespaceSageInterface.html#db9d4a03d11809413cca4cac1dfc18a7">wrapFunction</a>(definingDeclaration, nameGen(definingDeclaration.<a class="code" href="classSgFunctionDeclaration.html#2f8974b0e4100dd1e186c479478d589a">get_name</a>()));
<a name="l01591"></a>01591 }
<a name="l01592"></a>01592 
<a name="l01595"></a>01595 <a class="code" href="classSgInitializedName.html">SgInitializedName</a>&amp; <a class="code" href="namespaceSageInterface.html#e1fae2ae93d70efe722d0bde9473842e">getFirstVariable</a>(<a class="code" href="classSgVariableDeclaration.html">SgVariableDeclaration</a>&amp; vardecl);
<a name="l01596"></a>01596 
<a name="l01597"></a>01597 
<a name="l01599"></a>01599 
<a name="l01600"></a>01600 
<a name="l01601"></a>01601 <span class="preprocessor">#if 0</span>
<a name="l01602"></a>01602 <span class="preprocessor"></span>
<a name="l01603"></a>01603 <span class="comment">//------------------------AST dump, stringify-----------------------------</span>
<a name="l01604"></a>01604 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l01605"></a>01605   std::string buildOperatorString ( <a class="code" href="classSgNode.html">SgNode</a>* astNode ); <span class="comment">//transformationSupport.h</span>
<a name="l01606"></a>01606 
<a name="l01607"></a>01607   <span class="comment">// do we need these?</span>
<a name="l01608"></a>01608   std::string dump_node(<span class="keyword">const</span> <a class="code" href="classSgNode.html">SgNode</a>* astNode);
<a name="l01609"></a>01609   std::string dump_tree(<span class="keyword">const</span> <a class="code" href="classSgNode.html">SgNode</a>* astNode);
<a name="l01610"></a>01610 
<a name="l01611"></a>01611   <span class="comment">// or a friendly version of  unparseToString(), as a memeber function</span>
<a name="l01612"></a>01612   std::string <a class="code" href="namespaceOmpSupport.html#bd54e60feb0dcc01a470ef9bf0b514e1">SgNode::toString</a>(<span class="keywordtype">bool</span> asSubTree=<span class="keyword">true</span>); <span class="comment">// dump node or subtree</span>
<a name="l01613"></a>01613 
<a name="l01614"></a>01614 <span class="comment">//----------------------------AST comparison------------------------------</span>
<a name="l01615"></a>01615 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l01616"></a>01616 <span class="comment">// How to get generic functions for comparison?</span>
<a name="l01617"></a>01617   <span class="keywordtype">bool</span> isNodeEqual(<a class="code" href="classSgNode.html">SgNode</a>* node1, <a class="code" href="classSgNode.html">SgNode</a>* node2); <span class="comment">//?</span>
<a name="l01618"></a>01618   <span class="keywordtype">bool</span> isTreeEqual(<a class="code" href="classSgNode.html">SgNode</a>* tree1, <a class="code" href="classSgNode.html">SgNode</a>* tree2);
<a name="l01619"></a>01619 
<a name="l01621"></a>01621   <span class="keywordtype">bool</span> expressionTreeEqual(<a class="code" href="classSgExpression.html">SgExpression</a>*, <a class="code" href="classSgExpression.html">SgExpression</a>*);
<a name="l01623"></a>01623   <span class="keywordtype">bool</span> expressionTreeEqualStar(<span class="keyword">const</span> <a class="code" href="Cxx__Grammar_8h.html#c126acfbeeb31bc8a63c06ccfb218f0e">SgExpressionPtrList</a>&amp;,
<a name="l01624"></a>01624                              <span class="keyword">const</span> <a class="code" href="Cxx__Grammar_8h.html#c126acfbeeb31bc8a63c06ccfb218f0e">SgExpressionPtrList</a>&amp;);
<a name="l01625"></a>01625 
<a name="l01626"></a>01626 <span class="comment">//----------------------AST verfication/repair----------------------------</span>
<a name="l01627"></a>01627 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l01628"></a>01628 <span class="comment">// sanity check of AST subtree, any suggestions?</span>
<a name="l01629"></a>01629 <span class="comment">//  TODO</span>
<a name="l01630"></a>01630     verifySgNode(<a class="code" href="classSgNode.html">SgNode</a>* node, <span class="keywordtype">bool</span> subTree=<span class="keyword">true</span>);
<a name="l01631"></a>01631   <span class="comment">//src/midend/astDiagnostics/AstConsistencyTests.h</span>
<a name="l01632"></a>01632   <span class="comment">// AstTests::runAllTests(SgProject * )</span>
<a name="l01633"></a>01633 
<a name="l01634"></a>01634   <span class="comment">//src/midend/astUtil/astInterface/AstInterface.h.C</span>
<a name="l01635"></a>01635   <span class="comment">//FixSgProject(SgProject &amp;project)</span>
<a name="l01636"></a>01636   <span class="comment">//FixSgTree(SgNode* r)</span>
<a name="l01637"></a>01637 
<a name="l01638"></a>01638   <span class="comment">//src/frontend/SageIII/astPostProcessing</span>
<a name="l01639"></a>01639   <span class="comment">//AstPostProcessing(SgNode * node)</span>
<a name="l01640"></a>01640 
<a name="l01641"></a>01641 <span class="comment">//--------------------------AST modification------------------------------</span>
<a name="l01642"></a>01642 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l01643"></a>01643 <span class="comment">// any operations changing AST tree, including</span>
<a name="l01644"></a>01644 <span class="comment">// insert, copy, delete(remove), replace</span>
<a name="l01645"></a>01645 
<a name="l01646"></a>01646   <span class="comment">// insert before or after some point, argument list is consistent with LowLevelRewrite</span>
<a name="l01647"></a>01647   <span class="keywordtype">void</span> insertAst(<a class="code" href="classSgNode.html">SgNode</a>* targetPosition, <a class="code" href="classSgNode.html">SgNode</a>* newNode, <span class="keywordtype">bool</span> insertBefore=<span class="keyword">true</span>);
<a name="l01648"></a>01648 
<a name="l01649"></a>01649   <span class="comment">// previous examples</span>
<a name="l01650"></a>01650   <span class="comment">//void myStatementInsert(SgStatement* target,...)</span>
<a name="l01651"></a>01651   <span class="comment">// void AstInterfaceBase::InsertStmt(AstNodePtr const &amp; orig, AstNodePtr const &amp;n, bool insertbefore, bool extractfromBasicBlock)</span>
<a name="l01652"></a>01652 
<a name="l01653"></a>01653   <span class="comment">// copy</span>
<a name="l01654"></a>01654   <span class="comment">// copy children of one basic block to another basic block</span>
<a name="l01655"></a>01655   <span class="comment">//void appendStatementCopy (const SgBasicBlock* a, SgBasicBlock* b);</span>
<a name="l01656"></a>01656   <span class="keywordtype">void</span> copyStatements (<span class="keyword">const</span> <a class="code" href="classSgBasicBlock.html">SgBasicBlock</a>* src, <a class="code" href="classSgBasicBlock.html">SgBasicBlock</a>* dst);
<a name="l01657"></a>01657 
<a name="l01658"></a>01658   <span class="comment">// delete (remove) a node or a whole subtree</span>
<a name="l01659"></a>01659   <span class="keywordtype">void</span> removeSgNode(<a class="code" href="classSgNode.html">SgNode</a>* targetNode); <span class="comment">// need this?</span>
<a name="l01660"></a>01660   <span class="keywordtype">void</span> removeSgNodeTree(<a class="code" href="classSgNode.html">SgNode</a>* subtree); <span class="comment">// need this?</span>
<a name="l01661"></a>01661 
<a name="l01662"></a>01662   <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#f5972a33cb2e9b5723e50ceccdaccb9f">removeStatement</a>( <a class="code" href="classSgStatement.html">SgStatement</a>* targetStmt);
<a name="l01663"></a>01663 
<a name="l01664"></a>01664   <span class="comment">//Move = delete + insert</span>
<a name="l01665"></a>01665   <span class="keywordtype">void</span> moveAst (<a class="code" href="classSgNode.html">SgNode</a>* src, <a class="code" href="classSgNode.html">SgNode</a>* target); <span class="comment">// need this?</span>
<a name="l01666"></a>01666       <span class="comment">// similar to</span>
<a name="l01667"></a>01667   <span class="keywordtype">void</span> moveStatements (<a class="code" href="classSgBasicBlock.html">SgBasicBlock</a>* src, <a class="code" href="classSgBasicBlock.html">SgBasicBlock</a>* target);
<a name="l01668"></a>01668 
<a name="l01669"></a>01669   <span class="comment">// replace= delete old + insert new (via building or copying)</span>
<a name="l01670"></a>01670 
<a name="l01671"></a>01671 <span class="comment">// DQ (1/25/2010): This does not appear to exist as a definition anywhere in ROSE.</span>
<a name="l01672"></a>01672 <span class="comment">// void replaceAst(SgNode* oldNode, SgNode* newNode);</span>
<a name="l01673"></a>01673 
<a name="l01674"></a>01674    <span class="comment">//void replaceChild(SgNode* parent, SgNode* from, SgNode* to);</span>
<a name="l01675"></a>01675    <span class="comment">//bool AstInterface::ReplaceAst( const AstNodePtr&amp; orig, const AstNodePtr&amp; n)</span>
<a name="l01676"></a>01676 
<a name="l01677"></a>01677 <span class="comment">//--------------------------AST transformations---------------------------</span>
<a name="l01678"></a>01678 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l01679"></a>01679 <span class="comment">// Advanced AST modifications through basic AST modifications</span>
<a name="l01680"></a>01680 <span class="comment">// Might not be included in AST utitlity list, but listed here for the record.</span>
<a name="l01681"></a>01681 
<a name="l01682"></a>01682   <span class="comment">// extract statements/content from a scope</span>
<a name="l01683"></a>01683   <span class="keywordtype">void</span> flattenBlocks(<a class="code" href="classSgNode.html">SgNode</a>* n);
<a name="l01684"></a>01684 
<a name="l01685"></a>01685   <span class="comment">//src/midend/astInlining/inlinerSupport.h</span>
<a name="l01686"></a>01686   <span class="keywordtype">void</span> renameVariables(<a class="code" href="classSgNode.html">SgNode</a>* n);
<a name="l01687"></a>01687   <span class="keywordtype">void</span> renameLabels(<a class="code" href="classSgNode.html">SgNode</a>* n, <a class="code" href="classSgFunctionDefinition.html">SgFunctionDefinition</a>* enclosingFunctionDefinition);
<a name="l01688"></a>01688 
<a name="l01689"></a>01689   <span class="keywordtype">void</span> simpleCopyAndConstantPropagation(<a class="code" href="classSgNode.html">SgNode</a>* top);
<a name="l01690"></a>01690   <span class="keywordtype">void</span> changeAllMembersToPublic(<a class="code" href="classSgNode.html">SgNode</a>* n);
<a name="l01691"></a>01691 
<a name="l01692"></a>01692   <span class="keywordtype">void</span> removeVariableDeclaration(<a class="code" href="classSgInitializedName.html">SgInitializedName</a>* initname);
<a name="l01693"></a>01693 
<a name="l01695"></a>01695   <a class="code" href="classSgAssignOp.html">SgAssignOp</a>* convertInitializerIntoAssignment(<a class="code" href="classSgAssignInitializer.html">SgAssignInitializer</a>* <a class="code" href="namespaceDbg.html#559185a86ba5f0d687a12f5e3b564e7f">init</a>);
<a name="l01696"></a>01696 
<a name="l01701"></a>01701   <span class="keywordtype">void</span> pushTestIntoBody(LoopStatement* loopStmt);
<a name="l01702"></a>01702 
<a name="l01703"></a>01703   <span class="comment">//programTransformation/finiteDifferencing/finiteDifferencing.h</span>
<a name="l01705"></a>01705 <span class="comment"></span>  <span class="keywordtype">void</span> moveForDeclaredVariables(<a class="code" href="classSgNode.html">SgNode</a>* root);
<a name="l01706"></a>01706 
<a name="l01707"></a>01707 <span class="comment">//------------------------ Is/Has functions ------------------------------</span>
<a name="l01708"></a>01708 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l01709"></a>01709 <span class="comment">// misc. boolean functions</span>
<a name="l01710"></a>01710 <span class="comment">// some of them could moved to SgXXX class as a member function</span>
<a name="l01711"></a>01711 
<a name="l01712"></a>01712   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#1a75ef1b6fc0708f3a2791d5198bdf19">isOverloaded</a> (<a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> * functionDeclaration);
<a name="l01713"></a>01713 
<a name="l01714"></a>01714   <span class="keywordtype">bool</span> isSwitchCond (<span class="keyword">const</span> <a class="code" href="classSgStatement.html">SgStatement</a>* s);
<a name="l01715"></a>01715   <span class="keywordtype">bool</span> isIfCond (<span class="keyword">const</span> <a class="code" href="classSgStatement.html">SgStatement</a>* s);
<a name="l01716"></a>01716   <span class="keywordtype">bool</span> isWhileCond (<span class="keyword">const</span> <a class="code" href="classSgStatement.html">SgStatement</a>* s);
<a name="l01717"></a>01717   <span class="keywordtype">bool</span> isStdNamespace (<span class="keyword">const</span> <a class="code" href="classSgScopeStatement.html">SgScopeStatement</a>* scope);
<a name="l01718"></a>01718   <span class="keywordtype">bool</span> isTemplateInst (<span class="keyword">const</span> <a class="code" href="classSgDeclarationStatement.html">SgDeclarationStatement</a>* decl);
<a name="l01719"></a>01719 
<a name="l01720"></a>01720 
<a name="l01721"></a>01721   <span class="keywordtype">bool</span> isCtor (<span class="keyword">const</span> <a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>* func);
<a name="l01722"></a>01722   <span class="keywordtype">bool</span> isDtor (<span class="keyword">const</span> <a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>* func);
<a name="l01723"></a>01723 
<a name="l01724"></a>01724    <span class="comment">// src/midend/astInlining/typeTraits.h</span>
<a name="l01725"></a>01725   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#756c8b08ca6df604e0e474ce92520240">hasTrivialDestructor</a>(<a class="code" href="classSgType.html">SgType</a>* t);
<a name="l01726"></a>01726   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#82f20af57da57491b26e6028fc4949c7">isNonconstReference</a>(<a class="code" href="classSgType.html">SgType</a>* t);
<a name="l01727"></a>01727   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#82448abd826a63fbf74cabde856223ec">isReferenceType</a>(<a class="code" href="classSgType.html">SgType</a>* t);
<a name="l01728"></a>01728 
<a name="l01729"></a>01729   <span class="comment">//  generic ones, or move to the SgXXX class as a member function</span>
<a name="l01730"></a>01730 
<a name="l01731"></a>01731   <span class="keywordtype">bool</span> isConst(<a class="code" href="classSgNode.html">SgNode</a>* node); <span class="comment">// const type, variable, function, etc.</span>
<a name="l01732"></a>01732   <span class="comment">// .... and more</span>
<a name="l01733"></a>01733 
<a name="l01734"></a>01734   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#3a8271b0d66df14cd687c3367c3530cc">isConstType</a> (<span class="keyword">const</span> <a class="code" href="classSgType.html">SgType</a>* type);
<a name="l01735"></a>01735   <span class="keywordtype">bool</span> isConstFunction (<span class="keyword">const</span> <a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>* decl);
<a name="l01736"></a>01736 
<a name="l01737"></a>01737 
<a name="l01738"></a>01738   <span class="keywordtype">bool</span> isMemberVariable(<span class="keyword">const</span> <a class="code" href="classSgInitializedName.html">SgInitializedName</a> &amp; var);
<a name="l01739"></a>01739   <span class="comment">//bool isMemberVariable(const SgNode&amp; in);</span>
<a name="l01740"></a>01740 
<a name="l01741"></a>01741   <span class="keywordtype">bool</span> <a class="code" href="namespaceSageInterface.html#b456db305882bbb6be21968b59fc865c">isPrototypeInScope</a> (<a class="code" href="classSgScopeStatement.html">SgScopeStatement</a> * scope,
<a name="l01742"></a>01742                            <a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> * functionDeclaration,
<a name="l01743"></a>01743                            <a class="code" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> * startingAtDeclaration);
<a name="l01744"></a>01744 
<a name="l01745"></a>01745   <span class="keywordtype">bool</span> MayRedefined(<a class="code" href="classSgExpression.html">SgExpression</a>* expr, <a class="code" href="classSgNode.html">SgNode</a>* root);
<a name="l01746"></a>01746   <span class="comment">// bool isPotentiallyModified(SgExpression* expr, SgNode* root); // inlinderSupport.h</span>
<a name="l01747"></a>01747   <span class="keywordtype">bool</span> hasAddressTaken(<a class="code" href="classSgExpression.html">SgExpression</a>* expr, <a class="code" href="classSgNode.html">SgNode</a>* root);
<a name="l01748"></a>01748 
<a name="l01749"></a>01749   <span class="comment">//src/midend/astInlining/inlinerSupport.C</span>
<a name="l01750"></a>01750      <span class="comment">// can also classified as topdown search</span>
<a name="l01751"></a>01751   <span class="keywordtype">bool</span> containsVariableReference(<a class="code" href="classSgNode.html">SgNode</a>* root, <a class="code" href="classSgInitializedName.html">SgInitializedName</a>* var);
<a name="l01752"></a>01752 
<a name="l01753"></a>01753   <span class="keywordtype">bool</span> isDeclarationOf(<a class="code" href="classSgVariableDeclaration.html">SgVariableDeclaration</a>* decl, <a class="code" href="classSgInitializedName.html">SgInitializedName</a>* var);
<a name="l01754"></a>01754   <span class="keywordtype">bool</span> isPotentiallyModifiedDuringLifeOf(<a class="code" href="classSgBasicBlock.html">SgBasicBlock</a>* sc,
<a name="l01755"></a>01755                                        <a class="code" href="classSgInitializedName.html">SgInitializedName</a>* toCheck,
<a name="l01756"></a>01756                                        <a class="code" href="classSgInitializedName.html">SgInitializedName</a>* lifetime)
<a name="l01757"></a>01757   <span class="comment">//src/midend/programTransformation/partialRedundancyElimination/pre.h</span>
<a name="l01758"></a>01758   <span class="keywordtype">bool</span> anyOfListPotentiallyModifiedIn(<span class="keyword">const</span> std::vector&lt;SgVariableSymbol*&gt;&amp; syms, <a class="code" href="classSgNode.html">SgNode</a>* n);
<a name="l01759"></a>01759 
<a name="l01760"></a>01760 <span class="comment">//------------------------ loop handling ---------------------------------</span>
<a name="l01761"></a>01761 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l01762"></a>01762   <span class="comment">//get and set loop control expressions</span>
<a name="l01763"></a>01763   <span class="comment">// 0: init expr, 1: condition expr, 2: stride expr</span>
<a name="l01764"></a>01764 
<a name="l01765"></a>01765   <a class="code" href="classSgExpression.html">SgExpression</a>* getForLoopTripleValues(<span class="keywordtype">int</span> valuetype,<a class="code" href="classSgForStatement.html">SgForStatement</a>* forstmt );
<a name="l01766"></a>01766   <span class="keywordtype">int</span> setForLoopTripleValues(<span class="keywordtype">int</span> valuetype,<a class="code" href="classSgForStatement.html">SgForStatement</a>* forstmt, <a class="code" href="classSgExpression.html">SgExpression</a>* exp);
<a name="l01767"></a>01767 
<a name="l01768"></a>01768   <span class="keywordtype">bool</span> isLoopIndexVarRef(<a class="code" href="classSgForStatement.html">SgForStatement</a>* forstmt, <a class="code" href="classSgVarRefExp.html">SgVarRefExp</a> *varref);
<a name="l01769"></a>01769   <a class="code" href="classSgInitializedName.html">SgInitializedName</a> * getLoopIndexVar(<a class="code" href="classSgForStatement.html">SgForStatement</a>* forstmt);
<a name="l01770"></a>01770 
<a name="l01771"></a>01771 <span class="comment">//------------------------expressions-------------------------------------</span>
<a name="l01772"></a>01772 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l01773"></a>01773   <span class="comment">//src/midend/programTransformation/partialRedundancyElimination/pre.h</span>
<a name="l01774"></a>01774   <span class="keywordtype">int</span> countComputationsOfExpressionIn(<a class="code" href="classSgExpression.html">SgExpression</a>* expr, <a class="code" href="classSgNode.html">SgNode</a>* root);
<a name="l01775"></a>01775 
<a name="l01776"></a>01776         <span class="comment">//src/midend/astInlining/replaceExpressionWithStatement.h</span>
<a name="l01777"></a>01777   <span class="keywordtype">void</span> replaceAssignmentStmtWithStatement(<a class="code" href="classSgExprStatement.html">SgExprStatement</a>* from, StatementGenerator* to);
<a name="l01778"></a>01778 
<a name="l01779"></a>01779   <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#c8ce4794f2e0212a315bceb252fe93f2">replaceSubexpressionWithStatement</a>(<a class="code" href="classSgExpression.html">SgExpression</a>* from,
<a name="l01780"></a>01780                                        StatementGenerator* to);
<a name="l01781"></a>01781   <a class="code" href="classSgExpression.html">SgExpression</a>* getRootOfExpression(<a class="code" href="classSgExpression.html">SgExpression</a>* n);
<a name="l01782"></a>01782 
<a name="l01783"></a>01783 <span class="comment">//--------------------------preprocessing info. -------------------------</span>
<a name="l01784"></a>01784 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l01786"></a>01786 <span class="comment"></span>  <span class="keywordtype">void</span> cutPreprocInfo (<a class="code" href="classSgBasicBlock.html">SgBasicBlock</a>* b,
<a name="l01787"></a>01787                        <a class="code" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> pos,
<a name="l01788"></a>01788                        <a class="code" href="rose__attributes__list_8h.html#d4b5f34bc0846e58b38e0ba5e8aac8b0">AttachedPreprocessingInfoType</a>&amp; save_buf);
<a name="l01790"></a>01790   <span class="keywordtype">void</span> pastePreprocInfoFront (<a class="code" href="rose__attributes__list_8h.html#d4b5f34bc0846e58b38e0ba5e8aac8b0">AttachedPreprocessingInfoType</a>&amp; save_buf,
<a name="l01791"></a>01791                               <a class="code" href="classSgStatement.html">SgStatement</a>* s);
<a name="l01793"></a>01793   <span class="keywordtype">void</span> pastePreprocInfoBack (<a class="code" href="rose__attributes__list_8h.html#d4b5f34bc0846e58b38e0ba5e8aac8b0">AttachedPreprocessingInfoType</a>&amp; save_buf,
<a name="l01794"></a>01794                              <a class="code" href="classSgStatement.html">SgStatement</a>* s);
<a name="l01795"></a>01795 
<a name="l01801"></a>01801   <span class="comment">// a generic one for all</span>
<a name="l01803"></a>01803 <span class="comment"></span>  <span class="keywordtype">void</span> moveBeforePreprocInfo (<a class="code" href="classSgStatement.html">SgStatement</a>* src, <a class="code" href="classSgStatement.html">SgStatement</a>* dest);
<a name="l01804"></a>01804   <span class="keywordtype">void</span> moveInsidePreprocInfo (<a class="code" href="classSgBasicBlock.html">SgBasicBlock</a>* src, <a class="code" href="classSgBasicBlock.html">SgBasicBlock</a>* dest);
<a name="l01805"></a>01805   <span class="keywordtype">void</span> moveAfterPreprocInfo (<a class="code" href="classSgStatement.html">SgStatement</a>* src, <a class="code" href="classSgStatement.html">SgStatement</a>* dest);
<a name="l01806"></a>01806 
<a name="l01807"></a>01807 <span class="comment">//--------------------------------operator--------------------------------</span>
<a name="l01808"></a>01808 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l01809"></a>01809   from transformationSupport.h, not sure <span class="keywordflow">if</span> they should be included here
<a name="l01810"></a>01810   <span class="comment">/* return enum code for SAGE operators */</span>
<a name="l01811"></a>01811   operatorCodeType classifyOverloadedOperator(); <span class="comment">// transformationSupport.h</span>
<a name="l01812"></a>01812 
<a name="l01818"></a>01818   std::string stringifyOperator (std::string name);
<a name="l01819"></a>01819 
<a name="l01820"></a>01820 <span class="comment">//--------------------------------macro ----------------------------------</span>
<a name="l01821"></a>01821 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l01822"></a>01822   std::string buildMacro ( std::string s ); <span class="comment">//transformationSupport.h</span>
<a name="l01823"></a>01823 
<a name="l01824"></a>01824 <span class="comment">//--------------------------------access functions---------------------------</span>
<a name="l01825"></a>01825 <span class="comment">//----------------------------------get/set sth.-----------------------------</span>
<a name="l01826"></a>01826 <span class="comment">// several categories:</span>
<a name="l01827"></a>01827 * get/set a direct child/grandchild node or fields
<a name="l01828"></a>01828 * get/set a property flag value
<a name="l01829"></a>01829 * get a descendent child node <span class="keyword">using</span> <a class="code" href="Cxx__Grammar_8h.html#59f7fee88581c4dd75f5fb25dbefa29edefb5d09673c144dc5b4dc177e278696">preorder</a> searching
<a name="l01830"></a>01830 * get an <a class="code" href="namespacesg.html#87bf656b2d09c9ac4d3d173e83f83b57">ancestor</a> node <span class="keyword">using</span> bottomup/reverse searching
<a name="l01831"></a>01831 
<a name="l01832"></a>01832         <span class="comment">// SgName or string?</span>
<a name="l01833"></a>01833   std::string getFunctionName (<a class="code" href="classSgFunctionCallExp.html">SgFunctionCallExp</a>* functionCallExp);
<a name="l01834"></a>01834   std::string getFunctionTypeName ( <a class="code" href="classSgFunctionCallExp.html">SgFunctionCallExp</a>* functionCallExpression );
<a name="l01835"></a>01835 
<a name="l01836"></a>01836     <span class="comment">// do we need them anymore? or existing member functions are enought?</span>
<a name="l01837"></a>01837     <span class="comment">// a generic one:</span>
<a name="l01838"></a>01838    std::string <a class="code" href="namespaceSageInterface.html#d8c38176c2d0e4d2bc851e70007902f9">get_name</a> (<span class="keyword">const</span> <a class="code" href="classSgNode.html">SgNode</a>* node);
<a name="l01839"></a>01839    std::string <a class="code" href="namespaceSageInterface.html#d8c38176c2d0e4d2bc851e70007902f9">get_name</a> (<span class="keyword">const</span> <a class="code" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> * declaration);
<a name="l01840"></a>01840 
<a name="l01841"></a>01841   <span class="comment">// get/set some property: should moved to SgXXX as an inherent memeber function?</span>
<a name="l01842"></a>01842   <span class="comment">// access modifier</span>
<a name="l01843"></a>01843   <span class="keywordtype">void</span>  <a class="code" href="namespaceSageInterface.html#5a4e98c40873b96844edc32c7b2604e7">setExtern</a> (SgFunctionDeclartion*)
<a name="l01844"></a>01844   void  clearExtern()
<a name="l01845"></a>01845 
<a name="l01846"></a>01846    <span class="comment">// similarly for other declarations and other properties</span>
<a name="l01847"></a>01847   <span class="keywordtype">void</span> <a class="code" href="namespaceSageInterface.html#5a4e98c40873b96844edc32c7b2604e7">setExtern</a> (<a class="code" href="classSgVariableDeclaration.html">SgVariableDeclaration</a>*)
<a name="l01848"></a>01848   <span class="keywordtype">void</span> setPublic()
<a name="l01849"></a>01849   <span class="keywordtype">void</span> setPrivate()
<a name="l01850"></a>01850 
<a name="l01851"></a>01851 
<a name="l01852"></a>01852 <span class="preprocessor">#endif</span>
<a name="l01853"></a>01853 <span class="preprocessor"></span>}<span class="comment">// end of namespace</span>
<a name="l01854"></a>01854 
<a name="l01855"></a>01855 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
