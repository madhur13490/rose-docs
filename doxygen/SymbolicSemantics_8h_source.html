<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ROSE: SymbolicSemantics.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.9.5a</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('SymbolicSemantics_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">SymbolicSemantics.h</div>  </div>
</div>
<div class="contents">
<a href="SymbolicSemantics_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef Rose_SymbolicSemantics_H</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define Rose_SymbolicSemantics_H</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span><span class="preprocessor">#include &lt;stdint.h&gt;</span>
<a name="l00004"></a>00004 <span class="preprocessor">#ifndef __STDC_FORMAT_MACROS</span>
<a name="l00005"></a><a class="code" href="SymbolicSemantics_8h.html#aacbb9e1f38be71e22df1584a37c56693">00005</a> <span class="preprocessor"></span><span class="preprocessor">#define __STDC_FORMAT_MACROS</span>
<a name="l00006"></a>00006 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00007"></a>00007 <span class="preprocessor"></span><span class="preprocessor">#include &lt;inttypes.h&gt;</span>
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 <span class="preprocessor">#include &quot;<a class="code" href="x86InstructionSemantics_8h.html">x86InstructionSemantics.h</a>&quot;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &quot;<a class="code" href="SMTSolver_8h.html">SMTSolver.h</a>&quot;</span>
<a name="l00011"></a>00011 
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 
<a name="l00031"></a><a class="code" href="namespaceSymbolicSemantics.html">00031</a> <span class="keyword">namespace </span>SymbolicSemantics {
<a name="l00032"></a>00032 
<a name="l00033"></a><a class="code" href="namespaceSymbolicSemantics.html#a5148365f05e99b2d11ca3d29056bbfba">00033</a>     <span class="keyword">typedef</span> <a class="code" href="namespaceInsnSemanticsExpr.html#ac844e749754811a3133b020121477328">InsnSemanticsExpr::RenameMap</a> <a class="code" href="namespaceSymbolicSemantics.html#a5148365f05e99b2d11ca3d29056bbfba">RenameMap</a>;
<a name="l00034"></a><a class="code" href="namespaceSymbolicSemantics.html#a7093fd1847fa243496eb98a15f3f18ae">00034</a>     <span class="keyword">typedef</span> <a class="code" href="classInsnSemanticsExpr_1_1LeafNode.html" title="Leaf node of an expression tree for instruction semantics.">InsnSemanticsExpr::LeafNode</a> <a class="code" href="namespaceSymbolicSemantics.html#a7093fd1847fa243496eb98a15f3f18ae">LeafNode</a>;
<a name="l00035"></a><a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">00035</a>     <span class="keyword">typedef</span> <a class="code" href="classInsnSemanticsExpr_1_1InternalNode.html" title="Internal node of an expression tree for instruction semantics.">InsnSemanticsExpr::InternalNode</a> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>;
<a name="l00036"></a><a class="code" href="namespaceSymbolicSemantics.html#a1050fc5db6424f8c20870a470cfec119">00036</a>     <span class="keyword">typedef</span> <a class="code" href="classInsnSemanticsExpr_1_1TreeNode.html" title="Any node of an expression tree for instruction semantics, from which the InternalNode and LeafNode cl...">InsnSemanticsExpr::TreeNode</a> <a class="code" href="namespaceSymbolicSemantics.html#a1050fc5db6424f8c20870a470cfec119">TreeNode</a>;
<a name="l00037"></a>00037 
<a name="l00038"></a>00038     <span class="comment">/* ValueType cannot directly be a TreeNode because ValueType&#39;s bit size is a template argument while tree node sizes are</span>
<a name="l00039"></a>00039 <span class="comment">     * stored as a data member.  Therefore, ValueType will always point to a TreeNode.  Most of the methods that are invoked on</span>
<a name="l00040"></a>00040 <span class="comment">     * ValueType just call the same methods for TreeNode. */</span>
<a name="l00041"></a>00041     <span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> nBits&gt;
<a name="l00042"></a><a class="code" href="structSymbolicSemantics_1_1ValueType.html">00042</a>     <span class="keyword">struct </span><a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType</a> {
<a name="l00043"></a>00043 
<a name="l00044"></a><a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">00044</a>         <a class="code" href="classInsnSemanticsExpr_1_1TreeNode.html" title="Any node of an expression tree for instruction semantics, from which the InternalNode and LeafNode cl...">TreeNode</a> *<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>; <span class="comment">/*reference counted*/</span>
<a name="l00045"></a>00045 
<a name="l00047"></a><a class="code" href="structSymbolicSemantics_1_1ValueType.html#a735af0e86e12367112e09b01b6eb3db8">00047</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html#a735af0e86e12367112e09b01b6eb3db8" title="Construct a value that is unknown and unique.">ValueType</a>() {
<a name="l00048"></a>00048             <a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a> = <a class="code" href="classInsnSemanticsExpr_1_1LeafNode.html#a6042f36ad2e1907d8f10bf7624b00c57" title="Construct a new free variable with a specified number of significant bits.">LeafNode::create_variable</a>(nBits);
<a name="l00049"></a>00049             <a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>-&gt;<a class="code" href="classInsnSemanticsExpr_1_1TreeNode.html#a9e6afd6276e88f666de06b5af04aedd8" title="Increments the reference count by one and returns the new reference count.">inc_nrefs</a>();
<a name="l00050"></a>00050         }
<a name="l00051"></a>00051 
<a name="l00052"></a><a class="code" href="structSymbolicSemantics_1_1ValueType.html#a7b6e6862454966c97d008aa8520f5709">00052</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html#a7b6e6862454966c97d008aa8520f5709">ValueType</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType</a> &amp;other) {
<a name="l00053"></a>00053             <a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a> = other.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>;
<a name="l00054"></a>00054             <a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>-&gt;<a class="code" href="classInsnSemanticsExpr_1_1TreeNode.html#a9e6afd6276e88f666de06b5af04aedd8" title="Increments the reference count by one and returns the new reference count.">inc_nrefs</a>();
<a name="l00055"></a>00055         }
<a name="l00056"></a>00056 
<a name="l00057"></a><a class="code" href="structSymbolicSemantics_1_1ValueType.html#aa653551c90c24e9eea16d9d87bc1f866">00057</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType</a>&amp; <a class="code" href="structSymbolicSemantics_1_1ValueType.html#aa653551c90c24e9eea16d9d87bc1f866">operator=</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType</a> &amp;other) {
<a name="l00058"></a>00058             <a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>-&gt;<a class="code" href="classInsnSemanticsExpr_1_1TreeNode.html#a734e00b7348b12f117b7f8c3dcd7770c" title="Decrements the reference count by one and returns the new reference count.">dec_nrefs</a>();
<a name="l00059"></a>00059             <a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>-&gt;<a class="code" href="classInsnSemanticsExpr_1_1TreeNode.html#a18b6d72538e59fcce85ccae6bfe93a34" title="Deletes this node and all children, provided the children aren&#39;t also children of other nodes...">deleteDeeply</a>();
<a name="l00060"></a>00060             <a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a> = other.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>;
<a name="l00061"></a>00061             <a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>-&gt;<a class="code" href="classInsnSemanticsExpr_1_1TreeNode.html#a9e6afd6276e88f666de06b5af04aedd8" title="Increments the reference count by one and returns the new reference count.">inc_nrefs</a>();
<a name="l00062"></a>00062             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00063"></a>00063         }
<a name="l00064"></a>00064 
<a name="l00066"></a><a class="code" href="structSymbolicSemantics_1_1ValueType.html#a41e3a78eb36d0bf5ea824b30c7cf6cb0">00066</a>         <span class="keyword">explicit</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html#a41e3a78eb36d0bf5ea824b30c7cf6cb0" title="Construct a ValueType with a known value.">ValueType</a>(uint64_t n) {
<a name="l00067"></a>00067             <a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a> = <a class="code" href="classInsnSemanticsExpr_1_1LeafNode.html#a5c5a9606638db5e4fbb6990c55084d1c" title="Construct a new integer with the specified number of significant bits.">LeafNode::create_integer</a>(nBits, n);
<a name="l00068"></a>00068             <a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>-&gt;<a class="code" href="classInsnSemanticsExpr_1_1TreeNode.html#a9e6afd6276e88f666de06b5af04aedd8" title="Increments the reference count by one and returns the new reference count.">inc_nrefs</a>();
<a name="l00069"></a>00069         }
<a name="l00070"></a>00070 
<a name="l00072"></a><a class="code" href="structSymbolicSemantics_1_1ValueType.html#a5b337917167a56fc7f49cf236a82f642">00072</a>         <span class="keyword">explicit</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html#a5b337917167a56fc7f49cf236a82f642" title="Construct a ValueType from a TreeNode.">ValueType</a>(<a class="code" href="classInsnSemanticsExpr_1_1TreeNode.html" title="Any node of an expression tree for instruction semantics, from which the InternalNode and LeafNode cl...">TreeNode</a> *node) {
<a name="l00073"></a>00073             assert(node-&gt;<a class="code" href="classInsnSemanticsExpr_1_1TreeNode.html#ad1f524ed1d3970a4fe1a98c2cce72dbf" title="Returns the number of significant bits.">get_nbits</a>()==nBits);
<a name="l00074"></a>00074             <a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a> = node;
<a name="l00075"></a>00075             expr-&gt;<a class="code" href="classInsnSemanticsExpr_1_1TreeNode.html#a9e6afd6276e88f666de06b5af04aedd8" title="Increments the reference count by one and returns the new reference count.">inc_nrefs</a>();
<a name="l00076"></a>00076         }
<a name="l00077"></a>00077 
<a name="l00078"></a><a class="code" href="structSymbolicSemantics_1_1ValueType.html#ad39bb437a956e02580915687d994ba55">00078</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html#ad39bb437a956e02580915687d994ba55">~ValueType</a>() {
<a name="l00079"></a>00079             <a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>-&gt;<a class="code" href="classInsnSemanticsExpr_1_1TreeNode.html#a734e00b7348b12f117b7f8c3dcd7770c" title="Decrements the reference count by one and returns the new reference count.">dec_nrefs</a>();
<a name="l00080"></a>00080             <a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>-&gt;<a class="code" href="classInsnSemanticsExpr_1_1TreeNode.html#a18b6d72538e59fcce85ccae6bfe93a34" title="Deletes this node and all children, provided the children aren&#39;t also children of other nodes...">deleteDeeply</a>();
<a name="l00081"></a>00081         }
<a name="l00082"></a>00082 
<a name="l00085"></a><a class="code" href="structSymbolicSemantics_1_1ValueType.html#a62a710f7f3fdfc7b83f8ec7f50db93f4">00085</a>         <span class="keywordtype">void</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html#a62a710f7f3fdfc7b83f8ec7f50db93f4" title="Print the value.">print</a>(std::ostream &amp;o, <a class="code" href="namespaceSymbolicSemantics.html#a5148365f05e99b2d11ca3d29056bbfba">RenameMap</a> *rmap=NULL)<span class="keyword"> const </span>{
<a name="l00086"></a>00086             <a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>-&gt;<a class="code" href="classInsnSemanticsExpr_1_1TreeNode.html#aad68c4f3d98e347562afc2fcae63759b" title="Print the expression to a stream.">print</a>(o, rmap);
<a name="l00087"></a>00087         }
<a name="l00088"></a>00088 
<a name="l00090"></a><a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c">00090</a>         <span class="keywordtype">bool</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>()<span class="keyword"> const </span>{
<a name="l00091"></a>00091             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>-&gt;<a class="code" href="classInsnSemanticsExpr_1_1TreeNode.html#ab96471cfdaa08de96e862ecef49d4791" title="Returns true if the expression is a known value.">is_known</a>();
<a name="l00092"></a>00092         }
<a name="l00093"></a>00093 
<a name="l00095"></a><a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219">00095</a>         uint64_t <a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>()<span class="keyword"> const </span>{
<a name="l00096"></a>00096             <a class="code" href="classInsnSemanticsExpr_1_1LeafNode.html" title="Leaf node of an expression tree for instruction semantics.">LeafNode</a> *leaf = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classInsnSemanticsExpr_1_1LeafNode.html" title="Leaf node of an expression tree for instruction semantics.">LeafNode</a>*<span class="keyword">&gt;</span>(<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>);
<a name="l00097"></a>00097             assert(leaf);
<a name="l00098"></a>00098             <span class="keywordflow">return</span> leaf-&gt;<a class="code" href="classInsnSemanticsExpr_1_1LeafNode.html#a6bf5bc6c093d65039f0199b1d4457cb6" title="Returns the integer value of a node for which is_known() returns true.">get_value</a>();
<a name="l00099"></a>00099         }
<a name="l00100"></a>00100     };
<a name="l00101"></a>00101 
<a name="l00102"></a>00102     <span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00103"></a><a class="code" href="namespaceSymbolicSemantics.html#af0c70f6f907f458e05ed050a415ed40b">00103</a>     std::ostream&amp; operator&lt;&lt;(std::ostream &amp;o, const ValueType&lt;Len&gt; &amp;e) {
<a name="l00104"></a>00104         e.print(o, NULL);
<a name="l00105"></a>00105         <span class="keywordflow">return</span> o;
<a name="l00106"></a>00106     }
<a name="l00107"></a>00107 
<a name="l00127"></a><a class="code" href="structSymbolicSemantics_1_1MemoryCell.html">00127</a>     <span class="keyword">struct </span><a class="code" href="structSymbolicSemantics_1_1MemoryCell.html" title="Represents one location in memory.">MemoryCell</a> {
<a name="l00128"></a><a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#a1bb6ae7a38c929916d3cd5b3deab95d1">00128</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#a1bb6ae7a38c929916d3cd5b3deab95d1">address</a>;
<a name="l00129"></a><a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#a25159c75a164c15230b745c0ef072b54">00129</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#a25159c75a164c15230b745c0ef072b54">data</a>;
<a name="l00130"></a><a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#a1d0ea3ddf1e2a2e2b45f65131639d369">00130</a>         <span class="keywordtype">size_t</span> <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#a1d0ea3ddf1e2a2e2b45f65131639d369">nbytes</a>;
<a name="l00131"></a><a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#a822acf88ce7f52da2e88fd90f6e48990">00131</a>         <span class="keywordtype">bool</span> <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#a822acf88ce7f52da2e88fd90f6e48990">clobbered</a>;             <span class="comment">/* Set to invalidate possible aliases during writeMemory() */</span>
<a name="l00132"></a><a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#afb2ff0c7114ecd0b4217e5106ed29507">00132</a>         <span class="keywordtype">bool</span> <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#afb2ff0c7114ecd0b4217e5106ed29507">written</a>;               <span class="comment">/* Set to true by writeMemory */</span>
<a name="l00133"></a>00133 
<a name="l00134"></a>00134         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00135"></a><a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#ac352cbd34018052822dc426321c6534b">00135</a>         <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#ac352cbd34018052822dc426321c6534b">MemoryCell</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;<a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#a1bb6ae7a38c929916d3cd5b3deab95d1">address</a>, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#a25159c75a164c15230b745c0ef072b54">data</a>, <span class="keywordtype">size_t</span> <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#a1d0ea3ddf1e2a2e2b45f65131639d369">nbytes</a>)
<a name="l00136"></a>00136             : address(address), data(data), nbytes(nbytes), <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#a822acf88ce7f52da2e88fd90f6e48990">clobbered</a>(false), <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#afb2ff0c7114ecd0b4217e5106ed29507">written</a>(false) {}
<a name="l00137"></a>00137 
<a name="l00138"></a><a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#a4b86e12d2b5a2e415d496cb9b0e9ea54">00138</a>         <span class="keywordtype">bool</span> <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#a4b86e12d2b5a2e415d496cb9b0e9ea54">is_clobbered</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#a822acf88ce7f52da2e88fd90f6e48990">clobbered</a>; }
<a name="l00139"></a><a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#a060a9cf4523046f7e5c8417f8dd8d76a">00139</a>         <span class="keywordtype">void</span> <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#a060a9cf4523046f7e5c8417f8dd8d76a">set_clobbered</a>() { <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#a822acf88ce7f52da2e88fd90f6e48990">clobbered</a> = <span class="keyword">true</span>; }
<a name="l00140"></a><a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#a8a10fc132a6d99425a1e376d8c32e90b">00140</a>         <span class="keywordtype">bool</span> <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#a8a10fc132a6d99425a1e376d8c32e90b">is_written</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#afb2ff0c7114ecd0b4217e5106ed29507">written</a>; }
<a name="l00141"></a><a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#ad011025e2126bd8d7550f3704244c93f">00141</a>         <span class="keywordtype">void</span> <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#ad011025e2126bd8d7550f3704244c93f">set_written</a>() { <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#afb2ff0c7114ecd0b4217e5106ed29507">written</a> = <span class="keyword">true</span>; }
<a name="l00142"></a>00142 
<a name="l00146"></a>00146         <span class="keywordtype">bool</span> <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#abf8d9b6cb5f69802b84750fa8432ae02" title="Returns true if this memory value could possibly overlap with the other memory value.">may_alias</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html" title="Represents one location in memory.">MemoryCell</a> &amp;other, <a class="code" href="classSMTSolver.html" title="Interface to Satisfiability Modulo Theory (SMT) solvers.">SMTSolver</a> *solver) <span class="keyword">const</span>;
<a name="l00147"></a>00147 
<a name="l00150"></a>00150         <span class="keywordtype">bool</span> <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#ac9b305b2fdcc5f941fdfdc21573eae26" title="Returns true if this memory address is the same as the other.">must_alias</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html" title="Represents one location in memory.">MemoryCell</a> &amp;other, <a class="code" href="classSMTSolver.html" title="Interface to Satisfiability Modulo Theory (SMT) solvers.">SMTSolver</a> *solver) <span class="keyword">const</span>;
<a name="l00151"></a>00151 
<a name="l00154"></a>00154         <span class="keywordtype">void</span> <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#aa6de400c00812cf6fedb49c6f700b0ba" title="Prints the value of a memory cell on a single line.">print</a>(std::ostream &amp;o, <a class="code" href="namespaceSymbolicSemantics.html#a5148365f05e99b2d11ca3d29056bbfba">RenameMap</a> *rmap=NULL) <span class="keyword">const</span>;
<a name="l00155"></a>00155     };
<a name="l00156"></a>00156 
<a name="l00157"></a><a class="code" href="namespaceSymbolicSemantics.html#aa11ebc03c3b442c0f39667422dc5a17a">00157</a>     <span class="keyword">typedef</span> std::vector&lt;MemoryCell&gt; <a class="code" href="namespaceSymbolicSemantics.html#aa11ebc03c3b442c0f39667422dc5a17a">Memory</a>;
<a name="l00158"></a>00158 
<a name="l00160"></a><a class="code" href="structSymbolicSemantics_1_1State.html">00160</a>     <span class="keyword">struct </span><a class="code" href="structSymbolicSemantics_1_1State.html" title="Represents the entire state of the machine.">State</a> {
<a name="l00161"></a><a class="code" href="structSymbolicSemantics_1_1State.html#a06d6a3e396eb75f176801be642a534c5">00161</a>         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> <a class="code" href="structSymbolicSemantics_1_1State.html#a06d6a3e396eb75f176801be642a534c5" title="Number of general-purpose registers in this state.">n_gprs</a> = 8;             
<a name="l00162"></a><a class="code" href="structSymbolicSemantics_1_1State.html#a798036852f5d27d79474277fdd414c0e">00162</a>         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> <a class="code" href="structSymbolicSemantics_1_1State.html#a798036852f5d27d79474277fdd414c0e" title="Number of segmentation registers in this state.">n_segregs</a> = 6;          
<a name="l00163"></a><a class="code" href="structSymbolicSemantics_1_1State.html#af759fac458596ba9f982ba897198b834">00163</a>         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> <a class="code" href="structSymbolicSemantics_1_1State.html#af759fac458596ba9f982ba897198b834" title="Number of flag registers in this state.">n_flags</a> = 16;           
<a name="l00165"></a><a class="code" href="structSymbolicSemantics_1_1State.html#ab7b69f87b8b838c15abe78d7dace22fc">00165</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> <a class="code" href="structSymbolicSemantics_1_1State.html#ab7b69f87b8b838c15abe78d7dace22fc" title="Instruction pointer.">ip</a>;                           
<a name="l00166"></a><a class="code" href="structSymbolicSemantics_1_1State.html#aa4eba52bac554f862e1a3f1723ccfe3a">00166</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> <a class="code" href="structSymbolicSemantics_1_1State.html#aa4eba52bac554f862e1a3f1723ccfe3a" title="General-purpose registers.">gpr</a>[<a class="code" href="structSymbolicSemantics_1_1State.html#a06d6a3e396eb75f176801be642a534c5" title="Number of general-purpose registers in this state.">n_gprs</a>];                  
<a name="l00167"></a><a class="code" href="structSymbolicSemantics_1_1State.html#a44bc9efb653b62529f04903c67925c48">00167</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;16&gt;</a> <a class="code" href="structSymbolicSemantics_1_1State.html#a44bc9efb653b62529f04903c67925c48" title="Segmentation registers.">segreg</a>[<a class="code" href="structSymbolicSemantics_1_1State.html#a798036852f5d27d79474277fdd414c0e" title="Number of segmentation registers in this state.">n_segregs</a>];            
<a name="l00168"></a><a class="code" href="structSymbolicSemantics_1_1State.html#aae557035aec8db3604a1ebea2b29924a">00168</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;1&gt;</a> <a class="code" href="structSymbolicSemantics_1_1State.html#aae557035aec8db3604a1ebea2b29924a" title="Control/status flags (i.e., FLAG register).">flag</a>[<a class="code" href="structSymbolicSemantics_1_1State.html#af759fac458596ba9f982ba897198b834" title="Number of flag registers in this state.">n_flags</a>];                 
<a name="l00169"></a><a class="code" href="structSymbolicSemantics_1_1State.html#a33bea68a1f6ac63deb9b34563ffc32a3">00169</a>         <a class="code" href="namespaceSymbolicSemantics.html#aa11ebc03c3b442c0f39667422dc5a17a">Memory</a> <a class="code" href="structSymbolicSemantics_1_1State.html#a33bea68a1f6ac63deb9b34563ffc32a3" title="Core memory.">mem</a>;                                 
<a name="l00173"></a>00173         <span class="keywordtype">void</span> <a class="code" href="structSymbolicSemantics_1_1State.html#a1b92185099fdd697f4c62824f64d4f47" title="Print the state in a human-friendly way.">print</a>(std::ostream &amp;o, <a class="code" href="namespaceSymbolicSemantics.html#a5148365f05e99b2d11ca3d29056bbfba">RenameMap</a> *rmap=NULL) <span class="keyword">const</span>;
<a name="l00174"></a>00174 
<a name="l00177"></a>00177         <span class="keywordtype">void</span> <a class="code" href="structSymbolicSemantics_1_1State.html#a3b43e01c68380fbc395fe15a2918f0ea" title="Print info about how registers differ.">print_diff_registers</a>(std::ostream &amp;o, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1State.html" title="Represents the entire state of the machine.">State</a>&amp;, <a class="code" href="namespaceSymbolicSemantics.html#a5148365f05e99b2d11ca3d29056bbfba">RenameMap</a> *rmap=NULL) <span class="keyword">const</span>;
<a name="l00178"></a>00178 
<a name="l00180"></a>00180         <span class="keywordtype">bool</span> <a class="code" href="structSymbolicSemantics_1_1State.html#a982c476ea79c92399834ec67bf15e710" title="Tests registers of two states for equality.">equal_registers</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1State.html" title="Represents the entire state of the machine.">State</a>&amp;) <span class="keyword">const</span>;
<a name="l00181"></a>00181 
<a name="l00184"></a><a class="code" href="structSymbolicSemantics_1_1State.html#a21c4fd988e28c43b36d314dbbdf79c60">00184</a>         <span class="keywordtype">void</span> <a class="code" href="structSymbolicSemantics_1_1State.html#a21c4fd988e28c43b36d314dbbdf79c60" title="Removes from memory those values at addresses below the current stack pointer.">discard_popped_memory</a>() {
<a name="l00185"></a>00185             <span class="comment">/*FIXME: not implemented yet. [RPM 2010-05-24]*/</span>
<a name="l00186"></a>00186         }
<a name="l00187"></a>00187 
<a name="l00188"></a>00188     };
<a name="l00189"></a>00189 
<a name="l00190"></a>00190     std::ostream&amp; <a class="code" href="namespaceSymbolicSemantics.html#af0c70f6f907f458e05ed050a415ed40b">operator&lt;&lt;</a>(std::ostream &amp;o, <span class="keyword">const</span> MemoryCell&amp; mc);
<a name="l00191"></a>00191     std::ostream&amp; <a class="code" href="namespaceSymbolicSemantics.html#af0c70f6f907f458e05ed050a415ed40b">operator&lt;&lt;</a>(std::ostream &amp;o, <span class="keyword">const</span> State&amp; state);
<a name="l00192"></a>00192 
<a name="l00194"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html">00194</a>     <span class="keyword">class </span><a class="code" href="classSymbolicSemantics_1_1Policy.html" title="A policy that is supplied to the semantic analysis constructor.">Policy</a> {
<a name="l00195"></a>00195     <span class="keyword">private</span>:
<a name="l00196"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#acaa5e9fa30b339215f03b058ca2c0312">00196</a>         <a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *<a class="code" href="classSymbolicSemantics_1_1Policy.html#acaa5e9fa30b339215f03b058ca2c0312" title="Set by startInstruction(), cleared by finishInstruction()">cur_insn</a>;         
<a name="l00197"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a2d75334bcb4671e7b3aec81c7904da45">00197</a>         <span class="keyword">mutable</span> <a class="code" href="structSymbolicSemantics_1_1State.html" title="Represents the entire state of the machine.">State</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a2d75334bcb4671e7b3aec81c7904da45" title="Original machine state, initialized by constructor and mem_write.">orig_state</a>;           
<a name="l00206"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a4ff1f363deb8988a0fa96e04f85e4885">00206</a>         <span class="keyword">mutable</span> <a class="code" href="structSymbolicSemantics_1_1State.html" title="Represents the entire state of the machine.">State</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a4ff1f363deb8988a0fa96e04f85e4885" title="Current machine state updated by each processInstruction().">cur_state</a>;            
<a name="l00211"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a43661b0c3078e35e6dac0473fbef2b2b">00211</a>         <span class="keywordtype">bool</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a43661b0c3078e35e6dac0473fbef2b2b" title="Property that determines how the stack behaves.">p_discard_popped_memory</a>;       
<a name="l00215"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#ab85e968d57a89b32977fedc02bdb5ebc">00215</a>         <span class="keywordtype">size_t</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#ab85e968d57a89b32977fedc02bdb5ebc" title="Total number of instructions processed.">ninsns</a>;                      
<a name="l00218"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#ae97a155267ab95e36b889af7963cbb4f">00218</a>         <a class="code" href="classSMTSolver.html" title="Interface to Satisfiability Modulo Theory (SMT) solvers.">SMTSolver</a> *<a class="code" href="classSymbolicSemantics_1_1Policy.html#ae97a155267ab95e36b889af7963cbb4f" title="The solver to use for Satisfiability Modulo Theory, or NULL.">solver</a>;                  
<a name="l00220"></a>00220     <span class="keyword">public</span>:
<a name="l00222"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a87cbb60147f7233b4c6663bb22994fcc">00222</a>         <a class="code" href="classSymbolicSemantics_1_1Policy.html#a87cbb60147f7233b4c6663bb22994fcc" title="Constructs a new policy without an SMT solver.">Policy</a>() {
<a name="l00223"></a>00223             <a class="code" href="classSymbolicSemantics_1_1Policy.html#a1c339701e13afd002a51cec3e5c28369" title="Initialize undefined policy.">init</a>();
<a name="l00224"></a>00224             <span class="comment">/* So that named values are identical in both; reinitialized by first call to startInstruction(). */</span>
<a name="l00225"></a>00225             <a class="code" href="classSymbolicSemantics_1_1Policy.html#a2d75334bcb4671e7b3aec81c7904da45" title="Original machine state, initialized by constructor and mem_write.">orig_state</a> = <a class="code" href="classSymbolicSemantics_1_1Policy.html#a4ff1f363deb8988a0fa96e04f85e4885" title="Current machine state updated by each processInstruction().">cur_state</a>;
<a name="l00226"></a>00226         }
<a name="l00227"></a>00227 
<a name="l00229"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#ad51a43fa1fa14dfaaca1f66a314859c1">00229</a>         <a class="code" href="classSymbolicSemantics_1_1Policy.html#ad51a43fa1fa14dfaaca1f66a314859c1" title="Constructs a new policy with an SMT solver.">Policy</a>(<a class="code" href="classSMTSolver.html" title="Interface to Satisfiability Modulo Theory (SMT) solvers.">SMTSolver</a> *<a class="code" href="classSymbolicSemantics_1_1Policy.html#ae97a155267ab95e36b889af7963cbb4f" title="The solver to use for Satisfiability Modulo Theory, or NULL.">solver</a>) {
<a name="l00230"></a>00230             <a class="code" href="classSymbolicSemantics_1_1Policy.html#a1c339701e13afd002a51cec3e5c28369" title="Initialize undefined policy.">init</a>();
<a name="l00231"></a>00231             this-&gt;solver = <a class="code" href="classSymbolicSemantics_1_1Policy.html#ae97a155267ab95e36b889af7963cbb4f" title="The solver to use for Satisfiability Modulo Theory, or NULL.">solver</a>;
<a name="l00232"></a>00232             <span class="comment">/* So that named values are identical in both; reinitialized by first call to startInstruction(). */</span>
<a name="l00233"></a>00233             <a class="code" href="classSymbolicSemantics_1_1Policy.html#a2d75334bcb4671e7b3aec81c7904da45" title="Original machine state, initialized by constructor and mem_write.">orig_state</a> = <a class="code" href="classSymbolicSemantics_1_1Policy.html#a4ff1f363deb8988a0fa96e04f85e4885" title="Current machine state updated by each processInstruction().">cur_state</a>;
<a name="l00234"></a>00234         }
<a name="l00235"></a>00235 
<a name="l00237"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a1c339701e13afd002a51cec3e5c28369">00237</a>         <span class="keywordtype">void</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a1c339701e13afd002a51cec3e5c28369" title="Initialize undefined policy.">init</a>() {
<a name="l00238"></a>00238             <a class="code" href="classSymbolicSemantics_1_1Policy.html#acaa5e9fa30b339215f03b058ca2c0312" title="Set by startInstruction(), cleared by finishInstruction()">cur_insn</a> = NULL;
<a name="l00239"></a>00239             <a class="code" href="classSymbolicSemantics_1_1Policy.html#a43661b0c3078e35e6dac0473fbef2b2b" title="Property that determines how the stack behaves.">p_discard_popped_memory</a> = <span class="keyword">false</span>;
<a name="l00240"></a>00240             <a class="code" href="classSymbolicSemantics_1_1Policy.html#ab85e968d57a89b32977fedc02bdb5ebc" title="Total number of instructions processed.">ninsns</a> = 0;
<a name="l00241"></a>00241             <a class="code" href="classSymbolicSemantics_1_1Policy.html#ae97a155267ab95e36b889af7963cbb4f" title="The solver to use for Satisfiability Modulo Theory, or NULL.">solver</a> = NULL;
<a name="l00242"></a>00242         }
<a name="l00243"></a>00243 
<a name="l00245"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a0044031ccce1249734d248febb905613">00245</a>         <span class="keywordtype">void</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a0044031ccce1249734d248febb905613" title="Sets the satisfiability modulo theory (SMT) solver to use for certain operations.">set_solver</a>(<a class="code" href="classSMTSolver.html" title="Interface to Satisfiability Modulo Theory (SMT) solvers.">SMTSolver</a> *s) { <a class="code" href="classSymbolicSemantics_1_1Policy.html#ae97a155267ab95e36b889af7963cbb4f" title="The solver to use for Satisfiability Modulo Theory, or NULL.">solver</a> = s; }
<a name="l00246"></a>00246 
<a name="l00248"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a81118baf1900f2a938a6dc90cb817505">00248</a>         <a class="code" href="classSMTSolver.html" title="Interface to Satisfiability Modulo Theory (SMT) solvers.">SMTSolver</a> *<a class="code" href="classSymbolicSemantics_1_1Policy.html#a81118baf1900f2a938a6dc90cb817505" title="Returns the solver that is currently being used.">get_solver</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#ae97a155267ab95e36b889af7963cbb4f" title="The solver to use for Satisfiability Modulo Theory, or NULL.">solver</a>; }
<a name="l00249"></a>00249 
<a name="l00251"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a8e315badcbe419a4ecc45eda011068a2">00251</a>         <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1State.html" title="Represents the entire state of the machine.">State</a>&amp; <a class="code" href="classSymbolicSemantics_1_1Policy.html#a8e315badcbe419a4ecc45eda011068a2" title="Returns the current state.">get_state</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a4ff1f363deb8988a0fa96e04f85e4885" title="Current machine state updated by each processInstruction().">cur_state</a>; }
<a name="l00252"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a5f7905e4fc8c8b2d928a25fad92b4d0a">00252</a>         <a class="code" href="structSymbolicSemantics_1_1State.html" title="Represents the entire state of the machine.">State</a>&amp; <a class="code" href="classSymbolicSemantics_1_1Policy.html#a5f7905e4fc8c8b2d928a25fad92b4d0a">get_state</a>() { <span class="keywordflow">return</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a4ff1f363deb8988a0fa96e04f85e4885" title="Current machine state updated by each processInstruction().">cur_state</a>; }
<a name="l00253"></a>00253 
<a name="l00256"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#ad96dad12900393ab089cebc460e32195">00256</a>         <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1State.html" title="Represents the entire state of the machine.">State</a>&amp; <a class="code" href="classSymbolicSemantics_1_1Policy.html#ad96dad12900393ab089cebc460e32195" title="Returns the original state.">get_orig_state</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a2d75334bcb4671e7b3aec81c7904da45" title="Original machine state, initialized by constructor and mem_write.">orig_state</a>; }
<a name="l00257"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a44922257552cbfb602cdaa74f53d61ef">00257</a>         <a class="code" href="structSymbolicSemantics_1_1State.html" title="Represents the entire state of the machine.">State</a>&amp; <a class="code" href="classSymbolicSemantics_1_1Policy.html#a44922257552cbfb602cdaa74f53d61ef">get_orig_state</a>() { <span class="keywordflow">return</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a2d75334bcb4671e7b3aec81c7904da45" title="Original machine state, initialized by constructor and mem_write.">orig_state</a>; }
<a name="l00258"></a>00258 
<a name="l00260"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#af2e570fffb1401804f0a5bb4be630083">00260</a>         <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a>&amp; <a class="code" href="classSymbolicSemantics_1_1Policy.html#af2e570fffb1401804f0a5bb4be630083" title="Returns the current instruction pointer.">get_ip</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a4ff1f363deb8988a0fa96e04f85e4885" title="Current machine state updated by each processInstruction().">cur_state</a>.<a class="code" href="structSymbolicSemantics_1_1State.html#ab7b69f87b8b838c15abe78d7dace22fc" title="Instruction pointer.">ip</a>; }
<a name="l00261"></a>00261 
<a name="l00263"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a36f10ec8e26406f82a1ff63d4b097647">00263</a>         <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a>&amp; <a class="code" href="classSymbolicSemantics_1_1Policy.html#a36f10ec8e26406f82a1ff63d4b097647" title="Returns the original instruction pointer.">get_orig_ip</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a2d75334bcb4671e7b3aec81c7904da45" title="Original machine state, initialized by constructor and mem_write.">orig_state</a>.<a class="code" href="structSymbolicSemantics_1_1State.html#ab7b69f87b8b838c15abe78d7dace22fc" title="Instruction pointer.">ip</a>; }
<a name="l00264"></a>00264 
<a name="l00266"></a>00266         <a class="code" href="namespaceSymbolicSemantics.html#aa11ebc03c3b442c0f39667422dc5a17a">Memory</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a6763180d8b3ebd0a95f3d30822f8de66" title="Returns a copy of the current state after removing memory that is not pertinent to an equal_states() ...">memory_for_equality</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1State.html" title="Represents the entire state of the machine.">State</a>&amp;) <span class="keyword">const</span>;
<a name="l00267"></a>00267 
<a name="l00269"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a6763180d8b3ebd0a95f3d30822f8de66">00269</a>         <a class="code" href="namespaceSymbolicSemantics.html#aa11ebc03c3b442c0f39667422dc5a17a">Memory</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a6763180d8b3ebd0a95f3d30822f8de66" title="Returns a copy of the current state after removing memory that is not pertinent to an equal_states() ...">memory_for_equality</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a6763180d8b3ebd0a95f3d30822f8de66" title="Returns a copy of the current state after removing memory that is not pertinent to an equal_states() ...">memory_for_equality</a>(<a class="code" href="classSymbolicSemantics_1_1Policy.html#a4ff1f363deb8988a0fa96e04f85e4885" title="Current machine state updated by each processInstruction().">cur_state</a>); }
<a name="l00270"></a>00270 
<a name="l00274"></a>00274         <span class="keywordtype">bool</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a4887299117362699b981656e464e9ff3" title="Compares two states for equality.">equal_states</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1State.html" title="Represents the entire state of the machine.">State</a>&amp;, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1State.html" title="Represents the entire state of the machine.">State</a>&amp;) <span class="keyword">const</span>;
<a name="l00275"></a>00275 
<a name="l00278"></a>00278         <span class="keywordtype">void</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a69f0c2fd93330f62c7dd35ae84f8f20d" title="Print the current state of this policy.">print</a>(std::ostream&amp;, <a class="code" href="namespaceSymbolicSemantics.html#a5148365f05e99b2d11ca3d29056bbfba">RenameMap</a> *rmap=NULL) <span class="keyword">const</span>;
<a name="l00279"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a258bd22a87130030d6740b199fe73094">00279</a>         <span class="keyword">friend</span> std::ostream&amp; <a class="code" href="classSymbolicSemantics_1_1Policy.html#a258bd22a87130030d6740b199fe73094">operator&lt;&lt;</a>(std::ostream &amp;o, <span class="keyword">const</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html" title="A policy that is supplied to the semantic analysis constructor.">Policy</a> &amp;p) {
<a name="l00280"></a>00280             p.<a class="code" href="classSymbolicSemantics_1_1Policy.html#a69f0c2fd93330f62c7dd35ae84f8f20d" title="Print the current state of this policy.">print</a>(o, NULL);
<a name="l00281"></a>00281             <span class="keywordflow">return</span> o;
<a name="l00282"></a>00282         }
<a name="l00283"></a>00283 
<a name="l00286"></a>00286         <span class="keywordtype">bool</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#aed439152ae431370f0a45011acfa8b10" title="Returns true if the specified value exists in memory and is provably at or above the stack pointer...">on_stack</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;value) <span class="keyword">const</span>;
<a name="l00287"></a>00287 
<a name="l00289"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#ac1ebe77ec12e9b0128f465dcfae6544d">00289</a>         <span class="keywordtype">void</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#ac1ebe77ec12e9b0128f465dcfae6544d" title="Changes how the policy treats the stack.">set_discard_popped_memory</a>(<span class="keywordtype">bool</span> b) {
<a name="l00290"></a>00290             <a class="code" href="classSymbolicSemantics_1_1Policy.html#a43661b0c3078e35e6dac0473fbef2b2b" title="Property that determines how the stack behaves.">p_discard_popped_memory</a> = b;
<a name="l00291"></a>00291         }
<a name="l00292"></a>00292 
<a name="l00295"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a1d41c0b7645e8a08c3ca394f8a3cbe6f">00295</a>         <span class="keywordtype">bool</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a1d41c0b7645e8a08c3ca394f8a3cbe6f" title="Returns the current setting for the property that determines how the stack behaves.">get_discard_popped_memory</a>()<span class="keyword"> const </span>{
<a name="l00296"></a>00296             <span class="keywordflow">return</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a43661b0c3078e35e6dac0473fbef2b2b" title="Property that determines how the stack behaves.">p_discard_popped_memory</a>;
<a name="l00297"></a>00297         }
<a name="l00298"></a>00298 
<a name="l00301"></a>00301         <span class="keywordtype">void</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a93f262774b3bc03fd3bba7861a597f65" title="Print only the differences between two states.">print_diff</a>(std::ostream&amp;, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1State.html" title="Represents the entire state of the machine.">State</a>&amp;, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1State.html" title="Represents the entire state of the machine.">State</a>&amp;, <a class="code" href="namespaceSymbolicSemantics.html#a5148365f05e99b2d11ca3d29056bbfba">RenameMap</a> *rmap=NULL) <span class="keyword">const</span> ;
<a name="l00302"></a>00302 
<a name="l00305"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a451c91c0b24f33493856b84b24829285">00305</a>         <span class="keywordtype">void</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a451c91c0b24f33493856b84b24829285" title="Print the difference between a state and the initial state.">print_diff</a>(std::ostream &amp;o, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1State.html" title="Represents the entire state of the machine.">State</a> &amp;state, <a class="code" href="namespaceSymbolicSemantics.html#a5148365f05e99b2d11ca3d29056bbfba">RenameMap</a> *rmap=NULL)<span class="keyword"> const </span>{
<a name="l00306"></a>00306             <a class="code" href="classSymbolicSemantics_1_1Policy.html#a93f262774b3bc03fd3bba7861a597f65" title="Print only the differences between two states.">print_diff</a>(o, <a class="code" href="classSymbolicSemantics_1_1Policy.html#a2d75334bcb4671e7b3aec81c7904da45" title="Original machine state, initialized by constructor and mem_write.">orig_state</a>, state, rmap);
<a name="l00307"></a>00307         }
<a name="l00308"></a>00308 
<a name="l00311"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#ad467ffff612e8d0b7008bbcbfd34c003">00311</a>         <span class="keywordtype">void</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#ad467ffff612e8d0b7008bbcbfd34c003" title="Print the difference between the current state and the initial state.">print_diff</a>(std::ostream &amp;o, <a class="code" href="namespaceSymbolicSemantics.html#a5148365f05e99b2d11ca3d29056bbfba">RenameMap</a> *rmap=NULL)<span class="keyword"> const </span>{
<a name="l00312"></a>00312             <a class="code" href="classSymbolicSemantics_1_1Policy.html#a93f262774b3bc03fd3bba7861a597f65" title="Print only the differences between two states.">print_diff</a>(o, <a class="code" href="classSymbolicSemantics_1_1Policy.html#a2d75334bcb4671e7b3aec81c7904da45" title="Original machine state, initialized by constructor and mem_write.">orig_state</a>, <a class="code" href="classSymbolicSemantics_1_1Policy.html#a4ff1f363deb8988a0fa96e04f85e4885" title="Current machine state updated by each processInstruction().">cur_state</a>, rmap);
<a name="l00313"></a>00313         }
<a name="l00314"></a>00314 
<a name="l00317"></a>00317         std::string <a class="code" href="classSymbolicSemantics_1_1Policy.html#a06809027349251b5ed7976db3a08f34b" title="Returns the SHA1 hash of the difference between the current state and the original state...">SHA1</a>() <span class="keyword">const</span>;
<a name="l00318"></a>00318 
<a name="l00321"></a>00321         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> FromLen, <span class="keywordtype">size_t</span> ToLen&gt;
<a name="l00322"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#aff36e78cd5b42cb3a5b043ff0a433b2b">00322</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;ToLen&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#aff36e78cd5b42cb3a5b043ff0a433b2b" title="Extend (or shrink) from FromLen bits to ToLen bits by adding or removing high-order bits from the inp...">unsignedExtend</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;FromLen&gt;</a> &amp;a)<span class="keyword"> const </span>{
<a name="l00323"></a>00323             <span class="keywordflow">if</span> (a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>())
<a name="l00324"></a>00324                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;ToLen&gt;</a>(<a class="code" href="structIntegerOps_1_1GenMask.html">IntegerOps::GenMask&lt;uint64_t,ToLen&gt;::value</a> &amp; a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>());
<a name="l00325"></a>00325             <span class="keywordflow">if</span> (FromLen==ToLen)
<a name="l00326"></a>00326                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;ToLen&gt;</a>(a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>);
<a name="l00327"></a>00327             <span class="keywordflow">if</span> (FromLen&gt;ToLen)
<a name="l00328"></a>00328                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;ToLen&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(ToLen, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969adb8bbdd081026c212180181dff129771" title="Extract subsequence of bits.">InsnSemanticsExpr::OP_EXTRACT</a>,
<a name="l00329"></a>00329                                                          <a class="code" href="classInsnSemanticsExpr_1_1LeafNode.html#a5c5a9606638db5e4fbb6990c55084d1c" title="Construct a new integer with the specified number of significant bits.">LeafNode::create_integer</a>(32, 0),
<a name="l00330"></a>00330                                                          <a class="code" href="classInsnSemanticsExpr_1_1LeafNode.html#a5c5a9606638db5e4fbb6990c55084d1c" title="Construct a new integer with the specified number of significant bits.">LeafNode::create_integer</a>(32, ToLen),
<a name="l00331"></a>00331                                                          a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00332"></a>00332             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;ToLen&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(ToLen, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969aa43cddc86dcc8478030651c08e752e9f" title="Unsigned extention at msb.">InsnSemanticsExpr::OP_UEXTEND</a>,
<a name="l00333"></a>00333                                                      <a class="code" href="classInsnSemanticsExpr_1_1LeafNode.html#a5c5a9606638db5e4fbb6990c55084d1c" title="Construct a new integer with the specified number of significant bits.">LeafNode::create_integer</a>(32, ToLen), a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00334"></a>00334         }
<a name="l00335"></a>00335 
<a name="l00337"></a>00337         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> FromLen, <span class="keywordtype">size_t</span> ToLen&gt;
<a name="l00338"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a9887bd28580672f1b2d415bd0944fabd">00338</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;ToLen&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a9887bd28580672f1b2d415bd0944fabd" title="Sign extend from FromLen bits to ToLen bits.">signedExtend</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;FromLen&gt;</a> &amp;a)<span class="keyword"> const </span>{
<a name="l00339"></a>00339             <span class="keywordflow">if</span> (a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>())
<a name="l00340"></a>00340                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;ToLen&gt;</a>(IntegerOps::signExtend&lt;FromLen, ToLen&gt;(a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>()));
<a name="l00341"></a>00341             <span class="keywordflow">if</span> (FromLen==ToLen)
<a name="l00342"></a>00342                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;ToLen&gt;</a>(a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>);
<a name="l00343"></a>00343             <span class="keywordflow">if</span> (FromLen &gt; ToLen)
<a name="l00344"></a>00344                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;ToLen&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(ToLen, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969adb8bbdd081026c212180181dff129771" title="Extract subsequence of bits.">InsnSemanticsExpr::OP_EXTRACT</a>,
<a name="l00345"></a>00345                                                          <a class="code" href="classInsnSemanticsExpr_1_1LeafNode.html#a5c5a9606638db5e4fbb6990c55084d1c" title="Construct a new integer with the specified number of significant bits.">LeafNode::create_integer</a>(32, 0),
<a name="l00346"></a>00346                                                          <a class="code" href="classInsnSemanticsExpr_1_1LeafNode.html#a5c5a9606638db5e4fbb6990c55084d1c" title="Construct a new integer with the specified number of significant bits.">LeafNode::create_integer</a>(32, ToLen),
<a name="l00347"></a>00347                                                          a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00348"></a>00348             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;ToLen&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(ToLen, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969a078ee7503250acc4910d649419bd473e" title="Signed extension at msb.">InsnSemanticsExpr::OP_SEXTEND</a>,
<a name="l00349"></a>00349                                                      <a class="code" href="classInsnSemanticsExpr_1_1LeafNode.html#a5c5a9606638db5e4fbb6990c55084d1c" title="Construct a new integer with the specified number of significant bits.">LeafNode::create_integer</a>(32, ToLen), a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00350"></a>00350         }
<a name="l00351"></a>00351 
<a name="l00354"></a>00354         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> BeginAt, <span class="keywordtype">size_t</span> EndAt, <span class="keywordtype">size_t</span> Len&gt;
<a name="l00355"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#af28c00e05f0fc17eb748d3f3c25ffa4b">00355</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType</a>&lt;EndAt-BeginAt&gt; <a class="code" href="classSymbolicSemantics_1_1Policy.html#af28c00e05f0fc17eb748d3f3c25ffa4b" title="Extracts certain bits from the specified value and shifts them to the low-order positions in the resu...">extract</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;a)<span class="keyword"> const </span>{
<a name="l00356"></a>00356             <span class="keywordflow">if</span> (0==BeginAt)
<a name="l00357"></a>00357                 <span class="keywordflow">return</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#aff36e78cd5b42cb3a5b043ff0a433b2b" title="Extend (or shrink) from FromLen bits to ToLen bits by adding or removing high-order bits from the inp...">unsignedExtend</a>&lt;Len,EndAt-BeginAt&gt;(a);
<a name="l00358"></a>00358             <span class="keywordflow">if</span> (a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>())
<a name="l00359"></a>00359                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;EndAt-BeginAt&gt;</a>((a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>()&gt;&gt;BeginAt) &amp; IntegerOps::genMask&lt;uint64_t&gt;(EndAt-BeginAt));
<a name="l00360"></a>00360             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType</a>&lt;EndAt-BeginAt&gt;(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(EndAt-BeginAt, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969adb8bbdd081026c212180181dff129771" title="Extract subsequence of bits.">InsnSemanticsExpr::OP_EXTRACT</a>,
<a name="l00361"></a>00361                                                              <a class="code" href="classInsnSemanticsExpr_1_1LeafNode.html#a5c5a9606638db5e4fbb6990c55084d1c" title="Construct a new integer with the specified number of significant bits.">LeafNode::create_integer</a>(32, BeginAt),
<a name="l00362"></a>00362                                                              <a class="code" href="classInsnSemanticsExpr_1_1LeafNode.html#a5c5a9606638db5e4fbb6990c55084d1c" title="Construct a new integer with the specified number of significant bits.">LeafNode::create_integer</a>(32, EndAt),
<a name="l00363"></a>00363                                                              a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00364"></a>00364         }
<a name="l00365"></a>00365 
<a name="l00374"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a70f32592732a58b6d2a534c5227cc703">00374</a>         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt; <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a70f32592732a58b6d2a534c5227cc703" title="Reads a value from memory in a way that always returns the same value provided there are not interven...">mem_read</a>(<a class="code" href="structSymbolicSemantics_1_1State.html" title="Represents the entire state of the machine.">State</a> &amp;state, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;addr)<span class="keyword"> const </span>{
<a name="l00375"></a>00375             <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html" title="Represents one location in memory.">MemoryCell</a> new_cell(addr, <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a>(), Len/8);
<a name="l00376"></a>00376             <span class="keywordtype">bool</span> aliased = <span class="keyword">false</span>; <span class="comment">/*is new_cell aliased by any existing writes?*/</span>
<a name="l00377"></a>00377 
<a name="l00378"></a>00378             <span class="keywordflow">for</span> (Memory::iterator mi=state.<a class="code" href="structSymbolicSemantics_1_1State.html#a33bea68a1f6ac63deb9b34563ffc32a3" title="Core memory.">mem</a>.begin(); mi!=state.<a class="code" href="structSymbolicSemantics_1_1State.html#a33bea68a1f6ac63deb9b34563ffc32a3" title="Core memory.">mem</a>.end(); ++mi) {
<a name="l00379"></a>00379                 <span class="keywordflow">if</span> (new_cell.<a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#ac9b305b2fdcc5f941fdfdc21573eae26" title="Returns true if this memory address is the same as the other.">must_alias</a>(*mi, <a class="code" href="classSymbolicSemantics_1_1Policy.html#ae97a155267ab95e36b889af7963cbb4f" title="The solver to use for Satisfiability Modulo Theory, or NULL.">solver</a>)) {
<a name="l00380"></a>00380                     <span class="keywordflow">if</span> ((*mi).clobbered) {
<a name="l00381"></a>00381                         (*mi).clobbered = <span class="keyword">false</span>;
<a name="l00382"></a>00382                         (*mi).data = new_cell.<a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#a25159c75a164c15230b745c0ef072b54">data</a>;
<a name="l00383"></a>00383                         <span class="keywordflow">return</span> unsignedExtend&lt;32, Len&gt;(new_cell.<a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#a25159c75a164c15230b745c0ef072b54">data</a>);
<a name="l00384"></a>00384                     } <span class="keywordflow">else</span> {
<a name="l00385"></a>00385                         <span class="keywordflow">return</span> unsignedExtend&lt;32, Len&gt;((*mi).data);
<a name="l00386"></a>00386                     }
<a name="l00387"></a>00387                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((*mi).written &amp;&amp; new_cell.<a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#abf8d9b6cb5f69802b84750fa8432ae02" title="Returns true if this memory value could possibly overlap with the other memory value.">may_alias</a>(*mi, <a class="code" href="classSymbolicSemantics_1_1Policy.html#ae97a155267ab95e36b889af7963cbb4f" title="The solver to use for Satisfiability Modulo Theory, or NULL.">solver</a>)) {
<a name="l00388"></a>00388                     aliased = <span class="keyword">true</span>;
<a name="l00389"></a>00389                 }
<a name="l00390"></a>00390             }
<a name="l00391"></a>00391 
<a name="l00392"></a>00392             <span class="keywordflow">if</span> (!aliased &amp;&amp; &amp;state!=&amp;<a class="code" href="classSymbolicSemantics_1_1Policy.html#a2d75334bcb4671e7b3aec81c7904da45" title="Original machine state, initialized by constructor and mem_write.">orig_state</a>) {
<a name="l00393"></a>00393                 <span class="comment">/* We didn&#39;t find the memory cell in the specified state and it&#39;s not aliased to any writes in that state.</span>
<a name="l00394"></a>00394 <span class="comment">                 * Therefore use the value from the initial memory state (creating it if necessary). */</span>
<a name="l00395"></a>00395                 <span class="keywordflow">for</span> (Memory::iterator mi=<a class="code" href="classSymbolicSemantics_1_1Policy.html#a2d75334bcb4671e7b3aec81c7904da45" title="Original machine state, initialized by constructor and mem_write.">orig_state</a>.<a class="code" href="structSymbolicSemantics_1_1State.html#a33bea68a1f6ac63deb9b34563ffc32a3" title="Core memory.">mem</a>.begin(); mi!=<a class="code" href="classSymbolicSemantics_1_1Policy.html#a2d75334bcb4671e7b3aec81c7904da45" title="Original machine state, initialized by constructor and mem_write.">orig_state</a>.<a class="code" href="structSymbolicSemantics_1_1State.html#a33bea68a1f6ac63deb9b34563ffc32a3" title="Core memory.">mem</a>.end(); ++mi) {
<a name="l00396"></a>00396                     <span class="keywordflow">if</span> (new_cell.<a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#ac9b305b2fdcc5f941fdfdc21573eae26" title="Returns true if this memory address is the same as the other.">must_alias</a>(*mi, <a class="code" href="classSymbolicSemantics_1_1Policy.html#ae97a155267ab95e36b889af7963cbb4f" title="The solver to use for Satisfiability Modulo Theory, or NULL.">solver</a>)) {
<a name="l00397"></a>00397                         ROSE_ASSERT(!(*mi).clobbered);
<a name="l00398"></a>00398                         ROSE_ASSERT(!(*mi).written);
<a name="l00399"></a>00399                         state.<a class="code" href="structSymbolicSemantics_1_1State.html#a33bea68a1f6ac63deb9b34563ffc32a3" title="Core memory.">mem</a>.push_back(*mi);
<a name="l00400"></a>00400                         <span class="keywordflow">return</span> unsignedExtend&lt;32, Len&gt;((*mi).data);
<a name="l00401"></a>00401                     }
<a name="l00402"></a>00402                 }
<a name="l00403"></a>00403 
<a name="l00404"></a>00404                 <a class="code" href="classSymbolicSemantics_1_1Policy.html#a2d75334bcb4671e7b3aec81c7904da45" title="Original machine state, initialized by constructor and mem_write.">orig_state</a>.<a class="code" href="structSymbolicSemantics_1_1State.html#a33bea68a1f6ac63deb9b34563ffc32a3" title="Core memory.">mem</a>.push_back(new_cell);
<a name="l00405"></a>00405             }
<a name="l00406"></a>00406 
<a name="l00407"></a>00407             <span class="comment">/* Create the cell in the current state. */</span>
<a name="l00408"></a>00408             state.<a class="code" href="structSymbolicSemantics_1_1State.html#a33bea68a1f6ac63deb9b34563ffc32a3" title="Core memory.">mem</a>.push_back(new_cell);
<a name="l00409"></a>00409             <span class="keywordflow">return</span> unsignedExtend&lt;32,Len&gt;(new_cell.<a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#a25159c75a164c15230b745c0ef072b54">data</a>);
<a name="l00410"></a>00410         }
<a name="l00411"></a>00411 
<a name="l00413"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#ac2f8b20f44d974292ce56cef0bbd765ba3e60a6fdb033b9c054be838e83c9c0c5">00413</a>         <span class="keyword">enum</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#ac2f8b20f44d974292ce56cef0bbd765b" title="See memory_reference_type().">MemRefType</a> { <a class="code" href="classSymbolicSemantics_1_1Policy.html#ac2f8b20f44d974292ce56cef0bbd765ba3e60a6fdb033b9c054be838e83c9c0c5">MRT_STACK_PTR</a>, <a class="code" href="classSymbolicSemantics_1_1Policy.html#ac2f8b20f44d974292ce56cef0bbd765ba56cef8e1af926a9367050611844d6180">MRT_FRAME_PTR</a>, <a class="code" href="classSymbolicSemantics_1_1Policy.html#ac2f8b20f44d974292ce56cef0bbd765baca249bfa0f4f39d5229179d9fc03a524">MRT_OTHER_PTR</a> };
<a name="l00414"></a>00414 
<a name="l00418"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a35c2d05c0b5468e5b7e6aea4ef12c0b6">00418</a>         <a class="code" href="classSymbolicSemantics_1_1Policy.html#ac2f8b20f44d974292ce56cef0bbd765b" title="See memory_reference_type().">MemRefType</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a35c2d05c0b5468e5b7e6aea4ef12c0b6" title="Determines if the specified address is related to the current stack or frame pointer.">memory_reference_type</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1State.html" title="Represents the entire state of the machine.">State</a> &amp;state, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;addr)<span class="keyword"> const </span>{
<a name="l00419"></a>00419 <span class="preprocessor">#if 0 </span><span class="comment">/*FIXME: not implemented yet [RPM 2010-05-24]*/</span>
<a name="l00420"></a>00420             <span class="keywordflow">if</span> (addr.name) {
<a name="l00421"></a>00421                 <span class="keywordflow">if</span> (addr.name==state.<a class="code" href="structSymbolicSemantics_1_1State.html#aa4eba52bac554f862e1a3f1723ccfe3a" title="General-purpose registers.">gpr</a>[<a class="code" href="InstructionEnumsX86_8h.html#a5069ca462f85d162797843f48bc6bceda1f5849637e513ff627dc7360562d1ca0">x86_gpr_sp</a>].name) <span class="keywordflow">return</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#ac2f8b20f44d974292ce56cef0bbd765ba3e60a6fdb033b9c054be838e83c9c0c5">MRT_STACK_PTR</a>;
<a name="l00422"></a>00422                 <span class="keywordflow">if</span> (addr.name==state.<a class="code" href="structSymbolicSemantics_1_1State.html#aa4eba52bac554f862e1a3f1723ccfe3a" title="General-purpose registers.">gpr</a>[<a class="code" href="InstructionEnumsX86_8h.html#a5069ca462f85d162797843f48bc6bcedaa9ec94ced24945de2d3e64be23e8a19b">x86_gpr_bp</a>].name) <span class="keywordflow">return</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#ac2f8b20f44d974292ce56cef0bbd765ba56cef8e1af926a9367050611844d6180">MRT_FRAME_PTR</a>;
<a name="l00423"></a>00423                 <span class="keywordflow">return</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#ac2f8b20f44d974292ce56cef0bbd765baca249bfa0f4f39d5229179d9fc03a524">MRT_OTHER_PTR</a>;
<a name="l00424"></a>00424             }
<a name="l00425"></a>00425             <span class="keywordflow">if</span> (addr==state.<a class="code" href="structSymbolicSemantics_1_1State.html#aa4eba52bac554f862e1a3f1723ccfe3a" title="General-purpose registers.">gpr</a>[<a class="code" href="InstructionEnumsX86_8h.html#a5069ca462f85d162797843f48bc6bceda1f5849637e513ff627dc7360562d1ca0">x86_gpr_sp</a>]) <span class="keywordflow">return</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#ac2f8b20f44d974292ce56cef0bbd765ba3e60a6fdb033b9c054be838e83c9c0c5">MRT_STACK_PTR</a>;
<a name="l00426"></a>00426             <span class="keywordflow">if</span> (addr==state.<a class="code" href="structSymbolicSemantics_1_1State.html#aa4eba52bac554f862e1a3f1723ccfe3a" title="General-purpose registers.">gpr</a>[<a class="code" href="InstructionEnumsX86_8h.html#a5069ca462f85d162797843f48bc6bcedaa9ec94ced24945de2d3e64be23e8a19b">x86_gpr_bp</a>]) <span class="keywordflow">return</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#ac2f8b20f44d974292ce56cef0bbd765ba56cef8e1af926a9367050611844d6180">MRT_FRAME_PTR</a>;
<a name="l00427"></a>00427 <span class="preprocessor">#endif</span>
<a name="l00428"></a>00428 <span class="preprocessor"></span>            <span class="keywordflow">return</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#ac2f8b20f44d974292ce56cef0bbd765baca249bfa0f4f39d5229179d9fc03a524">MRT_OTHER_PTR</a>;
<a name="l00429"></a>00429         }
<a name="l00430"></a>00430 
<a name="l00433"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a64ab14d885dc6a6b7e7c299607e18b78">00433</a>         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt; <span class="keywordtype">void</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a64ab14d885dc6a6b7e7c299607e18b78" title="Writes a value to memory.">mem_write</a>(<a class="code" href="structSymbolicSemantics_1_1State.html" title="Represents the entire state of the machine.">State</a> &amp;state, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;addr, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;data) {
<a name="l00434"></a>00434             ROSE_ASSERT(&amp;state!=&amp;<a class="code" href="classSymbolicSemantics_1_1Policy.html#a2d75334bcb4671e7b3aec81c7904da45" title="Original machine state, initialized by constructor and mem_write.">orig_state</a>);
<a name="l00435"></a>00435             <a class="code" href="structSymbolicSemantics_1_1MemoryCell.html" title="Represents one location in memory.">MemoryCell</a> new_cell(addr, unsignedExtend&lt;Len, 32&gt;(data), Len/8);
<a name="l00436"></a>00436             new_cell.<a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#ad011025e2126bd8d7550f3704244c93f">set_written</a>();
<a name="l00437"></a>00437             <span class="keywordtype">bool</span> saved = <span class="keyword">false</span>; <span class="comment">/* has new_cell been saved into memory? */</span>
<a name="l00438"></a>00438 
<a name="l00439"></a>00439             <span class="comment">/* Is new memory reference through the stack pointer or frame pointer? */</span>
<a name="l00440"></a>00440             <a class="code" href="classSymbolicSemantics_1_1Policy.html#ac2f8b20f44d974292ce56cef0bbd765b" title="See memory_reference_type().">MemRefType</a> new_mrt = <a class="code" href="classSymbolicSemantics_1_1Policy.html#a35c2d05c0b5468e5b7e6aea4ef12c0b6" title="Determines if the specified address is related to the current stack or frame pointer.">memory_reference_type</a>(state, addr);
<a name="l00441"></a>00441 
<a name="l00442"></a>00442             <span class="comment">/* Overwrite and/or clobber existing memory locations. */</span>
<a name="l00443"></a>00443             <span class="keywordflow">for</span> (Memory::iterator mi=state.<a class="code" href="structSymbolicSemantics_1_1State.html#a33bea68a1f6ac63deb9b34563ffc32a3" title="Core memory.">mem</a>.begin(); mi!=state.<a class="code" href="structSymbolicSemantics_1_1State.html#a33bea68a1f6ac63deb9b34563ffc32a3" title="Core memory.">mem</a>.end(); ++mi) {
<a name="l00444"></a>00444                 <span class="keywordflow">if</span> (new_cell.<a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#ac9b305b2fdcc5f941fdfdc21573eae26" title="Returns true if this memory address is the same as the other.">must_alias</a>(*mi, <a class="code" href="classSymbolicSemantics_1_1Policy.html#ae97a155267ab95e36b889af7963cbb4f" title="The solver to use for Satisfiability Modulo Theory, or NULL.">solver</a>)) {
<a name="l00445"></a>00445                     *mi = new_cell;
<a name="l00446"></a>00446                     saved = <span class="keyword">true</span>;
<a name="l00447"></a>00447                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classSymbolicSemantics_1_1Policy.html#a43661b0c3078e35e6dac0473fbef2b2b" title="Property that determines how the stack behaves.">p_discard_popped_memory</a> &amp;&amp; new_mrt!=<a class="code" href="classSymbolicSemantics_1_1Policy.html#a35c2d05c0b5468e5b7e6aea4ef12c0b6" title="Determines if the specified address is related to the current stack or frame pointer.">memory_reference_type</a>(state, (*mi).address)) {
<a name="l00448"></a>00448                     <span class="comment">/* Assume that memory referenced through the stack pointer does not alias that which is referenced through the</span>
<a name="l00449"></a>00449 <span class="comment">                     * frame pointer, and neither of them alias memory that is referenced other ways. */</span>
<a name="l00450"></a>00450                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (new_cell.<a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#abf8d9b6cb5f69802b84750fa8432ae02" title="Returns true if this memory value could possibly overlap with the other memory value.">may_alias</a>(*mi, <a class="code" href="classSymbolicSemantics_1_1Policy.html#ae97a155267ab95e36b889af7963cbb4f" title="The solver to use for Satisfiability Modulo Theory, or NULL.">solver</a>)) {
<a name="l00451"></a>00451                     (*mi).<a class="code" href="structSymbolicSemantics_1_1MemoryCell.html#a060a9cf4523046f7e5c8417f8dd8d76a">set_clobbered</a>();
<a name="l00452"></a>00452                 } <span class="keywordflow">else</span> {
<a name="l00453"></a>00453                     <span class="comment">/* memory cell *mi is not aliased to cell being written */</span>
<a name="l00454"></a>00454                 }
<a name="l00455"></a>00455             }
<a name="l00456"></a>00456             <span class="keywordflow">if</span> (!saved)
<a name="l00457"></a>00457                 state.<a class="code" href="structSymbolicSemantics_1_1State.html#a33bea68a1f6ac63deb9b34563ffc32a3" title="Core memory.">mem</a>.push_back(new_cell);
<a name="l00458"></a>00458         }
<a name="l00459"></a>00459 
<a name="l00460"></a>00460 
<a name="l00461"></a>00461         <span class="comment">/*************************************************************************************************************************</span>
<a name="l00462"></a>00462 <span class="comment">         * Functions invoked by the X86InstructionSemantics class for every processed instructions</span>
<a name="l00463"></a>00463 <span class="comment">         *************************************************************************************************************************/</span>
<a name="l00464"></a>00464 
<a name="l00465"></a>00465         <span class="comment">/* Called at the beginning of X86InstructionSemantics::processInstruction() */</span>
<a name="l00466"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#acf99fa44dab67621c077ce853156b63c">00466</a>         <span class="keywordtype">void</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#acf99fa44dab67621c077ce853156b63c">startInstruction</a>(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn) {
<a name="l00467"></a>00467             <a class="code" href="classSymbolicSemantics_1_1Policy.html#a4ff1f363deb8988a0fa96e04f85e4885" title="Current machine state updated by each processInstruction().">cur_state</a>.<a class="code" href="structSymbolicSemantics_1_1State.html#ab7b69f87b8b838c15abe78d7dace22fc" title="Instruction pointer.">ip</a> = <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a>(insn-&gt;<a class="code" href="classSgAsmStatement.html#a9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>());
<a name="l00468"></a>00468             <span class="keywordflow">if</span> (0==<a class="code" href="classSymbolicSemantics_1_1Policy.html#ab85e968d57a89b32977fedc02bdb5ebc" title="Total number of instructions processed.">ninsns</a>++)
<a name="l00469"></a>00469                 <a class="code" href="classSymbolicSemantics_1_1Policy.html#a2d75334bcb4671e7b3aec81c7904da45" title="Original machine state, initialized by constructor and mem_write.">orig_state</a> = <a class="code" href="classSymbolicSemantics_1_1Policy.html#a4ff1f363deb8988a0fa96e04f85e4885" title="Current machine state updated by each processInstruction().">cur_state</a>;
<a name="l00470"></a>00470             <a class="code" href="classSymbolicSemantics_1_1Policy.html#acaa5e9fa30b339215f03b058ca2c0312" title="Set by startInstruction(), cleared by finishInstruction()">cur_insn</a> = insn;
<a name="l00471"></a>00471         }
<a name="l00472"></a>00472 
<a name="l00473"></a>00473         <span class="comment">/* Called at the end of X86InstructionSemantics::processInstruction() */</span>
<a name="l00474"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a60b62828f3e883a3e3c86727c7b00623">00474</a>         <span class="keywordtype">void</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a60b62828f3e883a3e3c86727c7b00623">finishInstruction</a>(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a>*) {
<a name="l00475"></a>00475             <span class="keywordflow">if</span> (<a class="code" href="classSymbolicSemantics_1_1Policy.html#a43661b0c3078e35e6dac0473fbef2b2b" title="Property that determines how the stack behaves.">p_discard_popped_memory</a>)
<a name="l00476"></a>00476                 <a class="code" href="classSymbolicSemantics_1_1Policy.html#a4ff1f363deb8988a0fa96e04f85e4885" title="Current machine state updated by each processInstruction().">cur_state</a>.<a class="code" href="structSymbolicSemantics_1_1State.html#a21c4fd988e28c43b36d314dbbdf79c60" title="Removes from memory those values at addresses below the current stack pointer.">discard_popped_memory</a>();
<a name="l00477"></a>00477             <a class="code" href="classSymbolicSemantics_1_1Policy.html#acaa5e9fa30b339215f03b058ca2c0312" title="Set by startInstruction(), cleared by finishInstruction()">cur_insn</a> = NULL;
<a name="l00478"></a>00478         }
<a name="l00479"></a>00479 
<a name="l00480"></a>00480 
<a name="l00481"></a>00481 
<a name="l00482"></a>00482         <span class="comment">/*************************************************************************************************************************</span>
<a name="l00483"></a>00483 <span class="comment">         * Functions invoked by the X86InstructionSemantics class to construct values</span>
<a name="l00484"></a>00484 <span class="comment">         *************************************************************************************************************************/</span>
<a name="l00485"></a>00485 
<a name="l00487"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a2889fb4f6968cc9b64636408aa909b25">00487</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;1&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a2889fb4f6968cc9b64636408aa909b25" title="True value.">true_</a>()<span class="keyword"> const </span>{
<a name="l00488"></a>00488             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;1&gt;</a>(1);
<a name="l00489"></a>00489         }
<a name="l00490"></a>00490 
<a name="l00492"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#aaf081b947bedf2fd07bab2162f7a81cd">00492</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;1&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#aaf081b947bedf2fd07bab2162f7a81cd" title="False value.">false_</a>()<span class="keyword"> const </span>{
<a name="l00493"></a>00493             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;1&gt;</a>((uint64_t)0);
<a name="l00494"></a>00494         }
<a name="l00495"></a>00495 
<a name="l00497"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#add456fde3ce50f023a1a00d7bcb96e48">00497</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;1&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#add456fde3ce50f023a1a00d7bcb96e48" title="Undefined Boolean.">undefined_</a>()<span class="keyword"> const </span>{
<a name="l00498"></a>00498             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;1&gt;</a>();
<a name="l00499"></a>00499         }
<a name="l00500"></a>00500 
<a name="l00502"></a>00502         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00503"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a8ea0f065d804498c8d1afda14b50f72b">00503</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a8ea0f065d804498c8d1afda14b50f72b" title="Used to build a known constant.">number</a>(uint64_t n)<span class="keyword"> const </span>{
<a name="l00504"></a>00504             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(n);
<a name="l00505"></a>00505         }
<a name="l00506"></a>00506 
<a name="l00507"></a>00507 
<a name="l00508"></a>00508 
<a name="l00509"></a>00509         <span class="comment">/*************************************************************************************************************************</span>
<a name="l00510"></a>00510 <span class="comment">         * Functions invoked by the X86InstructionSemantics class for individual instructions</span>
<a name="l00511"></a>00511 <span class="comment">         *************************************************************************************************************************/</span>
<a name="l00512"></a>00512 
<a name="l00514"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a5c15931175035976f787185dd961b494">00514</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a5c15931175035976f787185dd961b494" title="Called only for CALL instructions before assigning new value to IP register.">filterCallTarget</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;a)<span class="keyword"> const </span>{
<a name="l00515"></a>00515             <span class="keywordflow">return</span> a;
<a name="l00516"></a>00516         }
<a name="l00517"></a>00517 
<a name="l00519"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#aedab7b024fa628dcd93e2ddb5ed56320">00519</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#aedab7b024fa628dcd93e2ddb5ed56320" title="Called only for RET instructions before adjusting the IP register.">filterReturnTarget</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;a)<span class="keyword"> const </span>{
<a name="l00520"></a>00520             <span class="keywordflow">return</span> a;
<a name="l00521"></a>00521         }
<a name="l00522"></a>00522 
<a name="l00524"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#ab9baadf8f30dcc43ce4f5487f3acac7c">00524</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#ab9baadf8f30dcc43ce4f5487f3acac7c" title="Called only for JMP instructions before adjusting the IP register.">filterIndirectJumpTarget</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;a)<span class="keyword"> const </span>{
<a name="l00525"></a>00525             <span class="keywordflow">return</span> a;
<a name="l00526"></a>00526         }
<a name="l00527"></a>00527 
<a name="l00529"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a33bdd5bfc7147c1d7fca90c9b747fce7">00529</a>         <span class="keywordtype">void</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a33bdd5bfc7147c1d7fca90c9b747fce7" title="Called only for the HLT instruction.">hlt</a>() {} <span class="comment">// FIXME</span>
<a name="l00530"></a>00530 
<a name="l00532"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#ae16664ca002b37bd443f33a652a2302f">00532</a>         <span class="keywordtype">void</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#ae16664ca002b37bd443f33a652a2302f" title="Called only for the CPUID instruction.">cpuid</a>() {} <span class="comment">// FIXME</span>
<a name="l00533"></a>00533 
<a name="l00535"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a3e537cf530b991b84b71f284fd30178d">00535</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;64&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a3e537cf530b991b84b71f284fd30178d" title="Called only for the RDTSC instruction.">rdtsc</a>() {
<a name="l00536"></a>00536             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;64&gt;</a>((uint64_t)0);
<a name="l00537"></a>00537         }
<a name="l00538"></a>00538 
<a name="l00540"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#ab0ba95e29940a7ab6ac594f9eb8e9ca0">00540</a>         <span class="keywordtype">void</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#ab0ba95e29940a7ab6ac594f9eb8e9ca0" title="Called only for the INT instruction.">interrupt</a>(uint8_t num) {
<a name="l00541"></a>00541             <a class="code" href="classSymbolicSemantics_1_1Policy.html#a4ff1f363deb8988a0fa96e04f85e4885" title="Current machine state updated by each processInstruction().">cur_state</a> = <a class="code" href="structSymbolicSemantics_1_1State.html" title="Represents the entire state of the machine.">State</a>(); <span class="comment">/*reset entire machine state*/</span>
<a name="l00542"></a>00542         }
<a name="l00543"></a>00543 
<a name="l00545"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a0da9f322591a17368c9a8a26335c24ff">00545</a>         <span class="keywordtype">void</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a0da9f322591a17368c9a8a26335c24ff" title="Called for SYSENTER instruction.">sysenter</a>() {
<a name="l00546"></a>00546             <a class="code" href="classSymbolicSemantics_1_1Policy.html#a4ff1f363deb8988a0fa96e04f85e4885" title="Current machine state updated by each processInstruction().">cur_state</a> = <a class="code" href="structSymbolicSemantics_1_1State.html" title="Represents the entire state of the machine.">State</a>(); <span class="comment">/*reset entire machine state*/</span>
<a name="l00547"></a>00547         }
<a name="l00548"></a>00548 
<a name="l00549"></a>00549 
<a name="l00550"></a>00550 
<a name="l00551"></a>00551         <span class="comment">/*************************************************************************************************************************</span>
<a name="l00552"></a>00552 <span class="comment">         * Functions invoked by the X86InstructionSemantics class for data access operations</span>
<a name="l00553"></a>00553 <span class="comment">         *************************************************************************************************************************/</span>
<a name="l00554"></a>00554 
<a name="l00556"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#ab2d3893581eb70f842763ffcf272aaba">00556</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#ab2d3893581eb70f842763ffcf272aaba" title="Returns value of the specified 32-bit general purpose register.">readGPR</a>(<a class="code" href="InstructionEnumsX86_8h.html#a5069ca462f85d162797843f48bc6bced" title="Intel x86 general purpose registers.">X86GeneralPurposeRegister</a> r)<span class="keyword"> const </span>{
<a name="l00557"></a>00557             <span class="keywordflow">return</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a4ff1f363deb8988a0fa96e04f85e4885" title="Current machine state updated by each processInstruction().">cur_state</a>.<a class="code" href="structSymbolicSemantics_1_1State.html#aa4eba52bac554f862e1a3f1723ccfe3a" title="General-purpose registers.">gpr</a>[r];
<a name="l00558"></a>00558         }
<a name="l00559"></a>00559 
<a name="l00561"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a1fb8e64e2b96b49e6149f81696a9adb0">00561</a>         <span class="keywordtype">void</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a1fb8e64e2b96b49e6149f81696a9adb0" title="Places a value in the specified 32-bit general purpose register.">writeGPR</a>(<a class="code" href="InstructionEnumsX86_8h.html#a5069ca462f85d162797843f48bc6bced" title="Intel x86 general purpose registers.">X86GeneralPurposeRegister</a> r, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;value) {
<a name="l00562"></a>00562             <a class="code" href="classSymbolicSemantics_1_1Policy.html#a4ff1f363deb8988a0fa96e04f85e4885" title="Current machine state updated by each processInstruction().">cur_state</a>.<a class="code" href="structSymbolicSemantics_1_1State.html#aa4eba52bac554f862e1a3f1723ccfe3a" title="General-purpose registers.">gpr</a>[r] = value;
<a name="l00563"></a>00563         }
<a name="l00564"></a>00564 
<a name="l00566"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a2316a435320d85bad71f0cafaf89f3fb">00566</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;16&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a2316a435320d85bad71f0cafaf89f3fb" title="Reads a value from the specified 16-bit segment register.">readSegreg</a>(<a class="code" href="InstructionEnumsX86_8h.html#a0b09709b1ff4de1bbe47357b6d7b0e64" title="Intel x86 segment registers.">X86SegmentRegister</a> sr)<span class="keyword"> const </span>{
<a name="l00567"></a>00567             <span class="keywordflow">return</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a4ff1f363deb8988a0fa96e04f85e4885" title="Current machine state updated by each processInstruction().">cur_state</a>.<a class="code" href="structSymbolicSemantics_1_1State.html#a44bc9efb653b62529f04903c67925c48" title="Segmentation registers.">segreg</a>[sr];
<a name="l00568"></a>00568         }
<a name="l00569"></a>00569 
<a name="l00571"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#af57f7dfcac485545ff7c784309065d67">00571</a>         <span class="keywordtype">void</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#af57f7dfcac485545ff7c784309065d67" title="Places a value in the specified 16-bit segment register.">writeSegreg</a>(<a class="code" href="InstructionEnumsX86_8h.html#a0b09709b1ff4de1bbe47357b6d7b0e64" title="Intel x86 segment registers.">X86SegmentRegister</a> sr, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;16&gt;</a> &amp;value) {
<a name="l00572"></a>00572             <a class="code" href="classSymbolicSemantics_1_1Policy.html#a4ff1f363deb8988a0fa96e04f85e4885" title="Current machine state updated by each processInstruction().">cur_state</a>.<a class="code" href="structSymbolicSemantics_1_1State.html#a44bc9efb653b62529f04903c67925c48" title="Segmentation registers.">segreg</a>[sr] = value;
<a name="l00573"></a>00573         }
<a name="l00574"></a>00574 
<a name="l00577"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#ad5fb39fa0acbfaad6a3d903d37c08d34">00577</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#ad5fb39fa0acbfaad6a3d903d37c08d34" title="Returns the value of the instruction pointer as it would be during the execution of the instruction...">readIP</a>()<span class="keyword"> const </span>{
<a name="l00578"></a>00578             <span class="keywordflow">return</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a4ff1f363deb8988a0fa96e04f85e4885" title="Current machine state updated by each processInstruction().">cur_state</a>.<a class="code" href="structSymbolicSemantics_1_1State.html#ab7b69f87b8b838c15abe78d7dace22fc" title="Instruction pointer.">ip</a>;
<a name="l00579"></a>00579         }
<a name="l00580"></a>00580 
<a name="l00582"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#ad16ceaa6e9c469c4176622675c02aaa2">00582</a>         <span class="keywordtype">void</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#ad16ceaa6e9c469c4176622675c02aaa2" title="Changes the value of the instruction pointer.">writeIP</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;value) {
<a name="l00583"></a>00583             <a class="code" href="classSymbolicSemantics_1_1Policy.html#a4ff1f363deb8988a0fa96e04f85e4885" title="Current machine state updated by each processInstruction().">cur_state</a>.<a class="code" href="structSymbolicSemantics_1_1State.html#ab7b69f87b8b838c15abe78d7dace22fc" title="Instruction pointer.">ip</a> = value;
<a name="l00584"></a>00584         }
<a name="l00585"></a>00585 
<a name="l00587"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a153d7aa31f9945234bedf6ba3bb044ed">00587</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;1&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a153d7aa31f9945234bedf6ba3bb044ed" title="Returns the value of a specific control/status/system flag.">readFlag</a>(<a class="code" href="InstructionEnumsX86_8h.html#ab8c1069abaa6534f3481d52cfe950881" title="Intel x86 status flags.">X86Flag</a> f)<span class="keyword"> const </span>{
<a name="l00588"></a>00588             <span class="keywordflow">return</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a4ff1f363deb8988a0fa96e04f85e4885" title="Current machine state updated by each processInstruction().">cur_state</a>.<a class="code" href="structSymbolicSemantics_1_1State.html#aae557035aec8db3604a1ebea2b29924a" title="Control/status flags (i.e., FLAG register).">flag</a>[f];
<a name="l00589"></a>00589         }
<a name="l00590"></a>00590 
<a name="l00592"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a77320859900d1d144b837432756c2fbc">00592</a>         <span class="keywordtype">void</span> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a77320859900d1d144b837432756c2fbc" title="Changes the value of the specified control/status/system flag.">writeFlag</a>(<a class="code" href="InstructionEnumsX86_8h.html#ab8c1069abaa6534f3481d52cfe950881" title="Intel x86 status flags.">X86Flag</a> f, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;1&gt;</a> &amp;value) {
<a name="l00593"></a>00593             <a class="code" href="classSymbolicSemantics_1_1Policy.html#a4ff1f363deb8988a0fa96e04f85e4885" title="Current machine state updated by each processInstruction().">cur_state</a>.<a class="code" href="structSymbolicSemantics_1_1State.html#aae557035aec8db3604a1ebea2b29924a" title="Control/status flags (i.e., FLAG register).">flag</a>[f] = value;
<a name="l00594"></a>00594         }
<a name="l00595"></a>00595 
<a name="l00597"></a>00597         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt; <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>
<a name="l00598"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a33c154e158ac629e36e7c9f5a1f77769">00598</a>         <a class="code" href="classSymbolicSemantics_1_1Policy.html#a33c154e158ac629e36e7c9f5a1f77769" title="Reads a value from memory.">readMemory</a>(<a class="code" href="InstructionEnumsX86_8h.html#a0b09709b1ff4de1bbe47357b6d7b0e64" title="Intel x86 segment registers.">X86SegmentRegister</a> segreg, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;addr, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;1&gt;</a> cond)<span class="keyword"> const </span>{
<a name="l00599"></a>00599             <span class="keywordflow">return</span> mem_read&lt;Len&gt;(<a class="code" href="classSymbolicSemantics_1_1Policy.html#a4ff1f363deb8988a0fa96e04f85e4885" title="Current machine state updated by each processInstruction().">cur_state</a>, addr);
<a name="l00600"></a>00600         }
<a name="l00601"></a>00601 
<a name="l00603"></a>00603         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt; <span class="keywordtype">void</span>
<a name="l00604"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#ac7a65b8c0e83b2f32f7424a5d84da39e">00604</a>         <a class="code" href="classSymbolicSemantics_1_1Policy.html#ac7a65b8c0e83b2f32f7424a5d84da39e" title="Writes a value to memory.">writeMemory</a>(<a class="code" href="InstructionEnumsX86_8h.html#a0b09709b1ff4de1bbe47357b6d7b0e64" title="Intel x86 segment registers.">X86SegmentRegister</a> segreg, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;addr, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;data, <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;1&gt;</a> cond) {
<a name="l00605"></a>00605             mem_write&lt;Len&gt;(<a class="code" href="classSymbolicSemantics_1_1Policy.html#a4ff1f363deb8988a0fa96e04f85e4885" title="Current machine state updated by each processInstruction().">cur_state</a>, addr, data);
<a name="l00606"></a>00606         }
<a name="l00607"></a>00607 
<a name="l00608"></a>00608 
<a name="l00609"></a>00609 
<a name="l00610"></a>00610         <span class="comment">/*************************************************************************************************************************</span>
<a name="l00611"></a>00611 <span class="comment">         * Functions invoked by the X86InstructionSemantics class for arithmetic operations</span>
<a name="l00612"></a>00612 <span class="comment">         *************************************************************************************************************************/</span>
<a name="l00613"></a>00613 
<a name="l00615"></a>00615         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00616"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a8a9f4ab1f078363b36b097b44b198eea">00616</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a8a9f4ab1f078363b36b097b44b198eea" title="Adds two values.">add</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;a, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;b)<span class="keyword"> const </span>{
<a name="l00617"></a>00617             <span class="keywordflow">if</span> (a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>()) {
<a name="l00618"></a>00618                 <span class="keywordflow">if</span> (b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>()) {
<a name="l00619"></a>00619                     <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(<a class="code" href="classInsnSemanticsExpr_1_1LeafNode.html#a5c5a9606638db5e4fbb6990c55084d1c" title="Construct a new integer with the specified number of significant bits.">LeafNode::create_integer</a>(Len, a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>()+b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>()));
<a name="l00620"></a>00620                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (0==a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>()) {
<a name="l00621"></a>00621                     <span class="keywordflow">return</span> b;
<a name="l00622"></a>00622                 }
<a name="l00623"></a>00623             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>() &amp;&amp; 0==b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>()) {
<a name="l00624"></a>00624                 <span class="keywordflow">return</span> a;
<a name="l00625"></a>00625             }
<a name="l00626"></a>00626             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(Len, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969aed79156e6c3b38d937736d84cb5c093e" title="Addition.">InsnSemanticsExpr::OP_ADD</a>, a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>, b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00627"></a>00627         }
<a name="l00628"></a>00628 
<a name="l00643"></a>00643         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00644"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a3e93f1f67b4ab8a45f12e1fe3ccd57e7">00644</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a3e93f1f67b4ab8a45f12e1fe3ccd57e7" title="Add two values of equal size and a carry bit.">addWithCarries</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;a, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;b, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;1&gt;</a> &amp;c,
<a name="l00645"></a>00645                                       <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;carry_out)<span class="keyword"> const </span>{
<a name="l00646"></a>00646             <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len+1&gt;</a> aa = unsignedExtend&lt;Len, Len+1&gt;(a);
<a name="l00647"></a>00647             <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len+1&gt;</a> bb = unsignedExtend&lt;Len, Len+1&gt;(b);
<a name="l00648"></a>00648             <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len+1&gt;</a> cc = unsignedExtend&lt;1,   Len+1&gt;(c);
<a name="l00649"></a>00649             <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len+1&gt;</a> sumco = add&lt;Len+1&gt;(aa, add&lt;Len+1&gt;(bb, cc));
<a name="l00650"></a>00650             carry_out = extract&lt;1, Len+1&gt;(xor_&lt;Len+1&gt;(aa, xor_&lt;Len+1&gt;(bb, sumco)));
<a name="l00651"></a>00651             <span class="keywordflow">return</span> add&lt;Len&gt;(a, add&lt;Len&gt;(b, unsignedExtend&lt;1, Len&gt;(c)));
<a name="l00652"></a>00652         }
<a name="l00653"></a>00653 
<a name="l00655"></a>00655         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00656"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#aa238871d768284a47317be9a70d6966c">00656</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#aa238871d768284a47317be9a70d6966c" title="Computes bit-wise AND of two values.">and_</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;a, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;b)<span class="keyword"> const </span>{
<a name="l00657"></a>00657             <span class="keywordflow">if</span> (a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>() &amp;&amp; b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>())
<a name="l00658"></a>00658                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>() &amp; b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>());
<a name="l00659"></a>00659             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(Len, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969abd266fb226958b53f2e81cfc312385b2" title="Bitwise AND.">InsnSemanticsExpr::OP_BV_AND</a>, a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>, b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00660"></a>00660         }
<a name="l00661"></a>00661 
<a name="l00663"></a>00663         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00664"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a044e9d060e4d11712c8e4ea5c2a0b0b7">00664</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;1&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a044e9d060e4d11712c8e4ea5c2a0b0b7" title="Returns true_, false_, or undefined_ depending on whether argument is zero.">equalToZero</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;a)<span class="keyword"> const </span>{
<a name="l00665"></a>00665             <span class="keywordflow">if</span> (a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>())
<a name="l00666"></a>00666                 <span class="keywordflow">return</span> a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>() ? <a class="code" href="classSymbolicSemantics_1_1Policy.html#aaf081b947bedf2fd07bab2162f7a81cd" title="False value.">false_</a>() : <a class="code" href="classSymbolicSemantics_1_1Policy.html#a2889fb4f6968cc9b64636408aa909b25" title="True value.">true_</a>();
<a name="l00667"></a>00667             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;1&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(1, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969adb7740a45116fcd176bbd71bc2acfb63" title="Equal to zero.">InsnSemanticsExpr::OP_ZEROP</a>, a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00668"></a>00668         }
<a name="l00669"></a>00669 
<a name="l00671"></a>00671         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00672"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a351934a333c3237cfbe897f1a1575685">00672</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a351934a333c3237cfbe897f1a1575685" title="One&#39;s complement.">invert</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;a)<span class="keyword"> const </span>{
<a name="l00673"></a>00673             <span class="keywordflow">if</span> (a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>())
<a name="l00674"></a>00674                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(<a class="code" href="classInsnSemanticsExpr_1_1LeafNode.html#a5c5a9606638db5e4fbb6990c55084d1c" title="Construct a new integer with the specified number of significant bits.">LeafNode::create_integer</a>(Len, ~a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>()));
<a name="l00675"></a>00675             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(Len, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969aef02f20da57c7fdf99cc808850cac5c6" title="Boolean inversion.">InsnSemanticsExpr::OP_INVERT</a>, a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00676"></a>00676         }
<a name="l00677"></a>00677 
<a name="l00680"></a>00680         <span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> Len1, <span class="keywordtype">size_t</span> Len2&gt;
<a name="l00681"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a9ae7de955eced19a01c0796e874c89fc">00681</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len1+Len2&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a9ae7de955eced19a01c0796e874c89fc" title="Concatenate the values of a and b so that the result has b in the high-order bits and a in the low or...">concat</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len1&gt;</a> &amp;a, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len2&gt;</a> &amp;b)<span class="keyword"> const </span>{
<a name="l00682"></a>00682             <span class="keywordflow">if</span> (a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>() &amp;&amp; b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>())
<a name="l00683"></a>00683                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len1+Len2&gt;</a>(a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>() | (b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>() &lt;&lt; Len1));
<a name="l00684"></a>00684             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len1+Len2&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(Len1+Len2, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969a988dc3187e02c827037ab2a62d6072c5" title="Concatenation.">InsnSemanticsExpr::OP_CONCAT</a>, b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>, a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00685"></a>00685         }
<a name="l00686"></a>00686 
<a name="l00688"></a>00688         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00689"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#aef5599483e9b2fa88816f3227208668d">00689</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#aef5599483e9b2fa88816f3227208668d" title="Returns second or third arg depending on value of first arg.">ite</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;1&gt;</a> &amp;sel, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;ifTrue, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;ifFalse)<span class="keyword"> const </span>{
<a name="l00690"></a>00690             <span class="keywordflow">if</span> (sel.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>()) {
<a name="l00691"></a>00691                 <span class="keywordflow">return</span> sel.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>() ? ifTrue : ifFalse;
<a name="l00692"></a>00692             }
<a name="l00693"></a>00693             <span class="keywordflow">if</span> (<a class="code" href="classSymbolicSemantics_1_1Policy.html#ae97a155267ab95e36b889af7963cbb4f" title="The solver to use for Satisfiability Modulo Theory, or NULL.">solver</a>) {
<a name="l00694"></a>00694                 <span class="comment">/* If the selection expression cannot be true, then return ifFalse */</span>
<a name="l00695"></a>00695                 <a class="code" href="classInsnSemanticsExpr_1_1TreeNode.html" title="Any node of an expression tree for instruction semantics, from which the InternalNode and LeafNode cl...">TreeNode</a> *assertion = <span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(1, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969a7cfb2dfea98afe678041e46c9229b610" title="Equality.">InsnSemanticsExpr::OP_EQ</a>,
<a name="l00696"></a>00696                                                        sel.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>, <a class="code" href="classInsnSemanticsExpr_1_1LeafNode.html#a5c5a9606638db5e4fbb6990c55084d1c" title="Construct a new integer with the specified number of significant bits.">LeafNode::create_integer</a>(1, 1));
<a name="l00697"></a>00697                 <span class="keywordtype">bool</span> can_be_true = <a class="code" href="classSymbolicSemantics_1_1Policy.html#ae97a155267ab95e36b889af7963cbb4f" title="The solver to use for Satisfiability Modulo Theory, or NULL.">solver</a>-&gt;<a class="code" href="classSMTSolver.html#aa8c6a53134e3a38e15abbcd461554dd5" title="Determines if the specified expression is satisfiable.">satisfiable</a>(assertion);
<a name="l00698"></a>00698                 assertion-&gt;<a class="code" href="classInsnSemanticsExpr_1_1TreeNode.html#a18b6d72538e59fcce85ccae6bfe93a34" title="Deletes this node and all children, provided the children aren&#39;t also children of other nodes...">deleteDeeply</a>(); assertion=NULL;
<a name="l00699"></a>00699                 <span class="keywordflow">if</span> (!can_be_true) <span class="keywordflow">return</span> ifFalse;
<a name="l00700"></a>00700 
<a name="l00701"></a>00701                 <span class="comment">/* If the selection expression cannot be false, then return ifTrue */</span>
<a name="l00702"></a>00702                 assertion = <span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(1, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969a7cfb2dfea98afe678041e46c9229b610" title="Equality.">InsnSemanticsExpr::OP_EQ</a>,
<a name="l00703"></a>00703                                              sel.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>, <a class="code" href="classInsnSemanticsExpr_1_1LeafNode.html#a5c5a9606638db5e4fbb6990c55084d1c" title="Construct a new integer with the specified number of significant bits.">LeafNode::create_integer</a>(1, 0));
<a name="l00704"></a>00704                 <span class="keywordtype">bool</span> can_be_false = <a class="code" href="classSymbolicSemantics_1_1Policy.html#ae97a155267ab95e36b889af7963cbb4f" title="The solver to use for Satisfiability Modulo Theory, or NULL.">solver</a>-&gt;<a class="code" href="classSMTSolver.html#aa8c6a53134e3a38e15abbcd461554dd5" title="Determines if the specified expression is satisfiable.">satisfiable</a>(assertion);
<a name="l00705"></a>00705                 assertion-&gt;<a class="code" href="classInsnSemanticsExpr_1_1TreeNode.html#a18b6d72538e59fcce85ccae6bfe93a34" title="Deletes this node and all children, provided the children aren&#39;t also children of other nodes...">deleteDeeply</a>(); assertion=NULL;
<a name="l00706"></a>00706                 <span class="keywordflow">if</span> (!can_be_false) <span class="keywordflow">return</span> ifTrue;
<a name="l00707"></a>00707             }
<a name="l00708"></a>00708             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(Len, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969a77a0e0a5de1cb75d0a25962e786fe511" title="If-then-else.">InsnSemanticsExpr::OP_ITE</a>, sel.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>, ifTrue.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>, ifFalse.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00709"></a>00709         }
<a name="l00710"></a>00710 
<a name="l00712"></a>00712         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00713"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#aea1c9ea72638639f955d6040de4b3018">00713</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#aea1c9ea72638639f955d6040de4b3018" title="Returns position of least significant set bit; zero when no bits are set.">leastSignificantSetBit</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;a)<span class="keyword"> const </span>{
<a name="l00714"></a>00714             <span class="keywordflow">if</span> (a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>()) {
<a name="l00715"></a>00715                 uint64_t n = a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>();
<a name="l00716"></a>00716                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;Len; ++i) {
<a name="l00717"></a>00717                     <span class="keywordflow">if</span> (n &amp; ((uint64_t)1 &lt;&lt; i))
<a name="l00718"></a>00718                         <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(i);
<a name="l00719"></a>00719                 }
<a name="l00720"></a>00720                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>((uint64_t)0);
<a name="l00721"></a>00721             }
<a name="l00722"></a>00722             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(Len, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969a86eb2c297326474e7db9aecde8894c9e" title="Least significant set bit or zero.">InsnSemanticsExpr::OP_LSSB</a>, a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00723"></a>00723         }
<a name="l00724"></a>00724 
<a name="l00726"></a>00726         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00727"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#afd9202f31e86b4ac40de859d7af4e2dc">00727</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#afd9202f31e86b4ac40de859d7af4e2dc" title="Returns position of most significant set bit; zero when no bits are set.">mostSignificantSetBit</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;a)<span class="keyword"> const </span>{
<a name="l00728"></a>00728             <span class="keywordflow">if</span> (a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>()) {
<a name="l00729"></a>00729                 uint64_t n = a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>();
<a name="l00730"></a>00730                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=Len; i&gt;0; --i) {
<a name="l00731"></a>00731                     <span class="keywordflow">if</span> (n &amp; ((uint64_t)1 &lt;&lt; (i-1)))
<a name="l00732"></a>00732                         <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(i-1);
<a name="l00733"></a>00733                 }
<a name="l00734"></a>00734                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>((uint64_t)0);
<a name="l00735"></a>00735             }
<a name="l00736"></a>00736             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(Len, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969ab8ee7eeb85c2ebf0518a4bfe631513e1" title="Most significant set bit or zero.">InsnSemanticsExpr::OP_MSSB</a>, a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00737"></a>00737         }
<a name="l00738"></a>00738 
<a name="l00740"></a>00740         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00741"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#aaa7e590685613596357bf66ffe5c10d0">00741</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#aaa7e590685613596357bf66ffe5c10d0" title="Two&#39;s complement.">negate</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;a)<span class="keyword"> const </span>{
<a name="l00742"></a>00742             <span class="keywordflow">if</span> (a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>())
<a name="l00743"></a>00743                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(-a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>());
<a name="l00744"></a>00744             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(Len, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969a224f1aeb2fa5cb3e798a03b9b517516f" title="Arithmetic negation.">InsnSemanticsExpr::OP_NEGATE</a>, a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00745"></a>00745         }
<a name="l00746"></a>00746 
<a name="l00748"></a>00748         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00749"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#aa69425f4a8f6b400b447d4959ba4d4eb">00749</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#aa69425f4a8f6b400b447d4959ba4d4eb" title="Computes bit-wise OR of two values.">or_</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;a, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;b)<span class="keyword"> const </span>{
<a name="l00750"></a>00750             <span class="keywordflow">if</span> (a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>() &amp;&amp; b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>())
<a name="l00751"></a>00751                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>() | b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>());
<a name="l00752"></a>00752             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(Len, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969a07ec1a5d3713489688b744c85ebb09e6" title="Bitwise OR.">InsnSemanticsExpr::OP_BV_OR</a>, a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>, b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00753"></a>00753         }
<a name="l00754"></a>00754 
<a name="l00756"></a>00756         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len, <span class="keywordtype">size_t</span> SALen&gt;
<a name="l00757"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a31e54ef0caf0e78f2a870fc4f0fb0fd8">00757</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a31e54ef0caf0e78f2a870fc4f0fb0fd8" title="Rotate bits to the left.">rotateLeft</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;a, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;SALen&gt;</a> &amp;sa)<span class="keyword"> const </span>{
<a name="l00758"></a>00758             <span class="keywordflow">if</span> (a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>() &amp;&amp; sa.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>())
<a name="l00759"></a>00759                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(IntegerOps::rotateLeft&lt;Len&gt;(a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>(), sa.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>()));
<a name="l00760"></a>00760             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(Len, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969af2b722d1a1791f5f37a69b52f62f61e2" title="Rotate left.">InsnSemanticsExpr::OP_ROL</a>, sa.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>, a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00761"></a>00761         }
<a name="l00762"></a>00762 
<a name="l00764"></a>00764         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len, <span class="keywordtype">size_t</span> SALen&gt;
<a name="l00765"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#ae78354eb10998caa212e5f762bec226e">00765</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#ae78354eb10998caa212e5f762bec226e" title="Rotate bits to the right.">rotateRight</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;a, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;SALen&gt;</a> &amp;sa)<span class="keyword"> const </span>{
<a name="l00766"></a>00766             <span class="keywordflow">if</span> (a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>() &amp;&amp; sa.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>())
<a name="l00767"></a>00767                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(IntegerOps::rotateRight&lt;Len&gt;(a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>(), sa.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>()));
<a name="l00768"></a>00768             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(Len, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969a53e9f92a283a254eeb5a0235ce12367d" title="Rotate right.">InsnSemanticsExpr::OP_ROR</a>, sa.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>, a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00769"></a>00769         }
<a name="l00770"></a>00770 
<a name="l00772"></a>00772         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len, <span class="keywordtype">size_t</span> SALen&gt;
<a name="l00773"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#aa3f187678c449f9e331970db60e07193">00773</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#aa3f187678c449f9e331970db60e07193" title="Returns arg shifted left.">shiftLeft</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;a, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;SALen&gt;</a> &amp;sa)<span class="keyword"> const </span>{
<a name="l00774"></a>00774             <span class="keywordflow">if</span> (a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>() &amp;&amp; sa.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>())
<a name="l00775"></a>00775                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(IntegerOps::shiftLeft&lt;Len&gt;(a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>(), sa.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>()));
<a name="l00776"></a>00776             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(Len, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969a3594a2a7f9a1a036c22c57015a556158" title="Shift left, introducing zeros at lsb.">InsnSemanticsExpr::OP_SHL0</a>, sa.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>, a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00777"></a>00777         }
<a name="l00778"></a>00778 
<a name="l00780"></a>00780         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len, <span class="keywordtype">size_t</span> SALen&gt;
<a name="l00781"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a12c8a382e05c800078a7d6a11f5d3ad4">00781</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a12c8a382e05c800078a7d6a11f5d3ad4" title="Returns arg shifted right logically (no sign bit).">shiftRight</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;a, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;SALen&gt;</a> &amp;sa)<span class="keyword"> const </span>{
<a name="l00782"></a>00782             <span class="keywordflow">if</span> (a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>() &amp;&amp; sa.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>())
<a name="l00783"></a>00783                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(IntegerOps::shiftRightLogical&lt;Len&gt;(a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>(), sa.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>()));
<a name="l00784"></a>00784             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(Len, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969a3f7b7dca3d046f7d9e830a0c1cd9806d" title="Shift right, introducing zeros at msb.">InsnSemanticsExpr::OP_SHR0</a>, sa.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>, a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00785"></a>00785         }
<a name="l00786"></a>00786 
<a name="l00788"></a>00788         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len, <span class="keywordtype">size_t</span> SALen&gt;
<a name="l00789"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a69a93d91842baa48502607c889e5d738">00789</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a69a93d91842baa48502607c889e5d738" title="Returns arg shifted right arithmetically (with sign bit).">shiftRightArithmetic</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;a, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;SALen&gt;</a> &amp;sa)<span class="keyword"> const </span>{
<a name="l00790"></a>00790             <span class="keywordflow">if</span> (a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>() &amp;&amp; sa.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>())
<a name="l00791"></a>00791                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(IntegerOps::shiftRightArithmetic&lt;Len&gt;(a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>(), sa.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>()));
<a name="l00792"></a>00792             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(Len, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969ab8361a118cef11bdc37fca78357129ea" title="Arithmetic shift right.">InsnSemanticsExpr::OP_ASR</a>, sa.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>, a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00793"></a>00793         }
<a name="l00794"></a>00794 
<a name="l00796"></a>00796         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> From, <span class="keywordtype">size_t</span> To&gt;
<a name="l00797"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a120604113592fd1c645ecacce84e1f2f">00797</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;To&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a120604113592fd1c645ecacce84e1f2f" title="Sign extends a value.">signExtend</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;From&gt;</a> &amp;a) {
<a name="l00798"></a>00798             <span class="keywordflow">return</span> signedExtend&lt;From, To&gt;(a);
<a name="l00799"></a>00799         }
<a name="l00800"></a>00800 
<a name="l00802"></a>00802         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len1, <span class="keywordtype">size_t</span> Len2&gt;
<a name="l00803"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a58eaa55e891ef7533f48b294c2c9e1e0">00803</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len1&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a58eaa55e891ef7533f48b294c2c9e1e0" title="Divides two signed values.">signedDivide</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len1&gt;</a> &amp;a, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len2&gt;</a> &amp;b)<span class="keyword"> const </span>{
<a name="l00804"></a>00804             <span class="keywordflow">if</span> (a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>() &amp;&amp; b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>() &amp;&amp; 0!=b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>())
<a name="l00805"></a>00805                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len1&gt;</a>(IntegerOps::signExtend&lt;Len1, 64&gt;(a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>()) /
<a name="l00806"></a>00806                                        IntegerOps::signExtend&lt;Len2, 64&gt;(b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>()));
<a name="l00807"></a>00807             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len1&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(Len1, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969aecc1a8a77054955ae08426215f26ed56" title="Signed division.">InsnSemanticsExpr::OP_SDIV</a>, a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>, b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00808"></a>00808         }
<a name="l00809"></a>00809 
<a name="l00811"></a>00811         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len1, <span class="keywordtype">size_t</span> Len2&gt;
<a name="l00812"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a4a8c62b2c3c41da5afb9d0779922949c">00812</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len2&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a4a8c62b2c3c41da5afb9d0779922949c" title="Calculates modulo with signed values.">signedModulo</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len1&gt;</a> &amp;a, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len2&gt;</a> &amp;b)<span class="keyword"> const </span>{
<a name="l00813"></a>00813             <span class="keywordflow">if</span> (a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>() &amp;&amp; b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>() &amp;&amp; 0!=b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>())
<a name="l00814"></a>00814                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len2&gt;</a>(IntegerOps::signExtend&lt;Len1, 64&gt;(a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>()) %
<a name="l00815"></a>00815                                        IntegerOps::signExtend&lt;Len2, 64&gt;(b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>()));
<a name="l00816"></a>00816             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len2&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(Len2, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969a14267d5562dd530f554385baf858fb2c" title="Signed modulus.">InsnSemanticsExpr::OP_SMOD</a>, a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>, b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00817"></a>00817         }
<a name="l00818"></a>00818 
<a name="l00820"></a>00820         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len1, <span class="keywordtype">size_t</span> Len2&gt;
<a name="l00821"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a0859c0932909ea66cb90688ea73dff4b">00821</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len1+Len2&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a0859c0932909ea66cb90688ea73dff4b" title="Multiplies two signed values.">signedMultiply</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len1&gt;</a> &amp;a, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len2&gt;</a> &amp;b)<span class="keyword"> const </span>{
<a name="l00822"></a>00822             <span class="keywordflow">if</span> (a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>() &amp;&amp; b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>())
<a name="l00823"></a>00823                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len1+Len2&gt;</a>(IntegerOps::signExtend&lt;Len1, 64&gt;(a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>()) *
<a name="l00824"></a>00824                                             IntegerOps::signExtend&lt;Len2, 64&gt;(b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>()));
<a name="l00825"></a>00825             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len1+Len2&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(Len1+Len2, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969a060ebe71e95b8cb0ff3783c6a90d6d94" title="Signed multiplication.">InsnSemanticsExpr::OP_SMUL</a>, a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>, b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00826"></a>00826         }
<a name="l00827"></a>00827 
<a name="l00829"></a>00829         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len1, <span class="keywordtype">size_t</span> Len2&gt;
<a name="l00830"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#ab4bd2a8070094e7656379bc0934cd17b">00830</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len1&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#ab4bd2a8070094e7656379bc0934cd17b" title="Divides two unsigned values.">unsignedDivide</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len1&gt;</a> &amp;a, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len2&gt;</a> &amp;b)<span class="keyword"> const </span>{
<a name="l00831"></a>00831             <span class="keywordflow">if</span> (a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>() &amp;&amp; b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>() &amp;&amp; 0!=b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>())
<a name="l00832"></a>00832                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len1&gt;</a>(a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>() / b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>());
<a name="l00833"></a>00833             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len1&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(Len1, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969a3692a5f348ce3bf32a4062a7473dd2bd" title="Signed division.">InsnSemanticsExpr::OP_UDIV</a>, a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>, b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00834"></a>00834         }
<a name="l00835"></a>00835 
<a name="l00837"></a>00837         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len1, <span class="keywordtype">size_t</span> Len2&gt;
<a name="l00838"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#afce26f2dae6214756dc3d43d339c3051">00838</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len2&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#afce26f2dae6214756dc3d43d339c3051" title="Calculates modulo with unsigned values.">unsignedModulo</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len1&gt;</a> &amp;a, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len2&gt;</a> &amp;b)<span class="keyword"> const </span>{
<a name="l00839"></a>00839             <span class="keywordflow">if</span> (a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>() &amp;&amp; b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>() &amp;&amp; 0!=b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>())
<a name="l00840"></a>00840                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len2&gt;</a>(a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>() % b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>());
<a name="l00841"></a>00841             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len2&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(Len2, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969a3d1b8db3a67b7eedb566d4a80822d2ed" title="Unsigned modulus.">InsnSemanticsExpr::OP_UMOD</a>, a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>, b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00842"></a>00842         }
<a name="l00843"></a>00843 
<a name="l00845"></a>00845         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len1, <span class="keywordtype">size_t</span> Len2&gt;
<a name="l00846"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a1e2860dd5147f001d4364b95c952c377">00846</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len1+Len2&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a1e2860dd5147f001d4364b95c952c377" title="Multiply two unsigned values.">unsignedMultiply</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len1&gt;</a> &amp;a, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len2&gt;</a> &amp;b)<span class="keyword"> const </span>{
<a name="l00847"></a>00847             <span class="keywordflow">if</span> (a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>() &amp;&amp; b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>())
<a name="l00848"></a>00848                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len1+Len2&gt;</a>(a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>()*b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>());
<a name="l00849"></a>00849             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len1+Len2&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(Len1+Len2, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969a9bc28761386bfc05ac2cc9185f3d4c37" title="Unsigned multiplication.">InsnSemanticsExpr::OP_UMUL</a>, a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>, b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00850"></a>00850         }
<a name="l00851"></a>00851 
<a name="l00853"></a>00853         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Len&gt;
<a name="l00854"></a><a class="code" href="classSymbolicSemantics_1_1Policy.html#a7e745cec65a783468eceadb5320d71ab">00854</a>         <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> <a class="code" href="classSymbolicSemantics_1_1Policy.html#a7e745cec65a783468eceadb5320d71ab" title="Computes bit-wise XOR of two values.">xor_</a>(<span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;a, <span class="keyword">const</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;b)<span class="keyword"> const </span>{
<a name="l00855"></a>00855             <span class="keywordflow">if</span> (a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>() &amp;&amp; b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#abc9ade7baa97929c38167597d4bc484c" title="Returns true if the value is a known constant.">is_known</a>())
<a name="l00856"></a>00856                 <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>() ^ b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#ab2739ec730893d3910df26dd10c68219" title="Returns the value of a known constant.">known_value</a>());
<a name="l00857"></a>00857             <span class="keywordflow">return</span> <a class="code" href="structSymbolicSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(<span class="keyword">new</span> <a class="code" href="namespaceSymbolicSemantics.html#a8b508f876696925f9e1b1c9e3074757f">InternalNode</a>(Len, <a class="code" href="namespaceInsnSemanticsExpr.html#af49db0ef78c1f52368e7b0c87ccdd969a8c619b9e6304e21423d320743d55749f" title="Bitwise exclusive OR.">InsnSemanticsExpr::OP_BV_XOR</a>, a.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>, b.<a class="code" href="structSymbolicSemantics_1_1ValueType.html#a1be115b513bd21e9616b43469f55232d">expr</a>));
<a name="l00858"></a>00858         }
<a name="l00859"></a>00859     };
<a name="l00860"></a>00860 
<a name="l00861"></a>00861 }; <span class="comment">/*namespace*/</span>
<a name="l00862"></a>00862 
<a name="l00863"></a>00863 
<a name="l00864"></a>00864 <span class="preprocessor">#endif</span>
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="SymbolicSemantics_8h.html">SymbolicSemantics.h</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Thu Dec 1 2011 16:31:44 for ROSE by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
