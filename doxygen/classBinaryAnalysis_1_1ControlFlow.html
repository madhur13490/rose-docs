<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: BinaryAnalysis::ControlFlow Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceBinaryAnalysis.html">BinaryAnalysis</a>::<a class="el" href="classBinaryAnalysis_1_1ControlFlow.html">ControlFlow</a></div>
<h1>BinaryAnalysis::ControlFlow Class Reference</h1><!-- doxytag: class="BinaryAnalysis::ControlFlow" --><code>#include &lt;<a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a>&gt;</code>
<p>
Collaboration diagram for BinaryAnalysis::ControlFlow:<p><center><img src="classBinaryAnalysis_1_1ControlFlow__coll__graph.png" border="0" usemap="#BinaryAnalysis_1_1ControlFlow__coll__map" alt="Collaboration graph"></center>
<map name="BinaryAnalysis_1_1ControlFlow__coll__map">
<area href="classBinaryAnalysis_1_1ControlFlow_1_1VertexFilter.html" shape="rect" coords="5,7,285,33" alt="">
<area href="classBinaryAnalysis_1_1ControlFlow_1_1EdgeFilter.html" shape="rect" coords="309,7,579,33" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classBinaryAnalysis_1_1ControlFlow-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Binary control flow analysis. 
<p>
This class serves mostly to organize the functions that operate on control flow, but also provides a container for various settings that influence the control flow analyses, such as the vertex and edge filters.<p>
Control flow is represented in the AST as successor pointers (<a class="el" href="classSgAsmIntegerValueExpression.html">SgAsmIntegerValueExpression</a>) attached to each basic block (<a class="el" href="classSgAsmBlock.html">SgAsmBlock</a>). The successor information is initialized by the <a class="el" href="classPartitioner.html">Partitioner</a> class when the AST is built (see <a class="el" href="classPartitioner.html#d94b1f74e750728b71d1726330786506">Partitioner::build_ast()</a>) and are available with <a class="el" href="classSgAsmBlock.html#54922f0881f4b2a3d3b3808a3b3e77ae">SgAsmBlock::get_successors()</a>. The <a class="el" href="classSgAsmBlock.html#8f13421583226182e94b9452ddb48078">SgAsmBlock::get_successors_complete()</a> returns a Boolean indicating whether the set of successors is completely known. Successors would be incomplete, for instance, for a block that returns from a function or a block that ends with a computed branch whose targets could not be statically determined.<p>
The wikipedia entry for "Control Flow Graph" [1] has many useful definitions.<p>
Control flow graphs can be calculated over any subtree of the AST. Usually one creates CFGs that span a single function or a whole interpretation. The vertex and edge filtes can restrict which basic blocks and control flow edges are considered by the various methods of this class. For instance, to create a global CFG that has only those edges that look like function calls, one could do the following (see also, <a class="el" href="classBinaryAnalysis_1_1FunctionCall.html">BinaryAnalysis::FunctionCall</a>):<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// Create a filter that rejects all edges except those whose target</span>
  <span class="comment">// is a function entry block.</span>
  <span class="keyword">struct </span>OnlyCallEdges: <span class="keyword">public</span> <a class="code" href="classBinaryAnalysis_1_1ControlFlow.html#d94587a729936415c40e65d1c274b0b2">ControlFlow</a>::EdgeFilter {
      <span class="keywordtype">bool</span> operator()(<a class="code" href="classBinaryAnalysis_1_1ControlFlow.html#d94587a729936415c40e65d1c274b0b2">ControlFlow</a> *analyzer, <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *src, <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *dst) {
          <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *func = dst-&gt;<a class="code" href="classSgAsmBlock.html#bdd6257d93832cc2b0dcbdf07f9ccd3c">get_enclosing_function</a>();
          <span class="keywordflow">return</span> func &amp;&amp; dst == func-&gt;<a class="code" href="classSgAsmFunction.html#89be684ba50382920d018616cfe74f86">get_entry_block</a>();
      }
  } <a class="code" href="classBinaryAnalysis_1_1ControlFlow.html#80d77204cf9f714828a775faff29dfac">edge_filter</a>;

  <span class="comment">// Create the control flow analyzer and set its edge filter.</span>
  <a class="code" href="classBinaryAnalysis_1_1ControlFlow.html#d94587a729936415c40e65d1c274b0b2">ControlFlow</a> analyzer;
  analyzer.set_edge_filter(&amp;<a class="code" href="classBinaryAnalysis_1_1ControlFlow.html#80d77204cf9f714828a775faff29dfac">edge_filter</a>);

  <span class="comment">// Generate a control flow graph over an entire interpretation. It will include</span>
  <span class="comment">// all basic blocks, but only edges which are function calls.</span>
  <span class="keyword">typedef</span> <a class="code" href="classBinaryAnalysis_1_1ControlFlow.html#d704a3d62401287d23f40c0aed8b70e8">ControlFlow::Graph</a> CFG;
  <a class="code" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *interp = ...;
  CFG <a class="code" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a> = analyzer.build_cfg_from_ast&lt;CFG&gt;(interp);
</pre></div><p>
Note that the <a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#a05cddf89974e64596a6cde6c88034cd">build_cfg_from_ast()</a>, as well as most of the other methods in this class, are function templates that take a graph type as an argument. For convenience, this class defines a default graph type, Graph. Any Boost adjacency list graph type can be used as long as the following are true:<p>
<ul>
<li>
the graph vertices are stored as a vector ("vecS" as the second template argument of adjacency_list) </li>
<li>
the graph is bidirectional ("bidrectionalS" as the third template argument), </li>
<li>
the boost::vertex_name property is a <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> pointer. </li>
</ul>
<p>
Another way to build a function call graph is to first build a complete control flow graph and then do a filtered copy to obtain a second graph with only the function call edges:<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// Build a complete control flow graph using a default</span>
  <span class="comment">// control flow analyzer.</span>
  <span class="keyword">typedef</span> <a class="code" href="classBinaryAnalysis_1_1ControlFlow.html#d704a3d62401287d23f40c0aed8b70e8">BinaryAnalysis::ControlFlow::Graph</a> CFG;
  CFG cfg = <a class="code" href="classBinaryAnalysis_1_1ControlFlow.html#d94587a729936415c40e65d1c274b0b2">ControlFlow</a>().build_cfg_from_ast&lt;CFG&gt;(interp);

  <span class="comment">// Using the same analyzer as the previous example, one that</span>
  <span class="comment">// filters out all but the function call edges, create a call</span>
  <span class="comment">// graph.</span>
  CFG cg = analyzer.copy(cfg);
</pre></div><p>
The <a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#2532d28ee1226ae45fd43cc6c660ceac">BinaryAnalysis::FunctionCall::Graph</a> differs from a filtered <a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#d704a3d62401287d23f40c0aed8b70e8">ControlFlow::Graph</a> in that the former's vertices point to functions (<a class="el" href="classSgAsmFunction.html">SgAsmFunction</a>) in the AST while the latter's points to basic blocks (<a class="el" href="classSgAsmBlock.html">SgAsmBlock</a>). However, building a CFG that has only function call edges is a common enough operation that we provide a method to do just that. The benefit of using <a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#d656d3f7b97cc4bf2cc58983877c58a4">build_cg_from_ast()</a> is that the user can easily define an additional edge filter to even further restrict the edges (see that method's source code for an example).<p>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="classBinaryAnalysis_1_1ControlFlow.html#d704a3d62401287d23f40c0aed8b70e8">ControlFlow::Graph</a> CFG;
  CFG cg = <a class="code" href="classBinaryAnalysis_1_1ControlFlow.html#d94587a729936415c40e65d1c274b0b2">ControlFlow</a>().build_cg_from_ast&lt;CFG&gt;(interp);
</pre></div><p>
Since binary control flow graphs are simply Boost graphs, they can be easily printed as GraphViz graphs using boost::write_graphviz(). If you want something other than vertex descriptors in the graphs, you could use a PropertyWriter class, like this one, which labels the vertices with the basic block address. Ideally, one would use a class template, but we keep this example simple:<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// Label the graphviz vertices with basic block addresses.</span>
  <span class="comment">// Boost requires this to be declared at file scope.</span>
  <span class="keyword">struct </span>GraphvizVertexWriter {
      <span class="keyword">const</span> <a class="code" href="classBinaryAnalysis_1_1ControlFlow.html#d704a3d62401287d23f40c0aed8b70e8">BinaryAnalysis::ControlFlow::Graph</a> &amp;cfg;
      GraphvizVertexWriter(<a class="code" href="classBinaryAnalysis_1_1ControlFlow.html#d704a3d62401287d23f40c0aed8b70e8">BinaryAnalysis::ControlFlow::Graph</a> &amp;cfg): cfg(cfg) {}
      <span class="keyword">typedef</span> boost::graph&lt;BinaryAnalysis::ControlFlow::Graph&gt;::vertex_descriptor <a class="code" href="structVertex.html">Vertex</a>;
      <span class="keywordtype">void</span> operator()(std::ostream &amp;output, <span class="keyword">const</span> <a class="code" href="structVertex.html">Vertex</a> &amp;v) {
          <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *block = get(boost::vertex_name, cfg, v);
          output &lt;&lt;<span class="stringliteral">"[ label=\""</span> &lt;&lt;<a class="code" href="namespaceStringUtility.html#b07dfdb6df484680f9a29ad4fcf79f80">StringUtility::addrToString</a>(block-&gt;<a class="code" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>()) &lt;&lt;<span class="stringliteral">"\" ]"</span>;
      }
  };

  <span class="comment">// Write the graph</span>
  boost::write_graphviz(std::cout, cfg, GraphvizVertexWriter(cfg));
</pre></div><p>
[1] <a href="https://secure.wikimedia.org/wikipedia/en/wiki/Control_flow_graph">https://secure.wikimedia.org/wikipedia/en/wiki/Control_flow_graph</a> 
<p>

<p>
Definition at line <a class="el" href="BinaryControlFlow_8h-source.html#l00112">112</a> of file <a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a>.<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef boost::adjacency_list&lt;<br>
 boost::setS, boost::vecS,<br>
 boost::bidirectionalS, boost::property&lt;<br>
 boost::vertex_name_t, <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> * &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#d704a3d62401287d23f40c0aed8b70e8">Graph</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default control flow graph type.  <a href="#d704a3d62401287d23f40c0aed8b70e8"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#d94587a729936415c40e65d1c274b0b2">ControlFlow</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#4c1d71eaa352ed643ebab2ed32c065f0">clear_ast</a> (<a class="el" href="classSgNode.html">SgNode</a> *ast)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears successor information from the AST.  <a href="#4c1d71eaa352ed643ebab2ed32c065f0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class ControlFlowGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#568c4c7e6937ece21891abc092133ed2">apply_to_ast</a> (const ControlFlowGraph &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies graph to AST.  <a href="#568c4c7e6937ece21891abc092133ed2"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class ControlFlowGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#30051216b4c0ed13ceb6f9e16f11834e">cache_vertex_descriptors</a> (const ControlFlowGraph &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cache vertex descriptors in AST.  <a href="#30051216b4c0ed13ceb6f9e16f11834e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class ControlFlowGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::vector&lt; typename boost::graph_traits&lt;<br>
 ControlFlowGraph &gt;::vertex_descriptor &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#9b44dd5ab3164a42619a3c985a6d86ff">flow_order</a> (const ControlFlowGraph &amp;, typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor start, std::vector&lt; size_t &gt; *reverse_order=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Orders nodes by depth first search reverse post order.  <a href="#9b44dd5ab3164a42619a3c985a6d86ff"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class ControlFlowGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::vector&lt; typename boost::graph_traits&lt;<br>
 ControlFlowGraph &gt;::vertex_descriptor &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#a23ac98fe0507882b7b3e566d91f8cc5">return_blocks</a> (const ControlFlowGraph &amp;<a class="el" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>, typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor start)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns list of function return blocks.  <a href="#a23ac98fe0507882b7b3e566d91f8cc5"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#8c601fcc466e5264ac2b95a9b97b4972">set_vertex_filter</a> (<a class="el" href="classBinaryAnalysis_1_1ControlFlow_1_1VertexFilter.html">VertexFilter</a> *filter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manipulate the vertex filter.  <a href="#8c601fcc466e5264ac2b95a9b97b4972"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classBinaryAnalysis_1_1ControlFlow_1_1VertexFilter.html">VertexFilter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#0e956b6a5e301fddce57bdc560bc1e07">get_vertex_filter</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manipulate the vertex filter.  <a href="#0e956b6a5e301fddce57bdc560bc1e07"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#bcf4d93c4f4c729804a2f2d2aa4fa016">set_edge_filter</a> (<a class="el" href="classBinaryAnalysis_1_1ControlFlow_1_1EdgeFilter.html">EdgeFilter</a> *filter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manipulate the edge filter.  <a href="#bcf4d93c4f4c729804a2f2d2aa4fa016"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classBinaryAnalysis_1_1ControlFlow_1_1EdgeFilter.html">EdgeFilter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#caa73fc90ba2d46bde1beb8ad7076c58">get_edge_filter</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manipulate the edge filter.  <a href="#caa73fc90ba2d46bde1beb8ad7076c58"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#5e6e8bcad74de9f7774aaef4b020551b">is_vertex_filtered</a> (<a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *block, <a class="el" href="classBinaryAnalysis_1_1ControlFlow_1_1VertexFilter.html">VertexFilter</a> *filter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if a vertex is filtered out.  <a href="#5e6e8bcad74de9f7774aaef4b020551b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#5d79bb2dd20a320394a688bec0ca745f">is_vertex_filtered</a> (<a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *block)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if a vertex is filtered out.  <a href="#5d79bb2dd20a320394a688bec0ca745f"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#a5f92125604556805185b1093276cbbd">is_edge_filtered</a> (<a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *src, <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *dst, <a class="el" href="classBinaryAnalysis_1_1ControlFlow_1_1EdgeFilter.html">EdgeFilter</a> *filter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if an edge is filtered out.  <a href="#a5f92125604556805185b1093276cbbd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#cfa4725abb0f7dfb9c3fae68e52ce021">is_edge_filtered</a> (<a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *src, <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if an edge is filtered out.  <a href="#cfa4725abb0f7dfb9c3fae68e52ce021"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class ControlFlowGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ControlFlowGraph&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#a05cddf89974e64596a6cde6c88034cd">build_cfg_from_ast</a> (<a class="el" href="classSgNode.html">SgNode</a> *root)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a control flow graph for part of an AST.  <a href="#a05cddf89974e64596a6cde6c88034cd"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class ControlFlowGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#29fcf825725b491d030862ce1b3b7e3a">build_cfg_from_ast</a> (<a class="el" href="classSgNode.html">SgNode</a> *root, ControlFlowGraph &amp;<a class="el" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a control flow graph for part of an AST.  <a href="#29fcf825725b491d030862ce1b3b7e3a"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class ControlFlowGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ControlFlowGraph&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#d656d3f7b97cc4bf2cc58983877c58a4">build_cg_from_ast</a> (<a class="el" href="classSgNode.html">SgNode</a> *root)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a control flow graph with only function call edges.  <a href="#d656d3f7b97cc4bf2cc58983877c58a4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class ControlFlowGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#b53158918a9295fc507a556f08575400">build_cg_from_ast</a> (<a class="el" href="classSgNode.html">SgNode</a> *root, ControlFlowGraph &amp;<a class="el" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a control flow graph with only function call edges.  <a href="#b53158918a9295fc507a556f08575400"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class ControlFlowGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ControlFlowGraph&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#7a1476ccd3c335b5e6a5a49edc87b31a">copy</a> (const ControlFlowGraph &amp;src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a graph while filtering.  <a href="#7a1476ccd3c335b5e6a5a49edc87b31a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class ControlFlowGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#d346491ff2cc65190247edd57c38811f">copy</a> (const ControlFlowGraph &amp;src, ControlFlowGraph &amp;dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a graph while filtering.  <a href="#d346491ff2cc65190247edd57c38811f"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classBinaryAnalysis_1_1ControlFlow_1_1VertexFilter.html">VertexFilter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#86fb22efa66d4b6a8562cb67e33c6781">vertex_filter</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classBinaryAnalysis_1_1ControlFlow_1_1EdgeFilter.html">EdgeFilter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#80d77204cf9f714828a775faff29dfac">edge_filter</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow_1_1EdgeFilter.html">EdgeFilter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Filter for edges.  <a href="classBinaryAnalysis_1_1ControlFlow_1_1EdgeFilter.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBinaryAnalysis_1_1ControlFlow_1_1FlowOrder.html">FlowOrder</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBinaryAnalysis_1_1ControlFlow_1_1ReturnBlocks.html">ReturnBlocks</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow_1_1VertexFilter.html">VertexFilter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Filter for vertices.  <a href="classBinaryAnalysis_1_1ControlFlow_1_1VertexFilter.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1ControlFlow_1_1VertexInserter.html">VertexInserter</a></td></tr>

</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="d704a3d62401287d23f40c0aed8b70e8"></a><!-- doxytag: member="BinaryAnalysis::ControlFlow::Graph" ref="d704a3d62401287d23f40c0aed8b70e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::adjacency_list&lt;boost::setS, boost::vecS, boost::bidirectionalS, boost::property&lt;boost::vertex_name_t, <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a>*&gt; &gt; <a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#d704a3d62401287d23f40c0aed8b70e8">BinaryAnalysis::ControlFlow::Graph</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default control flow graph type. 
<p>
A control flow graph is simply a Boost graph whose vertex descriptors are integers and whose vertices point to <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> nodes in the AST (via the boost::vertex_name property). The graph edges represent flow of control from one <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> to another. Since the control flow graph is a Boost graph, it is endowed with all the features of a Boost graph and can be the operand of the various Boost graph algorithms. See <a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#a05cddf89974e64596a6cde6c88034cd">build_cfg_from_ast()</a> for specifics about what is included in such a graph.<p>
It is common to need a type for the vertices and edges. Boost graphs store this information in graph_traits and users should use that to obtain those types. Doing so will, in the long run, make your code more extensible since the only datatype you're depending on is the graph itself--change the graph type and the vertex and edge types will automatically adjust. See Boost Graph Library documentation for all the available types. The most common are:<p>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> boost::graph_traits&lt;Graph&gt;::vertex_descriptor <a class="code" href="structVertex.html">Vertex</a>;
  <span class="keyword">typedef</span> boost::graph_traits&lt;Graph&gt;::edge_descriptor <a class="code" href="structEdge.html">Edge</a>;
</pre></div> 
<p>
Definition at line <a class="el" href="BinaryControlFlow_8h-source.html#l00140">140</a> of file <a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a>.
</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="d94587a729936415c40e65d1c274b0b2"></a><!-- doxytag: member="BinaryAnalysis::ControlFlow::ControlFlow" ref="d94587a729936415c40e65d1c274b0b2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BinaryAnalysis::ControlFlow::ControlFlow           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="BinaryControlFlow_8h-source.html#l00114">114</a> of file <a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a>.
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="8c601fcc466e5264ac2b95a9b97b4972"></a><!-- doxytag: member="BinaryAnalysis::ControlFlow::set_vertex_filter" ref="8c601fcc466e5264ac2b95a9b97b4972" args="(VertexFilter *filter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BinaryAnalysis::ControlFlow::set_vertex_filter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBinaryAnalysis_1_1ControlFlow_1_1VertexFilter.html">VertexFilter</a> *&nbsp;</td>
          <td class="paramname"> <em>filter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Manipulate the vertex filter. 
<p>
When building a control flow graph, the vertex filter is invoked on each basic block which is about to be added as a vertex. If the filter returns false then that block is not added to the graph. A null filter accepts all vertices. 
<p>
Definition at line <a class="el" href="BinaryControlFlow_8h-source.html#l00174">174</a> of file <a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a>.
<p>
References <a class="el" href="BinaryControlFlow_8h-source.html#l00211">vertex_filter</a>.
</div>
</div><p>
<a class="anchor" name="0e956b6a5e301fddce57bdc560bc1e07"></a><!-- doxytag: member="BinaryAnalysis::ControlFlow::get_vertex_filter" ref="0e956b6a5e301fddce57bdc560bc1e07" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBinaryAnalysis_1_1ControlFlow_1_1VertexFilter.html">VertexFilter</a>* BinaryAnalysis::ControlFlow::get_vertex_filter           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Manipulate the vertex filter. 
<p>
When building a control flow graph, the vertex filter is invoked on each basic block which is about to be added as a vertex. If the filter returns false then that block is not added to the graph. A null filter accepts all vertices. 
<p>
Definition at line <a class="el" href="BinaryControlFlow_8h-source.html#l00175">175</a> of file <a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a>.
<p>
References <a class="el" href="BinaryControlFlow_8h-source.html#l00211">vertex_filter</a>.
</div>
</div><p>
<a class="anchor" name="bcf4d93c4f4c729804a2f2d2aa4fa016"></a><!-- doxytag: member="BinaryAnalysis::ControlFlow::set_edge_filter" ref="bcf4d93c4f4c729804a2f2d2aa4fa016" args="(EdgeFilter *filter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BinaryAnalysis::ControlFlow::set_edge_filter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBinaryAnalysis_1_1ControlFlow_1_1EdgeFilter.html">EdgeFilter</a> *&nbsp;</td>
          <td class="paramname"> <em>filter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Manipulate the edge filter. 
<p>
When building a control flow graph, the edge filter is invoked for each edge which is about to be added to the graph. If the filter returns false then that edge is not added to the graph. A null filter accepts all edges. 
<p>
Definition at line <a class="el" href="BinaryControlFlow_8h-source.html#l00184">184</a> of file <a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a>.
<p>
References <a class="el" href="BinaryControlFlow_8h-source.html#l00212">edge_filter</a>.
<p>
Referenced by <a class="el" href="BinaryControlFlow_8h-source.html#l00513">build_cg_from_ast()</a>.
</div>
</div><p>
<a class="anchor" name="caa73fc90ba2d46bde1beb8ad7076c58"></a><!-- doxytag: member="BinaryAnalysis::ControlFlow::get_edge_filter" ref="caa73fc90ba2d46bde1beb8ad7076c58" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBinaryAnalysis_1_1ControlFlow_1_1EdgeFilter.html">EdgeFilter</a>* BinaryAnalysis::ControlFlow::get_edge_filter           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Manipulate the edge filter. 
<p>
When building a control flow graph, the edge filter is invoked for each edge which is about to be added to the graph. If the filter returns false then that edge is not added to the graph. A null filter accepts all edges. 
<p>
Definition at line <a class="el" href="BinaryControlFlow_8h-source.html#l00185">185</a> of file <a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a>.
<p>
References <a class="el" href="BinaryControlFlow_8h-source.html#l00212">edge_filter</a>.
<p>
Referenced by <a class="el" href="BinaryControlFlow_8h-source.html#l00513">build_cg_from_ast()</a>.
</div>
</div><p>
<a class="anchor" name="5e6e8bcad74de9f7774aaef4b020551b"></a><!-- doxytag: member="BinaryAnalysis::ControlFlow::is_vertex_filtered" ref="5e6e8bcad74de9f7774aaef4b020551b" args="(SgAsmBlock *block, VertexFilter *filter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BinaryAnalysis::ControlFlow::is_vertex_filtered           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBinaryAnalysis_1_1ControlFlow_1_1VertexFilter.html">VertexFilter</a> *&nbsp;</td>
          <td class="paramname"> <em>filter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if a vertex is filtered out. 
<p>
Returns true if the vertex would be filtered out by being rejected by the current vertex filter. 
<p>
Definition at line <a class="el" href="BinaryControlFlow_8h-source.html#l00193">193</a> of file <a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a>.
<p>
Referenced by <a class="el" href="BinaryControlFlow_8h-source.html#l00443">apply_to_ast()</a>, <a class="el" href="BinaryControlFlow_8h-source.html#l00474">cache_vertex_descriptors()</a>, <a class="el" href="BinaryControlFlow_8h-source.html#l00350">BinaryAnalysis::ControlFlow::VertexInserter&lt; ControlFlowGraph &gt;::conditionally_add_vertex()</a>, <a class="el" href="BinaryControlFlow_8h-source.html#l00542">copy()</a>, and <a class="el" href="BinaryControlFlow_8h-source.html#l00194">is_vertex_filtered()</a>.
</div>
</div><p>
<a class="anchor" name="5d79bb2dd20a320394a688bec0ca745f"></a><!-- doxytag: member="BinaryAnalysis::ControlFlow::is_vertex_filtered" ref="5d79bb2dd20a320394a688bec0ca745f" args="(SgAsmBlock *block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BinaryAnalysis::ControlFlow::is_vertex_filtered           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>block</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if a vertex is filtered out. 
<p>
Returns true if the vertex would be filtered out by being rejected by the current vertex filter. 
<p>
Definition at line <a class="el" href="BinaryControlFlow_8h-source.html#l00194">194</a> of file <a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a>.
<p>
References <a class="el" href="BinaryControlFlow_8h-source.html#l00193">is_vertex_filtered()</a>, and <a class="el" href="BinaryControlFlow_8h-source.html#l00211">vertex_filter</a>.
</div>
</div><p>
<a class="anchor" name="a5f92125604556805185b1093276cbbd"></a><!-- doxytag: member="BinaryAnalysis::ControlFlow::is_edge_filtered" ref="a5f92125604556805185b1093276cbbd" args="(SgAsmBlock *src, SgAsmBlock *dst, EdgeFilter *filter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BinaryAnalysis::ControlFlow::is_edge_filtered           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBinaryAnalysis_1_1ControlFlow_1_1EdgeFilter.html">EdgeFilter</a> *&nbsp;</td>
          <td class="paramname"> <em>filter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if an edge is filtered out. 
<p>
Returns true if the edge would be filtered out by being rejected by the current edge filter. 
<p>
Definition at line <a class="el" href="BinaryControlFlow_8h-source.html#l00202">202</a> of file <a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a>.
<p>
Referenced by <a class="el" href="BinaryControlFlow_8h-source.html#l00443">apply_to_ast()</a>, <a class="el" href="BinaryControlFlow_8h-source.html#l00486">build_cfg_from_ast()</a>, <a class="el" href="BinaryControlFlow_8h-source.html#l00542">copy()</a>, and <a class="el" href="BinaryControlFlow_8h-source.html#l00205">is_edge_filtered()</a>.
</div>
</div><p>
<a class="anchor" name="cfa4725abb0f7dfb9c3fae68e52ce021"></a><!-- doxytag: member="BinaryAnalysis::ControlFlow::is_edge_filtered" ref="cfa4725abb0f7dfb9c3fae68e52ce021" args="(SgAsmBlock *src, SgAsmBlock *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BinaryAnalysis::ControlFlow::is_edge_filtered           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if an edge is filtered out. 
<p>
Returns true if the edge would be filtered out by being rejected by the current edge filter. 
<p>
Definition at line <a class="el" href="BinaryControlFlow_8h-source.html#l00205">205</a> of file <a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a>.
<p>
References <a class="el" href="BinaryControlFlow_8h-source.html#l00212">edge_filter</a>, and <a class="el" href="BinaryControlFlow_8h-source.html#l00202">is_edge_filtered()</a>.
</div>
</div><p>
<a class="anchor" name="4c1d71eaa352ed643ebab2ed32c065f0"></a><!-- doxytag: member="BinaryAnalysis::ControlFlow::clear_ast" ref="4c1d71eaa352ed643ebab2ed32c065f0" args="(SgNode *ast)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BinaryAnalysis::ControlFlow::clear_ast           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>ast</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears successor information from the AST. 
<p>
Traverses the specified AST and clears the successor lists for all blocks. The blocks are visited by an AST traversal, not by following successor pointers.<p>
The current vertex filter determines which edges are filtered. 
</div>
</div><p>
<a class="anchor" name="568c4c7e6937ece21891abc092133ed2"></a><!-- doxytag: member="BinaryAnalysis::ControlFlow::apply_to_ast" ref="568c4c7e6937ece21891abc092133ed2" args="(const ControlFlowGraph &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BinaryAnalysis::ControlFlow::apply_to_ast           </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies graph to AST. 
<p>
Just as a control flow graph can be built from the successor lists stored in the AST (see <a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#a05cddf89974e64596a6cde6c88034cd">build_cfg_from_ast()</a>), a graph can be used to initialize the successor information in an AST. This function does that. Only the blocks which are vertices of the graph and which pass the current vertex filter are affected. Only edges that pass the current edge filter are added as successors to the (cleared) block successor list.<p>
At this time [2011-05-19] the successor_complete property of each affected block is set to true, but this may change in the future. 
<p>
Definition at line <a class="el" href="BinaryControlFlow_8h-source.html#l00443">443</a> of file <a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a>.
<p>
References <a class="el" href="BinaryControlFlow_8h-source.html#l00202">is_edge_filtered()</a>, and <a class="el" href="BinaryControlFlow_8h-source.html#l00193">is_vertex_filtered()</a>.
</div>
</div><p>
<a class="anchor" name="30051216b4c0ed13ceb6f9e16f11834e"></a><!-- doxytag: member="BinaryAnalysis::ControlFlow::cache_vertex_descriptors" ref="30051216b4c0ed13ceb6f9e16f11834e" args="(const ControlFlowGraph &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BinaryAnalysis::ControlFlow::cache_vertex_descriptors           </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cache vertex descriptors in AST. 
<p>
The vertices of a control flow graph are of type <a class="el" href="structVertex.html">Vertex</a>, and point at the basic blocks (<a class="el" href="classSgAsmBlock.html">SgAsmBlock</a>) of the AST. Although most graph algorithms will only need to map <a class="el" href="structVertex.html">Vertex</a> to <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a>, the inverse mapping is also sometimes useful. That mapping can be stored into an std::map via graph traversal, or stored in the AST itself attached to each <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a>. Using an std::map requires an O(log N) lookup each time we need to get the vertex descriptor from a block, while storing the vertex descriptor in the AST requires O(1) lookup time.<p>
The vertex descriptors are available via <a class="el" href="classSgAsmBlock.html#e7899513748bd3f925b56b2f8a78a8a7">SgAsmBlock::get_cached_vertex()</a>. Other graph types (e.g., dominance graphs) might also use the same cache line. The cached vertex is stored as a size_t, which is the same underlying type for CFG vertices.<p>
The current vertex filter determines which blocks are modified. 
<p>
Definition at line <a class="el" href="BinaryControlFlow_8h-source.html#l00474">474</a> of file <a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a>.
<p>
References <a class="el" href="BinaryControlFlow_8h-source.html#l00193">is_vertex_filtered()</a>.
</div>
</div><p>
<a class="anchor" name="a05cddf89974e64596a6cde6c88034cd"></a><!-- doxytag: member="BinaryAnalysis::ControlFlow::build_cfg_from_ast" ref="a05cddf89974e64596a6cde6c88034cd" args="(SgNode *root)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ControlFlowGraph BinaryAnalysis::ControlFlow::build_cfg_from_ast           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a control flow graph for part of an AST. 
<p>
Builds a control flow graph for the part of the abstract syntax tree rooted at <code>root</code> by traversing the AST to find all basic blocks and using the successors of those blocks to define the edges of the control flow graph. Successors are retrieved via <a class="el" href="classSgAsmBlock.html#54922f0881f4b2a3d3b3808a3b3e77ae">SgAsmBlock::get_successors()</a> and are of type <a class="el" href="classSgAsmIntegerValueExpression.html">SgAsmIntegerValueExpression</a>.<p>
The current vertex and edge filters are used to determine which blocks and flow edges are added to the graph. However, the following types of successors are never added (and don't trigger a call to the filter): <ul>
<li>
Successors that have no block pointer, but only an address. This can happen when we didn't disassemble any instruction at the successor address, and thus don't have a block at which to point. </li>
<li>
Successors that point to a block outside the specified AST subtree. For instance, when considering the control flow graph of an individual function, successors for function calls will point outside the calling function (unless the call is recursive).</li>
<li>
</li>
<li>
Successors that are not known. Some basic blocks, such as function return blocks or blocks ending with computed branches, usually only have unknown successors. Such edges are not added to the graph. </li>
</ul>

<p>
Definition at line <a class="el" href="BinaryControlFlow_8h-source.html#l00637">637</a> of file <a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a>.
<p>
References <a class="el" href="yicesParserLib_8h-source.html#l01439">cfg</a>.
<p>
Referenced by <a class="el" href="BinaryControlFlow_8h-source.html#l00513">build_cg_from_ast()</a>.
</div>
</div><p>
<a class="anchor" name="29fcf825725b491d030862ce1b3b7e3a"></a><!-- doxytag: member="BinaryAnalysis::ControlFlow::build_cfg_from_ast" ref="29fcf825725b491d030862ce1b3b7e3a" args="(SgNode *root, ControlFlowGraph &amp;cfg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BinaryAnalysis::ControlFlow::build_cfg_from_ast           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ControlFlowGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cfg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a control flow graph for part of an AST. 
<p>
Builds a control flow graph for the part of the abstract syntax tree rooted at <code>root</code> by traversing the AST to find all basic blocks and using the successors of those blocks to define the edges of the control flow graph. Successors are retrieved via <a class="el" href="classSgAsmBlock.html#54922f0881f4b2a3d3b3808a3b3e77ae">SgAsmBlock::get_successors()</a> and are of type <a class="el" href="classSgAsmIntegerValueExpression.html">SgAsmIntegerValueExpression</a>.<p>
The current vertex and edge filters are used to determine which blocks and flow edges are added to the graph. However, the following types of successors are never added (and don't trigger a call to the filter): <ul>
<li>
Successors that have no block pointer, but only an address. This can happen when we didn't disassemble any instruction at the successor address, and thus don't have a block at which to point. </li>
<li>
Successors that point to a block outside the specified AST subtree. For instance, when considering the control flow graph of an individual function, successors for function calls will point outside the calling function (unless the call is recursive).</li>
<li>
</li>
<li>
Successors that are not known. Some basic blocks, such as function return blocks or blocks ending with computed branches, usually only have unknown successors. Such edges are not added to the graph. </li>
</ul>

<p>
Definition at line <a class="el" href="BinaryControlFlow_8h-source.html#l00486">486</a> of file <a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a>.
<p>
References <a class="el" href="yicesParserLib_8h-source.html#l01439">cfg</a>, <a class="el" href="BinaryControlFlow_8h-source.html#l00202">is_edge_filtered()</a>, <a class="el" href="Cxx__Grammar_8h.html#0f21c6b7a4aede1900e16a5122233a83">isSgAsmBlock()</a>, and <a class="el" href="Cxx__Grammar_8h.html#59f7fee88581c4dd75f5fb25dbefa29edefb5d09673c144dc5b4dc177e278696">preorder</a>.
</div>
</div><p>
<a class="anchor" name="d656d3f7b97cc4bf2cc58983877c58a4"></a><!-- doxytag: member="BinaryAnalysis::ControlFlow::build_cg_from_ast" ref="d656d3f7b97cc4bf2cc58983877c58a4" args="(SgNode *root)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ControlFlowGraph BinaryAnalysis::ControlFlow::build_cg_from_ast           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a control flow graph with only function call edges. 
<p>
This differs from a true <a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#2532d28ee1226ae45fd43cc6c660ceac">FunctionCall::Graph</a> in that the vertices of the returned graph point to basic blocks, while the vertices of a <a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#2532d28ee1226ae45fd43cc6c660ceac">FunctionCall::Graph</a> point to functions (<a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> nodes).<p>
The graph is built by applying an edge filter (in addition to the edge filter that might be set by the user) that only accepts edges whose target is a function entry block. 
<p>
Definition at line <a class="el" href="BinaryControlFlow_8h-source.html#l00646">646</a> of file <a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a>.
<p>
References <a class="el" href="yicesParserLib_8h-source.html#l01439">cfg</a>.
</div>
</div><p>
<a class="anchor" name="b53158918a9295fc507a556f08575400"></a><!-- doxytag: member="BinaryAnalysis::ControlFlow::build_cg_from_ast" ref="b53158918a9295fc507a556f08575400" args="(SgNode *root, ControlFlowGraph &amp;cfg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BinaryAnalysis::ControlFlow::build_cg_from_ast           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ControlFlowGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cfg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a control flow graph with only function call edges. 
<p>
This differs from a true <a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#2532d28ee1226ae45fd43cc6c660ceac">FunctionCall::Graph</a> in that the vertices of the returned graph point to basic blocks, while the vertices of a <a class="el" href="classBinaryAnalysis_1_1FunctionCall.html#2532d28ee1226ae45fd43cc6c660ceac">FunctionCall::Graph</a> point to functions (<a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> nodes).<p>
The graph is built by applying an edge filter (in addition to the edge filter that might be set by the user) that only accepts edges whose target is a function entry block. 
<p>
Definition at line <a class="el" href="BinaryControlFlow_8h-source.html#l00513">513</a> of file <a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a>.
<p>
References <a class="el" href="BinaryControlFlow_8h-source.html#l00637">build_cfg_from_ast()</a>, <a class="el" href="BinaryControlFlow_8h-source.html#l00212">edge_filter</a>, <a class="el" href="BinaryControlFlow_8h-source.html#l00185">get_edge_filter()</a>, <a class="el" href="classSgAsmBlock.html#bdd6257d93832cc2b0dcbdf07f9ccd3c">SgAsmBlock::get_enclosing_function()</a>, <a class="el" href="SgAsmFunction_8C-source.html#l00192">SgAsmFunction::get_entry_block()</a>, and <a class="el" href="BinaryControlFlow_8h-source.html#l00184">set_edge_filter()</a>.
</div>
</div><p>
<a class="anchor" name="7a1476ccd3c335b5e6a5a49edc87b31a"></a><!-- doxytag: member="BinaryAnalysis::ControlFlow::copy" ref="7a1476ccd3c335b5e6a5a49edc87b31a" args="(const ControlFlowGraph &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ControlFlowGraph BinaryAnalysis::ControlFlow::copy           </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies a graph while filtering. 
<p>
Copies a graph while applying the current source and destination vertex and edge filters. If all vertices are selected by the vertex filter, then the desintation graph's vertex descriptors will correspond to the same vertices in the source graph (i.e., vertex V in the source will be the same basic block as vertex V in the destination).<p>
If an edge is unfiltered but one of its vertices is filtered, then the edge will not be included in the result. 
<p>
Definition at line <a class="el" href="BinaryControlFlow_8h-source.html#l00572">572</a> of file <a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a>.
</div>
</div><p>
<a class="anchor" name="d346491ff2cc65190247edd57c38811f"></a><!-- doxytag: member="BinaryAnalysis::ControlFlow::copy" ref="d346491ff2cc65190247edd57c38811f" args="(const ControlFlowGraph &amp;src, ControlFlowGraph &amp;dst)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BinaryAnalysis::ControlFlow::copy           </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ControlFlowGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies a graph while filtering. 
<p>
Copies a graph while applying the current source and destination vertex and edge filters. If all vertices are selected by the vertex filter, then the desintation graph's vertex descriptors will correspond to the same vertices in the source graph (i.e., vertex V in the source will be the same basic block as vertex V in the destination).<p>
If an edge is unfiltered but one of its vertices is filtered, then the edge will not be included in the result. 
<p>
Definition at line <a class="el" href="BinaryControlFlow_8h-source.html#l00542">542</a> of file <a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a>.
<p>
References <a class="el" href="BinaryControlFlow_8h-source.html#l00202">is_edge_filtered()</a>, and <a class="el" href="BinaryControlFlow_8h-source.html#l00193">is_vertex_filtered()</a>.
</div>
</div><p>
<a class="anchor" name="9b44dd5ab3164a42619a3c985a6d86ff"></a><!-- doxytag: member="BinaryAnalysis::ControlFlow::flow_order" ref="9b44dd5ab3164a42619a3c985a6d86ff" args="(const ControlFlowGraph &amp;, typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor start, std::vector&lt; size_t &gt; *reverse_order=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor &gt; BinaryAnalysis::ControlFlow::flow_order           </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; *&nbsp;</td>
          <td class="paramname"> <em>reverse_order</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Orders nodes by depth first search reverse post order. 
<p>
Reversed, depth-first-search, post-order is a common node order needed for solving flow equations, and this method returns a vector whose elements are graph vertices. The algorithm is to allocate the vector to be the same length as the total number of vertices in the graph, and then do a depth-first-search starting with the specified node. Each node is visited after all its children (post-order). Each node visit adds the node to the vector starting at the end of the vector and working forward.<p>
If reverse_order is non-null then it will be the inverse mapping from the returned vector. In other words, if the return value is named forward_order, then<p>
forward_order[i] == v implies reverse_order[v] == i<p>
Here's an example of how this would typically be used.<p>
<div class="fragment"><pre class="fragment">  std::vector&lt;size_t&gt; rflowlist; <span class="comment">// reverse mapping</span>
  std::vector&lt;ControlFlow::Vector&gt; flowlist;
  flowlist = <a class="code" href="classBinaryAnalysis_1_1ControlFlow.html#d94587a729936415c40e65d1c274b0b2">ControlFlow</a>().flow_order(cfg, start, &amp;rflowlist);

  <span class="keywordtype">bool</span> changed;
  <span class="keywordflow">do</span> {
      changed = <span class="keyword">false</span>;
      <span class="keywordflow">for</span> (size_t i=0; i&lt;flowlist.size(); ++i) {
          ControlFlow::Vertex vertex = flowlist[i];
          <span class="comment">// solve flow equation for vertex...</span>
          <span class="keywordflow">if</span> (result_at_vertex_changed)
              changed = <span class="keyword">true</span>;
      }
  } <span class="keywordflow">while</span> (changed);
</pre></div> 
<p>
Definition at line <a class="el" href="BinaryControlFlow_8h-source.html#l00604">604</a> of file <a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a>.
</div>
</div><p>
<a class="anchor" name="a23ac98fe0507882b7b3e566d91f8cc5"></a><!-- doxytag: member="BinaryAnalysis::ControlFlow::return_blocks" ref="a23ac98fe0507882b7b3e566d91f8cc5" args="(const ControlFlowGraph &amp;cfg, typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor start)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor &gt; BinaryAnalysis::ControlFlow::return_blocks           </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor&nbsp;</td>
          <td class="paramname"> <em>start</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns list of function return blocks. 
<p>
More specifically, this method traverses the control flow graph (CFG) beginning at the specified node and returns a list (in depth first search order) of all vertices which are in the connected subgraph and which do not have any known successors, but at least one unknown successor. 
<p>
Definition at line <a class="el" href="BinaryControlFlow_8h-source.html#l00625">625</a> of file <a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a>.
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="86fb22efa66d4b6a8562cb67e33c6781"></a><!-- doxytag: member="BinaryAnalysis::ControlFlow::vertex_filter" ref="86fb22efa66d4b6a8562cb67e33c6781" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBinaryAnalysis_1_1ControlFlow_1_1VertexFilter.html">VertexFilter</a>* <a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#86fb22efa66d4b6a8562cb67e33c6781">BinaryAnalysis::ControlFlow::vertex_filter</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="BinaryControlFlow_8h-source.html#l00211">211</a> of file <a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a>.
<p>
Referenced by <a class="el" href="BinaryControlFlow_8h-source.html#l00175">get_vertex_filter()</a>, <a class="el" href="BinaryControlFlow_8h-source.html#l00194">is_vertex_filtered()</a>, and <a class="el" href="BinaryControlFlow_8h-source.html#l00174">set_vertex_filter()</a>.
</div>
</div><p>
<a class="anchor" name="80d77204cf9f714828a775faff29dfac"></a><!-- doxytag: member="BinaryAnalysis::ControlFlow::edge_filter" ref="80d77204cf9f714828a775faff29dfac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBinaryAnalysis_1_1ControlFlow_1_1EdgeFilter.html">EdgeFilter</a>* <a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#80d77204cf9f714828a775faff29dfac">BinaryAnalysis::ControlFlow::edge_filter</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="BinaryControlFlow_8h-source.html#l00212">212</a> of file <a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a>.
<p>
Referenced by <a class="el" href="BinaryControlFlow_8h-source.html#l00513">build_cg_from_ast()</a>, <a class="el" href="BinaryControlFlow_8h-source.html#l00185">get_edge_filter()</a>, <a class="el" href="BinaryControlFlow_8h-source.html#l00205">is_edge_filtered()</a>, and <a class="el" href="BinaryControlFlow_8h-source.html#l00184">set_edge_filter()</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="BinaryControlFlow_8h-source.html">BinaryControlFlow.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
