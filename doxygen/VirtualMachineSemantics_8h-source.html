<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: VirtualMachineSemantics.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>VirtualMachineSemantics.h</h1><a href="VirtualMachineSemantics_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef Rose_VirtualMachineSemantics_H</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define Rose_VirtualMachineSemantics_H</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 
<a name="l00005"></a>00005 <span class="preprocessor">#ifndef __STDC_FORMAT_MACROS</span>
<a name="l00006"></a>00006 <span class="preprocessor"></span><span class="preprocessor">#define __STDC_FORMAT_MACROS</span>
<a name="l00007"></a>00007 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00008"></a>00008 <span class="preprocessor"></span><span class="preprocessor">#include &lt;inttypes.h&gt;</span>
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;stdint.h&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00013"></a>00013 
<a name="l00014"></a>00014 <span class="preprocessor">#include "rosePublicConfig.h"</span>
<a name="l00015"></a>00015 <span class="preprocessor">#ifdef ROSE_HAVE_GCRYPT_H</span>
<a name="l00016"></a>00016 <span class="preprocessor"></span><span class="preprocessor">#include &lt;gcrypt.h&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#endif</span>
<a name="l00018"></a>00018 <span class="preprocessor"></span>
<a name="l00019"></a>00019 <span class="preprocessor">#include "<a class="code" href="x86InstructionSemantics_8h.html">x86InstructionSemantics.h</a>"</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include "<a class="code" href="BaseSemantics_8h.html">BaseSemantics.h</a>"</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include "<a class="code" href="MemoryMap_8h.html">MemoryMap.h</a>"</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="keyword">namespace </span>BinaryAnalysis {                      <span class="comment">// documented elsewhere</span>
<a name="l00024"></a>00024     <span class="keyword">namespace </span>InstructionSemantics {            <span class="comment">// documented elsewhere</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 
<a name="l00040"></a><a class="code" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics.html">00040</a>         <span class="keyword">namespace </span>VirtualMachineSemantics {
<a name="l00041"></a>00041 
<a name="l00042"></a>00042             <span class="keyword">extern</span> uint64_t <a class="code" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics.html#61cd94a8fc9e2c2994d4375710b877a6">name_counter</a>;
<a name="l00043"></a>00043 
<a name="l00044"></a><a class="code" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics.html#16a0fa410b5f7f2caf704e14194c53d4">00044</a>             <span class="keyword">typedef</span> std::map&lt;uint64_t, uint64_t&gt; <a class="code" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics.html#16a0fa410b5f7f2caf704e14194c53d4">RenameMap</a>;
<a name="l00045"></a>00045 
<a name="l00047"></a>00047             <span class="keyword">template</span>&lt;size_t nBits&gt;
<a name="l00048"></a><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">00048</a>             <span class="keyword">struct </span><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType</a> {
<a name="l00049"></a><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">00049</a>                 uint64_t <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>;                      
<a name="l00050"></a><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">00050</a>                 uint64_t <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a>;                    
<a name="l00052"></a><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">00052</a>                 <span class="keywordtype">bool</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a>;                        
<a name="l00056"></a><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#b90bcd8f6fdad12b3a1f68d7565853b1">00056</a>                 <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#b90bcd8f6fdad12b3a1f68d7565853b1">ValueType</a>(): <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>(++<a class="code" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics.html#61cd94a8fc9e2c2994d4375710b877a6">name_counter</a>), <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a>(0), <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a>(false) {}
<a name="l00057"></a>00057 
<a name="l00059"></a>00059                 <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00060"></a><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#63fee47557347e87b1655a3c5d345d35">00060</a>                 <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#b90bcd8f6fdad12b3a1f68d7565853b1">ValueType</a>(<span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;other) {
<a name="l00061"></a>00061                     <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a> = other.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>;
<a name="l00062"></a>00062                     <span class="comment">/*make sure high-order bits are zeroed out*/</span>
<a name="l00063"></a>00063                     <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a> = other.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a> &amp; <a class="code" href="structIntegerOps_1_1GenMask.html">IntegerOps::GenMask&lt;uint64_t, nBits&gt;::value</a>;
<a name="l00064"></a>00064                     <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a> = other.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a>;
<a name="l00065"></a>00065                 }
<a name="l00066"></a>00066 
<a name="l00068"></a><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#038155dac54da3a3ea16a45802b69ff0">00068</a>                 <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#b90bcd8f6fdad12b3a1f68d7565853b1">ValueType</a>(uint64_t n)   <span class="comment">/*implicit*/</span>
<a name="l00069"></a>00069                     : <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>(0), <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a>(n), <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a>(false) {
<a name="l00070"></a>00070                     this-&gt;<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a> &amp;= <a class="code" href="structIntegerOps_1_1GenMask.html">IntegerOps::GenMask&lt;uint64_t, nBits&gt;::value</a>;
<a name="l00071"></a>00071                 }
<a name="l00072"></a>00072 
<a name="l00074"></a><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#04d3b9d74e22b74c02beac746cc7bb51">00074</a>                 <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#b90bcd8f6fdad12b3a1f68d7565853b1">ValueType</a>(uint64_t <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>, uint64_t <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a>, <span class="keywordtype">bool</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a>=<span class="keyword">false</span>)
<a name="l00075"></a>00075                     : name(name), offset(offset), <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a>(<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a>) {
<a name="l00076"></a>00076                     this-&gt;offset &amp;= <a class="code" href="structIntegerOps_1_1GenMask.html">IntegerOps::GenMask&lt;uint64_t, nBits&gt;::value</a>;
<a name="l00077"></a>00077                 }
<a name="l00078"></a>00078 
<a name="l00080"></a><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#df41a94ce70e1920ee4c4646625bf6df">00080</a>                 <span class="keywordtype">bool</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#df41a94ce70e1920ee4c4646625bf6df">is_known</a>()<span class="keyword"> const </span>{
<a name="l00081"></a>00081                     <span class="keywordflow">return</span> 0==<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>;
<a name="l00082"></a>00082                 }
<a name="l00083"></a>00083 
<a name="l00085"></a><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#5be6a2613640de8c425a76d03631e643">00085</a>                 uint64_t <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#5be6a2613640de8c425a76d03631e643">known_value</a>()<span class="keyword"> const </span>{
<a name="l00086"></a>00086                     ROSE_ASSERT(<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#df41a94ce70e1920ee4c4646625bf6df">is_known</a>());
<a name="l00087"></a>00087                     <span class="keywordflow">return</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a>;
<a name="l00088"></a>00088                 }
<a name="l00089"></a>00089 
<a name="l00094"></a>00094                 <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;nBits&gt;</a> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#7ac83edb0acfb190034452c64e837bb6">rename</a>(<a class="code" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics.html#16a0fa410b5f7f2caf704e14194c53d4">RenameMap</a> *rmap=NULL) <span class="keyword">const</span>;
<a name="l00095"></a>00095 
<a name="l00098"></a><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#1850ca47a3d164bef7fdfd110ff421ce">00098</a>                 <span class="keywordtype">void</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#1850ca47a3d164bef7fdfd110ff421ce">print</a>(std::ostream &amp;o, <a class="code" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics.html#16a0fa410b5f7f2caf704e14194c53d4">RenameMap</a> *rmap=NULL)<span class="keyword"> const </span>{
<a name="l00099"></a>00099                     uint64_t sign_bit = (uint64_t)1 &lt;&lt; (nBits-1); <span class="comment">/* e.g., 80000000 */</span>
<a name="l00100"></a>00100                     uint64_t val_mask = sign_bit - 1;             <span class="comment">/* e.g., 7fffffff */</span>
<a name="l00101"></a>00101                     <span class="comment">/*magnitude of negative value*/</span>
<a name="l00102"></a>00102                     uint64_t negative = nBits&gt;1 &amp;&amp; (<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a> &amp; sign_bit) ? (~<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a> &amp; val_mask) + 1 : 0;
<a name="l00103"></a>00103 
<a name="l00104"></a>00104                     <span class="keywordflow">if</span> (<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>!=0) {
<a name="l00105"></a>00105                         <span class="comment">/* This is a named value rather than a constant. */</span>
<a name="l00106"></a>00106                         uint64_t renamed = <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>;
<a name="l00107"></a>00107                         <span class="keywordflow">if</span> (rmap) {
<a name="l00108"></a>00108                             RenameMap::iterator found = rmap-&gt;find(<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>);
<a name="l00109"></a>00109                             <span class="keywordflow">if</span> (found==rmap-&gt;end()) {
<a name="l00110"></a>00110                                 renamed = rmap-&gt;size()+1;
<a name="l00111"></a>00111                                 rmap-&gt;insert(std::make_pair(<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>, renamed));
<a name="l00112"></a>00112                             } <span class="keywordflow">else</span> {
<a name="l00113"></a>00113                                 renamed = found-&gt;second;
<a name="l00114"></a>00114                             }
<a name="l00115"></a>00115                         }
<a name="l00116"></a>00116                         <span class="keyword">const</span> <span class="keywordtype">char</span> *sign = <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a> ? <span class="stringliteral">"-"</span> : <span class="stringliteral">""</span>;
<a name="l00117"></a>00117                         o &lt;&lt;sign &lt;&lt;<span class="stringliteral">"v"</span> &lt;&lt;std::dec &lt;&lt;renamed;
<a name="l00118"></a>00118                         <span class="keywordflow">if</span> (negative) {
<a name="l00119"></a>00119                             o &lt;&lt;<span class="stringliteral">"-0x"</span> &lt;&lt;std::hex &lt;&lt;negative;
<a name="l00120"></a>00120                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a>) {
<a name="l00121"></a>00121                             o &lt;&lt;<span class="stringliteral">"+0x"</span> &lt;&lt;std::hex &lt;&lt;<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a>;
<a name="l00122"></a>00122                         }
<a name="l00123"></a>00123                     } <span class="keywordflow">else</span> {
<a name="l00124"></a>00124                         <span class="comment">/* This is a constant */</span>
<a name="l00125"></a>00125                         ROSE_ASSERT(!<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a>);
<a name="l00126"></a>00126                         o  &lt;&lt;<span class="stringliteral">"0x"</span> &lt;&lt;std::hex &lt;&lt;<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a>;
<a name="l00127"></a>00127                         <span class="keywordflow">if</span> (negative)
<a name="l00128"></a>00128                             o &lt;&lt;<span class="stringliteral">" (-0x"</span> &lt;&lt;std::hex &lt;&lt;negative &lt;&lt;<span class="stringliteral">")"</span>;
<a name="l00129"></a>00129                     }
<a name="l00130"></a>00130                 }
<a name="l00131"></a><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#0ec47e2c0962905fdc8edc7ec3d9ba16">00131</a>                 <span class="keywordtype">void</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#1850ca47a3d164bef7fdfd110ff421ce">print</a>(std::ostream &amp;o, <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1SEMANTIC__NO__PRINT__HELPER.html">BaseSemantics::SEMANTIC_NO_PRINT_HELPER</a> *unused=NULL)<span class="keyword"> const </span>{
<a name="l00132"></a>00132                     <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#1850ca47a3d164bef7fdfd110ff421ce">print</a>(o, (<a class="code" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics.html#16a0fa410b5f7f2caf704e14194c53d4">RenameMap</a>*)0);
<a name="l00133"></a>00133                 }
<a name="l00134"></a>00134 
<a name="l00135"></a><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#3efb536f43831c501ba45913885a7c06">00135</a>                 <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#3efb536f43831c501ba45913885a7c06">operator==</a>(<span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType</a> &amp;a, <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType</a> &amp;b) {
<a name="l00136"></a>00136                     <span class="keywordflow">return</span> a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>==b.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a> &amp;&amp; (!a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a> || a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a>==b.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a>) &amp;&amp; a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a>==b.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a>;
<a name="l00137"></a>00137                 }
<a name="l00138"></a>00138 
<a name="l00139"></a><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#2607590c9ea6641ce2ce2a8a11604aa4">00139</a>                 <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#2607590c9ea6641ce2ce2a8a11604aa4">operator!=</a>(<span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType</a> &amp;a, <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType</a> &amp;b) {
<a name="l00140"></a>00140                     <span class="keywordflow">return</span> !(a==b);
<a name="l00141"></a>00141                 }
<a name="l00142"></a>00142 
<a name="l00143"></a><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#f3c75085eb653cfcb9345dee6455bed0">00143</a>                 <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#f3c75085eb653cfcb9345dee6455bed0">operator&lt;</a>(<span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType</a> &amp;a, <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType</a> &amp;b) {
<a name="l00144"></a>00144                     <span class="keywordflow">if</span> (a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>&lt;b.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00145"></a>00145                     <span class="keywordflow">if</span> (b.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>&lt;a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00146"></a>00146                     <span class="keywordflow">if</span> (a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a> &amp;&amp; a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a>&lt;b.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a>) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00147"></a>00147                     <span class="keywordflow">if</span> (a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a> &amp;&amp; b.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a>&lt;a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00148"></a>00148                     <span class="keywordflow">return</span> a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a> &lt; b.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a>;
<a name="l00149"></a>00149                 }
<a name="l00150"></a>00150             };
<a name="l00151"></a>00151 
<a name="l00152"></a>00152             <span class="keyword">template</span>&lt;size_t Len&gt;
<a name="l00153"></a><a class="code" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics.html#5bb4bba621e84fb162292fe4b6b29617">00153</a>             std::ostream&amp; operator&lt;&lt;(std::ostream &amp;o, const ValueType&lt;Len&gt; &amp;e) {
<a name="l00154"></a>00154                 e.print(o, (<a class="code" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics.html#16a0fa410b5f7f2caf704e14194c53d4">RenameMap</a>*)0);
<a name="l00155"></a>00155                 <span class="keywordflow">return</span> o;
<a name="l00156"></a>00156             }
<a name="l00157"></a>00157 
<a name="l00160"></a>00160             <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;size_t&gt; <span class="keyword">class </span><a class="code" href="findConstants_8h.html#f264add90703032b91ed8eea9b8b1282">ValueType</a>=<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">VirtualMachineSemantics::ValueType</a>&gt;
<a name="l00161"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html">00161</a>             <span class="keyword">class </span><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html">MemoryCell</a>: <span class="keyword">public</span> BaseSemantics::<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html">MemoryCell</a>&lt;ValueType&gt; {
<a name="l00162"></a>00162             <span class="keyword">public</span>:
<a name="l00163"></a>00163 
<a name="l00165"></a>00165                 <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00166"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html#a729971d26bf7837ec7fc4df37fe6ca6">00166</a>                 <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html#a729971d26bf7837ec7fc4df37fe6ca6">MemoryCell</a>(<span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCell.html#c096609894a800e2c91045ad1c250890">address</a>, <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCell.html#ec2a7cf9871c0db052dc2aa2c8f6df80">data</a>, size_t <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCell.html#d4ed515e55151f862b6364773e3b68f4">nbytes</a>)
<a name="l00167"></a>00167                     : BaseSemantics::<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html">MemoryCell</a>&lt;<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType</a>&gt;(<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCell.html#c096609894a800e2c91045ad1c250890">address</a>, <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCell.html#ec2a7cf9871c0db052dc2aa2c8f6df80">data</a>, nbytes) {}
<a name="l00168"></a>00168 
<a name="l00172"></a>00172                 <span class="keywordtype">bool</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html#db9e70e0a5616a76aa8659d8237a7a18">may_alias</a>(<span class="keyword">const</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html">MemoryCell</a> &amp;other) <span class="keyword">const</span>;
<a name="l00173"></a>00173 
<a name="l00176"></a>00176                 <span class="keywordtype">bool</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html#b5ab7ef26b896b73c38aa3f68a566e96">must_alias</a>(<span class="keyword">const</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html">MemoryCell</a> &amp;other) <span class="keyword">const</span>;
<a name="l00177"></a>00177 
<a name="l00178"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html#ba358f0242e5af9481323b26963f3aa8">00178</a>                 <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html#ba358f0242e5af9481323b26963f3aa8">operator==</a>(<span class="keyword">const</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html">MemoryCell</a> &amp;a, <span class="keyword">const</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html">MemoryCell</a> &amp;b) {
<a name="l00179"></a>00179                     <span class="keywordflow">return</span> (a.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCell.html#bf4afc40f4678bcf78308d0b53407cca">get_address</a>()==b.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCell.html#bf4afc40f4678bcf78308d0b53407cca">get_address</a>() &amp;&amp;
<a name="l00180"></a>00180                             a.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCell.html#b870b2b8669c94dcd6c0cf9d6fed18bf">get_data</a>()==b.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCell.html#b870b2b8669c94dcd6c0cf9d6fed18bf">get_data</a>() &amp;&amp;
<a name="l00181"></a>00181                             a.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCell.html#3f8dee19a2e2435d896c9a5abd7a9772">get_nbytes</a>()==b.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCell.html#3f8dee19a2e2435d896c9a5abd7a9772">get_nbytes</a>() &amp;&amp;
<a name="l00182"></a>00182                             a.get_clobbered()==b.get_clobbered() &amp;&amp;
<a name="l00183"></a>00183                             a.get_written()==b.get_written());
<a name="l00184"></a>00184                 }
<a name="l00185"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html#4e4091231d8abff07af581023aab9b7b">00185</a>                 <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html#4e4091231d8abff07af581023aab9b7b">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html">MemoryCell</a> &amp;a, <span class="keyword">const</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html">MemoryCell</a> &amp;b) {
<a name="l00186"></a>00186                     <span class="keywordflow">return</span> !(a==b);
<a name="l00187"></a>00187                 }
<a name="l00188"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html#aad5ba89efe6914450d8d775005279bf">00188</a>                 <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html#aad5ba89efe6914450d8d775005279bf">operator&lt;</a>(<span class="keyword">const</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html">MemoryCell</a> &amp;a, <span class="keyword">const</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html">MemoryCell</a> &amp;b) {
<a name="l00189"></a>00189                     <span class="keywordflow">return</span> a.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCell.html#bf4afc40f4678bcf78308d0b53407cca">get_address</a>() &lt; b.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCell.html#bf4afc40f4678bcf78308d0b53407cca">get_address</a>();
<a name="l00190"></a>00190                 }
<a name="l00191"></a>00191             };
<a name="l00192"></a>00192 
<a name="l00194"></a>00194             <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;size_t&gt; <span class="keyword">class </span><a class="code" href="findConstants_8h.html#f264add90703032b91ed8eea9b8b1282">ValueType</a>=<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">VirtualMachineSemantics::ValueType</a>&gt;
<a name="l00195"></a><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">00195</a>             <span class="keyword">struct </span><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State</a>: <span class="keyword">public</span> BaseSemantics::StateX86&lt;MemoryCell, ValueType&gt; {
<a name="l00196"></a><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html#d831d830f401f13ec7f3e418619cff38">00196</a>                 <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html">BaseSemantics::StateX86&lt;MemoryCell, ValueType&gt;::Memory</a> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html#d831d830f401f13ec7f3e418619cff38">Memory</a>;
<a name="l00197"></a>00197 
<a name="l00200"></a>00200                 <span class="keywordtype">void</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html#2d5b56be66a5a23afd80dc0e963f2a43">print_diff_registers</a>(std::ostream &amp;o, <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State</a>&amp;, <a class="code" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics.html#16a0fa410b5f7f2caf704e14194c53d4">RenameMap</a> *rmap=NULL) <span class="keyword">const</span>;
<a name="l00201"></a>00201 
<a name="l00203"></a>00203                 <span class="keywordtype">bool</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html#56fca3c01535560dd35852f0ccdbef2b">equal_registers</a>(<span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State</a>&amp;) <span class="keyword">const</span>;
<a name="l00204"></a>00204 
<a name="l00207"></a>00207                 <span class="keywordtype">void</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html#ba1c75a61b9b637683375ecd1031d24b">discard_popped_memory</a>();
<a name="l00208"></a>00208             };
<a name="l00209"></a>00209 
<a name="l00211"></a>00211             <span class="keyword">template</span>&lt;
<a name="l00212"></a>00212                 <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;size_t&gt; <span class="keyword">class </span><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType</a>&gt; <span class="keyword">class </span><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State</a> = <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">VirtualMachineSemantics::State</a>,
<a name="l00213"></a>00213                 <span class="keyword">template</span> &lt;size_t nBits&gt; <span class="keyword">class </span><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType</a> = <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">VirtualMachineSemantics::ValueType</a>
<a name="l00214"></a>00214                 &gt;
<a name="l00215"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html">00215</a>             <span class="keyword">class </span><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html">Policy</a>: <span class="keyword">public</span> BaseSemantics::<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html">Policy</a> {
<a name="l00216"></a>00216             <span class="keyword">protected</span>:
<a name="l00217"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#46325f2388893181e3250ff7994c97bf">00217</a>                 <a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#46325f2388893181e3250ff7994c97bf">cur_insn</a>;         
<a name="l00218"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5b0f9cdb044e166490bf0cedb2139fd5">00218</a>                 <span class="keyword">mutable</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;</a> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5b0f9cdb044e166490bf0cedb2139fd5">orig_state</a>;
<a name="l00229"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#8c93aefb8905337a0b7c547b05aa843f">00229</a>                 <span class="keyword">mutable</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;</a> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#8c93aefb8905337a0b7c547b05aa843f">cur_state</a>;
<a name="l00235"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5fc5428cfe9ff350f07f30f2c5aafbf1">00235</a>                 <span class="keywordtype">bool</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5fc5428cfe9ff350f07f30f2c5aafbf1">p_discard_popped_memory</a>;       
<a name="l00240"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#605f546a3cf1e290cbf9bed47862c0f8">00240</a>                 size_t <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#605f546a3cf1e290cbf9bed47862c0f8">ninsns</a>;                      
<a name="l00243"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#0f7b715a06cb30c5d910acb2aea531d3">00243</a>                 <a class="code" href="classMemoryMap.html">MemoryMap</a> *<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#0f7b715a06cb30c5d910acb2aea531d3">map</a>;                     
<a name="l00245"></a>00245             <span class="keyword">public</span>:
<a name="l00246"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#43aa439c904293164f55d165117897fe">00246</a>                 <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#43aa439c904293164f55d165117897fe">Policy</a>(): <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#46325f2388893181e3250ff7994c97bf">cur_insn</a>(NULL), <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5fc5428cfe9ff350f07f30f2c5aafbf1">p_discard_popped_memory</a>(false), <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#605f546a3cf1e290cbf9bed47862c0f8">ninsns</a>(0), <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#0f7b715a06cb30c5d910acb2aea531d3">map</a>(NULL) {
<a name="l00247"></a>00247                     <span class="comment">/* So that named values are identical in both; reinitialized by first call to startInstruction(). */</span>
<a name="l00248"></a>00248                     <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1Policy.html#606d5c04dfb5e74cf4413e4eb485a6c7">set_register_dictionary</a>(<a class="code" href="classRegisterDictionary.html#0a761efb234e80639bfdcc27e8695393">RegisterDictionary::dictionary_pentium4</a>());
<a name="l00249"></a>00249                     <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5b0f9cdb044e166490bf0cedb2139fd5">orig_state</a> = <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#8c93aefb8905337a0b7c547b05aa843f">cur_state</a>;
<a name="l00250"></a>00250                 }
<a name="l00251"></a>00251 
<a name="l00254"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#ac8bf68f23db55f1f93f4c6fd84f1683">00254</a>                 <span class="keywordtype">void</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#ac8bf68f23db55f1f93f4c6fd84f1683">set_map</a>(<a class="code" href="classMemoryMap.html">MemoryMap</a> *<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#0f7b715a06cb30c5d910acb2aea531d3">map</a>) {
<a name="l00255"></a>00255                     this-&gt;<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#0f7b715a06cb30c5d910acb2aea531d3">map</a> = <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#0f7b715a06cb30c5d910acb2aea531d3">map</a>;
<a name="l00256"></a>00256                 }
<a name="l00257"></a>00257 
<a name="l00260"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#45e2ffb9486b8952234b8c0c17789d77">00260</a>                 size_t <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#45e2ffb9486b8952234b8c0c17789d77">get_ninsns</a>()<span class="keyword"> const </span>{
<a name="l00261"></a>00261                     <span class="keywordflow">return</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#605f546a3cf1e290cbf9bed47862c0f8">ninsns</a>;
<a name="l00262"></a>00262                 }
<a name="l00263"></a>00263 
<a name="l00266"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#c983c1bca3a802926a4a646c2e7cafec">00266</a>                 <span class="keywordtype">void</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#c983c1bca3a802926a4a646c2e7cafec">set_ninsns</a>(size_t n) {
<a name="l00267"></a>00267                     <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#605f546a3cf1e290cbf9bed47862c0f8">ninsns</a> = n;
<a name="l00268"></a>00268                 }
<a name="l00269"></a>00269 
<a name="l00271"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#49b652ae546e1da89288cfb9e7c0d986">00271</a>                 <a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#49b652ae546e1da89288cfb9e7c0d986">get_insn</a>()<span class="keyword"> const </span>{
<a name="l00272"></a>00272                     <span class="keywordflow">return</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#46325f2388893181e3250ff7994c97bf">cur_insn</a>;
<a name="l00273"></a>00273                 }
<a name="l00274"></a>00274 
<a name="l00277"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#6dc666773b7a39833112a8f39e3dc27f">00277</a>                 <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;</a>&amp; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#6dc666773b7a39833112a8f39e3dc27f">get_state</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#8c93aefb8905337a0b7c547b05aa843f">cur_state</a>; }
<a name="l00278"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#f2fd0cafe9327522b7f762020097c29a">00278</a>                 <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;</a>&amp; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#6dc666773b7a39833112a8f39e3dc27f">get_state</a>() { <span class="keywordflow">return</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#8c93aefb8905337a0b7c547b05aa843f">cur_state</a>; }
<a name="l00283"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#34420a8716653bfdbc00698bdbe4a13a">00283</a>                 <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;</a>&amp; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#34420a8716653bfdbc00698bdbe4a13a">get_orig_state</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5b0f9cdb044e166490bf0cedb2139fd5">orig_state</a>; }
<a name="l00284"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#ab2104e15e629025e8ab99ff65b76d1e">00284</a>                 <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;</a>&amp; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#34420a8716653bfdbc00698bdbe4a13a">get_orig_state</a>() { <span class="keywordflow">return</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5b0f9cdb044e166490bf0cedb2139fd5">orig_state</a>; }
<a name="l00285"></a>00285 
<a name="l00287"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#8730a9c64deb3c06c9c2651f408269a2">00287</a>                 <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a>&amp; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#8730a9c64deb3c06c9c2651f408269a2">get_ip</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#8c93aefb8905337a0b7c547b05aa843f">cur_state</a>.ip; }
<a name="l00288"></a>00288 
<a name="l00290"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#acde26d508c3a0e9f9adfca49055a363">00290</a>                 <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a>&amp; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#acde26d508c3a0e9f9adfca49055a363">get_orig_ip</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5b0f9cdb044e166490bf0cedb2139fd5">orig_state</a>.ip; }
<a name="l00291"></a>00291 
<a name="l00293"></a>00293                 <span class="keyword">typename</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;::Memory</a> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#2d1c1741f7c467c60fb754c0e0363645">memory_for_equality</a>(<span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;</a>&amp;) <span class="keyword">const</span>;
<a name="l00294"></a>00294 
<a name="l00297"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#2d1c1741f7c467c60fb754c0e0363645">00297</a>                 <span class="keyword">typename</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;::Memory</a> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#2d1c1741f7c467c60fb754c0e0363645">memory_for_equality</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#2d1c1741f7c467c60fb754c0e0363645">memory_for_equality</a>(<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#8c93aefb8905337a0b7c547b05aa843f">cur_state</a>); }
<a name="l00298"></a>00298 
<a name="l00302"></a>00302                 <span class="keywordtype">bool</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#7b6c42d5a5503a8531870a1d038bb86b">equal_states</a>(<span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;</a>&amp;) <span class="keyword">const</span>;
<a name="l00303"></a>00303 
<a name="l00306"></a>00306                 <span class="keywordtype">void</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#b98442dbcd64f400131da07cfe0634ea">print</a>(std::ostream&amp;, <a class="code" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics.html#16a0fa410b5f7f2caf704e14194c53d4">RenameMap</a> *rmap=NULL) <span class="keyword">const</span>;
<a name="l00307"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#1231a538298dedf6e6f020aaaf035a40">00307</a>                 <span class="keyword">friend</span> std::ostream&amp; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#1231a538298dedf6e6f020aaaf035a40">operator&lt;&lt;</a>(std::ostream &amp;o, <span class="keyword">const</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html">Policy</a> &amp;p) {
<a name="l00308"></a>00308                     p.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#b98442dbcd64f400131da07cfe0634ea">print</a>(o, NULL);
<a name="l00309"></a>00309                     <span class="keywordflow">return</span> o;
<a name="l00310"></a>00310                 }
<a name="l00311"></a>00311 
<a name="l00314"></a>00314                 <span class="keywordtype">bool</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#ed14ff9f312d57f08453dc7bf2c43a22">on_stack</a>(<span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;value) <span class="keyword">const</span>;
<a name="l00315"></a>00315 
<a name="l00318"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#b1fac3b34459770dba090cc2b34726f8">00318</a>                 <span class="keywordtype">void</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#b1fac3b34459770dba090cc2b34726f8">set_discard_popped_memory</a>(<span class="keywordtype">bool</span> b) {
<a name="l00319"></a>00319                     <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5fc5428cfe9ff350f07f30f2c5aafbf1">p_discard_popped_memory</a> = b;
<a name="l00320"></a>00320                 }
<a name="l00321"></a>00321 
<a name="l00324"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#44836b03e13058555e03cd82c728b772">00324</a>                 <span class="keywordtype">bool</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#44836b03e13058555e03cd82c728b772">get_discard_popped_memory</a>()<span class="keyword"> const </span>{
<a name="l00325"></a>00325                     <span class="keywordflow">return</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5fc5428cfe9ff350f07f30f2c5aafbf1">p_discard_popped_memory</a>;
<a name="l00326"></a>00326                 }
<a name="l00327"></a>00327 
<a name="l00330"></a>00330                 <span class="keywordtype">void</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#2230d867f612d919a780743357964eed">print_diff</a>(std::ostream&amp;, <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;</a>&amp;, <a class="code" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics.html#16a0fa410b5f7f2caf704e14194c53d4">RenameMap</a> *rmap=NULL) <span class="keyword">const </span>;
<a name="l00331"></a>00331 
<a name="l00334"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#70dedc9127b30434ea715ebec8d6f1a3">00334</a>                 <span class="keywordtype">void</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#2230d867f612d919a780743357964eed">print_diff</a>(std::ostream &amp;o, <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;</a> &amp;state, <a class="code" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics.html#16a0fa410b5f7f2caf704e14194c53d4">RenameMap</a> *rmap=NULL)<span class="keyword"> const </span>{
<a name="l00335"></a>00335                     <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#2230d867f612d919a780743357964eed">print_diff</a>(o, <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5b0f9cdb044e166490bf0cedb2139fd5">orig_state</a>, state, rmap);
<a name="l00336"></a>00336                 }
<a name="l00337"></a>00337 
<a name="l00340"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#9f4090875acc42776f51f50962f4ab2d">00340</a>                 <span class="keywordtype">void</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#2230d867f612d919a780743357964eed">print_diff</a>(std::ostream &amp;o, <a class="code" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics.html#16a0fa410b5f7f2caf704e14194c53d4">RenameMap</a> *rmap=NULL)<span class="keyword"> const </span>{
<a name="l00341"></a>00341                     <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#2230d867f612d919a780743357964eed">print_diff</a>(o, <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5b0f9cdb044e166490bf0cedb2139fd5">orig_state</a>, <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#8c93aefb8905337a0b7c547b05aa843f">cur_state</a>, rmap);
<a name="l00342"></a>00342                 }
<a name="l00343"></a>00343 
<a name="l00346"></a>00346                 std::string <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#4032d9f5c18808fa4b581df958b52a58">SHA1</a>() <span class="keyword">const</span>;
<a name="l00347"></a>00347 
<a name="l00352"></a>00352                 <span class="keywordtype">bool</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#4032d9f5c18808fa4b581df958b52a58">SHA1</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *digest) <span class="keyword">const</span>;
<a name="l00353"></a>00353 
<a name="l00355"></a>00355                 <span class="keyword">template</span> &lt;size_t FromLen, size_t ToLen&gt;
<a name="l00356"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#493129c738b6dc0271a2524446555415">00356</a>                 <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;ToLen&gt;</a> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#493129c738b6dc0271a2524446555415">signExtend</a>(<span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;FromLen&gt;</a> &amp;a)<span class="keyword"> const </span>{
<a name="l00357"></a>00357                     <span class="keywordflow">if</span> (ToLen==FromLen) <span class="keywordflow">return</span> a;
<a name="l00358"></a>00358                     <span class="keywordflow">if</span> (a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>) <span class="keywordflow">return</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;ToLen&gt;</a>();
<a name="l00359"></a>00359                     <span class="keywordflow">return</span> IntegerOps::signExtend&lt;FromLen, ToLen&gt;(a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a>);
<a name="l00360"></a>00360                 }
<a name="l00361"></a>00361 
<a name="l00363"></a>00363                 <span class="keyword">template</span> &lt;size_t BeginAt, size_t EndAt, size_t Len&gt;
<a name="l00364"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#00a73edae886cca3e16474a37b5c1f45">00364</a>                 <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType</a>&lt;EndAt-BeginAt&gt; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#00a73edae886cca3e16474a37b5c1f45">extract</a>(<span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;a)<span class="keyword"> const </span>{
<a name="l00365"></a>00365                     <span class="keywordflow">if</span> (0==BeginAt) <span class="keywordflow">return</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType</a>&lt;EndAt-BeginAt&gt;(a);
<a name="l00366"></a>00366                     <span class="keywordflow">if</span> (a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>) <span class="keywordflow">return</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType</a>&lt;EndAt-BeginAt&gt;();
<a name="l00367"></a>00367                     <span class="keywordflow">return</span> (a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a> &gt;&gt; BeginAt) &amp; (<a class="code" href="structIntegerOps_1_1SHL1.html">IntegerOps::SHL1</a>&lt;uint64_t, EndAt-BeginAt&gt;::value - 1);
<a name="l00368"></a>00368                 }
<a name="l00369"></a>00369 
<a name="l00372"></a>00372                 <span class="keyword">template</span> &lt;size_t FromLen, size_t ToLen&gt;
<a name="l00373"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#1ed8f028b97efebf6050794d956d175b">00373</a>                 <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;ToLen&gt;</a> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#1ed8f028b97efebf6050794d956d175b">unsignedExtend</a>(<span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;FromLen&gt;</a> &amp;a)<span class="keyword"> const </span>{
<a name="l00374"></a>00374                     <span class="keywordflow">return</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;ToLen&gt;</a>(a);
<a name="l00375"></a>00375                 }
<a name="l00376"></a>00376 
<a name="l00386"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#cb0f63b47524e905ffc734a4b393f5cf">00386</a>                 <span class="keyword">template</span> &lt;size_t Len&gt; <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#cb0f63b47524e905ffc734a4b393f5cf">mem_read</a>(<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;</a> &amp;state, <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;addr)<span class="keyword"> const </span>{
<a name="l00387"></a>00387                     <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html">MemoryCell&lt;ValueType&gt;</a> new_cell(addr, <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a>(), Len/8);
<a name="l00388"></a>00388                     <span class="keywordtype">bool</span> aliased = <span class="keyword">false</span>; <span class="comment">/*is new_cell aliased by any existing writes?*/</span>
<a name="l00389"></a>00389 
<a name="l00390"></a>00390                     <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;::Memory::iterator</a> mi=state.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html#8d3ae5327b47936c966c801a9ac05014">mem</a>.begin(); mi!=state.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html#8d3ae5327b47936c966c801a9ac05014">mem</a>.end(); ++mi) {
<a name="l00391"></a>00391                         <span class="keywordflow">if</span> (new_cell.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html#b5ab7ef26b896b73c38aa3f68a566e96">must_alias</a>(*mi)) {
<a name="l00392"></a>00392                             <span class="keywordflow">if</span> ((*mi).is_clobbered()) {
<a name="l00393"></a>00393                                 (*mi).set_clobbered(<span class="keyword">false</span>);
<a name="l00394"></a>00394                                 (*mi).set_data(new_cell.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCell.html#b870b2b8669c94dcd6c0cf9d6fed18bf">get_data</a>());
<a name="l00395"></a>00395                                 <span class="keywordflow">return</span> new_cell.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCell.html#b870b2b8669c94dcd6c0cf9d6fed18bf">get_data</a>();
<a name="l00396"></a>00396                             } <span class="keywordflow">else</span> {
<a name="l00397"></a>00397                                 <span class="keywordflow">return</span> (*mi).get_data();
<a name="l00398"></a>00398                             }
<a name="l00399"></a>00399                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (new_cell.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html#db9e70e0a5616a76aa8659d8237a7a18">may_alias</a>(*mi) &amp;&amp; (*mi).is_written()) {
<a name="l00400"></a>00400                             aliased = <span class="keyword">true</span>;
<a name="l00401"></a>00401                         }
<a name="l00402"></a>00402                     }
<a name="l00403"></a>00403 
<a name="l00404"></a>00404                     <span class="keywordflow">if</span> (!aliased &amp;&amp; &amp;state!=&amp;<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5b0f9cdb044e166490bf0cedb2139fd5">orig_state</a>) {
<a name="l00405"></a>00405                         <span class="comment">/* We didn't find the memory cell in the specified state and it's not aliased to any writes in that</span>
<a name="l00406"></a>00406 <span class="comment">                         * state. Therefore use the value from the initial memory state (creating it if necessary). */</span>
<a name="l00407"></a>00407                         <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;::Memory::iterator</a> mi=<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5b0f9cdb044e166490bf0cedb2139fd5">orig_state</a>.mem.begin();
<a name="l00408"></a>00408                              mi!=<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5b0f9cdb044e166490bf0cedb2139fd5">orig_state</a>.mem.end();
<a name="l00409"></a>00409                              ++mi) {
<a name="l00410"></a>00410                             <span class="keywordflow">if</span> (new_cell.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html#b5ab7ef26b896b73c38aa3f68a566e96">must_alias</a>(*mi)) {
<a name="l00411"></a>00411                                 ROSE_ASSERT(!(*mi).is_clobbered());
<a name="l00412"></a>00412                                 ROSE_ASSERT(!(*mi).is_written());
<a name="l00413"></a>00413                                 state.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html#8d3ae5327b47936c966c801a9ac05014">mem</a>.push_back(*mi);
<a name="l00414"></a>00414                                 std::sort(state.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html#8d3ae5327b47936c966c801a9ac05014">mem</a>.begin(), state.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html#8d3ae5327b47936c966c801a9ac05014">mem</a>.end());
<a name="l00415"></a>00415                                 <span class="keywordflow">return</span> (*mi).get_data();
<a name="l00416"></a>00416                             }
<a name="l00417"></a>00417                         }
<a name="l00418"></a>00418 
<a name="l00419"></a>00419                         <span class="comment">/* Not found in initial state. But if we have a known address and a valid memory map then initialize</span>
<a name="l00420"></a>00420 <span class="comment">                         * the original state with data from the memory map. */</span>      
<a name="l00421"></a>00421                         <span class="keywordflow">if</span> (<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#0f7b715a06cb30c5d910acb2aea531d3">map</a> &amp;&amp; addr.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#df41a94ce70e1920ee4c4646625bf6df">is_known</a>()) {
<a name="l00422"></a>00422                             uint8_t buf[<span class="keyword">sizeof</span>(uint64_t)];
<a name="l00423"></a>00423                             ROSE_ASSERT(Len/8 &lt; <span class="keyword">sizeof</span> buf);
<a name="l00424"></a>00424                             size_t nread = <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#0f7b715a06cb30c5d910acb2aea531d3">map</a>-&gt;<a class="code" href="classMemoryMap.html#6f970a3185c7d4a5b21dd21c0479ef9e">read</a>(buf, addr.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#5be6a2613640de8c425a76d03631e643">known_value</a>(), Len/8);
<a name="l00425"></a>00425                             <span class="keywordflow">if</span> (nread==Len/8) {
<a name="l00426"></a>00426                                 uint64_t n = 0;
<a name="l00427"></a>00427                                 <span class="keywordflow">for</span> (size_t i=0; i&lt;Len/8; i++)
<a name="l00428"></a>00428                                     n |= buf[i] &lt;&lt; (8*i);
<a name="l00429"></a>00429                                 new_cell.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCell.html#5977745c13502f9b5e7ff7c675d826eb">set_data</a>(number&lt;32&gt;(n));
<a name="l00430"></a>00430                             }
<a name="l00431"></a>00431                         }
<a name="l00432"></a>00432 
<a name="l00433"></a>00433                         <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5b0f9cdb044e166490bf0cedb2139fd5">orig_state</a>.mem.push_back(new_cell);
<a name="l00434"></a>00434                         std::sort(<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5b0f9cdb044e166490bf0cedb2139fd5">orig_state</a>.mem.begin(), <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5b0f9cdb044e166490bf0cedb2139fd5">orig_state</a>.mem.end());
<a name="l00435"></a>00435                     }
<a name="l00436"></a>00436 
<a name="l00437"></a>00437                     <span class="comment">/* Create the cell in the current state. */</span>
<a name="l00438"></a>00438                     state.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html#8d3ae5327b47936c966c801a9ac05014">mem</a>.push_back(new_cell);
<a name="l00439"></a>00439                     std::sort(state.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html#8d3ae5327b47936c966c801a9ac05014">mem</a>.begin(), state.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html#8d3ae5327b47936c966c801a9ac05014">mem</a>.end());
<a name="l00440"></a>00440                     <span class="keywordflow">return</span> new_cell.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCell.html#b870b2b8669c94dcd6c0cf9d6fed18bf">get_data</a>();
<a name="l00441"></a>00441                 }
<a name="l00442"></a>00442 
<a name="l00444"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#e8be7d11d634281d33458309f16f24a2">00444</a>                 <span class="keyword">enum</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#e8be7d11d634281d33458309f16f24a2">MemRefType</a> { <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#e8be7d11d634281d33458309f16f24a2393fced5f39169c0ef5408b7b8498a14">MRT_STACK_PTR</a>, <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#e8be7d11d634281d33458309f16f24a20761dc0f1e7ab3d014b7e60b27cc236a">MRT_FRAME_PTR</a>, <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#e8be7d11d634281d33458309f16f24a26e874ba1acfb3a7c73c4ca8991bb5fef">MRT_OTHER_PTR</a> };
<a name="l00445"></a>00445 
<a name="l00450"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#68dbc14a75b58e85a8e2b5f03d3c42f6">00450</a>                 <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#e8be7d11d634281d33458309f16f24a2">MemRefType</a> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#68dbc14a75b58e85a8e2b5f03d3c42f6">memory_reference_type</a>(<span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;</a> &amp;state, <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;addr)<span class="keyword"> const </span>{
<a name="l00451"></a>00451                     <span class="keywordflow">if</span> (addr.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>) {
<a name="l00452"></a>00452                         <span class="keywordflow">if</span> (addr.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>==state.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html#23d70e82eade1842742d0fc114c9c8c3">gpr</a>[<a class="code" href="InstructionEnumsX86_8h.html#cc245284d886f9c6728df7922b3d1f114be93f17b2c8645908e8efc27567ec3e">x86_gpr_sp</a>].name) <span class="keywordflow">return</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#e8be7d11d634281d33458309f16f24a2393fced5f39169c0ef5408b7b8498a14">MRT_STACK_PTR</a>;
<a name="l00453"></a>00453                         <span class="keywordflow">if</span> (addr.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>==state.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html#23d70e82eade1842742d0fc114c9c8c3">gpr</a>[<a class="code" href="InstructionEnumsX86_8h.html#cc245284d886f9c6728df7922b3d1f113b18343ebdd8ab7389189f5f376418e7">x86_gpr_bp</a>].name) <span class="keywordflow">return</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#e8be7d11d634281d33458309f16f24a20761dc0f1e7ab3d014b7e60b27cc236a">MRT_FRAME_PTR</a>;
<a name="l00454"></a>00454                         <span class="keywordflow">return</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#e8be7d11d634281d33458309f16f24a26e874ba1acfb3a7c73c4ca8991bb5fef">MRT_OTHER_PTR</a>;
<a name="l00455"></a>00455                     }
<a name="l00456"></a>00456                     <span class="keywordflow">if</span> (addr==state.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html#23d70e82eade1842742d0fc114c9c8c3">gpr</a>[<a class="code" href="InstructionEnumsX86_8h.html#cc245284d886f9c6728df7922b3d1f114be93f17b2c8645908e8efc27567ec3e">x86_gpr_sp</a>]) <span class="keywordflow">return</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#e8be7d11d634281d33458309f16f24a2393fced5f39169c0ef5408b7b8498a14">MRT_STACK_PTR</a>;
<a name="l00457"></a>00457                     <span class="keywordflow">if</span> (addr==state.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html#23d70e82eade1842742d0fc114c9c8c3">gpr</a>[<a class="code" href="InstructionEnumsX86_8h.html#cc245284d886f9c6728df7922b3d1f113b18343ebdd8ab7389189f5f376418e7">x86_gpr_bp</a>]) <span class="keywordflow">return</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#e8be7d11d634281d33458309f16f24a20761dc0f1e7ab3d014b7e60b27cc236a">MRT_FRAME_PTR</a>;
<a name="l00458"></a>00458                     <span class="keywordflow">return</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#e8be7d11d634281d33458309f16f24a26e874ba1acfb3a7c73c4ca8991bb5fef">MRT_OTHER_PTR</a>;
<a name="l00459"></a>00459                 }
<a name="l00460"></a>00460 
<a name="l00464"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#d4e727d5754eebd12847c0eb2aad5f4e">00464</a>                 <span class="keyword">template</span> &lt;size_t Len&gt; <span class="keywordtype">void</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#d4e727d5754eebd12847c0eb2aad5f4e">mem_write</a>(<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;</a> &amp;state, <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;addr,
<a name="l00465"></a>00465                                                      <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;data) {
<a name="l00466"></a>00466                     ROSE_ASSERT(&amp;state!=&amp;<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5b0f9cdb044e166490bf0cedb2139fd5">orig_state</a>);
<a name="l00467"></a>00467                     <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html">MemoryCell&lt;ValueType&gt;</a> new_cell(addr, data, Len/8);
<a name="l00468"></a>00468                     new_cell.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCell.html#a0470768f28c06456974fc46e3f5716f">set_written</a>();
<a name="l00469"></a>00469                     <span class="keywordtype">bool</span> saved = <span class="keyword">false</span>; <span class="comment">/* has new_cell been saved into memory? */</span>
<a name="l00470"></a>00470 
<a name="l00471"></a>00471                     <span class="comment">/* Is new memory reference through the stack pointer or frame pointer? */</span>
<a name="l00472"></a>00472                     <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#e8be7d11d634281d33458309f16f24a2">MemRefType</a> new_mrt = <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#68dbc14a75b58e85a8e2b5f03d3c42f6">memory_reference_type</a>(state, addr);
<a name="l00473"></a>00473 
<a name="l00474"></a>00474                     <span class="comment">/* Overwrite and/or clobber existing memory locations. */</span>
<a name="l00475"></a>00475                     <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;::Memory::iterator</a> mi=state.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html#8d3ae5327b47936c966c801a9ac05014">mem</a>.begin(); mi!=state.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html#8d3ae5327b47936c966c801a9ac05014">mem</a>.end(); ++mi) {
<a name="l00476"></a>00476                         <span class="keywordflow">if</span> (new_cell.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html#b5ab7ef26b896b73c38aa3f68a566e96">must_alias</a>(*mi)) {
<a name="l00477"></a>00477                             *mi = new_cell;
<a name="l00478"></a>00478                             saved = <span class="keyword">true</span>;
<a name="l00479"></a>00479                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5fc5428cfe9ff350f07f30f2c5aafbf1">p_discard_popped_memory</a> &amp;&amp; new_mrt!=<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#68dbc14a75b58e85a8e2b5f03d3c42f6">memory_reference_type</a>(state, (*mi).get_address())) {
<a name="l00480"></a>00480                             <span class="comment">/* Assume that memory referenced through the stack pointer does not alias that which is referenced</span>
<a name="l00481"></a>00481 <span class="comment">                             * through the frame pointer, and neither of them alias memory that is referenced other ways. */</span>
<a name="l00482"></a>00482                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (new_cell.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html#db9e70e0a5616a76aa8659d8237a7a18">may_alias</a>(*mi)) {
<a name="l00483"></a>00483                             (*mi).<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCell.html#2553ec27843b46085ae2287b2650fbce">set_clobbered</a>();
<a name="l00484"></a>00484                         } <span class="keywordflow">else</span> {
<a name="l00485"></a>00485                             <span class="comment">/* memory cell *mi is not aliased to cell being written */</span>
<a name="l00486"></a>00486                         }
<a name="l00487"></a>00487                     }
<a name="l00488"></a>00488                     <span class="keywordflow">if</span> (!saved) {
<a name="l00489"></a>00489                         state.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html#8d3ae5327b47936c966c801a9ac05014">mem</a>.push_back(new_cell);
<a name="l00490"></a>00490                         std::sort(state.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html#8d3ae5327b47936c966c801a9ac05014">mem</a>.begin(), state.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html#8d3ae5327b47936c966c801a9ac05014">mem</a>.end());
<a name="l00491"></a>00491                     }
<a name="l00492"></a>00492                 }
<a name="l00493"></a>00493 
<a name="l00494"></a>00494                 <span class="comment">/*************************************************************************************************************</span>
<a name="l00495"></a>00495 <span class="comment">                 * Functions invoked by the X86InstructionSemantics class for every processed instruction or block</span>
<a name="l00496"></a>00496 <span class="comment">                 *************************************************************************************************************/</span>
<a name="l00497"></a>00497 
<a name="l00499"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#25ed1a190fa5d8fcefbf480fbbb3b6ce">00499</a>                 <span class="keywordtype">void</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#25ed1a190fa5d8fcefbf480fbbb3b6ce">startInstruction</a>(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn) {
<a name="l00500"></a>00500                     <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#8c93aefb8905337a0b7c547b05aa843f">cur_state</a>.ip = <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a>(insn-&gt;<a class="code" href="classSgAsmStatement.html#c9fec81ac91c3bd3e1dbd3854bc0a07d">get_address</a>());
<a name="l00501"></a>00501                     <span class="keywordflow">if</span> (0==<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#605f546a3cf1e290cbf9bed47862c0f8">ninsns</a>++)
<a name="l00502"></a>00502                         <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5b0f9cdb044e166490bf0cedb2139fd5">orig_state</a> = <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#8c93aefb8905337a0b7c547b05aa843f">cur_state</a>;
<a name="l00503"></a>00503                     <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#46325f2388893181e3250ff7994c97bf">cur_insn</a> = insn;
<a name="l00504"></a>00504                 }
<a name="l00505"></a>00505 
<a name="l00507"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#eda7987dd6e97ce507cc40a5884103e3">00507</a>                 <span class="keywordtype">void</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#eda7987dd6e97ce507cc40a5884103e3">finishInstruction</a>(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a>*) {
<a name="l00508"></a>00508                     <span class="keywordflow">if</span> (<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5fc5428cfe9ff350f07f30f2c5aafbf1">p_discard_popped_memory</a>)
<a name="l00509"></a>00509                         <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#8c93aefb8905337a0b7c547b05aa843f">cur_state</a>.discard_popped_memory();
<a name="l00510"></a>00510                     <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#46325f2388893181e3250ff7994c97bf">cur_insn</a> = NULL;
<a name="l00511"></a>00511                 }
<a name="l00512"></a>00512 
<a name="l00513"></a>00513                 <span class="comment">/* Called at the beginning of X86InstructionSemantics::processBlock() */</span>
<a name="l00514"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#c9c9f72416b0e46edc3553c642798252">00514</a>                 <span class="keywordtype">void</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#c9c9f72416b0e46edc3553c642798252">startBlock</a>(<a class="code" href="rosedefs_8h.html#283c223e045cae7ac98ac96cf32c85e6">rose_addr_t</a> addr) {}
<a name="l00515"></a>00515 
<a name="l00516"></a>00516                 <span class="comment">/* Called at the end of X86InstructionSemantics::processBlock() */</span>
<a name="l00517"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#f0c7947922bdc51575ed888bbede7a4b">00517</a>                 <span class="keywordtype">void</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#f0c7947922bdc51575ed888bbede7a4b">finishBlock</a>(<a class="code" href="rosedefs_8h.html#283c223e045cae7ac98ac96cf32c85e6">rose_addr_t</a> addr) {}
<a name="l00518"></a>00518 
<a name="l00519"></a>00519                 <span class="comment">/*************************************************************************************************************</span>
<a name="l00520"></a>00520 <span class="comment">                 * Functions invoked by the X86InstructionSemantics class to construct values</span>
<a name="l00521"></a>00521 <span class="comment">                 *************************************************************************************************************/</span>
<a name="l00522"></a>00522 
<a name="l00524"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#e178d9f0fb74b2c95f818fa77e12086d">00524</a>                 <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;1&gt;</a> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#e178d9f0fb74b2c95f818fa77e12086d">true_</a>()<span class="keyword"> const </span>{
<a name="l00525"></a>00525                     <span class="keywordflow">return</span> 1;
<a name="l00526"></a>00526                 }
<a name="l00527"></a>00527 
<a name="l00529"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#d4090f8b30d3343a34d3eb3fe4f69bd0">00529</a>                 <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;1&gt;</a> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#d4090f8b30d3343a34d3eb3fe4f69bd0">false_</a>()<span class="keyword"> const </span>{
<a name="l00530"></a>00530                     <span class="keywordflow">return</span> 0;
<a name="l00531"></a>00531                 }
<a name="l00532"></a>00532 
<a name="l00534"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#58d83bd2940a896f27bb6120ac656ca0">00534</a>                 <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;1&gt;</a> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#58d83bd2940a896f27bb6120ac656ca0">undefined_</a>()<span class="keyword"> const </span>{
<a name="l00535"></a>00535                     <span class="keywordflow">return</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;1&gt;</a>();
<a name="l00536"></a>00536                 }
<a name="l00537"></a>00537 
<a name="l00539"></a>00539                 <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00540"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#a93f9b6e6fbcf1931afb47ee90ebde67">00540</a>                 <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#a93f9b6e6fbcf1931afb47ee90ebde67">number</a>(uint64_t n)<span class="keyword"> const </span>{
<a name="l00541"></a>00541                     <span class="keywordflow">return</span> n;
<a name="l00542"></a>00542                 }
<a name="l00543"></a>00543 
<a name="l00544"></a>00544 
<a name="l00545"></a>00545 
<a name="l00546"></a>00546                 <span class="comment">/*************************************************************************************************************</span>
<a name="l00547"></a>00547 <span class="comment">                 * Functions invoked by the X86InstructionSemantics class for individual instructions</span>
<a name="l00548"></a>00548 <span class="comment">                 *************************************************************************************************************/</span>
<a name="l00549"></a>00549 
<a name="l00551"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#3807486a5144aa4153456df44c7feeb4">00551</a>                 <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#3807486a5144aa4153456df44c7feeb4">filterCallTarget</a>(<span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;a)<span class="keyword"> const </span>{
<a name="l00552"></a>00552                     <span class="keywordflow">return</span> a;
<a name="l00553"></a>00553                 }
<a name="l00554"></a>00554 
<a name="l00556"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#b2d703449b493e160222153dd87ca480">00556</a>                 <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#b2d703449b493e160222153dd87ca480">filterReturnTarget</a>(<span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;a)<span class="keyword"> const </span>{
<a name="l00557"></a>00557                     <span class="keywordflow">return</span> a;
<a name="l00558"></a>00558                 }
<a name="l00559"></a>00559 
<a name="l00561"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#563497e9c4eedf030fc494639f41234a">00561</a>                 <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#563497e9c4eedf030fc494639f41234a">filterIndirectJumpTarget</a>(<span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;a)<span class="keyword"> const </span>{
<a name="l00562"></a>00562                     <span class="keywordflow">return</span> a;
<a name="l00563"></a>00563                 }
<a name="l00564"></a>00564 
<a name="l00566"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#77026c306efcc733994cf8f7b818ce73">00566</a>                 <span class="keywordtype">void</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#77026c306efcc733994cf8f7b818ce73">hlt</a>() {} <span class="comment">// FIXME</span>
<a name="l00567"></a>00567 
<a name="l00569"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#54430702ec2c95c6ce196a79712634f5">00569</a>                 <span class="keywordtype">void</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#54430702ec2c95c6ce196a79712634f5">cpuid</a>() {} <span class="comment">// FIXME</span>
<a name="l00570"></a>00570 
<a name="l00572"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#ee980fc82f28e8b6e848c01c10cf9a58">00572</a>                 <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;64&gt;</a> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#ee980fc82f28e8b6e848c01c10cf9a58">rdtsc</a>() {
<a name="l00573"></a>00573                     <span class="keywordflow">return</span> 0;
<a name="l00574"></a>00574                 }
<a name="l00575"></a>00575 
<a name="l00577"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#4d5c781a73202869249c9dcf1de9af91">00577</a>                 <span class="keywordtype">void</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#4d5c781a73202869249c9dcf1de9af91">interrupt</a>(uint8_t num) {
<a name="l00578"></a>00578                     <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#8c93aefb8905337a0b7c547b05aa843f">cur_state</a> = <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;</a>(); <span class="comment">/*reset entire machine state*/</span>
<a name="l00579"></a>00579                 }
<a name="l00580"></a>00580 
<a name="l00582"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#ee0defdf2d37f95785f8c48a83292407">00582</a>                 <span class="keywordtype">void</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#ee0defdf2d37f95785f8c48a83292407">sysenter</a>() {
<a name="l00583"></a>00583                     <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#8c93aefb8905337a0b7c547b05aa843f">cur_state</a> = <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;</a>(); <span class="comment">/*reset entire machine state*/</span>
<a name="l00584"></a>00584                 }
<a name="l00585"></a>00585 
<a name="l00586"></a>00586 
<a name="l00587"></a>00587 
<a name="l00588"></a>00588                 <span class="comment">/*************************************************************************************************************</span>
<a name="l00589"></a>00589 <span class="comment">                 * Functions invoked by the X86InstructionSemantics class for data access operations</span>
<a name="l00590"></a>00590 <span class="comment">                 *************************************************************************************************************/</span>
<a name="l00591"></a>00591 
<a name="l00592"></a>00592 <span class="preprocessor">#include "<a class="code" href="ReadWriteRegisterFragment_8h.html">ReadWriteRegisterFragment.h</a>"</span>
<a name="l00593"></a>00593 
<a name="l00595"></a>00595                 <span class="keyword">template</span> &lt;size_t Len&gt; <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>
<a name="l00596"></a>00596                 <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#0bc39b24adbf9a90bcf2b96b6f233098">readMemory</a>(<a class="code" href="InstructionEnumsX86_8h.html#96942c0566d4aa5f4e881d8e77a299a5">X86SegmentRegister</a> segreg, <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;addr, <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;1&gt;</a> &amp;cond)<span class="keyword"> const </span>{
<a name="l00597"></a>00597                     <span class="keywordflow">return</span> mem_read&lt;Len&gt;(<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#8c93aefb8905337a0b7c547b05aa843f">cur_state</a>, addr);
<a name="l00598"></a>00598                 }
<a name="l00599"></a>00599 
<a name="l00601"></a>00601                 <span class="keyword">template</span> &lt;size_t Len&gt; <span class="keywordtype">void</span>
<a name="l00602"></a>00602                 <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#a6994f0267559e860ff3156c2bfe02d4">writeMemory</a>(<a class="code" href="InstructionEnumsX86_8h.html#96942c0566d4aa5f4e881d8e77a299a5">X86SegmentRegister</a> segreg, <span class="keyword">const</span> ValueType&lt;32&gt; &amp;addr, <span class="keyword">const</span> ValueType&lt;Len&gt; &amp;data,
<a name="l00603"></a>00603                             <span class="keyword">const</span> ValueType&lt;1&gt; &amp;cond) {
<a name="l00604"></a>00604                     mem_write&lt;Len&gt;(<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#8c93aefb8905337a0b7c547b05aa843f">cur_state</a>, addr, data);
<a name="l00605"></a>00605                 }
<a name="l00606"></a>00606 
<a name="l00607"></a>00607 
<a name="l00608"></a>00608 
<a name="l00609"></a>00609                 <span class="comment">/*************************************************************************************************************</span>
<a name="l00610"></a>00610 <span class="comment">                 * Functions invoked by the X86InstructionSemantics class for arithmetic operations</span>
<a name="l00611"></a>00611 <span class="comment">                 *************************************************************************************************************/</span>
<a name="l00612"></a>00612 
<a name="l00614"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#b3c28ea2fb0cba59f29e3ff5f079eb24">00614</a>                 <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00615"></a>00615                 <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#ef6a8331eea43a03322aa25efb2cca9f">add</a>(<span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;a, <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;b)<span class="keyword"> const </span>{
<a name="l00616"></a>00616                     <span class="keywordflow">if</span> (a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>==b.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a> &amp;&amp; (!a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a> || a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a>!=b.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a>)) {
<a name="l00617"></a>00617                         <span class="comment">/* [V1+x] + [-V1+y] = [x+y]  or</span>
<a name="l00618"></a>00618 <span class="comment">                         * [x] + [y] = [x+y] */</span>
<a name="l00619"></a>00619                         <span class="keywordflow">return</span> a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a> + b.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a>;
<a name="l00620"></a>00620                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a> || !b.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>) {
<a name="l00621"></a>00621                         <span class="comment">/* [V1+x] + [y] = [V1+x+y]   or</span>
<a name="l00622"></a>00622 <span class="comment">                         * [x] + [V2+y] = [V2+x+y]   or</span>
<a name="l00623"></a>00623 <span class="comment">                         * [-V1+x] + [y] = [-V1+x+y] or</span>
<a name="l00624"></a>00624 <span class="comment">                         * [x] + [-V2+y] = [-V2+x+y] */</span>
<a name="l00625"></a>00625                         <span class="keywordflow">return</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>+b.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>, a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a>+b.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a>, a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a> || b.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a>);
<a name="l00626"></a>00626                     } <span class="keywordflow">else</span> {
<a name="l00627"></a>00627                         <span class="keywordflow">return</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>();
<a name="l00628"></a>00628                     }
<a name="l00629"></a>00629                 }
<a name="l00630"></a>00630 
<a name="l00632"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5f3d59e47112f901952dc6cf5a965558">00632</a>                 <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00633"></a>00633                 <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#52995402153ecea20c05621ce2e4cb45">addWithCarries</a>(<span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;a, <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;b, <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;1&gt;</a> &amp;c,
<a name="l00634"></a>00634                                               <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a> &amp;carry_out)<span class="keyword"> const </span>{
<a name="l00635"></a>00635                     <span class="keywordtype">int</span> n_unknown = (a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>?1:0) + (b.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>?1:0) + (c.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>?1:0);
<a name="l00636"></a>00636                     <span class="keywordflow">if</span> (n_unknown &lt;= 1) {
<a name="l00637"></a>00637                         <span class="comment">/* At most, one of the operands is an unknown value. See add() for more details. */</span>
<a name="l00638"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#caa917c9693435829db6138b928e380a">00638</a>                         uint64_t sum = a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a> + b.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a> + c.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a>;
<a name="l00639"></a>00639                         carry_out = 0==n_unknown ? <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>((a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a> ^ b.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a> ^ sum)&gt;&gt;1) : <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType</a>&lt;Len&gt;();
<a name="l00640"></a>00640                         <span class="keywordflow">return</span> ValueType&lt;Len&gt;(a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>+b.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>+c.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>, sum, a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a>||b.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a>||c.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a>);
<a name="l00641"></a>00641                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>==b.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a> &amp;&amp; !c.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a> &amp;&amp; a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a>!=b.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a>) {
<a name="l00642"></a>00642                         <span class="comment">/* A and B are known or have bases that cancel out, and C is known */</span>
<a name="l00643"></a>00643                         uint64_t sum = a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a> + b.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a> + c.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a>;
<a name="l00644"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#cbcfde31384a0188c74b38c5ec5cf6cd">00644</a>                         carry_out = <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>((a.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a> ^ b.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a> ^ sum)&gt;&gt;1);
<a name="l00645"></a>00645                         <span class="keywordflow">return</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>(sum);
<a name="l00646"></a>00646                     } <span class="keywordflow">else</span> {
<a name="l00647"></a>00647                         carry_out = <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>();
<a name="l00648"></a>00648                         <span class="keywordflow">return</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>();
<a name="l00649"></a>00649                     }
<a name="l00650"></a>00650                 }
<a name="l00651"></a>00651 
<a name="l00653"></a>00653                 <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00654"></a>00654                 ValueType&lt;Len&gt; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#e0e92ef3c32f24eade47b462b286835f">and_</a>(<span class="keyword">const</span> ValueType&lt;Len&gt; &amp;a, <span class="keyword">const</span> ValueType&lt;Len&gt; &amp;b)<span class="keyword"> const </span>{
<a name="l00655"></a>00655                     <span class="keywordflow">if</span> ((!a.name &amp;&amp; 0==a.offset) || (!b.name &amp;&amp; 0==b.offset)) <span class="keywordflow">return</span> 0;
<a name="l00656"></a>00656                     <span class="keywordflow">if</span> (a.name || b.name) <span class="keywordflow">return</span> ValueType&lt;Len&gt;();
<a name="l00657"></a>00657                     <span class="keywordflow">return</span> a.offset &amp; b.offset;
<a name="l00658"></a>00658                 }
<a name="l00659"></a>00659 
<a name="l00661"></a>00661                 <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00662"></a>00662                 ValueType&lt;1&gt; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#68da0c40a7fe342a439b16ee24763aa1">equalToZero</a>(<span class="keyword">const</span> ValueType&lt;Len&gt; &amp;a)<span class="keyword"> const </span>{
<a name="l00663"></a>00663                     <span class="keywordflow">if</span> (a.name) <span class="keywordflow">return</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#58d83bd2940a896f27bb6120ac656ca0">undefined_</a>();
<a name="l00664"></a>00664                     <span class="keywordflow">return</span> a.offset ? <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#d4090f8b30d3343a34d3eb3fe4f69bd0">false_</a>() : <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#e178d9f0fb74b2c95f818fa77e12086d">true_</a>();
<a name="l00665"></a>00665                 }
<a name="l00666"></a>00666 
<a name="l00668"></a>00668                 <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00669"></a>00669                 ValueType&lt;Len&gt; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#b079477bf4164c9b6659f662332403de">invert</a>(<span class="keyword">const</span> ValueType&lt;Len&gt; &amp;a)<span class="keyword"> const </span>{
<a name="l00670"></a>00670                     <span class="keywordflow">if</span> (a.name) <span class="keywordflow">return</span> ValueType&lt;Len&gt;(a.name, ~a.offset, !a.negate);
<a name="l00671"></a>00671                     <span class="keywordflow">return</span> ~a.offset;
<a name="l00672"></a>00672                 }
<a name="l00673"></a>00673 
<a name="l00675"></a>00675                 <span class="keyword">template</span>&lt;size_t Len1, size_t Len2&gt;
<a name="l00676"></a>00676                 ValueType&lt;Len1+Len2&gt; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#48c1bcfc29d50abf11f9e9aacc21f9fc">concat</a>(<span class="keyword">const</span> ValueType&lt;Len1&gt; &amp;a, <span class="keyword">const</span> ValueType&lt;Len2&gt; &amp;b)<span class="keyword"> const </span>{
<a name="l00677"></a>00677                     <span class="keywordflow">if</span> (a.name || b.name) <span class="keywordflow">return</span> ValueType&lt;Len1+Len2&gt;();
<a name="l00678"></a>00678                     <span class="keywordflow">return</span> a.offset | (b.offset &lt;&lt; Len1);
<a name="l00679"></a>00679                 }
<a name="l00680"></a>00680 
<a name="l00682"></a>00682                 <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00683"></a>00683                 ValueType&lt;Len&gt; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#2d450b62112ae4a3ee3f18b362ebaa91">ite</a>(<span class="keyword">const</span> ValueType&lt;1&gt; &amp;sel, <span class="keyword">const</span> ValueType&lt;Len&gt; &amp;ifTrue, <span class="keyword">const</span> ValueType&lt;Len&gt; &amp;ifFalse)<span class="keyword"> const </span>{
<a name="l00684"></a>00684                     <span class="keywordflow">if</span> (ifTrue==ifFalse) <span class="keywordflow">return</span> ifTrue;
<a name="l00685"></a>00685                     <span class="keywordflow">if</span> (sel.name) <span class="keywordflow">return</span> ValueType&lt;Len&gt;();
<a name="l00686"></a>00686                     <span class="keywordflow">return</span> sel.offset ? ifTrue : ifFalse;
<a name="l00687"></a>00687                 }
<a name="l00688"></a>00688 
<a name="l00690"></a>00690                 <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00691"></a>00691                 ValueType&lt;Len&gt; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#725dc4f78ddf1d035aacb2512227c267">leastSignificantSetBit</a>(<span class="keyword">const</span> ValueType&lt;Len&gt; &amp;a)<span class="keyword"> const </span>{
<a name="l00692"></a>00692                     <span class="keywordflow">if</span> (a.name) <span class="keywordflow">return</span> ValueType&lt;Len&gt;();
<a name="l00693"></a>00693                     <span class="keywordflow">for</span> (size_t i=0; i&lt;Len; ++i) {
<a name="l00694"></a>00694                         <span class="keywordflow">if</span> (a.offset &amp; ((uint64_t)1 &lt;&lt; i))
<a name="l00695"></a>00695                             <span class="keywordflow">return</span> i;
<a name="l00696"></a>00696                     }
<a name="l00697"></a>00697                     <span class="keywordflow">return</span> 0;
<a name="l00698"></a>00698                 }
<a name="l00699"></a>00699 
<a name="l00701"></a>00701                 <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00702"></a>00702                 ValueType&lt;Len&gt; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#f8d7e1596dac098b39ec2180c493399e">mostSignificantSetBit</a>(<span class="keyword">const</span> ValueType&lt;Len&gt; &amp;a)<span class="keyword"> const </span>{
<a name="l00703"></a>00703                     <span class="keywordflow">if</span> (a.name) <span class="keywordflow">return</span> ValueType&lt;Len&gt;();
<a name="l00704"></a>00704                     <span class="keywordflow">for</span> (size_t i=Len; i&gt;0; --i) {
<a name="l00705"></a>00705                         <span class="keywordflow">if</span> (a.offset &amp; ((uint64_t)1 &lt;&lt; (i-1)))
<a name="l00706"></a>00706                             <span class="keywordflow">return</span> i-1;
<a name="l00707"></a>00707                     }
<a name="l00708"></a>00708                     <span class="keywordflow">return</span> 0;
<a name="l00709"></a>00709                 }
<a name="l00710"></a>00710 
<a name="l00712"></a>00712                 <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00713"></a>00713                 ValueType&lt;Len&gt; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#411e83b546bf4bd1644a1fa7443239ea">negate</a>(<span class="keyword">const</span> ValueType&lt;Len&gt; &amp;a)<span class="keyword"> const </span>{
<a name="l00714"></a>00714                     <span class="keywordflow">if</span> (a.name) <span class="keywordflow">return</span> ValueType&lt;Len&gt;(a.name, -a.offset, !a.negate);
<a name="l00715"></a>00715                     <span class="keywordflow">return</span> -a.offset;
<a name="l00716"></a>00716                 }
<a name="l00717"></a>00717 
<a name="l00719"></a>00719                 <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00720"></a>00720                 ValueType&lt;Len&gt; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#793e80d4e27c8b47f059928409a92c45">or_</a>(<span class="keyword">const</span> ValueType&lt;Len&gt; &amp;a, <span class="keyword">const</span> ValueType&lt;Len&gt; &amp;b)<span class="keyword"> const </span>{
<a name="l00721"></a>00721                     <span class="keywordflow">if</span> (a==b) <span class="keywordflow">return</span> a;
<a name="l00722"></a>00722                     <span class="keywordflow">if</span> (!a.name &amp;&amp; !b.name) <span class="keywordflow">return</span> a.offset | b.offset;
<a name="l00723"></a>00723                     <span class="keywordflow">if</span> (!a.name &amp;&amp; a.offset==<a class="code" href="structIntegerOps_1_1GenMask.html">IntegerOps::GenMask&lt;uint64_t, Len&gt;::value</a>) <span class="keywordflow">return</span> a;
<a name="l00724"></a>00724                     <span class="keywordflow">if</span> (!b.name &amp;&amp; b.offset==<a class="code" href="structIntegerOps_1_1GenMask.html">IntegerOps::GenMask&lt;uint64_t, Len&gt;::value</a>) <span class="keywordflow">return</span> b;
<a name="l00725"></a>00725                     <span class="keywordflow">return</span> ValueType&lt;Len&gt;();
<a name="l00726"></a>00726                 }
<a name="l00727"></a>00727 
<a name="l00729"></a>00729                 <span class="keyword">template</span> &lt;size_t Len, size_t SALen&gt;
<a name="l00730"></a>00730                 ValueType&lt;Len&gt; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#48f66c5551c6e804d3d5a4b9ba1f45f8">rotateLeft</a>(<span class="keyword">const</span> ValueType&lt;Len&gt; &amp;a, <span class="keyword">const</span> ValueType&lt;SALen&gt; &amp;sa)<span class="keyword"> const </span>{
<a name="l00731"></a>00731                     <span class="keywordflow">if</span> (!a.name &amp;&amp; !sa.name) <span class="keywordflow">return</span> IntegerOps::rotateLeft&lt;Len&gt;(a.offset, sa.offset);
<a name="l00732"></a>00732                     <span class="keywordflow">if</span> (!sa.name &amp;&amp; 0==sa.offset % Len) <span class="keywordflow">return</span> a;
<a name="l00733"></a>00733                     <span class="keywordflow">return</span> ValueType&lt;Len&gt;();
<a name="l00734"></a>00734                 }
<a name="l00735"></a>00735 
<a name="l00737"></a>00737                 <span class="keyword">template</span> &lt;size_t Len, size_t SALen&gt;
<a name="l00738"></a>00738                 ValueType&lt;Len&gt; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#b1477b0245fbc9e1fee1e977ad094bc2">rotateRight</a>(<span class="keyword">const</span> ValueType&lt;Len&gt; &amp;a, <span class="keyword">const</span> ValueType&lt;SALen&gt; &amp;sa)<span class="keyword"> const </span>{
<a name="l00739"></a>00739                     <span class="keywordflow">if</span> (!a.name &amp;&amp; !sa.name) <span class="keywordflow">return</span> IntegerOps::rotateRight&lt;Len&gt;(a.offset, sa.offset);
<a name="l00740"></a>00740                     <span class="keywordflow">if</span> (!sa.name &amp;&amp; 0==sa.offset % Len) <span class="keywordflow">return</span> a;
<a name="l00741"></a>00741                     <span class="keywordflow">return</span> ValueType&lt;Len&gt;();
<a name="l00742"></a>00742                 }
<a name="l00743"></a>00743 
<a name="l00745"></a>00745                 <span class="keyword">template</span> &lt;size_t Len, size_t SALen&gt;
<a name="l00746"></a>00746                 ValueType&lt;Len&gt; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#117ffb4db6986944b8abe0076a34d321">shiftLeft</a>(<span class="keyword">const</span> ValueType&lt;Len&gt; &amp;a, <span class="keyword">const</span> ValueType&lt;SALen&gt; &amp;sa)<span class="keyword"> const </span>{
<a name="l00747"></a>00747                     <span class="keywordflow">if</span> (!a.name &amp;&amp; !sa.name) <span class="keywordflow">return</span> IntegerOps::shiftLeft&lt;Len&gt;(a.offset, sa.offset);
<a name="l00748"></a>00748                     <span class="keywordflow">if</span> (!sa.name) {
<a name="l00749"></a>00749                         <span class="keywordflow">if</span> (0==sa.offset) <span class="keywordflow">return</span> a;
<a name="l00750"></a>00750                         <span class="keywordflow">if</span> (sa.offset&gt;=Len) <span class="keywordflow">return</span> 0;
<a name="l00751"></a>00751                     }
<a name="l00752"></a>00752                     <span class="keywordflow">return</span> ValueType&lt;Len&gt;();
<a name="l00753"></a>00753                 }
<a name="l00754"></a>00754 
<a name="l00756"></a>00756                 <span class="keyword">template</span> &lt;size_t Len, size_t SALen&gt;
<a name="l00757"></a>00757                 ValueType&lt;Len&gt; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#ae706e08fbd3544603faf230c3ebb6c3">shiftRight</a>(<span class="keyword">const</span> ValueType&lt;Len&gt; &amp;a, <span class="keyword">const</span> ValueType&lt;SALen&gt; &amp;sa)<span class="keyword"> const </span>{
<a name="l00758"></a>00758                     <span class="keywordflow">if</span> (!a.name &amp;&amp; !sa.name) <span class="keywordflow">return</span> IntegerOps::shiftRightLogical&lt;Len&gt;(a.offset, sa.offset);
<a name="l00759"></a>00759                     <span class="keywordflow">if</span> (!sa.name) {
<a name="l00760"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#45c8d1bf7f0ba9da4d21269ed8fd09a1">00760</a>                         <span class="keywordflow">if</span> (0==sa.offset) <span class="keywordflow">return</span> a;
<a name="l00761"></a>00761                         <span class="keywordflow">if</span> (sa.offset&gt;=Len) <span class="keywordflow">return</span> 0;
<a name="l00762"></a>00762                     }
<a name="l00763"></a>00763                     <span class="keywordflow">return</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;Len&gt;</a>();
<a name="l00764"></a>00764                 }
<a name="l00765"></a>00765 
<a name="l00767"></a>00767                 <span class="keyword">template</span> &lt;size_t Len, size_t SALen&gt;
<a name="l00768"></a>00768                 ValueType&lt;Len&gt; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#d38618e5bbaddc8f2c1ced35d729a154">shiftRightArithmetic</a>(<span class="keyword">const</span> ValueType&lt;Len&gt; &amp;a, <span class="keyword">const</span> ValueType&lt;SALen&gt; &amp;sa)<span class="keyword"> const </span>{
<a name="l00769"></a>00769                     <span class="keywordflow">if</span> (!a.name &amp;&amp; !sa.name) <span class="keywordflow">return</span> IntegerOps::shiftRightArithmetic&lt;Len&gt;(a.offset, sa.offset);
<a name="l00770"></a>00770                     <span class="keywordflow">if</span> (!sa.name &amp;&amp; 0==sa.offset) <span class="keywordflow">return</span> a;
<a name="l00771"></a>00771                     <span class="keywordflow">return</span> ValueType&lt;Len&gt;();
<a name="l00772"></a>00772                 }
<a name="l00773"></a>00773 
<a name="l00775"></a>00775                 <span class="keyword">template</span> &lt;size_t Len1, size_t Len2&gt;
<a name="l00776"></a>00776                 ValueType&lt;Len1&gt; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#9a4b2b77c90bf383b05aa6cc1279f395">signedDivide</a>(<span class="keyword">const</span> ValueType&lt;Len1&gt; &amp;a, <span class="keyword">const</span> ValueType&lt;Len2&gt; &amp;b)<span class="keyword"> const </span>{
<a name="l00777"></a>00777                     <span class="keywordflow">if</span> (!b.name) {
<a name="l00778"></a>00778                         <span class="keywordflow">if</span> (0==b.offset) <span class="keywordflow">throw</span> Exception(<span class="stringliteral">"division by zero"</span>);
<a name="l00779"></a>00779                         <span class="keywordflow">if</span> (!a.name)
<a name="l00780"></a>00780                             <span class="keywordflow">return</span> IntegerOps::signExtend&lt;Len1, 64&gt;(a.offset) / IntegerOps::signExtend&lt;Len2, 64&gt;(b.offset);
<a name="l00781"></a>00781                         <span class="keywordflow">if</span> (1==b.offset) <span class="keywordflow">return</span> a;
<a name="l00782"></a>00782                         <span class="keywordflow">if</span> (b.offset==<a class="code" href="structIntegerOps_1_1GenMask.html">IntegerOps::GenMask&lt;uint64_t,Len2&gt;::value</a>) <span class="keywordflow">return</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#411e83b546bf4bd1644a1fa7443239ea">negate</a>(a);
<a name="l00783"></a>00783                         <span class="comment">/*FIXME: also possible to return zero if B is large enough. [RPM 2010-05-18]*/</span>
<a name="l00784"></a>00784                     }
<a name="l00785"></a>00785                     <span class="keywordflow">return</span> ValueType&lt;Len1&gt;();
<a name="l00786"></a>00786                 }
<a name="l00787"></a>00787 
<a name="l00789"></a>00789                 <span class="keyword">template</span> &lt;size_t Len1, size_t Len2&gt;
<a name="l00790"></a>00790                 ValueType&lt;Len2&gt; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#239286b71c48623b011cda1f31679ad4">signedModulo</a>(<span class="keyword">const</span> ValueType&lt;Len1&gt; &amp;a, <span class="keyword">const</span> ValueType&lt;Len2&gt; &amp;b)<span class="keyword"> const </span>{
<a name="l00791"></a>00791                     <span class="keywordflow">if</span> (a.name || b.name) <span class="keywordflow">return</span> ValueType&lt;Len2&gt;();
<a name="l00792"></a>00792                     <span class="keywordflow">if</span> (0==b.offset) <span class="keywordflow">throw</span> Exception(<span class="stringliteral">"division by zero"</span>);
<a name="l00793"></a>00793                     <span class="keywordflow">return</span> IntegerOps::signExtend&lt;Len1, 64&gt;(a.offset) % IntegerOps::signExtend&lt;Len2, 64&gt;(b.offset);
<a name="l00794"></a>00794                     <span class="comment">/* FIXME: More folding possibilities... if 'b' is a power of two then we can return 'a' with the bitsize of</span>
<a name="l00795"></a>00795 <span class="comment">                     * 'b'. */</span>
<a name="l00796"></a>00796                 }
<a name="l00797"></a>00797 
<a name="l00799"></a>00799                 <span class="keyword">template</span> &lt;size_t Len1, size_t Len2&gt;
<a name="l00800"></a>00800                 ValueType&lt;Len1+Len2&gt; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#a1e17c3a577241a7840725bb8ae9a5a9">signedMultiply</a>(<span class="keyword">const</span> ValueType&lt;Len1&gt; &amp;a, <span class="keyword">const</span> ValueType&lt;Len2&gt; &amp;b)<span class="keyword"> const </span>{
<a name="l00801"></a>00801                     <span class="keywordflow">if</span> (!a.name &amp;&amp; !b.name)
<a name="l00802"></a>00802                         <span class="keywordflow">return</span> IntegerOps::signExtend&lt;Len1, 64&gt;(a.offset) * IntegerOps::signExtend&lt;Len2, 64&gt;(b.offset);
<a name="l00803"></a>00803                     <span class="keywordflow">if</span> (!b.name) {
<a name="l00804"></a>00804                         <span class="keywordflow">if</span> (0==b.offset) <span class="keywordflow">return</span> 0;
<a name="l00805"></a>00805                         <span class="keywordflow">if</span> (1==b.offset) <span class="keywordflow">return</span> signExtend&lt;Len1, Len1+Len2&gt;(a);
<a name="l00806"></a>00806                         <span class="keywordflow">if</span> (b.offset==<a class="code" href="structIntegerOps_1_1GenMask.html">IntegerOps::GenMask&lt;uint64_t,Len2&gt;::value</a>) <span class="keywordflow">return</span> signExtend&lt;Len1, Len1+Len2&gt;(<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#411e83b546bf4bd1644a1fa7443239ea">negate</a>(a));
<a name="l00807"></a>00807                     }
<a name="l00808"></a>00808                     <span class="keywordflow">if</span> (!a.name) {
<a name="l00809"></a>00809                         <span class="keywordflow">if</span> (0==a.offset) <span class="keywordflow">return</span> 0;
<a name="l00810"></a>00810                         <span class="keywordflow">if</span> (1==a.offset) <span class="keywordflow">return</span> signExtend&lt;Len2, Len1+Len2&gt;(b);
<a name="l00811"></a>00811                         <span class="keywordflow">if</span> (a.offset==<a class="code" href="structIntegerOps_1_1GenMask.html">IntegerOps::GenMask&lt;uint64_t,Len1&gt;::value</a>) <span class="keywordflow">return</span> signExtend&lt;Len2, Len1+Len2&gt;(<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#411e83b546bf4bd1644a1fa7443239ea">negate</a>(b));
<a name="l00812"></a>00812                     }
<a name="l00813"></a>00813                     <span class="keywordflow">return</span> ValueType&lt;Len1+Len2&gt;();
<a name="l00814"></a>00814                 }
<a name="l00815"></a>00815 
<a name="l00817"></a>00817                 <span class="keyword">template</span> &lt;size_t Len1, size_t Len2&gt;
<a name="l00818"></a>00818                 ValueType&lt;Len1&gt; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5cb2dea2c227a1f4d1d9ee00e7cbb635">unsignedDivide</a>(<span class="keyword">const</span> ValueType&lt;Len1&gt; &amp;a, <span class="keyword">const</span> ValueType&lt;Len2&gt; &amp;b)<span class="keyword"> const </span>{
<a name="l00819"></a>00819                     <span class="keywordflow">if</span> (!b.name) {
<a name="l00820"></a>00820                         <span class="keywordflow">if</span> (0==b.offset) <span class="keywordflow">throw</span> Exception(<span class="stringliteral">"division by zero"</span>);
<a name="l00821"></a>00821                         <span class="keywordflow">if</span> (!a.name) <span class="keywordflow">return</span> a.offset / b.offset;
<a name="l00822"></a>00822                         <span class="keywordflow">if</span> (1==b.offset) <span class="keywordflow">return</span> a;
<a name="l00823"></a>00823                         <span class="comment">/*FIXME: also possible to return zero if B is large enough. [RPM 2010-05-18]*/</span>
<a name="l00824"></a>00824                     }
<a name="l00825"></a>00825                     <span class="keywordflow">return</span> ValueType&lt;Len1&gt;();
<a name="l00826"></a>00826                 }
<a name="l00827"></a>00827 
<a name="l00829"></a>00829                 <span class="keyword">template</span> &lt;size_t Len1, size_t Len2&gt;
<a name="l00830"></a>00830                 ValueType&lt;Len2&gt; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#315f0b1c4c76013ecccc9d97448ca325">unsignedModulo</a>(<span class="keyword">const</span> ValueType&lt;Len1&gt; &amp;a, <span class="keyword">const</span> ValueType&lt;Len2&gt; &amp;b)<span class="keyword"> const </span>{
<a name="l00831"></a>00831                     <span class="keywordflow">if</span> (!b.name) {
<a name="l00832"></a>00832                         <span class="keywordflow">if</span> (0==b.offset) <span class="keywordflow">throw</span> Exception(<span class="stringliteral">"division by zero"</span>);
<a name="l00833"></a>00833                         <span class="keywordflow">if</span> (!a.name) <span class="keywordflow">return</span> a.offset % b.offset;
<a name="l00834"></a>00834                         <span class="comment">/* FIXME: More folding possibilities... if 'b' is a power of two then we can return 'a' with the</span>
<a name="l00835"></a>00835 <span class="comment">                         * bitsize of 'b'. */</span>
<a name="l00836"></a>00836                     }
<a name="l00837"></a>00837                     <span class="keywordflow">if</span> (unsignedExtend&lt;Len1,64&gt;(a)==unsignedExtend&lt;Len2,64&gt;(b)) <span class="keywordflow">return</span> b;
<a name="l00838"></a>00838                     <span class="keywordflow">return</span> ValueType&lt;Len2&gt;();
<a name="l00839"></a>00839                 }
<a name="l00840"></a>00840 
<a name="l00842"></a>00842                 <span class="keyword">template</span> &lt;size_t Len1, size_t Len2&gt;
<a name="l00843"></a>00843                 ValueType&lt;Len1+Len2&gt; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#412acd4436f33a9d8a73a1c51b5cd226">unsignedMultiply</a>(<span class="keyword">const</span> ValueType&lt;Len1&gt; &amp;a, <span class="keyword">const</span> ValueType&lt;Len2&gt; &amp;b)<span class="keyword"> const </span>{
<a name="l00844"></a>00844                     <span class="keywordflow">if</span> (!a.name &amp;&amp; !b.name)
<a name="l00845"></a>00845                         <span class="keywordflow">return</span> a.offset * b.offset;
<a name="l00846"></a>00846                     <span class="keywordflow">if</span> (!b.name) {
<a name="l00847"></a>00847                         <span class="keywordflow">if</span> (0==b.offset) <span class="keywordflow">return</span> 0;
<a name="l00848"></a>00848                         <span class="keywordflow">if</span> (1==b.offset) <span class="keywordflow">return</span> unsignedExtend&lt;Len1, Len1+Len2&gt;(a);
<a name="l00849"></a>00849                     }
<a name="l00850"></a>00850                     <span class="keywordflow">if</span> (!a.name) {
<a name="l00851"></a>00851                         <span class="keywordflow">if</span> (0==a.offset) <span class="keywordflow">return</span> 0;
<a name="l00852"></a>00852                         <span class="keywordflow">if</span> (1==a.offset) <span class="keywordflow">return</span> unsignedExtend&lt;Len2, Len1+Len2&gt;(b);
<a name="l00853"></a>00853                     }
<a name="l00854"></a>00854                     <span class="keywordflow">return</span> ValueType&lt;Len1+Len2&gt;();
<a name="l00855"></a>00855                 }
<a name="l00856"></a>00856 
<a name="l00858"></a>00858                 <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00859"></a>00859                 ValueType&lt;Len&gt; <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#d91d9c272a3c4d48099452d2596f1f6b">xor_</a>(<span class="keyword">const</span> ValueType&lt;Len&gt; &amp;a, <span class="keyword">const</span> ValueType&lt;Len&gt; &amp;b)<span class="keyword"> const </span>{
<a name="l00860"></a>00860                     <span class="keywordflow">if</span> (!a.name &amp;&amp; !b.name)
<a name="l00861"></a>00861                         <span class="keywordflow">return</span> a.offset ^ b.offset;
<a name="l00862"></a>00862                     <span class="keywordflow">if</span> (a==b)
<a name="l00863"></a>00863                         <span class="keywordflow">return</span> 0;
<a name="l00864"></a>00864                     <span class="keywordflow">if</span> (!b.name) {
<a name="l00865"></a>00865                         <span class="keywordflow">if</span> (0==b.offset) <span class="keywordflow">return</span> a;
<a name="l00866"></a>00866                         <span class="keywordflow">if</span> (b.offset==<a class="code" href="structIntegerOps_1_1GenMask.html">IntegerOps::GenMask&lt;uint64_t, Len&gt;::value</a>) <span class="keywordflow">return</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#b079477bf4164c9b6659f662332403de">invert</a>(a);
<a name="l00867"></a>00867                     }
<a name="l00868"></a>00868                     <span class="keywordflow">if</span> (!a.name) {
<a name="l00869"></a>00869                         <span class="keywordflow">if</span> (0==a.offset) <span class="keywordflow">return</span> b;
<a name="l00870"></a>00870                         <span class="keywordflow">if</span> (a.offset==<a class="code" href="structIntegerOps_1_1GenMask.html">IntegerOps::GenMask&lt;uint64_t, Len&gt;::value</a>) <span class="keywordflow">return</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#b079477bf4164c9b6659f662332403de">invert</a>(b);
<a name="l00871"></a>00871                     }
<a name="l00872"></a>00872                     <span class="keywordflow">return</span> ValueType&lt;Len&gt;();
<a name="l00873"></a>00873                 }
<a name="l00874"></a>00874             };
<a name="l00875"></a>00875 
<a name="l00876"></a>00876             <span class="comment">/*************************************************************************************************************</span>
<a name="l00877"></a>00877 <span class="comment">             *                              ValueType template functions</span>
<a name="l00878"></a>00878 <span class="comment">             *************************************************************************************************************/</span>
<a name="l00879"></a>00879 
<a name="l00880"></a>00880 
<a name="l00881"></a>00881             <span class="keyword">template</span>&lt;size_t Len&gt; ValueType&lt;Len&gt;
<a name="l00882"></a>00882             ValueType&lt;Len&gt;::rename(<a class="code" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics.html#16a0fa410b5f7f2caf704e14194c53d4">RenameMap</a> *rmap)<span class="keyword"> const</span>
<a name="l00883"></a>00883 <span class="keyword">            </span>{
<a name="l00884"></a>00884                 ValueType&lt;Len&gt; retval = *<span class="keyword">this</span>;
<a name="l00885"></a>00885                 <span class="keywordflow">if</span> (rmap &amp;&amp; name&gt;0) {
<a name="l00886"></a>00886                     RenameMap::iterator found = rmap-&gt;find(name);
<a name="l00887"></a>00887                     <span class="keywordflow">if</span> (found==rmap-&gt;end()) {
<a name="l00888"></a>00888                         retval.name = rmap-&gt;size()+1;
<a name="l00889"></a>00889                         rmap-&gt;insert(std::make_pair(name, retval.name));
<a name="l00890"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#0bc39b24adbf9a90bcf2b96b6f233098">00890</a>                     } <span class="keywordflow">else</span> {
<a name="l00891"></a>00891                         retval.name = found-&gt;second;
<a name="l00892"></a>00892                     }
<a name="l00893"></a>00893                 }
<a name="l00894"></a>00894                 <span class="keywordflow">return</span> retval;
<a name="l00895"></a>00895             }
<a name="l00896"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#a6994f0267559e860ff3156c2bfe02d4">00896</a> 
<a name="l00897"></a>00897 
<a name="l00898"></a>00898 
<a name="l00899"></a>00899             <span class="comment">/*************************************************************************************************************</span>
<a name="l00900"></a>00900 <span class="comment">             *                              MemoryCell template functions</span>
<a name="l00901"></a>00901 <span class="comment">             *************************************************************************************************************/</span>
<a name="l00902"></a>00902 
<a name="l00903"></a>00903             <span class="keyword">template</span>&lt;<span class="keyword">template</span> &lt;size_t&gt; <span class="keyword">class </span><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType</a>&gt;
<a name="l00904"></a>00904             <span class="keywordtype">bool</span>
<a name="l00905"></a>00905             <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html">MemoryCell&lt;ValueType&gt;::may_alias</a>(<span class="keyword">const</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html">MemoryCell</a> &amp;other)<span class="keyword"> const </span>{
<a name="l00906"></a>00906                 <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;addr1 = this-&gt;address;
<a name="l00907"></a>00907                 <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;addr2 = other.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCell.html#c096609894a800e2c91045ad1c250890">address</a>;
<a name="l00908"></a>00908                 <span class="keywordflow">if</span> (addr1.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a> != addr2.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a>) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00909"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#ef6a8331eea43a03322aa25efb2cca9f">00909</a> 
<a name="l00910"></a>00910                 <span class="comment">/* Same unknown values but inverses (any offset). */</span>
<a name="l00911"></a>00911                 <span class="keywordflow">if</span> (addr1.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a> &amp;&amp; addr1.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a>!=addr2.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a>) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00912"></a>00912 
<a name="l00913"></a>00913                 <span class="comment">/* If they have the same base values (or are both constant) then check the offsets. The 32-bit casts are</span>
<a name="l00914"></a>00914 <span class="comment">                 * purportedly necessary to wrap propertly, but I'm not sure this will work for addresses (LatticeElements)</span>
<a name="l00915"></a>00915 <span class="comment">                 * that have a length other than 32 bits. [FIXME RPM 2009-02-03]. */</span>
<a name="l00916"></a>00916                 uint32_t offsetDiff = (uint32_t)(addr1.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a> - addr2.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a>);
<a name="l00917"></a>00917                 <span class="keywordflow">if</span> (offsetDiff &lt; this-&gt;nbytes || offsetDiff &gt; (uint32_t)(-other.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCell.html#d4ed515e55151f862b6364773e3b68f4">nbytes</a>))
<a name="l00918"></a>00918                     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00919"></a>00919                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00920"></a>00920             }
<a name="l00921"></a>00921 
<a name="l00922"></a>00922             <span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;size_t&gt; <span class="keyword">class </span><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType</a>&gt;
<a name="l00923"></a>00923             <span class="keywordtype">bool</span>
<a name="l00924"></a>00924             <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html">MemoryCell&lt;ValueType&gt;::must_alias</a>(<span class="keyword">const</span> <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1MemoryCell.html">MemoryCell&lt;ValueType&gt;</a> &amp;other)<span class="keyword"> const </span>{
<a name="l00925"></a>00925                 <span class="keywordflow">return</span> this-&gt;address == other.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCell.html#c096609894a800e2c91045ad1c250890">address</a>;
<a name="l00926"></a>00926             }
<a name="l00927"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#52995402153ecea20c05621ce2e4cb45">00927</a> 
<a name="l00928"></a>00928             <span class="comment">/*****************************************************************************************************************</span>
<a name="l00929"></a>00929 <span class="comment">             *                              State template functions</span>
<a name="l00930"></a>00930 <span class="comment">             *****************************************************************************************************************/</span>
<a name="l00931"></a>00931 
<a name="l00932"></a>00932             <span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;size_t&gt; <span class="keyword">class </span><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType</a>&gt;
<a name="l00933"></a>00933             <span class="keywordtype">void</span>
<a name="l00934"></a>00934             <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;::print_diff_registers</a>(std::ostream &amp;o, <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State</a> &amp;other, <a class="code" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics.html#16a0fa410b5f7f2caf704e14194c53d4">RenameMap</a> *rmap<span class="comment">/*=NULL*/</span>)<span class="keyword"> const</span>
<a name="l00935"></a>00935 <span class="keyword">            </span>{
<a name="l00936"></a>00936 <span class="preprocessor">#ifndef CXX_IS_ROSE_ANALYSIS</span>
<a name="l00937"></a>00937 <span class="preprocessor"></span>                <span class="comment">// DQ (5/22/2010): This code does not compile using ROSE, it needs to be investigated to be reduced to an bug</span>
<a name="l00938"></a>00938                 <span class="comment">// report.</span>
<a name="l00939"></a>00939 
<a name="l00940"></a>00940                 std::string <a class="code" href="SgUnaryOp_8docs.html#67583283682fa1efdfa7969c1db6162c528fe3fcb2aa60370189f8203f6a1099">prefix</a> = <span class="stringliteral">"    "</span>;
<a name="l00941"></a>00941 
<a name="l00942"></a>00942                 <span class="keywordflow">for</span> (size_t i=0; i&lt;this-&gt;n_gprs; ++i) {
<a name="l00943"></a>00943                     <span class="keywordflow">if</span> (this-&gt;gpr[i]!=other.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html#23d70e82eade1842742d0fc114c9c8c3">gpr</a>[i]) {
<a name="l00944"></a>00944                         o &lt;&lt;prefix &lt;&lt;gprToString((<a class="code" href="InstructionEnumsX86_8h.html#cc245284d886f9c6728df7922b3d1f11">X86GeneralPurposeRegister</a>)i) &lt;&lt;<span class="stringliteral">": "</span>
<a name="l00945"></a>00945                           &lt;&lt;this-&gt;gpr[i].rename(rmap) &lt;&lt;<span class="stringliteral">" -&gt; "</span> &lt;&lt;other.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html#23d70e82eade1842742d0fc114c9c8c3">gpr</a>[i].<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#7ac83edb0acfb190034452c64e837bb6">rename</a>(rmap) &lt;&lt;<span class="stringliteral">"\n"</span>;
<a name="l00946"></a>00946                     }
<a name="l00947"></a>00947                 }
<a name="l00948"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#e0e92ef3c32f24eade47b462b286835f">00948</a>                 <span class="keywordflow">for</span> (size_t i=0; i&lt;this-&gt;n_segregs; ++i) {
<a name="l00949"></a>00949                     <span class="keywordflow">if</span> (this-&gt;segreg[i]!=other.segreg[i]) {
<a name="l00950"></a>00950                         o &lt;&lt;<a class="code" href="SgUnaryOp_8docs.html#67583283682fa1efdfa7969c1db6162c528fe3fcb2aa60370189f8203f6a1099">prefix</a> &lt;&lt;segregToString((<a class="code" href="InstructionEnumsX86_8h.html#96942c0566d4aa5f4e881d8e77a299a5">X86SegmentRegister</a>)i) &lt;&lt;<span class="stringliteral">": "</span>
<a name="l00951"></a>00951                           &lt;&lt;this-&gt;segreg[i].rename(rmap) &lt;&lt;<span class="stringliteral">" -&gt; "</span> &lt;&lt;other.segreg[i].rename(rmap) &lt;&lt;<span class="stringliteral">"\n"</span>;
<a name="l00952"></a>00952                     }
<a name="l00953"></a>00953                 }
<a name="l00954"></a>00954                 <span class="keywordflow">for</span> (size_t i=0; i&lt;this-&gt;n_flags; ++i) {
<a name="l00955"></a>00955                     <span class="keywordflow">if</span> (this-&gt;flag[i]!=other.flag[i]) {
<a name="l00956"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#68da0c40a7fe342a439b16ee24763aa1">00956</a>                         o &lt;&lt;<a class="code" href="SgUnaryOp_8docs.html#67583283682fa1efdfa7969c1db6162c528fe3fcb2aa60370189f8203f6a1099">prefix</a> &lt;&lt;flagToString((<a class="code" href="InstructionEnumsX86_8h.html#9ac9dbd1d59111684b314d9d9cb7c8b6">X86Flag</a>)i) &lt;&lt;<span class="stringliteral">": "</span>
<a name="l00957"></a>00957                           &lt;&lt;this-&gt;flag[i].rename(rmap) &lt;&lt;<span class="stringliteral">" -&gt; "</span> &lt;&lt;other.flag[i].rename(rmap) &lt;&lt;<span class="stringliteral">"\n"</span>;
<a name="l00958"></a>00958                     }
<a name="l00959"></a>00959                 }
<a name="l00960"></a>00960                 <span class="keywordflow">if</span> (this-&gt;ip!=other.ip) {
<a name="l00961"></a>00961                     o &lt;&lt;<a class="code" href="SgUnaryOp_8docs.html#67583283682fa1efdfa7969c1db6162c528fe3fcb2aa60370189f8203f6a1099">prefix</a> &lt;&lt;<span class="stringliteral">"ip: "</span> &lt;&lt;this-&gt;ip.rename(rmap) &lt;&lt;<span class="stringliteral">" -&gt; "</span> &lt;&lt;other.ip.rename(rmap) &lt;&lt;<span class="stringliteral">"\n"</span>;
<a name="l00962"></a>00962                 }
<a name="l00963"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#b079477bf4164c9b6659f662332403de">00963</a> <span class="preprocessor">#endif</span>
<a name="l00964"></a>00964 <span class="preprocessor"></span>            }
<a name="l00965"></a>00965 
<a name="l00966"></a>00966             <span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;size_t&gt; <span class="keyword">class </span><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType</a>&gt;
<a name="l00967"></a>00967             <span class="keywordtype">bool</span>
<a name="l00968"></a>00968             <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;::equal_registers</a>(<span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State</a> &amp;other)<span class="keyword"> const</span>
<a name="l00969"></a>00969 <span class="keyword">            </span>{
<a name="l00970"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#48c1bcfc29d50abf11f9e9aacc21f9fc">00970</a> <span class="preprocessor">#ifndef CXX_IS_ROSE_ANALYSIS</span>
<a name="l00971"></a>00971 <span class="preprocessor"></span>                <span class="keywordflow">for</span> (size_t i=0; i&lt;this-&gt;n_gprs; ++i)
<a name="l00972"></a>00972                     <span class="keywordflow">if</span> (this-&gt;gpr[i]!=other.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html#23d70e82eade1842742d0fc114c9c8c3">gpr</a>[i]) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00973"></a>00973                 for (size_t i=0; i&lt;this-&gt;n_segregs; ++i)
<a name="l00974"></a>00974                     <span class="keywordflow">if</span> (this-&gt;segreg[i]!=other.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html#230c001c3ff101904a758f55148ec4fe">segreg</a>[i]) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00975"></a>00975                 for (size_t i=0; i&lt;this-&gt;n_flags; ++i)
<a name="l00976"></a>00976                     <span class="keywordflow">if</span> (this-&gt;flag[i]!=other.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html#a172412af4fd39e3878ec53f451a839f">flag</a>[i]) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00977"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#2d450b62112ae4a3ee3f18b362ebaa91">00977</a>                 if (this-&gt;ip!=other.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html#aa6016ac7976a78ce85483375ecf4032">ip</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00978"></a>00978 #endif
<a name="l00979"></a>00979                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00980"></a>00980             }
<a name="l00981"></a>00981 
<a name="l00982"></a>00982             <span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;size_t&gt; <span class="keyword">class </span><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType</a>&gt;
<a name="l00983"></a>00983             <span class="keywordtype">void</span>
<a name="l00984"></a>00984             <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;::discard_popped_memory</a>()
<a name="l00985"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#725dc4f78ddf1d035aacb2512227c267">00985</a>             {
<a name="l00986"></a>00986                 Memory new_mem;
<a name="l00987"></a>00987                 <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;sp = this-&gt;gpr[<a class="code" href="InstructionEnumsX86_8h.html#cc245284d886f9c6728df7922b3d1f114be93f17b2c8645908e8efc27567ec3e">x86_gpr_sp</a>];
<a name="l00988"></a>00988                 <span class="keywordflow">for</span> (<span class="keyword">typename</span> Memory::const_iterator mi=this-&gt;mem.begin(); mi!=this-&gt;mem.end(); ++mi) {
<a name="l00989"></a>00989                     <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;addr = (*mi).<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1MemoryCell.html#bf4afc40f4678bcf78308d0b53407cca">get_address</a>();
<a name="l00990"></a>00990                     <span class="keywordflow">if</span> (addr.name!=sp.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#a5aaf78d9eafde3ba89826881e7e2613">name</a> || addr.negate!=sp.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#d21d168e0d697f22b2980a48b944d301">negate</a> || (int32_t)addr.offset&gt;=(int32_t)sp.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#13128fb47c3f48b47f6b6a82a4b5599b">offset</a>)
<a name="l00991"></a>00991                         new_mem.push_back(*mi);
<a name="l00992"></a>00992                 }
<a name="l00993"></a>00993                 this-&gt;mem = new_mem;
<a name="l00994"></a>00994             }
<a name="l00995"></a>00995 
<a name="l00996"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#f8d7e1596dac098b39ec2180c493399e">00996</a>             <span class="comment">/*****************************************************************************************************************</span>
<a name="l00997"></a>00997 <span class="comment">             *                              Policy template functions</span>
<a name="l00998"></a>00998 <span class="comment">             *****************************************************************************************************************/</span>
<a name="l00999"></a>00999 
<a name="l01000"></a>01000             <span class="comment">/* Returns memory that needs to be compared by equal_states() */</span>
<a name="l01001"></a>01001             <span class="keyword">template</span>&lt;
<a name="l01002"></a>01002                 <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;size_t&gt; <span class="keyword">class </span><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType</a>&gt; <span class="keyword">class </span><a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State</a>,
<a name="l01003"></a>01003                 template&lt;size_t&gt; class ValueType&gt;
<a name="l01004"></a>01004             typename State&lt;ValueType&gt;::Memory
<a name="l01005"></a>01005             <a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html">Policy</a>&lt;State, ValueType&gt;::memory_for_equality(const State&lt;ValueType&gt; &amp;state) const
<a name="l01006"></a>01006             {
<a name="l01007"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#411e83b546bf4bd1644a1fa7443239ea">01007</a>                 <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;</a> tmp_state = state;
<a name="l01008"></a>01008                 <span class="keyword">typename</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;::Memory</a> retval;
<a name="l01009"></a>01009 <span class="preprocessor">#ifndef CXX_IS_ROSE_ANALYSIS</span>
<a name="l01010"></a>01010 <span class="preprocessor"></span>                <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;::Memory::const_iterator</a> mi=state.mem.begin(); mi!=state.mem.end(); ++mi) {
<a name="l01011"></a>01011                     <span class="keywordflow">if</span> ((*mi).is_written() &amp;&amp; (*mi).get_data()!=mem_read&lt;32&gt;(orig_state, (*mi).get_address()))
<a name="l01012"></a>01012                         retval.push_back(*mi);
<a name="l01013"></a>01013                 }
<a name="l01014"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#793e80d4e27c8b47f059928409a92c45">01014</a> <span class="preprocessor">#endif</span>
<a name="l01015"></a>01015 <span class="preprocessor"></span>                <span class="keywordflow">return</span> retval;
<a name="l01016"></a>01016             }
<a name="l01017"></a>01017 
<a name="l01018"></a>01018             <span class="keyword">template</span>&lt;
<a name="l01019"></a>01019                 <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;size_t&gt; <span class="keyword">class </span>ValueType&gt; <span class="keyword">class </span>State,
<a name="l01020"></a>01020                 template&lt;size_t&gt; class ValueType&gt;
<a name="l01021"></a>01021             bool
<a name="l01022"></a>01022             Policy&lt;State, ValueType&gt;::equal_states(const State&lt;ValueType&gt; &amp;s1, const State&lt;ValueType&gt; &amp;s2) const
<a name="l01023"></a>01023             {
<a name="l01024"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#48f66c5551c6e804d3d5a4b9ba1f45f8">01024</a> <span class="preprocessor">#ifndef CXX_IS_ROSE_ANALYSIS</span>
<a name="l01025"></a>01025 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (!s1.equal_registers(s2))
<a name="l01026"></a>01026                     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01027"></a>01027                 <span class="keyword">typename</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;::Memory</a> m1 = memory_for_equality(s1);
<a name="l01028"></a>01028                 <span class="keyword">typename</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;::Memory</a> m2 = memory_for_equality(s2);
<a name="l01029"></a>01029                 <span class="keywordflow">if</span> (m1.size()!=m2.size())
<a name="l01030"></a>01030                     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01031"></a>01031                 <span class="keywordflow">for</span> (size_t i=0; i&lt;m1.size(); ++i) {
<a name="l01032"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#b1477b0245fbc9e1fee1e977ad094bc2">01032</a>                     <span class="keywordflow">if</span> (m1[i].get_nbytes() != m2[i].get_nbytes() ||
<a name="l01033"></a>01033                         m1[i].get_address()!= m2[i].get_address() ||
<a name="l01034"></a>01034                         m1[i].get_data()   != m2[i].get_data())
<a name="l01035"></a>01035                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01036"></a>01036                 }
<a name="l01037"></a>01037 <span class="preprocessor">#endif</span>
<a name="l01038"></a>01038 <span class="preprocessor"></span>                <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01039"></a>01039             }
<a name="l01040"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#117ffb4db6986944b8abe0076a34d321">01040</a> 
<a name="l01041"></a>01041             <span class="keyword">template</span>&lt;
<a name="l01042"></a>01042                 <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;size_t&gt; <span class="keyword">class </span>ValueType&gt; <span class="keyword">class </span>State,
<a name="l01043"></a>01043                 template&lt;size_t&gt; class ValueType&gt;
<a name="l01044"></a>01044             void
<a name="l01045"></a>01045             Policy&lt;State, ValueType&gt;::print(std::ostream &amp;o, RenameMap *rmap<span class="comment">/*=NULL*/</span>) const
<a name="l01046"></a>01046             {
<a name="l01047"></a>01047                 cur_state.<a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics_1_1StateX86.html#963e577ebbd4cf0e14e29f001309c4d0">print</a>(o, <span class="stringliteral">""</span>, rmap);
<a name="l01048"></a>01048             }
<a name="l01049"></a>01049 
<a name="l01050"></a>01050             <span class="keyword">template</span>&lt;
<a name="l01051"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#ae706e08fbd3544603faf230c3ebb6c3">01051</a>                 <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;size_t&gt; <span class="keyword">class </span>ValueType&gt; <span class="keyword">class </span>State,
<a name="l01052"></a>01052                 template&lt;size_t&gt; class ValueType&gt;
<a name="l01053"></a>01053             void
<a name="l01054"></a>01054             Policy&lt;State, ValueType&gt;::print_diff(std::ostream &amp;o, const State&lt;ValueType&gt; &amp;s1,
<a name="l01055"></a>01055                                                  const State&lt;ValueType&gt; &amp;s2, RenameMap *rmap<span class="comment">/*=NULL*/</span>) const
<a name="l01056"></a>01056             {
<a name="l01057"></a>01057 <span class="preprocessor">#ifndef CXX_IS_ROSE_ANALYSIS</span>
<a name="l01058"></a>01058 <span class="preprocessor"></span>                s1.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html#2d5b56be66a5a23afd80dc0e963f2a43">print_diff_registers</a>(o, s2, rmap);
<a name="l01059"></a>01059 
<a name="l01060"></a>01060                 <span class="comment">/* Get all addresses that have been written and are not currently clobbered. */</span>
<a name="l01061"></a>01061                 std::set&lt;ValueType&lt;32&gt; &gt; addresses;
<a name="l01062"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#d38618e5bbaddc8f2c1ced35d729a154">01062</a>                 <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;::Memory::const_iterator</a> mi=s1.mem.begin(); mi!=s1.mem.end(); ++mi) {
<a name="l01063"></a>01063                     <span class="keywordflow">if</span> (!(*mi).is_clobbered() &amp;&amp; (*mi).is_written())
<a name="l01064"></a>01064                         addresses.insert((*mi).get_address());
<a name="l01065"></a>01065                 }
<a name="l01066"></a>01066                 <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;::Memory::const_iterator</a> mi=s2.mem.begin(); mi!=s2.mem.end(); ++mi) {
<a name="l01067"></a>01067                     <span class="keywordflow">if</span> (!(*mi).is_clobbered() &amp;&amp; (*mi).is_written())
<a name="l01068"></a>01068                         addresses.insert((*mi).get_address());
<a name="l01069"></a>01069                 }
<a name="l01070"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#9a4b2b77c90bf383b05aa6cc1279f395">01070</a> 
<a name="l01071"></a>01071                 <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;</a> tmp_s1 = s1;
<a name="l01072"></a>01072                 <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;</a> tmp_s2 = s2;
<a name="l01073"></a>01073                 size_t nmemdiff = 0;
<a name="l01074"></a>01074                 <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::set&lt;<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &gt;::const_iterator ai=addresses.begin(); ai!=addresses.end(); ++ai) {
<a name="l01075"></a>01075                     <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> v1 = mem_read&lt;32&gt;(tmp_s1, *ai);
<a name="l01076"></a>01076                     <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> v2 = mem_read&lt;32&gt;(tmp_s2, *ai);
<a name="l01077"></a>01077                     <span class="keywordflow">if</span> (v1 != v2) {
<a name="l01078"></a>01078                         <span class="keywordflow">if</span> (0==nmemdiff++) o &lt;&lt;<span class="stringliteral">"    memory:\n"</span>;
<a name="l01079"></a>01079                         o &lt;&lt;<span class="stringliteral">"      "</span> &lt;&lt;(*ai).rename(rmap) &lt;&lt;<span class="stringliteral">": "</span> &lt;&lt;v1.rename(rmap) &lt;&lt;<span class="stringliteral">" -&gt; "</span> &lt;&lt;v2.<a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html#7ac83edb0acfb190034452c64e837bb6">rename</a>(rmap) &lt;&lt;<span class="stringliteral">"\n"</span>;
<a name="l01080"></a>01080                     }
<a name="l01081"></a>01081                 }
<a name="l01082"></a>01082 <span class="preprocessor">#endif</span>
<a name="l01083"></a>01083 <span class="preprocessor"></span>            }
<a name="l01084"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#239286b71c48623b011cda1f31679ad4">01084</a> 
<a name="l01085"></a>01085             <span class="keyword">template</span>&lt;
<a name="l01086"></a>01086                 <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;size_t&gt; <span class="keyword">class </span>ValueType&gt; <span class="keyword">class </span>State,
<a name="l01087"></a>01087                 template&lt;size_t&gt; class ValueType&gt;
<a name="l01088"></a>01088             bool
<a name="l01089"></a>01089             Policy&lt;State, ValueType&gt;::on_stack(const ValueType&lt;32&gt; &amp;value) const
<a name="l01090"></a>01090             {
<a name="l01091"></a>01091 <span class="preprocessor">#ifndef CXX_IS_ROSE_ANALYSIS</span>
<a name="l01092"></a>01092 <span class="preprocessor"></span>                <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> sp_inverted = invert(cur_state.gpr[<a class="code" href="InstructionEnumsX86_8h.html#cc245284d886f9c6728df7922b3d1f114be93f17b2c8645908e8efc27567ec3e">x86_gpr_sp</a>]);
<a name="l01093"></a>01093                 <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1State.html">State&lt;ValueType&gt;::Memory::const_iterator</a> mi=cur_state.mem.begin(); mi!=cur_state.mem.end(); ++mi) {
<a name="l01094"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#a1e17c3a577241a7840725bb8ae9a5a9">01094</a>                     <span class="keywordflow">if</span> ((*mi).get_nbytes()!=4 || !((*mi).get_data()==value)) <span class="keywordflow">continue</span>;
<a name="l01095"></a>01095                     <span class="keyword">const</span> <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> &amp;addr = (*mi).get_address();
<a name="l01096"></a>01096 
<a name="l01097"></a>01097                     <span class="comment">/* Is addr &gt;= sp? */</span>
<a name="l01098"></a>01098                     <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> carries = 0;
<a name="l01099"></a>01099                     <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;32&gt;</a> diff = addWithCarries(addr, sp_inverted, true_(), carries<span class="comment">/*out*/</span>);
<a name="l01100"></a>01100                     <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;1&gt;</a> sf = extract&lt;31,32&gt;(diff);
<a name="l01101"></a>01101                     <a class="code" href="structBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1ValueType.html">ValueType&lt;1&gt;</a> of = xor_(extract&lt;31,32&gt;(carries), extract&lt;30,31&gt;(carries));
<a name="l01102"></a>01102                     <span class="keywordflow">if</span> (sf==of) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01103"></a>01103                 }
<a name="l01104"></a>01104 <span class="preprocessor">#endif</span>
<a name="l01105"></a>01105 <span class="preprocessor"></span>                <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01106"></a>01106             }
<a name="l01107"></a>01107 
<a name="l01108"></a>01108             <span class="keyword">template</span>&lt;
<a name="l01109"></a>01109                 <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;size_t&gt; <span class="keyword">class </span>ValueType&gt; <span class="keyword">class </span>State,
<a name="l01110"></a>01110                 template&lt;size_t&gt; class ValueType&gt;
<a name="l01111"></a>01111             bool
<a name="l01112"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#5cb2dea2c227a1f4d1d9ee00e7cbb635">01112</a>             Policy&lt;State, ValueType&gt;::SHA1(unsigned char digest[20]) const
<a name="l01113"></a>01113             {
<a name="l01114"></a>01114 <span class="preprocessor">#ifdef ROSE_HAVE_GCRYPT_H</span>
<a name="l01115"></a>01115 <span class="preprocessor"></span>                <span class="comment">/* libgcrypt requires gcry_check_version() to be called "before any other function in the library", but doesn't</span>
<a name="l01116"></a>01116 <span class="comment">                 * include an API function for determining if this has already been performed. It also doesn't indicate what</span>
<a name="l01117"></a>01117 <span class="comment">                 * happens when it's called more than once, or how expensive the call is.  Therefore, instead of calling it</span>
<a name="l01118"></a>01118 <span class="comment">                 * every time through this function, we'll just call it the first time. */</span>
<a name="l01119"></a>01119                 <span class="keyword">static</span> <span class="keywordtype">bool</span> initialized = <span class="keyword">false</span>;
<a name="l01120"></a>01120                 <span class="keywordflow">if</span> (!initialized) {
<a name="l01121"></a>01121                     gcry_check_version(NULL);
<a name="l01122"></a>01122                     initialized = <span class="keyword">true</span>;
<a name="l01123"></a>01123                 }
<a name="l01124"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#315f0b1c4c76013ecccc9d97448ca325">01124</a> 
<a name="l01125"></a>01125                 std::stringstream s;
<a name="l01126"></a>01126                 <a class="code" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics.html#16a0fa410b5f7f2caf704e14194c53d4">RenameMap</a> rmap;
<a name="l01127"></a>01127                 print_diff(s, &amp;rmap);
<a name="l01128"></a>01128                 ROSE_ASSERT(gcry_md_get_algo_dlen(GCRY_MD_SHA1)==20);
<a name="l01129"></a>01129                 gcry_md_hash_buffer(GCRY_MD_SHA1, digest, s.str().c_str(), s.str().size());
<a name="l01130"></a>01130                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01131"></a>01131 <span class="preprocessor">#else</span>
<a name="l01132"></a>01132 <span class="preprocessor"></span>                memset(digest, 0, 20);
<a name="l01133"></a>01133                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01134"></a>01134 <span class="preprocessor">#endif</span>
<a name="l01135"></a>01135 <span class="preprocessor"></span>            }
<a name="l01136"></a>01136 
<a name="l01137"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#412acd4436f33a9d8a73a1c51b5cd226">01137</a>             <span class="keyword">template</span>&lt;
<a name="l01138"></a>01138                 <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;size_t&gt; <span class="keyword">class </span>ValueType&gt; <span class="keyword">class </span>State,
<a name="l01139"></a>01139                 template&lt;size_t&gt; class ValueType&gt;
<a name="l01140"></a>01140             std::string
<a name="l01141"></a>01141             Policy&lt;State, ValueType&gt;::SHA1() const
<a name="l01142"></a>01142             {
<a name="l01143"></a>01143                 std::string digest_str;
<a name="l01144"></a>01144                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> digest[20];
<a name="l01145"></a>01145                 <span class="keywordflow">if</span> (SHA1(digest)) {
<a name="l01146"></a>01146                     <span class="keywordflow">for</span> (size_t i=<span class="keyword">sizeof</span> digest; i&gt;0; --i) {
<a name="l01147"></a>01147                         digest_str += <span class="stringliteral">"0123456789abcdef"</span>[(digest[i-1] &gt;&gt; 4) &amp; 0xf];
<a name="l01148"></a>01148                         digest_str += <span class="stringliteral">"0123456789abcdef"</span>[digest[i-1] &amp; 0xf];
<a name="l01149"></a>01149                     }
<a name="l01150"></a>01150                 }
<a name="l01151"></a>01151                 <span class="keywordflow">return</span> digest_str;
<a name="l01152"></a>01152             }
<a name="l01153"></a><a class="code" href="classBinaryAnalysis_1_1InstructionSemantics_1_1VirtualMachineSemantics_1_1Policy.html#d91d9c272a3c4d48099452d2596f1f6b">01153</a>     
<a name="l01154"></a>01154         } <span class="comment">/*namespace*/</span>
<a name="l01155"></a>01155     } <span class="comment">/*namespace*/</span>
<a name="l01156"></a>01156 } <span class="comment">/*namespace*/</span>
<a name="l01157"></a>01157 
<a name="l01158"></a>01158 
<a name="l01159"></a>01159 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue May 22 05:03:39 2012 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
