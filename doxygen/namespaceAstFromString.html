<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: AstFromString Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li id="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="namespaces.html"><span>Namespace List</span></a></li>
    <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
  </ul></div>
<h1>AstFromString Namespace Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Liao 4/13/2011. 
<p>
Support creating simple recursive descent parsers of source code annotations<p>
The namespace, <a class="el" href="namespaceAstFromString.html">AstFromString</a>, collects a set of helper functions (or parser building blocks) that operate on an input string to create simple recursive descent parsers for source code annotations(C/C++ pragmas or Fortran comments). 
<p>

<p>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Character check , without side effect on the current position</h2></td></tr>
<tr><td colspan="2">utility functions for checking characters, without changing the current position of the input string being parsed. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#da0d171a30f169d5620272c66d3d5c8c">afs_is_digit</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the current character is a digit. The current position of the input string remains unchanged either way.  <a href="#da0d171a30f169d5620272c66d3d5c8c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#72c0b5acd1cd30df98bb570357c845ea">afs_is_identifier_char</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the current character is a legal identifier character, including letters, digits, '_' and '$' (For fortran). No side effect on the current position.  <a href="#72c0b5acd1cd30df98bb570357c845ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#05677585e184ef8a881a8565a26ffb28">afs_is_letter</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the current character is a letter. No side effect on the current position of the input string.  <a href="#05677585e184ef8a881a8565a26ffb28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#11b24b41cef8d03a45ca8a079c8b2350">afs_is_lower_letter</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the current character is a lower case letter.  <a href="#11b24b41cef8d03a45ca8a079c8b2350"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#ad82524f84140c3e4d595a9e9fb5a132">afs_is_upper_letter</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the current character is a upper case letter.  <a href="#ad82524f84140c3e4d595a9e9fb5a132"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Match with side effects (set c_parsed_node and advance the current position of character) if successful. Return false and have no side effects if the match fails.</h2></td></tr>
<tr><td colspan="2">utility functions for matching string, whitespace, identifiers, const etc. Successful match will advance the current position. entry point, declarations, types Follow the order of <a href="http://www.antlr.org/grammar/1153358328744/C.g">http://www.antlr.org/grammar/1153358328744/C.g</a> <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#3cd96a9a913bdcd74d8872627f43abe6">afs_match_char</a> (char c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">match a char, advance one position if successful.  <a href="#3cd96a9a913bdcd74d8872627f43abe6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#3fa38d1fa399750040b91b8ce7aab969">afs_match_substr</a> (const char *substr, bool checkTrail=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match a sub string: a given sub c string from the input c string, again skip heading space/tabs if any.  <a href="#3fa38d1fa399750040b91b8ce7aab969"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#5abae5c653d5afad4a8706a3048ff8d4">afs_skip_whitespace</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match and skip whitespace.  <a href="#5abae5c653d5afad4a8706a3048ff8d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#be55805eb4a4992b6f6bbca8c991b9ae">afs_match_identifier</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match identifier, move to the next character if successful. The identifier could be a name of a type, function, variable, or label. The resolved identifier (type or variable/function/label name) is stored into c_parsed_node.  <a href="#be55805eb4a4992b6f6bbca8c991b9ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#f71865ace99fdae73e785f40a66e76e3">afs_match_integer_const</a> (int *result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match an integer constant, store it into result.  <a href="#f71865ace99fdae73e785f40a66e76e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#66bf6ffe4a7289d433d9b73b96dfb6a8">afs_match_translation_unit</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match a translation unit. Not yet implemented.  <a href="#66bf6ffe4a7289d433d9b73b96dfb6a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#b8723927c40b380f0ca5db0916aa04b1">afs_match_external_declaration</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match an external declaration. Not yet implemented.  <a href="#b8723927c40b380f0ca5db0916aa04b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#e06f2c046ca13de801fc2880c6445e0d">afs_match_function_definition</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match a function definition. Not yet implemented.  <a href="#e06f2c046ca13de801fc2880c6445e0d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#116fca2a1343fd6caa5ec533c48b210c">afs_match_declaration</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match a declaration. Not yet implemented.  <a href="#116fca2a1343fd6caa5ec533c48b210c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#a2610a30f7c006f42b2f30f265b93e49">afs_match_declaration_specifiers</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match declaration specifiers. Not yet implemented.  <a href="#a2610a30f7c006f42b2f30f265b93e49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#699b8dc8f9b0c6259df7aea73784d45d">afs_match_init_declarator_list</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match an init declarator list. Not yet implemented.  <a href="#699b8dc8f9b0c6259df7aea73784d45d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#85d0ea63479b87f8b0e758b671e19045">afs_match_init_declarator</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match init declarator. Not yet implemented.  <a href="#85d0ea63479b87f8b0e758b671e19045"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#980d054be0a0d7c22f2cdd4947650a43">afs_match_storage_class_specifier</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match a storage class specifier. Not yet implemented.  <a href="#980d054be0a0d7c22f2cdd4947650a43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#11b78ad746fb5b993b3e7c06ca7ccea3">afs_match_type_specifier</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match a type specifier : 'void' | 'char' | 'short' | 'int' | 'long' | 'float' | 'double' | 'signed' | 'unsigned' | struct_or_union_specifier | enum_specifier | type_id. The recognized type is stored in c_parsed_node.  <a href="#11b78ad746fb5b993b3e7c06ca7ccea3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#4e5f1c0435a73d7c7f59a04403648c79">afs_match_specifier_qualifier_list</a> (std::vector&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match a list of specifiers and qualifiers : : ( type_qualifier | type_specifier )+.  <a href="#4e5f1c0435a73d7c7f59a04403648c79"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#f3a0147793736529720ee0d205eb4605">afs_match_type_qualifier</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match a type qualifier : 'const' | 'volatile'.  <a href="#f3a0147793736529720ee0d205eb4605"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#0d85361a2e72bdb7597bfae44bb9000d">afs_match_type_name</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match a type name : specifier_qualifier_list abstract_declarator?  <a href="#0d85361a2e72bdb7597bfae44bb9000d"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Expression</h2></td></tr>
<tr><td colspan="2">utility functions for parsing expressions and generate AST pieces for them. Successful match will advance the current position. The function names and grammars largely follow the conventions used in <a href="http://www.antlr.org/grammar/1153358328744/C.g.">http://www.antlr.org/grammar/1153358328744/C.g.</a> For example in the grammar shown, | means or, * means 0 or more repetition of the previous term , ? means 0 or 1 occurrence of the previous term. + means 1 or more occurrence. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#b2f7e408ebd42abd6a3f1524a9a40c4f">afs_match_argument_expression_list</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Grammar: argument_expression_list : assignment_expression (',' assignment_expression)* one assignment_expression, followed by optionally arbitrary numbers of (',' assignment_expression).  <a href="#b2f7e408ebd42abd6a3f1524a9a40c4f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#8ff708dd8c6a3b1d4e0ef24435ef57a0">afs_match_additive_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Grammar: additive_expression : (multiplicative_expression) ('+' multiplicative_expression | '-' multiplicative_expression)*.  <a href="#8ff708dd8c6a3b1d4e0ef24435ef57a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#b790e1f12bf6b12d05af38bf858d9f77">afs_match_multiplicative_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">multiplicative_expression : (cast_expression) ('*' cast_expression | '/' cast_expression | '' cast_expression)*  <a href="#b790e1f12bf6b12d05af38bf858d9f77"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#fb9988003ec258d5b1158320db512e6b">afs_match_cast_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">cast_expression : '(' type_name ')' cast_expression | unary_expression  <a href="#fb9988003ec258d5b1158320db512e6b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#f3734616354c3caa2f606209dc5177e8">afs_match_unary_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unary_expression : postfix_expression | INC_OP unary_expression | DEC_OP unary_expression | unary_operator cast_expression | SIZEOF unary_expression | SIZEOF '(' type_name ')'  <a href="#f3734616354c3caa2f606209dc5177e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#15123da9beb78f35c462ed98edca8642">afs_match_postfix_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">postfix_expression : primary_expression ( '[' expression ']' | '(' ')' | '(' argument_expression_list ')' | '.' IDENTIFIER | '-&gt;' IDENTIFIER | '++' | '--' )*  <a href="#15123da9beb78f35c462ed98edca8642"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#f42fbad2937c56dbf426299bc0ea8512">afs_match_primary_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">primary_expression : IDENTIFIER | constant | '(' expression ')'  <a href="#f42fbad2937c56dbf426299bc0ea8512"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#22e93ed03cda1337021b9d19150e6823">afs_match_constant</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Only integer constant is supported for now. Full grammar is constant : HEX_LITERAL | OCTAL_LITERAL | DECIMAL_LITERAL | CHARACTER_LITERAL | STRING_LITERAL | FLOATING_POINT_LITERAL.  <a href="#22e93ed03cda1337021b9d19150e6823"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#5da3da6c00c88c919b7e993859a6a03a">afs_match_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">expression : assignment_expression (',' assignment_expression)*. Match one or more assignment_expression  <a href="#5da3da6c00c88c919b7e993859a6a03a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#db9826b8265782cdc48caea38b4a274d">afs_match_constant_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">constant_expression : conditional_expression  <a href="#db9826b8265782cdc48caea38b4a274d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#0bc445f47d61dd4f000f8f4b9c8847b8">afs_match_assignment_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">assignment_expression : lvalue assignment_operator assignment_expression | conditional_expression  <a href="#0bc445f47d61dd4f000f8f4b9c8847b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#456363ab176f7bd2e416e24a9bb66609">afs_match_lvalue</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">lvalue: unary_expression  <a href="#456363ab176f7bd2e416e24a9bb66609"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#d458e39d03f3b271a7de89ca1be1d700">afs_match_conditional_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">conditional_expression : logical_or_expression ('?' expression ':' conditional_expression)? '?' means 0 or 1 occurrence  <a href="#d458e39d03f3b271a7de89ca1be1d700"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#05197a45404734e6fff0bcf7c1c27891">afs_match_logical_or_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">logical_or_expression : logical_and_expression ('||' logical_and_expression)*  <a href="#05197a45404734e6fff0bcf7c1c27891"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#e5203e84707829c1894962029bec667a">afs_match_logical_and_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">logical_and_expression : inclusive_or_expression ('&amp;&amp;' inclusive_or_expression)*  <a href="#e5203e84707829c1894962029bec667a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#5a44009993b03d6dbffd3804f22b4102">afs_match_inclusive_or_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inclusive_or_expression : exclusive_or_expression ('|' exclusive_or_expression)*  <a href="#5a44009993b03d6dbffd3804f22b4102"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#3dfd5735e6a8b871ab0919e1b7e16b7d">afs_match_exclusive_or_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">exclusive_or_expression : and_expression ('^' and_expression)*  <a href="#3dfd5735e6a8b871ab0919e1b7e16b7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#1c2994badc59ec172a4246a27b1ff8e9">afs_match_and_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">and_expression : equality_expression ('&amp;' equality_expression)*  <a href="#1c2994badc59ec172a4246a27b1ff8e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#3d5da6b7003e1f23f800e4b318a98d67">afs_match_equality_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">equality_expression : relational_expression (('=='|'!=') relational_expression)*  <a href="#3d5da6b7003e1f23f800e4b318a98d67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#841d1f4cd3da31ad6e58e0a6c5df1e82">afs_match_relational_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">relational_expression : shift_expression (('&lt;'|'&gt;'|'&lt;='|'&gt;=') shift_expression)*  <a href="#841d1f4cd3da31ad6e58e0a6c5df1e82"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#2ee5e90fe38fca83e116a6ad5f720b0f">afs_match_shift_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">shift_expression : additive_expression (('&lt;&lt;'|'&gt;&gt;') additive_expression)*  <a href="#2ee5e90fe38fca83e116a6ad5f720b0f"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Statement</h2></td></tr>
<tr><td colspan="2">utility functions to parse a few statements. Successful match will advance the current position. INCOMPLETE now, Don't use them yet! <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#f90e6b9eebdaabd1f7967f8787439634">afs_match_statement</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">match any statement, not complete yet. Don't use it yet . : labeled_statement | compound_statement | expression_statement | selection_statement | iteration_statement | jump_statement  <a href="#f90e6b9eebdaabd1f7967f8787439634"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#341d881e4cb7e51b45642b243e131f54">afs_match_labeled_statement</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match labeled statement : IDENTIFIER ':' statement | 'case' constant_expression ':' statement | 'default' ':' statement.  <a href="#341d881e4cb7e51b45642b243e131f54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#33d1694de5d8c3267437ade0d54503ee">afs_match_compound_statement</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Not yet implemented. Match compound statement: '{' declaration* statement_list? '}'.  <a href="#33d1694de5d8c3267437ade0d54503ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#9f71021a17ce4a74735ce161945aedd3">afs_match_expression_statement</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match expression statement: : ';' | expression ';'.  <a href="#9f71021a17ce4a74735ce161945aedd3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#010c4debe4214c19e8e57d6e9957cbc7">afs_match_selection_statement</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match selection statement: IF '(' expression ')' statement | IF '(' expression ')' statement ELSE statement | SWITCH '(' expression ')' statement.  <a href="#010c4debe4214c19e8e57d6e9957cbc7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#5562f2db0432968a76bad994ebe2eee2">afs_match_iteration_statement</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match an iteration statement: : 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'for' '(' expression_statement expression_statement expression? ')' statement.  <a href="#5562f2db0432968a76bad994ebe2eee2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#ab86f0076ee748c6509d7388a3a1d77a">afs_match_jump_statement</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match a jump statement : 'goto' IDENTIFIER ';' | 'continue' ';' | 'break' ';' | 'return' ';' | 'return' expression ';'.  <a href="#ab86f0076ee748c6509d7388a3a1d77a"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Namespace scope variables</h2></td></tr>
<tr><td colspan="2">Semi-global variables <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#40c060440fd38cf16b94e53c857b0ab8">c_char</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A namespace scope char* to avoid passing and returning a target c string for every and each function current characters being scanned, what is pointed is const, the pointer itself is not const.  <a href="#40c060440fd38cf16b94e53c857b0ab8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#d0a195aa797474256eb6a247c5785096">c_sgnode</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">current anchor <a class="el" href="classSgNode.html">SgNode</a> associated with parsing. It will serve as a start point to find enclosing scopes for resolving identifiers/symbols  <a href="#d0a195aa797474256eb6a247c5785096"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#fa86836cff8cafbe2defb54470659310">c_parsed_node</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store the AST substree (expression, statement) generated from a helper function.  <a href="#fa86836cff8cafbe2defb54470659310"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="da0d171a30f169d5620272c66d3d5c8c"></a><!-- doxytag: member="AstFromString::afs_is_digit" ref="da0d171a30f169d5620272c66d3d5c8c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_is_digit           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if the current character is a digit. The current position of the input string remains unchanged either way. 
<p>

</div>
</div><p>
<a class="anchor" name="72c0b5acd1cd30df98bb570357c845ea"></a><!-- doxytag: member="AstFromString::afs_is_identifier_char" ref="72c0b5acd1cd30df98bb570357c845ea" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_is_identifier_char           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if the current character is a legal identifier character, including letters, digits, '_' and '$' (For fortran). No side effect on the current position. 
<p>

</div>
</div><p>
<a class="anchor" name="05677585e184ef8a881a8565a26ffb28"></a><!-- doxytag: member="AstFromString::afs_is_letter" ref="05677585e184ef8a881a8565a26ffb28" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_is_letter           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if the current character is a letter. No side effect on the current position of the input string. 
<p>

</div>
</div><p>
<a class="anchor" name="11b24b41cef8d03a45ca8a079c8b2350"></a><!-- doxytag: member="AstFromString::afs_is_lower_letter" ref="11b24b41cef8d03a45ca8a079c8b2350" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_is_lower_letter           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if the current character is a lower case letter. 
<p>

</div>
</div><p>
<a class="anchor" name="ad82524f84140c3e4d595a9e9fb5a132"></a><!-- doxytag: member="AstFromString::afs_is_upper_letter" ref="ad82524f84140c3e4d595a9e9fb5a132" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_is_upper_letter           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if the current character is a upper case letter. 
<p>

</div>
</div><p>
<a class="anchor" name="3cd96a9a913bdcd74d8872627f43abe6"></a><!-- doxytag: member="AstFromString::afs_match_char" ref="3cd96a9a913bdcd74d8872627f43abe6" args="(char c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_char           </td>
          <td>(</td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
match a char, advance one position if successful. 
<p>

</div>
</div><p>
<a class="anchor" name="3fa38d1fa399750040b91b8ce7aab969"></a><!-- doxytag: member="AstFromString::afs_match_substr" ref="3fa38d1fa399750040b91b8ce7aab969" args="(const char *substr, bool checkTrail=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_substr           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>substr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>checkTrail</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match a sub string: a given sub c string from the input c string, again skip heading space/tabs if any. 
<p>
checkTrail: Check the immediate following character after the match, it must be one of whitespace, end of str, newline, tab, (, ), or '!', etc. It is set to true by default, used to ensure the matched substr is a full identifier/keywords. Note: If try to match non-identifier, such as operators +=, etc), please set checkTrail to false!! But Fortran OpenMP allows blanks/tabs to be ignored between certain pair of keywords: e.g: end critical == endcritical , parallel do == paralleldo to match the 'end' and 'parallel', we have to skip trail checking. return values:<ul>
<li>true: find a match, the current char is pointed to the next char after the substr</li><li>false: no match, the current char is intact </li></ul>

</div>
</div><p>
<a class="anchor" name="5abae5c653d5afad4a8706a3048ff8d4"></a><!-- doxytag: member="AstFromString::afs_skip_whitespace" ref="5abae5c653d5afad4a8706a3048ff8d4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_skip_whitespace           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match and skip whitespace. 
<p>

</div>
</div><p>
<a class="anchor" name="be55805eb4a4992b6f6bbca8c991b9ae"></a><!-- doxytag: member="AstFromString::afs_match_identifier" ref="be55805eb4a4992b6f6bbca8c991b9ae" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_identifier           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match identifier, move to the next character if successful. The identifier could be a name of a type, function, variable, or label. The resolved identifier (type or variable/function/label name) is stored into c_parsed_node. 
<p>

</div>
</div><p>
<a class="anchor" name="f71865ace99fdae73e785f40a66e76e3"></a><!-- doxytag: member="AstFromString::afs_match_integer_const" ref="f71865ace99fdae73e785f40a66e76e3" args="(int *result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_integer_const           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>result</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match an integer constant, store it into result. 
<p>

</div>
</div><p>
<a class="anchor" name="66bf6ffe4a7289d433d9b73b96dfb6a8"></a><!-- doxytag: member="AstFromString::afs_match_translation_unit" ref="66bf6ffe4a7289d433d9b73b96dfb6a8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_translation_unit           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match a translation unit. Not yet implemented. 
<p>

</div>
</div><p>
<a class="anchor" name="b8723927c40b380f0ca5db0916aa04b1"></a><!-- doxytag: member="AstFromString::afs_match_external_declaration" ref="b8723927c40b380f0ca5db0916aa04b1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_external_declaration           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match an external declaration. Not yet implemented. 
<p>

</div>
</div><p>
<a class="anchor" name="e06f2c046ca13de801fc2880c6445e0d"></a><!-- doxytag: member="AstFromString::afs_match_function_definition" ref="e06f2c046ca13de801fc2880c6445e0d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_function_definition           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match a function definition. Not yet implemented. 
<p>

</div>
</div><p>
<a class="anchor" name="116fca2a1343fd6caa5ec533c48b210c"></a><!-- doxytag: member="AstFromString::afs_match_declaration" ref="116fca2a1343fd6caa5ec533c48b210c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_declaration           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match a declaration. Not yet implemented. 
<p>

</div>
</div><p>
<a class="anchor" name="a2610a30f7c006f42b2f30f265b93e49"></a><!-- doxytag: member="AstFromString::afs_match_declaration_specifiers" ref="a2610a30f7c006f42b2f30f265b93e49" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_declaration_specifiers           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match declaration specifiers. Not yet implemented. 
<p>

</div>
</div><p>
<a class="anchor" name="699b8dc8f9b0c6259df7aea73784d45d"></a><!-- doxytag: member="AstFromString::afs_match_init_declarator_list" ref="699b8dc8f9b0c6259df7aea73784d45d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_init_declarator_list           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match an init declarator list. Not yet implemented. 
<p>

</div>
</div><p>
<a class="anchor" name="85d0ea63479b87f8b0e758b671e19045"></a><!-- doxytag: member="AstFromString::afs_match_init_declarator" ref="85d0ea63479b87f8b0e758b671e19045" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_init_declarator           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match init declarator. Not yet implemented. 
<p>

</div>
</div><p>
<a class="anchor" name="980d054be0a0d7c22f2cdd4947650a43"></a><!-- doxytag: member="AstFromString::afs_match_storage_class_specifier" ref="980d054be0a0d7c22f2cdd4947650a43" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_storage_class_specifier           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match a storage class specifier. Not yet implemented. 
<p>

</div>
</div><p>
<a class="anchor" name="11b78ad746fb5b993b3e7c06ca7ccea3"></a><!-- doxytag: member="AstFromString::afs_match_type_specifier" ref="11b78ad746fb5b993b3e7c06ca7ccea3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_type_specifier           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match a type specifier : 'void' | 'char' | 'short' | 'int' | 'long' | 'float' | 'double' | 'signed' | 'unsigned' | struct_or_union_specifier | enum_specifier | type_id. The recognized type is stored in c_parsed_node. 
<p>

</div>
</div><p>
<a class="anchor" name="4e5f1c0435a73d7c7f59a04403648c79"></a><!-- doxytag: member="AstFromString::afs_match_specifier_qualifier_list" ref="4e5f1c0435a73d7c7f59a04403648c79" args="(std::vector&lt; SgNode * &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_specifier_qualifier_list           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match a list of specifiers and qualifiers : : ( type_qualifier | type_specifier )+. 
<p>

</div>
</div><p>
<a class="anchor" name="f3a0147793736529720ee0d205eb4605"></a><!-- doxytag: member="AstFromString::afs_match_type_qualifier" ref="f3a0147793736529720ee0d205eb4605" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_type_qualifier           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match a type qualifier : 'const' | 'volatile'. 
<p>

</div>
</div><p>
<a class="anchor" name="0d85361a2e72bdb7597bfae44bb9000d"></a><!-- doxytag: member="AstFromString::afs_match_type_name" ref="0d85361a2e72bdb7597bfae44bb9000d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_type_name           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match a type name : specifier_qualifier_list abstract_declarator? 
<p>

</div>
</div><p>
<a class="anchor" name="b2f7e408ebd42abd6a3f1524a9a40c4f"></a><!-- doxytag: member="AstFromString::afs_match_argument_expression_list" ref="b2f7e408ebd42abd6a3f1524a9a40c4f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_argument_expression_list           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Grammar: argument_expression_list : assignment_expression (',' assignment_expression)* one assignment_expression, followed by optionally arbitrary numbers of (',' assignment_expression). 
<p>

</div>
</div><p>
<a class="anchor" name="8ff708dd8c6a3b1d4e0ef24435ef57a0"></a><!-- doxytag: member="AstFromString::afs_match_additive_expression" ref="8ff708dd8c6a3b1d4e0ef24435ef57a0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_additive_expression           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Grammar: additive_expression : (multiplicative_expression) ('+' multiplicative_expression | '-' multiplicative_expression)*. 
<p>

</div>
</div><p>
<a class="anchor" name="b790e1f12bf6b12d05af38bf858d9f77"></a><!-- doxytag: member="AstFromString::afs_match_multiplicative_expression" ref="b790e1f12bf6b12d05af38bf858d9f77" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_multiplicative_expression           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
multiplicative_expression : (cast_expression) ('*' cast_expression | '/' cast_expression | '' cast_expression)* 
<p>

</div>
</div><p>
<a class="anchor" name="fb9988003ec258d5b1158320db512e6b"></a><!-- doxytag: member="AstFromString::afs_match_cast_expression" ref="fb9988003ec258d5b1158320db512e6b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_cast_expression           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
cast_expression : '(' type_name ')' cast_expression | unary_expression 
<p>

</div>
</div><p>
<a class="anchor" name="f3734616354c3caa2f606209dc5177e8"></a><!-- doxytag: member="AstFromString::afs_match_unary_expression" ref="f3734616354c3caa2f606209dc5177e8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_unary_expression           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
unary_expression : postfix_expression | INC_OP unary_expression | DEC_OP unary_expression | unary_operator cast_expression | SIZEOF unary_expression | SIZEOF '(' type_name ')' 
<p>

</div>
</div><p>
<a class="anchor" name="15123da9beb78f35c462ed98edca8642"></a><!-- doxytag: member="AstFromString::afs_match_postfix_expression" ref="15123da9beb78f35c462ed98edca8642" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_postfix_expression           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
postfix_expression : primary_expression ( '[' expression ']' | '(' ')' | '(' argument_expression_list ')' | '.' IDENTIFIER | '-&gt;' IDENTIFIER | '++' | '--' )* 
<p>

</div>
</div><p>
<a class="anchor" name="f42fbad2937c56dbf426299bc0ea8512"></a><!-- doxytag: member="AstFromString::afs_match_primary_expression" ref="f42fbad2937c56dbf426299bc0ea8512" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_primary_expression           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
primary_expression : IDENTIFIER | constant | '(' expression ')' 
<p>

</div>
</div><p>
<a class="anchor" name="22e93ed03cda1337021b9d19150e6823"></a><!-- doxytag: member="AstFromString::afs_match_constant" ref="22e93ed03cda1337021b9d19150e6823" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_constant           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Only integer constant is supported for now. Full grammar is constant : HEX_LITERAL | OCTAL_LITERAL | DECIMAL_LITERAL | CHARACTER_LITERAL | STRING_LITERAL | FLOATING_POINT_LITERAL. 
<p>

</div>
</div><p>
<a class="anchor" name="5da3da6c00c88c919b7e993859a6a03a"></a><!-- doxytag: member="AstFromString::afs_match_expression" ref="5da3da6c00c88c919b7e993859a6a03a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_expression           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
expression : assignment_expression (',' assignment_expression)*. Match one or more assignment_expression 
<p>

</div>
</div><p>
<a class="anchor" name="db9826b8265782cdc48caea38b4a274d"></a><!-- doxytag: member="AstFromString::afs_match_constant_expression" ref="db9826b8265782cdc48caea38b4a274d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_constant_expression           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
constant_expression : conditional_expression 
<p>

</div>
</div><p>
<a class="anchor" name="0bc445f47d61dd4f000f8f4b9c8847b8"></a><!-- doxytag: member="AstFromString::afs_match_assignment_expression" ref="0bc445f47d61dd4f000f8f4b9c8847b8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_assignment_expression           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
assignment_expression : lvalue assignment_operator assignment_expression | conditional_expression 
<p>

</div>
</div><p>
<a class="anchor" name="456363ab176f7bd2e416e24a9bb66609"></a><!-- doxytag: member="AstFromString::afs_match_lvalue" ref="456363ab176f7bd2e416e24a9bb66609" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_lvalue           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lvalue: unary_expression 
<p>

</div>
</div><p>
<a class="anchor" name="d458e39d03f3b271a7de89ca1be1d700"></a><!-- doxytag: member="AstFromString::afs_match_conditional_expression" ref="d458e39d03f3b271a7de89ca1be1d700" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_conditional_expression           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
conditional_expression : logical_or_expression ('?' expression ':' conditional_expression)? '?' means 0 or 1 occurrence 
<p>

</div>
</div><p>
<a class="anchor" name="05197a45404734e6fff0bcf7c1c27891"></a><!-- doxytag: member="AstFromString::afs_match_logical_or_expression" ref="05197a45404734e6fff0bcf7c1c27891" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_logical_or_expression           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
logical_or_expression : logical_and_expression ('||' logical_and_expression)* 
<p>

</div>
</div><p>
<a class="anchor" name="e5203e84707829c1894962029bec667a"></a><!-- doxytag: member="AstFromString::afs_match_logical_and_expression" ref="e5203e84707829c1894962029bec667a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_logical_and_expression           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
logical_and_expression : inclusive_or_expression ('&amp;&amp;' inclusive_or_expression)* 
<p>

</div>
</div><p>
<a class="anchor" name="5a44009993b03d6dbffd3804f22b4102"></a><!-- doxytag: member="AstFromString::afs_match_inclusive_or_expression" ref="5a44009993b03d6dbffd3804f22b4102" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_inclusive_or_expression           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
inclusive_or_expression : exclusive_or_expression ('|' exclusive_or_expression)* 
<p>

</div>
</div><p>
<a class="anchor" name="3dfd5735e6a8b871ab0919e1b7e16b7d"></a><!-- doxytag: member="AstFromString::afs_match_exclusive_or_expression" ref="3dfd5735e6a8b871ab0919e1b7e16b7d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_exclusive_or_expression           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
exclusive_or_expression : and_expression ('^' and_expression)* 
<p>

</div>
</div><p>
<a class="anchor" name="1c2994badc59ec172a4246a27b1ff8e9"></a><!-- doxytag: member="AstFromString::afs_match_and_expression" ref="1c2994badc59ec172a4246a27b1ff8e9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_and_expression           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
and_expression : equality_expression ('&amp;' equality_expression)* 
<p>

</div>
</div><p>
<a class="anchor" name="3d5da6b7003e1f23f800e4b318a98d67"></a><!-- doxytag: member="AstFromString::afs_match_equality_expression" ref="3d5da6b7003e1f23f800e4b318a98d67" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_equality_expression           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
equality_expression : relational_expression (('=='|'!=') relational_expression)* 
<p>

</div>
</div><p>
<a class="anchor" name="841d1f4cd3da31ad6e58e0a6c5df1e82"></a><!-- doxytag: member="AstFromString::afs_match_relational_expression" ref="841d1f4cd3da31ad6e58e0a6c5df1e82" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_relational_expression           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
relational_expression : shift_expression (('&lt;'|'&gt;'|'&lt;='|'&gt;=') shift_expression)* 
<p>

</div>
</div><p>
<a class="anchor" name="2ee5e90fe38fca83e116a6ad5f720b0f"></a><!-- doxytag: member="AstFromString::afs_match_shift_expression" ref="2ee5e90fe38fca83e116a6ad5f720b0f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_shift_expression           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
shift_expression : additive_expression (('&lt;&lt;'|'&gt;&gt;') additive_expression)* 
<p>

</div>
</div><p>
<a class="anchor" name="f90e6b9eebdaabd1f7967f8787439634"></a><!-- doxytag: member="AstFromString::afs_match_statement" ref="f90e6b9eebdaabd1f7967f8787439634" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_statement           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
match any statement, not complete yet. Don't use it yet . : labeled_statement | compound_statement | expression_statement | selection_statement | iteration_statement | jump_statement 
<p>

</div>
</div><p>
<a class="anchor" name="341d881e4cb7e51b45642b243e131f54"></a><!-- doxytag: member="AstFromString::afs_match_labeled_statement" ref="341d881e4cb7e51b45642b243e131f54" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_labeled_statement           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match labeled statement : IDENTIFIER ':' statement | 'case' constant_expression ':' statement | 'default' ':' statement. 
<p>

</div>
</div><p>
<a class="anchor" name="33d1694de5d8c3267437ade0d54503ee"></a><!-- doxytag: member="AstFromString::afs_match_compound_statement" ref="33d1694de5d8c3267437ade0d54503ee" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_compound_statement           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Not yet implemented. Match compound statement: '{' declaration* statement_list? '}'. 
<p>

</div>
</div><p>
<a class="anchor" name="9f71021a17ce4a74735ce161945aedd3"></a><!-- doxytag: member="AstFromString::afs_match_expression_statement" ref="9f71021a17ce4a74735ce161945aedd3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_expression_statement           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match expression statement: : ';' | expression ';'. 
<p>

</div>
</div><p>
<a class="anchor" name="010c4debe4214c19e8e57d6e9957cbc7"></a><!-- doxytag: member="AstFromString::afs_match_selection_statement" ref="010c4debe4214c19e8e57d6e9957cbc7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_selection_statement           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match selection statement: IF '(' expression ')' statement | IF '(' expression ')' statement ELSE statement | SWITCH '(' expression ')' statement. 
<p>

</div>
</div><p>
<a class="anchor" name="5562f2db0432968a76bad994ebe2eee2"></a><!-- doxytag: member="AstFromString::afs_match_iteration_statement" ref="5562f2db0432968a76bad994ebe2eee2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_iteration_statement           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match an iteration statement: : 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'for' '(' expression_statement expression_statement expression? ')' statement. 
<p>

</div>
</div><p>
<a class="anchor" name="ab86f0076ee748c6509d7388a3a1d77a"></a><!-- doxytag: member="AstFromString::afs_match_jump_statement" ref="ab86f0076ee748c6509d7388a3a1d77a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AstFromString::afs_match_jump_statement           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match a jump statement : 'goto' IDENTIFIER ';' | 'continue' ';' | 'break' ';' | 'return' ';' | 'return' expression ';'. 
<p>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="40c060440fd38cf16b94e53c857b0ab8"></a><!-- doxytag: member="AstFromString::c_char" ref="40c060440fd38cf16b94e53c857b0ab8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="namespaceAstFromString.html#40c060440fd38cf16b94e53c857b0ab8">AstFromString::c_char</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A namespace scope char* to avoid passing and returning a target c string for every and each function current characters being scanned, what is pointed is const, the pointer itself is not const. 
<p>

</div>
</div><p>
<a class="anchor" name="d0a195aa797474256eb6a247c5785096"></a><!-- doxytag: member="AstFromString::c_sgnode" ref="d0a195aa797474256eb6a247c5785096" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgNode.html">SgNode</a>* <a class="el" href="namespaceAstFromString.html#d0a195aa797474256eb6a247c5785096">AstFromString::c_sgnode</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
current anchor <a class="el" href="classSgNode.html">SgNode</a> associated with parsing. It will serve as a start point to find enclosing scopes for resolving identifiers/symbols 
<p>

</div>
</div><p>
<a class="anchor" name="fa86836cff8cafbe2defb54470659310"></a><!-- doxytag: member="AstFromString::c_parsed_node" ref="fa86836cff8cafbe2defb54470659310" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgNode.html">SgNode</a>* <a class="el" href="namespaceAstFromString.html#fa86836cff8cafbe2defb54470659310">AstFromString::c_parsed_node</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Store the AST substree (expression, statement) generated from a helper function. 
<p>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
