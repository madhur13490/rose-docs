<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: BinaryAnalysis::InstructionSemantics Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li id="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="namespaces.html"><span>Namespace List</span></a></li>
    <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceBinaryAnalysis.html">BinaryAnalysis</a>::<a class="el" href="namespaceBinaryAnalysis_1_1InstructionSemantics.html">InstructionSemantics</a></div>
<h1>BinaryAnalysis::InstructionSemantics Namespace Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Binary instruction semantics. 
<p>
Entities in this namespace deal with the semantics of machine instructions, and with the process of "executing" a machine instruction in a particular semantic domain. Instruction "execution" is a very broad term and can refer to execution in the tranditional sense where each instruction modifies the machine state (registers and memory) in a particular domain (concrete, interval, sign, symbolic, user-defined). But it can also refer to any kind of analysis that depends on semantics of individual machine instructions (def-use, taint, etc). It can even refer to the transformation of machine instructions in <a class="el" href="namespaceROSE.html">ROSE</a> internal representation to some other representation (e.g., <a class="el" href="namespaceROSE.html">ROSE</a> RISC or LLVM) where the other representation is built by "executing" the instruction.<h2><a class="anchor" name="IS1">
Components of instruction semantics</a></h2>
ROSE's binary semantics framework has two major components: the dispatchers and the semantic domains. The instruction dispatcher "executes" a machine instruction by translating it into a sequence of RISC-like operations, and the semantics domain defines what the RISC-operators do (e.g., change a concrete machine state, produce an output listing of RISC operations, build an LLVM representation).<p>
The <em>dispatcher</em> is a class template and <a class="el" href="namespaceROSE.html">ROSE</a> defines one per machine architecture. In this respect, the dispatcher is akin to the microcontroller for a CISC architecture, such as the x86 microcontroller within an x86 CPU. The dispatcher implicitly defines the interface for the RISC operations, which are documented in the <a class="el" href="classBinaryAnalysis_1_1InstructionSemantics_1_1NullSemantics_1_1Policy.html">BinaryAnalysis::InstructionSemantics::NullSemantics::Policy</a> class. Users can subclass the dispatcher if they need to override how a machine instruction is translated into RISC operations. (Note: <a class="el" href="namespaceROSE.html">ROSE</a> might move away from the huge "switch" statement implementation to a table-driven approach, in which case subclassing of the entire dispatcher will likely be replaced by either modifying the dispatch table or by subclassing individual machine instruction classes.)<p>
The <em>semantic domain</em> is a loose term that refers to at least three parts taken as a whole: a value type, a machine state type, and a semantic policy. Semantic domains have names like "concrete domain", "interval domain", "sign domain", "symbolic domain", etc. The term is used loosely since one could have different implementations of, say, a "concrete domain" by instantiating slightly different versions of the dispatcher class template. For instance, one concrete domain might use the <a class="el" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1PartialSymbolicSemantics.html">PartialSymbolicSemantics</a> classes in a concrete way, while another might use custom classes tuned for higher performance. <a class="el" href="namespaceROSE.html">ROSE</a> defines a set of semantic domains--each defined by grouping its three components (value type, machine state type, and semantic policy) into a single name space or class.<p>
The <em>value type</em> of a semantic domain is a type (usually a class) that holds values for that domain. For instance, a concrete domain's value type would likely hold bit vectors of varying sizes. Instantiations of the value type are used for register contents, memory contents, memory addresses, and temporary values that exist during execution of a machine instruction. Value types are templates whose single parameter is the value width in bits. For instance, an x86 architecture needs values that are 1, 5, 8, 16, 32, and 64 bits wide (the 1-bit values are for Booleans in the EFLAGS register; the five-bit values are shift counts on a 32-bit architecutre; the 64-bit values are needed for integer multiply on a 32-bit architecture; this list is likely not exhaustive).<p>
As instructions execute they use inputs and generate outputs, which are read from and written to a <em>machine state</em>. The machine state consists of registers and memory, each of which holds a value which is instantiated from the domain's value type. Furthermore, memory addresses are also described by instances of the domain's value type (although internally, they can use a different type as long as a translation is provided to and from that type). The names and inter-relationships of the architectures registers are contained in a <a class="el" href="classRegisterDictionary.html">RegisterDictionary</a> while the state itself contains the values stored in those registers. The organization of registers and memory within the state is defined by the state. The state can choose to either provide an API to access the registers and memory, or it can be closely integrated with the semantic policy described next...<p>
The <em>semantic policy</em> class provides the implementations for the RISC operators and holds the machine's state upon which those operators operate. The policy class is provided as an argument to the dispatcher class template in order to instantiate a dispatcher with the specified RISC semantics. It is possible (and normal) to define multiple versions of a dispatcher each with a different semantic policy and each tuned for a specific kind of analysis.<h2><a class="anchor" name="IS2">
Nomenclature choice</a></h2>
The dispatcher class templates currently have names <a class="el" href="structBinaryAnalysis_1_1InstructionSemantics_1_1X86InstructionSemantics.html">X86InstructionSemantics</a>. We may change "Semantics" to "Dispatcher" since "semantics" is already present in the fully qualified name, and since "dispatcher" is a nounified verb that follows our naming convention yet hints at the action it intends to implement.<p>
The term "policy" will likely remain as is. The central idiom in policy-based design is a class template (called the "host class"; i.e., our dispatcher classes), taking several type parameters as input, which are instantiated with types selected by the user (called "policy classes"), each implementing a particular implicit interface (called a "policy"), and encapsulating some orthogonal (or mostly orthogonal) aspect of the behavior of the instantiated class. By supplying a host class combined with a set of different, canned implementations for each policy, a library or module can support an exponential number of different behavior combinations, resolved at compile time, and selected by mixing and matching the different supplied policy classes in the instantiation of the host class template. Additionally, by writing a custom implementation of a given policy, a policy-based library can be used in situations requiring behaviors unforeseen by the library implementor. Unlike mixins, policies often contain state variables (machine states in our case) and nested types (the value type in our case); unlike callbacks, policies typically contain several related functions (the RISC operators in our case).<h2><a class="anchor" name="IS3">
Specialization</a></h2>
The instruction semantics architecture is designed to allow users to specialize nearly every part of it. Most of the components are class templates whose arguments are types that provide mostly orthogonal parts of the templatized class. <a class="el" href="namespaceROSE.html">ROSE</a> defines triplets (value type, state type, semantic policy) that are designed to work together to implement a particular semantic domain, but users are free to replace or subclass any of those components to build customized semantic domains. For example, the x86 simulator (in "projects/simulator") subclasses the <a class="el" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1PartialSymbolicSemantics.html">PartialSymbolicSemantics</a> state in order to use memory mapped via ROSE's <a class="el" href="classMemoryMap.html">MemoryMap</a> class, and its policy in order to handle system calls (among other things).<h2><a class="anchor" name="IS4">
Future work</a></h2>
<em>Table-driven dispatch.</em> The current dispatchers are implemented with a huge switch statement selecting for each possible machine instruction. This design doesn't lend itself well to users being able to augment/override individual instructions, users adding new instructions, enabling large groups of instructions individually (e.g., SSE) to handle variations in machine architecture since each modification requires a subclass. The plan is to replace the large "switch" statement with a dispatch table and replace each "case" with a functor specific to that machine instruction. Users will be able to modify individual table entries, modify related groups of table entries, subclass functors for individual instructions, or define new functors. The functors will likely be class templates that take arguments similar to the dispatcher's class template.<p>
<em>Floating-point instructions.</em> Floating point registers are defined in the various <a class="el" href="classRegisterDictionary.html">RegisterDictionary</a> objects but none of the semantic states actually define space for them, and we haven't defined any floating-point RISC operations for policies to implement. As for existing machine instructions, the dispatchers will translate machine floating point instructions to RISC operations, and the specifics of those operations will be defined by the various semantic policies. For instance, the policy for a concrete semantic domain might use the host machine's native IEEE floating point to emulate the target machine's floating-point operations.<h2><a class="anchor" name="IS5">
Example</a></h2>
See actual source code for examples since this interface is an active area of <a class="el" href="namespaceROSE.html">ROSE</a> development (Dec-2012). In order to use one of ROSE's predefined semantic domains you'll likely need to define some types and variables, something along these lines:<p>
<div class="fragment"><pre class="fragment">   <span class="keyword">using namespace </span>BinaryAnalysis::InstructionSemantics;
   <span class="keyword">typedef</span> SymbolicSemantics::Policy&lt;&gt; Policy;
   <span class="keyword">typedef</span> X86InstructionSemantics&lt;Policy, SymbolicSemantics::ValueType&gt; Dispatcher;
   Policy policy;
   Dispatcher dispatcher(policy);
</pre></div><p>
In order to analyze a sequence of instructions, one calls the dispatcher's processInstruction() method one instruction at a time. The dispatcher breaks the instruction down into a sequence of RISC-like operations and invokes those operations in the policy. The policy's operations produce domain-specific result values and/or update the state (registers, memory, etc) associated with the policy. Each policy provides methods by which the user can inspect and/or modify the state. In fact, in order to follow flow-of-control from one instruction to another, it is customary to read the x86 EIP (instruction pointer register) value to get the address for the next instruction fetch.<p>
One can find actual uses of instruction semantics in <a class="el" href="namespaceROSE.html">ROSE</a> by searching for <a class="el" href="structBinaryAnalysis_1_1InstructionSemantics_1_1X86InstructionSemantics.html">X86InstructionSemantics</a>. Also, the simulator project (in projects/simulator) has many examples how to use instruction semantics--in fact, the simulator defines its own concrete domain by subclassing <a class="el" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1PartialSymbolicSemantics.html">PartialSymbolicSemantics</a> in order to execute specimen programs. 
<p>

<p>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1InstructionSemantics_1_1Interval.html">Interval</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classRange.html">Range</a> of possible values.  <a href="classBinaryAnalysis_1_1InstructionSemantics_1_1Interval.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics.html">MultiSemantics</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Semantic domain composed of sub-domains.  <a href="classBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBinaryAnalysis_1_1InstructionSemantics_1_1X86InstructionSemantics.html">X86InstructionSemantics</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translation class.  <a href="structBinaryAnalysis_1_1InstructionSemantics_1_1X86InstructionSemantics.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1BaseSemantics.html">BaseSemantics</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base classes for instruction semantics. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1IntervalSemantics.html">IntervalSemantics</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An interval analysis semantic domain. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1NullSemantics.html">NullSemantics</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Semantic domain that does nothing, but is well documented. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1PartialSymbolicSemantics.html">PartialSymbolicSemantics</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A fast, partially symbolic semantic domain. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html">SymbolicSemantics</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A fully symbolic semantic domain. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classRangeMap.html">RangeMap</a>&lt; <a class="el" href="classBinaryAnalysis_1_1InstructionSemantics_1_1Interval.html">Interval</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBinaryAnalysis_1_1InstructionSemantics.html#fdf5078bf4c716828b56ba6951c4a895">Intervals</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set of intervals.  <a href="#fdf5078bf4c716828b56ba6951c4a895"></a><br></td></tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="fdf5078bf4c716828b56ba6951c4a895"></a><!-- doxytag: member="BinaryAnalysis::InstructionSemantics::Intervals" ref="fdf5078bf4c716828b56ba6951c4a895" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classRangeMap.html">RangeMap</a>&lt;<a class="el" href="classBinaryAnalysis_1_1InstructionSemantics_1_1Interval.html">Interval</a>&gt; <a class="el" href="classRangeMap.html">BinaryAnalysis::InstructionSemantics::Intervals</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set of intervals. 
<p>

<p>
Definition at line <a class="el" href="IntervalSemantics_8h-source.html#l00077">77</a> of file <a class="el" href="IntervalSemantics_8h-source.html">IntervalSemantics.h</a>.
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
