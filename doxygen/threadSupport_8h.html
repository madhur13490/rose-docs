<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: threadSupport.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>threadSupport.h File Reference</h1>
<p>
<code>#include &quot;rosePublicConfig.h&quot;</code><br>
<code>#include &lt;assert.h&gt;</code><br>
<code>#include &lt;stdint.h&gt;</code><br>
<code>#include &lt;stdio.h&gt;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;string&gt;</code><br>
<code>#include &lt;pthread.h&gt;</code><br>

<p>
Include dependency graph for threadSupport.h:<p><center><img src="threadSupport_8h__incl.png" border="0" usemap="#threadSupport.h_map" alt=""></center>

<p>
This graph shows which files directly or indirectly include this file:<p><center><img src="threadSupport_8h__dep__incl.png" border="0" usemap="#threadSupport.hdep_map" alt=""></center>
<map name="threadSupport.hdep_map">
<area href="Disassembler_8h.html" shape="rect" coords="176,369,296,396" alt="">
<area href="SMTSolver_8h.html" shape="rect" coords="187,597,285,624" alt="">
<area href="callbacks_8h.html" shape="rect" coords="189,180,283,207" alt="">
<area href="Partitioner_8h.html" shape="rect" coords="397,91,493,117" alt="">
<area href="Disassembler_8C.html" shape="rect" coords="833,141,953,168" alt="">
<area href="DisassemblerArm_8C.html" shape="rect" coords="819,369,968,396" alt="">
<area href="DisassemblerX86_8C.html" shape="rect" coords="820,445,967,472" alt="">
<area href="SgAsmArmInstruction_8C.html" shape="rect" coords="359,496,532,523" alt="">
<area href="SgAsmPowerpcInstruction_8C.html" shape="rect" coords="345,344,545,371" alt="">
<area href="SgAsmX86Instruction_8C.html" shape="rect" coords="597,597,768,624" alt="">
<area href="AsmUnparser_8h.html" shape="rect" coords="385,268,505,295" alt="">
<area href="Partitioner_8C.html" shape="rect" coords="845,40,941,67" alt="">
<area href="binary__analysis_8h.html" shape="rect" coords="617,40,748,67" alt="">
<area href="AsmUnparser__compat_8h.html" shape="rect" coords="595,344,771,371" alt="">
<area href="AsmUnparser_8C.html" shape="rect" coords="833,243,953,269" alt="">
<area href="unparseX86Asm_8C.html" shape="rect" coords="612,243,753,269" alt="">
<area href="unparsePowerpcAsm_8C.html" shape="rect" coords="597,293,768,320" alt="">
<area href="SymbolicSemantics_8h.html" shape="rect" coords="365,597,525,624" alt="">
<area href="YicesSolver_8h.html" shape="rect" coords="393,648,497,675" alt="">
<area href="YicesSolver_8C.html" shape="rect" coords="629,648,736,675" alt="">
<area href="AsmFunctionIndex_8h.html" shape="rect" coords="371,40,520,67" alt="">
</map>

<p>
<a href="threadSupport_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTS__mutex__t.html">RTS_mutex_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mutual exclusion lock.  <a href="structRTS__mutex__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTS__rwlock__t.html">RTS_rwlock_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A read-write lock for <a class="el" href="namespaceROSE.html">ROSE</a> Thread Support.  <a href="structRTS__rwlock__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTS__Message.html">RTS_Message</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Support for messages in a multi-threaded program.  <a href="classRTS__Message.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTS__Message_1_1Prefix.html">RTS_Message::Prefix</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classRTS__Message_1_1Prefix.html">Prefix</a> class is used to generate prefix text for every line of output.  <a href="classRTS__Message_1_1Prefix.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#5ca53bbe32dc002e954181609be3ec66">RTS_MESSAGE</a>(MESG)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides a locked context for messaging.  <a href="#5ca53bbe32dc002e954181609be3ec66"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#1fcd3d707a6ae1e755f0e3a9019adbfa">RTS_MESSAGE_END</a>(SOL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides a locked context for messaging.  <a href="#1fcd3d707a6ae1e755f0e3a9019adbfa"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#792beae2b8dd41178941f43fd9846f25">ROSE_THREADS_ENABLED</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#bb3dc4d97954bae840202427027e33ae">ROSE_THREADS_POSIX</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#e38269e003df2431ff43e7fab618d8cd">RTS_MUTEX</a>(MUTEX)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Protect a critical section with a mutual exclusion lock.  <a href="#e38269e003df2431ff43e7fab618d8cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#aaa39a48f69302ebfea6780090e1e198">RTS_MUTEX_END</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">End an RTS_MUTEX construct.  <a href="#aaa39a48f69302ebfea6780090e1e198"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#652c960b2ca57973e1422b29d7251a49">RTS_MUTEX_MAGIC</a>&nbsp;&nbsp;&nbsp;0x1a95a713</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#030bdc54eda342fca5df6aa60412ac55">RTS_MUTEX_INITIALIZER</a>(LAYER)&nbsp;&nbsp;&nbsp;{ RTS_MUTEX_MAGIC, (LAYER), PTHREAD_MUTEX_INITIALIZER }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#333c7a83dea3fbceabd87927f0a6e31c">RTS_RWLOCK</a>(RWLOCK, HOW)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Protect a critical section with a read-write lock.  <a href="#333c7a83dea3fbceabd87927f0a6e31c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#ecce636d5a02a2a0dbce4a8aeee89193">RTS_RWLOCK_END</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#a506b9c66d1b333296b3f1b5760f6c1b">RTS_READ</a>(RWLOCK)&nbsp;&nbsp;&nbsp;RTS_RWLOCK(RWLOCK, rdlock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See RTS_RWLOCK.  <a href="#a506b9c66d1b333296b3f1b5760f6c1b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#fe189a5161d2a92492f8e22f387f79df">RTS_READ_END</a>&nbsp;&nbsp;&nbsp;RTS_RWLOCK_END</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See RTS_RWLOCK.  <a href="#fe189a5161d2a92492f8e22f387f79df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#8c6d4b12e773b1acfb142ca2d9be833f">RTS_WRITE</a>(RWLOCK)&nbsp;&nbsp;&nbsp;RTS_RWLOCK(RWLOCK, wrlock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See RTS_RWLOCK.  <a href="#8c6d4b12e773b1acfb142ca2d9be833f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#4276ab9ab62a7a797f8a64e963e0e9fa">RTS_WRITE_END</a>&nbsp;&nbsp;&nbsp;RTS_RWLOCK_END</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See RTS_RWLOCK.  <a href="#4276ab9ab62a7a797f8a64e963e0e9fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#8a8c3d20eeccf16020067805b056bd2f">RTS_RWLOCK_MAGIC</a>&nbsp;&nbsp;&nbsp;0x20e7f3f4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#a91efd4dbd3bb6664418a7fcd128544f">RTS_RWLOCK_INITIALIZER</a>(LAYER)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Static initializer for an <a class="el" href="structRTS__rwlock__t.html">RTS_rwlock_t</a> instance, similar in nature to PTHREAD_RWLOCK_INITIALIZER.  <a href="#a91efd4dbd3bb6664418a7fcd128544f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#626807a014a5c4ad9ea94e7c6bfb0d8c">RTS_INIT</a>(MUTEX, ALLOW_RECURSION)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializer synchronization.  <a href="#626807a014a5c4ad9ea94e7c6bfb0d8c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#54294de9405d4d40dd7fd9890dd09096">RTS_INIT_END</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">End an RTS_INIT construct.  <a href="#54294de9405d4d40dd7fd9890dd09096"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#d9802e9ddf3622fe5fc89638403b3aa1">RTS_INIT_RECURSIVE</a>(MUTEX)&nbsp;&nbsp;&nbsp;RTS_INIT(MUTEX, true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See RTS_INIT.  <a href="#d9802e9ddf3622fe5fc89638403b3aa1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#5e9a828fc3c6236d1da69cbcb1c2b55d">RTS_INIT_NONRECURSIVE</a>(MUTEX)&nbsp;&nbsp;&nbsp;RTS_INIT(MUTEX, false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">See RTS_INIT.  <a href="#5e9a828fc3c6236d1da69cbcb1c2b55d"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e66">RTS_Layer</a> { <br>
&nbsp;&nbsp;<a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e665e209625091af5bb4e402d758dfe7ed8">RTS_LAYER_DONTCARE</a> =  0, 
<br>
&nbsp;&nbsp;<a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e660aec3207859c61931aa5a288c7093242">RTS_LAYER_ROSE_CALLBACKS_LIST_OBJ</a> =  100, 
<br>
&nbsp;&nbsp;<a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e668d39869337b97ae353ea51674d341510">RTS_LAYER_RTS_MESSAGE_CLASS</a> =  105, 
<br>
&nbsp;&nbsp;<a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e667b779deca9fcf835fcac214d14630f44">RTS_LAYER_DISASSEMBLER_CLASS</a> =  110, 
<br>
&nbsp;&nbsp;<a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e661fa082d6132a6db8f1a7e01160ebeb3b">RTS_LAYER_ROSE_SMT_SOLVERS</a> =  115, 
<br>
&nbsp;&nbsp;<a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e66c85071f8aafdcc45a05e50aa2c02fa3f">RTS_LAYER_RSIM_SIGNALHANDLING_OBJ</a> =  200, 
<br>
&nbsp;&nbsp;<a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e66b1acff323bcaa7eea356283da8a6eb78">RTS_LAYER_RSIM_PROCESS_OBJ</a> =  201, 
<br>
&nbsp;&nbsp;<a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e66c4de666a6cbb30b9deec7590203ca9ae">RTS_LAYER_RSIM_PROCESS_CLONE_OBJ</a> =  202, 
<br>
&nbsp;&nbsp;<a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e66b2d15048229db5e0e2ccdcb39a65dc8c">RTS_LAYER_RSIM_THREAD_OBJ</a> =  203, 
<br>
&nbsp;&nbsp;<a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e662b54265640c74706fc85ddb0c87d67d2">RTS_LAYER_RSIM_THREAD_CLASS</a> =  204, 
<br>
&nbsp;&nbsp;<a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e66edd481d6fec092eb91a909466e120ae2">RTS_LAYER_RSIM_SYSCALLDISABLER_OBJ</a> =  205, 
<br>
&nbsp;&nbsp;<a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e661f3f01517238c0373d8e25fe288dfa3b">RTS_LAYER_RSIM_TRACEIO_OBJ</a> =  206, 
<br>
&nbsp;&nbsp;<a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e66d6432f3135595194de4ac661bf7a0ed2">RTS_LAYER_RSIM_SIMULATOR_CLASS</a> =  207, 
<br>
&nbsp;&nbsp;<a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e66ff9448d8bb81a8cd86b93ba1d0565ad6">RTS_LAYER_RSIM_SIMULATOR_OBJ</a> =  208, 
<br>
&nbsp;&nbsp;<a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e660691b07b993be20e6939e60a26b2f121">RTS_LAYER_USER_MIN</a> =  250, 
<br>
&nbsp;&nbsp;<a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e664875004500c6207be99005d90a62d50c">RTS_LAYER_USER_MAX</a> =  299, 
<br>
&nbsp;&nbsp;<a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e662c35e16828c5bfb068ff794c04d6d7ef">RTS_LAYER_NLAYERS</a> =  300
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Layers where syncrhonization primitives are defined.  <a href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e66">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#d2c4328b3b8b370126e47d3119a0f07f">RTS_acquiring</a> (<a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e66">RTS_Layer</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check for layering violations.  <a href="#d2c4328b3b8b370126e47d3119a0f07f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#8a2a092ecc1774deb0c34b0bf5083f63">RTS_releasing</a> (<a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e66">RTS_Layer</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notes the release of a lock.  <a href="#8a2a092ecc1774deb0c34b0bf5083f63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#b3a418d4d1a65645192cd924c5c5a915">RTS_mutex_init</a> (<a class="el" href="structRTS__mutex__t.html">RTS_mutex_t</a> *, <a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e66">RTS_Layer</a>, pthread_mutexattr_t *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a mutual exclusion lock.  <a href="#b3a418d4d1a65645192cd924c5c5a915"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#a3303f66060397d3b30b274b8af734d0">RTS_mutex_lock</a> (<a class="el" href="structRTS__mutex__t.html">RTS_mutex_t</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain an exclusive lock.  <a href="#a3303f66060397d3b30b274b8af734d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#af26a49bd51454c12b82afb6e43482e3">RTS_mutex_unlock</a> (<a class="el" href="structRTS__mutex__t.html">RTS_mutex_t</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release an exclusive lock.  <a href="#af26a49bd51454c12b82afb6e43482e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#6a1ab8cc7d7036b338001c45c4012f32">RTS_rwlock_init</a> (<a class="el" href="structRTS__rwlock__t.html">RTS_rwlock_t</a> *rwlock, <a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e66">RTS_Layer</a>, pthread_rwlockattr_t *wrlock_attrs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intializes an <a class="el" href="structRTS__rwlock__t.html">RTS_rwlock_t</a> in a manner similar to pthread_rwlock_init().  <a href="#6a1ab8cc7d7036b338001c45c4012f32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#c011afd117f0bc44a89339a0b8c1ad06">RTS_rwlock_rdlock</a> (<a class="el" href="structRTS__rwlock__t.html">RTS_rwlock_t</a> *rwlock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a read lock.  <a href="#c011afd117f0bc44a89339a0b8c1ad06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#f83173e18c286c3dc716dd0dadd0a808">RTS_rwlock_wrlock</a> (<a class="el" href="structRTS__rwlock__t.html">RTS_rwlock_t</a> *rwlock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a write lock.  <a href="#f83173e18c286c3dc716dd0dadd0a808"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="threadSupport_8h.html#237d9b798a0cc406ac5a4b85ed571a53">RTS_rwlock_unlock</a> (<a class="el" href="structRTS__rwlock__t.html">RTS_rwlock_t</a> *rwlock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release a read or write lock.  <a href="#237d9b798a0cc406ac5a4b85ed571a53"></a><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="792beae2b8dd41178941f43fd9846f25"></a><!-- doxytag: member="threadSupport.h::ROSE_THREADS_ENABLED" ref="792beae2b8dd41178941f43fd9846f25" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ROSE_THREADS_ENABLED          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="threadSupport_8h-source.html#l00036">36</a> of file <a class="el" href="threadSupport_8h-source.html">threadSupport.h</a>.
</div>
</div><p>
<a class="anchor" name="bb3dc4d97954bae840202427027e33ae"></a><!-- doxytag: member="threadSupport.h::ROSE_THREADS_POSIX" ref="bb3dc4d97954bae840202427027e33ae" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ROSE_THREADS_POSIX          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="threadSupport_8h-source.html#l00037">37</a> of file <a class="el" href="threadSupport_8h-source.html">threadSupport.h</a>.
</div>
</div><p>
<a class="anchor" name="e38269e003df2431ff43e7fab618d8cd"></a><!-- doxytag: member="threadSupport.h::RTS_MUTEX" ref="e38269e003df2431ff43e7fab618d8cd" args="(MUTEX)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTS_MUTEX          </td>
          <td>(</td>
          <td class="paramtype">MUTEX&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {        <span class="comment">/* standard CPP macro protection */</span>                                                                            \
        <a class="code" href="structRTS__mutex__t.html">RTS_mutex_t</a> *RTS_Mp_mutex = &amp;(MUTEX); <span class="comment">/* saved for when we need to unlock it */</span>                                        \
        <span class="keywordtype">int</span> RTS_Mp_err = <a class="code" href="threadSupport_8h.html#a3303f66060397d3b30b274b8af734d0">RTS_mutex_lock</a>(RTS_Mp_mutex);                                                                         \
        assert(0==RTS_Mp_err);                                                                                                 \
        <span class="keywordflow">do</span> {    <span class="comment">/* so we can catch "break" statements */</span>                                                                       \
            <span class="keywordflow">try</span> {
</pre></div>Protect a critical section with a mutual exclusion lock. 
<p>
This macro should be used within <a class="el" href="namespaceROSE.html">ROSE</a> whenever we need to obtain a lock for a critical section. The critical section should end with a matching RTS_MUTEX_END macro. The suggested code style is to use curly braces and indentation to help visually line up the RTS_MUTEX with the RTS_MUTEX_END, such as:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="threadSupport_8h.html#e38269e003df2431ff43e7fab618d8cd">RTS_MUTEX</a>(class_mutex) {
      critical_section_goes_here;
  } <a class="code" href="threadSupport_8h.html#aaa39a48f69302ebfea6780090e1e198">RTS_MUTEX_END</a>;
</pre></div><p>
The critical section should not exit the construct except through the RTS_MUTEX_END macro. In other words, the critical section should not have "return" statements, longjmps, or any "goto" that branches outside the critical section. However, "break" statements and exceptions are supported.<p>
If the mutex is an error checking mutex then <a class="el" href="namespaceROSE.html">ROSE</a> will assert that the lock is not already held by this thread. If the mutex is recursive then the lock will be obtained recursively if necessary. 
<p>
Definition at line <a class="el" href="threadSupport_8h-source.html#l00157">157</a> of file <a class="el" href="threadSupport_8h-source.html">threadSupport.h</a>.
<p>
Referenced by <a class="el" href="callbacks_8h-source.html#l00146">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::after()</a>, <a class="el" href="callbacks_8h-source.html#l00120">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::append()</a>, <a class="el" href="callbacks_8h-source.html#l00164">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::before()</a>, <a class="el" href="callbacks_8h-source.html#l00250">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::callbacks()</a>, <a class="el" href="callbacks_8h-source.html#l00240">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::clear()</a>, <a class="el" href="callbacks_8h-source.html#l00107">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::empty()</a>, <a class="el" href="callbacks_8h-source.html#l00212">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::erase()</a>, <a class="el" href="Disassembler_8C-source.html#l00172">Disassembler::lookup()</a>, <a class="el" href="callbacks_8h-source.html#l00133">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::prepend()</a>, <a class="el" href="Disassembler_8C-source.html#l00276">Disassembler::progress()</a>, <a class="el" href="Disassembler_8C-source.html#l00146">Disassembler::register_subclass()</a>, <a class="el" href="callbacks_8h-source.html#l00184">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::replace()</a>, <a class="el" href="Disassembler_8C-source.html#l00266">Disassembler::set_progress_reporting()</a>, and <a class="el" href="callbacks_8h-source.html#l00096">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::size()</a>.
</div>
</div><p>
<a class="anchor" name="aaa39a48f69302ebfea6780090e1e198"></a><!-- doxytag: member="threadSupport.h::RTS_MUTEX_END" ref="aaa39a48f69302ebfea6780090e1e198" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTS_MUTEX_END          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">} <span class="keywordflow">catch</span> (...) {                                                                                                    \
                RTS_Mp_err = <a class="code" href="threadSupport_8h.html#af26a49bd51454c12b82afb6e43482e3">RTS_mutex_unlock</a>(RTS_Mp_mutex);                                                                   \
                assert(0==RTS_Mp_err);                                                                                         \
                <span class="keywordflow">throw</span>;                                                                                                         \
            }                                                                                                                  \
        } <span class="keywordflow">while</span> (0);                                                                                                           \
        RTS_Mp_err = <a class="code" href="threadSupport_8h.html#af26a49bd51454c12b82afb6e43482e3">RTS_mutex_unlock</a>(RTS_Mp_mutex);                                                                           \
        assert(0==RTS_Mp_err);                                                                                                 \
    } <span class="keywordflow">while</span> (0)
</pre></div>End an RTS_MUTEX construct. 
<p>

<p>
Definition at line <a class="el" href="threadSupport_8h-source.html#l00166">166</a> of file <a class="el" href="threadSupport_8h-source.html">threadSupport.h</a>.
<p>
Referenced by <a class="el" href="callbacks_8h-source.html#l00146">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::after()</a>, <a class="el" href="callbacks_8h-source.html#l00120">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::append()</a>, <a class="el" href="callbacks_8h-source.html#l00164">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::before()</a>, <a class="el" href="callbacks_8h-source.html#l00250">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::callbacks()</a>, <a class="el" href="callbacks_8h-source.html#l00240">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::clear()</a>, <a class="el" href="callbacks_8h-source.html#l00107">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::empty()</a>, <a class="el" href="callbacks_8h-source.html#l00212">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::erase()</a>, <a class="el" href="Disassembler_8C-source.html#l00172">Disassembler::lookup()</a>, <a class="el" href="callbacks_8h-source.html#l00133">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::prepend()</a>, <a class="el" href="Disassembler_8C-source.html#l00276">Disassembler::progress()</a>, <a class="el" href="Disassembler_8C-source.html#l00146">Disassembler::register_subclass()</a>, <a class="el" href="callbacks_8h-source.html#l00184">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::replace()</a>, <a class="el" href="Disassembler_8C-source.html#l00266">Disassembler::set_progress_reporting()</a>, and <a class="el" href="callbacks_8h-source.html#l00096">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::size()</a>.
</div>
</div><p>
<a class="anchor" name="652c960b2ca57973e1422b29d7251a49"></a><!-- doxytag: member="threadSupport.h::RTS_MUTEX_MAGIC" ref="652c960b2ca57973e1422b29d7251a49" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTS_MUTEX_MAGIC&nbsp;&nbsp;&nbsp;0x1a95a713          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="threadSupport_8h-source.html#l00187">187</a> of file <a class="el" href="threadSupport_8h-source.html">threadSupport.h</a>.
</div>
</div><p>
<a class="anchor" name="030bdc54eda342fca5df6aa60412ac55"></a><!-- doxytag: member="threadSupport.h::RTS_MUTEX_INITIALIZER" ref="030bdc54eda342fca5df6aa60412ac55" args="(LAYER)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTS_MUTEX_INITIALIZER          </td>
          <td>(</td>
          <td class="paramtype">LAYER&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;{ RTS_MUTEX_MAGIC, (LAYER), PTHREAD_MUTEX_INITIALIZER }</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="threadSupport_8h-source.html#l00201">201</a> of file <a class="el" href="threadSupport_8h-source.html">threadSupport.h</a>.
</div>
</div><p>
<a class="anchor" name="333c7a83dea3fbceabd87927f0a6e31c"></a><!-- doxytag: member="threadSupport.h::RTS_RWLOCK" ref="333c7a83dea3fbceabd87927f0a6e31c" args="(RWLOCK, HOW)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTS_RWLOCK          </td>
          <td>(</td>
          <td class="paramtype">RWLOCK,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HOW&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {        <span class="comment">/* standard CPP macro protection */</span>                                                                            \
        <a class="code" href="structRTS__rwlock__t.html">RTS_rwlock_t</a> *RTS_Wp_rwlock = &amp;(RWLOCK); <span class="comment">/* saved for when we need to unlock it */</span>                                     \
        <span class="keywordtype">int</span> RTS_Wp_err = RTS_rwlock_##HOW(RTS_Wp_rwlock);                                                                      \
        assert(0==RTS_Wp_err);                                                                                                 \
        <span class="keywordflow">do</span> {    <span class="comment">/* so we can catch "break" statements */</span>                                                                       \
            <span class="keywordflow">try</span> {
</pre></div>Protect a critical section with a read-write lock. 
<p>
These macros should be used within <a class="el" href="namespaceROSE.html">ROSE</a> whenever we need to protect a critical section among two kinds of access: reading and writing.<p>
This construct allows at most one thread to hold a write lock, or multiple threads to hold read locks. Write locks are granted only when no other thread holds a read or write lock, and a request for a write lock blocks (becomes pending) if the lock cannot be granted. Read locks are granted only when no write lock is already granted to another thread, and no write lock is pending.<p>
Like POSIX read-write locks, <a class="el" href="structRTS__rwlock__t.html">RTS_rwlock_t</a> allows a single thread to obtain multiple read locks recursively. Unlike POSIX read-write locks, <a class="el" href="structRTS__rwlock__t.html">RTS_rwlock_t</a> also allows the following:<p>
<ul>
<li>
A lock (read or write) is granted to a thread which already holds a write lock. The POSIX implementation deadlocks in this situation. This feature is useful in <a class="el" href="namespaceROSE.html">ROSE</a> when a read-write lock guards access to data members of an object, and the object methods can be invoked recursively. </li>
<li>
The <a class="el" href="threadSupport_8h.html#237d9b798a0cc406ac5a4b85ed571a53">RTS_rwlock_unlock()</a> function releases locks in the reverse order they were granted and should only be called by the thread to which the lock was granted. </li>
</ul>
<p>
In particular, this implementation does not allow a thread which holds only read locks to be granted a write lock (i.e., no lock upgrading). Like POSIX read-write locks, this situation will lead to deadlock.<p>
The RTS_READ macro should be paired with an RTS_READ_END macro; the RTS_WRITE macro should be paired with an RTS_WRITE_END macro. The RTS_RWLOCK macro is a generalization of RTS_READ and RTS_WRITE where its second argument is either the word "rdlock" or "wrlock", respectively. It should be paired with an RTS_RWLOCK_END macro.<p>
The critical section may exit only via "break" statement, throwing an exception, or falling through the end. Exceptions thrown by the critical section will release the lock before rethrowing the exception.<p>
A simple example demonstrating how locks can be obtained recursively. Any number of threads can be operating on a single, common object concurrently and each of the four defined operations remains atomic.<p>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Stack {
  <span class="keyword">public</span>:
      Stack() {
          <a class="code" href="threadSupport_8h.html#6a1ab8cc7d7036b338001c45c4012f32">RTS_rwlock_init</a>(&amp;rwlock, NULL);
      }
  
      MD5sum sum()<span class="keyword"> const </span>{
          MD5sum retval;
          <a class="code" href="threadSupport_8h.html#a506b9c66d1b333296b3f1b5760f6c1b">RTS_READ</a>(rwlock) {
              <span class="keywordflow">for</span> (size_t i=0; i&lt;stack.size(); i++)
                  retval.composite(stack[i]);
          } <a class="code" href="threadSupport_8h.html#fe189a5161d2a92492f8e22f387f79df">RTS_READ_END</a>;
          <span class="keywordflow">return</span> retval;
      }

      <span class="keywordtype">void</span> push(<span class="keyword">const</span> std::string &amp;s) {
          <a class="code" href="threadSupport_8h.html#8c6d4b12e773b1acfb142ca2d9be833f">RTS_WRITE</a>(rwlock) {
              stack.push_back(s);
          } <a class="code" href="threadSupport_8h.html#4276ab9ab62a7a797f8a64e963e0e9fa">RTS_WRITE_END</a>;
      }
  
      <span class="comment">// swap top and third from top; toss second from top</span>
      <span class="comment">// throw exception when stack becomes too small</span>
      <span class="keywordtype">void</span> adjust() {
          <a class="code" href="threadSupport_8h.html#8c6d4b12e773b1acfb142ca2d9be833f">RTS_WRITE</a>(rwlock) {
              std::string s1 = pop(); <span class="comment">// may throw</span>
              (void) pop();           <span class="comment">// may throw</span>
              std::string s2 = pop(); <span class="comment">// may throw</span>
              push(s1);
              push(s2);
          } <a class="code" href="threadSupport_8h.html#4276ab9ab62a7a797f8a64e963e0e9fa">RTS_WRITE_END</a>;
      }

      <span class="comment">// adjust() until sum specified termination condition</span>
      <span class="comment">// throw exception when stack becomes too small</span>
      <span class="keywordtype">void</span> adjust_until(<span class="keyword">const</span> MD5sum &amp;term) {
          <a class="code" href="threadSupport_8h.html#8c6d4b12e773b1acfb142ca2d9be833f">RTS_WRITE</a>(rwlock) {
              <span class="keywordflow">while</span> (sum()!=term)    <span class="comment">// recursive read lock</span>
                  adjust();          <span class="comment">// recursive write lock; may throw</span>
          } <a class="code" href="threadSupport_8h.html#4276ab9ab62a7a797f8a64e963e0e9fa">RTS_WRITE_END</a>;
      }
  
  <span class="keyword">private</span>:
      std::vector&lt;std::string&gt; stack;
      <span class="keyword">mutable</span> <a class="code" href="structRTS__rwlock__t.html">RTS_rwlock_t</a> rwlock;   <span class="comment">// mutable so sum() can be const as user would expect</span>
  };
</pre></div> 
<p>
Definition at line <a class="el" href="threadSupport_8h-source.html#l00315">315</a> of file <a class="el" href="threadSupport_8h-source.html">threadSupport.h</a>.
</div>
</div><p>
<a class="anchor" name="ecce636d5a02a2a0dbce4a8aeee89193"></a><!-- doxytag: member="threadSupport.h::RTS_RWLOCK_END" ref="ecce636d5a02a2a0dbce4a8aeee89193" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTS_RWLOCK_END          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">} <span class="keywordflow">catch</span> (...) {                                                                                                    \
                RTS_Wp_err = <a class="code" href="threadSupport_8h.html#237d9b798a0cc406ac5a4b85ed571a53">RTS_rwlock_unlock</a>(RTS_Wp_rwlock);                                                                 \
                assert(0==RTS_Wp_err);                                                                                         \
                <span class="keywordflow">throw</span>;                                                                                                         \
            }                                                                                                                  \
        } <span class="keywordflow">while</span> (0);                                                                                                           \
        RTS_Wp_err = <a class="code" href="threadSupport_8h.html#237d9b798a0cc406ac5a4b85ed571a53">RTS_rwlock_unlock</a>(RTS_Wp_rwlock);                                                                         \
        assert(0==RTS_Wp_err);                                                                                                 \
    } <span class="keywordflow">while</span> (0)
</pre></div>
<p>
Definition at line <a class="el" href="threadSupport_8h-source.html#l00323">323</a> of file <a class="el" href="threadSupport_8h-source.html">threadSupport.h</a>.
</div>
</div><p>
<a class="anchor" name="a506b9c66d1b333296b3f1b5760f6c1b"></a><!-- doxytag: member="threadSupport.h::RTS_READ" ref="a506b9c66d1b333296b3f1b5760f6c1b" args="(RWLOCK)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTS_READ          </td>
          <td>(</td>
          <td class="paramtype">RWLOCK&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;RTS_RWLOCK(RWLOCK, rdlock)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
See RTS_RWLOCK. 
<p>

<p>
Definition at line <a class="el" href="threadSupport_8h-source.html#l00341">341</a> of file <a class="el" href="threadSupport_8h-source.html">threadSupport.h</a>.
</div>
</div><p>
<a class="anchor" name="fe189a5161d2a92492f8e22f387f79df"></a><!-- doxytag: member="threadSupport.h::RTS_READ_END" ref="fe189a5161d2a92492f8e22f387f79df" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTS_READ_END&nbsp;&nbsp;&nbsp;RTS_RWLOCK_END          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
See RTS_RWLOCK. 
<p>

<p>
Definition at line <a class="el" href="threadSupport_8h-source.html#l00342">342</a> of file <a class="el" href="threadSupport_8h-source.html">threadSupport.h</a>.
</div>
</div><p>
<a class="anchor" name="8c6d4b12e773b1acfb142ca2d9be833f"></a><!-- doxytag: member="threadSupport.h::RTS_WRITE" ref="8c6d4b12e773b1acfb142ca2d9be833f" args="(RWLOCK)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTS_WRITE          </td>
          <td>(</td>
          <td class="paramtype">RWLOCK&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;RTS_RWLOCK(RWLOCK, wrlock)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
See RTS_RWLOCK. 
<p>

<p>
Definition at line <a class="el" href="threadSupport_8h-source.html#l00343">343</a> of file <a class="el" href="threadSupport_8h-source.html">threadSupport.h</a>.
</div>
</div><p>
<a class="anchor" name="4276ab9ab62a7a797f8a64e963e0e9fa"></a><!-- doxytag: member="threadSupport.h::RTS_WRITE_END" ref="4276ab9ab62a7a797f8a64e963e0e9fa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTS_WRITE_END&nbsp;&nbsp;&nbsp;RTS_RWLOCK_END          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
See RTS_RWLOCK. 
<p>

<p>
Definition at line <a class="el" href="threadSupport_8h-source.html#l00344">344</a> of file <a class="el" href="threadSupport_8h-source.html">threadSupport.h</a>.
</div>
</div><p>
<a class="anchor" name="8a8c3d20eeccf16020067805b056bd2f"></a><!-- doxytag: member="threadSupport.h::RTS_RWLOCK_MAGIC" ref="8a8c3d20eeccf16020067805b056bd2f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTS_RWLOCK_MAGIC&nbsp;&nbsp;&nbsp;0x20e7f3f4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="threadSupport_8h-source.html#l00372">372</a> of file <a class="el" href="threadSupport_8h-source.html">threadSupport.h</a>.
</div>
</div><p>
<a class="anchor" name="a91efd4dbd3bb6664418a7fcd128544f"></a><!-- doxytag: member="threadSupport.h::RTS_RWLOCK_INITIALIZER" ref="a91efd4dbd3bb6664418a7fcd128544f" args="(LAYER)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTS_RWLOCK_INITIALIZER          </td>
          <td>(</td>
          <td class="paramtype">LAYER&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{ <a class="code" href="threadSupport_8h.html#8a8c3d20eeccf16020067805b056bd2f">RTS_RWLOCK_MAGIC</a>,                                                                    \
                                          (LAYER),                                                                             \
                                          PTHREAD_RWLOCK_INITIALIZER,                                                          \
                                          <a class="code" href="threadSupport_8h.html#030bdc54eda342fca5df6aa60412ac55">RTS_MUTEX_INITIALIZER</a>(<a class="code" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e665e209625091af5bb4e402d758dfe7ed8">RTS_LAYER_DONTCARE</a>),                                           \
                                          0<span class="comment">/*...*/</span>                                                                             \
                                         }
</pre></div>Static initializer for an <a class="el" href="structRTS__rwlock__t.html">RTS_rwlock_t</a> instance, similar in nature to PTHREAD_RWLOCK_INITIALIZER. 
<p>

<p>
Definition at line <a class="el" href="threadSupport_8h-source.html#l00376">376</a> of file <a class="el" href="threadSupport_8h-source.html">threadSupport.h</a>.
</div>
</div><p>
<a class="anchor" name="626807a014a5c4ad9ea94e7c6bfb0d8c"></a><!-- doxytag: member="threadSupport.h::RTS_INIT" ref="626807a014a5c4ad9ea94e7c6bfb0d8c" args="(MUTEX, ALLOW_RECURSION)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTS_INIT          </td>
          <td>(</td>
          <td class="paramtype">MUTEX,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOW_RECURSION&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                                                                                                       \
        <span class="keyword">static</span> <span class="keywordtype">bool</span> RTS_Is_initialized=<span class="keyword">false</span>, RTS_Is_initializing=<span class="keyword">false</span>;        <span class="comment">/* "s"==shared; "p"=private */</span>                 \
        <span class="keyword">static</span> pthread_t RTS_Is_initializer;                                                                                   \
        <span class="keyword">static</span> pthread_cond_t RTS_Is_condition=PTHREAD_COND_INITIALIZER;                                                       \
        <a class="code" href="structRTS__mutex__t.html">RTS_mutex_t</a> *RTS_Ip_mutex = &amp;(MUTEX);                                                                                  \
        <span class="keywordtype">bool</span> RTS_Ip_initialized, RTS_Ip_initializing;                                                                          \
        <span class="keywordtype">bool</span> RTS_Ip_allow_recursion = (ALLOW_RECURSION);                                                                       \
                                                                                                                               \
        <span class="comment">/* First critical section is only to obtain the initialization status and update it to "initializing" if necessary. We \</span>
<span class="comment">         * must release the lock before the RTS_I_LOCK body is executed in case we need to handle recursive calls to the       \</span>
<span class="comment">         * RTS_I_LOCK construct. */</span>                                                                                            \
        <a class="code" href="threadSupport_8h.html#e38269e003df2431ff43e7fab618d8cd">RTS_MUTEX</a>(MUTEX) {                                                                                                     \
            <span class="keywordflow">if</span> (!(RTS_Ip_initialized=RTS_Is_initialized) &amp;&amp; !(RTS_Ip_initializing=RTS_Is_initializing)) {                      \
                RTS_Is_initializing = <span class="keyword">true</span>; <span class="comment">/* but leave private copy false so we can detect changed state */</span>                  \
                RTS_Is_initializer = pthread_self();                                                                           \
            }                                                                                                                  \
        } <a class="code" href="threadSupport_8h.html#aaa39a48f69302ebfea6780090e1e198">RTS_MUTEX_END</a>;                                                                                                       \
                                                                                                                               \
        <span class="keywordflow">if</span> (!RTS_Ip_initialized) {                                                                                             \
            <span class="keywordflow">if</span> (!RTS_Ip_initializing) {                                                                                        \
                <span class="keywordflow">do</span> { <span class="comment">/* so we catch "break" statements in user-supplied code. */</span>                                               \
                    <span class="keywordflow">try</span> {
</pre></div>Initializer synchronization. 
<p>
Sometimes we want a critical section to be executed only by the first thread to call the function and all other threads that might call the same function should block until the first caller completes. These macros can be used for that purpose.<p>
The MUTEX is briefly locked to inspect the state of initilization, and then unlocked before the user-supplied body is executed. The user is permitted to obtain the mutex lock again in the body if desired, although this is only necessary if other code paths (outside the RTS_INIT construct) might interfere with the body.<p>
If ALLOW_RECURSION is true, then a recursive call from the body will jump over the RTS_INIT construct without doing anything (other than briefly obtaining the mutex lock to inspect the state of initialization). Otherwise a recursive call from the body is considered a logic error and the process will be aborted. For convenience, we define two additional macros, RTS_INIT_RECURSIVE and RTS_INIT_NONRECURSIVE, which may be used in place of the two-argument RTS_INIT macro.<p>
The user-supplied body may exit prematurely either by a "break" statement or by throwing an exception. In either case, the initialization is assumed to have completed and the body will not be executed by any other future call. Any other kind of premature exit from the body (return, goto, longjmp, etc) results in undefined behavior.<p>
Example code. Consider a class method which is responsible for one-time initialization of certain class data structures. This initialization function is called by nearly every other method in the class, and therefore anything that the initialization function does might result in a recursive call to the initializer.<p>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">void</span>
  SomeClass::initclass()
  {
      <a class="code" href="threadSupport_8h.html#d9802e9ddf3622fe5fc89638403b3aa1">RTS_INIT_RECURSIVE</a>(class_mutex) {
          register_subclass(<span class="keyword">new</span> Subclass1);
          register_subclass(<span class="keyword">new</span> Subclass2);
          register_subclass(<span class="keyword">new</span> Subclass3);
      } <a class="code" href="threadSupport_8h.html#54294de9405d4d40dd7fd9890dd09096">RTS_INIT_END</a>;
  }
</pre></div> 
<p>
Definition at line <a class="el" href="threadSupport_8h-source.html#l00482">482</a> of file <a class="el" href="threadSupport_8h-source.html">threadSupport.h</a>.
</div>
</div><p>
<a class="anchor" name="54294de9405d4d40dd7fd9890dd09096"></a><!-- doxytag: member="threadSupport.h::RTS_INIT_END" ref="54294de9405d4d40dd7fd9890dd09096" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTS_INIT_END          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
End an RTS_INIT construct. 
<p>

<p>
Definition at line <a class="el" href="threadSupport_8h-source.html#l00506">506</a> of file <a class="el" href="threadSupport_8h-source.html">threadSupport.h</a>.
<p>
Referenced by <a class="el" href="Disassembler_8C-source.html#l00133">Disassembler::initclass()</a>.
</div>
</div><p>
<a class="anchor" name="d9802e9ddf3622fe5fc89638403b3aa1"></a><!-- doxytag: member="threadSupport.h::RTS_INIT_RECURSIVE" ref="d9802e9ddf3622fe5fc89638403b3aa1" args="(MUTEX)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTS_INIT_RECURSIVE          </td>
          <td>(</td>
          <td class="paramtype">MUTEX&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;RTS_INIT(MUTEX, true)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
See RTS_INIT. 
<p>

<p>
Definition at line <a class="el" href="threadSupport_8h-source.html#l00550">550</a> of file <a class="el" href="threadSupport_8h-source.html">threadSupport.h</a>.
<p>
Referenced by <a class="el" href="Disassembler_8C-source.html#l00133">Disassembler::initclass()</a>.
</div>
</div><p>
<a class="anchor" name="5e9a828fc3c6236d1da69cbcb1c2b55d"></a><!-- doxytag: member="threadSupport.h::RTS_INIT_NONRECURSIVE" ref="5e9a828fc3c6236d1da69cbcb1c2b55d" args="(MUTEX)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTS_INIT_NONRECURSIVE          </td>
          <td>(</td>
          <td class="paramtype">MUTEX&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;RTS_INIT(MUTEX, false)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
See RTS_INIT. 
<p>

<p>
Definition at line <a class="el" href="threadSupport_8h-source.html#l00551">551</a> of file <a class="el" href="threadSupport_8h-source.html">threadSupport.h</a>.
</div>
</div><p>
<a class="anchor" name="5ca53bbe32dc002e954181609be3ec66"></a><!-- doxytag: member="threadSupport.h::RTS_MESSAGE" ref="5ca53bbe32dc002e954181609be3ec66" args="(MESG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTS_MESSAGE          </td>
          <td>(</td>
          <td class="paramtype">MESG&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                                                                                                       \
        <a class="code" href="classRTS__Message.html">RTS_Message</a> *RTS_Mp_mesg = &amp;(MESG);                                                                                    \
        <span class="keywordtype">int</span> RTS_Mp_err = RTS_Mp_mesg-&gt;<a class="code" href="classRTS__Message.html#d9592ced2e906fb57fd2d8ac19143430">lock</a>();                                                                                  \
        assert(0==RTS_Mp_err);                                                                                                 \
        <span class="keywordflow">do</span> {                                                                                                                   \
            <span class="keywordflow">try</span> {
</pre></div>Provides a locked context for messaging. 
<p>
Normal message output methods do not require locking since they perform the locking implicitly. However, one needs to provide some kind of customized output not otherwise possible, a lock needs to be obtained while that output is produced. See RTS_Messsage::lock() for details.<p>
The RTS_MESSAGE macro takes an <a class="el" href="classRTS__Message.html">RTS_Message</a> object as an argument, and locks it until the corresponding RTS_MESSAGE_END macro. The RTS_MESSAGE_END macro takes one argument: a Boolean expression which evaluates to true if no output was produced or the output ended with a line-feed.<p>
The body between the RTS_MESSAGE and RTS_MESSAGE_END macro should not exit non-locally except by "break" or throwing an exception, both of which release the lock.<p>
Example:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classRTS__Message.html">RTS_Message</a> mesg(stderr, NULL);
  <a class="code" href="threadSupport_8h.html#5ca53bbe32dc002e954181609be3ec66">RTS_MESSAGE</a>(mesg) {
     <span class="keywordflow">for</span> (size_t i=0; i&lt;n; i++) {
         fprintf(stderr, <span class="stringliteral">"    arg(%d) = %d\n"</span>, i, arg[i]);
     }
  } <a class="code" href="threadSupport_8h.html#1fcd3d707a6ae1e755f0e3a9019adbfa">RTS_MESSAGE_END</a>(<span class="keyword">true</span>);
</pre></div><p>
Note that the previous example could have more easily been obtained with the following, except that in a multi-threaded application another thread might interject its own output between these lines. <div class="fragment"><pre class="fragment">  <a class="code" href="classRTS__Message.html">RTS_Message</a> mesg(stderr, NULL);
  <span class="keywordflow">for</span> (size_t i=0; i&lt;n; i++) {
      mesg.mesg(<span class="stringliteral">"    arg(%d) = %d\n"</span>, i, arg[i]);
  }
</pre></div> 
<p>
Definition at line <a class="el" href="threadSupport_8h-source.html#l00767">767</a> of file <a class="el" href="threadSupport_8h-source.html">threadSupport.h</a>.
</div>
</div><p>
<a class="anchor" name="1fcd3d707a6ae1e755f0e3a9019adbfa"></a><!-- doxytag: member="threadSupport.h::RTS_MESSAGE_END" ref="1fcd3d707a6ae1e755f0e3a9019adbfa" args="(SOL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTS_MESSAGE_END          </td>
          <td>(</td>
          <td class="paramtype">SOL&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">} <span class="keywordflow">catch</span> (...) {                                                                                                    \
                RTS_Mp_err = RTS_Mp_mesg-&gt;unlock((SOL));                                                                       \
                assert(0==RTS_Mp_err);                                                                                         \
                <span class="keywordflow">throw</span>;                                                                                                         \
            }                                                                                                                  \
        } <span class="keywordflow">while</span> (0);                                                                                                           \
        RTS_Mp_err = RTS_Mp_mesg-&gt;unlock((SOL));                                                                               \
        assert(0==RTS_Mp_err);                                                                                                 \
    } <span class="keywordflow">while</span> (0)
</pre></div>Provides a locked context for messaging. 
<p>
Normal message output methods do not require locking since they perform the locking implicitly. However, one needs to provide some kind of customized output not otherwise possible, a lock needs to be obtained while that output is produced. See RTS_Messsage::lock() for details.<p>
The RTS_MESSAGE macro takes an <a class="el" href="classRTS__Message.html">RTS_Message</a> object as an argument, and locks it until the corresponding RTS_MESSAGE_END macro. The RTS_MESSAGE_END macro takes one argument: a Boolean expression which evaluates to true if no output was produced or the output ended with a line-feed.<p>
The body between the RTS_MESSAGE and RTS_MESSAGE_END macro should not exit non-locally except by "break" or throwing an exception, both of which release the lock.<p>
Example:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classRTS__Message.html">RTS_Message</a> mesg(stderr, NULL);
  <a class="code" href="threadSupport_8h.html#5ca53bbe32dc002e954181609be3ec66">RTS_MESSAGE</a>(mesg) {
     <span class="keywordflow">for</span> (size_t i=0; i&lt;n; i++) {
         fprintf(stderr, <span class="stringliteral">"    arg(%d) = %d\n"</span>, i, arg[i]);
     }
  } <a class="code" href="threadSupport_8h.html#1fcd3d707a6ae1e755f0e3a9019adbfa">RTS_MESSAGE_END</a>(<span class="keyword">true</span>);
</pre></div><p>
Note that the previous example could have more easily been obtained with the following, except that in a multi-threaded application another thread might interject its own output between these lines. <div class="fragment"><pre class="fragment">  <a class="code" href="classRTS__Message.html">RTS_Message</a> mesg(stderr, NULL);
  <span class="keywordflow">for</span> (size_t i=0; i&lt;n; i++) {
      mesg.mesg(<span class="stringliteral">"    arg(%d) = %d\n"</span>, i, arg[i]);
  }
</pre></div> 
<p>
Definition at line <a class="el" href="threadSupport_8h-source.html#l00775">775</a> of file <a class="el" href="threadSupport_8h-source.html">threadSupport.h</a>.
</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="cdb719c4a573bf8cb5e26245cb1b2e66"></a><!-- doxytag: member="threadSupport.h::RTS_Layer" ref="cdb719c4a573bf8cb5e26245cb1b2e66" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e66">RTS_Layer</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Layers where syncrhonization primitives are defined. 
<p>
When a thread intends to acquire multiple locks at a time, it must acquire those locks in a particular order to prevent deadlock. Deadlock can occur when thread 1 attempts to acquire lock A and then B, while thread 2 attempts to acquire lock B and then A. By defining every lock to belong to a particular software layer, we can impose a partial ordering on the locks and enforce the requirement that a thread obtain locks in that order. To use the previous example, if lock A belongs to layer X and lock B to layer Y, then a rule that says "locks of layer X must be acquired before locks of layer Y when attempting to acquire both at once" would be sufficient to prevent deadlock. This mechanism makes no attempt to define an acquisition order for locks of the same layer (at least not at this time).<p>
When a thread acquires locks from more than one layer at a time, they must be acquired in descending order by layer (they can be released in any order). If a thread attempts to aquire a lock whose layer is greater than the minimum layer for which it already holds a lock, then an error message is emitted and the process aborts.<p>
New layers can be added to this enum and the RTS_LAYER_NLAYERS constant can be increased if necessary. When a layer's number is changed, all of <a class="el" href="namespaceROSE.html">ROSE</a> must be recompiled. The constant name is used in error messages. Names ending with "_CLASS" refer to synchronization primities that are class data members (or global), while those ending with "_OBJ" belong to a particular object.<p>
Layer zero is special and is the default layer for all syncronization primitives not explicitly associated with any layer. Locks in layer zero can be acquired in any order without generating an error message (so silent deadlock is a distinct possibility). <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="cdb719c4a573bf8cb5e26245cb1b2e665e209625091af5bb4e402d758dfe7ed8"></a><!-- doxytag: member="RTS_LAYER_DONTCARE" ref="cdb719c4a573bf8cb5e26245cb1b2e665e209625091af5bb4e402d758dfe7ed8" args="" -->RTS_LAYER_DONTCARE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="cdb719c4a573bf8cb5e26245cb1b2e660aec3207859c61931aa5a288c7093242"></a><!-- doxytag: member="RTS_LAYER_ROSE_CALLBACKS_LIST_OBJ" ref="cdb719c4a573bf8cb5e26245cb1b2e660aec3207859c61931aa5a288c7093242" args="" -->RTS_LAYER_ROSE_CALLBACKS_LIST_OBJ</em>&nbsp;</td><td>
<a class="el" href="classROSE__Callbacks_1_1List.html">ROSE_Callbacks::List</a> class. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="cdb719c4a573bf8cb5e26245cb1b2e668d39869337b97ae353ea51674d341510"></a><!-- doxytag: member="RTS_LAYER_RTS_MESSAGE_CLASS" ref="cdb719c4a573bf8cb5e26245cb1b2e668d39869337b97ae353ea51674d341510" args="" -->RTS_LAYER_RTS_MESSAGE_CLASS</em>&nbsp;</td><td>
<a class="el" href="classRTS__Message.html">RTS_Message</a> class. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="cdb719c4a573bf8cb5e26245cb1b2e667b779deca9fcf835fcac214d14630f44"></a><!-- doxytag: member="RTS_LAYER_DISASSEMBLER_CLASS" ref="cdb719c4a573bf8cb5e26245cb1b2e667b779deca9fcf835fcac214d14630f44" args="" -->RTS_LAYER_DISASSEMBLER_CLASS</em>&nbsp;</td><td>
<a class="el" href="classDisassembler.html">Disassembler</a> class. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="cdb719c4a573bf8cb5e26245cb1b2e661fa082d6132a6db8f1a7e01160ebeb3b"></a><!-- doxytag: member="RTS_LAYER_ROSE_SMT_SOLVERS" ref="cdb719c4a573bf8cb5e26245cb1b2e661fa082d6132a6db8f1a7e01160ebeb3b" args="" -->RTS_LAYER_ROSE_SMT_SOLVERS</em>&nbsp;</td><td>
<a class="el" href="classSMTSolver.html">SMTSolver</a> class. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="cdb719c4a573bf8cb5e26245cb1b2e66c85071f8aafdcc45a05e50aa2c02fa3f"></a><!-- doxytag: member="RTS_LAYER_RSIM_SIGNALHANDLING_OBJ" ref="cdb719c4a573bf8cb5e26245cb1b2e66c85071f8aafdcc45a05e50aa2c02fa3f" args="" -->RTS_LAYER_RSIM_SIGNALHANDLING_OBJ</em>&nbsp;</td><td>
RSIM_SignalHandling. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="cdb719c4a573bf8cb5e26245cb1b2e66b1acff323bcaa7eea356283da8a6eb78"></a><!-- doxytag: member="RTS_LAYER_RSIM_PROCESS_OBJ" ref="cdb719c4a573bf8cb5e26245cb1b2e66b1acff323bcaa7eea356283da8a6eb78" args="" -->RTS_LAYER_RSIM_PROCESS_OBJ</em>&nbsp;</td><td>
RSIM_Process. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="cdb719c4a573bf8cb5e26245cb1b2e66c4de666a6cbb30b9deec7590203ca9ae"></a><!-- doxytag: member="RTS_LAYER_RSIM_PROCESS_CLONE_OBJ" ref="cdb719c4a573bf8cb5e26245cb1b2e66c4de666a6cbb30b9deec7590203ca9ae" args="" -->RTS_LAYER_RSIM_PROCESS_CLONE_OBJ</em>&nbsp;</td><td>
RSIM_Process::Clone. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="cdb719c4a573bf8cb5e26245cb1b2e66b2d15048229db5e0e2ccdcb39a65dc8c"></a><!-- doxytag: member="RTS_LAYER_RSIM_THREAD_OBJ" ref="cdb719c4a573bf8cb5e26245cb1b2e66b2d15048229db5e0e2ccdcb39a65dc8c" args="" -->RTS_LAYER_RSIM_THREAD_OBJ</em>&nbsp;</td><td>
RSIM_Thread. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="cdb719c4a573bf8cb5e26245cb1b2e662b54265640c74706fc85ddb0c87d67d2"></a><!-- doxytag: member="RTS_LAYER_RSIM_THREAD_CLASS" ref="cdb719c4a573bf8cb5e26245cb1b2e662b54265640c74706fc85ddb0c87d67d2" args="" -->RTS_LAYER_RSIM_THREAD_CLASS</em>&nbsp;</td><td>
RSIM_Thread. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="cdb719c4a573bf8cb5e26245cb1b2e66edd481d6fec092eb91a909466e120ae2"></a><!-- doxytag: member="RTS_LAYER_RSIM_SYSCALLDISABLER_OBJ" ref="cdb719c4a573bf8cb5e26245cb1b2e66edd481d6fec092eb91a909466e120ae2" args="" -->RTS_LAYER_RSIM_SYSCALLDISABLER_OBJ</em>&nbsp;</td><td>
RSIM_Adapter::SyscallDisabler. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="cdb719c4a573bf8cb5e26245cb1b2e661f3f01517238c0373d8e25fe288dfa3b"></a><!-- doxytag: member="RTS_LAYER_RSIM_TRACEIO_OBJ" ref="cdb719c4a573bf8cb5e26245cb1b2e661f3f01517238c0373d8e25fe288dfa3b" args="" -->RTS_LAYER_RSIM_TRACEIO_OBJ</em>&nbsp;</td><td>
RSIM_Adapter::TraceIO. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="cdb719c4a573bf8cb5e26245cb1b2e66d6432f3135595194de4ac661bf7a0ed2"></a><!-- doxytag: member="RTS_LAYER_RSIM_SIMULATOR_CLASS" ref="cdb719c4a573bf8cb5e26245cb1b2e66d6432f3135595194de4ac661bf7a0ed2" args="" -->RTS_LAYER_RSIM_SIMULATOR_CLASS</em>&nbsp;</td><td>
RSIM_Simulator. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="cdb719c4a573bf8cb5e26245cb1b2e66ff9448d8bb81a8cd86b93ba1d0565ad6"></a><!-- doxytag: member="RTS_LAYER_RSIM_SIMULATOR_OBJ" ref="cdb719c4a573bf8cb5e26245cb1b2e66ff9448d8bb81a8cd86b93ba1d0565ad6" args="" -->RTS_LAYER_RSIM_SIMULATOR_OBJ</em>&nbsp;</td><td>
RSIM_Simulator. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="cdb719c4a573bf8cb5e26245cb1b2e660691b07b993be20e6939e60a26b2f121"></a><!-- doxytag: member="RTS_LAYER_USER_MIN" ref="cdb719c4a573bf8cb5e26245cb1b2e660691b07b993be20e6939e60a26b2f121" args="" -->RTS_LAYER_USER_MIN</em>&nbsp;</td><td>
Minimum layer for end-user usage. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="cdb719c4a573bf8cb5e26245cb1b2e664875004500c6207be99005d90a62d50c"></a><!-- doxytag: member="RTS_LAYER_USER_MAX" ref="cdb719c4a573bf8cb5e26245cb1b2e664875004500c6207be99005d90a62d50c" args="" -->RTS_LAYER_USER_MAX</em>&nbsp;</td><td>
Maximum layer for end-user usage. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="cdb719c4a573bf8cb5e26245cb1b2e662c35e16828c5bfb068ff794c04d6d7ef"></a><!-- doxytag: member="RTS_LAYER_NLAYERS" ref="cdb719c4a573bf8cb5e26245cb1b2e662c35e16828c5bfb068ff794c04d6d7ef" args="" -->RTS_LAYER_NLAYERS</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

<p>
Definition at line <a class="el" href="threadSupport_8h-source.html#l00087">87</a> of file <a class="el" href="threadSupport_8h-source.html">threadSupport.h</a>.
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="d2c4328b3b8b370126e47d3119a0f07f"></a><!-- doxytag: member="threadSupport.h::RTS_acquiring" ref="d2c4328b3b8b370126e47d3119a0f07f" args="(RTS_Layer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTS_acquiring           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e66">RTS_Layer</a>&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check for layering violations. 
<p>
This should be called just before any attempt to acquire a lock. The specified layer should be the layer of the lock being acquired. Returns true if it is OK to acquire the lock, false if doing so could result in deadlock. Before returning false, an error message is printed to stderr.<p>
Note that this function is a no-op when the compiler does not support the "__thread" type qualifier, nor any other qualifier as detected by the <a class="el" href="namespaceROSE.html">ROSE</a> configure script. Currently, this is a no-op on Mac OS X. [RPM 2011-05-04] 
</div>
</div><p>
<a class="anchor" name="8a2a092ecc1774deb0c34b0bf5083f63"></a><!-- doxytag: member="threadSupport.h::RTS_releasing" ref="8a2a092ecc1774deb0c34b0bf5083f63" args="(RTS_Layer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTS_releasing           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e66">RTS_Layer</a>&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Notes the release of a lock. 
<p>
This function should be called before or after each release of a lock. The layer number is that of the lock which is release. 
</div>
</div><p>
<a class="anchor" name="b3a418d4d1a65645192cd924c5c5a915"></a><!-- doxytag: member="threadSupport.h::RTS_mutex_init" ref="b3a418d4d1a65645192cd924c5c5a915" args="(RTS_mutex_t *, RTS_Layer, pthread_mutexattr_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTS_mutex_init           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRTS__mutex__t.html">RTS_mutex_t</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e66">RTS_Layer</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pthread_mutexattr_t *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize a mutual exclusion lock. 
<p>

<p>
Referenced by <a class="el" href="callbacks_8h-source.html#l00084">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::List()</a>.
</div>
</div><p>
<a class="anchor" name="a3303f66060397d3b30b274b8af734d0"></a><!-- doxytag: member="threadSupport.h::RTS_mutex_lock" ref="a3303f66060397d3b30b274b8af734d0" args="(RTS_mutex_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTS_mutex_lock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRTS__mutex__t.html">RTS_mutex_t</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtain an exclusive lock. 
<p>
Behavior is similar to pthread_mutex_lock(). Returns zero on success, errno on failure. 
</div>
</div><p>
<a class="anchor" name="af26a49bd51454c12b82afb6e43482e3"></a><!-- doxytag: member="threadSupport.h::RTS_mutex_unlock" ref="af26a49bd51454c12b82afb6e43482e3" args="(RTS_mutex_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTS_mutex_unlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRTS__mutex__t.html">RTS_mutex_t</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release an exclusive lock. 
<p>
Behavior is similar to pthread_mutex_unlock(). Returns zero on success, errno on failure. 
</div>
</div><p>
<a class="anchor" name="6a1ab8cc7d7036b338001c45c4012f32"></a><!-- doxytag: member="threadSupport.h::RTS_rwlock_init" ref="6a1ab8cc7d7036b338001c45c4012f32" args="(RTS_rwlock_t *rwlock, RTS_Layer, pthread_rwlockattr_t *wrlock_attrs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTS_rwlock_init           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRTS__rwlock__t.html">RTS_rwlock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rwlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e66">RTS_Layer</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pthread_rwlockattr_t *&nbsp;</td>
          <td class="paramname"> <em>wrlock_attrs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Intializes an <a class="el" href="structRTS__rwlock__t.html">RTS_rwlock_t</a> in a manner similar to pthread_rwlock_init(). 
<p>

</div>
</div><p>
<a class="anchor" name="c011afd117f0bc44a89339a0b8c1ad06"></a><!-- doxytag: member="threadSupport.h::RTS_rwlock_rdlock" ref="c011afd117f0bc44a89339a0b8c1ad06" args="(RTS_rwlock_t *rwlock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTS_rwlock_rdlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRTS__rwlock__t.html">RTS_rwlock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rwlock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtain a read lock. 
<p>
The semantics are identical to pthread_rwlock_rdlock() documented in "The Open Group Base Specifications Issue 6: IEEE Std 1003.1, 2004 Edition" [1] with the following changes:<p>
<ul>
<li>
If the calling thread holds a write lock, then the read lock is automatically granted. A single process can be both reading and writing, and may hold multiple kinds locks. </li>
<li>
Calls to <a class="el" href="threadSupport_8h.html#237d9b798a0cc406ac5a4b85ed571a53">RTS_rwlock_unlock()</a> release the recursive locks in the opposite order they were obtained. </li>
</ul>
<p>
[1] <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_rwlock_rdlock.html">http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_rwlock_rdlock.html</a> 
</div>
</div><p>
<a class="anchor" name="f83173e18c286c3dc716dd0dadd0a808"></a><!-- doxytag: member="threadSupport.h::RTS_rwlock_wrlock" ref="f83173e18c286c3dc716dd0dadd0a808" args="(RTS_rwlock_t *rwlock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTS_rwlock_wrlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRTS__rwlock__t.html">RTS_rwlock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rwlock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtain a write lock. 
<p>
The semantics are identical to pthread_rwlock_wrlock() documented in "The Open Group Base Specifications Issue 6: IEEE Std 1003.1, 2004 Edition" [1] with the following changes:<p>
<ul>
<li>
If the calling thread already holds a write lock, then a recursive write lock is automatically granted. A single process can hold multiple write locks. </li>
<li>
Calls to <a class="el" href="threadSupport_8h.html#237d9b798a0cc406ac5a4b85ed571a53">RTS_rwlock_unlock()</a> release the recursive locks in the opposite order they were obtained. </li>
</ul>
<p>
Note that a write lock will not be granted if a thread already holds only read locks. Attempting to obtain a write lock in this situation will result in deadlock.<p>
[1] <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_rwlock_wrlock.html">http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_rwlock_wrlock.html</a> 
</div>
</div><p>
<a class="anchor" name="237d9b798a0cc406ac5a4b85ed571a53"></a><!-- doxytag: member="threadSupport.h::RTS_rwlock_unlock" ref="237d9b798a0cc406ac5a4b85ed571a53" args="(RTS_rwlock_t *rwlock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RTS_rwlock_unlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRTS__rwlock__t.html">RTS_rwlock_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rwlock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release a read or write lock. 
<p>
The semantics are identical to pthread_rwlock_unlock() documented in "The Open Group Base Specification Issue 6: IEEE Std 1003.1, 2004 Edition" [1] with the following additions:<p>
<ul>
<li>
Recursive locks are released in the oposite order they were acquired. </li>
</ul>
<p>
[1] <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_rwlock_unlock.html">http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_rwlock_unlock.html</a> 
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
