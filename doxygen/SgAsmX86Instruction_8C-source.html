<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: SgAsmX86Instruction.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>SgAsmX86Instruction.C</h1><a href="SgAsmX86Instruction_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* SgAsmx86Instruction member definitions.  Do not move them to src/ROSETTA/Grammar/BinaryInstruction.code (or any *.code file)</span>
<a name="l00002"></a>00002 <span class="comment"> * because then they won't get indexed/formatted/etc. by C-aware tools. */</span>
<a name="l00003"></a>00003 
<a name="l00004"></a>00004 <span class="preprocessor">#include "<a class="code" href="sage3basic_8h.html">sage3basic.h</a>"</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include "<a class="code" href="SymbolicSemantics_8h.html">SymbolicSemantics.h</a>"</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include "<a class="code" href="PartialSymbolicSemantics_8h.html">PartialSymbolicSemantics.h</a>"</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include "<a class="code" href="YicesSolver_8h.html">YicesSolver.h</a>"</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include "<a class="code" href="Disassembler_8h.html">Disassembler.h</a>"</span>
<a name="l00009"></a>00009 
<a name="l00011"></a>00011 <span class="keywordtype">bool</span>
<a name="l00012"></a><a class="code" href="classSgAsmx86Instruction.html#d3f2d2701a70a7f93194befbbe795031">00012</a> <a class="code" href="classSgAsmx86Instruction.html#d3f2d2701a70a7f93194befbbe795031">SgAsmx86Instruction::terminatesBasicBlock</a>() {
<a name="l00013"></a>00013     <span class="keywordflow">if</span> (<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()==<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca557149fb5e2bdecc279e252f5d750211f7a1">x86_unknown_instruction</a>)
<a name="l00014"></a>00014         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00015"></a>00015     <span class="keywordflow">return</span> x86InstructionIsControlTransfer(<span class="keyword">this</span>);
<a name="l00016"></a>00016 }
<a name="l00017"></a>00017 
<a name="l00020"></a>00020 <span class="keywordtype">bool</span>
<a name="l00021"></a><a class="code" href="classSgAsmx86Instruction.html#f6767ea57159445e387072aec637a6c8">00021</a> <a class="code" href="classSgAsmx86Instruction.html#f6767ea57159445e387072aec637a6c8">SgAsmx86Instruction::is_function_call</a>(<span class="keyword">const</span> std::vector&lt;SgAsmInstruction*&gt;&amp; insns, <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> *target)
<a name="l00022"></a>00022 {
<a name="l00023"></a>00023     <span class="keywordflow">if</span> (insns.size()==0)
<a name="l00024"></a>00024         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00025"></a>00025     <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *last = <a class="code" href="classSgAsmx86Instruction.html#5a1941efaed4886e825fd6e8ce5b342e">isSgAsmx86Instruction</a>(insns.back());
<a name="l00026"></a>00026     <span class="keywordflow">if</span> (!last)
<a name="l00027"></a>00027         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00028"></a>00028     <span class="keywordflow">if</span> (last-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()!=<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571221e4d163bb7557e57e351140aa7855e">x86_call</a> &amp;&amp; last-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()!=<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca55714edb34feaf8cb03afb49361a9a0b26c4">x86_farcall</a>)
<a name="l00029"></a>00029         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00030"></a>00030     <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> tmp;
<a name="l00031"></a>00031     <span class="keywordflow">if</span> (x86GetKnownBranchTarget(last, tmp))
<a name="l00032"></a>00032         *target = tmp; <span class="comment">/* "target" must not be modified if we don't know the target address. */</span>
<a name="l00033"></a>00033     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00034"></a>00034 }
<a name="l00035"></a>00035 
<a name="l00037"></a>00037 <span class="keywordtype">bool</span>
<a name="l00038"></a><a class="code" href="classSgAsmx86Instruction.html#b50f44a00dee951af055464c8a39ab99">00038</a> <a class="code" href="classSgAsmx86Instruction.html#b50f44a00dee951af055464c8a39ab99">SgAsmx86Instruction::is_function_return</a>(<span class="keyword">const</span> std::vector&lt;SgAsmInstruction*&gt; &amp;insns) {
<a name="l00039"></a>00039     <span class="keywordflow">if</span> (insns.empty())
<a name="l00040"></a>00040         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00041"></a>00041     <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *last_insn = <a class="code" href="classSgAsmx86Instruction.html#5a1941efaed4886e825fd6e8ce5b342e">isSgAsmx86Instruction</a>(insns.back());
<a name="l00042"></a>00042     <span class="keywordflow">if</span> (!last_insn)
<a name="l00043"></a>00043         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00044"></a>00044     <span class="keywordflow">if</span> (last_insn-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()==<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca557193febfccef733b633e7c6374ea207532">x86_ret</a> || last_insn-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()==<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca55713388fe6b40dfb8e1f67da320fad88afc">x86_retf</a>)
<a name="l00045"></a>00045         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00046"></a>00046     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00047"></a>00047 }
<a name="l00048"></a>00048 
<a name="l00050"></a>00050 <span class="keywordtype">bool</span>
<a name="l00051"></a><a class="code" href="classSgAsmx86Instruction.html#2adfb183ad4b1c3ea9084890d544d273">00051</a> <a class="code" href="classSgAsmx86Instruction.html#2adfb183ad4b1c3ea9084890d544d273">SgAsmx86Instruction::is_unknown</a>()<span class="keyword"> const</span>
<a name="l00052"></a>00052 <span class="keyword"></span>{
<a name="l00053"></a>00053     <span class="keywordflow">return</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca557149fb5e2bdecc279e252f5d750211f7a1">x86_unknown_instruction</a> == <a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>();
<a name="l00054"></a>00054 }
<a name="l00055"></a>00055 
<a name="l00057"></a>00057 <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a>
<a name="l00058"></a><a class="code" href="classSgAsmx86Instruction.html#e43b0ae94f1e860f93fd9a17300a6ef5">00058</a> <a class="code" href="classSgAsmx86Instruction.html#e43b0ae94f1e860f93fd9a17300a6ef5">SgAsmx86Instruction::get_successors</a>(<span class="keywordtype">bool</span> *complete) {
<a name="l00059"></a>00059     <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> retval;
<a name="l00060"></a>00060     *complete = <span class="keyword">true</span>; <span class="comment">/*assume true and prove otherwise*/</span>
<a name="l00061"></a>00061 
<a name="l00062"></a>00062     <span class="keywordflow">switch</span> (<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()) {
<a name="l00063"></a>00063         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571221e4d163bb7557e57e351140aa7855e">x86_call</a>:
<a name="l00064"></a>00064         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca55714edb34feaf8cb03afb49361a9a0b26c4">x86_farcall</a>:
<a name="l00065"></a>00065         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571ad03bc3cf5ca0f4918d34b66a2ae0b24">x86_jmp</a>:
<a name="l00066"></a>00066         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca557198fb4c6bacf21d45da2c1eb7380caccc">x86_farjmp</a>: {
<a name="l00067"></a>00067             <span class="comment">/* Unconditional branch to operand-specified address. We cannot assume that a CALL instruction returns to the</span>
<a name="l00068"></a>00068 <span class="comment">             * fall-through address. */</span>
<a name="l00069"></a>00069             <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va;
<a name="l00070"></a>00070             <span class="keywordflow">if</span> (x86GetKnownBranchTarget(<span class="keyword">this</span>, va<span class="comment">/*out*/</span>)) {
<a name="l00071"></a>00071                 retval.insert(va);
<a name="l00072"></a>00072             } <span class="keywordflow">else</span> {
<a name="l00073"></a>00073                 *complete = <span class="keyword">false</span>;
<a name="l00074"></a>00074             }
<a name="l00075"></a>00075             <span class="keywordflow">break</span>;
<a name="l00076"></a>00076         }
<a name="l00077"></a>00077 
<a name="l00078"></a>00078         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca55715adc3e4175e047962bf4de0660f2d90c">x86_ja</a>:
<a name="l00079"></a>00079         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca557117f3c7758d04694d75d994ea820f38af">x86_jae</a>:
<a name="l00080"></a>00080         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571b04a29eee70451d2960720baae6505b4">x86_jb</a>:
<a name="l00081"></a>00081         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571dd1b776e79b2ecf99301dd78d43df807">x86_jbe</a>:
<a name="l00082"></a>00082         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571b18f5590e1c5d7527aaa0f01df9dd195">x86_jcxz</a>:
<a name="l00083"></a>00083         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571029f954b70d3fd3d5adfb1bdf43a1211">x86_jecxz</a>:
<a name="l00084"></a>00084         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca55717e68e91c34806e29bda1e6fa134f2b26">x86_jrcxz</a>:
<a name="l00085"></a>00085         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571d5af926a48b705472bb60603f2b9c4c1">x86_je</a>:
<a name="l00086"></a>00086         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571a41f0d819697815b5385167af967da71">x86_jg</a>:
<a name="l00087"></a>00087         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571ffcf9c14662d88cc133fe36ca5c5155e">x86_jge</a>:
<a name="l00088"></a>00088         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571a2042208c911e6d260dd671e9a53d913">x86_jl</a>:
<a name="l00089"></a>00089         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571f910187c03ed1199fe2fc5d5040086c7">x86_jle</a>:
<a name="l00090"></a>00090         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca55715abacd9a02a9157c87575791f6ccb668">x86_jne</a>:
<a name="l00091"></a>00091         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca55715abaf86f58f8f8578060ac155b8914d3">x86_jno</a>:
<a name="l00092"></a>00092         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca55716a046969884cc22f5d6ac481848ed074">x86_jns</a>:
<a name="l00093"></a>00093         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca55712305b1639dbf254c09b0150d4aa17f60">x86_jo</a>:
<a name="l00094"></a>00094         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571e91d2388b4a9cae4a5900526215416b5">x86_jpe</a>:
<a name="l00095"></a>00095         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571c020b28f28b9adb3cba775f7a52385d2">x86_jpo</a>:
<a name="l00096"></a>00096         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571fd8827f045d5206ee72e1314a9092676">x86_js</a>:
<a name="l00097"></a>00097         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca55716cd65d70ab12e773336f7026f482ec49">x86_loop</a>:
<a name="l00098"></a>00098         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca55712f0629bd505f120d4f986412e41ee762">x86_loopnz</a>:
<a name="l00099"></a>00099         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571b4327d97b3651a38ff249bf2299b9c9d">x86_loopz</a>: {
<a name="l00100"></a>00100             <span class="comment">/* Conditional branches to operand-specified address */</span>
<a name="l00101"></a>00101             <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va;
<a name="l00102"></a>00102             <span class="keywordflow">if</span> (x86GetKnownBranchTarget(<span class="keyword">this</span>, va<span class="comment">/*out*/</span>)) {
<a name="l00103"></a>00103                 retval.insert(va);
<a name="l00104"></a>00104             } <span class="keywordflow">else</span> {
<a name="l00105"></a>00105                 *complete = <span class="keyword">false</span>;
<a name="l00106"></a>00106             }
<a name="l00107"></a>00107             retval.insert(<a class="code" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>() + <a class="code" href="classSgAsmInstruction.html#6adcc4eb7c725185baa3a2425a57843c">get_size</a>());
<a name="l00108"></a>00108             <span class="keywordflow">break</span>;
<a name="l00109"></a>00109         }
<a name="l00110"></a>00110 
<a name="l00111"></a>00111         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca557193febfccef733b633e7c6374ea207532">x86_ret</a>:
<a name="l00112"></a>00112         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca557174124219c6ecfe187796647b531a59a7">x86_iret</a>:
<a name="l00113"></a>00113         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca55710d844a8f9428f4b82d3ddfc4940affbc">x86_int1</a>:
<a name="l00114"></a>00114         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca557149f84bee5ecc3180bef134bb28ab1931">x86_int3</a>:
<a name="l00115"></a>00115         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca55715359d4a9e1c6be45ba336a982e941590">x86_into</a>:
<a name="l00116"></a>00116         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca55712c698dbc2d0b6a890ce71561de20d4b8">x86_rsm</a>:
<a name="l00117"></a>00117         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571dcb16bd10cd5e85b4fb366f8daea1cce">x86_ud2</a>:
<a name="l00118"></a>00118         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca55713388fe6b40dfb8e1f67da320fad88afc">x86_retf</a>: {
<a name="l00119"></a>00119             <span class="comment">/* Unconditional branch to run-time specified address */</span>
<a name="l00120"></a>00120             *complete = <span class="keyword">false</span>;
<a name="l00121"></a>00121             <span class="keywordflow">break</span>;
<a name="l00122"></a>00122         }
<a name="l00123"></a>00123 
<a name="l00124"></a>00124         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571b162a22a8217c3117690697e598751e6">x86_hlt</a>: {
<a name="l00125"></a>00125             <span class="comment">/* Instructions having no successor. */</span>
<a name="l00126"></a>00126             <span class="keywordflow">break</span>;
<a name="l00127"></a>00127         }
<a name="l00128"></a>00128 
<a name="l00129"></a>00129         <span class="keywordflow">case</span> <a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca557149fb5e2bdecc279e252f5d750211f7a1">x86_unknown_instruction</a>: {
<a name="l00130"></a>00130             <span class="comment">/* Instructions having unknown successors */</span>
<a name="l00131"></a>00131             *complete = <span class="keyword">false</span>;
<a name="l00132"></a>00132         }
<a name="l00133"></a>00133 
<a name="l00134"></a>00134         <span class="keywordflow">default</span>: {
<a name="l00135"></a>00135             <span class="comment">/* Instructions that always fall through to the next instruction */</span>
<a name="l00136"></a>00136             retval.insert(<a class="code" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>() + <a class="code" href="classSgAsmInstruction.html#6adcc4eb7c725185baa3a2425a57843c">get_size</a>());
<a name="l00137"></a>00137             <span class="keywordflow">break</span>;
<a name="l00138"></a>00138         }
<a name="l00139"></a>00139     }
<a name="l00140"></a>00140     <span class="keywordflow">return</span> retval;
<a name="l00141"></a>00141 }
<a name="l00142"></a>00142 
<a name="l00144"></a>00144 <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a>
<a name="l00145"></a><a class="code" href="classSgAsmx86Instruction.html#b282ee973cad2f6dada9bfd8e20bf446">00145</a> <a class="code" href="classSgAsmx86Instruction.html#e43b0ae94f1e860f93fd9a17300a6ef5">SgAsmx86Instruction::get_successors</a>(<span class="keyword">const</span> std::vector&lt;SgAsmInstruction*&gt;&amp; insns, <span class="keywordtype">bool</span> *complete, <a class="code" href="classMemoryMap.html">MemoryMap</a> *initial_memory)
<a name="l00146"></a>00146 {
<a name="l00147"></a>00147     <span class="keyword">using namespace </span>BinaryAnalysis::InstructionSemantics;
<a name="l00148"></a>00148     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> debug = <span class="keyword">false</span>;
<a name="l00149"></a>00149 
<a name="l00150"></a>00150     <span class="keywordflow">if</span> (debug) {
<a name="l00151"></a>00151         std::cerr &lt;&lt;<span class="stringliteral">"SgAsmx86Instruction::get_successors("</span> &lt;&lt;<a class="code" href="namespaceStringUtility.html#b07dfdb6df484680f9a29ad4fcf79f80">StringUtility::addrToString</a>(insns.front()-&gt;get_address())
<a name="l00152"></a>00152                   &lt;&lt;<span class="stringliteral">" for "</span> &lt;&lt;insns.size() &lt;&lt;<span class="stringliteral">" instruction"</span> &lt;&lt;(1==insns.size()?<span class="stringliteral">""</span>:<span class="stringliteral">"s"</span>) &lt;&lt;<span class="stringliteral">"):"</span> &lt;&lt;std::endl;
<a name="l00153"></a>00153     }
<a name="l00154"></a>00154 
<a name="l00155"></a>00155     <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> successors = <a class="code" href="classSgAsmInstruction.html#f6899182698893142221e72f0f88ac0e">SgAsmInstruction::get_successors</a>(insns, complete);
<a name="l00156"></a>00156 
<a name="l00157"></a>00157     <span class="comment">/* If we couldn't determine all the successors, or a cursory analysis couldn't narrow it down to a single successor then</span>
<a name="l00158"></a>00158 <span class="comment">     * we'll do a more thorough analysis now. In the case where the cursory analysis returned a complete set containing two</span>
<a name="l00159"></a>00159 <span class="comment">     * successors, a thorough analysis might be able to narrow it down to a single successor. We should not make special</span>
<a name="l00160"></a>00160 <span class="comment">     * assumptions about CALL and FARCALL instructions -- their only successor is the specified address operand. */</span>
<a name="l00161"></a>00161     <span class="keywordflow">if</span> (!*complete || successors.size()&gt;1) {
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 #<span class="keywordflow">if</span> 0
<a name="l00164"></a>00164         <span class="comment">/* Use the most robust semantic analysis available.  Warning: this can be very slow, especially when an SMT solver is</span>
<a name="l00165"></a>00165 <span class="comment">         * involved! */</span>
<a name="l00166"></a>00166 # <span class="keywordflow">if</span> defined(ROSE_YICES) || defined(ROSE_HAVE_LIBYICES)
<a name="l00167"></a>00167         <a class="code" href="classYicesSolver.html">YicesSolver</a> yices;
<a name="l00168"></a>00168         <span class="keywordflow">if</span> (yices.<a class="code" href="classYicesSolver.html#9cabdcd4d115df17979041860ad1f873">available_linkage</a>() &amp; <a class="code" href="classYicesSolver.html#716e740bfbf90e6980c889701d28779c38b27c325642c984c801caa3bf880e88">YicesSolver::LM_LIBRARY</a>) {
<a name="l00169"></a>00169             yices.<a class="code" href="classYicesSolver.html#e701cb7725a89619bbc5cca87849730e">set_linkage</a>(<a class="code" href="classYicesSolver.html#716e740bfbf90e6980c889701d28779c38b27c325642c984c801caa3bf880e88">YicesSolver::LM_LIBRARY</a>);
<a name="l00170"></a>00170         } <span class="keywordflow">else</span> {
<a name="l00171"></a>00171             yices.<a class="code" href="classYicesSolver.html#e701cb7725a89619bbc5cca87849730e">set_linkage</a>(<a class="code" href="classYicesSolver.html#716e740bfbf90e6980c889701d28779c178b12445110b22c8ef7e8421414dad2">YicesSolver::LM_EXECUTABLE</a>);
<a name="l00172"></a>00172         }
<a name="l00173"></a>00173         <a class="code" href="classSMTSolver.html">SMTSolver</a> *solver = &amp;yices;
<a name="l00174"></a>00174 <span class="preprocessor"># else</span>
<a name="l00175"></a>00175 <span class="preprocessor"></span>        <a class="code" href="classSMTSolver.html">SMTSolver</a> *solver = NULL;
<a name="l00176"></a>00176 <span class="preprocessor"># endif</span>
<a name="l00177"></a>00177 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (debug &amp;&amp; solver)
<a name="l00178"></a>00178             solver-&gt;<a class="code" href="classSMTSolver.html#4438cac1dbb6f4296c4faa56703e0e4c">set_debug</a>(stderr);
<a name="l00179"></a>00179         <span class="keyword">typedef</span> SymbolicSemantics::Policy&lt;&gt; Policy;
<a name="l00180"></a>00180         <span class="keyword">typedef</span> SymbolicSemantics::ValueType&lt;32&gt; RegisterType;
<a name="l00181"></a>00181         <span class="keyword">typedef</span> X86InstructionSemantics&lt;Policy, SymbolicSemantics::ValueType&gt; Semantics;
<a name="l00182"></a>00182         Policy policy(solver);
<a name="l00183"></a>00183 <span class="preprocessor">#else</span>
<a name="l00184"></a>00184 <span class="preprocessor"></span>        <span class="keyword">typedef</span> PartialSymbolicSemantics::Policy&lt;&gt; Policy;
<a name="l00185"></a>00185         <span class="keyword">typedef</span> PartialSymbolicSemantics::ValueType&lt;32&gt; RegisterType;
<a name="l00186"></a>00186         <span class="keyword">typedef</span> X86InstructionSemantics&lt;Policy, PartialSymbolicSemantics::ValueType&gt; Semantics;
<a name="l00187"></a>00187         Policy policy;
<a name="l00188"></a>00188         policy.set_map(initial_memory);
<a name="l00189"></a>00189 <span class="preprocessor">#endif</span>
<a name="l00190"></a>00190 <span class="preprocessor"></span>        <span class="keywordflow">try</span> {
<a name="l00191"></a>00191             Semantics semantics(policy);
<a name="l00192"></a>00192             <span class="keywordflow">for</span> (size_t i=0; i&lt;insns.size(); i++) {
<a name="l00193"></a>00193                 <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* insn = <a class="code" href="classSgAsmx86Instruction.html#5a1941efaed4886e825fd6e8ce5b342e">isSgAsmx86Instruction</a>(insns[i]);
<a name="l00194"></a>00194                 semantics.processInstruction(insn);
<a name="l00195"></a>00195                 <span class="keywordflow">if</span> (debug) {
<a name="l00196"></a>00196                     std::cerr &lt;&lt; <span class="stringliteral">"  state after "</span> &lt;&lt;<a class="code" href="AsmUnparser__compat_8h.html#3b979292833b85f5b059b2893250453c">unparseInstructionWithAddress</a>(insn) &lt;&lt;std::endl
<a name="l00197"></a>00197                               &lt;&lt;policy.get_state();
<a name="l00198"></a>00198                 }
<a name="l00199"></a>00199             }
<a name="l00200"></a>00200             <span class="keyword">const</span> RegisterType &amp;newip = policy.get_ip();
<a name="l00201"></a>00201             <span class="keywordflow">if</span> (newip.is_known()) {
<a name="l00202"></a>00202                 successors.clear();
<a name="l00203"></a>00203                 successors.insert(newip.known_value());
<a name="l00204"></a>00204                 *complete = <span class="keyword">true</span>; <span class="comment">/*this is the complete set of successors*/</span>
<a name="l00205"></a>00205             }
<a name="l00206"></a>00206         } <span class="keywordflow">catch</span>(<span class="keyword">const</span> Semantics::Exception&amp; e) {
<a name="l00207"></a>00207             <span class="comment">/* Abandon entire basic block if we hit an instruction that's not implemented. */</span>
<a name="l00208"></a>00208             <span class="keywordflow">if</span> (debug)
<a name="l00209"></a>00209                 std::cerr &lt;&lt;e &lt;&lt;<span class="stringliteral">"\n"</span>;
<a name="l00210"></a>00210         } <span class="keywordflow">catch</span>(<span class="keyword">const</span> Policy::Exception&amp; e) {
<a name="l00211"></a>00211             <span class="comment">/* Abandon entire basic block if the semantics policy cannot handle the instruction. */</span>
<a name="l00212"></a>00212             <span class="keywordflow">if</span> (debug)
<a name="l00213"></a>00213                 std::cerr &lt;&lt;e &lt;&lt;<span class="stringliteral">"\n"</span>;
<a name="l00214"></a>00214         }
<a name="l00215"></a>00215     }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217     <span class="keywordflow">if</span> (debug) {
<a name="l00218"></a>00218         std::cerr &lt;&lt;<span class="stringliteral">"  successors:"</span>;
<a name="l00219"></a>00219         <span class="keywordflow">for</span> (Disassembler::AddressSet::const_iterator si=successors.begin(); si!=successors.end(); ++si)
<a name="l00220"></a>00220             std::cerr &lt;&lt;<span class="stringliteral">" "</span> &lt;&lt;<a class="code" href="namespaceStringUtility.html#b07dfdb6df484680f9a29ad4fcf79f80">StringUtility::addrToString</a>(*si);
<a name="l00221"></a>00221         <span class="keywordflow">if</span> (!*complete) std::cerr &lt;&lt;<span class="stringliteral">"..."</span>;
<a name="l00222"></a>00222         std::cerr &lt;&lt;std::endl;
<a name="l00223"></a>00223     }
<a name="l00224"></a>00224 
<a name="l00225"></a>00225     <span class="keywordflow">return</span> successors;
<a name="l00226"></a>00226 }
<a name="l00227"></a>00227 
<a name="l00358"></a>00358 <span class="keywordtype">bool</span>
<a name="l00359"></a><a class="code" href="classSgAsmx86Instruction.html#fa3c395b4965200a21d8be718a049bd0">00359</a> <a class="code" href="classSgAsmx86Instruction.html#fa3c395b4965200a21d8be718a049bd0">SgAsmx86Instruction::has_effect</a>()
<a name="l00360"></a>00360 {
<a name="l00361"></a>00361     std::vector&lt;SgAsmInstruction*&gt; sequence;
<a name="l00362"></a>00362     sequence.push_back(<span class="keyword">this</span>);
<a name="l00363"></a>00363     <span class="keywordflow">return</span> <a class="code" href="classSgAsmx86Instruction.html#fa3c395b4965200a21d8be718a049bd0">has_effect</a>(sequence, <span class="keyword">false</span>);
<a name="l00364"></a>00364 }
<a name="l00365"></a>00365 
<a name="l00387"></a>00387 <span class="keywordtype">bool</span>
<a name="l00388"></a><a class="code" href="classSgAsmx86Instruction.html#7657930c3f173a0675fa2668b74bba11">00388</a> <a class="code" href="classSgAsmx86Instruction.html#fa3c395b4965200a21d8be718a049bd0">SgAsmx86Instruction::has_effect</a>(<span class="keyword">const</span> std::vector&lt;SgAsmInstruction*&gt;&amp; insns, <span class="keywordtype">bool</span> allow_branch<span class="comment">/*false*/</span>, 
<a name="l00389"></a>00389                                 <span class="keywordtype">bool</span> relax_stack_semantics<span class="comment">/*false*/</span>)
<a name="l00390"></a>00390 {
<a name="l00391"></a>00391     <span class="keyword">using namespace </span>BinaryAnalysis::InstructionSemantics;
<a name="l00392"></a>00392 
<a name="l00393"></a>00393     <span class="keywordflow">if</span> (insns.empty()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00394"></a>00394 
<a name="l00395"></a>00395     <span class="keyword">typedef</span> PartialSymbolicSemantics::Policy&lt;&gt; Policy;
<a name="l00396"></a>00396     <span class="keyword">typedef</span> X86InstructionSemantics&lt;Policy, PartialSymbolicSemantics::ValueType&gt; Semantics;
<a name="l00397"></a>00397     Policy policy;
<a name="l00398"></a>00398     Semantics semantics(policy);
<a name="l00399"></a>00399     <span class="keywordflow">if</span> (relax_stack_semantics) policy.set_discard_popped_memory(<span class="keyword">true</span>);
<a name="l00400"></a>00400     <span class="keywordflow">try</span> {
<a name="l00401"></a>00401         <span class="keywordflow">for</span> (std::vector&lt;SgAsmInstruction*&gt;::const_iterator ii=insns.begin(); ii!=insns.end(); ++ii) {
<a name="l00402"></a>00402             <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn = <a class="code" href="classSgAsmx86Instruction.html#5a1941efaed4886e825fd6e8ce5b342e">isSgAsmx86Instruction</a>(*ii);
<a name="l00403"></a>00403             <span class="keywordflow">if</span> (!insn) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00404"></a>00404             semantics.processInstruction(insn);
<a name="l00405"></a>00405             <span class="keywordflow">if</span> (!policy.get_ip().is_known()) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00406"></a>00406         }
<a name="l00407"></a>00407     } <span class="keywordflow">catch</span> (<span class="keyword">const</span> Semantics::Exception&amp;) {
<a name="l00408"></a>00408         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00409"></a>00409     } <span class="keywordflow">catch</span> (<span class="keyword">const</span> Policy::Exception&amp;) {
<a name="l00410"></a>00410         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00411"></a>00411     }
<a name="l00412"></a>00412 
<a name="l00413"></a>00413     <span class="comment">/* If the final instruction pointer is not the fall-through address of the final instruction then return true. In other</span>
<a name="l00414"></a>00414 <span class="comment">     * words, a sequence ending with a JMP (for instance) has an effect, but an internal JMP has no effect.  This is to</span>
<a name="l00415"></a>00415 <span class="comment">     * support instruction sequences from non-contiguous basic blocks. */</span>
<a name="l00416"></a>00416     ROSE_ASSERT(policy.get_ip().is_known());
<a name="l00417"></a>00417     <span class="keywordflow">if</span> (!allow_branch &amp;&amp; policy.get_ip().known_value()!=insns.back()-&gt;get_address() + insns.back()-&gt;get_size())
<a name="l00418"></a>00418         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00419"></a>00419 
<a name="l00420"></a>00420     <span class="comment">/* Instructions have an effect if the state changed.  We want the comparison to be independent of the instruction pointer,</span>
<a name="l00421"></a>00421 <span class="comment">     * so we'll set the IP of both the initial and final states to the same (unknown) value. */</span> 
<a name="l00422"></a>00422     policy.get_orig_state().registers.ip = policy.get_state().registers.ip = PartialSymbolicSemantics::ValueType&lt;32&gt;();
<a name="l00423"></a>00423     <span class="keywordflow">return</span> !policy.equal_states(policy.get_orig_state(), policy.get_state());
<a name="l00424"></a>00424 }
<a name="l00425"></a>00425 
<a name="l00437"></a>00437 std::vector&lt; std::pair&lt; size_t, size_t &gt; &gt;
<a name="l00438"></a><a class="code" href="classSgAsmx86Instruction.html#b71eb3011264ac4b4813ed16c57a585c">00438</a> <a class="code" href="classSgAsmx86Instruction.html#b71eb3011264ac4b4813ed16c57a585c">SgAsmx86Instruction::find_noop_subsequences</a>(<span class="keyword">const</span> std::vector&lt;SgAsmInstruction*&gt;&amp; insns, <span class="keywordtype">bool</span> allow_branch<span class="comment">/*false*/</span>, 
<a name="l00439"></a>00439                                             <span class="keywordtype">bool</span> relax_stack_semantics<span class="comment">/*false*/</span>)
<a name="l00440"></a>00440 {
<a name="l00441"></a>00441     <span class="keyword">using namespace </span>BinaryAnalysis::InstructionSemantics;
<a name="l00442"></a>00442 
<a name="l00443"></a>00443     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> verbose = <span class="keyword">false</span>;
<a name="l00444"></a>00444 
<a name="l00445"></a>00445     <span class="keywordflow">if</span> (verbose) std::cerr &lt;&lt;<span class="stringliteral">"find_noop_subsequences:\n"</span>;
<a name="l00446"></a>00446     std::vector&lt; std::pair &lt;size_t<span class="comment">/*starting insn index*/</span>, size_t<span class="comment">/*num. insns*/</span>&gt; &gt; retval;
<a name="l00447"></a>00447 
<a name="l00448"></a>00448     <span class="keyword">typedef</span> PartialSymbolicSemantics::Policy&lt;&gt; Policy;
<a name="l00449"></a>00449     <span class="keyword">typedef</span> X86InstructionSemantics&lt;Policy, PartialSymbolicSemantics::ValueType&gt; Semantics;
<a name="l00450"></a>00450     Policy policy;
<a name="l00451"></a>00451     <span class="keywordflow">if</span> (relax_stack_semantics) policy.set_discard_popped_memory(<span class="keyword">true</span>);
<a name="l00452"></a>00452     Semantics semantics(policy);
<a name="l00453"></a>00453 
<a name="l00454"></a>00454     <span class="comment">/* When comparing states, we don't want to compare the instruction pointers. Therefore, we'll change the IP value of</span>
<a name="l00455"></a>00455 <span class="comment">     * each state to be the same. */</span>
<a name="l00456"></a>00456     <span class="keyword">const</span> PartialSymbolicSemantics::ValueType&lt;32&gt; common_ip;
<a name="l00457"></a>00457     
<a name="l00458"></a>00458     <span class="comment">/* Save the state before and after each instruction.  states[i] is the state before insn[i] and states[i+1] is the state</span>
<a name="l00459"></a>00459 <span class="comment">     * after insn[i]. */</span>
<a name="l00460"></a>00460     std::vector&lt;PartialSymbolicSemantics::State&lt;PartialSymbolicSemantics::ValueType&gt; &gt; state;
<a name="l00461"></a>00461     state.push_back(policy.get_state());
<a name="l00462"></a>00462     state.back().registers.ip = common_ip;
<a name="l00463"></a>00463     <span class="keywordflow">try</span> {
<a name="l00464"></a>00464         <span class="keywordflow">for</span> (std::vector&lt;SgAsmInstruction*&gt;::const_iterator ii=insns.begin(); ii!=insns.end(); ++ii) {
<a name="l00465"></a>00465             <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn = <a class="code" href="classSgAsmx86Instruction.html#5a1941efaed4886e825fd6e8ce5b342e">isSgAsmx86Instruction</a>(*ii);
<a name="l00466"></a>00466             <span class="keywordflow">if</span> (verbose)
<a name="l00467"></a>00467                 std::cerr &lt;&lt;<span class="stringliteral">"  insn #"</span> &lt;&lt;(state.size()-1)
<a name="l00468"></a>00468                           &lt;&lt;<span class="stringliteral">" "</span> &lt;&lt;(insn ? <a class="code" href="AsmUnparser__compat_8h.html#3b979292833b85f5b059b2893250453c">unparseInstructionWithAddress</a>(insn) : <span class="stringliteral">"&lt;none&gt;"</span>) &lt;&lt;<span class="stringliteral">"\n"</span>;
<a name="l00469"></a>00469             <span class="keywordflow">if</span> (!insn) <span class="keywordflow">return</span> retval;
<a name="l00470"></a>00470             semantics.processInstruction(insn);
<a name="l00471"></a>00471             state.push_back(policy.get_state());
<a name="l00472"></a>00472             <span class="keywordflow">if</span> (verbose) std::cerr &lt;&lt;<span class="stringliteral">"  state:\n"</span> &lt;&lt;policy.get_state();
<a name="l00473"></a>00473         }
<a name="l00474"></a>00474     } <span class="keywordflow">catch</span> (<span class="keyword">const</span> Semantics::Exception&amp;) {
<a name="l00475"></a>00475         <span class="comment">/* Perhaps we can find at least a few no-op subsequences... */</span>
<a name="l00476"></a>00476     } <span class="keywordflow">catch</span> (<span class="keyword">const</span> Policy::Exception&amp;) {
<a name="l00477"></a>00477         <span class="comment">/* Perhaps we can find at least a few no-op subsequences... */</span>
<a name="l00478"></a>00478     }
<a name="l00479"></a>00479 
<a name="l00480"></a>00480     <span class="comment">/* If the last instruction resulted in indeterminant instruction pointer then discard it from the list of states because</span>
<a name="l00481"></a>00481 <span class="comment">     * it has an effect (it's probably a conditional jump).  It's up to the caller whether a final instruction that</span>
<a name="l00482"></a>00482 <span class="comment">     * unconditionally branches has an effect. */</span>
<a name="l00483"></a>00483     <span class="keywordflow">if</span> (!policy.get_ip().is_known()) {
<a name="l00484"></a>00484         state.pop_back();
<a name="l00485"></a>00485     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!allow_branch &amp;&amp;
<a name="l00486"></a>00486                policy.get_ip().known_value()!=insns.back()-&gt;get_address() + insns.back()-&gt;get_size()) {
<a name="l00487"></a>00487         state.pop_back();
<a name="l00488"></a>00488     }
<a name="l00489"></a>00489 
<a name="l00490"></a>00490     <span class="comment">/* Change the IP register so its the same for all states so it doesn't contribute to state differences. */</span>
<a name="l00491"></a>00491     <span class="keyword">const</span> size_t nstates = state.size();
<a name="l00492"></a>00492     <span class="keywordflow">for</span> (size_t i=0; i&lt;nstates; i++)
<a name="l00493"></a>00493         state[i].registers.ip = common_ip;
<a name="l00494"></a>00494 
<a name="l00495"></a>00495     <span class="comment">/* Find pairs of equivalent states. */</span>
<a name="l00496"></a>00496     if (verbose) std::cerr &lt;&lt;<span class="stringliteral">"  number of states: "</span> &lt;&lt;nstates &lt;&lt;<span class="stringliteral">"\n"</span>;
<a name="l00497"></a>00497     <span class="keywordflow">for</span> (size_t i=0; i&lt;nstates-1; i++) {
<a name="l00498"></a>00498         <span class="keywordflow">for</span> (size_t j=i+1; j&lt;nstates; j++) {
<a name="l00499"></a>00499             <span class="keywordflow">if</span> (policy.equal_states(state[i], state[j])) {
<a name="l00500"></a>00500                 <span class="keywordflow">if</span> (verbose) std::cerr &lt;&lt;<span class="stringliteral">"  at instruction #"</span>&lt;&lt;i &lt;&lt;<span class="stringliteral">": no-op of length "</span> &lt;&lt;(j-i) &lt;&lt;<span class="stringliteral">"\n"</span>;
<a name="l00501"></a>00501                 retval.push_back(std::make_pair(i, j-i));
<a name="l00502"></a>00502             }
<a name="l00503"></a>00503         }
<a name="l00504"></a>00504     }
<a name="l00505"></a>00505 
<a name="l00506"></a>00506     <span class="keywordflow">return</span> retval;
<a name="l00507"></a>00507 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
