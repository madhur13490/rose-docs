<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: affineInequality.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>affineInequality.h</h1><a href="affineInequality_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef AFFINE_INEQUALITY_H</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define AFFINE_INEQUALITY_H</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="preprocessor">#include "<a class="code" href="genericDataflowCommon_8h.html">genericDataflowCommon.h</a>"</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include "<a class="code" href="VirtualCFGIterator_8h.html">VirtualCFGIterator.h</a>"</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include "<a class="code" href="cfgUtils_8h.html">cfgUtils.h</a>"</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include "<a class="code" href="CallGraphTraverse_8h.html">CallGraphTraverse.h</a>"</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include "<a class="code" href="analysis_8h.html">analysis.h</a>"</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include "<a class="code" href="divAnalysis_8h.html">divAnalysis.h</a>"</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include "<a class="code" href="printAnalysisStates_8h.html">printAnalysisStates.h</a>"</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include "<a class="code" href="LogicalCond_8h.html">LogicalCond.h</a>"</span>
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;functional&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;queue&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;list&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;set&gt;</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="comment">// represents the constraint on variables x and y: x*a &lt;= y*b + c</span>
<a name="l00022"></a><a class="code" href="classaffineInequality.html">00022</a> <span class="keyword">class </span><a class="code" href="classaffineInequality.html">affineInequality</a>: <span class="keyword">public</span> <a class="code" href="classprintable.html">printable</a> <span class="comment">// : public LogicalCond</span>
<a name="l00023"></a>00023 {
<a name="l00024"></a><a class="code" href="classaffineInequality.html#14ce010a440f5d721a24c62700b6dff9">00024</a>         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classvarAffineInequality.html">varAffineInequality</a>;
<a name="l00025"></a>00025         
<a name="l00026"></a>00026         <span class="keyword">public</span>:
<a name="l00027"></a>00027         <span class="comment">// The different signs that a variable may have</span>
<a name="l00028"></a><a class="code" href="classaffineInequality.html#55888d879e043626426bc0847531610a">00028</a>         <span class="keyword">typedef</span> <span class="keyword">enum</span>{
<a name="l00029"></a>00029                 <span class="comment">// This variable's state is unknown</span>
<a name="l00030"></a>00030                 <a class="code" href="classaffineInequality.html#55888d879e043626426bc0847531610a87d106c32ee724687a49ff7cc61be146">unknownSgn</a>, 
<a name="l00031"></a>00031                 <span class="comment">// This variable is =zero</span>
<a name="l00032"></a>00032                 <a class="code" href="classaffineInequality.html#55888d879e043626426bc0847531610ad4b628a97aed14376e8ef677783c4c4a">eqZero</a>, 
<a name="l00033"></a>00033                 <span class="comment">// This variable is positive or =zero</span>
<a name="l00034"></a>00034                 <a class="code" href="classaffineInequality.html#55888d879e043626426bc0847531610ad8ca96f5566335e5104446216cd6b9bd">posZero</a>, 
<a name="l00035"></a>00035                 <span class="comment">// This variable is negative or =zero</span>
<a name="l00036"></a>00036                 <a class="code" href="classaffineInequality.html#55888d879e043626426bc0847531610ad6cfaa73834155d61664d3ca9b111cd3">negZero</a>} <a class="code" href="classaffineInequality.html#55888d879e043626426bc0847531610a">signs</a>;
<a name="l00037"></a>00037         
<a name="l00038"></a>00038         <span class="keyword">protected</span>:
<a name="l00039"></a>00039         <span class="comment">//varID y;</span>
<a name="l00040"></a><a class="code" href="classaffineInequality.html#d3add790137df2e6d70f7f049b67b13d">00040</a>         <span class="keywordtype">int</span> <a class="code" href="classaffineInequality.html#d3add790137df2e6d70f7f049b67b13d">a</a>;
<a name="l00041"></a><a class="code" href="classaffineInequality.html#f78c056dd6185e6c4ad574c826db915d">00041</a>         <span class="keywordtype">int</span> <a class="code" href="classaffineInequality.html#f78c056dd6185e6c4ad574c826db915d">b</a>;
<a name="l00042"></a><a class="code" href="classaffineInequality.html#bda6046bf5a05665a5e38d8e9d75f56c">00042</a>         <span class="keywordtype">int</span> <a class="code" href="classaffineInequality.html#bda6046bf5a05665a5e38d8e9d75f56c">c</a>;
<a name="l00043"></a>00043         
<a name="l00044"></a>00044         <span class="comment">// flags that indicate whether the x or y variables are = zeroVar</span>
<a name="l00045"></a><a class="code" href="classaffineInequality.html#1ca1af10885603d70f35a2daf7046866">00045</a>         <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#1ca1af10885603d70f35a2daf7046866">xZero</a>;
<a name="l00046"></a><a class="code" href="classaffineInequality.html#40268fbf761d63b2673db1cd347f073e">00046</a>         <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#40268fbf761d63b2673db1cd347f073e">yZero</a>;
<a name="l00047"></a>00047         
<a name="l00048"></a>00048         <span class="comment">// indicate the sign of x and y</span>
<a name="l00049"></a><a class="code" href="classaffineInequality.html#84f57625fdc8601b926cb09adb5471f6">00049</a>         <a class="code" href="classaffineInequality.html#55888d879e043626426bc0847531610a">signs</a> <a class="code" href="classaffineInequality.html#84f57625fdc8601b926cb09adb5471f6">xSign</a>;
<a name="l00050"></a><a class="code" href="classaffineInequality.html#c7b4e6f97948f436f95d945a1dedf43c">00050</a>         <a class="code" href="classaffineInequality.html#55888d879e043626426bc0847531610a">signs</a> <a class="code" href="classaffineInequality.html#c7b4e6f97948f436f95d945a1dedf43c">ySign</a>;
<a name="l00051"></a>00051         
<a name="l00052"></a>00052         <span class="keyword">public</span>:
<a name="l00053"></a>00053         <span class="comment">// Possible levels of this constraint. Above bottom the levels are ordered according to their </span>
<a name="l00054"></a>00054         <span class="comment">//    information content. False has the most content (admits fewest points), then a specific</span>
<a name="l00055"></a>00055         <span class="comment">//    affine inequality and finally, top, which represents a state where the true inequality is</span>
<a name="l00056"></a>00056         <span class="comment">//    too complex to be represented as an affine inequality, meaning that the only affine inequality</span>
<a name="l00057"></a>00057         <span class="comment">//    that can do the job is x &lt;= y + infinity.</span>
<a name="l00058"></a>00058         <span class="comment">// no constraint known since current constraints are not representable using a single affine </span>
<a name="l00059"></a>00059         <span class="comment">// inequality (i.e. x &lt;= y + infinity)</span>
<a name="l00060"></a><a class="code" href="classaffineInequality.html#5f2c233aa7930f81849ad3fe27942e8a">00060</a>         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">short</span> <a class="code" href="classaffineInequality.html#5f2c233aa7930f81849ad3fe27942e8a">top</a>=3;
<a name="l00061"></a>00061         <span class="comment">// some affine inequality constraint is known</span>
<a name="l00062"></a><a class="code" href="classaffineInequality.html#001b7122cd434f554ec1d1fb6f8f4465">00062</a>         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">short</span> <a class="code" href="classaffineInequality.html#001b7122cd434f554ec1d1fb6f8f4465">constrKnown</a>=2;
<a name="l00063"></a>00063         <span class="comment">// it is known that the affine constraints are inconsistent: x&lt;=y-infinity</span>
<a name="l00064"></a>00064         <span class="comment">//static const short falseConstr=1;</span>
<a name="l00065"></a>00065         <span class="comment">// the values of the variables are not constrained relative to each other (effectively, bottom == uninitialized)</span>
<a name="l00066"></a>00066         <span class="comment">// (this object would not even be created in this case)</span>
<a name="l00067"></a><a class="code" href="classaffineInequality.html#1dce7118c31ac587bf616056dec06cad">00067</a>         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">short</span> <a class="code" href="classaffineInequality.html#1dce7118c31ac587bf616056dec06cad">bottom</a>=0;
<a name="l00068"></a>00068         
<a name="l00069"></a>00069         <span class="keyword">protected</span>:
<a name="l00070"></a>00070         <span class="comment">// the current level in this constraint's lattice</span>
<a name="l00071"></a><a class="code" href="classaffineInequality.html#b80382a5d131f87c05493651221d50e2">00071</a>         <span class="keywordtype">short</span> <a class="code" href="classaffineInequality.html#b80382a5d131f87c05493651221d50e2">level</a>;
<a name="l00072"></a>00072         
<a name="l00073"></a>00073         <span class="keyword">public</span>:
<a name="l00074"></a>00074         
<a name="l00075"></a>00075         <a class="code" href="classaffineInequality.html#499f10bc37721e01345d57c40d27bf77">affineInequality</a>();
<a name="l00076"></a>00076         
<a name="l00077"></a>00077         <a class="code" href="classaffineInequality.html#499f10bc37721e01345d57c40d27bf77">affineInequality</a>(<span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>&amp; that);
<a name="l00078"></a>00078         
<a name="l00079"></a>00079         <a class="code" href="classaffineInequality.html#499f10bc37721e01345d57c40d27bf77">affineInequality</a>(<span class="keywordtype">int</span> <a class="code" href="classaffineInequality.html#d3add790137df2e6d70f7f049b67b13d">a</a>, <span class="keywordtype">int</span> <a class="code" href="classaffineInequality.html#f78c056dd6185e6c4ad574c826db915d">b</a>, <span class="keywordtype">int</span> <a class="code" href="classaffineInequality.html#bda6046bf5a05665a5e38d8e9d75f56c">c</a>, <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#1ca1af10885603d70f35a2daf7046866">xZero</a>, <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#40268fbf761d63b2673db1cd347f073e">yZero</a>, <a class="code" href="classaffineInequality.html#55888d879e043626426bc0847531610a">signs</a> <a class="code" href="classaffineInequality.html#84f57625fdc8601b926cb09adb5471f6">xSign</a>, <a class="code" href="classaffineInequality.html#55888d879e043626426bc0847531610a">signs</a> <a class="code" href="classaffineInequality.html#c7b4e6f97948f436f95d945a1dedf43c">ySign</a>);
<a name="l00080"></a>00080         
<a name="l00081"></a>00081         <span class="comment">// given a constraint on x, z and a constraint on z, y, infers the corresponding constraint on x, y </span>
<a name="l00082"></a>00082         <span class="comment">// and sets this constraint to it</span>
<a name="l00083"></a>00083         <a class="code" href="classaffineInequality.html#499f10bc37721e01345d57c40d27bf77">affineInequality</a>(<span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>&amp; xz, <span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>&amp; zy<span class="comment">/*, bool xZero, bool yZero, DivLattice* divX, DivLattice* divY, varID z*/</span>);
<a name="l00084"></a>00084         
<a name="l00085"></a>00085         <span class="keywordtype">void</span> <a class="code" href="classaffineInequality.html#8d33a8f8366055b927d27c47eae0e80c">operator=</a>(<span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>&amp; that);
<a name="l00086"></a>00086         
<a name="l00087"></a>00087         <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#6e2727b2939b8c18e786d4236b3670be">operator==</a>(<span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>&amp; that) <span class="keyword">const</span>;
<a name="l00088"></a>00088         
<a name="l00089"></a>00089         <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#c56ef30c40a2234fce6697bcb869e2ea">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>&amp; that) <span class="keyword">const</span>;
<a name="l00090"></a>00090         
<a name="l00091"></a>00091         <span class="comment">// lexicographic ordering (total order)</span>
<a name="l00092"></a>00092         <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#2eba60a177ab764657825944b30c5146">operator&lt;</a>(<span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>&amp; that) <span class="keyword">const</span>;
<a name="l00093"></a>00093         
<a name="l00094"></a>00094         <span class="comment">// Semantic affineInequality ordering (partial order)</span>
<a name="l00095"></a>00095         <span class="comment">// Returns true if this affineInequality represents less or more information (less information is </span>
<a name="l00096"></a>00096         <span class="comment">// top, more information is bottom) than that for all values of x and y and false otherwise</span>
<a name="l00097"></a>00097         <span class="comment">//bool operator&lt;&lt;(const affineInequality&amp; that) const;</span>
<a name="l00098"></a>00098         <span class="comment">// !!! NOTE: WE MAY WANT A SEMANTIC LESS-THAN-OR-EQ SINCE THAT CAN BE COMPUTED MORE PRECISELY BASED IN &lt;= INFORMATION</span>
<a name="l00099"></a>00099         <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#8f6715f54b05a5df98b44095a2f076cd">semLessThan</a>(<span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>&amp; that, <span class="keywordtype">bool</span> xEqZero, <span class="keywordtype">bool</span> yEqZero) <span class="keyword">const</span>;
<a name="l00100"></a>00100         <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#8f6715f54b05a5df98b44095a2f076cd">semLessThan</a>(<span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>&amp; that, 
<a name="l00101"></a>00101                     <span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>* <a class="code" href="classaffineInequality.html#1ca1af10885603d70f35a2daf7046866">xZero</a>, <span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>* zeroX,
<a name="l00102"></a>00102                     <span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>* <a class="code" href="classaffineInequality.html#40268fbf761d63b2673db1cd347f073e">yZero</a>, <span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>* zeroY, std::string indent=<span class="stringliteral">""</span>) <span class="keyword">const</span>;
<a name="l00103"></a>00103         <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#3b8bdb33454773765f00c55f51073dcb">semLessThanEq</a>(<span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>&amp; that, 
<a name="l00104"></a>00104                     <span class="keywordtype">bool</span> xIsZeroVar, 
<a name="l00105"></a>00105                     <span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>* <a class="code" href="classaffineInequality.html#1ca1af10885603d70f35a2daf7046866">xZero</a>, <span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>* zeroX,
<a name="l00106"></a>00106                     <span class="keywordtype">bool</span> yIsZeroVar,
<a name="l00107"></a>00107                     <span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>* <a class="code" href="classaffineInequality.html#40268fbf761d63b2673db1cd347f073e">yZero</a>, <span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>* zeroY, std::string indent=<span class="stringliteral">""</span>) <span class="keyword">const</span>;
<a name="l00108"></a>00108         
<a name="l00109"></a>00109         <span class="comment">// Semantic affineInequality ordering (partial order), focused on negated inequalities</span>
<a name="l00110"></a>00110         <span class="comment">// Returns true if the negation of this affineInequality represents more information (less information is </span>
<a name="l00111"></a>00111         <span class="comment">// top, more information is bottom) than the nagation of that for all values of x and y and false otherwise</span>
<a name="l00112"></a>00112         <span class="comment">//bool affineInequality::semLessThanNeg(const affineInequality&amp; that) const</span>
<a name="l00113"></a>00113         <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#25a6771a1d343e23566f4817562a9f43">semLessThanNeg</a>(<span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>&amp; that, <span class="keywordtype">bool</span> xEqZero, <span class="keywordtype">bool</span> yEqZero) <span class="keyword">const</span>;
<a name="l00114"></a>00114         
<a name="l00115"></a>00115         <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#9bebef892aaab86739041fc3e885c062">set</a>(<span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>&amp; that);
<a name="l00116"></a>00116         
<a name="l00117"></a>00117         <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#9bebef892aaab86739041fc3e885c062">set</a>(<span class="keywordtype">int</span> <a class="code" href="classaffineInequality.html#d3add790137df2e6d70f7f049b67b13d">a</a>, <span class="keywordtype">int</span> <a class="code" href="classaffineInequality.html#f78c056dd6185e6c4ad574c826db915d">b</a>, <span class="keywordtype">int</span> <a class="code" href="classaffineInequality.html#bda6046bf5a05665a5e38d8e9d75f56c">c</a>);
<a name="l00118"></a>00118         <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#9bebef892aaab86739041fc3e885c062">set</a>(<span class="keywordtype">int</span> <a class="code" href="classaffineInequality.html#d3add790137df2e6d70f7f049b67b13d">a</a>, <span class="keywordtype">int</span> <a class="code" href="classaffineInequality.html#f78c056dd6185e6c4ad574c826db915d">b</a>, <span class="keywordtype">int</span> <a class="code" href="classaffineInequality.html#bda6046bf5a05665a5e38d8e9d75f56c">c</a>, <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#1ca1af10885603d70f35a2daf7046866">xZero</a>, <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#40268fbf761d63b2673db1cd347f073e">yZero</a>, <a class="code" href="classaffineInequality.html#55888d879e043626426bc0847531610a">signs</a> <a class="code" href="classaffineInequality.html#84f57625fdc8601b926cb09adb5471f6">xSign</a>, <a class="code" href="classaffineInequality.html#55888d879e043626426bc0847531610a">signs</a> <a class="code" href="classaffineInequality.html#c7b4e6f97948f436f95d945a1dedf43c">ySign</a>);
<a name="l00119"></a>00119         
<a name="l00120"></a>00120         <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#c61dafb8306cd0331637bd053f368650">setA</a>(<span class="keywordtype">int</span> <a class="code" href="classaffineInequality.html#d3add790137df2e6d70f7f049b67b13d">a</a>);
<a name="l00121"></a>00121         
<a name="l00122"></a>00122         <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#e4b617124d193951571e0c82ea96bbef">setB</a>(<span class="keywordtype">int</span> <a class="code" href="classaffineInequality.html#f78c056dd6185e6c4ad574c826db915d">b</a>);
<a name="l00123"></a>00123         
<a name="l00124"></a>00124         <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#b3f2d0f63cf516d233444ad6ccf510c8">setC</a>(<span class="keywordtype">int</span> <a class="code" href="classaffineInequality.html#bda6046bf5a05665a5e38d8e9d75f56c">c</a>);
<a name="l00125"></a>00125         
<a name="l00126"></a>00126         <span class="comment">// sets this constraint object to bottom</span>
<a name="l00127"></a>00127         <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#c0ac62a730dd0a69165432f53fa25d31">setToBottom</a>();
<a name="l00128"></a>00128         
<a name="l00129"></a>00129         <span class="comment">// sets this constraint object to false</span>
<a name="l00130"></a>00130         <span class="comment">//bool setToFalse();</span>
<a name="l00131"></a>00131         
<a name="l00132"></a>00132         <span class="comment">// sets this constraint object to top</span>
<a name="l00133"></a>00133         <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#0d1fceaa286f624c39a29f244b3b7cde">setToTop</a>();
<a name="l00134"></a>00134         
<a name="l00135"></a>00135         <span class="comment">// returns y, a, b or c</span>
<a name="l00136"></a>00136         
<a name="l00137"></a>00137         <span class="keywordtype">int</span> <a class="code" href="classaffineInequality.html#7e3b13dddf4a09a5db03be4964c0b681">getA</a>() <span class="keyword">const</span>;
<a name="l00138"></a>00138         
<a name="l00139"></a>00139         <span class="keywordtype">int</span> <a class="code" href="classaffineInequality.html#556057f3ade39112c1efb135fe2b5659">getB</a>() <span class="keyword">const</span>;
<a name="l00140"></a>00140         
<a name="l00141"></a>00141         <span class="keywordtype">int</span> <a class="code" href="classaffineInequality.html#ee4326b27337996959fedba00ad6bf25">getC</a>() <span class="keyword">const</span>;
<a name="l00142"></a>00142         
<a name="l00143"></a>00143         <span class="keywordtype">short</span> <a class="code" href="classaffineInequality.html#5052c641f75f1650f73df1d1cfa32ce8">getLevel</a>() <span class="keyword">const</span>;
<a name="l00144"></a>00144         
<a name="l00145"></a>00145         <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#a82bec5c394d0edbed4ba802b3176515">isXZero</a>() <span class="keyword">const</span>;
<a name="l00146"></a>00146         <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#e635dfa35ce321c10f3c54d71d0d3e03">isYZero</a>() <span class="keyword">const</span>;
<a name="l00147"></a>00147         
<a name="l00148"></a>00148         <a class="code" href="classaffineInequality.html#55888d879e043626426bc0847531610a">signs</a> <a class="code" href="classaffineInequality.html#086b2b58268d73c45edb60f44f959f9e">getXSign</a>() <span class="keyword">const</span>;
<a name="l00149"></a>00149         <a class="code" href="classaffineInequality.html#55888d879e043626426bc0847531610a">signs</a> <a class="code" href="classaffineInequality.html#1e7f2e01904c00069db1e12f81124c94">getYSign</a>() <span class="keyword">const</span>;
<a name="l00150"></a>00150         
<a name="l00151"></a>00151         <span class="keyword">protected</span>:
<a name="l00152"></a>00152         <span class="comment">// divide out from a, b and c any common factors, reducing the triple to its normal form</span>
<a name="l00153"></a>00153         <span class="comment">// return true if this modifies this constraint and false otherwise</span>
<a name="l00154"></a>00154         <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#9388c3f66ecdf6a0a72137a18d84c60f">normalize</a>();
<a name="l00155"></a>00155         
<a name="l00156"></a>00156         <span class="keyword">public</span>:
<a name="l00157"></a>00157         <span class="comment">// INTERSECT this with that, saving the result in this</span>
<a name="l00158"></a>00158         <span class="comment">// Intersection = the affine inequality that contains the constraint information of both</span>
<a name="l00159"></a>00159         <span class="comment">//         this AND that (i.e. the line that is lower than both lines)</span>
<a name="l00160"></a>00160         <span class="comment">// (moves this/that upward in the lattice)</span>
<a name="l00161"></a>00161         <span class="keywordtype">void</span> <a class="code" href="classaffineInequality.html#d659dd96e08292c9feaf466fe2a0f71b">operator*=</a>(<span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>&amp; that);
<a name="l00162"></a>00162         
<a name="l00163"></a>00163         <span class="comment">// Just like *=, except intersectUpd() returns true if the operation causes this</span>
<a name="l00164"></a>00164         <span class="comment">// affineInequality to change and false otherwise.</span>
<a name="l00165"></a>00165         <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#a844b970626326519487486426c4f8bf">intersectUpd</a>(<span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>&amp; that);
<a name="l00166"></a>00166 
<a name="l00167"></a>00167         <span class="comment">// UNION this with that, saving the result in this</span>
<a name="l00168"></a>00168         <span class="comment">// Union = the affine inequality that contains no more information than either</span>
<a name="l00169"></a>00169         <span class="comment">//         this OR that (i.e. the line that is higher than both lines)</span>
<a name="l00170"></a>00170         <span class="comment">// (moves this/that downward in the lattice)</span>
<a name="l00171"></a>00171         <span class="keywordtype">void</span> <a class="code" href="classaffineInequality.html#6dc984ea36d76558d7e42716178cbbd8">operator+=</a>(<span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>&amp; that);
<a name="l00172"></a>00172         
<a name="l00173"></a>00173         <span class="comment">// Just like +=, except unionUpd() returns true if the operation causes this</span>
<a name="l00174"></a>00174         <span class="comment">// affineInequality to change and false otherwise.</span>
<a name="l00175"></a>00175         <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#4189bb9c144a38e62285af09acbce3f1">unionUpd</a>(<span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>&amp; that);
<a name="l00176"></a>00176         
<a name="l00177"></a>00177         <span class="comment">// WIDEN this with that, saving the result in this</span>
<a name="l00178"></a>00178         <span class="comment">//void operator^=(const affineInequality&amp; that);</span>
<a name="l00179"></a>00179         
<a name="l00180"></a>00180         <span class="comment">// returns true if the x-y constraint constrXY is consistent with the y-x constraint constrYX for </span>
<a name="l00181"></a>00181         <span class="comment">// some values of x and y and false otherwise. Since affineInequalities are conservative in the</span>
<a name="l00182"></a>00182         <span class="comment">// sense that they don't contain any more information than is definitely true, it may be</span>
<a name="l00183"></a>00183         <span class="comment">// that the true constraints are in fact inconsistent but we do not have enough information to</span>
<a name="l00184"></a>00184         <span class="comment">// prove this.</span>
<a name="l00185"></a>00185         <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classaffineInequality.html#2d66ba33fa8b3aa648d224a6611cb31a">mayConsistent</a>(<span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>&amp; constrXY, <span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>&amp; constrYX);
<a name="l00186"></a>00186         
<a name="l00187"></a>00187         <span class="keyword">static</span> std::string <a class="code" href="classaffineInequality.html#494e2f81e99eee3a962cf2eca0a2ba51">signToString</a>(<a class="code" href="classaffineInequality.html#55888d879e043626426bc0847531610a">signs</a> sign);
<a name="l00188"></a>00188         
<a name="l00189"></a>00189         std::string <a class="code" href="classaffineInequality.html#0051ccece9848473657ec92c630c3966">str</a>(std::string indent=<span class="stringliteral">""</span>);
<a name="l00190"></a>00190         std::string <a class="code" href="classaffineInequality.html#0051ccece9848473657ec92c630c3966">str</a>(std::string indent=<span class="stringliteral">""</span>) <span class="keyword">const</span>;
<a name="l00191"></a>00191         
<a name="l00192"></a>00192         std::string <a class="code" href="classaffineInequality.html#0051ccece9848473657ec92c630c3966">str</a>(<a class="code" href="classvarID.html">varID</a> <a class="code" href="classvarAffineInequality.html#415e6e0922be908c5728a19cd407011b">x</a>, <a class="code" href="classvarID.html">varID</a> <a class="code" href="classvarAffineInequality.html#00eeea5bdf94aa8c61c9db5bc056d4b3">y</a>, std::string indent=<span class="stringliteral">""</span>) <span class="keyword">const</span>;
<a name="l00193"></a>00193         <span class="comment">// Prints out the negation of the constraint ax &lt;= by+c</span>
<a name="l00194"></a>00194         std::string <a class="code" href="classaffineInequality.html#01e23c114fdaaff8115bdc3f6d9880d0">strNeg</a>(<a class="code" href="classvarID.html">varID</a> <a class="code" href="classvarAffineInequality.html#415e6e0922be908c5728a19cd407011b">x</a>, <a class="code" href="classvarID.html">varID</a> <a class="code" href="classvarAffineInequality.html#00eeea5bdf94aa8c61c9db5bc056d4b3">y</a>, std::string indent) <span class="keyword">const</span>;
<a name="l00195"></a>00195         
<a name="l00196"></a>00196         <span class="keyword">public</span>:
<a name="l00197"></a>00197         <span class="comment">// the basic logical operations that must be supported by any implementation of </span>
<a name="l00198"></a>00198         <span class="comment">// a logical condition: NOT, AND and OR</span>
<a name="l00199"></a>00199         <span class="comment">/*void notUpd();</span>
<a name="l00200"></a>00200 <span class="comment">        void andUpd(LogicalCond&amp; that);</span>
<a name="l00201"></a>00201 <span class="comment">        void orUpd(LogicalCond&amp; that);*/</span>
<a name="l00202"></a>00202 };
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 <span class="comment">// represents a full affine inequality, including the variables involved in the inequality</span>
<a name="l00205"></a><a class="code" href="classvarAffineInequality.html">00205</a> <span class="keyword">class </span><a class="code" href="classvarAffineInequality.html">varAffineInequality</a> : <span class="keyword">public</span> <a class="code" href="classprintable.html">printable</a> <span class="comment">//: public LogicalCond</span>
<a name="l00206"></a>00206 {
<a name="l00207"></a>00207         <span class="keyword">protected</span>:
<a name="l00208"></a><a class="code" href="classvarAffineInequality.html#415e6e0922be908c5728a19cd407011b">00208</a>         <a class="code" href="classvarID.html">varID</a> <a class="code" href="classvarAffineInequality.html#415e6e0922be908c5728a19cd407011b">x</a>;
<a name="l00209"></a><a class="code" href="classvarAffineInequality.html#00eeea5bdf94aa8c61c9db5bc056d4b3">00209</a>         <a class="code" href="classvarID.html">varID</a> <a class="code" href="classvarAffineInequality.html#00eeea5bdf94aa8c61c9db5bc056d4b3">y</a>;
<a name="l00210"></a><a class="code" href="classvarAffineInequality.html#9adbf173deffde5bdd841f4348208854">00210</a>         <a class="code" href="classaffineInequality.html">affineInequality</a> <a class="code" href="classvarAffineInequality.html#9adbf173deffde5bdd841f4348208854">ineq</a>;
<a name="l00211"></a>00211         
<a name="l00212"></a>00212         <span class="keyword">public</span>:
<a name="l00213"></a>00213         <a class="code" href="classvarAffineInequality.html#c5080d53e1cdc61a92aa9400174aab93">varAffineInequality</a>(<span class="keyword">const</span> <a class="code" href="classvarAffineInequality.html">varAffineInequality</a>&amp; that);
<a name="l00214"></a>00214         
<a name="l00215"></a>00215         <a class="code" href="classvarAffineInequality.html#c5080d53e1cdc61a92aa9400174aab93">varAffineInequality</a>(<span class="keyword">const</span> <a class="code" href="classvarID.html">varID</a>&amp; <a class="code" href="classvarAffineInequality.html#415e6e0922be908c5728a19cd407011b">x</a>, <span class="keyword">const</span> <a class="code" href="classvarID.html">varID</a>&amp; <a class="code" href="classvarAffineInequality.html#00eeea5bdf94aa8c61c9db5bc056d4b3">y</a>, <span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>&amp; <a class="code" href="classvarAffineInequality.html#9adbf173deffde5bdd841f4348208854">ineq</a>);
<a name="l00216"></a>00216         
<a name="l00217"></a>00217         <a class="code" href="classvarAffineInequality.html#c5080d53e1cdc61a92aa9400174aab93">varAffineInequality</a>(<span class="keyword">const</span> <a class="code" href="classvarID.html">varID</a>&amp; <a class="code" href="classvarAffineInequality.html#415e6e0922be908c5728a19cd407011b">x</a>, <span class="keyword">const</span> <a class="code" href="classvarID.html">varID</a>&amp; <a class="code" href="classvarAffineInequality.html#00eeea5bdf94aa8c61c9db5bc056d4b3">y</a>, <span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b, <span class="keywordtype">int</span> c, <span class="keywordtype">bool</span> xZero, <span class="keywordtype">bool</span> yZero);
<a name="l00218"></a>00218         
<a name="l00219"></a>00219         <span class="comment">// get methods</span>
<a name="l00220"></a>00220         <span class="comment">/*varID&amp; getX() const;</span>
<a name="l00221"></a>00221 <span class="comment">        </span>
<a name="l00222"></a>00222 <span class="comment">        varID&amp; getY() const;</span>
<a name="l00223"></a>00223 <span class="comment">        </span>
<a name="l00224"></a>00224 <span class="comment">        affineInequality&amp; getIneq() const;*/</span>
<a name="l00225"></a>00225         
<a name="l00226"></a>00226         <span class="keyword">const</span> <a class="code" href="classvarID.html">varID</a>&amp; <a class="code" href="classvarAffineInequality.html#60f02a30af72f14b40721dd95a0eed6e">getX</a>() <span class="keyword">const</span>;
<a name="l00227"></a>00227         
<a name="l00228"></a>00228         <span class="keyword">const</span> <a class="code" href="classvarID.html">varID</a>&amp; <a class="code" href="classvarAffineInequality.html#092fe32d4b41b25a83b14b43da6ba4d0">getY</a>() <span class="keyword">const</span>;
<a name="l00229"></a>00229         
<a name="l00230"></a>00230         <span class="keywordtype">int</span> <a class="code" href="classvarAffineInequality.html#ed41fd7c4bacb214bed8248e1366ae0d">getA</a>() <span class="keyword">const</span>;
<a name="l00231"></a>00231         
<a name="l00232"></a>00232         <span class="keywordtype">int</span> <a class="code" href="classvarAffineInequality.html#0e012585ae8dc84231a105795e39470f">getB</a>() <span class="keyword">const</span>;
<a name="l00233"></a>00233         
<a name="l00234"></a>00234         <span class="keywordtype">int</span> <a class="code" href="classvarAffineInequality.html#264d7e2f816bb47b4b03243d1aaed985">getC</a>() <span class="keyword">const</span>;
<a name="l00235"></a>00235         
<a name="l00236"></a>00236         
<a name="l00237"></a>00237         <span class="keyword">const</span> <a class="code" href="classaffineInequality.html">affineInequality</a>&amp; <a class="code" href="classvarAffineInequality.html#5b8635c8294402b5f76f7c059a56fa49">getIneq</a>() <span class="keyword">const</span>;
<a name="l00238"></a>00238         
<a name="l00239"></a>00239         <span class="comment">// set methods, return true if this object changes</span>
<a name="l00240"></a>00240         <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="classvarAffineInequality.html#4157f7dc78fd78e5f47bbd5d8d1b4d94">setX</a>(<span class="keyword">const</span> <a class="code" href="classvarID.html">varID</a>&amp; <a class="code" href="classvarAffineInequality.html#415e6e0922be908c5728a19cd407011b">x</a>);
<a name="l00241"></a>00241         
<a name="l00242"></a>00242         <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="classvarAffineInequality.html#d295d5eadc144edad6e9db197f65e23c">setY</a>(<span class="keyword">const</span> <a class="code" href="classvarID.html">varID</a>&amp; <a class="code" href="classvarAffineInequality.html#00eeea5bdf94aa8c61c9db5bc056d4b3">y</a>);
<a name="l00243"></a>00243         
<a name="l00244"></a>00244         <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="classvarAffineInequality.html#9f5cd78de34027a72ebfa8a691d4145c">setA</a>(<span class="keywordtype">int</span> a);
<a name="l00245"></a>00245         
<a name="l00246"></a>00246         <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="classvarAffineInequality.html#2a5b9a3863d8ea4ad993cff683ba94a4">setB</a>(<span class="keywordtype">int</span> b);
<a name="l00247"></a>00247         
<a name="l00248"></a>00248         <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="classvarAffineInequality.html#314bebd71e8ea0b8a3885cc7735f76a2">setC</a>(<span class="keywordtype">int</span> c);
<a name="l00249"></a>00249         
<a name="l00250"></a>00250         <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="classvarAffineInequality.html#7c8b71ddd14c9e617850761cedeb2dce">setIneq</a>(<a class="code" href="classaffineInequality.html">affineInequality</a>&amp; <a class="code" href="classvarAffineInequality.html#9adbf173deffde5bdd841f4348208854">ineq</a>);
<a name="l00251"></a>00251         
<a name="l00252"></a>00252         <span class="comment">// comparison methods</span>
<a name="l00253"></a>00253         <span class="keywordtype">bool</span> <a class="code" href="classvarAffineInequality.html#fb6dfc5173245250de3cdbbb34372f8b">operator==</a>(<span class="keyword">const</span> <a class="code" href="classvarAffineInequality.html">varAffineInequality</a>&amp; that) <span class="keyword">const</span>;
<a name="l00254"></a>00254         
<a name="l00255"></a>00255         <span class="keywordtype">bool</span> <a class="code" href="classvarAffineInequality.html#51b1d74fa6e3eaac7b3c4c040a920c08">operator&lt;</a>(<span class="keyword">const</span> <a class="code" href="classvarAffineInequality.html">varAffineInequality</a>&amp; that) <span class="keyword">const</span>;
<a name="l00256"></a>00256         
<a name="l00257"></a>00257         std::string <a class="code" href="classvarAffineInequality.html#ad7e9aeaee75969820316d815d2a4c3d">str</a>(std::string indent=<span class="stringliteral">""</span>);
<a name="l00258"></a>00258 
<a name="l00259"></a>00259         std::string <a class="code" href="classvarAffineInequality.html#ad7e9aeaee75969820316d815d2a4c3d">str</a>(std::string indent=<span class="stringliteral">""</span>) <span class="keyword">const</span>;
<a name="l00260"></a>00260         
<a name="l00261"></a>00261         <span class="comment">// Parses expr and returns the corresponding varAffineInequality if expr can be represented</span>
<a name="l00262"></a>00262         <span class="comment">// as such and NULL otherwise.</span>
<a name="l00263"></a>00263         <span class="comment">//static varAffineInequality* parseIneq(SgExpression* expr);</span>
<a name="l00264"></a>00264         
<a name="l00265"></a>00265         <span class="keyword">public</span>:
<a name="l00266"></a>00266         <span class="comment">// the basic logical operations that must be supported by any implementation of </span>
<a name="l00267"></a>00267         <span class="comment">// a logical condition: NOT, AND and OR</span>
<a name="l00268"></a>00268         <span class="comment">/*void notUpd();</span>
<a name="l00269"></a>00269 <span class="comment">        void andUpd(LogicalCond&amp; that);</span>
<a name="l00270"></a>00270 <span class="comment">        void orUpd(LogicalCond&amp; that);</span>
<a name="l00271"></a>00271 <span class="comment">        </span>
<a name="l00272"></a>00272 <span class="comment">        // returns a copy of this LogicalCond object</span>
<a name="l00273"></a>00273 <span class="comment">        LogicalCond* copy();*/</span>
<a name="l00274"></a>00274 };
<a name="l00275"></a>00275 
<a name="l00276"></a>00276 <span class="comment">/****************************</span>
<a name="l00277"></a>00277 <span class="comment"> *** affineInequalityFact ***</span>
<a name="l00278"></a>00278 <span class="comment"> ****************************/</span>
<a name="l00279"></a>00279 
<a name="l00280"></a><a class="code" href="classaffineInequalityFact.html">00280</a> <span class="keyword">class </span><a class="code" href="classaffineInequalityFact.html">affineInequalityFact</a> : <span class="keyword">public</span> <a class="code" href="classNodeFact.html">NodeFact</a>
<a name="l00281"></a>00281 {
<a name="l00282"></a>00282         <span class="keyword">public</span>:
<a name="l00283"></a><a class="code" href="classaffineInequalityFact.html#268ea4fcf734f4cb54dfe476be967c05">00283</a>         std::set&lt;varAffineInequality&gt; <a class="code" href="classaffineInequalityFact.html#268ea4fcf734f4cb54dfe476be967c05">ineqs</a>;
<a name="l00284"></a>00284         
<a name="l00285"></a><a class="code" href="classaffineInequalityFact.html#5d98cdd2be385fbacd34478dac65891f">00285</a>         <a class="code" href="classaffineInequalityFact.html#5d98cdd2be385fbacd34478dac65891f">affineInequalityFact</a>()
<a name="l00286"></a>00286         {}
<a name="l00287"></a>00287         
<a name="l00288"></a><a class="code" href="classaffineInequalityFact.html#452ef847f47dad950ab19039ea150716">00288</a>         <a class="code" href="classaffineInequalityFact.html#5d98cdd2be385fbacd34478dac65891f">affineInequalityFact</a>(<span class="keyword">const</span> <a class="code" href="classaffineInequalityFact.html">affineInequalityFact</a>&amp; that)
<a name="l00289"></a>00289         {
<a name="l00290"></a>00290                 this-&gt;<a class="code" href="classaffineInequalityFact.html#268ea4fcf734f4cb54dfe476be967c05">ineqs</a> = that.<a class="code" href="classaffineInequalityFact.html#268ea4fcf734f4cb54dfe476be967c05">ineqs</a>;
<a name="l00291"></a>00291         }
<a name="l00292"></a>00292         
<a name="l00293"></a>00293         <a class="code" href="classNodeFact.html">NodeFact</a>* <a class="code" href="classaffineInequalityFact.html#a0dc1903118452d0db8cc84c0a867062">copy</a>() <span class="keyword">const</span>;
<a name="l00294"></a>00294         
<a name="l00295"></a>00295         std::string <a class="code" href="classaffineInequalityFact.html#bf56fec11dd2b989ad7fd591e428a430">str</a>(std::string indent=<span class="stringliteral">""</span>);
<a name="l00296"></a>00296         std::string <a class="code" href="classaffineInequalityFact.html#bf56fec11dd2b989ad7fd591e428a430">str</a>(std::string indent=<span class="stringliteral">""</span>) <span class="keyword">const</span>;
<a name="l00297"></a>00297 };
<a name="l00298"></a>00298 
<a name="l00299"></a>00299 
<a name="l00300"></a>00300 <span class="comment">/********************************</span>
<a name="l00301"></a>00301 <span class="comment"> *** affineInequalitiesPlacer ***</span>
<a name="l00302"></a>00302 <span class="comment"> ********************************/</span>
<a name="l00303"></a>00303 <span class="comment">// points trueIneqFact and falseIneqFact to freshly allocated objects that represent the true and false</span>
<a name="l00304"></a>00304 <span class="comment">// branches of the control flow guarded by the given expression. They are set to NULL if our representation</span>
<a name="l00305"></a>00305 <span class="comment">// cannot represent one of the expressions.</span>
<a name="l00306"></a>00306 <span class="comment">// doFalseBranch - if =true, falseIneqFact is set to the correct false-branch condition and to NULL otherwise</span>
<a name="l00307"></a>00307 <span class="keywordtype">void</span> <a class="code" href="affineInequality_8h.html#61875de08dc55401e3c165dd866e8482">setTrueFalseIneq</a>(<a class="code" href="classSgExpression.html">SgExpression</a>* expr, 
<a name="l00308"></a>00308                       <a class="code" href="classaffineInequalityFact.html">affineInequalityFact</a> **trueIneqFact, <a class="code" href="classaffineInequalityFact.html">affineInequalityFact</a> **falseIneqFact, 
<a name="l00309"></a>00309                       <span class="keywordtype">bool</span> doFalseBranch);
<a name="l00310"></a>00310                                      
<a name="l00311"></a><a class="code" href="classaffineInequalitiesPlacer.html">00311</a> <span class="keyword">class </span><a class="code" href="classaffineInequalitiesPlacer.html">affineInequalitiesPlacer</a> : <span class="keyword">public</span> <a class="code" href="classUnstructuredPassIntraAnalysis.html">UnstructuredPassIntraAnalysis</a>
<a name="l00312"></a>00312 {
<a name="l00313"></a>00313         <span class="keyword">public</span>:
<a name="l00314"></a>00314         <span class="keywordtype">void</span> <a class="code" href="classaffineInequalitiesPlacer.html#5da735afd2288e265b9f1e94ca7cd579">visit</a>(<span class="keyword">const</span> <a class="code" href="classFunction.html">Function</a>&amp; func, <span class="keyword">const</span> <a class="code" href="classVirtualCFG_1_1DataflowNode.html">DataflowNode</a>&amp; n, <a class="code" href="classNodeState.html">NodeState</a>&amp; state);
<a name="l00315"></a>00315 };
<a name="l00316"></a>00316 
<a name="l00317"></a>00317 <span class="comment">/*// Looks over all the conditional statements in the application and associates appropriate </span>
<a name="l00318"></a>00318 <span class="comment">//    affine inequalities with the SgNodes that depend on these statements. Each inequality</span>
<a name="l00319"></a>00319 <span class="comment">//    is a must: it must be true of the node that it is associated with.</span>
<a name="l00320"></a>00320 <span class="comment">void initAffineIneqs(SgProject* project);</span>
<a name="l00321"></a>00321 <span class="comment"></span>
<a name="l00322"></a>00322 <span class="comment">// return the set of varAffineInequalities associated with this node or NULL if none are available</span>
<a name="l00323"></a>00323 <span class="comment">std::set&lt;varAffineInequality&gt;* getAffineIneq(SgNode* n);*/</span>
<a name="l00324"></a>00324 
<a name="l00325"></a>00325 <span class="comment">/*class printAffineInequalities : public UnstructuredPassIntraAnalysis</span>
<a name="l00326"></a>00326 <span class="comment">{</span>
<a name="l00327"></a>00327 <span class="comment">        affineInequalitiesPlacer* placer;</span>
<a name="l00328"></a>00328 <span class="comment">        </span>
<a name="l00329"></a>00329 <span class="comment">        public:</span>
<a name="l00330"></a>00330 <span class="comment">        printAffineInequalities(affineInequalitiesPlacer *placer);</span>
<a name="l00331"></a>00331 <span class="comment">                </span>
<a name="l00332"></a>00332 <span class="comment">        void visit(const Function&amp; func, const DataflowNode&amp; n, NodeState&amp; state);</span>
<a name="l00333"></a>00333 <span class="comment">};*/</span>
<a name="l00334"></a>00334 
<a name="l00335"></a>00335 <span class="comment">// prints the inequality facts set by the given affineInequalityPlacer</span>
<a name="l00336"></a>00336 <span class="keywordtype">void</span> <a class="code" href="affineInequality_8h.html#338ab6cc717e821c5af38f206ecd36af">printAffineInequalities</a>(<a class="code" href="classaffineInequalitiesPlacer.html">affineInequalitiesPlacer</a>* aip, std::string indent=<span class="stringliteral">""</span>);
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 <span class="comment">// Runs the Affine Inequality Placer analysis</span>
<a name="l00339"></a>00339 <span class="keywordtype">void</span> <a class="code" href="affineInequality_8h.html#87ca6a8c8ff26514f7e3b426abc38c10">runAffineIneqPlacer</a>(<span class="keywordtype">bool</span> printStates=<span class="keyword">false</span>);
<a name="l00340"></a>00340 
<a name="l00341"></a>00341 <span class="comment">// returns the set of inequalities known to be true at the given DataflowNode</span>
<a name="l00342"></a>00342 <span class="keyword">const</span> std::set&lt;varAffineInequality&gt;&amp; <a class="code" href="affineInequality_8h.html#68ebc7049ca8caa859ff4ce15f9fa0b8">getAffineIneq</a>(<span class="keyword">const</span> <a class="code" href="classVirtualCFG_1_1DataflowNode.html">DataflowNode</a>&amp; n);
<a name="l00343"></a>00343 
<a name="l00344"></a>00344 <span class="comment">// Returns the set of inequalities known to be true at the given DataflowNode's descendants</span>
<a name="l00345"></a>00345 std::list&lt;std::set&lt;varAffineInequality&gt; &gt; <a class="code" href="affineInequality_8h.html#e91802c1b5971b95497092291640b5bb">getAffineIneqDesc</a>(<span class="keyword">const</span> <a class="code" href="classVirtualCFG_1_1DataflowNode.html">DataflowNode</a>&amp; n);
<a name="l00346"></a>00346 
<a name="l00347"></a>00347 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
