<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: Todo List</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1><a class="anchor" name="todo">Todo List</a></h1><a class="anchor" name="_todo000147"></a> <dl>
<dt>Class <a class="el" href="classAst.html">Ast</a>  </dt>
<dd>(DQ 2/1/2006): Could we please change the name of this class, it is not an AST.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000001"></a> <dl>
<dt>Class <a class="el" href="classAST__FILE__IO.html">AST_FILE_IO</a>  </dt>
<dd>Consider making this a namespace.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000001"></a> <dl>
<dt>Class <a class="el" href="classAST__FILE__IO.html">AST_FILE_IO</a>  </dt>
<dd>For the general file IO we should consider a special file name, similar to "rose_..."<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000009"></a> <dl>
<dt>Class <a class="el" href="classAstSimpleProcessing.html">AstSimpleProcessing</a>  </dt>
<dd>Make options 'preorder' and 'postorder' local to the class (will brake user code).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000160"></a> <dl>
<dt>Class <a class="el" href="classDOTGeneration.html">DOTGeneration</a>  </dt>
<dd>Finish documentation! </dd>
</dl>
<p>
<a class="anchor" name="_todo000161"></a> <dl>
<dt>Class <a class="el" href="classDOTInheritedAttribute.html">DOTInheritedAttribute</a>  </dt>
<dd>Finish documentation! </dd>
</dl>
<p>
<a class="anchor" name="_todo000163"></a> <dl>
<dt>Class <a class="el" href="classDOTRepresentation.html">DOTRepresentation</a>  </dt>
<dd>Finish documentation! </dd>
</dl>
<p>
<a class="anchor" name="_todo000162"></a> <dl>
<dt>Class <a class="el" href="classDOTSynthesizedAttribute.html">DOTSynthesizedAttribute</a>  </dt>
<dd>Finish documentation! </dd>
</dl>
<p>
<a class="anchor" name="_todo000165"></a> <dl>
<dt>Class <a class="el" href="classPDFGeneration.html">PDFGeneration</a>  </dt>
<dd>Finish documentation! </dd>
</dl>
<p>
<a class="anchor" name="_todo000166"></a> <dl>
<dt>Class <a class="el" href="classPDFInheritedAttribute.html">PDFInheritedAttribute</a>  </dt>
<dd>Finish documentation! </dd>
</dl>
<p>
<a class="anchor" name="_todo000036"></a> <dl>
<dt>Class <a class="el" href="classSg__File__Info.html">Sg_File_Info</a>  </dt>
<dd>isOutputInCodeGeneration() is orthogonal to isCompilerGenerated and isTransformation(). Currently IR nodes that are marked as isTransformation() are output, but these need to be marked as also being isOutputInCodeGeneration() so that orthogonality of the concepts is maintained.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000036"></a> <dl>
<dt>Class <a class="el" href="classSg__File__Info.html">Sg_File_Info</a>  </dt>
<dd>It is possible to call get_file_info() on a SgFileInfo object and this needs to be fixed because it does not make any sense. This is because get_file_info is defined as a virtual function on <a class="el" href="classSgNode.html">SgNode</a>. Not sure this is a great design, but maybe it just needs a local implementation of a private get_file_info() member function so that it can't be called (can be hidden).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000036"></a> <dl>
<dt>Class <a class="el" href="classSg__File__Info.html">Sg_File_Info</a>  </dt>
<dd>Should there be a simpler way to copy a SgFileInfo object than: "new Sg_File_Info(*fileInfo);" or "fileInfo-&gt;copy();"; likely not!<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000036"></a> <dl>
<dt>Class <a class="el" href="classSg__File__Info.html">Sg_File_Info</a>  </dt>
<dd>Define the subset of IR nodes which would all have:<ol type=1>
<li><a class="el" href="classSg__File__Info.html">Sg_File_Info</a></li><li><a class="el" href="classAstAttributeMechanism.html">AstAttributeMechanism</a></li><li><a class="el" href="classSgNode.html">SgNode</a> (parent pointer) <br>
 This will make the documentation more intuative. The argument supporting this is that we operate on those IR nodes that correspond to the visual representation of the source code (so we can exclude SgSymbols, and SgTypes). Having the same subset of IR nodes permits a simpler documentation of the API and intuition as to where it applies. A likely subset would be:</li><li>SgLocatedNodes</li><li><a class="el" href="classSgFile.html">SgFile</a></li><li><a class="el" href="classSgDirectory.html">SgDirectory</a> (questionable)</li><li><a class="el" href="classSgInitializedName.html">SgInitializedName</a></li><li><a class="el" href="classSgBaseClass.html">SgBaseClass</a></li><li><a class="el" href="classSgTemplateArgument.html">SgTemplateArgument</a></li><li><a class="el" href="classSgTemplateParameter.html">SgTemplateParameter</a></li></ol>
<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000036"></a> <dl>
<dt>Class <a class="el" href="classSg__File__Info.html">Sg_File_Info</a>  </dt>
<dd>Remove the functions: isCompilerGeneratedNodeToBeUnparsed(), setCompilerGeneratedNodeToBeUnparsed(), and unsetCompilerGeneratedNodeToBeUnparsed() from where they are called.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000036"></a> <dl>
<dt>Class <a class="el" href="classSg__File__Info.html">Sg_File_Info</a>  </dt>
<dd>Consider putting the endOfConstruct information into the single <a class="el" href="classSg__File__Info.html">Sg_File_Info</a> object. Currently the <a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> stores two <a class="el" href="classSg__File__Info.html">Sg_File_Info</a> objects, one for the beginning and the end of each construct. This would save significant space in the AST. Additional information in the <a class="el" href="classSg__File__Info.html">Sg_File_Info</a> could be:<ul>
<li>offset from starting line number to the end of construct</li><li>flag for if end of construct is located in the same file as the start of construct</li></ul>
<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000036"></a> <dl>
<dt>Class <a class="el" href="classSg__File__Info.html">Sg_File_Info</a>  </dt>
<dd>Consider using "short int" instead of "int" for the file_id, line, and col (and maybe the classificationBitField) to reduce the size of the data structure. Padding is not a significant issue since data structures are allocated in contiguious memory (except for padding to at least the nearest byte if bit field widths are used.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000044"></a> <dl>
<dt>Member <a class="el" href="classSg__File__Info.html#8c0692f18f568ca8bcd64b4a77f2aa09">Sg_File_Info::hasPositionInSource</a> () const  </dt>
<dd>figure out what this does, it appears to be called in two places (attachment of comments and CPP directives (attachPreprocessingInfo.C) and marking template specializations for output (markTemplateSpecializationsForOutput.C)).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000010"></a> <dl>
<dt>Class <a class="el" href="classSgAsmStmt.html">SgAsmStmt</a>  </dt>
<dd>This should not be a SgDeclaration (should be a regular <a class="el" href="classSgStatement.html">SgStatement</a>). Where "asm" is used in declarations (e.g. "int x asm("ax") = 0;") this is a <a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a>. A asm statment is really just another kind of statement (e.g "asm ("template",output operand, input operand);"). This sort of statement is not a declaration (as I understand it). This will be fixed in a later release.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000011"></a> <dl>
<dt>Class <a class="el" href="classSgAssignInitializer.html">SgAssignInitializer</a>  </dt>
<dd>Double check the accuracy of this description.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000013"></a> <dl>
<dt>Class <a class="el" href="classSgBoolValExp.html">SgBoolValExp</a>  </dt>
<dd>The name "SgBoolValExp" should be "SgBoolVal" to be consistant with the names of all other classes derived from <a class="el" href="classSgValueExp.html">SgValueExp</a>.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000015"></a> <dl>
<dt>Class <a class="el" href="classSgClassNameRefExp.html">SgClassNameRefExp</a>  </dt>
<dd>Need to figure out some examples of whare this is used.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000016"></a> <dl>
<dt>Member <a class="el" href="classSgConstructorInitializer.html#941814b813615809f1ae74ced777e070">SgConstructorInitializer::p_associated_class_unknown</a>  </dt>
<dd>Enforce p_declaration is valid pointer when p_associated_class_unknown is false within AST consistency tests. </dd>
</dl>
<p>
<a class="anchor" name="_todo000017"></a> <dl>
<dt>Class <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a>  </dt>
<dd>Current issues to look at:<ul>
<li>Current classes derived from <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> and the <a class="el" href="classSgInitializedName.html">SgInitializedName</a> class have ways of generating names, qualified names, and mangled names, but we lack a uniform mechanism to generate mangled qualified names. The implementation is not uniform within the IR and this is a problem for applications which must generate unique names for C++ constructs. Specific to functions names:<ul>
<li>We have:<ol type=i>
<li><a class="el" href="namespaceSageInterface.html#d8c38176c2d0e4d2bc851e70007902f9">get_name()</a></li><li>get_qualified_name()</li><li>get_mangled_name()</li></ol>
</li><li>While we need (on ALL <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> IR nodes):<ol type=i>
<li><a class="el" href="namespaceSageInterface.html#d8c38176c2d0e4d2bc851e70007902f9">get_name()</a></li><li>get_qualified_name()</li><li>get_mangled_name()</li><li>get_qualified_mangled_name()</li></ol>
</li></ul>
</li></ul>
<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000018"></a> <dl>
<dt>Class <a class="el" href="classSgDeleteExp.html">SgDeleteExp</a>  </dt>
<dd>I believe we can associate the destructors from the class with delete operators.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000019"></a> <dl>
<dt>Member <a class="el" href="classSgDeleteExp.html#1e6057f3fc884e8bab45b6582bf6ebc4">SgDeleteExp::p_need_global_specifier</a>  </dt>
<dd>Check if this bool data member is used and/or required.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000020"></a> <dl>
<dt>Class <a class="el" href="classSgDirectory.html">SgDirectory</a>  </dt>
<dd>Consider adding a SgFileInfo data member to be uniform with <a class="el" href="classSgFile.html">SgFile</a>.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000021"></a> <dl>
<dt>Class <a class="el" href="classSgDoubleVal.html">SgDoubleVal</a>  </dt>
<dd>Add string to this class so that the exact value can be held in the AST.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000022"></a> <dl>
<dt>Class <a class="el" href="classSgDoWhileStmt.html">SgDoWhileStmt</a>  </dt>
<dd>The conditional test should be an expression (different from a <a class="el" href="classSgWhileStmt.html">SgWhileStmt</a>), see test2005_114.C for examples and details. </dd>
</dl>
<p>
<a class="anchor" name="_todo000023"></a> <dl>
<dt>Member <a class="el" href="classSgDoWhileStmt.html#9c8ace6e8ef16dcd1f98d70341580907">SgDoWhileStmt::p_condition</a>  </dt>
<dd>This should be changed to be a <a class="el" href="classSgExpression.html">SgExpression</a> (to follow the C++ standard). We also have the condition specified before the body within the ROSETTA specification and this causes the traversal to travers the condition and body in the wrong order (for do-while, the traversal should be body forst and condition second). See test2005_114.C for more details and example code (example of strange loops). </dd>
</dl>
<p>
<a class="anchor" name="_todo000024"></a> <dl>
<dt>Class <a class="el" href="classSgExpression.html">SgExpression</a>  </dt>
<dd>Consider placing the VARARGS expression nodes into a common base class derived from <a class="el" href="classSgExpression.html">SgExpression</a>.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000024"></a> <dl>
<dt>Class <a class="el" href="classSgExpression.html">SgExpression</a>  </dt>
<dd>I have removed the access functions from the explicit storage of type information in <a class="el" href="classSgExpression.html">SgExpression</a> objects as phase 1 of a 2 phase approach to eliminate the storage of the type in the <a class="el" href="classSgExpression.html">SgExpression</a> IR nodes. This type should be computed where required. This would avoid it being held redundently. This mechanism is being redone internally. Some IR nodes will have likely have to store there type explicaitly (function expressions for example, though it might be better computed through the symbol). It is not clear it this computing of the type will be better than stroing of the type explicitly. It might be required for <a class="el" href="classSgBinaryOp.html">SgBinaryOp</a> IR nodes to store the type if it is not clearly from either the lhs or rhs (if no simple rule exists).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000024"></a> <dl>
<dt>Class <a class="el" href="classSgExpression.html">SgExpression</a>  </dt>
<dd><a class="el" href="classSgScopeOp.html">SgScopeOp</a> is deprecated and will be removed in a future version of <a class="el" href="namespaceROSE.html">ROSE</a>. It is a hold over from support for CC++ which is not supported in SAGE III anymore.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000024"></a> <dl>
<dt>Class <a class="el" href="classSgExpression.html">SgExpression</a>  </dt>
<dd><a class="el" href="classSgRefExp.html">SgRefExp</a> is deprecated and will be removed in a future version of <a class="el" href="namespaceROSE.html">ROSE</a>. It is not used anywhere within SAGE III and I don't know why it is there.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000024"></a> <dl>
<dt>Class <a class="el" href="classSgExpression.html">SgExpression</a>  </dt>
<dd>Need to find an example of where <a class="el" href="classSgClassNameRefExp.html">SgClassNameRefExp</a> is used. It is build in the EDG/Sage III translation, but not in a way that it is obvious that it is still used within Sage III. So this may have to be removed at a latr date.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000024"></a> <dl>
<dt>Class <a class="el" href="classSgExpression.html">SgExpression</a>  </dt>
<dd>To support Fortran parser we need an IR node which will represent the ambiguity of an array access or function call expression. These are then resolved within the AST after parsing (requires AST Fixup rule).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000024"></a> <dl>
<dt>Class <a class="el" href="classSgExpression.html">SgExpression</a>  </dt>
<dd>Fortran support requires support for function call using: "foo(temp=*&lt;label&gt;)" this might force the development of a label expression to support this. Code using this compiles with gfortran, so it appears to be F90.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000031"></a> <dl>
<dt>Class <a class="el" href="classSgExprListExp.html">SgExprListExp</a>  </dt>
<dd>Consider that get_type() returns a SgDefalutType and should return the <a class="el" href="classSgType.html">SgType</a> associated with the last expression in the list.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000032"></a> <dl>
<dt>Class <a class="el" href="classSgFile.html">SgFile</a>  </dt>
<dd>The ROSEAttributesListContainerPtr p_preprocessorDirectivesAndCommentsList should be implemented a list instead of a pointer to a list. This might require a list copy in the internal hand,ing, but would simplify the design and there is not the same memory constraint of having a pointer to a list vs. a list here because the list is almost always valid (most source code incluses at least one comment or CPP directive) and there is only one <a class="el" href="classSgFile.html">SgFile</a> object per source file (so there are relatively few <a class="el" href="classSgFile.html">SgFile</a> nodes in even a very large AST).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000032"></a> <dl>
<dt>Class <a class="el" href="classSgFile.html">SgFile</a>  </dt>
<dd>This IR nodes now has a <a class="el" href="classSg__File__Info.html">Sg_File_Info</a> pointer, however it needs to be made consistant with the filename that is returned from SgFile::get_fileName().<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000032"></a> <dl>
<dt>Class <a class="el" href="classSgFile.html">SgFile</a>  </dt>
<dd>The default constructor for <a class="el" href="classSgFile.html">SgFile</a> sets the <a class="el" href="classSgGlobal.html">SgGlobal</a> pointer to NULL and perhaps it would be better if it set it to a valid <a class="el" href="classSgGlobal.html">SgGlobal</a> object then we would have a better defined empty list of declarations.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000032"></a> <dl>
<dt>Class <a class="el" href="classSgFile.html">SgFile</a>  </dt>
<dd>Yarden has suggested we provide a way to modify the link line that would be generated to support the backend compilation. I think we should have a list of strings that could be added to the link line (appended to the end would be the simplist). Else we need a virtual function that could be overloaded to customize the control over the link command generation (however we want to discourage the derivation of user defined IR nodes from existing IR nodes since this would break some of the internal mechanisms that use the memory pools).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000045"></a> <dl>
<dt>Class <a class="el" href="classSgFloatVal.html">SgFloatVal</a>  </dt>
<dd>Add string to this class so that the exact value can be held in the AST.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000046"></a> <dl>
<dt>Class <a class="el" href="classSgForInitStatement.html">SgForInitStatement</a>  </dt>
<dd>Evaluate if this should be derived from <a class="el" href="classSgSupport.html">SgSupport</a>, like other "list" based IR nodes.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000046"></a> <dl>
<dt>Class <a class="el" href="classSgForInitStatement.html">SgForInitStatement</a>  </dt>
<dd>Evaluate if we should even have this IR node. If the <a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> were to be fixed to really use the list of <a class="el" href="classSgInitializedName.html">SgInitializedName</a> objects where multiple variables are declared in the same variable declaration then we might not need this (I think). And if it didn't exist it would make the use of the <a class="el" href="classSgForStatement.html">SgForStatement</a> a little bit simpler.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000048"></a> <dl>
<dt>Class <a class="el" href="classSgForStatement.html">SgForStatement</a>  </dt>
<dd>The conditional in this test is currently an expression, but should be a SgConditional or a <a class="el" href="classSgStatement.html">SgStatement</a> (e.g. so that it can be a variable declaration).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000048"></a> <dl>
<dt>Class <a class="el" href="classSgForStatement.html">SgForStatement</a>  </dt>
<dd>Now that the test is a <a class="el" href="classSgStatement.html">SgStatement</a>, perhaps the name of the field should be "test" instead of "test_expr".<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000052"></a> <dl>
<dt>Class <a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>  </dt>
<dd>Need to mark function declarations appearing in the file rose_edg_required_macros_and_functions.h as compiler generated since they are either builtin functions for gcc and g++ or those those builtin function that gcc and g++ required and which EDG fails to include as builtin when compiling with EDG's GNU_COMPATABILITY_MODE (current default for <a class="el" href="namespaceROSE.html">ROSE</a>).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000052"></a> <dl>
<dt>Class <a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>  </dt>
<dd>Need to better handle fiend injection rules, currently the <a class="el" href="classSgFunctionSymbol.html">SgFunctionSymbol</a> for a friend function is placed into the global scope. It likely should be the outer scope for a non-defining declaration and the class scope for a defining declaration. But the exact rules for this are more complex. So the location of the <a class="el" href="classSgFunctionSymbol.html">SgFunctionSymbol</a> in the symbol table of <a class="el" href="classSgGlobal.html">SgGlobal</a> is a poor approximation.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000054"></a> <dl>
<dt>Class <a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a>  </dt>
<dd>Check scopes of variables in function parameter list, should point to function definition, if the function definition exists, else they are undefined. If they are undefined then we still have to have something for them to point to, we could propose that this be the scope of the function declaration (I think this is what is done). The test in the tutorial tests this and it seems to be correct.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000054"></a> <dl>
<dt>Class <a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a>  </dt>
<dd>Not clear if this should be a declaration statement (might make more sense derived from <a class="el" href="classSgSupport.html">SgSupport</a>, or perhaps from <a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> (with other IR nodes that are currently derived from <a class="el" href="classSgSupport.html">SgSupport</a>, see <a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> for details).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000054"></a> <dl>
<dt>Class <a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a>  </dt>
<dd>If this should be a <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> (and there is a reasonable argument for this) then perhaps the declaration containing any default parameters should be the defining declaration, independent of the defining declaration of the associated function declaration.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000057"></a> <dl>
<dt>Class <a class="el" href="classSgFunctionRefExp.html">SgFunctionRefExp</a>  </dt>
<dd>Figure out why <a class="el" href="classSgMemberFunctionRefExp.html">SgMemberFunctionRefExp</a> is required instead of just <a class="el" href="classSgFunctionRefExp.html">SgFunctionRefExp</a>.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000057"></a> <dl>
<dt>Class <a class="el" href="classSgFunctionRefExp.html">SgFunctionRefExp</a>  </dt>
<dd>Make the use of a <a class="el" href="classSgMemberFunctionSymbol.html">SgMemberFunctionSymbol</a> in a <a class="el" href="classSgFunctionRefExp.html">SgFunctionRefExp</a> an error. The result will not unparse correctly (suggested by Jeremiah).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000059"></a> <dl>
<dt>Class <a class="el" href="classSgFunctionTypeTable.html">SgFunctionTypeTable</a>  </dt>
<dd>Evaluate if this should be derived from <a class="el" href="classSgSupport.html">SgSupport</a> (consistant with <a class="el" href="classSgSymbolTable.html">SgSymbolTable</a>).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000059"></a> <dl>
<dt>Class <a class="el" href="classSgFunctionTypeTable.html">SgFunctionTypeTable</a>  </dt>
<dd>Evaluate if we might like to have the p_function_type_table be a <a class="el" href="classSgSymbolTable.html">SgSymbolTable</a> rather than a pointer to a <a class="el" href="classSgSymbolTable.html">SgSymbolTable</a> (see implementation note).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000061"></a> <dl>
<dt>Class <a class="el" href="classSgGlobal.html">SgGlobal</a>  </dt>
<dd>Cleanup interface which presently has multiple append,prepend, insert functions. It might be best to eliminate them and use STL directly. </dd>
</dl>
<p>
<a class="anchor" name="_todo000062"></a> <dl>
<dt>Class <a class="el" href="classSgIfStmt.html">SgIfStmt</a>  </dt>
<dd>The unparse function "unparseIfStmt" associated with this IR node is implemented using a loop. I think this should be changed to be more conventional and structural (consistant with the design of the rest of the unparsing). </dd>
</dl>
<p>
<a class="anchor" name="_todo000065"></a> <dl>
<dt>Class <a class="el" href="classSgLabelStatement.html">SgLabelStatement</a>  </dt>
<dd>Review if we want to have the label statement reference it's associated statement (it would be a redundent reference, since the next statement is already in the list of statements for the scope).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000066"></a> <dl>
<dt>Class <a class="el" href="classSgLocatedNode.html">SgLocatedNode</a>  </dt>
<dd>The <a class="el" href="classAstAttributeMechanism.html">AstAttributeMechanism</a> type should be handed as other IR nodes with it's own memory pool, except that in all cases where it would be used, it would be a base class to a user-defined derived type and thus would not fix in our memory pool.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000066"></a> <dl>
<dt>Class <a class="el" href="classSgLocatedNode.html">SgLocatedNode</a>  </dt>
<dd>Consider name change of "SgLocatedNode" to "SgSourceNode".<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000066"></a> <dl>
<dt>Class <a class="el" href="classSgLocatedNode.html">SgLocatedNode</a>  </dt>
<dd>Consider moving some of the IR nodes currently in <a class="el" href="classSgSupport.html">SgSupport</a> to this IR node. IR nodes that might be moved would include:<ol type=1>
<li><a class="el" href="classSgFile.html">SgFile</a></li><li><a class="el" href="classSgDirectory.html">SgDirectory</a> (questionable)</li><li><a class="el" href="classSgInitializedName.html">SgInitializedName</a></li><li><a class="el" href="classSgBaseClass.html">SgBaseClass</a></li><li><a class="el" href="classSgTemplateArgument.html">SgTemplateArgument</a></li><li><a class="el" href="classSgTemplateParameter.html">SgTemplateParameter</a></li></ol>
<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000069"></a> <dl>
<dt>Class <a class="el" href="classSgLongDoubleVal.html">SgLongDoubleVal</a>  </dt>
<dd>Add string to this class so that the exact value can be held in the AST.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000070"></a> <dl>
<dt>Class <a class="el" href="classSgModifierNodes.html">SgModifierNodes</a>  </dt>
<dd>Fortran support for modifiers is required: see section 5.2, 5.3 in Fortran 2003 standard. Note that type modifiers can be used as statements.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000071"></a> <dl>
<dt>Class <a class="el" href="classSgName.html">SgName</a>  </dt>
<dd>Define a string conversion operator so that we can handle "SgName name; string s = name;" This would start the process of internally having <a class="el" href="classSgName.html">SgName</a> contain a C++ style string.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000071"></a> <dl>
<dt>Class <a class="el" href="classSgName.html">SgName</a>  </dt>
<dd>Change <a class="el" href="classSgName.html">SgName</a> to store a C++ style std::string, instead of a C style char*.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000071"></a> <dl>
<dt>Class <a class="el" href="classSgName.html">SgName</a>  </dt>
<dd>Some of the member functions defined in this class will be removed (head(), tail(), etc.) because they represent low level string handling which is best done on a C++ style string more directly using C++ string operators.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000074"></a> <dl>
<dt>Class <a class="el" href="classSgNamespaceDeclarationStatement.html">SgNamespaceDeclarationStatement</a>  </dt>
<dd>Consider having a function which could generate a list of all the <a class="el" href="classSgNamespaceDeclarationStatement.html">SgNamespaceDeclarationStatement</a> IR nodes that match the same namspace. This would make a good first project for a new student.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000074"></a> <dl>
<dt>Class <a class="el" href="classSgNamespaceDeclarationStatement.html">SgNamespaceDeclarationStatement</a>  </dt>
<dd>Include a graph to show how scopes are handled within the AST.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000076"></a> <dl>
<dt>Class <a class="el" href="classSgNamespaceDefinitionStatement.html">SgNamespaceDefinitionStatement</a>  </dt>
<dd>Cleanup interface which presently has multiple append,prepend, insert functions. It might be best to eliminate them and use STL directly. </dd>
</dl>
<p>
<a class="anchor" name="_todo000077"></a> <dl>
<dt>Class <a class="el" href="classSgNamespaceSymbol.html">SgNamespaceSymbol</a>  </dt>
<dd>It might be that we should have a SgNamespaceAliasSymbol so that namespace aliasing can be better supported. We can consider this for future work.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000078"></a> <dl>
<dt>Class <a class="el" href="classSgNewExp.html">SgNewExp</a>  </dt>
<dd>Provide some examples to detail the difference between placement, constructor, and builtin arguments.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000078"></a> <dl>
<dt>Class <a class="el" href="classSgNewExp.html">SgNewExp</a>  </dt>
<dd>I believe we can associate the constructors from the class with new operators.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000080"></a> <dl>
<dt>Member <a class="el" href="classSgNewExp.html#07d8847d4f502ef01308509fa6766679">SgNewExp::p_placement_args</a>  </dt>
<dd>Provide some examples to detail the difference between placement, constructor, and builtin arguments (these are rarely used in C++). </dd>
</dl>
<p>
<a class="anchor" name="_todo000081"></a> <dl>
<dt>Member <a class="el" href="classSgNewExp.html#4aa707fae50265c6fb9fcec0b75af02d">SgNewExp::p_constructor_args</a>  </dt>
<dd>Provide some examples to detail the difference between placement, constructor, and builtin arguments. </dd>
</dl>
<p>
<a class="anchor" name="_todo000082"></a> <dl>
<dt>Member <a class="el" href="classSgNewExp.html#42b8095f2396cb7d1f2cf6c89ec1ac8c">SgNewExp::p_builtin_args</a>  </dt>
<dd>Provide some examples to detail the difference between placement, constructor, and builtin arguments. </dd>
</dl>
<p>
<a class="anchor" name="_todo000083"></a> <dl>
<dt>Class <a class="el" href="classSgNode.html">SgNode</a>  </dt>
<dd>The "AstAttributeMechanism attribute;" field should be fixed:<ul>
<li>The attribute within this class is not added using ROSETTA and is one of the last (if not the last) variable to NOT be added to the IR nodes using ROSETTA. Because it is not added using ROSETTA, it is a special case (and we hate special cases) in the file I/O (by Jochen) and perhaps elsewhere. This variable should be added using ROSETTA!</li><li>Access functions need to be built for the "AstAttributeMechanism attribute;" field and it needs to be moved to be a private data member.</li><li>It should be moved to only those IR nodes were it makes sense, e.g. excluded from:<ol type=a>
<li><a class="el" href="classSgName.html">SgName</a></li><li><a class="el" href="classSgModifier.html">SgModifier</a> (and all derived modifier IR nodes)</li><li><a class="el" href="classSgUnparse__Info.html">SgUnparse_Info</a></li><li><a class="el" href="classSgSymbolTable.html">SgSymbolTable</a></li></ol>
</li></ul>
<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000083"></a> <dl>
<dt>Class <a class="el" href="classSgNode.html">SgNode</a>  </dt>
<dd>Consider eliminating the set_freepointer() function since only the internal memory allocation mechanisms should use it (and they are forced to access the data member directly since they traverse the memory pools directly and member function can onl be called on allocated object initialized vi the new operator (with a proper constructor call, so that the this pointer is set properly)). Perhaps we don't need access functions for this data member at all.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000012"></a> <dl>
<dt>Member <a class="el" href="classSgNode.html#424645345b57be63499504a4ae3871e0">SgNode::unparseToCompleteString</a> () </dt>
<dd>This function needs a better name since it is unclear what the "complete" string is.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000063"></a> <dl>
<dt>Member <a class="el" href="classSgNode.html#424645345b57be63499504a4ae3871e0">SgNode::unparseToCompleteString</a> () </dt>
<dd>This function needs a better name since it is unclear what the "complete" string is.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000064"></a> <dl>
<dt>Member <a class="el" href="classSgNode.html#424645345b57be63499504a4ae3871e0">SgNode::unparseToCompleteString</a> () </dt>
<dd>This function needs a better name since it is unclear what the "complete" string is.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000085"></a> <dl>
<dt>Member <a class="el" href="classSgNode.html#424645345b57be63499504a4ae3871e0">SgNode::unparseToCompleteString</a> () </dt>
<dd>This function needs a better name since it is unclear what the "complete" string is.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000086"></a> <dl>
<dt>Class <a class="el" href="classSgOptions.html">SgOptions</a>  </dt>
<dd>Review if we really want to keep this class.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000087"></a> <dl>
<dt>Class <a class="el" href="classSgProject.html">SgProject</a>  </dt>
<dd>Make the "*PtrList" typed objects non-pointer data members (lists) instead of pointer to lists.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000087"></a> <dl>
<dt>Class <a class="el" href="classSgProject.html">SgProject</a>  </dt>
<dd>Implement a "-dumpversion" for compatibility with GNU (icc does the same).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000089"></a> <dl>
<dt>Class <a class="el" href="classSgRefExp.html">SgRefExp</a>  </dt>
<dd>Double check this description.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000090"></a> <dl>
<dt>Class <a class="el" href="classSgReturnStmt.html">SgReturnStmt</a>  </dt>
<dd>Check that when return (SgReturnStatement) is implicit, it should be marked as compiler generated. Actually we only include returns in the AST which are explicit, so this is not a problem.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000091"></a> <dl>
<dt>Class <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a>  </dt>
<dd>Where current derived IR nodes from <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> contain <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> objects, we should consider having them contain <a class="el" href="classSgStatement.html">SgStatement</a> objects instead of <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>. This would avoid current normalizations which are cute, but perhaps unwelcome. We need to discuss and rule on this detail. An alternative would be to let there be a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> and mark it as compiler-generated if it does not appear in the original source code. then the unparser (code generator) could be made to avoid output of the SgBasicblock (and enforce that the number of statements in the block is not greater than one). Effected IR nodes include:<ul>
<li><a class="el" href="classSgCatchOptionStmt.html">SgCatchOptionStmt</a> (should contain <a class="el" href="classSgStatement.html">SgStatement</a>)</li><li><a class="el" href="classSgDoWhileStmt.html">SgDoWhileStmt</a> (should contain <a class="el" href="classSgStatement.html">SgStatement</a>)</li><li><a class="el" href="classSgForStatement.html">SgForStatement</a> (should contain <a class="el" href="classSgStatement.html">SgStatement</a>)</li><li><a class="el" href="classSgIfStmt.html">SgIfStmt</a> (should contain true and false <a class="el" href="classSgStatement.html">SgStatement</a>)</li><li><a class="el" href="classSgSwitchStatement.html">SgSwitchStatement</a> (should contain <a class="el" href="classSgStatement.html">SgStatement</a>)</li><li><a class="el" href="classSgWhileStmt.html">SgWhileStmt</a> (should contain <a class="el" href="classSgStatement.html">SgStatement</a>) <br>
 these are currently correct:</li><li><a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> (should contain a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>)</li><li><a class="el" href="classSgGlobal.html">SgGlobal</a> (constains a list of declarations (<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> objects))</li><li><a class="el" href="classSgNamespaceDefinitionStatement.html">SgNamespaceDefinitionStatement</a> (constains a list of declarations (<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> objects))</li><li><a class="el" href="classSgClassDefinition.html">SgClassDefinition</a> (constains a list of declarations (<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> objects))</li></ul>
<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000093"></a> <dl>
<dt>Class <a class="el" href="classSgSizeOfOp.html">SgSizeOfOp</a>  </dt>
<dd>Need to implement support in EDG/SageIII translation for this operator.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000094"></a> <dl>
<dt>Class <a class="el" href="classSgStatement.html">SgStatement</a>  </dt>
<dd>There are a number of statements that contain a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> where they should contain a <a class="el" href="classSgStatement.html">SgStatement</a>. In each case changing the data member to be a <a class="el" href="classSgStatement.html">SgStatement</a> will unfortunately change the constructor parameter list and thus the <a class="el" href="namespaceROSE.html">ROSE</a> API. So these changes have to be organized a a point where it is clear we will be changing some details of the <a class="el" href="namespaceROSE.html">ROSE</a> API (prior to external release). Problem IR nodes are:<ul>
<li><a class="el" href="classSgCaseOptionStmt.html">SgCaseOptionStmt</a></li><li><a class="el" href="classSgTryStmt.html">SgTryStmt</a></li><li><a class="el" href="classSgDefaultOptionStmt.html">SgDefaultOptionStmt</a></li><li><a class="el" href="classSgIfStmt.html">SgIfStmt</a></li><li><a class="el" href="classSgForStatement.html">SgForStatement</a></li><li><a class="el" href="classSgWhileStmt.html">SgWhileStmt</a></li><li><a class="el" href="classSgDoWhileStmt.html">SgDoWhileStmt</a></li><li><a class="el" href="classSgSwitchStatement.html">SgSwitchStatement</a></li></ul>
<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000094"></a> <dl>
<dt>Class <a class="el" href="classSgStatement.html">SgStatement</a>  </dt>
<dd>Fortran support for modifiers can be used as statement (must be added to IR): see section 5.2, 5.3 in Fortran 2003 standard. Note that type modifiers can be used as statements.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000094"></a> <dl>
<dt>Class <a class="el" href="classSgStatement.html">SgStatement</a>  </dt>
<dd>Fortran support requires statements in section 6.3.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000094"></a> <dl>
<dt>Class <a class="el" href="classSgStatement.html">SgStatement</a>  </dt>
<dd>Fortran support requires for "where" and "forall" statements.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000094"></a> <dl>
<dt>Class <a class="el" href="classSgStatement.html">SgStatement</a>  </dt>
<dd>Fortran support requires for case statement ranges (gnu extension for C, but standard in Fortran).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000094"></a> <dl>
<dt>Class <a class="el" href="classSgStatement.html">SgStatement</a>  </dt>
<dd>Fortran support requires statements in section 8.1.4, 8.1.5.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000094"></a> <dl>
<dt>Class <a class="el" href="classSgStatement.html">SgStatement</a>  </dt>
<dd>Fortran support requires statements in section 15 (modifiers for ISO_C_BINDING).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000101"></a> <dl>
<dt>Class <a class="el" href="classSgSwitchStatement.html">SgSwitchStatement</a>  </dt>
<dd>FIXED: The conditional test should be a <a class="el" href="classSgStatement.html">SgStatement</a> so that a declaration can be used, it is currently an <a class="el" href="classSgExpression.html">SgExpression</a> (specifically a <a class="el" href="classSgExpressionRoot.html">SgExpressionRoot</a>).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000101"></a> <dl>
<dt>Class <a class="el" href="classSgSwitchStatement.html">SgSwitchStatement</a>  </dt>
<dd>The body of the SgSwitch should really be a <a class="el" href="classSgStatement.html">SgStatement</a> not a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>. DuffsDevice can be modified to should an example of this but there are also much more trivial examples. See comment about this in the <a class="el" href="classSgStatement.html">SgStatement</a> todo list. </dd>
</dl>
<p>
<a class="anchor" name="_todo000104"></a> <dl>
<dt>Class <a class="el" href="classSgSymbol.html">SgSymbol</a>  </dt>
<dd>Consider derivation of <a class="el" href="classSgEnumSymbol.html">SgEnumSymbol</a>, <a class="el" href="classSgClassSymbol.html">SgClassSymbol</a>, and <a class="el" href="classSgTypedefSymbol.html">SgTypedefSymbol</a> from a common SgTypeSymbol. Then supporting functions for SgTypeSymbol would lookup any of these type based symbols.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000105"></a> <dl>
<dt>Class <a class="el" href="classSgSymbolTable.html">SgSymbolTable</a>  </dt>
<dd>The <a class="el" href="classrose__hash__multimap.html">rose_hash_multimap</a> should perhaps be included as a data member instead of implemented as a pointer. We should consider this detail.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000105"></a> <dl>
<dt>Class <a class="el" href="classSgSymbolTable.html">SgSymbolTable</a>  </dt>
<dd>We should decide if we want to give Symbol Tables a name or not, it seems that we rarely if ever do this so perhaps we should not have such a field.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000107"></a> <dl>
<dt>Member <a class="el" href="classSgSymbolTable.html#aed504fbe20af5f216348c14da6064bf">SgSymbolTable::p_no_name</a>  </dt>
<dd>generate a list of instances where symbols don't have names. (Namespaces don't have to have a name for example).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000108"></a> <dl>
<dt>Class <a class="el" href="classSgTemplateArgument.html">SgTemplateArgument</a>  </dt>
<dd>Move this be a <a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> since it should have a position in the source code.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000109"></a> <dl>
<dt>Class <a class="el" href="classSgTemplateDeclaration.html">SgTemplateDeclaration</a>  </dt>
<dd>Template declarations marked as friend don't seem to be marked as friend internally.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000109"></a> <dl>
<dt>Class <a class="el" href="classSgTemplateDeclaration.html">SgTemplateDeclaration</a>  </dt>
<dd>The scope of a <a class="el" href="classSgTemplateDeclaration.html">SgTemplateDeclaration</a> should be a <a class="el" href="classSgTemplateInstantiationDefn.html">SgTemplateInstantiationDefn</a>, since it could be associated which more than one definition. What we need, and don't have yet, is a SgTemplateDefinition to accompany the <a class="el" href="classSgTemplateDeclaration.html">SgTemplateDeclaration</a> then a <a class="el" href="classSgTemplateDeclaration.html">SgTemplateDeclaration</a> could have a SgTemplateDefinition for a parent and or scope when it is a member function or namespace or global scope (typically), otherwise.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000109"></a> <dl>
<dt>Class <a class="el" href="classSgTemplateDeclaration.html">SgTemplateDeclaration</a>  </dt>
<dd>Make the "*PtrList" typed objects non-pointer data members (lists) instead of pointer to lists.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000112"></a> <dl>
<dt>Member <a class="el" href="classSgTemplateDeclaration.html#7a871ee7854bdbaec3fd2ce833c0c472">SgTemplateDeclaration::p_string</a>  </dt>
<dd>Check the accuracy of this statement in the unparser!<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000113"></a> <dl>
<dt>Class <a class="el" href="classSgTemplateInstantiationDecl.html">SgTemplateInstantiationDecl</a>  </dt>
<dd>Make the "*PtrList" typed objects non-pointer data members (lists) instead of pointer to lists.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000114"></a> <dl>
<dt>Class <a class="el" href="classSgTemplateInstantiationDirectiveStatement.html">SgTemplateInstantiationDirectiveStatement</a>  </dt>
<dd>Consider tranversing instantated templates instantiated by an explicit instanntatiation directive.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000115"></a> <dl>
<dt>Class <a class="el" href="classSgTemplateInstantiationFunctionDecl.html">SgTemplateInstantiationFunctionDecl</a>  </dt>
<dd>Make the "*PtrList" typed objects non-pointer data members (lists) instead of pointer to lists.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000116"></a> <dl>
<dt>Class <a class="el" href="classSgTemplateInstantiationMemberFunctionDecl.html">SgTemplateInstantiationMemberFunctionDecl</a>  </dt>
<dd>Make the "*PtrList" typed objects non-pointer data members (lists) instead of pointer to lists.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000117"></a> <dl>
<dt>Class <a class="el" href="classSgThrowOp.html">SgThrowOp</a>  </dt>
<dd>Make the "*PtrList" typed objects non-pointer data members (lists) instead of pointer to lists.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000117"></a> <dl>
<dt>Class <a class="el" href="classSgThrowOp.html">SgThrowOp</a>  </dt>
<dd>Consider that get_type() returns a SgDefalutType and should return the <a class="el" href="classSgType.html">SgType</a> associated with the last expression in the list (research details of the list of pointers in the C++ throw operator).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000119"></a> <dl>
<dt>Class <a class="el" href="classSgType.html">SgType</a>  </dt>
<dd>Several classes derived from <a class="el" href="classSgType.html">SgType</a> are not used and can be removed:<ol type=1>
<li><a class="el" href="classSgTypeUnknown.html">SgTypeUnknown</a> (Used by <a class="el" href="namespaceSageInterface.html">SageInterface</a> to specify references to undeclared variables)</li><li>SgUnknownMemberFunctionType</li></ol>
<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000119"></a> <dl>
<dt>Class <a class="el" href="classSgType.html">SgType</a>  </dt>
<dd>The signed types (except for signed char) are not used in SAGE III and do not exist in C or C++. These IR nodes should be removed, specifically <a class="el" href="classSgTypeSignedShort.html">SgTypeSignedShort</a>, <a class="el" href="classSgTypeSignedInt.html">SgTypeSignedInt</a>, <a class="el" href="classSgTypeSignedLong.html">SgTypeSignedLong</a>.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000119"></a> <dl>
<dt>Class <a class="el" href="classSgType.html">SgType</a>  </dt>
<dd>For Fortran support we need to add the kind, length data member to specify the width. To support handling of kind, length parameters we should use the information about the target backend compiler and map kind information to bit widths (not a high priority).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000119"></a> <dl>
<dt>Class <a class="el" href="classSgType.html">SgType</a>  </dt>
<dd>Labels appear to be used as types in "foo(*,*)", see example from Chris (LANL, 4/19/2007).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000123"></a> <dl>
<dt>Class <a class="el" href="classSgTypedefDeclaration.html">SgTypedefDeclaration</a>  </dt>
<dd>There are a few data members in this field that don't appear to be used (should be removed if not required):<ul>
<li>p_declaration: have not seen it be used anywhere (I think it is used when a declartion is explicit in the typedef, check this out, might be part of older mechanism before defining and nondefining declarations were developed to provide a uniform mechanism for all declarations)</li><li>p_parent_scope: this is a <a class="el" href="classSgSymbol.html">SgSymbol</a>, but I don't know why it is stored explicitly.</li></ul>
<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000124"></a> <dl>
<dt>Member <a class="el" href="classSgTypedefDeclaration.html#d283e43937f37710a185117dbeff9536">SgTypedefDeclaration::p_parent_scope</a>  </dt>
<dd>We can remove this.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000125"></a> <dl>
<dt>Member <a class="el" href="classSgTypedefSeq.html#bdefe0373e604cb9be444eb3633bbbb8">SgTypedefSeq::p_typedefs</a>  </dt>
<dd>It might be better for this to be a list of SgTypedefTypes<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000125"></a> <dl>
<dt>Member <a class="el" href="classSgTypedefSeq.html#bdefe0373e604cb9be444eb3633bbbb8">SgTypedefSeq::p_typedefs</a>  </dt>
<dd>Think about if we could also store a reference to all pointers and reference types where they share a common base_type.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000127"></a> <dl>
<dt>Member <a class="el" href="classSgUnaryOp.html#f935719dfe26f485b0f8a50eb245c706">SgUnaryOp::p_expression_type</a>  </dt>
<dd>This value is only used for the <a class="el" href="classSgCastExp.html">SgCastExp</a>, we will move it to that IR node when we are ready to change the interface for the SgExpressions (and SgUnaryExp IR nodes).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000128"></a> <dl>
<dt>Class <a class="el" href="classSgUsingDirectiveStatement.html">SgUsingDirectiveStatement</a>  </dt>
<dd>Explain difference between using declaration and using directive.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000129"></a> <dl>
<dt>Class <a class="el" href="classSgValueExp.html">SgValueExp</a>  </dt>
<dd>We should add a SgComplexValue IR nodes for C99 support of complex constants. At the moment these are internally represented as SgFloatValue, SgDoubleValue, or SgLongDoubleValue IR nodes.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000130"></a> <dl>
<dt>Class <a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a>  </dt>
<dd>Finish explaination of variable declaration, relationship to variable definition, and the scope issue.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000130"></a> <dl>
<dt>Class <a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a>  </dt>
<dd>template static variable declaration are instantiated and this is at least sometimes an error (at least when not part of a transformation). See test2005_69.C for example of this problem.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000132"></a> <dl>
<dt>Member <a class="el" href="classSgVariableDeclaration.html#e621302e09bf3b09f54a2914d78db552">SgVariableDeclaration::p_variableDeclarationContainsBaseTypeDefiningDeclaration</a>  </dt>
<dd>Provide an example of where p_variableDeclarationContainsBaseTypeDefiningDeclaration is true and where it is false. </dd>
</dl>
<p>
<a class="anchor" name="_todo000133"></a> <dl>
<dt>Class <a class="el" href="classSgVariableDefinition.html">SgVariableDefinition</a>  </dt>
<dd>If a <a class="el" href="classSgVariableDefinition.html">SgVariableDefinition</a> is built internally as part of a <a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> it should be marked as compiler generated if the "extern" keyword was not used in the <a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a>. This needs to be looked into.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000133"></a> <dl>
<dt>Class <a class="el" href="classSgVariableDefinition.html">SgVariableDefinition</a>  </dt>
<dd>Constant folding happens when the bitfield is a variable and the variable name is lost. This IR nodes needs to be modified to alternatively store the associated <a class="el" href="classSgExpression.html">SgExpression</a> (in case it is a root of an expression tree).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000135"></a> <dl>
<dt>Class <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a>  </dt>
<dd>Need to figure out if it is such a great idea of a single symbol to be in two scopes or if it would be better to use two different symbols (since there are two different <a class="el" href="classSgInitializedName.html">SgInitializedName</a> object built (the last one referencing the previous one through the p_prev_decl_item pointer)).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000135"></a> <dl>
<dt>Class <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a>  </dt>
<dd>The get_type() function can return NULL when the get_definition() is NULL. I think we should have assertiosn to make sure that get_definition is a valid pointer and that get_type() should not return NULL.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000137"></a> <dl>
<dt>Class <a class="el" href="classSgVarRefExp.html">SgVarRefExp</a>  </dt>
<dd>Test to verify that each variable reference is associated with the inner most scoped variable with that name, except where name qualified. Applies most easily to local variables. The same test could be used for function references, actually all references. <p>
Make sure that declarations appear before variable references.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000156"></a> <dl>
<dt>Class <a class="el" href="classStringUtility.html">StringUtility</a>  </dt>
<dd>Finish documentation! </dd>
</dl>
<p>
<a class="anchor" name="_todo000157"></a> <dl>
<dt>Class <a class="el" href="classStringUtility.html">StringUtility</a>  </dt>
<dd>Finish documentation! </dd>
</dl>
<p>
<a class="anchor" name="_todo000158"></a> <dl>
<dt>Class <a class="el" href="classStringUtility.html">StringUtility</a>  </dt>
<dd>Finish documentation! </dd>
</dl>
<p>
<a class="anchor" name="_todo000148"></a> <dl>
<dt>File <a class="el" href="graphProcessing_8h.html">graphProcessing.h</a>  </dt>
<dd>utilize BOOST visitors to take advantage of the BOOST graph structures abilities<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000138"></a> <dl>
<dt>Member <a class="el" href="manglingSupport_8h.html#2fcc0aef1a2f3f1a1ceff11d6660d2ac">mangleExpression</a>  </dt>
<dd>Find a better way to deal with general template expression arguments. </dd>
</dl>
<p>
<a class="anchor" name="_todo000143"></a> <dl>
<dt>Member <a class="el" href="namespaceSageInterface.html#ae2594fcfdf89b9fc795eb4b4c2d04aa">SageInterface::get_C_array_dimensions</a> (const <a class="el" href="classSgArrayType.html">SgArrayType</a> &amp;arrtype, <a class="el" href="classSgInitializedName.html">SgInitializedName</a> &amp;initname) </dt>
<dd>make initname const </dd>
</dl>
<p>
<a class="anchor" name="_todo000144"></a> <dl>
<dt>Member <a class="el" href="namespaceSageInterface.html#ef8223b9741c08bb50c4ee85e04bbe16">SageInterface::appendArg</a> (<a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a> *, <a class="el" href="classSgInitializedName.html">SgInitializedName</a> *) </dt>
<dd>function type , function symbol also need attention. </dd>
</dl>
<p>
<a class="anchor" name="_todo000142"></a> <dl>
<dt>Group <a class="el" href="group__frontendSageUtilityFunctions.html">frontendSageUtilityFunctions</a>  </dt>
<dd>A number of additional things to do:<ul>
<li>Pull scope handling out of EDG/Sage III translation so that is is made available to anyone else building the Sage III IR from scratch (which when it gets non-trivial, involves the manipulation of scopes).</li><li>Other stuff ... </li></ul>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000145"></a> <dl>
<dt>Group <a class="el" href="group__ROSE__ProgramTransformationGroup.html">ROSE_ProgramTransformationGroup</a>  </dt>
<dd>Add Constant folding since we currently unfold all folded expressions in the code generation phase. This would be something that could be verified as well since it EDG has also computed the constant folded result and we have stored that explicitly as well as the expression tree from which it was folded. The proposed constant folding would also work on AST fragments constructed explicitly in <a class="el" href="namespaceROSE.html">ROSE</a> from lower level mechanisms.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000145"></a> <dl>
<dt>Group <a class="el" href="group__ROSE__ProgramTransformationGroup.html">ROSE_ProgramTransformationGroup</a>  </dt>
<dd>The <a class="el" href="namespaceROSE.html">ROSE</a> source code might be easier to organize if we have an include directory just for the included files from the transformations. Then use separate directories for the implementations (we want to always separate the implementation if possible from the header file and place it in a separate file. This would make it easier to add transformations and make the maintenance of the development tree a bit easier. As it is each new directory forces a new include path to be specified and a new library to be generated (in /config/Makefile.for.ROSE.includes.and.libs).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000153"></a> <dl>
<dt>Group <a class="el" href="group__queryLib.html">queryLib</a>  </dt>
<dd>1. Finish documentation! <br>
 2. Make the source code directory structure for Query lib match the documentation. <br>
 3. Make the library more exstensible (perhaps designed like the PDF and DOT libraries).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000154"></a> <dl>
<dt>Group <a class="el" href="group__localNodeQueryLib.html">localNodeQueryLib</a>  </dt>
<dd>Finish documentation!<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000155"></a> <dl>
<dt>Group <a class="el" href="group__subtreeQueryLib.html">subtreeQueryLib</a>  </dt>
<dd>Finish documentation!<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000159"></a> <dl>
<dt>Group <a class="el" href="group__DOTGenerationStuff.html">DOTGenerationStuff</a>  </dt>
<dd>Finish documentation! </dd>
</dl>
<p>
<a class="anchor" name="_todo000164"></a> <dl>
<dt>Group <a class="el" href="group__PDFGenerationStuff.html">PDFGenerationStuff</a>  </dt>
<dd>Finish documentation! </dd>
</dl>
<p>
<a class="anchor" name="_todo000167"></a> <dl>
<dt>Group <a class="el" href="group__transformationSupportLib.html">transformationSupportLib</a>  </dt>
<dd>Fixup interfaces in Sage III using code from the <a class="el" href="classTransformationSupport.html">TransformationSupport</a> class. </dd>
</dl>
<p>
<a class="anchor" name="_todo000003"></a> <dl>
<dt>Page <a class="el" href="AST_Copy_Mechanism.html">ROSE AST Copy Mechanism</a>  </dt>
<dd>Most types are shared, but named types are copied, and the copies need to have there declarations reset to the new AST.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000003"></a> <dl>
<dt>Page <a class="el" href="AST_Copy_Mechanism.html">ROSE AST Copy Mechanism</a>  </dt>
<dd>base class modifiers are shared and this should be fixed.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000003"></a> <dl>
<dt>Page <a class="el" href="AST_Copy_Mechanism.html">ROSE AST Copy Mechanism</a>  </dt>
<dd>Friend function in classes are not represented by symbols in the global scope. Not that this is always the rule, it is the default for <a class="el" href="namespaceROSE.html">ROSE</a> and it is setup inconsistantly in the generated AST copy. See copytest2007_39.C.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000003"></a> <dl>
<dt>Page <a class="el" href="AST_Copy_Mechanism.html">ROSE AST Copy Mechanism</a>  </dt>
<dd>copytest2007_46.C is too difficult to figure out (likely because the SgTemplateArguments are shared).<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000003"></a> <dl>
<dt>Page <a class="el" href="AST_Copy_Mechanism.html">ROSE AST Copy Mechanism</a>  </dt>
<dd>copytest2007_47.C is too complex and likely demonstrates an error.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000003"></a> <dl>
<dt>Page <a class="el" href="AST_Copy_Mechanism.html">ROSE AST Copy Mechanism</a>  </dt>
<dd>copytest2007_49.C is too complex and likely demonstrates an error.<p>
</dd>
</dl>
<hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
