<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: RangeMap&lt; R, T &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>RangeMap&lt; R, T &gt; Class Template Reference</h1><!-- doxytag: class="RangeMap" --><code>#include &lt;<a class="el" href="rangemap_8h-source.html">rangemap.h</a>&gt;</code>
<p>
Inheritance diagram for RangeMap&lt; R, T &gt;:<p><center><img src="classRangeMap__inherit__graph.png" border="0" usemap="#RangeMap_3_01R_00_01T_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="RangeMap_3_01R_00_01T_01_4__inherit__map">
<area href="classExtentMap.html" shape="rect" coords="5,103,264,129" alt="">
<area href="classRangeMap.html" shape="rect" coords="288,103,547,129" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classRangeMap-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt;<br>
 class RangeMap&lt; R, T &gt;</h3>

A container of ranges, somewhat like a set. 
<p>
The container is able to hold non-overlapping ranges, each of which has some associated value attached to it. Arbitrary ranges can be inserted and erased from the <a class="el" href="classRangeMap.html">RangeMap</a> without regard to the ranges that are present in the map, since this class can merge and split values (through methods defined on the value) as necessary in order to maintain the non-overlapping invariant. Every attempt was made to optimize this class for storage and execution efficiency and usability. The interface is similar to the std::map interface.<p>
In the simple case, when no data is attached to the ranges in the map, the <a class="el" href="classRangeMap.html">RangeMap</a> acts somewhat like an std::set with the following differences: <ul>
<li>
The iterator points to a pair whose <code>first</code> member is a <a class="el" href="classRange.html">Range</a> (the second member is a <a class="el" href="classRangeMapVoid.html">RangeMapVoid</a> instance with no useful data). </li>
<li>
The <a class="el" href="classRangeMap.html">RangeMap</a> uses much less memory than an std::set when the members are mostly contiguous. </li>
<li>
The <a class="el" href="classRangeMap.html#3fd9ee5ddde9ab9a00270a47ac2a6055">find()</a> method is faster when members are mostly contiguous. Both are O(log N) but N is much smaller for a <a class="el" href="classRangeMap.html">RangeMap</a> than an std::set due to the compression factor. </li>
</ul>
<p>
Here's an example of using the <a class="el" href="classRangeMap.html">RangeMap</a> as a set. For every CPU instruction in a binary specimen, it adds the addresses of the instruction to the set. In some architectures, such as x86, the instructions might overlap; this approach correctly handles that.<p>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>InstructionAddresses: <span class="keyword">public</span> <a class="code" href="classAstSimpleProcessing.html">AstSimpleProcessing</a> {
      <span class="keyword">typedef</span> <a class="code" href="classRange.html">Range&lt;rose_addr_t&gt;</a> AddressRange;
      <a class="code" href="classRangeMap.html">RangeMap&lt;AddressRange&gt;</a> set;
      <span class="keywordtype">void</span> visit(<a class="code" href="classSgNode.html">SgNode</a> *node) {
          <a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn = <a class="code" href="Cxx__Grammar_8h.html#8ea3968ea14e6511567d5e5b654315f1">isSgAsmInstruction</a>(node);
          <span class="keywordflow">if</span> (insn!=NULL) {
              <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> start = insn-&gt;<a class="code" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>();
              size_t <a class="code" href="classRangeMap.html#2b3a6c7d061eee298faab8a21c33cca1">size</a> = insn-&gt;<a class="code" href="classSgAsmInstruction.html#6adcc4eb7c725185baa3a2425a57843c">get_size</a>();
              set.insert(AddressRange(start, size));
          }
      }
  } instruction_addresses;
  instruction_addresses.traverse(<a class="code" href="namespacecfgUtils.html#ce4abf2beca5826144d69d3a0283050f">project</a>, <a class="code" href="Cxx__Grammar_8h.html#59f7fee88581c4dd75f5fb25dbefa29edefb5d09673c144dc5b4dc177e278696">preorder</a>);
  std::cout &lt;&lt;<span class="stringliteral">"Instructions occupy "</span> &lt;&lt;instruction_addresses.set.size() &lt;&lt;<span class="stringliteral">" bytes:\n"</span>
            &lt;&lt;instruction_addresses.set;
</pre></div><p>
A more complex example is using a <a class="el" href="classRangeMap.html">RangeMap</a> to store a value with each range. A simple example follows, where we want to build a <a class="el" href="classRangeMap.html">RangeMap</a> that associates any address with the function that owns that address, even when functions are discontiguous in the address space. The first step is to define the value type for the <a class="el" href="classRangeMap.html">RangeMap</a> we'll be using to store this:<p>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="classRange.html">Range&lt;rose_addr_t&gt;</a> AddressRange;

  <span class="keyword">class </span>FunctionRangeMapValue: <span class="keyword">public</span> <a class="code" href="classRangeMapValue.html">RangeMapValue</a>&lt;AddressRange, SgAsmFunction*&gt; {
  <span class="keyword">public</span>:
      FunctionRangeMapValue(): public <a class="code" href="classRangeMapValue.html">RangeMapValue</a>&lt;AddressRange, <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a>*&gt;(NULL) {}
      FunctionRangeMapValue(<a class="code" href="classFunction.html">Function</a> *f): public <a class="code" href="classRangeMapValue.html">RangeMapValue</a>&lt;AddressRange, <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a>*&gt;(f) {}

      FunctionRangeMapValue split(<span class="keyword">const</span> AddressRange&amp;, <span class="keyword">const</span> AddressRange::Value&amp;) {
          <span class="keywordflow">return</span> *<span class="keyword">this</span>;
      }

      <span class="keywordtype">void</span> <a class="code" href="classRangeMap.html#9b6ea9d357802f62f6cef906f4244fd3">print</a>(std::ostream &amp;o)<span class="keyword"> const </span>{
          <span class="keywordflow">if</span> (NULL==value) {
              o &lt;&lt;<span class="stringliteral">"(null)"</span>;
          } <span class="keywordflow">else</span> {
              o &lt;&lt;<span class="stringliteral">"F"</span> &lt;&lt;<a class="code" href="namespaceStringUtility.html#b07dfdb6df484680f9a29ad4fcf79f80">StringUtility::addrToString</a>(get()-&gt;entry_va);
          }
      }
  };

  <span class="keyword">typedef</span> <a class="code" href="classRangeMap.html">RangeMap&lt;AddressRange, FunctionRangeMapValue&gt;</a> FunctionRangeMap; 
</pre></div><p>
Define an AST traversal add each instruction to the <a class="el" href="classRangeMap.html">RangeMap</a>:<p>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>FindInstructions: <span class="keyword">public</span> <a class="code" href="classAstSimpleProcessing.html">AstSimpleProcessing</a> {
      FunctionRangeMap <a class="code" href="classRangeMap.html#cfab0d67fb25a1a64304cb8c4a202c75">ranges</a>;
      <span class="keywordtype">void</span> visit(<a class="code" href="classSgNode.html">SgNode</a> *node) {
          <a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn = <a class="code" href="Cxx__Grammar_8h.html#8ea3968ea14e6511567d5e5b654315f1">isSgAsmInstruction</a>(node);
          <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *func = SageInterface::getEnclosingNode&lt;SgAsmFunction&gt;(insn);
          <span class="keywordflow">if</span> (insn &amp;&amp; func) {
              <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> start = insn-&gt;<a class="code" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>();
              size_t size = insn-&gt;<a class="code" href="classSgAsmInstruction.html#6adcc4eb7c725185baa3a2425a57843c">get_size</a>();
              <a class="code" href="classRangeMap.html#cfab0d67fb25a1a64304cb8c4a202c75">ranges</a>.insert(AddressRange(start, size), func);
          }
      }
  };
</pre></div><p>
Finally, traverse the AST and print the result. Because <a class="el" href="classRangeMap.html">RangeMap</a> merges adjacent ranges when possible, the output will contain the fewest number of ranges needed to describe the entire address space that's assigned to functions. Note that it's possible for two or more functions to "own" the same part of the address space if their instructions overlap, but since we defined our <a class="el" href="classRangeMap.html">RangeMap</a> to hold only one function pointer per address we'll see only the function that was added last for overlapping ranges.<p>
<div class="fragment"><pre class="fragment">  FindInstructions insn_finder;
  insn_finder.traverse(interpretation, <a class="code" href="Cxx__Grammar_8h.html#59f7fee88581c4dd75f5fb25dbefa29edefb5d09673c144dc5b4dc177e278696">preorder</a>);
  o &lt;&lt;insn_finder.ranges;
</pre></div><p>
The <a class="el" href="classRangeMap.html">RangeMap</a> class template can also be specialized to hold more complex values. The value type defines how ranges can be merged and split. <a class="el" href="classRangeMap.html">RangeMap</a> value types must implement the interface described for <a class="el" href="classRangeMapVoid.html">RangeMapVoid</a>. Another example of a value type is <a class="el" href="classRangeMapValue.html">RangeMapValue</a>, that holds a simple scalar value and determines "mergeabiliy" and "splitability" based on the equality operator. Eventually, <a class="el" href="classMemoryMap.html">MemoryMap</a> might also be rewritten in terms of <a class="el" href="classRangeMap.html">RangeMap</a>, and will have much more complex rules for merging, splitting, truncating, and removing. 
<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00722">722</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef R&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#cdbc3a9ee1147e598215bda2ac6f5dd8">Range</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#8aa4e3a3e0446c73b2dabd85385fa17c">Value</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A type having the <a class="el" href="classRange.html">Range</a> interface, used as keys in the underlying std::map.  <a href="#8aa4e3a3e0446c73b2dabd85385fa17c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef Map::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef Map::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef Map::reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#8074a1b4f0b2bba0cf371d996a1e5dd6">reverse_iterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef Map::const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#39b1f3d923e2f3da32c75b2b63329331">const_reverse_iterator</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#9a99920c98384a02f34d69ec99f73377">RangeMap</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new, empty map.  <a href="#9a99920c98384a02f34d69ec99f73377"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Other&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRangeMap.html#b776c935ab0cf5291d6e76c8656754ea">RangeMap</a> (const Other &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new map from an existing map.  <a href="#b776c935ab0cf5291d6e76c8656754ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#c8b0d162d933083b16e68f519eb7f953">empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this <a class="el" href="classRangeMap.html">RangeMap</a> is empty.  <a href="#c8b0d162d933083b16e68f519eb7f953"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#ffe28d68866b20d3510f312ab1ed91a2">nranges</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of ranges in the range map.  <a href="#ffe28d68866b20d3510f312ab1ed91a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#2b3a6c7d061eee298faab8a21c33cca1">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of values represented by this <a class="el" href="classRangeMap.html">RangeMap</a>.  <a href="#2b3a6c7d061eee298faab8a21c33cca1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#edffcf3e970c3707f06b053808dcf9ff">min</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the minimum value in an extent map.  <a href="#edffcf3e970c3707f06b053808dcf9ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#8390dd822f35acb4657f0e833777cba3">max</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the maximum value in an extent map.  <a href="#8390dd822f35acb4657f0e833777cba3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRange.html">Range</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#48f9bb610f4db9299f646e4068886808">minmax</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the range of values in this map.  <a href="#48f9bb610f4db9299f646e4068886808"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#aa952ec5cec6a9fce073e336109fd5f7">clear</a> (bool notify=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the map.  <a href="#aa952ec5cec6a9fce073e336109fd5f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a601374137845507fa80c404308ac426">erase</a> (const <a class="el" href="classRange.html">Range</a> &amp;erase_range)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases the specified range from this map.  <a href="#a601374137845507fa80c404308ac426"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class OtherMap&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRangeMap.html#00d59a4700389b0d1c2e8b66457db06b">erase_ranges</a> (const OtherMap &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase ranges from this map.  <a href="#00d59a4700389b0d1c2e8b66457db06b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#df8ef8a1ea1d08b513487c6043ec0d8d">insert</a> (<a class="el" href="classRange.html">Range</a> new_range, <a class="el" href="classRangeMap.html#8aa4e3a3e0446c73b2dabd85385fa17c">Value</a> new_value=<a class="el" href="classRangeMap.html#8aa4e3a3e0446c73b2dabd85385fa17c">Value</a>(), bool make_hole=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a range/value pair into the map.  <a href="#df8ef8a1ea1d08b513487c6043ec0d8d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#297d504b27078eb077ba93d24f257637">insert_ranges</a> (const <a class="el" href="classRangeMap.html">RangeMap</a> &amp;x, bool make_hole=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert one rangemap into another.  <a href="#297d504b27078eb077ba93d24f257637"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#342bf072f0b42f5b807cdd07982e0219">insert_ranges</a> (<a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a> start, <a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a> stop, bool make_hole=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert part of one rangemap into another.  <a href="#342bf072f0b42f5b807cdd07982e0219"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#0b847d42d1de229dd4e4a6ed289c9955">overlaps</a> (const <a class="el" href="classRangeMap.html">RangeMap</a> &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if two range maps overlap.  <a href="#0b847d42d1de229dd4e4a6ed289c9955"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#7e9523a07bea9f59770d7e4db3fc1093">overlaps</a> (const <a class="el" href="classRange.html">Range</a> &amp;r) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if a range map overlaps with a specified range.  <a href="#7e9523a07bea9f59770d7e4db3fc1093"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#b98012d738664a3a4268430dfe0c598b">distinct</a> (const <a class="el" href="classRangeMap.html">RangeMap</a> &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if two range maps are distinct.  <a href="#b98012d738664a3a4268430dfe0c598b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#cb7a2bd99750f3b48f7667d5f01fe083">contains</a> (<a class="el" href="classRange.html">Range</a> need) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if this range map contains all of the specified range.  <a href="#cb7a2bd99750f3b48f7667d5f01fe083"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#dc2f20a29d4cafd1e37871abc78bd657">contains</a> (const <a class="el" href="classRangeMap.html">RangeMap</a> &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determins if this range map contains all of some other range map.  <a href="#dc2f20a29d4cafd1e37871abc78bd657"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class ResultMap&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ResultMap&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRangeMap.html#19f65661f7cda3080ef227a72f5833a1">invert</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an inverse of a range map.  <a href="#19f65661f7cda3080ef227a72f5833a1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class ResultMap&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ResultMap&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRangeMap.html#55571866e93f2fa9a5580a3a65ddeef5">invert_within</a> (const <a class="el" href="classRange.html">Range</a> &amp;limits) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a range map that's the inverse of some other map.  <a href="#55571866e93f2fa9a5580a3a65ddeef5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html">RangeMap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#4b6cd20712b9ff730953ccd548183f52">select_overlapping_ranges</a> (const <a class="el" href="classRange.html">Range</a> &amp;selector) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Select ranges overlapping selector range.  <a href="#4b6cd20712b9ff730953ccd548183f52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#1079b01f80c8b3b4d7d8575ce49b4f99">check</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#9b6ea9d357802f62f6cef906f4244fd3">print</a> (std::ostream &amp;o) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints unformatted <a class="el" href="classRangeMap.html">RangeMap</a> on a single line.  <a href="#9b6ea9d357802f62f6cef906f4244fd3"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#09ef36a75655f2a1cbb74e60e34df930">begin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">First-item iterator.  <a href="#09ef36a75655f2a1cbb74e60e34df930"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#c90017a30464ebd434a33f3902aa4e36">begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">First-item iterator.  <a href="#c90017a30464ebd434a33f3902aa4e36"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#db1c2cb143b8d68961dbaf7debbf84e5">end</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">End-item iterator.  <a href="#db1c2cb143b8d68961dbaf7debbf84e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#64b179b10e420f39347c49a9ba7a7f97">end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">End-item iterator.  <a href="#64b179b10e420f39347c49a9ba7a7f97"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html#8074a1b4f0b2bba0cf371d996a1e5dd6">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#d3f7082969c7967d38c06b2ba6f19197">rbegin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a reverse iterator referring to the last item of the map, the <a class="el" href="classRangeMap.html#7838b1858fc9221aa675227020b71cc2">rend()</a> iterator if the <a class="el" href="classRangeMap.html">RangeMap</a> is empty.  <a href="#d3f7082969c7967d38c06b2ba6f19197"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html#39b1f3d923e2f3da32c75b2b63329331">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#0dae12393aab5b7254d7c86c6bc1e1a0">rbegin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a reverse iterator referring to the last item of the map, the <a class="el" href="classRangeMap.html#7838b1858fc9221aa675227020b71cc2">rend()</a> iterator if the <a class="el" href="classRangeMap.html">RangeMap</a> is empty.  <a href="#0dae12393aab5b7254d7c86c6bc1e1a0"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html#8074a1b4f0b2bba0cf371d996a1e5dd6">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#7838b1858fc9221aa675227020b71cc2">rend</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a reverse iterator referring to the element right before the first element in the map, which is considered its reverse end.  <a href="#7838b1858fc9221aa675227020b71cc2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html#39b1f3d923e2f3da32c75b2b63329331">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a7267f5fa4967e0ab756e72f2deec797">rend</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a reverse iterator referring to the element right before the first element in the map, which is considered its reverse end.  <a href="#a7267f5fa4967e0ab756e72f2deec797"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#3fd9ee5ddde9ab9a00270a47ac2a6055">find</a> (const typename <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a> &amp;addr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the range containing specified value.  <a href="#3fd9ee5ddde9ab9a00270a47ac2a6055"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#bbc3f6cb04978971c898a7a45d643287">find</a> (const typename <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a> &amp;addr) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the range containing specified value.  <a href="#bbc3f6cb04978971c898a7a45d643287"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#d59ac92205fde7c48fb73e6a28ff62c3">lower_bound</a> (const typename <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a> &amp;addr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the first range ending above the specified value.  <a href="#d59ac92205fde7c48fb73e6a28ff62c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#a84dbdb8e32df2d227f2c5f983ef0825">lower_bound</a> (const typename <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a> &amp;addr) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the first range ending above the specified value.  <a href="#a84dbdb8e32df2d227f2c5f983ef0825"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#0b5025ec1244eeec2619e2cc02cd8868">find_prior</a> (const typename <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a> &amp;addr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the last range starting at or below the specified value.  <a href="#0b5025ec1244eeec2619e2cc02cd8868"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#bed55ecf09a0c890051a27dd6e7ccead">find_prior</a> (const typename <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a> &amp;addr) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the last range starting at or below the specified value.  <a href="#bed55ecf09a0c890051a27dd6e7ccead"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#c8ed4543f00dadebcf0bfc1fcce33d9c">best_fit</a> (const typename <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a> &amp;size, <a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a> start)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find range with closest size.  <a href="#c8ed4543f00dadebcf0bfc1fcce33d9c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#34f973bb4b92cd21b93cf513cf5adfbb">best_fit</a> (const typename <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a> &amp;size, <a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a> start) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find range with closest size.  <a href="#34f973bb4b92cd21b93cf513cf5adfbb"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#3ffec229fe572ffe252e98b49597d616">first_fit</a> (const typename <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a> &amp;size, <a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a> start)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find first range of larger size.  <a href="#3ffec229fe572ffe252e98b49597d616"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#be8568e50454d9f13be779c11750323f">first_fit</a> (const typename <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a> &amp;size, <a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a> start)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find first range of larger size.  <a href="#be8568e50454d9f13be779c11750323f"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#3a9c931d12bab254da6386263ab0d4ca">find_overlap</a> (const <a class="el" href="classRangeMap.html">RangeMap</a> &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the first overlap between two <a class="el" href="classRangeMap.html">RangeMap</a> objects.  <a href="#3a9c931d12bab254da6386263ab0d4ca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#7f500bba08ce529ac3f6df75603fdded">first_overlap</a> (const <a class="el" href="classRangeMap.html">RangeMap</a> &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the first overlap between two <a class="el" href="classRangeMap.html">RangeMap</a> objects.  <a href="#7f500bba08ce529ac3f6df75603fdded"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#c4c758a7003cbc5600237ac715c63613">find_overlap</a> (<a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a> start, <a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a> stop, const <a class="el" href="classRangeMap.html">RangeMap</a> &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find an overlap between two <a class="el" href="classRangeMap.html">RangeMap</a> objects.  <a href="#c4c758a7003cbc5600237ac715c63613"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#2e269c7f95bf5a14ef3f598f17c42483">find_overlap</a> (<a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a> start, <a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a> stop, const <a class="el" href="classRangeMap.html">RangeMap</a> &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find an overlap between two <a class="el" href="classRangeMap.html">RangeMap</a> objects.  <a href="#2e269c7f95bf5a14ef3f598f17c42483"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::pair&lt; <a class="el" href="classRange.html">Range</a>,<br>
 <a class="el" href="classRange.html">Range</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#7609ee38a7e78ea97f3aa4ca15651d06">RangePair</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::pair&lt; <a class="el" href="classRange.html">Range</a>,<br>
 <a class="el" href="classRangeMap.html#8aa4e3a3e0446c73b2dabd85385fa17c">Value</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#354b969b7a2e2df03c2bc0b4c20bf543">MapPair</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map&lt; <a class="el" href="classRange.html">Range</a>, <a class="el" href="classRangeMap.html#8aa4e3a3e0446c73b2dabd85385fa17c">Value</a>,<br>
 <a class="el" href="structRangeMap_1_1RangeCompare.html">RangeCompare</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#8159c5dc84db3157927164f3662e4430">Map</a></td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRangeMap.html#8159c5dc84db3157927164f3662e4430">Map</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#cfab0d67fb25a1a64304cb8c4a202c75">ranges</a></td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRangeMap.html#083d5a2616f986b0c7127be058858cba">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classRangeMap.html">RangeMap</a> &amp;rmap)</td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRangeMap_1_1RangeCompare.html">RangeCompare</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The value attached to each range in this <a class="el" href="classRangeMap.html">RangeMap</a>.  <a href="structRangeMap_1_1RangeCompare.html#_details">More...</a><br></td></tr>
</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="cdbc3a9ee1147e598215bda2ac6f5dd8"></a><!-- doxytag: member="RangeMap::Range" ref="cdbc3a9ee1147e598215bda2ac6f5dd8" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef R <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::<a class="el" href="classRange.html">Range</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00724">724</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="8aa4e3a3e0446c73b2dabd85385fa17c"></a><!-- doxytag: member="RangeMap::Value" ref="8aa4e3a3e0446c73b2dabd85385fa17c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::<a class="el" href="classRangeMap.html#8aa4e3a3e0446c73b2dabd85385fa17c">Value</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A type having the <a class="el" href="classRange.html">Range</a> interface, used as keys in the underlying std::map. 
<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00725">725</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="7609ee38a7e78ea97f3aa4ca15651d06"></a><!-- doxytag: member="RangeMap::RangePair" ref="7609ee38a7e78ea97f3aa4ca15651d06" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="classRange.html">Range</a>, <a class="el" href="classRange.html">Range</a>&gt; <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::<a class="el" href="classRangeMap.html#7609ee38a7e78ea97f3aa4ca15651d06">RangePair</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00737">737</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="354b969b7a2e2df03c2bc0b4c20bf543"></a><!-- doxytag: member="RangeMap::MapPair" ref="354b969b7a2e2df03c2bc0b4c20bf543" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="classRange.html">Range</a>, <a class="el" href="classRangeMap.html#8aa4e3a3e0446c73b2dabd85385fa17c">Value</a>&gt; <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::<a class="el" href="classRangeMap.html#354b969b7a2e2df03c2bc0b4c20bf543">MapPair</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00738">738</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="8159c5dc84db3157927164f3662e4430"></a><!-- doxytag: member="RangeMap::Map" ref="8159c5dc84db3157927164f3662e4430" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="classRange.html">Range</a>, <a class="el" href="classRangeMap.html#8aa4e3a3e0446c73b2dabd85385fa17c">Value</a>, <a class="el" href="structRangeMap_1_1RangeCompare.html">RangeCompare</a>&gt; <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::<a class="el" href="classRangeMap.html#8159c5dc84db3157927164f3662e4430">Map</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00739">739</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="ff5cb1527b5c0906f1696aecab58c8d2"></a><!-- doxytag: member="RangeMap::iterator" ref="ff5cb1527b5c0906f1696aecab58c8d2" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Map::iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::<a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00743">743</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="b5c65ae6400776a38fe42e05b7b411cd"></a><!-- doxytag: member="RangeMap::const_iterator" ref="b5c65ae6400776a38fe42e05b7b411cd" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Map::const_iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::<a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00744">744</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="8074a1b4f0b2bba0cf371d996a1e5dd6"></a><!-- doxytag: member="RangeMap::reverse_iterator" ref="8074a1b4f0b2bba0cf371d996a1e5dd6" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Map::reverse_iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::<a class="el" href="classRangeMap.html#8074a1b4f0b2bba0cf371d996a1e5dd6">reverse_iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00745">745</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="39b1f3d923e2f3da32c75b2b63329331"></a><!-- doxytag: member="RangeMap::const_reverse_iterator" ref="39b1f3d923e2f3da32c75b2b63329331" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Map::const_reverse_iterator <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::<a class="el" href="classRangeMap.html#39b1f3d923e2f3da32c75b2b63329331">const_reverse_iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00746">746</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="9a99920c98384a02f34d69ec99f73377"></a><!-- doxytag: member="RangeMap::RangeMap" ref="9a99920c98384a02f34d69ec99f73377" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::<a class="el" href="classRangeMap.html">RangeMap</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new, empty map. 
<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00754">754</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="b776c935ab0cf5291d6e76c8656754ea"></a><!-- doxytag: member="RangeMap::RangeMap" ref="b776c935ab0cf5291d6e76c8656754ea" args="(const Other &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Other&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::<a class="el" href="classRangeMap.html">RangeMap</a>           </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new map from an existing map. 
<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00758">758</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="09ef36a75655f2a1cbb74e60e34df930"></a><!-- doxytag: member="RangeMap::begin" ref="09ef36a75655f2a1cbb74e60e34df930" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
First-item iterator. 
<p>
Returns an iterator for the first item, or the end iterator if the <a class="el" href="classRangeMap.html">RangeMap</a> is empty. The iterator is valid until any operation that changes the <a class="el" href="classRangeMap.html">RangeMap</a>, such as an insert or erase. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00775">775</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="IntervalSemantics_8h-source.html#l00421">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::add()</a>, <a class="el" href="Partitioner_8C-source.html#l03080">Partitioner::adjust_padding()</a>, <a class="el" href="ExtentMap_8C-source.html#l00037">ExtentMap::allocate_best_fit()</a>, <a class="el" href="ExtentMap_8C-source.html#l00049">ExtentMap::allocate_first_fit()</a>, <a class="el" href="rangemap_8h-source.html#l01268">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::check()</a>, <a class="el" href="rangemap_8h-source.html#l00979">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::clear()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00546">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::concat()</a>, <a class="el" href="rangemap_8h-source.html#l01154">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::contains()</a>, <a class="el" href="MemoryMap_8C-source.html#l00862">MemoryMap::dump()</a>, <a class="el" href="ExtentMap_8C-source.html#l00136">ExtentMap::dump_extents()</a>, <a class="el" href="MemoryMap_8C-source.html#l00628">MemoryMap::erase()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00518">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::extract()</a>, <a class="el" href="GenericFile_8C-source.html#l01261">SgAsmGenericFile::fill_holes()</a>, <a class="el" href="rangemap_8h-source.html#l01173">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::find_overlap()</a>, <a class="el" href="rangemap_8h-source.html#l00853">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::find_prior()</a>, <a class="el" href="rangemap_8h-source.html#l01176">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::first_overlap()</a>, <a class="el" href="Partitioner_8C-source.html#l03392">Partitioner::function_extent()</a>, <a class="el" href="GenericSection_8C-source.html#l00613">SgAsmGenericSection::get_referenced_extents()</a>, <a class="el" href="MemoryMap_8C-source.html#l00562">MemoryMap::init()</a>, <a class="el" href="rangemap_8h-source.html#l01094">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::insert_ranges()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00504">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::invert()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00632">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::negate()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00167">BinaryAnalysis::InstructionSemantics::IntervalSemantics::ValueType&lt; 16 &gt;::possible_bits()</a>, <a class="el" href="rangemap_8h-source.html#l01348">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::print()</a>, <a class="el" href="MemoryMap_8C-source.html#l00681">MemoryMap::prune()</a>, <a class="el" href="Partitioner_8C-source.html#l01643">Partitioner::scan_unassigned_bytes()</a>, <a class="el" href="GenericFile_8C-source.html#l00737">SgAsmGenericFile::shift_extend()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00725">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::shiftRight()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00777">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::signExtend()</a>, <a class="el" href="rangemap_8h-source.html#l00942">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::size()</a>, <a class="el" href="rtiHelpers_8h-source.html#l00053">toStringForRTI()</a>, <a class="el" href="MemoryMap_8C-source.html#l00674">MemoryMap::traverse()</a>, <a class="el" href="GenericSection_8C-source.html#l00700">SgAsmGenericSection::unparse()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00820">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::unsignedDivide()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00856">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::unsignedMultiply()</a>, and <a class="el" href="MemoryMap_8C-source.html#l00761">MemoryMap::write1()</a>.
</div>
</div><p>
<a class="anchor" name="c90017a30464ebd434a33f3902aa4e36"></a><!-- doxytag: member="RangeMap::begin" ref="c90017a30464ebd434a33f3902aa4e36" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
First-item iterator. 
<p>
Returns an iterator for the first item, or the end iterator if the <a class="el" href="classRangeMap.html">RangeMap</a> is empty. The iterator is valid until any operation that changes the <a class="el" href="classRangeMap.html">RangeMap</a>, such as an insert or erase. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00778">778</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="db1c2cb143b8d68961dbaf7debbf84e5"></a><!-- doxytag: member="RangeMap::end" ref="db1c2cb143b8d68961dbaf7debbf84e5" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
End-item iterator. 
<p>
Returns an iterator to the one-past-last item of the <a class="el" href="classRangeMap.html">RangeMap</a>, regardless of whether the range map is empty. The iterator is valid until any operation that changes the <a class="el" href="classRangeMap.html">RangeMap</a>, such as an insert or erase. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00787">787</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="IntervalSemantics_8h-source.html#l00421">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::add()</a>, <a class="el" href="Partitioner_8C-source.html#l03080">Partitioner::adjust_padding()</a>, <a class="el" href="ExtentMap_8C-source.html#l00037">ExtentMap::allocate_best_fit()</a>, <a class="el" href="ExtentMap_8C-source.html#l00049">ExtentMap::allocate_first_fit()</a>, <a class="el" href="MemoryMap_8C-source.html#l00639">MemoryMap::at()</a>, <a class="el" href="rangemap_8h-source.html#l00880">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::best_fit()</a>, <a class="el" href="rangemap_8h-source.html#l01268">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::check()</a>, <a class="el" href="rangemap_8h-source.html#l00979">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::clear()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00546">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::concat()</a>, <a class="el" href="rangemap_8h-source.html#l01133">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::contains()</a>, <a class="el" href="rangemap_8h-source.html#l01127">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::distinct()</a>, <a class="el" href="MemoryMap_8C-source.html#l00862">MemoryMap::dump()</a>, <a class="el" href="ExtentMap_8C-source.html#l00136">ExtentMap::dump_extents()</a>, <a class="el" href="rangemap_8h-source.html#l00991">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::erase()</a>, <a class="el" href="MemoryMap_8C-source.html#l00628">MemoryMap::erase()</a>, <a class="el" href="MemoryMap_8C-source.html#l00599">MemoryMap::exists()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00518">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::extract()</a>, <a class="el" href="GenericFile_8C-source.html#l01261">SgAsmGenericFile::fill_holes()</a>, <a class="el" href="rangemap_8h-source.html#l00824">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::find()</a>, <a class="el" href="MemoryMap_8C-source.html#l00648">MemoryMap::find_free()</a>, <a class="el" href="MemoryMap_8C-source.html#l00664">MemoryMap::find_last_free()</a>, <a class="el" href="rangemap_8h-source.html#l01173">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::find_overlap()</a>, <a class="el" href="rangemap_8h-source.html#l00853">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::find_prior()</a>, <a class="el" href="rangemap_8h-source.html#l00906">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::first_fit()</a>, <a class="el" href="rangemap_8h-source.html#l01176">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::first_overlap()</a>, <a class="el" href="Partitioner_8C-source.html#l03392">Partitioner::function_extent()</a>, <a class="el" href="GenericSection_8C-source.html#l00613">SgAsmGenericSection::get_referenced_extents()</a>, <a class="el" href="MemoryMap_8C-source.html#l00562">MemoryMap::init()</a>, <a class="el" href="rangemap_8h-source.html#l01062">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::insert()</a>, <a class="el" href="MemoryMap_8C-source.html#l00585">MemoryMap::insert()</a>, <a class="el" href="rangemap_8h-source.html#l01094">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::insert_ranges()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00504">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::invert()</a>, <a class="el" href="rangemap_8h-source.html#l01233">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::invert_within()</a>, <a class="el" href="MemoryMap_8C-source.html#l00811">MemoryMap::mprotect()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00632">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::negate()</a>, <a class="el" href="Partitioner_8C-source.html#l02176">Partitioner::FindInterPadFunctions::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l02036">Partitioner::FindFunctionFragments::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l01820">Partitioner::FindData::operator()()</a>, <a class="el" href="rangemap_8h-source.html#l01112">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::overlaps()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00167">BinaryAnalysis::InstructionSemantics::IntervalSemantics::ValueType&lt; 16 &gt;::possible_bits()</a>, <a class="el" href="rangemap_8h-source.html#l01348">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::print()</a>, <a class="el" href="MemoryMap_8C-source.html#l00681">MemoryMap::prune()</a>, <a class="el" href="MemoryMap_8C-source.html#l00708">MemoryMap::read1()</a>, <a class="el" href="Partitioner_8C-source.html#l01643">Partitioner::scan_unassigned_bytes()</a>, <a class="el" href="rangemap_8h-source.html#l01252">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::select_overlapping_ranges()</a>, <a class="el" href="GenericFile_8C-source.html#l00737">SgAsmGenericFile::shift_extend()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00725">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::shiftRight()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00777">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::signExtend()</a>, <a class="el" href="rangemap_8h-source.html#l00942">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::size()</a>, <a class="el" href="rtiHelpers_8h-source.html#l00053">toStringForRTI()</a>, <a class="el" href="MemoryMap_8C-source.html#l00674">MemoryMap::traverse()</a>, <a class="el" href="PeStringTable_8C-source.html#l00176">SgAsmCoffStrtab::unparse()</a>, <a class="el" href="GenericSection_8C-source.html#l00700">SgAsmGenericSection::unparse()</a>, <a class="el" href="ElfStringTable_8C-source.html#l00254">SgAsmElfStrtab::unparse()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00820">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::unsignedDivide()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00856">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::unsignedMultiply()</a>, and <a class="el" href="MemoryMap_8C-source.html#l00761">MemoryMap::write1()</a>.
</div>
</div><p>
<a class="anchor" name="64b179b10e420f39347c49a9ba7a7f97"></a><!-- doxytag: member="RangeMap::end" ref="64b179b10e420f39347c49a9ba7a7f97" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
End-item iterator. 
<p>
Returns an iterator to the one-past-last item of the <a class="el" href="classRangeMap.html">RangeMap</a>, regardless of whether the range map is empty. The iterator is valid until any operation that changes the <a class="el" href="classRangeMap.html">RangeMap</a>, such as an insert or erase. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00790">790</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="d3f7082969c7967d38c06b2ba6f19197"></a><!-- doxytag: member="RangeMap::rbegin" ref="d3f7082969c7967d38c06b2ba6f19197" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html#8074a1b4f0b2bba0cf371d996a1e5dd6">reverse_iterator</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::rbegin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a reverse iterator referring to the last item of the map, the <a class="el" href="classRangeMap.html#7838b1858fc9221aa675227020b71cc2">rend()</a> iterator if the <a class="el" href="classRangeMap.html">RangeMap</a> is empty. 
<p>
The iterator is valid until any operation that changes the <a class="el" href="classRangeMap.html">RangeMap</a>, such as an insert or erase. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00799">799</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="GenericString_8C-source.html#l00305">SgAsmGenericStrtab::reallocate()</a>.
</div>
</div><p>
<a class="anchor" name="0dae12393aab5b7254d7c86c6bc1e1a0"></a><!-- doxytag: member="RangeMap::rbegin" ref="0dae12393aab5b7254d7c86c6bc1e1a0" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html#39b1f3d923e2f3da32c75b2b63329331">const_reverse_iterator</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::rbegin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a reverse iterator referring to the last item of the map, the <a class="el" href="classRangeMap.html#7838b1858fc9221aa675227020b71cc2">rend()</a> iterator if the <a class="el" href="classRangeMap.html">RangeMap</a> is empty. 
<p>
The iterator is valid until any operation that changes the <a class="el" href="classRangeMap.html">RangeMap</a>, such as an insert or erase. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00802">802</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="7838b1858fc9221aa675227020b71cc2"></a><!-- doxytag: member="RangeMap::rend" ref="7838b1858fc9221aa675227020b71cc2" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html#8074a1b4f0b2bba0cf371d996a1e5dd6">reverse_iterator</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::rend           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a reverse iterator referring to the element right before the first element in the map, which is considered its reverse end. 
<p>
Notice that <a class="el" href="classRangeMap.html#7838b1858fc9221aa675227020b71cc2">rend()</a> does not refer to the same element as <a class="el" href="classRangeMap.html#09ef36a75655f2a1cbb74e60e34df930">begin()</a>, but to the element right before it. The iterator is valid until any operation that changes the <a class="el" href="classRangeMap.html">RangeMap</a>, such as an insert or erase. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00812">812</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="a7267f5fa4967e0ab756e72f2deec797"></a><!-- doxytag: member="RangeMap::rend" ref="a7267f5fa4967e0ab756e72f2deec797" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html#39b1f3d923e2f3da32c75b2b63329331">const_reverse_iterator</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::rend           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a reverse iterator referring to the element right before the first element in the map, which is considered its reverse end. 
<p>
Notice that <a class="el" href="classRangeMap.html#7838b1858fc9221aa675227020b71cc2">rend()</a> does not refer to the same element as <a class="el" href="classRangeMap.html#09ef36a75655f2a1cbb74e60e34df930">begin()</a>, but to the element right before it. The iterator is valid until any operation that changes the <a class="el" href="classRangeMap.html">RangeMap</a>, such as an insert or erase. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00815">815</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="3fd9ee5ddde9ab9a00270a47ac2a6055"></a><!-- doxytag: member="RangeMap::find" ref="3fd9ee5ddde9ab9a00270a47ac2a6055" args="(const typename Range::Value &amp;addr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::find           </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>addr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the range containing specified value. 
<p>
Returns an iterator to the <a class="el" href="classRange.html">Range</a> containing the specified value, or the <a class="el" href="classRangeMap.html#db1c2cb143b8d68961dbaf7debbf84e5">end()</a> iterator if no such range exists. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00824">824</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="MemoryMap_8C-source.html#l00639">MemoryMap::at()</a>, <a class="el" href="rangemap_8h-source.html#l01133">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::contains()</a>, <a class="el" href="MemoryMap_8C-source.html#l00599">MemoryMap::exists()</a>, <a class="el" href="rangemap_8h-source.html#l01062">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::insert()</a>, <a class="el" href="Partitioner_8C-source.html#l02176">Partitioner::FindInterPadFunctions::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l02036">Partitioner::FindFunctionFragments::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l01820">Partitioner::FindData::operator()()</a>, <a class="el" href="MemoryMap_8C-source.html#l00708">MemoryMap::read1()</a>, and <a class="el" href="MemoryMap_8C-source.html#l00761">MemoryMap::write1()</a>.
</div>
</div><p>
<a class="anchor" name="bbc3f6cb04978971c898a7a45d643287"></a><!-- doxytag: member="RangeMap::find" ref="bbc3f6cb04978971c898a7a45d643287" args="(const typename Range::Value &amp;addr) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::find           </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>addr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the range containing specified value. 
<p>
Returns an iterator to the <a class="el" href="classRange.html">Range</a> containing the specified value, or the <a class="el" href="classRangeMap.html#db1c2cb143b8d68961dbaf7debbf84e5">end()</a> iterator if no such range exists. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00830">830</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="d59ac92205fde7c48fb73e6a28ff62c3"></a><!-- doxytag: member="RangeMap::lower_bound" ref="d59ac92205fde7c48fb73e6a28ff62c3" args="(const typename Range::Value &amp;addr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::lower_bound           </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>addr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds the first range ending above the specified value. 
<p>
This is similar to the <a class="el" href="classRangeMap.html#3fd9ee5ddde9ab9a00270a47ac2a6055">find()</a> method, except it does not return the <a class="el" href="classRangeMap.html#db1c2cb143b8d68961dbaf7debbf84e5">end()</a> iterator if a range exists above the specified value. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00842">842</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l00991">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::erase()</a>, <a class="el" href="rangemap_8h-source.html#l00824">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::find()</a>, <a class="el" href="MemoryMap_8C-source.html#l00648">MemoryMap::find_free()</a>, <a class="el" href="rangemap_8h-source.html#l01187">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::find_overlap()</a>, <a class="el" href="rangemap_8h-source.html#l00853">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::find_prior()</a>, <a class="el" href="rangemap_8h-source.html#l01062">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::insert()</a>, <a class="el" href="MemoryMap_8C-source.html#l00585">MemoryMap::insert()</a>, <a class="el" href="rangemap_8h-source.html#l01233">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::invert_within()</a>, <a class="el" href="MemoryMap_8C-source.html#l00811">MemoryMap::mprotect()</a>, <a class="el" href="rangemap_8h-source.html#l01118">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::overlaps()</a>, and <a class="el" href="rangemap_8h-source.html#l01252">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::select_overlapping_ranges()</a>.
</div>
</div><p>
<a class="anchor" name="a84dbdb8e32df2d227f2c5f983ef0825"></a><!-- doxytag: member="RangeMap::lower_bound" ref="a84dbdb8e32df2d227f2c5f983ef0825" args="(const typename Range::Value &amp;addr) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::lower_bound           </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>addr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds the first range ending above the specified value. 
<p>
This is similar to the <a class="el" href="classRangeMap.html#3fd9ee5ddde9ab9a00270a47ac2a6055">find()</a> method, except it does not return the <a class="el" href="classRangeMap.html#db1c2cb143b8d68961dbaf7debbf84e5">end()</a> iterator if a range exists above the specified value. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00845">845</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="0b5025ec1244eeec2619e2cc02cd8868"></a><!-- doxytag: member="RangeMap::find_prior" ref="0b5025ec1244eeec2619e2cc02cd8868" args="(const typename Range::Value &amp;addr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::find_prior           </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>addr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds the last range starting at or below the specified value. 
<p>
Returns the end iterator if there is no range containing a value less than or equal to the specified value. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00853">853</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03080">Partitioner::adjust_padding()</a>, and <a class="el" href="MemoryMap_8C-source.html#l00664">MemoryMap::find_last_free()</a>.
</div>
</div><p>
<a class="anchor" name="bed55ecf09a0c890051a27dd6e7ccead"></a><!-- doxytag: member="RangeMap::find_prior" ref="bed55ecf09a0c890051a27dd6e7ccead" args="(const typename Range::Value &amp;addr) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::find_prior           </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>addr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds the last range starting at or below the specified value. 
<p>
Returns the end iterator if there is no range containing a value less than or equal to the specified value. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00863">863</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="c8ed4543f00dadebcf0bfc1fcce33d9c"></a><!-- doxytag: member="RangeMap::best_fit" ref="c8ed4543f00dadebcf0bfc1fcce33d9c" args="(const typename Range::Value &amp;size, iterator start)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::best_fit           </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>start</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find range with closest size. 
<p>
Returns an iterator pointing to the first range at or after the specified <code>start</code> iterator whose size is at least as large as the specified size. Returns the end iterator if no such range exists. Note that this is an O(N) algorithm. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00880">880</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="ExtentMap_8C-source.html#l00037">ExtentMap::allocate_best_fit()</a>.
</div>
</div><p>
<a class="anchor" name="34f973bb4b92cd21b93cf513cf5adfbb"></a><!-- doxytag: member="RangeMap::best_fit" ref="34f973bb4b92cd21b93cf513cf5adfbb" args="(const typename Range::Value &amp;size, const_iterator start) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::best_fit           </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>start</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find range with closest size. 
<p>
Returns an iterator pointing to the first range at or after the specified <code>start</code> iterator whose size is at least as large as the specified size. Returns the end iterator if no such range exists. Note that this is an O(N) algorithm. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00890">890</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="3ffec229fe572ffe252e98b49597d616"></a><!-- doxytag: member="RangeMap::first_fit" ref="3ffec229fe572ffe252e98b49597d616" args="(const typename Range::Value &amp;size, iterator start)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::first_fit           </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>start</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find first range of larger size. 
<p>
Returns an iterator to the first range at least as large as the specified <code>size</code> and at or after <code>start</code>. Returns the end iterator if no range is found. Note that this is an O(N) algorithm. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00906">906</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="ExtentMap_8C-source.html#l00049">ExtentMap::allocate_first_fit()</a>, and <a class="el" href="MemoryMap_8C-source.html#l00648">MemoryMap::find_free()</a>.
</div>
</div><p>
<a class="anchor" name="be8568e50454d9f13be779c11750323f"></a><!-- doxytag: member="RangeMap::first_fit" ref="be8568e50454d9f13be779c11750323f" args="(const typename Range::Value &amp;size, const_iterator start)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::first_fit           </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>start</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find first range of larger size. 
<p>
Returns an iterator to the first range at least as large as the specified <code>size</code> and at or after <code>start</code>. Returns the end iterator if no range is found. Note that this is an O(N) algorithm. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00913">913</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="c8b0d162d933083b16e68f519eb7f953"></a><!-- doxytag: member="RangeMap::empty" ref="c8b0d162d933083b16e68f519eb7f953" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::empty           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this <a class="el" href="classRangeMap.html">RangeMap</a> is empty. 
<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00928">928</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l01154">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::contains()</a>, <a class="el" href="Partitioner_8C-source.html#l01998">Partitioner::find_db_starting()</a>, <a class="el" href="rangemap_8h-source.html#l00853">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::find_prior()</a>, <a class="el" href="rangemap_8h-source.html#l00956">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::max()</a>, <a class="el" href="rangemap_8h-source.html#l00950">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::min()</a>, <a class="el" href="Partitioner_8C-source.html#l02036">Partitioner::FindFunctionFragments::operator()()</a>, and <a class="el" href="IntervalSemantics_8h-source.html#l00130">BinaryAnalysis::InstructionSemantics::IntervalSemantics::ValueType&lt; 16 &gt;::ValueType()</a>.
</div>
</div><p>
<a class="anchor" name="ffe28d68866b20d3510f312ab1ed91a2"></a><!-- doxytag: member="RangeMap::nranges" ref="ffe28d68866b20d3510f312ab1ed91a2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::nranges           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of ranges in the range map. 
<p>
This is the number of <a class="el" href="classRange.html">Range</a> objects one would encounter if they iterate over this <a class="el" href="classRangeMap.html">RangeMap</a> from <a class="el" href="classRangeMap.html#09ef36a75655f2a1cbb74e60e34df930">begin()</a> to <a class="el" href="classRangeMap.html#db1c2cb143b8d68961dbaf7debbf84e5">end()</a>. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00934">934</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03768">Partitioner::build_ast()</a>.
</div>
</div><p>
<a class="anchor" name="2b3a6c7d061eee298faab8a21c33cca1"></a><!-- doxytag: member="RangeMap::size" ref="2b3a6c7d061eee298faab8a21c33cca1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::size           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of values represented by this <a class="el" href="classRangeMap.html">RangeMap</a>. 
<p>
The number of values does not typically correlate with the amount of memory used by the <a class="el" href="classRangeMap.html">RangeMap</a> since each element of the underlying std::map represents an arbitrary number of values. Note that if the range occupies the entire possible set of values then the size might be returned as zero due to overflow, and it will be necessary to call <a class="el" href="classRangeMap.html#c8b0d162d933083b16e68f519eb7f953">empty()</a> to make the determination. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00942">942</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="ExtentMap_8C-source.html#l00061">ExtentMap::allocate_at()</a>, <a class="el" href="MemoryMap_8C-source.html#l00862">MemoryMap::dump()</a>, <a class="el" href="GenericFile_8C-source.html#l01139">SgAsmGenericFile::dump()</a>, <a class="el" href="Partitioner_8C-source.html#l03525">Partitioner::is_contiguous()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00146">BinaryAnalysis::InstructionSemantics::IntervalSemantics::ValueType&lt; 16 &gt;::is_known()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00151">BinaryAnalysis::InstructionSemantics::IntervalSemantics::ValueType&lt; 16 &gt;::known_value()</a>, and <a class="el" href="AsmFunctionIndex_8h-source.html#l00169">AsmFunctionIndex::SortByBytesSize::val()</a>.
</div>
</div><p>
<a class="anchor" name="edffcf3e970c3707f06b053808dcf9ff"></a><!-- doxytag: member="RangeMap::min" ref="edffcf3e970c3707f06b053808dcf9ff" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::min           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the minimum value in an extent map. 
<p>
The extent map must not be empty. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00950">950</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="IntervalSemantics_8h-source.html#l00151">BinaryAnalysis::InstructionSemantics::IntervalSemantics::ValueType&lt; 16 &gt;::known_value()</a>, <a class="el" href="rangemap_8h-source.html#l00962">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::minmax()</a>, and <a class="el" href="Partitioner_8C-source.html#l02036">Partitioner::FindFunctionFragments::operator()()</a>.
</div>
</div><p>
<a class="anchor" name="8390dd822f35acb4657f0e833777cba3"></a><!-- doxytag: member="RangeMap::max" ref="8390dd822f35acb4657f0e833777cba3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRange.html#0110e09e84e56cb5b63bc5bde2a2a241">Range::Value</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::max           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the maximum value in an extent map. 
<p>
The extent map must not be empty. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00956">956</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l00962">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::minmax()</a>, and <a class="el" href="IntervalSemantics_8h-source.html#l00130">BinaryAnalysis::InstructionSemantics::IntervalSemantics::ValueType&lt; 16 &gt;::ValueType()</a>.
</div>
</div><p>
<a class="anchor" name="48f9bb610f4db9299f646e4068886808"></a><!-- doxytag: member="RangeMap::minmax" ref="48f9bb610f4db9299f646e4068886808" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRange.html">Range</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::minmax           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the range of values in this map. 
<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00962">962</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="aa952ec5cec6a9fce073e336109fd5f7"></a><!-- doxytag: member="RangeMap::clear" ref="aa952ec5cec6a9fce073e336109fd5f7" args="(bool notify=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::clear           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>notify</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the map. 
<p>
Removes all entries from the map. If <code>notify</code> is true then also call the removing() method of each value. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00979">979</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="MemoryMap_8C-source.html#l00556">MemoryMap::clear()</a>, and <a class="el" href="ElfStringTable_8C-source.html#l00025">SgAsmElfStringSection::parse()</a>.
</div>
</div><p>
<a class="anchor" name="a601374137845507fa80c404308ac426"></a><!-- doxytag: member="RangeMap::erase" ref="a601374137845507fa80c404308ac426" args="(const Range &amp;erase_range)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::erase           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>erase_range</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erases the specified range from this map. 
<p>
The range to remove can span multiple existing ranges and/or parts of ranges, or no ranges at all. It would be nice to be able to return an iterator to the next item since we have that in hand. Unfortunately, limitations of std::map make this impractical. If you need an iterator, just make another call to <a class="el" href="classRangeMap.html#d59ac92205fde7c48fb73e6a28ff62c3">lower_bound()</a>. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00991">991</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03080">Partitioner::adjust_padding()</a>, <a class="el" href="ExtentMap_8C-source.html#l00061">ExtentMap::allocate_at()</a>, <a class="el" href="ExtentMap_8C-source.html#l00037">ExtentMap::allocate_best_fit()</a>, <a class="el" href="ExtentMap_8C-source.html#l00049">ExtentMap::allocate_first_fit()</a>, <a class="el" href="MemoryMap_8C-source.html#l00622">MemoryMap::erase()</a>, <a class="el" href="rangemap_8h-source.html#l01051">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::erase_ranges()</a>, <a class="el" href="GenericString_8C-source.html#l00271">SgAsmGenericStrtab::free_all_strings()</a>, <a class="el" href="rangemap_8h-source.html#l01062">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::insert()</a>, <a class="el" href="Partitioner_8C-source.html#l02036">Partitioner::FindFunctionFragments::operator()()</a>, <a class="el" href="MemoryMap_8C-source.html#l00681">MemoryMap::prune()</a>, <a class="el" href="PeStringTable_8C-source.html#l00050">SgAsmPEStringSection::set_size()</a>, <a class="el" href="ElfStringTable_8C-source.html#l00064">SgAsmElfStringSection::set_size()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00336">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::unsignedExtend()</a>, and <a class="el" href="IntervalSemantics_8h-source.html#l00837">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::unsignedModulo()</a>.
</div>
</div><p>
<a class="anchor" name="00d59a4700389b0d1c2e8b66457db06b"></a><!-- doxytag: member="RangeMap::erase_ranges" ref="00d59a4700389b0d1c2e8b66457db06b" args="(const OtherMap &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
<div class="memtemplate">
template&lt;class OtherMap&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::erase_ranges           </td>
          <td>(</td>
          <td class="paramtype">const OtherMap &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase ranges from this map. 
<p>
Every range in the <code>other</code> map is erased from this map. The maps need not be the same type as long as their ranges are the same type. The values of the <code>other</code> map are not used--only its ranges. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l01051">1051</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l01998">Partitioner::find_db_starting()</a>, and <a class="el" href="Partitioner_8C-source.html#l01643">Partitioner::scan_unassigned_bytes()</a>.
</div>
</div><p>
<a class="anchor" name="df8ef8a1ea1d08b513487c6043ec0d8d"></a><!-- doxytag: member="RangeMap::insert" ref="df8ef8a1ea1d08b513487c6043ec0d8d" args="(Range new_range, Value new_value=Value(), bool make_hole=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRange.html">Range</a>&nbsp;</td>
          <td class="paramname"> <em>new_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRangeMap.html#8aa4e3a3e0446c73b2dabd85385fa17c">Value</a>&nbsp;</td>
          <td class="paramname"> <em>new_value</em> = <code><a class="el" href="classRangeMap.html#8aa4e3a3e0446c73b2dabd85385fa17c">Value</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>make_hole</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a range/value pair into the map. 
<p>
If <code>make_hole</code> is true then the new range is allowed to replace existing ranges (or parts thereof), otherwise if the new range conflicts with eixsting ranges the new extent is not inserted and no change is made to the map. If <code>merge</code> is true then we attempt to merge the new range into adjacent ranges. Returns an iterator to the new map element, or if merged, to the element that contains the new value. Returns the end iterator if the range was not inserted. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l01062">1062</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="IntervalSemantics_8h-source.html#l00421">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::add()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00546">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::concat()</a>, <a class="el" href="Partitioner_8C-source.html#l03488">Partitioner::datablock_extent()</a>, <a class="el" href="Partitioner_8C-source.html#l00191">Partitioner::discover_jump_table()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00518">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::extract()</a>, <a class="el" href="GenericFile_8C-source.html#l01261">SgAsmGenericFile::fill_holes()</a>, <a class="el" href="Partitioner_8C-source.html#l01998">Partitioner::find_db_starting()</a>, <a class="el" href="GenericString_8C-source.html#l00241">SgAsmGenericStrtab::free()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00187">BinaryAnalysis::InstructionSemantics::IntervalSemantics::ValueType&lt; 16 &gt;::from_bits()</a>, <a class="el" href="Partitioner_8C-source.html#l03392">Partitioner::function_extent()</a>, <a class="el" href="SgAsmFunction_8C-source.html#l00140">SgAsmFunction::get_extent()</a>, <a class="el" href="GenericSection_8C-source.html#l00613">SgAsmGenericSection::get_referenced_extents()</a>, <a class="el" href="PeImportDirectory_8C-source.html#l00067">SgAsmPEImportDirectory::hintname_table_extent()</a>, <a class="el" href="MemoryMap_8C-source.html#l00585">MemoryMap::insert()</a>, <a class="el" href="rangemap_8h-source.html#l01101">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::insert_ranges()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00504">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::invert()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00574">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::leastSignificantSetBit()</a>, <a class="el" href="GenericFile_8C-source.html#l00112">SgAsmGenericFile::mark_referenced_extent()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00603">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::mostSignificantSetBit()</a>, <a class="el" href="MemoryMap_8C-source.html#l00811">MemoryMap::mprotect()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00632">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::negate()</a>, <a class="el" href="Partitioner_8C-source.html#l02036">Partitioner::FindFunctionFragments::operator()()</a>, <a class="el" href="MemoryMap_8C-source.html#l00681">MemoryMap::prune()</a>, <a class="el" href="rangemap_8h-source.html#l00758">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::RangeMap()</a>, <a class="el" href="rangemap_8h-source.html#l01252">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::select_overlapping_ranges()</a>, <a class="el" href="PeStringTable_8C-source.html#l00050">SgAsmPEStringSection::set_size()</a>, <a class="el" href="ElfStringTable_8C-source.html#l00064">SgAsmElfStringSection::set_size()</a>, <a class="el" href="GenericFile_8C-source.html#l00737">SgAsmGenericFile::shift_extend()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00725">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::shiftRight()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00777">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::signExtend()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00820">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::unsignedDivide()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00856">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::unsignedMultiply()</a>, and <a class="el" href="IntervalSemantics_8h-source.html#l00105">BinaryAnalysis::InstructionSemantics::IntervalSemantics::ValueType&lt; 16 &gt;::ValueType()</a>.
</div>
</div><p>
<a class="anchor" name="297d504b27078eb077ba93d24f257637"></a><!-- doxytag: member="RangeMap::insert_ranges" ref="297d504b27078eb077ba93d24f257637" args="(const RangeMap &amp;x, bool make_hole=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::insert_ranges           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>make_hole</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert one rangemap into another. 
<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l01094">1094</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="GenericString_8C-source.html#l00241">SgAsmGenericStrtab::free()</a>, <a class="el" href="rangemap_8h-source.html#l01094">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::insert_ranges()</a>, and <a class="el" href="IntervalSemantics_8h-source.html#l00564">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::ite()</a>.
</div>
</div><p>
<a class="anchor" name="342bf072f0b42f5b807cdd07982e0219"></a><!-- doxytag: member="RangeMap::insert_ranges" ref="342bf072f0b42f5b807cdd07982e0219" args="(const_iterator start, const_iterator stop, bool make_hole=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::insert_ranges           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>make_hole</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert part of one rangemap into another. 
<p>
The ranges from <code>start</code> (inclusive) to <code>stop</code> (exclusive) are inserted into this range map. The <code>start</code> and <code>stop</code> iterators should not be iterators of this map, but some other. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l01101">1101</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="0b847d42d1de229dd4e4a6ed289c9955"></a><!-- doxytag: member="RangeMap::overlaps" ref="0b847d42d1de229dd4e4a6ed289c9955" args="(const RangeMap &amp;x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::overlaps           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if two range maps overlap. 
<p>
Returns true iff any ranges of this map overlap with any ranges of map <code>x</code>. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l01112">1112</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="7e9523a07bea9f59770d7e4db3fc1093"></a><!-- doxytag: member="RangeMap::overlaps" ref="7e9523a07bea9f59770d7e4db3fc1093" args="(const Range &amp;r) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::overlaps           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if a range map overlaps with a specified range. 
<p>
Returns true iff any part of the range <code>r</code> is present in the map. A <a class="el" href="classRangeMap.html">RangeMap</a> never overlaps with an empty range. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l01118">1118</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="b98012d738664a3a4268430dfe0c598b"></a><!-- doxytag: member="RangeMap::distinct" ref="b98012d738664a3a4268430dfe0c598b" args="(const RangeMap &amp;x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::distinct           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if two range maps are distinct. 
<p>
Returns true iff there is no range in this map that overlaps with any range of map <code>x</code>. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l01127">1127</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="cb7a2bd99750f3b48f7667d5f01fe083"></a><!-- doxytag: member="RangeMap::contains" ref="cb7a2bd99750f3b48f7667d5f01fe083" args="(Range need) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::contains           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRange.html">Range</a>&nbsp;</td>
          <td class="paramname"> <em>need</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if this range map contains all of the specified range. 
<p>
If the specified range is empty then this function returns true: the map contains all empty ranges. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l01133">1133</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03705">Partitioner::build_ast()</a>, <a class="el" href="rangemap_8h-source.html#l01154">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::contains()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00494">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::equalToZero()</a>, <a class="el" href="MemoryMap_8C-source.html#l00599">MemoryMap::exists()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00241">BinaryAnalysis::InstructionSemantics::IntervalSemantics::MemoryCell&lt; ValueType &gt;::may_alias()</a>, <a class="el" href="Partitioner_8C-source.html#l02036">Partitioner::FindFunctionFragments::operator()()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00668">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::rotateLeft()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00688">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::rotateRight()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00709">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::shiftLeft()</a>, <a class="el" href="IntervalSemantics_8h-source.html#l00725">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::shiftRight()</a>, and <a class="el" href="IntervalSemantics_8h-source.html#l00755">BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy&lt; State, ValueType &gt;::shiftRightArithmetic()</a>.
</div>
</div><p>
<a class="anchor" name="dc2f20a29d4cafd1e37871abc78bd657"></a><!-- doxytag: member="RangeMap::contains" ref="dc2f20a29d4cafd1e37871abc78bd657" args="(const RangeMap &amp;x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::contains           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determins if this range map contains all of some other range map. 
<p>
Returns true iff each range in <code>x</code> is contained in some range of this map. If <code>x</code> is empty this function returns true: a <a class="el" href="classRangeMap.html">RangeMap</a> contains all empty ranges. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l01154">1154</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="3a9c931d12bab254da6386263ab0d4ca"></a><!-- doxytag: member="RangeMap::find_overlap" ref="3a9c931d12bab254da6386263ab0d4ca" args="(const RangeMap &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::find_overlap           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the first overlap between two <a class="el" href="classRangeMap.html">RangeMap</a> objects. 
<p>
Returns an iterator for this map that points to the first range that overlaps with some range in the other map, <code>x</code>. Returns the end iterator if no overlap is found. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l01173">1173</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l01173">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::find_overlap()</a>, and <a class="el" href="rangemap_8h-source.html#l01176">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::first_overlap()</a>.
</div>
</div><p>
<a class="anchor" name="7f500bba08ce529ac3f6df75603fdded"></a><!-- doxytag: member="RangeMap::first_overlap" ref="7f500bba08ce529ac3f6df75603fdded" args="(const RangeMap &amp;x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::first_overlap           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the first overlap between two <a class="el" href="classRangeMap.html">RangeMap</a> objects. 
<p>
Returns an iterator for this map that points to the first range that overlaps with some range in the other map, <code>x</code>. Returns the end iterator if no overlap is found. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l01176">1176</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l01127">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::distinct()</a>, and <a class="el" href="rangemap_8h-source.html#l01112">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::overlaps()</a>.
</div>
</div><p>
<a class="anchor" name="c4c758a7003cbc5600237ac715c63613"></a><!-- doxytag: member="RangeMap::find_overlap" ref="c4c758a7003cbc5600237ac715c63613" args="(iterator start, iterator stop, const RangeMap &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::find_overlap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRangeMap.html#ff5cb1527b5c0906f1696aecab58c8d2">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find an overlap between two <a class="el" href="classRangeMap.html">RangeMap</a> objects. 
<p>
Returns an iterator for this map that points to the first range that overlaps with some range in the other map, <code>x</code>. The returned iterator will be between <code>start</code> (inclusive) and <code>stop</code> (exclusive), which must obviously be iterators for this <a class="el" href="classRangeMap.html">RangeMap</a>, not <code>x</code>. Returns the end iterator if there is no overlap within the restricted ranges. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l01187">1187</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="2e269c7f95bf5a14ef3f598f17c42483"></a><!-- doxytag: member="RangeMap::find_overlap" ref="2e269c7f95bf5a14ef3f598f17c42483" args="(const_iterator start, const_iterator stop, const RangeMap &amp;x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::find_overlap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find an overlap between two <a class="el" href="classRangeMap.html">RangeMap</a> objects. 
<p>
Returns an iterator for this map that points to the first range that overlaps with some range in the other map, <code>x</code>. The returned iterator will be between <code>start</code> (inclusive) and <code>stop</code> (exclusive), which must obviously be iterators for this <a class="el" href="classRangeMap.html">RangeMap</a>, not <code>x</code>. Returns the end iterator if there is no overlap within the restricted ranges. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l01202">1202</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="19f65661f7cda3080ef227a72f5833a1"></a><!-- doxytag: member="RangeMap::invert" ref="19f65661f7cda3080ef227a72f5833a1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ResultMap&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ResultMap <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::invert           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an inverse of a range map. 
<p>
The values of the result are default constructed. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l01226">1226</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="MemoryMap_8C-source.html#l00648">MemoryMap::find_free()</a>, <a class="el" href="MemoryMap_8C-source.html#l00664">MemoryMap::find_last_free()</a>, and <a class="el" href="Partitioner_8C-source.html#l01643">Partitioner::scan_unassigned_bytes()</a>.
</div>
</div><p>
<a class="anchor" name="55571866e93f2fa9a5580a3a65ddeef5"></a><!-- doxytag: member="RangeMap::invert_within" ref="55571866e93f2fa9a5580a3a65ddeef5" args="(const Range &amp;limits) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ResultMap&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ResultMap <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::invert_within           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>limits</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a range map that's the inverse of some other map. 
<p>
The returned map's ranges will be limited according to the specified <code>limits</code>. The values of the result are default constructed. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l01233">1233</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="4b6cd20712b9ff730953ccd548183f52"></a><!-- doxytag: member="RangeMap::select_overlapping_ranges" ref="4b6cd20712b9ff730953ccd548183f52" args="(const Range &amp;selector) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html">RangeMap</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::select_overlapping_ranges           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>selector</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Select ranges overlapping selector range. 
<p>
Returns a new range map whose ranges are those ranges of this map that overlap with the specified <code>selector</code> range. 
<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l01252">1252</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<a class="anchor" name="1079b01f80c8b3b4d7d8575ce49b4f99"></a><!-- doxytag: member="RangeMap::check" ref="1079b01f80c8b3b4d7d8575ce49b4f99" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::check           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l01268">1268</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l00991">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::erase()</a>, and <a class="el" href="rangemap_8h-source.html#l01062">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::insert()</a>.
</div>
</div><p>
<a class="anchor" name="9b6ea9d357802f62f6cef906f4244fd3"></a><!-- doxytag: member="RangeMap::print" ref="9b6ea9d357802f62f6cef906f4244fd3" args="(std::ostream &amp;o) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::print           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>o</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prints unformatted <a class="el" href="classRangeMap.html">RangeMap</a> on a single line. 
<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l01348">1348</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="083d5a2616f986b0c7127be058858cba"></a><!-- doxytag: member="RangeMap::operator&lt;&lt;" ref="083d5a2616f986b0c7127be058858cba" args="(std::ostream &amp;o, const RangeMap &amp;rmap)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rmap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l01358">1358</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="cfab0d67fb25a1a64304cb8c4a202c75"></a><!-- doxytag: member="RangeMap::ranges" ref="cfab0d67fb25a1a64304cb8c4a202c75" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class T = RangeMapVoid&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRangeMap.html#8159c5dc84db3157927164f3662e4430">Map</a> <a class="el" href="classRangeMap.html">RangeMap</a>&lt; R, T &gt;::<a class="el" href="classRangeMap.html#cfab0d67fb25a1a64304cb8c4a202c75">ranges</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="rangemap_8h-source.html#l00740">740</a> of file <a class="el" href="rangemap_8h-source.html">rangemap.h</a>.
<p>
Referenced by <a class="el" href="rangemap_8h-source.html#l00775">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::begin()</a>, <a class="el" href="rangemap_8h-source.html#l00979">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::clear()</a>, <a class="el" href="rangemap_8h-source.html#l00928">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::empty()</a>, <a class="el" href="rangemap_8h-source.html#l00787">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::end()</a>, <a class="el" href="rangemap_8h-source.html#l00991">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::erase()</a>, <a class="el" href="rangemap_8h-source.html#l01062">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::insert()</a>, <a class="el" href="rangemap_8h-source.html#l00842">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::lower_bound()</a>, <a class="el" href="rangemap_8h-source.html#l00956">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::max()</a>, <a class="el" href="rangemap_8h-source.html#l00950">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::min()</a>, <a class="el" href="rangemap_8h-source.html#l00934">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::nranges()</a>, <a class="el" href="rangemap_8h-source.html#l00799">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::rbegin()</a>, and <a class="el" href="rangemap_8h-source.html#l00812">RangeMap&lt; Range&lt; rose_addr_t &gt; &gt;::rend()</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="rangemap_8h-source.html">rangemap.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
