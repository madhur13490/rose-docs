<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: Partitioner::IPDParser Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="classPartitioner.html">Partitioner</a>::<a class="el" href="classPartitioner_1_1IPDParser.html">IPDParser</a></div>
<h1>Partitioner::IPDParser Class Reference</h1><!-- doxytag: class="Partitioner::IPDParser" --><code>#include &lt;<a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>&gt;</code>
<p>
Collaboration diagram for Partitioner::IPDParser:<p><center><img src="classPartitioner_1_1IPDParser__coll__graph.png" border="0" usemap="#Partitioner_1_1IPDParser__coll__map" alt="Collaboration graph"></center>
<map name="Partitioner_1_1IPDParser__coll__map">
<area href="classPartitioner.html" shape="rect" coords="663,215,745,241" alt="">
<area href="classDisassembler.html" shape="rect" coords="708,311,815,337" alt="">
<area href="classRegisterDictionary.html" shape="rect" coords="455,215,591,241" alt="">
<area href="classPartitioner_1_1Function.html" shape="rect" coords="284,215,431,241" alt="">
<area href="structRTS__mutex__t.html" shape="rect" coords="877,215,981,241" alt="">
<area href="classPartitioner_1_1CodeCriteria.html" shape="rect" coords="423,103,596,129" alt="">
<area href="classPartitioner_1_1RegionStats.html" shape="rect" coords="620,103,788,129" alt="">
<area href="classMemoryMap.html" shape="rect" coords="813,103,912,129" alt="">
<area href="classRangeMap.html" shape="rect" coords="792,7,933,33" alt="">
<area href="structPartitioner_1_1BlockConfig.html" shape="rect" coords="92,215,260,241" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classPartitioner_1_1IPDParser-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
This is the parser for the instruction partitioning data (IPD) files. 
<p>
These files are text-based descriptions of the functions and basic blocks used by the partitioner and allow the user to seed the partitioner with additional information that is not otherwise available to the partitioner.<p>
For instance, the analyst may know that a function begins at a certain virtual address but for some reason the partitioner does not discover this address in its normal mode of operation. The analyst can create an IPD file that describes the function so that the Partitioning process finds the function.<p>
An IPD file is able to: <ul>
<li>
specify an entry address of a function that is otherwise not detected. </li>
<li>
give a name to a function that doesn't have one. </li>
<li>
specify whether the function ever returns to the caller. </li>
<li>
list additional basic blocks that appear in the function. </li>
<li>
specify the address of a basic block that is otherwise not detected. </li>
<li>
indicate that a basic block is semantically equivalent to another basic block. </li>
<li>
override the control-flow successors for a basic block. </li>
</ul>
<p>
The language non-terminals are: <div class="fragment"><pre class="fragment">     File := Declaration+
     Declaration := FuncDecl | BlockDecl

     FuncDecl := 'function' Address [Name] [FuncBody]
     FuncBody := <span class="charliteral">'{'</span> FuncStmtList <span class="charliteral">'}'</span>
     FuncStmtList := FuncStmt [<span class="charliteral">';'</span> FuncStmtList]
     FuncStmt := ( Empty | BlockDecl | ReturnSpec )
     ReturnSpec := '<span class="keywordflow">return</span>' | 'returns' | 'noreturn'

     BlockDecl := 'block' Address Integer [BlockBody]
     BlockBody := <span class="charliteral">'{'</span> BlockStmtList <span class="charliteral">'}'</span>
     BlockStmtList := BlockStmt [<span class="charliteral">';'</span> BlockStmtList]
     BlockStmt := ( Empty | Alias | Successors ) <span class="charliteral">';'</span>
     Alias := 'alias' Address
     Successors := ('successor' | '<a class="code" href="classPartitioner.html#e2e3e09e5194ba8c87bc968b65b63e3c">successors</a>') [SuccessorAddrList|AssemblyCode]
     SuccessorAddrList := <span class="charliteral">'{'</span> (AddressList | AddressList '...' | '...') <span class="charliteral">'}'</span>

     AddressList := Address ( <span class="charliteral">','</span> AddressList )*
     Address: Integer
     Integer: DECIMAL_INTEGER | OCTAL_INTEGER | HEXADECIMAL_INTEGER
     Name: STRING
     AssemblyCode: <span class="keyword">asm</span> <span class="charliteral">'{'</span> ASSEMBLY <span class="charliteral">'}'</span>
</pre></div><p>
Language terminals: <div class="fragment"><pre class="fragment">     HEXADECIMAL_INTEGER: as in C, <span class="keywordflow">for</span> example: 0x08045fe2
     OCTAL_INTEGER: as in C, <span class="keywordflow">for</span> example, 0775
     DECIMAL_INTEGER: as in C, <span class="keywordflow">for</span> example, 1234
     STRING: <span class="keywordtype">double</span> quoted. Use backslash to <a class="code" href="namespaceDbg.html#30e026df9550320a5ed77068dc06d501">escape</a> embedded <span class="keywordtype">double</span> quotes
     ASSEMBLY: x86 assembly instructions (must contain balanced curly braces, <span class="keywordflow">if</span> any)
</pre></div><p>
Comments begin with a hash ('#') and continue to the end of the line. The hash character is not treated specially inside quoted strings. Comments within an ASSEMBLY terminal must conform to the syntax accepted by the Netwide <a class="el" href="classAssembler.html">Assembler</a> (nasm), namely semicolon in place of a hash.<p>
<h2>Semantics</h2>
<p>
A block declaration specifies the virtual memory address of the block's first instruction. The integer after the address specifies the number of instructions in the block. If the specified length is less than the number of instructions that <a class="el" href="namespaceROSE.html">ROSE</a> would otherwise place in the block at that address, then <a class="el" href="namespaceROSE.html">ROSE</a> will create a block of exactly the specified size. Likewise, if the specified address is midway into a block that <a class="el" href="namespaceROSE.html">ROSE</a> would otherwise create, <a class="el" href="namespaceROSE.html">ROSE</a> will create a block at the specified address anyway, causing the previous instructions to be in a separate block (or blocks). If the specified block size is larger than what <a class="el" href="namespaceROSE.html">ROSE</a> would otherwise place in the block, the block will be created with fewer instructions but the BlockBody will be ignored.<p>
A function declaration specifies the virtual memory address of the entry point of a function. The body may specify whether the function returns. As of this writing [2010-05-13] a function declared as non-returning will be marked as returning if <a class="el" href="namespaceROSE.html">ROSE</a> discovers that a basic block of the function returns.<p>
If a block declaration appears inside a function declaration, then <a class="el" href="namespaceROSE.html">ROSE</a> will assign the block to the function.<p>
The block 'alias' attribute is used to indicate that two basic blocks perform the exact same operation. The specified address is the address of the basic block to use instead of this basic block. All control-flow edges pointing to this block will be rewritten to point to the specified address instead.<p>
Example file: <div class="fragment"><pre class="fragment">     function 0x805116 <span class="stringliteral">"func11"</span> {             # declare a <span class="keyword">new</span> function named <span class="stringliteral">"func11"</span>
         returns;                             # <span class="keyword">this</span> function returns to callers
         block 0x805116 {                     # block <a class="code" href="classPartitioner_1_1IPDParser.html#54eeee743e0eeb8a16703918dcdf5f0d">at</a> 0x805116 is part of func11
             alias 0x8052116, 0x8052126       # use block 0x805116 in place of 0x8052116 and 0x8052126
         }
     }
</pre></div><p>
<h2>Basic Block Successors</h2>
<p>
A block declaration can specify control-flow successors in two ways: as a list of addresses, or as an x86 assembly language program that's interpretted by <a class="el" href="namespaceROSE.html">ROSE</a>. The benefits of using a program to determine the successors is that the program can directly extract information, such as jump tables, from the specimen executable.<p>
The assembly source code is fed to the Netwide <a class="el" href="classAssembler.html">Assembler</a>, nasm (<a href="http://www.nasm.us/">http://www.nasm.us/</a>), which assembles it into i386 machine code. When <a class="el" href="namespaceROSE.html">ROSE</a> needs to figure out the successors for a basic block it will interpret the basic block, then load the successor program and interpret it, then extract the successor list from the program's return value. <a class="el" href="namespaceROSE.html">ROSE</a> interprets the program rather than running it directly so that the program can operate on unknown, symbolic data values rather than actual 32-bit numbers.<p>
The successor program is interpretted in a context that makes it appear to have been called (via CALL instruction) from the end of the basic block being analyzed. These arguments are passed to the program:<p>
<ul>
<li>
The address of an "svec" object to be filled in by the program. The first four-byte word at this address is the number of successor addresses that immediately follow and must be a known value upon return of the program. The following values are the successors--either known values or unknown values. </li>
<li>
The size of the "svec" object in bytes. The object is allocated by <a class="el" href="namespaceROSE.html">ROSE</a> and is a fixed size (8192 bytes at the time of this writing--able to hold 2047 successors). </li>
<li>
The starting virtual address of the first instruction of the basic block. </li>
<li>
The address immediately after the last instruction of the basic block. Depending on the <a class="el" href="classPartitioner.html">Partitioner</a> settings, basic block may or may not be contiguous in memory. </li>
<li>
The value of the stack pointer at the end of the basic block. <a class="el" href="namespaceROSE.html">ROSE</a> creates a new stack before starting the successor program because the basic block's stack might not be at a known memory address. </li>
</ul>
<p>
The successor program may either fall off the end or execute a RET statement.<p>
For instance, if the 5-instruction block at virtual address 0x00c01115 ends with an indirect jump through a 256-element jump table beginning at 0x00c037fa, then a program to compute the successors might look like this:<p>
<div class="fragment"><pre class="fragment">    block 0x00c01115 5 {
      <a class="code" href="classPartitioner.html#e2e3e09e5194ba8c87bc968b65b63e3c">successors</a> <span class="keyword">asm</span> {
          push ebp
          mov ebp, esp
          ; ecx is the base address of the <a class="code" href="classPartitioner.html#e2e3e09e5194ba8c87bc968b65b63e3c">successors</a> <span class="keywordflow">return</span> vector,
          ; the first element of which is the vector size.
          mov ecx, [ebp+8]
          <a class="code" href="namespacecfgUtils.html#495bbf2d6fb84a47ca0cc937068ab793">add</a> ecx, 4
          ; loop over the entries in the jump table, copying each
          ; address from the jump table to the svec <span class="keywordflow">return</span> value
          xor eax, eax
        loop:
          cmp eax, 256
          je done
          mov ebx, [0x00c037fa+eax*4]
          mov [ecx+eax*4], ebx
          inc eax
          jmp loop
        done:
          ; set the number of entries in the svec
          mov ecx, [ebp+8]
          mov DWORD [ecx], 256
          mov esp, ebp
          pop ebp
          ret
</pre></div><p>
<h2>Example Programmatic Usage</h2>
<p>
The easiest way to parse an IPD file is to read it into memory and then call the <a class="el" href="classPartitioner_1_1IPDParser.html#1d661c8f5c82fc44994c029f99ec3e98">parse()</a> method. The following code demonstrates the use of mmap to read the file into memory, parse it, and release it from memory. For simplicity, we do not check for errors in this example. <div class="fragment"><pre class="fragment">    <a class="code" href="classPartitioner.html">Partitioner</a> p;
    <span class="keywordtype">int</span> fd = open(<span class="stringliteral">"test.ipd"</span>, O_RDONLY);
    <span class="keyword">struct </span>stat sb;
    fstat(fd, &amp;sb);
    <span class="keyword">const</span> <span class="keywordtype">char</span> *content = (<span class="keywordtype">char</span>*)mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
    <a class="code" href="classPartitioner_1_1IPDParser.html">Partitioner::IPDParser</a>(p, content, sb.st_size).parse();
    munmap(content, sb.st_size);
</pre></div> 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01716">1716</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#39c5a87225d5ed405f2c4a66bc4de867">IPDParser</a> (<a class="el" href="classPartitioner.html">Partitioner</a> *p, const char *<a class="el" href="classPartitioner_1_1IPDParser.html#15a2d4db13147114192c939159020be4">input</a>, size_t <a class="el" href="classPartitioner_1_1IPDParser.html#bbac81ec3315c410bc06e8cc5c31688c">len</a>, const std::string &amp;<a class="el" href="classPartitioner_1_1IPDParser.html#1aeda08e05b72a1646ce308dde982d2e">input_name</a>=&quot;&quot;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#1d661c8f5c82fc44994c029f99ec3e98">parse</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Top-level parsing function.  <a href="#1d661c8f5c82fc44994c029f99ec3e98"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#dedeb62201011bf3d1600395f1a77523">unparse</a> (std::ostream &amp;, <a class="el" href="classSgNode.html">SgNode</a> *ast)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unparse an AST into an IPD file.  <a href="#dedeb62201011bf3d1600395f1a77523"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#c6e9156a22344f55b6043263a2c6f4c0">skip_space</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#6067047be4995e5648e664153ba2a716">is_terminal</a> (const char *to_match)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#cf018ae26ea85a39874057c65553e8d7">is_symbol</a> (const char *to_match)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#82566e411dd77fbb8deed8e6683b65fd">is_string</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#0a8eee5177cde51605991acd2a25f7a8">is_number</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#d36f560a0bb6e2a1b62156e42b41a1b8">match_terminal</a> (const char *to_match)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#90c808a4a45ce8e3810e38f44a54fb57">match_symbol</a> (const char *to_match)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#a8d1f9b9f21661022da0edf7cca5f532">match_symbol</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#cb3304c485e85d36a88a39b5468f5dcb">match_string</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#9c6a600f418e3dfa31272d113be98cba">match_number</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#08ce3f66f3e41000bfa4303c296eb89e">match_asm</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#36aebcd5b28f88c05f6849c6cec4df8d">parse_File</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#ae820d60f7ceee84c6d9fa466a4a3dd4">parse_Declaration</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#a3dfd42b173868dbf21d872ec7786ce1">parse_FuncDecl</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#fd03783fedd95da0676aeafce57c6943">parse_FuncBody</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#9e9ba73853321ef80061e8f62e196bf2">parse_FuncStmtList</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#241e5abe3389926ce78d35aa54b4be1a">parse_FuncStmt</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#e256eb959adee7db2bb74e67eb247005">parse_ReturnSpec</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#987b76c4cc410fa6dc76ebfa0baf9ba2">parse_BlockDecl</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#1df26558e5163d87a9f720a8c125df52">parse_BlockBody</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#ab1a7b54bef9cc941d892f8beff1e1f6">parse_BlockStmtList</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#ff7d41a52e0b26c097ba84b0d1ae9275">parse_BlockStmt</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#b4fe56b04c647807bcd715cd7bfb94de">parse_Alias</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#0590dc0a4b50dae95d10eeb295695d84">parse_Successors</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPartitioner.html">Partitioner</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#51f92296196be6d6c2d3ef1515f870dd">partitioner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classPartitioner.html">Partitioner</a> to be initialized.  <a href="#51f92296196be6d6c2d3ef1515f870dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#15a2d4db13147114192c939159020be4">input</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Input to be parsed.  <a href="#15a2d4db13147114192c939159020be4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#bbac81ec3315c410bc06e8cc5c31688c">len</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Length of input, not counting NUL termination (if any).  <a href="#bbac81ec3315c410bc06e8cc5c31688c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#1aeda08e05b72a1646ce308dde982d2e">input_name</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optional name of input (usually a file name).  <a href="#1aeda08e05b72a1646ce308dde982d2e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#54eeee743e0eeb8a16703918dcdf5f0d">at</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Current parse position w.r.t.  <a href="#54eeee743e0eeb8a16703918dcdf5f0d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPartitioner_1_1Function.html">Function</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#c5a37a339ea4e1ded645e5b2df437832">cur_func</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Non-null when inside a FuncBody nonterminal.  <a href="#c5a37a339ea4e1ded645e5b2df437832"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structPartitioner_1_1BlockConfig.html">BlockConfig</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html#db53b0b7475e5c86c347329f52364432">cur_block</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Non-null when inside a BlockBody nonterminal.  <a href="#db53b0b7475e5c86c347329f52364432"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser_1_1Exception.html">Exception</a></td></tr>

</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="39c5a87225d5ed405f2c4a66bc4de867"></a><!-- doxytag: member="Partitioner::IPDParser::IPDParser" ref="39c5a87225d5ed405f2c4a66bc4de867" args="(Partitioner *p, const char *input, size_t len, const std::string &amp;input_name=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Partitioner::IPDParser::IPDParser           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner.html">Partitioner</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>input_name</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01727">1727</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="1d661c8f5c82fc44994c029f99ec3e98"></a><!-- doxytag: member="Partitioner::IPDParser::parse" ref="1d661c8f5c82fc44994c029f99ec3e98" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::IPDParser::parse           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Top-level parsing function. 
<p>

</div>
</div><p>
<a class="anchor" name="dedeb62201011bf3d1600395f1a77523"></a><!-- doxytag: member="Partitioner::IPDParser::unparse" ref="dedeb62201011bf3d1600395f1a77523" args="(std::ostream &amp;, SgNode *ast)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Partitioner::IPDParser::unparse           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>ast</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unparse an AST into an IPD file. 
<p>

</div>
</div><p>
<a class="anchor" name="c6e9156a22344f55b6043263a2c6f4c0"></a><!-- doxytag: member="Partitioner::IPDParser::skip_space" ref="c6e9156a22344f55b6043263a2c6f4c0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::IPDParser::skip_space           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6067047be4995e5648e664153ba2a716"></a><!-- doxytag: member="Partitioner::IPDParser::is_terminal" ref="6067047be4995e5648e664153ba2a716" args="(const char *to_match)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Partitioner::IPDParser::is_terminal           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>to_match</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="cf018ae26ea85a39874057c65553e8d7"></a><!-- doxytag: member="Partitioner::IPDParser::is_symbol" ref="cf018ae26ea85a39874057c65553e8d7" args="(const char *to_match)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Partitioner::IPDParser::is_symbol           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>to_match</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="82566e411dd77fbb8deed8e6683b65fd"></a><!-- doxytag: member="Partitioner::IPDParser::is_string" ref="82566e411dd77fbb8deed8e6683b65fd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Partitioner::IPDParser::is_string           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0a8eee5177cde51605991acd2a25f7a8"></a><!-- doxytag: member="Partitioner::IPDParser::is_number" ref="0a8eee5177cde51605991acd2a25f7a8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Partitioner::IPDParser::is_number           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="d36f560a0bb6e2a1b62156e42b41a1b8"></a><!-- doxytag: member="Partitioner::IPDParser::match_terminal" ref="d36f560a0bb6e2a1b62156e42b41a1b8" args="(const char *to_match)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::IPDParser::match_terminal           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>to_match</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="90c808a4a45ce8e3810e38f44a54fb57"></a><!-- doxytag: member="Partitioner::IPDParser::match_symbol" ref="90c808a4a45ce8e3810e38f44a54fb57" args="(const char *to_match)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::IPDParser::match_symbol           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>to_match</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a8d1f9b9f21661022da0edf7cca5f532"></a><!-- doxytag: member="Partitioner::IPDParser::match_symbol" ref="a8d1f9b9f21661022da0edf7cca5f532" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Partitioner::IPDParser::match_symbol           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="cb3304c485e85d36a88a39b5468f5dcb"></a><!-- doxytag: member="Partitioner::IPDParser::match_string" ref="cb3304c485e85d36a88a39b5468f5dcb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Partitioner::IPDParser::match_string           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="9c6a600f418e3dfa31272d113be98cba"></a><!-- doxytag: member="Partitioner::IPDParser::match_number" ref="9c6a600f418e3dfa31272d113be98cba" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> Partitioner::IPDParser::match_number           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="08ce3f66f3e41000bfa4303c296eb89e"></a><!-- doxytag: member="Partitioner::IPDParser::match_asm" ref="08ce3f66f3e41000bfa4303c296eb89e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Partitioner::IPDParser::match_asm           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="36aebcd5b28f88c05f6849c6cec4df8d"></a><!-- doxytag: member="Partitioner::IPDParser::parse_File" ref="36aebcd5b28f88c05f6849c6cec4df8d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Partitioner::IPDParser::parse_File           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ae820d60f7ceee84c6d9fa466a4a3dd4"></a><!-- doxytag: member="Partitioner::IPDParser::parse_Declaration" ref="ae820d60f7ceee84c6d9fa466a4a3dd4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Partitioner::IPDParser::parse_Declaration           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a3dfd42b173868dbf21d872ec7786ce1"></a><!-- doxytag: member="Partitioner::IPDParser::parse_FuncDecl" ref="a3dfd42b173868dbf21d872ec7786ce1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Partitioner::IPDParser::parse_FuncDecl           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="fd03783fedd95da0676aeafce57c6943"></a><!-- doxytag: member="Partitioner::IPDParser::parse_FuncBody" ref="fd03783fedd95da0676aeafce57c6943" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Partitioner::IPDParser::parse_FuncBody           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="9e9ba73853321ef80061e8f62e196bf2"></a><!-- doxytag: member="Partitioner::IPDParser::parse_FuncStmtList" ref="9e9ba73853321ef80061e8f62e196bf2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Partitioner::IPDParser::parse_FuncStmtList           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="241e5abe3389926ce78d35aa54b4be1a"></a><!-- doxytag: member="Partitioner::IPDParser::parse_FuncStmt" ref="241e5abe3389926ce78d35aa54b4be1a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Partitioner::IPDParser::parse_FuncStmt           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e256eb959adee7db2bb74e67eb247005"></a><!-- doxytag: member="Partitioner::IPDParser::parse_ReturnSpec" ref="e256eb959adee7db2bb74e67eb247005" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Partitioner::IPDParser::parse_ReturnSpec           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="987b76c4cc410fa6dc76ebfa0baf9ba2"></a><!-- doxytag: member="Partitioner::IPDParser::parse_BlockDecl" ref="987b76c4cc410fa6dc76ebfa0baf9ba2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Partitioner::IPDParser::parse_BlockDecl           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1df26558e5163d87a9f720a8c125df52"></a><!-- doxytag: member="Partitioner::IPDParser::parse_BlockBody" ref="1df26558e5163d87a9f720a8c125df52" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Partitioner::IPDParser::parse_BlockBody           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ab1a7b54bef9cc941d892f8beff1e1f6"></a><!-- doxytag: member="Partitioner::IPDParser::parse_BlockStmtList" ref="ab1a7b54bef9cc941d892f8beff1e1f6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Partitioner::IPDParser::parse_BlockStmtList           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ff7d41a52e0b26c097ba84b0d1ae9275"></a><!-- doxytag: member="Partitioner::IPDParser::parse_BlockStmt" ref="ff7d41a52e0b26c097ba84b0d1ae9275" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Partitioner::IPDParser::parse_BlockStmt           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b4fe56b04c647807bcd715cd7bfb94de"></a><!-- doxytag: member="Partitioner::IPDParser::parse_Alias" ref="b4fe56b04c647807bcd715cd7bfb94de" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Partitioner::IPDParser::parse_Alias           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0590dc0a4b50dae95d10eeb295695d84"></a><!-- doxytag: member="Partitioner::IPDParser::parse_Successors" ref="0590dc0a4b50dae95d10eeb295695d84" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Partitioner::IPDParser::parse_Successors           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="51f92296196be6d6c2d3ef1515f870dd"></a><!-- doxytag: member="Partitioner::IPDParser::partitioner" ref="51f92296196be6d6c2d3ef1515f870dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPartitioner.html">Partitioner</a>* <a class="el" href="classPartitioner_1_1IPDParser.html#51f92296196be6d6c2d3ef1515f870dd">Partitioner::IPDParser::partitioner</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classPartitioner.html">Partitioner</a> to be initialized. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01718">1718</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
</div>
</div><p>
<a class="anchor" name="15a2d4db13147114192c939159020be4"></a><!-- doxytag: member="Partitioner::IPDParser::input" ref="15a2d4db13147114192c939159020be4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="classPartitioner_1_1IPDParser.html#15a2d4db13147114192c939159020be4">Partitioner::IPDParser::input</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Input to be parsed. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01719">1719</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
</div>
</div><p>
<a class="anchor" name="bbac81ec3315c410bc06e8cc5c31688c"></a><!-- doxytag: member="Partitioner::IPDParser::len" ref="bbac81ec3315c410bc06e8cc5c31688c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classPartitioner_1_1IPDParser.html#bbac81ec3315c410bc06e8cc5c31688c">Partitioner::IPDParser::len</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Length of input, not counting NUL termination (if any). 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01720">1720</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
</div>
</div><p>
<a class="anchor" name="1aeda08e05b72a1646ce308dde982d2e"></a><!-- doxytag: member="Partitioner::IPDParser::input_name" ref="1aeda08e05b72a1646ce308dde982d2e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classPartitioner_1_1IPDParser.html#1aeda08e05b72a1646ce308dde982d2e">Partitioner::IPDParser::input_name</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Optional name of input (usually a file name). 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01721">1721</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
</div>
</div><p>
<a class="anchor" name="54eeee743e0eeb8a16703918dcdf5f0d"></a><!-- doxytag: member="Partitioner::IPDParser::at" ref="54eeee743e0eeb8a16703918dcdf5f0d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classPartitioner_1_1IPDParser.html#54eeee743e0eeb8a16703918dcdf5f0d">Partitioner::IPDParser::at</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Current parse position w.r.t. 
<p>
"input". 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01722">1722</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
</div>
</div><p>
<a class="anchor" name="c5a37a339ea4e1ded645e5b2df437832"></a><!-- doxytag: member="Partitioner::IPDParser::cur_func" ref="c5a37a339ea4e1ded645e5b2df437832" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPartitioner_1_1Function.html">Function</a>* <a class="el" href="classPartitioner_1_1IPDParser.html#c5a37a339ea4e1ded645e5b2df437832">Partitioner::IPDParser::cur_func</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Non-null when inside a FuncBody nonterminal. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01723">1723</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
</div>
</div><p>
<a class="anchor" name="db53b0b7475e5c86c347329f52364432"></a><!-- doxytag: member="Partitioner::IPDParser::cur_block" ref="db53b0b7475e5c86c347329f52364432" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPartitioner_1_1BlockConfig.html">BlockConfig</a>* <a class="el" href="classPartitioner_1_1IPDParser.html#db53b0b7475e5c86c347329f52364432">Partitioner::IPDParser::cur_block</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Non-null when inside a BlockBody nonterminal. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01724">1724</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Partitioner_8h-source.html">Partitioner.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
