<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: Member List</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>affineInequality Member List</h1>This is the complete list of members for <a class="el" href="classaffineInequality.html">affineInequality</a>, including all inherited members.<p><table>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#d3add790137df2e6d70f7f049b67b13d">a</a></td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td><code> [protected]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#499f10bc37721e01345d57c40d27bf77">affineInequality</a>()</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#fb8abef667bf18cf386ac3b4ac84cfb5">affineInequality</a>(const affineInequality &amp;that)</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#362826bf3a15a5a2480be698f09a7f0d">affineInequality</a>(int a, int b, int c, bool xZero, bool yZero, signs xSign, signs ySign)</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#99b5bd82e740c40e66cfb239b6e538a2">affineInequality</a>(const affineInequality &amp;xz, const affineInequality &amp;zy)</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#f78c056dd6185e6c4ad574c826db915d">b</a></td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td><code> [protected]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#1dce7118c31ac587bf616056dec06cad">bottom</a></td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td><code> [static]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#bda6046bf5a05665a5e38d8e9d75f56c">c</a></td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td><code> [protected]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#001b7122cd434f554ec1d1fb6f8f4465">constrKnown</a></td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td><code> [static]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#55888d879e043626426bc0847531610ad4b628a97aed14376e8ef677783c4c4a">eqZero</a> enum value</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#7e3b13dddf4a09a5db03be4964c0b681">getA</a>() const </td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#556057f3ade39112c1efb135fe2b5659">getB</a>() const </td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#ee4326b27337996959fedba00ad6bf25">getC</a>() const </td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#5052c641f75f1650f73df1d1cfa32ce8">getLevel</a>() const </td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#086b2b58268d73c45edb60f44f959f9e">getXSign</a>() const </td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#1e7f2e01904c00069db1e12f81124c94">getYSign</a>() const </td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#a844b970626326519487486426c4f8bf">intersectUpd</a>(const affineInequality &amp;that)</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#a82bec5c394d0edbed4ba802b3176515">isXZero</a>() const </td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#e635dfa35ce321c10f3c54d71d0d3e03">isYZero</a>() const </td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#b80382a5d131f87c05493651221d50e2">level</a></td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td><code> [protected]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#2d66ba33fa8b3aa648d224a6611cb31a">mayConsistent</a>(const affineInequality &amp;constrXY, const affineInequality &amp;constrYX)</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td><code> [static]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#55888d879e043626426bc0847531610ad6cfaa73834155d61664d3ca9b111cd3">negZero</a> enum value</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#9388c3f66ecdf6a0a72137a18d84c60f">normalize</a>()</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td><code> [protected]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#d659dd96e08292c9feaf466fe2a0f71b">operator *=</a>(const affineInequality &amp;that)</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#c56ef30c40a2234fce6697bcb869e2ea">operator!=</a>(const affineInequality &amp;that) const </td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#6dc984ea36d76558d7e42716178cbbd8">operator+=</a>(const affineInequality &amp;that)</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#2eba60a177ab764657825944b30c5146">operator&lt;</a>(const affineInequality &amp;that) const </td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#8d33a8f8366055b927d27c47eae0e80c">operator=</a>(const affineInequality &amp;that)</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#6e2727b2939b8c18e786d4236b3670be">operator==</a>(const affineInequality &amp;that) const </td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#55888d879e043626426bc0847531610ad8ca96f5566335e5104446216cd6b9bd">posZero</a> enum value</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#8f6715f54b05a5df98b44095a2f076cd">semLessThan</a>(const affineInequality &amp;that, bool xEqZero, bool yEqZero) const </td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#b02549cf43cd51aacf421cf657c6ad62">semLessThan</a>(const affineInequality &amp;that, const affineInequality *xZero, const affineInequality *zeroX, const affineInequality *yZero, const affineInequality *zeroY, std::string indent=&quot;&quot;) const </td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#3b8bdb33454773765f00c55f51073dcb">semLessThanEq</a>(const affineInequality &amp;that, bool xIsZeroVar, const affineInequality *xZero, const affineInequality *zeroX, bool yIsZeroVar, const affineInequality *yZero, const affineInequality *zeroY, std::string indent=&quot;&quot;) const </td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#25a6771a1d343e23566f4817562a9f43">semLessThanNeg</a>(const affineInequality &amp;that, bool xEqZero, bool yEqZero) const </td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#9bebef892aaab86739041fc3e885c062">set</a>(const affineInequality &amp;that)</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#25e8a1394e30582ab02ecc0704595c52">set</a>(int a, int b, int c)</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#08a0991459691c07696fd7dda9605350">set</a>(int a, int b, int c, bool xZero, bool yZero, signs xSign, signs ySign)</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#c61dafb8306cd0331637bd053f368650">setA</a>(int a)</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#e4b617124d193951571e0c82ea96bbef">setB</a>(int b)</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#b3f2d0f63cf516d233444ad6ccf510c8">setC</a>(int c)</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#c0ac62a730dd0a69165432f53fa25d31">setToBottom</a>()</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#0d1fceaa286f624c39a29f244b3b7cde">setToTop</a>()</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#55888d879e043626426bc0847531610a">signs</a> enum name</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#494e2f81e99eee3a962cf2eca0a2ba51">signToString</a>(signs sign)</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td><code> [static]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#0051ccece9848473657ec92c630c3966">str</a>(std::string indent=&quot;&quot;)</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td><code> [virtual]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#34112e0116124f7a79a28270dc88dcc2">str</a>(std::string indent=&quot;&quot;) const </td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#c22336afeeb9c675dcfec789d6f1e287">str</a>(varID x, varID y, std::string indent=&quot;&quot;) const </td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#01e23c114fdaaff8115bdc3f6d9880d0">strNeg</a>(varID x, varID y, std::string indent) const </td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#5f2c233aa7930f81849ad3fe27942e8a">top</a></td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td><code> [static]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#4189bb9c144a38e62285af09acbce3f1">unionUpd</a>(const affineInequality &amp;that)</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#55888d879e043626426bc0847531610a87d106c32ee724687a49ff7cc61be146">unknownSgn</a> enum value</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#14ce010a440f5d721a24c62700b6dff9">varAffineInequality</a> class</td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td><code> [friend]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#84f57625fdc8601b926cb09adb5471f6">xSign</a></td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td><code> [protected]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#1ca1af10885603d70f35a2daf7046866">xZero</a></td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td><code> [protected]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#c7b4e6f97948f436f95d945a1dedf43c">ySign</a></td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td><code> [protected]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="classaffineInequality.html#40268fbf761d63b2673db1cd347f073e">yZero</a></td><td><a class="el" href="classaffineInequality.html">affineInequality</a></td><td><code> [protected]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="classprintable.html#fb70e69e4f63289016284574f4aa0375">~printable</a>()</td><td><a class="el" href="classprintable.html">printable</a></td><td><code> [inline, virtual]</code></td></tr>
</table><hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
