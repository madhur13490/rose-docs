<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: omp_lowering.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>omp_lowering.h File Reference</h1>
<p>
<code>#include &quot;astQuery.h&quot;</code><br>

<p>
Include dependency graph for omp_lowering.h:<p><center><img src="omp__lowering_8h__incl.png" border="0" usemap="#omp_lowering.h_map" alt=""></center>

<p>
This graph shows which files directly or indirectly include this file:<p><center><img src="omp__lowering_8h__dep__incl.png" border="0" usemap="#omp_lowering.hdep_map" alt=""></center>
<map name="omp_lowering.hdep_map">
<area href="sage3_8h.html" shape="rect" coords="179,81,251,108" alt="">
<area href="genericDataflowCommon_8h.html" shape="rect" coords="300,5,497,32" alt="">
<area href="partitionedAnalysis_8h.html" shape="rect" coords="548,31,700,57" alt="">
<area href="arrIndexLabeler_8h.html" shape="rect" coords="332,107,465,133" alt="">
<area href="CallGraphTraverse_8h.html" shape="rect" coords="323,157,475,184" alt="">
</map>

<p>
<a href="omp__lowering_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html">OmpSupport</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOmpSupport_1_1translationDriver.html">OmpSupport::translationDriver</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A driver to traverse AST trees and invoke individual translators for OpenMP constructs, (not in use) Postorder is preferred.  <a href="classOmpSupport_1_1translationDriver.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map&lt; const <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> *,<br>
 <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#517aeb9b0b29041f7d14636b9b643afb">OmpSupport::VariableSymbolMap_t</a></td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#bffc7f08fd77ecfd382fe54fd641dc10">OmpSupport::omp_rtl_enum</a> { <br>
&nbsp;&nbsp;<a class="el" href="namespaceOmpSupport.html#bffc7f08fd77ecfd382fe54fd641dc10f12bc592bdfb78759458c84c86b2cebf">OmpSupport::e_gomp</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceOmpSupport.html#bffc7f08fd77ecfd382fe54fd641dc10eb3a7478d9fd1eee2fc945b4eb9ac1b4">OmpSupport::e_omni</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceOmpSupport.html#bffc7f08fd77ecfd382fe54fd641dc1007cb5790e5364394b23de883fcbad67f">OmpSupport::e_last_rtl</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of target runtime libraries (not yet in use).  <a href="namespaceOmpSupport.html#bffc7f08fd77ecfd382fe54fd641dc10">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#7501a3bda788701ed37519c2e0f56a2f">OmpSupport::patchUpSharedVariables</a> (<a class="el" href="classSgFile.html">SgFile</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TODO: add a function within the <a class="el" href="namespaceOmpSupport.html">OmpSupport</a> namespace, the function should transform the AST, so all variables' data-sharing attributes are explicitied represented in the AST. <a class="el" href="namespaceROSE.html">ROSE</a> has dedicated AST nodes for OpenMP directives and the associated clauses, such as private, shared, reduction.  <a href="#7501a3bda788701ed37519c2e0f56a2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#109c3a085942e285df4d6a9b8d470f90">OmpSupport::makeDataSharingExplicit</a> (<a class="el" href="classSgFile.html">SgFile</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#949516f6dba7524ecfe19cb4bacafbe8">OmpSupport::commandLineProcessing</a> (std::vector&lt; std::string &gt; &amp;argvList)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#9ad14255713b507fc965732164024806">OmpSupport::lower_omp</a> (<a class="el" href="classSgSourceFile.html">SgSourceFile</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The top level interface to translate OpenMP directives.  <a href="#9ad14255713b507fc965732164024806"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#98e85da767f2a26695fdcd9d70c4adf3">OmpSupport::insertRTLHeaders</a> (<a class="el" href="classSgSourceFile.html">SgSourceFile</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert include "xxx.h", the interface of a runtime library to the compiler.  <a href="#98e85da767f2a26695fdcd9d70c4adf3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#404b0f71c1b780fec510bbd850fbcda1">OmpSupport::insertRTLinitAndCleanCode</a> (<a class="el" href="classSgSourceFile.html">SgSourceFile</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert runtime init and terminate routines to main() entry.  <a href="#404b0f71c1b780fec510bbd850fbcda1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#2b151fb4117c4b6b8b0e774d6c358006">OmpSupport::transOmpParallel</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate omp parallel.  <a href="#2b151fb4117c4b6b8b0e774d6c358006"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#547b91648d9a4437b6f6b410687aeda8">OmpSupport::transOmpSections</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate omp sections.  <a href="#547b91648d9a4437b6f6b410687aeda8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#e015c3c4d380f148944d2cb9f2a8a305">OmpSupport::transOmpTask</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate omp task.  <a href="#e015c3c4d380f148944d2cb9f2a8a305"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#8834de54bb3fee4a3f75e5aa7b7e60d4">OmpSupport::transOmpLoop</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate omp for or omp do loops.  <a href="#8834de54bb3fee4a3f75e5aa7b7e60d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#2d0cefae7b38c9b035dbbd2f5a417e80">OmpSupport::transOmpBarrier</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate omp barrier.  <a href="#2d0cefae7b38c9b035dbbd2f5a417e80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#dfc6ed0fb6cdc06e4b6cd3e0b50b9c0c">OmpSupport::transOmpFlush</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate omp flush.  <a href="#dfc6ed0fb6cdc06e4b6cd3e0b50b9c0c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#88cd2daf13f11b87b823d673fa512f07">OmpSupport::transOmpTaskwait</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate omp taskwait.  <a href="#88cd2daf13f11b87b823d673fa512f07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#91e377cd0e5da19d049a0d335419ba96">OmpSupport::transOmpThreadprivate</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate omp threadprivate.  <a href="#91e377cd0e5da19d049a0d335419ba96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#92d605f2c191dfe399343fd2af91d019">OmpSupport::transOmpOrdered</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate the ordered directive (not the ordered clause).  <a href="#92d605f2c191dfe399343fd2af91d019"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#2ce2fb3d01361a12fada8d678b2e1008">OmpSupport::transOmpAtomic</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate omp atomic.  <a href="#2ce2fb3d01361a12fada8d678b2e1008"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#101582626c5f4d0f5e38481522bbf1ad">OmpSupport::transOmpCritical</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate omp critical.  <a href="#101582626c5f4d0f5e38481522bbf1ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#3f911ebe755bc85aa73b25324bda24a8">OmpSupport::transOmpMaster</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate omp master.  <a href="#3f911ebe755bc85aa73b25324bda24a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#b5784dbc40c3d9f01093ae944cf5208a">OmpSupport::transOmpSingle</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate omp single.  <a href="#b5784dbc40c3d9f01093ae944cf5208a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#88e7c6a00a7f67b0e5a945611ac046e4">OmpSupport::generateOutlinedTask</a> (<a class="el" href="classSgNode.html">SgNode</a> *node, std::string &amp;wrapper_name, std::set&lt; <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> * &gt; &amp;syms, std::set&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt; &amp;readOnlyVars)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A helper function to generate implicit or explicit task for either omp parallel or omp task.  <a href="#88e7c6a00a7f67b0e5a945611ac046e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#21a3ae424b905f4dc2ba9014e82cb503">OmpSupport::transOmpVariables</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *ompStmt, <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *bb1, <a class="el" href="classSgExpression.html">SgExpression</a> *orig_loop_upper=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate OpenMP variables associated with an OpenMP pragma, such as private, firstprivate, lastprivate, reduction, etc. bb1 is the translation generated code block in which the variable handling statements will be inserted. Original loop upper bound is needed for implementing lastprivate (check if it is the last iteration).  <a href="#21a3ae424b905f4dc2ba9014e82cb503"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="Cxx__Grammar_8h.html#f5484e8d253ed1622192c3c08221ff2e">SgInitializedNamePtrList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#b29699a27a2737de726923e2f5f848e3">OmpSupport::collectAllClauseVariables</a> (<a class="el" href="classSgOmpClauseBodyStatement.html">SgOmpClauseBodyStatement</a> *clause_stmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collect all variables from OpenMP clauses associated with an omp statement: private, reduction, etc.  <a href="#b29699a27a2737de726923e2f5f848e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="Cxx__Grammar_8h.html#f5484e8d253ed1622192c3c08221ff2e">SgInitializedNamePtrList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#5b41317a22c3a1d265c8752f50bb32d2">OmpSupport::collectClauseVariables</a> (<a class="el" href="classSgOmpClauseBodyStatement.html">SgOmpClauseBodyStatement</a> *clause_stmt, const <a class="el" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a> &amp;vt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collect variables from a particular type of OpenMP clauses associated with an omp statement: private, reduction, etc.  <a href="#5b41317a22c3a1d265c8752f50bb32d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="Cxx__Grammar_8h.html#f5484e8d253ed1622192c3c08221ff2e">SgInitializedNamePtrList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#85852b5db3bf713b6f716629ea5845b4">OmpSupport::collectClauseVariables</a> (<a class="el" href="classSgOmpClauseBodyStatement.html">SgOmpClauseBodyStatement</a> *clause_stmt, const VariantVector &amp;vvt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collect variables from given types of OpenMP clauses associated with an omp statement: private, reduction, etc.  <a href="#85852b5db3bf713b6f716629ea5845b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#7864c28768da6fc35abb5067d5b6c527">OmpSupport::isInClauseVariableList</a> (<a class="el" href="classSgInitializedName.html">SgInitializedName</a> *var, <a class="el" href="classSgOmpClauseBodyStatement.html">SgOmpClauseBodyStatement</a> *clause_stmt, const <a class="el" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a> &amp;vt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a variable is in a variable list of a given clause type.  <a href="#7864c28768da6fc35abb5067d5b6c527"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#bc74ecf04230c9aa7e654b9a1fa63549">OmpSupport::isInClauseVariableList</a> (<a class="el" href="classSgInitializedName.html">SgInitializedName</a> *var, <a class="el" href="classSgOmpClauseBodyStatement.html">SgOmpClauseBodyStatement</a> *clause_stmt, const VariantVector &amp;vvt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a variable is in variable lists of given clause types.  <a href="#bc74ecf04230c9aa7e654b9a1fa63549"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#773a1ba63936deb15ad4a861bb2ded77">OmpSupport::replaceVariableReferences</a> (<a class="el" href="classSgNode.html">SgNode</a> *root, <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> *oldVar, <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> *newVar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace references to oldVar within root with references to newVar, return the number of references replaced.  <a href="#773a1ba63936deb15ad4a861bb2ded77"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#405aea41d1be782c5783c016f0fc9065">OmpSupport::replaceVariableReferences</a> (<a class="el" href="classSgNode.html">SgNode</a> *root, <a class="el" href="namespaceOmpSupport.html#517aeb9b0b29041f7d14636b9b643afb">VariableSymbolMap_t</a> varRemap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace variable references within root based on a map from old symbols to new symbols.  <a href="#405aea41d1be782c5783c016f0fc9065"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#bc9c500b7f5bbc80a49cce076a5dd3b7">OmpSupport::addClauseVariable</a> (<a class="el" href="classSgInitializedName.html">SgInitializedName</a> *var, <a class="el" href="classSgOmpClauseBodyStatement.html">SgOmpClauseBodyStatement</a> *clause_stmt, const <a class="el" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a> &amp;vt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a variable into a non-reduction clause of an OpenMP statement, create the clause transparently if it does not exist.  <a href="#bc9c500b7f5bbc80a49cce076a5dd3b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgOmpVariablesClause.html">SgOmpVariablesClause</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#ad8cd703d8cc0a5b53db5780ed35f775">OmpSupport::buildOmpVariableClause</a> (<a class="el" href="classSgOmpClauseBodyStatement.html">SgOmpClauseBodyStatement</a> *clause_stmt, const <a class="el" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a> &amp;vt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build a non-reduction variable clause for a given OpenMP directive. It directly returns the clause if the clause already exists.  <a href="#ad8cd703d8cc0a5b53db5780ed35f775"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#ecb7b3d9665847d1965d6b4c802272fd">OmpSupport::hasClause</a> (<a class="el" href="classSgOmpClauseBodyStatement.html">SgOmpClauseBodyStatement</a> *clause_stmt, const <a class="el" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a> &amp;vt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if an OpenMP statement has a clause of type vt.  <a href="#ecb7b3d9665847d1965d6b4c802272fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Rose_STL_Container&lt; <a class="el" href="classSgOmpClause.html">SgOmpClause</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#81bd5309bdbf0f69a4123eab1b23a796">OmpSupport::getClause</a> (<a class="el" href="classSgOmpClauseBodyStatement.html">SgOmpClauseBodyStatement</a> *clause_stmt, const <a class="el" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a> &amp;vt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get OpenMP clauses from an eligible OpenMP statement.  <a href="#81bd5309bdbf0f69a4123eab1b23a796"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#41e7dc6dc02ac38664033c6e3aba2d79">OmpSupport::useStaticSchedule</a> (<a class="el" href="classSgOmpClauseBodyStatement.html">SgOmpClauseBodyStatement</a> *omp_loop)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if an omp for/do loop use static schedule or not, including: default schedule, or schedule(static[,chunk_size]).  <a href="#41e7dc6dc02ac38664033c6e3aba2d79"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgOmpClause.html#c6be2cac5a261bcec8176fdedd62fb4e">SgOmpClause::omp_reduction_operator_enum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#04fdba2c69e22050d32513b9193d6f9f">OmpSupport::getReductionOperationType</a> (<a class="el" href="classSgInitializedName.html">SgInitializedName</a> *init_name, <a class="el" href="classSgOmpClauseBodyStatement.html">SgOmpClauseBodyStatement</a> *clause_stmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a reduction variable's reduction operation type.  <a href="#04fdba2c69e22050d32513b9193d6f9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#9aec69da3b6b51fd8e295a2d4c8606a1">OmpSupport::createInitialValueExp</a> (<a class="el" href="classSgOmpClause.html#c6be2cac5a261bcec8176fdedd62fb4e">SgOmpClause::omp_reduction_operator_enum</a> r_operator)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an initial value according to reduction operator type.  <a href="#9aec69da3b6b51fd8e295a2d4c8606a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#0f0aaed5159e4b93cb3707c542109d3f">OmpSupport::generateGOMPLoopStartFuncName</a> (bool isOrdered, <a class="el" href="classSgOmpClause.html#785f813fa12ef0ef54b11396d0b1c55d">SgOmpClause::omp_schedule_kind_enum</a> s_kind)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate GOMP loop schedule start function's name.  <a href="#0f0aaed5159e4b93cb3707c542109d3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#f936625c3e547a0b41be89e85974ac67">OmpSupport::generateGOMPLoopNextFuncName</a> (bool isOrdered, <a class="el" href="classSgOmpClause.html#785f813fa12ef0ef54b11396d0b1c55d">SgOmpClause::omp_schedule_kind_enum</a> s_kind)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate GOMP loop schedule next function's name.  <a href="#f936625c3e547a0b41be89e85974ac67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#83110275fc92ee90cbeda43b0906cb30">OmpSupport::toString</a> (<a class="el" href="classSgOmpClause.html#785f813fa12ef0ef54b11396d0b1c55d">SgOmpClause::omp_schedule_kind_enum</a> s_kind)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a schedule kind enum value to a small case string.  <a href="#83110275fc92ee90cbeda43b0906cb30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#6c6aa01c618b4f1e3f48f52b0f064fc2">OmpSupport::patchUpPrivateVariables</a> (<a class="el" href="classSgFile.html">SgFile</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Patch up private variables for omp for. The reason is that loop indices should be private by default and this function will make this explicit.  <a href="#6c6aa01c618b4f1e3f48f52b0f064fc2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#237ad2378fc46979d00850193ae1b767">OmpSupport::patchUpFirstprivateVariables</a> (<a class="el" href="classSgFile.html">SgFile</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Patch up firstprivate variables for omp task. The reason is that the specification 3.0 defines rules for implicitly determined data-sharing attributes and this function will make the firstprivate variable of omp task explicit.  <a href="#237ad2378fc46979d00850193ae1b767"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::set&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#843697fdaa86dcaf061a566a899ff399">OmpSupport::collectThreadprivateVariables</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collect threadprivate variables within the current project, return a set to avoid duplicated elements. No input parameters are needed since it finds match from memory pools.  <a href="#843697fdaa86dcaf061a566a899ff399"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#11f6c2558c6097ef8159e589b1c87970">OmpSupport::buildAndInsertDeclarationForOmp</a> (const std::string &amp;name, <a class="el" href="classSgType.html">SgType</a> *type, <a class="el" href="classSgInitializer.html">SgInitializer</a> *varInit, <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *orig_scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special handling when trying to build and insert a variable declaration into a BB within Fortran OpenMP code.  <a href="#11f6c2558c6097ef8159e589b1c87970"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#4c8e542fd545455f79d186bc3fb0107d">OmpSupport::getEnclosingRegionOrFuncDefinition</a> (<a class="el" href="classSgNode.html">SgNode</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find an enclosing parallel region or function definition's body.  <a href="#4c8e542fd545455f79d186bc3fb0107d"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#f8e89533a4c04bd31d7393781274f68e">OmpSupport::nCounter</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOmpSupport.html#bffc7f08fd77ecfd382fe54fd641dc10">omp_rtl_enum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOmpSupport.html#43438c01722b3b4802ce8d082a636759">OmpSupport::rtl_type</a></td></tr>

</table>
<hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
