<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: ssa_unfiltered_cfg::SSA_UnfilteredCfg Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespacessa__unfiltered__cfg.html">ssa_unfiltered_cfg</a>::<a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html">SSA_UnfilteredCfg</a></div>
<h1>ssa_unfiltered_cfg::SSA_UnfilteredCfg Class Reference</h1><!-- doxytag: class="ssa_unfiltered_cfg::SSA_UnfilteredCfg" --><code>#include &lt;<a class="el" href="ssaUnfilteredCfg_8h-source.html">ssaUnfilteredCfg.h</a>&gt;</code>
<p>
Collaboration diagram for ssa_unfiltered_cfg::SSA_UnfilteredCfg:<p><center><img src="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg__coll__graph.png" border="0" usemap="#ssa__unfiltered__cfg_1_1SSA__UnfilteredCfg__coll__map" alt="Collaboration graph"></center>
<map name="ssa__unfiltered__cfg_1_1SSA__UnfilteredCfg__coll__map">
<area href="classSgProject.html" shape="rect" coords="299,369,379,396" alt="">
<area href="classSgSupport.html" shape="rect" coords="296,92,381,119" alt="">
<area href="classSgFileList.html" shape="rect" coords="224,188,301,215" alt="">
<area href="classSgDirectoryList.html" shape="rect" coords="376,188,493,215" alt="">
<area href="classSgNode.html" shape="rect" coords="304,9,373,36" alt="">
<area href="classAstAttributeMechanism.html" shape="rect" coords="5,92,171,119" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Static single assignment analysis. This analysis attaches uses an definitions to unfiltered CFG nodes rather than to AST nodes; as such its interfaces are more intuitive and easier to use. It also resolves some ambiguity issues when attaching definitions to AST nodes.<p>
Known bugs: <ul>
<li>
Bodies of catch statements are not analyzed. This is a shortcoming of the <a class="el" href="namespaceROSE.html">ROSE</a> virtual CFG, because these bodies do not appear in the virtual CFG.  </li>
<li>
Variables used to define the dimensions inside an array declaration are not detected as uses. This is because the SgVarRef nodes for these variables are not visited by AST traversals. <p>
</li>
<li>
Operands of the sizeof operator are considered uses, and they should not be (relatively easy fix).  </li>
</ul>

<p>

<p>
Definition at line <a class="el" href="ssaUnfilteredCfg_8h-source.html#l00059">59</a> of file <a class="el" href="ssaUnfilteredCfg_8h-source.html">ssaUnfilteredCfg.h</a>.<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::vector&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A compound variable name as used by the variable renaming.  <a href="#fb9b5df31f254b0786f41d48f7862cf8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef boost::shared_ptr&lt;<br>
 <a class="el" href="classssa__unfiltered__cfg_1_1ReachingDef.html">ReachingDef</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#a442d38c42255e2ec0b5668b064c1126">ReachingDefPtr</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map&lt; <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a>,<br>
 <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#a442d38c42255e2ec0b5668b064c1126">ReachingDefPtr</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#66befa7dbaa0b1d0ab3969705281305b">NodeReachingDefTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A map from each variable to its reaching definitions at the current node.  <a href="#66befa7dbaa0b1d0ab3969705281305b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map&lt; CFGNode,<br>
 std::set&lt; <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#d39ef8031236ae3337571ab05680e6a7">CFGNodeToVarNamesMap</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map&lt; <a class="el" href="classSgNode.html">SgNode</a> *,<br>
 std::set&lt; <a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> * &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#199b6f6a653b2408bdb5280228a5ca07">ASTNodeToVarRefsMap</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map&lt; CFGNode,<br>
 <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#66befa7dbaa0b1d0ab3969705281305b">NodeReachingDefTable</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#4f0afc4eae0f862611c63ac851b42832">CFGNodeToDefTableMap</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#bd1a9d5d810a061a7da753b2ea226bdf">SSA_UnfilteredCfg</a> (<a class="el" href="classSgProject.html">SgProject</a> *proj)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#8685ac6c90d7bcf4dc699995435ebb9f">~SSA_UnfilteredCfg</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#d64ffd22efebf3a8670c8ca91083a502">run</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Run the analysis.  <a href="#d64ffd22efebf3a8670c8ca91083a502"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#4479f5e94064bebcbf28f74b93c81848">toDOT</a> (const std::string fileName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the CFG with any UniqueNames and Def/Use information visible.  <a href="#4479f5e94064bebcbf28f74b93c81848"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#0e9f025184e43ba7899c8e62a7651683">toFilteredDOT</a> (const std::string fileName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the CFG with any UniqueNames and Def/Use information visible.  <a href="#0e9f025184e43ba7899c8e62a7651683"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#66befa7dbaa0b1d0ab3969705281305b">NodeReachingDefTable</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#0f02c6d9151a665fa10da92c9c4183f4">getReachingDefsBefore</a> (const CFGNode &amp;node) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the reaching definitions *before* the given node was executed.  <a href="#0f02c6d9151a665fa10da92c9c4183f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#66befa7dbaa0b1d0ab3969705281305b">NodeReachingDefTable</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#f4dac6099e4812160814cda8fe3c68e3">getReachingDefsAfter</a> (const CFGNode &amp;node) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the reaching definitions *after* the given node was executed.  <a href="#f4dac6099e4812160814cda8fe3c68e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#66befa7dbaa0b1d0ab3969705281305b">NodeReachingDefTable</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#6b7bebf759a1df5c071dcb5b3381e372">getDefsAtNode</a> (const CFGNode &amp;node) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the definitions that occur at the given node.  <a href="#6b7bebf759a1df5c071dcb5b3381e372"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#66befa7dbaa0b1d0ab3969705281305b">NodeReachingDefTable</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#edfb24cd62c5022e612d972a7c32a260">getReachingDefsBefore</a> (<a class="el" href="classSgNode.html">SgNode</a> *astNode) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the reaching definitions before the given AST node is executed.  <a href="#edfb24cd62c5022e612d972a7c32a260"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#66befa7dbaa0b1d0ab3969705281305b">NodeReachingDefTable</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#c0e5873b7f43c4545afd22ad2e9363c6">getReachingDefsAfter</a> (<a class="el" href="classSgNode.html">SgNode</a> *astNode) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the reaching definitions after the given AST node is executed.  <a href="#c0e5873b7f43c4545afd22ad2e9363c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#66befa7dbaa0b1d0ab3969705281305b">NodeReachingDefTable</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#df7b5e5740817f2449dc9bff0d9b7155">getLastVersions</a> (<a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *astNode) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the final versions of all the variables at the end of the given function.  <a href="#df7b5e5740817f2449dc9bff0d9b7155"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::set&lt; <a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> * &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#38694268a50ddfbb24e48592d2af353b">getUsesAtNode</a> (<a class="el" href="classSgNode.html">SgNode</a> *astNode) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns all the SgVarRef objects that are used in the execution of the given AST node.  <a href="#38694268a50ddfbb24e48592d2af353b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#a442d38c42255e2ec0b5668b064c1126">ReachingDefPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#c47929e5c456a3e146a574bcf26127fc">getDefinitionForUse</a> (<a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> *astNode) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a use obtained through getUsesAtNode, resolve its corresponding def.  <a href="#c47929e5c456a3e146a574bcf26127fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#199b6f6a653b2408bdb5280228a5ca07">ASTNodeToVarRefsMap</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#9d6094f65baaf020d68c683386edbc8b">getUseTable</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the entire use table, mapping each non-statement AST node to the variables used in its execution.  <a href="#9d6094f65baaf020d68c683386edbc8b"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#e875578b91cb75fcfe27af6bfbf5c4b7">getDebug</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#6cb2f1278448124e7d8063dff9935672">getDebugExtra</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#d3fddf1a43cbd73d30475c330a632ff4">isPrefixOfName</a> (<a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a> name, <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a> prefix)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find if the given prefix is a prefix of the given name.  <a href="#d3fddf1a43cbd73d30475c330a632ff4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classssa__private_1_1VarUniqueName.html">ssa_private::VarUniqueName</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#4a7d19f0f15c9383a4d5147623ffe681">getUniqueName</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the uniqueName attribute for the given node.  <a href="#4a7d19f0f15c9383a4d5147623ffe681"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#7a0c07cd702dfe1814d307bebb44e1a1">getVarName</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the variable name of the given node.  <a href="#7a0c07cd702dfe1814d307bebb44e1a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#d0e88d7ef9d3f62147d91b4e749f2d09">getVarForExpression</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If an expression evaluates to a reference of a variable, returns that variable.  <a href="#d0e88d7ef9d3f62147d91b4e749f2d09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#0165a58f0b38ab769f2bd7fe449249c8">buildVariableReference</a> (const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a> &amp;var, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an AST fragment containing the appropriate varRefs and Dot/Arrow ops to access the given variable.  <a href="#0165a58f0b38ab769f2bd7fe449249c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#91c0d89c04898a7ec1b98d59efdf84bb">varnameToString</a> (const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a> &amp;vec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a string representation of a varName.  <a href="#91c0d89c04898a7ec1b98d59efdf84bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#bc9e22bfa700442cb0079cc5a00b3db9">printNodeDefTable</a> (const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#66befa7dbaa0b1d0ab3969705281305b">NodeReachingDefTable</a> &amp;table)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#2744555e034681173370c37f2dfb3a55">printFullDefTable</a> (const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#4f0afc4eae0f862611c63ac851b42832">CFGNodeToDefTableMap</a> &amp;defTable)</td></tr>

<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#81fd0f624a4860af55d1cd8df04f6497">emptyName</a></td></tr>

<tr><td colspan="2"><br><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#8982bf7ec1998fac45117ecef750aa6e">runDefUseDataFlow</a> (<a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *func)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Once all the local definitions have been inserted in the ssaLocalDefsTable and phi functions have been inserted in the reaching defs table, propagate reaching definitions along the CFG.  <a href="#8982bf7ec1998fac45117ecef750aa6e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#9ad6fdf6a510cb3f503daa2ef8d1ee99">expandParentMemberDefinitions</a> (const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#d39ef8031236ae3337571ab05680e6a7">CFGNodeToVarNamesMap</a> &amp;defs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expand all member definitions (chained names) to define every name in the chain that is shorter than the originally defined name.  <a href="#9ad6fdf6a510cb3f503daa2ef8d1ee99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#738b03e6e43c15c92f56ab601dd946ce">insertDefsForChildMemberUses</a> (const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#d39ef8031236ae3337571ab05680e6a7">CFGNodeToVarNamesMap</a> &amp;defs, const std::set&lt; <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a> &gt; &amp;usedNames)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find all uses of compound variable names and insert expanded defs for them when their parents are defined.  <a href="#738b03e6e43c15c92f56ab601dd946ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#0684d1627f60803182f7fc532c07edd8">insertDefsForExternalVariables</a> (<a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *function, const std::set&lt; <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a> &gt; &amp;usedNames)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert defs for functions that are declared outside the function scope.  <a href="#0684d1627f60803182f7fc532c07edd8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#666e67bfc038c0ed076d2ba7bd0aae06">insertPhiFunctions</a> (<a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *function, const std::vector&lt; CFGNode &gt; &amp;cfgNodesInPostOrder)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find where phi functions need to be inserted and insert empty phi functions at those nodes.  <a href="#666e67bfc038c0ed076d2ba7bd0aae06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#3be4bd1ad167fa26e254958df7130867">renumberAllDefinitions</a> (<a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *func, const std::vector&lt; CFGNode &gt; &amp;cfgNodesInPostOrder)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Give numbers to all the reachingDef objects.  <a href="#3be4bd1ad167fa26e254958df7130867"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#443c746378a3e9661c222dc2d3bdf660">updateIncomingPropagatedDefs</a> (const CFGNode &amp;cfgNode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take all the outgoing defs from previous nodes and merge them as the incoming defs of the current node.  <a href="#443c746378a3e9661c222dc2d3bdf660"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#52bf2f354579cd0dfb76f02c8710249e">propagateDefs</a> (const CFGNode &amp;cfgNode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs the data-flow update for one individual node, populating the reachingDefsTable for that node.  <a href="#52bf2f354579cd0dfb76f02c8710249e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#7b7bea911f993b072b9456a3421e3587">printToDOT</a> (<a class="el" href="classSgNode.html">SgNode</a> *root, std::ostream &amp;outFile)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#4df05df58a2bdf66e422ff0c685914f1">printToFilteredDOT</a> (<a class="el" href="classSgSourceFile.html">SgSourceFile</a> *file, std::ofstream &amp;outFile)</td></tr>

<tr><td colspan="2"><br><h2>Static Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#1d5d0dee5efb2be77d6f09c74507190d">isBuiltinVar</a> (const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a> &amp;var)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the variable is implicitly defined at the function entry by the compiler.  <a href="#1d5d0dee5efb2be77d6f09c74507190d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static std::vector&lt; CFGNode &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#916fbe95e1000e5b069657c8b32a9d31">getCfgNodesInPostorder</a> (<a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *func)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterates all the CFG nodes in the function and returns them in postorder, according to depth-first search.  <a href="#916fbe95e1000e5b069657c8b32a9d31"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgProject.html">SgProject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#a53c0dff81b102f0566e583ab40f3e06">project</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The project to perform SSA <a class="el" href="classAnalysis.html">Analysis</a> on.  <a href="#a53c0dff81b102f0566e583ab40f3e06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#199b6f6a653b2408bdb5280228a5ca07">ASTNodeToVarRefsMap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#56895fb1eb76a5351a295de4336bd5c2">astNodeToUses</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#4f0afc4eae0f862611c63ac851b42832">CFGNodeToDefTableMap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#a985a27d3d0db3d4b2629dbbe7e5ceee">localDefTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Map from each node to all the variables defined at that node.  <a href="#a985a27d3d0db3d4b2629dbbe7e5ceee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#4f0afc4eae0f862611c63ac851b42832">CFGNodeToDefTableMap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#ccb8cd4faffe99caa24cabef690c94a4">reachingDefTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Map from each node to all the reaching definitions at that node.  <a href="#ccb8cd4faffe99caa24cabef690c94a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#4f0afc4eae0f862611c63ac851b42832">CFGNodeToDefTableMap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#7e3a148d1bd0501ffea8d5136b925283">outgoingDefTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Map from each node to the reaching definitions at the end of the node.  <a href="#7e3a148d1bd0501ffea8d5136b925283"></a><br></td></tr>
</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="fb9b5df31f254b0786f41d48f7862cf8"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::VarName" ref="fb9b5df31f254b0786f41d48f7862cf8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classSgInitializedName.html">SgInitializedName</a>*&gt; <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">ssa_unfiltered_cfg::SSA_UnfilteredCfg::VarName</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A compound variable name as used by the variable renaming. 
<p>

<p>
Definition at line <a class="el" href="ssaUnfilteredCfg_8h-source.html#l00068">68</a> of file <a class="el" href="ssaUnfilteredCfg_8h-source.html">ssaUnfilteredCfg.h</a>.
</div>
</div><p>
<a class="anchor" name="a442d38c42255e2ec0b5668b064c1126"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::ReachingDefPtr" ref="a442d38c42255e2ec0b5668b064c1126" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="classssa__unfiltered__cfg_1_1ReachingDef.html">ReachingDef</a>&gt; <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#a442d38c42255e2ec0b5668b064c1126">ssa_unfiltered_cfg::SSA_UnfilteredCfg::ReachingDefPtr</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="ssaUnfilteredCfg_8h-source.html#l00070">70</a> of file <a class="el" href="ssaUnfilteredCfg_8h-source.html">ssaUnfilteredCfg.h</a>.
</div>
</div><p>
<a class="anchor" name="66befa7dbaa0b1d0ab3969705281305b"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::NodeReachingDefTable" ref="66befa7dbaa0b1d0ab3969705281305b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a>, <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#a442d38c42255e2ec0b5668b064c1126">ReachingDefPtr</a>&gt; <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#66befa7dbaa0b1d0ab3969705281305b">ssa_unfiltered_cfg::SSA_UnfilteredCfg::NodeReachingDefTable</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A map from each variable to its reaching definitions at the current node. 
<p>

<p>
Definition at line <a class="el" href="ssaUnfilteredCfg_8h-source.html#l00073">73</a> of file <a class="el" href="ssaUnfilteredCfg_8h-source.html">ssaUnfilteredCfg.h</a>.
</div>
</div><p>
<a class="anchor" name="d39ef8031236ae3337571ab05680e6a7"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::CFGNodeToVarNamesMap" ref="d39ef8031236ae3337571ab05680e6a7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;CFGNode, std::set&lt;<a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a>&gt; &gt; <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#d39ef8031236ae3337571ab05680e6a7">ssa_unfiltered_cfg::SSA_UnfilteredCfg::CFGNodeToVarNamesMap</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="ssaUnfilteredCfg_8h-source.html#l00075">75</a> of file <a class="el" href="ssaUnfilteredCfg_8h-source.html">ssaUnfilteredCfg.h</a>.
</div>
</div><p>
<a class="anchor" name="199b6f6a653b2408bdb5280228a5ca07"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::ASTNodeToVarRefsMap" ref="199b6f6a653b2408bdb5280228a5ca07" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="classSgNode.html">SgNode</a>*, std::set&lt;<a class="el" href="classSgVarRefExp.html">SgVarRefExp</a>*&gt; &gt; <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#199b6f6a653b2408bdb5280228a5ca07">ssa_unfiltered_cfg::SSA_UnfilteredCfg::ASTNodeToVarRefsMap</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="ssaUnfilteredCfg_8h-source.html#l00077">77</a> of file <a class="el" href="ssaUnfilteredCfg_8h-source.html">ssaUnfilteredCfg.h</a>.
</div>
</div><p>
<a class="anchor" name="4f0afc4eae0f862611c63ac851b42832"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::CFGNodeToDefTableMap" ref="4f0afc4eae0f862611c63ac851b42832" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;CFGNode, <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#66befa7dbaa0b1d0ab3969705281305b">NodeReachingDefTable</a>&gt; <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#4f0afc4eae0f862611c63ac851b42832">ssa_unfiltered_cfg::SSA_UnfilteredCfg::CFGNodeToDefTableMap</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="ssaUnfilteredCfg_8h-source.html#l00079">79</a> of file <a class="el" href="ssaUnfilteredCfg_8h-source.html">ssaUnfilteredCfg.h</a>.
</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="bd1a9d5d810a061a7da753b2ea226bdf"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::SSA_UnfilteredCfg" ref="bd1a9d5d810a061a7da753b2ea226bdf" args="(SgProject *proj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssa_unfiltered_cfg::SSA_UnfilteredCfg::SSA_UnfilteredCfg           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgProject.html">SgProject</a> *&nbsp;</td>
          <td class="paramname"> <em>proj</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="ssaUnfilteredCfg_8h-source.html#l00099">99</a> of file <a class="el" href="ssaUnfilteredCfg_8h-source.html">ssaUnfilteredCfg.h</a>.
</div>
</div><p>
<a class="anchor" name="8685ac6c90d7bcf4dc699995435ebb9f"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::~SSA_UnfilteredCfg" ref="8685ac6c90d7bcf4dc699995435ebb9f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssa_unfiltered_cfg::SSA_UnfilteredCfg::~SSA_UnfilteredCfg           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="ssaUnfilteredCfg_8h-source.html#l00101">101</a> of file <a class="el" href="ssaUnfilteredCfg_8h-source.html">ssaUnfilteredCfg.h</a>.
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="d64ffd22efebf3a8670c8ca91083a502"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::run" ref="d64ffd22efebf3a8670c8ca91083a502" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ssa_unfiltered_cfg::SSA_UnfilteredCfg::run           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Run the analysis. 
<p>

</div>
</div><p>
<a class="anchor" name="e875578b91cb75fcfe27af6bfbf5c4b7"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::getDebug" ref="e875578b91cb75fcfe27af6bfbf5c4b7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool ssa_unfiltered_cfg::SSA_UnfilteredCfg::getDebug           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="ssaUnfilteredCfg_8h-source.html#l00106">106</a> of file <a class="el" href="ssaUnfilteredCfg_8h-source.html">ssaUnfilteredCfg.h</a>.
<p>
References <a class="el" href="classSgProject.html#cc4f5deea195f1967735d804d21cf379">SgProject::get_verbose()</a>.
</div>
</div><p>
<a class="anchor" name="6cb2f1278448124e7d8063dff9935672"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::getDebugExtra" ref="6cb2f1278448124e7d8063dff9935672" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool ssa_unfiltered_cfg::SSA_UnfilteredCfg::getDebugExtra           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="ssaUnfilteredCfg_8h-source.html#l00111">111</a> of file <a class="el" href="ssaUnfilteredCfg_8h-source.html">ssaUnfilteredCfg.h</a>.
<p>
References <a class="el" href="classSgProject.html#cc4f5deea195f1967735d804d21cf379">SgProject::get_verbose()</a>.
</div>
</div><p>
<a class="anchor" name="8982bf7ec1998fac45117ecef750aa6e"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::runDefUseDataFlow" ref="8982bf7ec1998fac45117ecef750aa6e" args="(SgFunctionDefinition *func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ssa_unfiltered_cfg::SSA_UnfilteredCfg::runDefUseDataFlow           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Once all the local definitions have been inserted in the ssaLocalDefsTable and phi functions have been inserted in the reaching defs table, propagate reaching definitions along the CFG. 
<p>

</div>
</div><p>
<a class="anchor" name="1d5d0dee5efb2be77d6f09c74507190d"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::isBuiltinVar" ref="1d5d0dee5efb2be77d6f09c74507190d" args="(const VarName &amp;var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool ssa_unfiltered_cfg::SSA_UnfilteredCfg::isBuiltinVar           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the variable is implicitly defined at the function entry by the compiler. 
<p>

</div>
</div><p>
<a class="anchor" name="9ad6fdf6a510cb3f503daa2ef8d1ee99"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::expandParentMemberDefinitions" ref="9ad6fdf6a510cb3f503daa2ef8d1ee99" args="(const CFGNodeToVarNamesMap &amp;defs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ssa_unfiltered_cfg::SSA_UnfilteredCfg::expandParentMemberDefinitions           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#d39ef8031236ae3337571ab05680e6a7">CFGNodeToVarNamesMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>defs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Expand all member definitions (chained names) to define every name in the chain that is shorter than the originally defined name. 
<p>
When a member of a struct/class is referenced, this will insert definitions for every member referenced to access the currently referenced one.<p>
ex. Obj o; //Declare o of type Obj o.a.b = 5; //Def for o.a.b<p>
In the second line, this function will insert the following:<p>
o.a.b = 5; //Def for o.a.b, o.a, o 
</div>
</div><p>
<a class="anchor" name="738b03e6e43c15c92f56ab601dd946ce"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::insertDefsForChildMemberUses" ref="738b03e6e43c15c92f56ab601dd946ce" args="(const CFGNodeToVarNamesMap &amp;defs, const std::set&lt; VarName &gt; &amp;usedNames)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ssa_unfiltered_cfg::SSA_UnfilteredCfg::insertDefsForChildMemberUses           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#d39ef8031236ae3337571ab05680e6a7">CFGNodeToVarNamesMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>defs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>usedNames</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find all uses of compound variable names and insert expanded defs for them when their parents are defined. 
<p>
E.g. for a.x, all defs of a will have a def of a.x inserted. Note that there might be other child expansions of a, such as a.y, that we do not insert since they have no uses. 
</div>
</div><p>
<a class="anchor" name="0684d1627f60803182f7fc532c07edd8"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::insertDefsForExternalVariables" ref="0684d1627f60803182f7fc532c07edd8" args="(SgFunctionDefinition *function, const std::set&lt; VarName &gt; &amp;usedNames)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ssa_unfiltered_cfg::SSA_UnfilteredCfg::insertDefsForExternalVariables           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>usedNames</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert defs for functions that are declared outside the function scope. 
<p>

</div>
</div><p>
<a class="anchor" name="666e67bfc038c0ed076d2ba7bd0aae06"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::insertPhiFunctions" ref="666e67bfc038c0ed076d2ba7bd0aae06" args="(SgFunctionDefinition *function, const std::vector&lt; CFGNode &gt; &amp;cfgNodesInPostOrder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ssa_unfiltered_cfg::SSA_UnfilteredCfg::insertPhiFunctions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CFGNode &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cfgNodesInPostOrder</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find where phi functions need to be inserted and insert empty phi functions at those nodes. 
<p>
This updates the IN part of the reaching def table with Phi functions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cfgNodesInPostOrder</em>&nbsp;</td><td>all the CFG nodes of the function. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3be4bd1ad167fa26e254958df7130867"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::renumberAllDefinitions" ref="3be4bd1ad167fa26e254958df7130867" args="(SgFunctionDefinition *func, const std::vector&lt; CFGNode &gt; &amp;cfgNodesInPostOrder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ssa_unfiltered_cfg::SSA_UnfilteredCfg::renumberAllDefinitions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CFGNode &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cfgNodesInPostOrder</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Give numbers to all the reachingDef objects. 
<p>
Should be called after phi functions are inserted and the local def table is populated, but before dataflow propagates the definitions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cfgNodesInPostOrder</em>&nbsp;</td><td>a list of all the CFG nodes in the function, in postorder. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="443c746378a3e9661c222dc2d3bdf660"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::updateIncomingPropagatedDefs" ref="443c746378a3e9661c222dc2d3bdf660" args="(const CFGNode &amp;cfgNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ssa_unfiltered_cfg::SSA_UnfilteredCfg::updateIncomingPropagatedDefs           </td>
          <td>(</td>
          <td class="paramtype">const CFGNode &amp;&nbsp;</td>
          <td class="paramname"> <em>cfgNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Take all the outgoing defs from previous nodes and merge them as the incoming defs of the current node. 
<p>

</div>
</div><p>
<a class="anchor" name="52bf2f354579cd0dfb76f02c8710249e"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::propagateDefs" ref="52bf2f354579cd0dfb76f02c8710249e" args="(const CFGNode &amp;cfgNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ssa_unfiltered_cfg::SSA_UnfilteredCfg::propagateDefs           </td>
          <td>(</td>
          <td class="paramtype">const CFGNode &amp;&nbsp;</td>
          <td class="paramname"> <em>cfgNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs the data-flow update for one individual node, populating the reachingDefsTable for that node. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>true if the OUT defs from the node changed, false if they stayed the same. </dd></dl>

</div>
</div><p>
<a class="anchor" name="916fbe95e1000e5b069657c8b32a9d31"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::getCfgNodesInPostorder" ref="916fbe95e1000e5b069657c8b32a9d31" args="(SgFunctionDefinition *func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;CFGNode&gt; ssa_unfiltered_cfg::SSA_UnfilteredCfg::getCfgNodesInPostorder           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterates all the CFG nodes in the function and returns them in postorder, according to depth-first search. 
<p>
Reverse postorder is the most efficient order for dataflow propagation. 
</div>
</div><p>
<a class="anchor" name="7b7bea911f993b072b9456a3421e3587"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::printToDOT" ref="7b7bea911f993b072b9456a3421e3587" args="(SgNode *root, std::ostream &amp;outFile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ssa_unfiltered_cfg::SSA_UnfilteredCfg::printToDOT           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>outFile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4df05df58a2bdf66e422ff0c685914f1"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::printToFilteredDOT" ref="4df05df58a2bdf66e422ff0c685914f1" args="(SgSourceFile *file, std::ofstream &amp;outFile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ssa_unfiltered_cfg::SSA_UnfilteredCfg::printToFilteredDOT           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgSourceFile.html">SgSourceFile</a> *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream &amp;&nbsp;</td>
          <td class="paramname"> <em>outFile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4479f5e94064bebcbf28f74b93c81848"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::toDOT" ref="4479f5e94064bebcbf28f74b93c81848" args="(const std::string fileName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ssa_unfiltered_cfg::SSA_UnfilteredCfg::toDOT           </td>
          <td>(</td>
          <td class="paramtype">const std::string&nbsp;</td>
          <td class="paramname"> <em>fileName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print the CFG with any UniqueNames and Def/Use information visible. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fileName</em>&nbsp;</td><td>The filename to save graph as. Filenames will be prepended. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0e9f025184e43ba7899c8e62a7651683"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::toFilteredDOT" ref="0e9f025184e43ba7899c8e62a7651683" args="(const std::string fileName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ssa_unfiltered_cfg::SSA_UnfilteredCfg::toFilteredDOT           </td>
          <td>(</td>
          <td class="paramtype">const std::string&nbsp;</td>
          <td class="paramname"> <em>fileName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print the CFG with any UniqueNames and Def/Use information visible. 
<p>
This will only print the nodes that are of interest to the filter function used by the def/use traversal.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fileName</em>&nbsp;</td><td>The filename to save graph as. Filenames will be prepended. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0f02c6d9151a665fa10da92c9c4183f4"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::getReachingDefsBefore" ref="0f02c6d9151a665fa10da92c9c4183f4" args="(const CFGNode &amp;node) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#66befa7dbaa0b1d0ab3969705281305b">NodeReachingDefTable</a>&amp; ssa_unfiltered_cfg::SSA_UnfilteredCfg::getReachingDefsBefore           </td>
          <td>(</td>
          <td class="paramtype">const CFGNode &amp;&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the reaching definitions *before* the given node was executed. 
<p>

</div>
</div><p>
<a class="anchor" name="f4dac6099e4812160814cda8fe3c68e3"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::getReachingDefsAfter" ref="f4dac6099e4812160814cda8fe3c68e3" args="(const CFGNode &amp;node) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#66befa7dbaa0b1d0ab3969705281305b">NodeReachingDefTable</a>&amp; ssa_unfiltered_cfg::SSA_UnfilteredCfg::getReachingDefsAfter           </td>
          <td>(</td>
          <td class="paramtype">const CFGNode &amp;&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the reaching definitions *after* the given node was executed. 
<p>
If there are no local defs at the node (i.e. getDefsAtNode returns empty), then the reaching defs After a node are identical to the reaching defs before the node. 
</div>
</div><p>
<a class="anchor" name="6b7bebf759a1df5c071dcb5b3381e372"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::getDefsAtNode" ref="6b7bebf759a1df5c071dcb5b3381e372" args="(const CFGNode &amp;node) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#66befa7dbaa0b1d0ab3969705281305b">NodeReachingDefTable</a>&amp; ssa_unfiltered_cfg::SSA_UnfilteredCfg::getDefsAtNode           </td>
          <td>(</td>
          <td class="paramtype">const CFGNode &amp;&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the definitions that occur at the given node. 
<p>
If no definitions occur at the node, the result is empty 
</div>
</div><p>
<a class="anchor" name="edfb24cd62c5022e612d972a7c32a260"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::getReachingDefsBefore" ref="edfb24cd62c5022e612d972a7c32a260" args="(SgNode *astNode) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#66befa7dbaa0b1d0ab3969705281305b">NodeReachingDefTable</a>&amp; ssa_unfiltered_cfg::SSA_UnfilteredCfg::getReachingDefsBefore           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>astNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the reaching definitions before the given AST node is executed. 
<p>
This method is equivalent to looking up the reaching definitions before astNode-&gt;cfgForBeginning() 
</div>
</div><p>
<a class="anchor" name="c0e5873b7f43c4545afd22ad2e9363c6"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::getReachingDefsAfter" ref="c0e5873b7f43c4545afd22ad2e9363c6" args="(SgNode *astNode) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#66befa7dbaa0b1d0ab3969705281305b">NodeReachingDefTable</a>&amp; ssa_unfiltered_cfg::SSA_UnfilteredCfg::getReachingDefsAfter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>astNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the reaching definitions after the given AST node is executed. 
<p>
This method is equivalent to looking up the reaching definitions after astNode-&gt;cfgForEnd() 
</div>
</div><p>
<a class="anchor" name="df7b5e5740817f2449dc9bff0d9b7155"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::getLastVersions" ref="df7b5e5740817f2449dc9bff0d9b7155" args="(SgFunctionDefinition *astNode) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#66befa7dbaa0b1d0ab3969705281305b">NodeReachingDefTable</a>&amp; ssa_unfiltered_cfg::SSA_UnfilteredCfg::getLastVersions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *&nbsp;</td>
          <td class="paramname"> <em>astNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the final versions of all the variables at the end of the given function. 
<p>

</div>
</div><p>
<a class="anchor" name="38694268a50ddfbb24e48592d2af353b"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::getUsesAtNode" ref="38694268a50ddfbb24e48592d2af353b" args="(SgNode *astNode) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt;<a class="el" href="classSgVarRefExp.html">SgVarRefExp</a>*&gt;&amp; ssa_unfiltered_cfg::SSA_UnfilteredCfg::getUsesAtNode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>astNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns all the SgVarRef objects that are used in the execution of the given AST node. 
<p>
Each of the SgVarRef objects returned corresponds to a variable name 
</div>
</div><p>
<a class="anchor" name="c47929e5c456a3e146a574bcf26127fc"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::getDefinitionForUse" ref="c47929e5c456a3e146a574bcf26127fc" args="(SgVarRefExp *astNode) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#a442d38c42255e2ec0b5668b064c1126">ReachingDefPtr</a> ssa_unfiltered_cfg::SSA_UnfilteredCfg::getDefinitionForUse           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> *&nbsp;</td>
          <td class="paramname"> <em>astNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a use obtained through getUsesAtNode, resolve its corresponding def. 
<p>
This function may return NULL for SgVarRef objects not returned by getUsesAtNode 
</div>
</div><p>
<a class="anchor" name="9d6094f65baaf020d68c683386edbc8b"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::getUseTable" ref="9d6094f65baaf020d68c683386edbc8b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#199b6f6a653b2408bdb5280228a5ca07">ASTNodeToVarRefsMap</a>&amp; ssa_unfiltered_cfg::SSA_UnfilteredCfg::getUseTable           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the entire use table, mapping each non-statement AST node to the variables used in its execution. 
<p>

</div>
</div><p>
<a class="anchor" name="d3fddf1a43cbd73d30475c330a632ff4"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::isPrefixOfName" ref="d3fddf1a43cbd73d30475c330a632ff4" args="(VarName name, VarName prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool ssa_unfiltered_cfg::SSA_UnfilteredCfg::isPrefixOfName           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a>&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a>&nbsp;</td>
          <td class="paramname"> <em>prefix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find if the given prefix is a prefix of the given name. 
<p>
This will return whether the given name has the given prefix inside it.<p>
ex. a.b.c has prefix a.b, but not a.c<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name to search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefix</em>&nbsp;</td><td>The prefix to search for. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Whether or not the prefix is in this name. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4a7d19f0f15c9383a4d5147623ffe681"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::getUniqueName" ref="4a7d19f0f15c9383a4d5147623ffe681" args="(SgNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classssa__private_1_1VarUniqueName.html">ssa_private::VarUniqueName</a>* ssa_unfiltered_cfg::SSA_UnfilteredCfg::getUniqueName           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the uniqueName attribute for the given node. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>Node to get the attribute from. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The attribute, or NULL. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7a0c07cd702dfe1814d307bebb44e1a1"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::getVarName" ref="7a0c07cd702dfe1814d307bebb44e1a1" args="(SgNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a>&amp; ssa_unfiltered_cfg::SSA_UnfilteredCfg::getVarName           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the variable name of the given node. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>The node to get the name for. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The name, or empty name. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d0e88d7ef9d3f62147d91b4e749f2d09"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::getVarForExpression" ref="d0e88d7ef9d3f62147d91b4e749f2d09" args="(SgNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a>&amp; ssa_unfiltered_cfg::SSA_UnfilteredCfg::getVarForExpression           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If an expression evaluates to a reference of a variable, returns that variable. 
<p>
Handles casts, comma ops, address of ops, etc. For example, Given the expression (...., &amp;a), this method would return the VarName for a. 
</div>
</div><p>
<a class="anchor" name="0165a58f0b38ab769f2bd7fe449249c8"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::buildVariableReference" ref="0165a58f0b38ab769f2bd7fe449249c8" args="(const VarName &amp;var, SgScopeStatement *scope=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSgExpression.html">SgExpression</a>* ssa_unfiltered_cfg::SSA_UnfilteredCfg::buildVariableReference           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an AST fragment containing the appropriate varRefs and Dot/Arrow ops to access the given variable. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The variable to construct access for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scope</em>&nbsp;</td><td>The scope within which to construct the access. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>An expression that access the given variable in the given scope. </dd></dl>

</div>
</div><p>
<a class="anchor" name="91c0d89c04898a7ec1b98d59efdf84bb"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::varnameToString" ref="91c0d89c04898a7ec1b98d59efdf84bb" args="(const VarName &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::string ssa_unfiltered_cfg::SSA_UnfilteredCfg::varnameToString           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a string representation of a varName. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>varName to get string for. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>String for given varName. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bc9e22bfa700442cb0079cc5a00b3db9"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::printNodeDefTable" ref="bc9e22bfa700442cb0079cc5a00b3db9" args="(const NodeReachingDefTable &amp;table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ssa_unfiltered_cfg::SSA_UnfilteredCfg::printNodeDefTable           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#66befa7dbaa0b1d0ab3969705281305b">NodeReachingDefTable</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>table</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2744555e034681173370c37f2dfb3a55"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::printFullDefTable" ref="2744555e034681173370c37f2dfb3a55" args="(const CFGNodeToDefTableMap &amp;defTable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ssa_unfiltered_cfg::SSA_UnfilteredCfg::printFullDefTable           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#4f0afc4eae0f862611c63ac851b42832">CFGNodeToDefTableMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>defTable</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="a53c0dff81b102f0566e583ab40f3e06"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::project" ref="a53c0dff81b102f0566e583ab40f3e06" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgProject.html">SgProject</a>* <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#a53c0dff81b102f0566e583ab40f3e06">ssa_unfiltered_cfg::SSA_UnfilteredCfg::project</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The project to perform SSA <a class="el" href="classAnalysis.html">Analysis</a> on. 
<p>

<p>
Definition at line <a class="el" href="ssaUnfilteredCfg_8h-source.html#l00063">63</a> of file <a class="el" href="ssaUnfilteredCfg_8h-source.html">ssaUnfilteredCfg.h</a>.
</div>
</div><p>
<a class="anchor" name="56895fb1eb76a5351a295de4336bd5c2"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::astNodeToUses" ref="56895fb1eb76a5351a295de4336bd5c2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#199b6f6a653b2408bdb5280228a5ca07">ASTNodeToVarRefsMap</a> <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#56895fb1eb76a5351a295de4336bd5c2">ssa_unfiltered_cfg::SSA_UnfilteredCfg::astNodeToUses</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="ssaUnfilteredCfg_8h-source.html#l00083">83</a> of file <a class="el" href="ssaUnfilteredCfg_8h-source.html">ssaUnfilteredCfg.h</a>.
</div>
</div><p>
<a class="anchor" name="a985a27d3d0db3d4b2629dbbe7e5ceee"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::localDefTable" ref="a985a27d3d0db3d4b2629dbbe7e5ceee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#4f0afc4eae0f862611c63ac851b42832">CFGNodeToDefTableMap</a> <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#a985a27d3d0db3d4b2629dbbe7e5ceee">ssa_unfiltered_cfg::SSA_UnfilteredCfg::localDefTable</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Map from each node to all the variables defined at that node. 
<p>
If there are no variables defined at the node, the corresponding entry is empty. 
<p>
Definition at line <a class="el" href="ssaUnfilteredCfg_8h-source.html#l00087">87</a> of file <a class="el" href="ssaUnfilteredCfg_8h-source.html">ssaUnfilteredCfg.h</a>.
</div>
</div><p>
<a class="anchor" name="ccb8cd4faffe99caa24cabef690c94a4"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::reachingDefTable" ref="ccb8cd4faffe99caa24cabef690c94a4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#4f0afc4eae0f862611c63ac851b42832">CFGNodeToDefTableMap</a> <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#ccb8cd4faffe99caa24cabef690c94a4">ssa_unfiltered_cfg::SSA_UnfilteredCfg::reachingDefTable</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Map from each node to all the reaching definitions at that node. 
<p>
If a definition occurs at the node itself, it is not considered to reach the node. 
<p>
Definition at line <a class="el" href="ssaUnfilteredCfg_8h-source.html#l00091">91</a> of file <a class="el" href="ssaUnfilteredCfg_8h-source.html">ssaUnfilteredCfg.h</a>.
</div>
</div><p>
<a class="anchor" name="7e3a148d1bd0501ffea8d5136b925283"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::outgoingDefTable" ref="7e3a148d1bd0501ffea8d5136b925283" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#4f0afc4eae0f862611c63ac851b42832">CFGNodeToDefTableMap</a> <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#7e3a148d1bd0501ffea8d5136b925283">ssa_unfiltered_cfg::SSA_UnfilteredCfg::outgoingDefTable</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Map from each node to the reaching definitions at the end of the node. 
<p>
If no definitions occur at the node, its entry in this table should be the same as its entry in the reachingDef table. 
<p>
Definition at line <a class="el" href="ssaUnfilteredCfg_8h-source.html#l00095">95</a> of file <a class="el" href="ssaUnfilteredCfg_8h-source.html">ssaUnfilteredCfg.h</a>.
</div>
</div><p>
<a class="anchor" name="81fd0f624a4860af55d1cd8df04f6497"></a><!-- doxytag: member="ssa_unfiltered_cfg::SSA_UnfilteredCfg::emptyName" ref="81fd0f624a4860af55d1cd8df04f6497" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#fb9b5df31f254b0786f41d48f7862cf8">VarName</a> <a class="el" href="classssa__unfiltered__cfg_1_1SSA__UnfilteredCfg.html#81fd0f624a4860af55d1cd8df04f6497">ssa_unfiltered_cfg::SSA_UnfilteredCfg::emptyName</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="ssaUnfilteredCfg_8h-source.html#l00181">181</a> of file <a class="el" href="ssaUnfilteredCfg_8h-source.html">ssaUnfilteredCfg.h</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ssaUnfilteredCfg_8h-source.html">ssaUnfilteredCfg.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
