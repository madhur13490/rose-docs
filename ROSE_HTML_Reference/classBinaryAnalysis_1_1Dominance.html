<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: BinaryAnalysis::Dominance Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceBinaryAnalysis.html">BinaryAnalysis</a>::<a class="el" href="classBinaryAnalysis_1_1Dominance.html">Dominance</a></div>
<h1>BinaryAnalysis::Dominance Class Reference</h1><!-- doxytag: class="BinaryAnalysis::Dominance" --><code>#include &lt;<a class="el" href="BinaryDominance_8h-source.html">BinaryDominance.h</a>&gt;</code>
<p>
<a href="classBinaryAnalysis_1_1Dominance-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Class for calculating dominance on control flow graphs. 
<p>
Block D "dominates" block I if every possible execution path from the function entry block to block I includes block D. Note that "dominates" is reflexive; we say D "strictly dominates" I if D dominates I and D!=I. The "dominates" relationship is also transitive and antisymmetric. Furthermore, block D is an "immediate dominator" of block I if D dominates I and there does not exist a block C (C!=D and C!=I) for which D dominates C and C dominates I.<p>
<a class="el" href="namespaceROSE.html">ROSE</a> tracks dominance via a single block pointer within each block, which can be obtained by <a class="el" href="classSgAsmBlock.html#34b8bf030607e694430f424f48d37de2">SgAsmBlock::get_immediate_dominator()</a>. Although these pointers can also be explicitly modifed with <a class="el" href="classSgAsmBlock.html#b3589f716d477920c10e25ede1991d9f">SgAsmBlock::set_immediate_dominator()</a>, one normally uses the <a class="el" href="classBinaryAnalysis_1_1Dominance.html">Dominance</a> class to do this.<p>
<a class="el" href="classBinaryAnalysis_1_1Dominance.html">Dominance</a> information is represented three ways: <ol>
<li>
Within the AST: The SgAsmBlock::get_dominators() returns a list of all dominators (or all strict dominators) for a given node by following the immediate dominator pointers stored in the AST. </li>
<li>
As a boost graph: The vertices of the graph point to basic blocks (<a class="el" href="classSgAsmBlock.html">SgAsmBlock</a>); the edges flow to subordinate blocks from their immediate dominator, and form a tree. Note that the direction of edges is opposite that stored in the AST&mdash;this is intentional since many dominance anlyses use this direction. Methods producing or operating on this representation usually have "graph" as part of their name. </li>
<li>
As a vector: Since every block has zero or one immediate dominators, the immediate dominance relation can be represented as a map from suborindate block to immediate dominator block. The dominance relationship is calculated from a control flow graph (CFG) whose vertex descriptors are integers, so we use those integers as indices into the vector. The values stored in the vector are also CFG vertex descriptors. Methods producing or operating on this representation usually have "map" as part of their name. </li>
</ol>
<p>
The <a class="el" href="classBinaryAnalysis_1_1Dominance.html">Dominance</a> class provides two forms for most methods: one form in which the result is returned by reference, and one form in which the result is returned by value. The return-by-reference functions are slightly faster since they don't require the result to be copied.<h2><a class="anchor" name="BinaryDominance_Ex1">
Example</a></h2>
This example shows one way to initialize the <a class="el" href="classSgAsmBlock.html#34b8bf030607e694430f424f48d37de2">SgAsmBlock::get_immediate_dominator()</a> information for an entire AST. We use an AST traversal to find the function nodes (<a class="el" href="classSgAsmFunction.html">SgAsmFunction</a>), and for each function we calculate that function's control flow graph, and use the control flow graph to calculate the dominance graph. We then clear all previous immediate dominator pointers in the function, and re-initialize them with the dominance graph. The reason we first clear the AST is because <a class="el" href="classBinaryAnalysis_1_1Dominance.html#2819be8ef29c2430011946e0d8b47425">apply_to_ast()</a> only initializes the blocks which have dominators; if we didn't clear the AST then some of the blocks might have stale data.<p>
Control flow graphs and dominance graphs are created with methods of a control flow and dominance class, respectively. The reason for this extra class is to hold various properties that might affect how the graphs are created, such as whether we want a debug trace of the creation process (the commented out line).<p>
Most of the methods of this class are function templates that take any kind of boost graph providing it satisfies certain interface constraints: the vertices must be stored in a vector, the graph must be bidirectional, and the boost::vertex_name property must point to a <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a>. This is the same interface used for control flow graphs, so the user can use <a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#d704a3d62401287d23f40c0aed8b70e8">BinaryAnalysis::ControlFlow::Graph</a>, <a class="el" href="classBinaryAnalysis_1_1Dominance.html#d456be2c92fb7d272dce83216e388de6">BinaryAnalysis::Dominance::Graph</a>, or any other Boost graph satisfying these requirements.<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// The AST traversal.</span>
  <span class="keyword">struct </span>CalculateDominance: <span class="keyword">public</span> <a class="code" href="classAstSimpleProcessing.html">AstSimpleProcessing</a> {
      <a class="code" href="classBinaryAnalysis_1_1ControlFlow.html">BinaryAnalysis::ControlFlow</a> &amp;cfg_analysis;
      <a class="code" href="classBinaryAnalysis_1_1Dominance.html">BinaryAnalysis::Dominance</a> &amp;dom_analysis;
      CalculateDominance(<a class="code" href="classBinaryAnalysis_1_1ControlFlow.html">BinaryAnalysis::ControlFlow</a> &amp;cfg_analysis,
                         <a class="code" href="classBinaryAnalysis_1_1Dominance.html">BinaryAnalysis::Dominance</a> &amp;dom_analysis)
          : cfg_analysis(cfg_analysis), dom_analysis(dom_analysis)
          {}
      <span class="keywordtype">void</span> visit(<a class="code" href="classSgNode.html">SgNode</a> *node) {
          <span class="keyword">using namespace </span>BinaryAnalysis;
          <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *func = <a class="code" href="Cxx__Grammar_8h.html#3374b86a87959b6a02d8ca8f792d693e">isSgAsmFunction</a>(node);
          <span class="keywordflow">if</span> (func) {
              <a class="code" href="classBinaryAnalysis_1_1ControlFlow.html#d704a3d62401287d23f40c0aed8b70e8">ControlFlow::Graph</a> cfg = cfg_analysis.build_cfg_from_ast&lt;<a class="code" href="classBinaryAnalysis_1_1ControlFlow.html#d704a3d62401287d23f40c0aed8b70e8">ControlFlow::Graph</a>&gt;(func);
              <span class="keyword">typedef</span> boost::graph_traits&lt;ControlFlow::Graph&gt;::vertex_descriptor CFG_Vertex;
              CFG_Vertex entry = 0; <span class="comment">// first vertex is function entry block</span>
              assert(get(boost::vertex_name, cfg, entry) == func-&gt;<a class="code" href="classSgAsmFunction.html#89be684ba50382920d018616cfe74f86">get_entry_block</a>());
              <a class="code" href="classBinaryAnalysis_1_1Dominance.html#d456be2c92fb7d272dce83216e388de6">Dominance::Graph</a> dg = dom_analysis.build_idom_graph_from_cfg&lt;<a class="code" href="classBinaryAnalysis_1_1Dominance.html#d456be2c92fb7d272dce83216e388de6">Dominance::Graph</a>&gt;(cfg, entry);
              dom_analysis.clear_ast(func);
              dom_analysis.apply_to_ast(dg);
          }
      }
  };

  <span class="comment">// Create the analysis objects</span>
  <a class="code" href="classBinaryAnalysis_1_1ControlFlow.html">BinaryAnalysis::ControlFlow</a> cfg_analysis;
  <a class="code" href="classBinaryAnalysis_1_1Dominance.html">BinaryAnalysis::Dominance</a>   dom_analysis;
  <span class="comment">//dom_analysis.set_debug(stderr);</span>

  <span class="comment">// Perform the analysis; results are stored in the AST.</span>
  CalculateDominance(cfg_analysis, dom_analysis).traverse(<a class="code" href="namespacecfgUtils.html#ce4abf2beca5826144d69d3a0283050f">project</a>, <a class="code" href="Cxx__Grammar_8h.html#59f7fee88581c4dd75f5fb25dbefa29edefb5d09673c144dc5b4dc177e278696">preorder</a>);
</pre></div> 
<p>

<p>
Definition at line <a class="el" href="BinaryDominance_8h-source.html#l00093">93</a> of file <a class="el" href="BinaryDominance_8h-source.html">BinaryDominance.h</a>.<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef boost::adjacency_list&lt;<br>
 boost::setS, boost::vecS,<br>
 boost::bidirectionalS, boost::property&lt;<br>
 boost::vertex_name_t, <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> * &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1Dominance.html#d456be2c92fb7d272dce83216e388de6">Graph</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default dominance graph type.  <a href="#d456be2c92fb7d272dce83216e388de6"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1Dominance.html#85761cc274d3548c02e50690dc471e2f">Dominance</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1Dominance.html#f93c7f30845c2ced2803cf18ab228d41">clear_ast</a> (<a class="el" href="classSgNode.html">SgNode</a> *ast)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears immediate dominator pointers in a subtree.  <a href="#f93c7f30845c2ced2803cf18ab228d41"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class DominanceGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1Dominance.html#7054e9fc776d89c8e1a660a8101a0d7e">cache_vertex_descriptors</a> (const DominanceGraph &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cache vertex descriptors in AST.  <a href="#7054e9fc776d89c8e1a660a8101a0d7e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1Dominance.html#51ace9ec99d31dac859f6c8cf8ff8d6f">is_consistent</a> (<a class="el" href="classSgNode.html">SgNode</a> *ast, std::set&lt; <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> * &gt; *bad_blocks=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks that dominance relationships are consistent in an AST.  <a href="#51ace9ec99d31dac859f6c8cf8ff8d6f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1Dominance.html#9f4b205396253d22a2bdd857ac1c4638">set_debug</a> (FILE *<a class="el" href="classBinaryAnalysis_1_1Dominance.html#998b3910251b42464e8861d5e63ddbf9">debug</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Control debugging output.  <a href="#9f4b205396253d22a2bdd857ac1c4638"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">FILE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1Dominance.html#ab0a02321d6cdfc0d7df15b182ffd470">get_debug</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain debugging stream.  <a href="#ab0a02321d6cdfc0d7df15b182ffd470"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class DominanceGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1Dominance.html#2819be8ef29c2430011946e0d8b47425">apply_to_ast</a> (const DominanceGraph &amp;idg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies dominator information to the AST.  <a href="#2819be8ef29c2430011946e0d8b47425"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class ControlFlowGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1Dominance.html#8d8a6b40b8b102830f65b8714d1bc738">apply_to_ast</a> (const ControlFlowGraph &amp;<a class="el" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>, const <a class="el" href="structBinaryAnalysis_1_1Dominance_1_1RelationMap.html">RelationMap</a>&lt; ControlFlowGraph &gt; &amp;relation_map)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies dominator information to the AST.  <a href="#8d8a6b40b8b102830f65b8714d1bc738"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class ControlFlowGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structBinaryAnalysis_1_1Dominance_1_1RelationMap.html">RelationMap</a>&lt; ControlFlowGraph &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1Dominance.html#57d294cf70bb6c4aa0f5a5b830e022c6">build_idom_relation_from_cfg</a> (const ControlFlowGraph &amp;<a class="el" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>, typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor start)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a relation map for immediate dominator.  <a href="#57d294cf70bb6c4aa0f5a5b830e022c6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class ControlFlowGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1Dominance.html#536a69777a77863a168887b6f6e13f8a">build_idom_relation_from_cfg</a> (const ControlFlowGraph &amp;<a class="el" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>, typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor start, <a class="el" href="structBinaryAnalysis_1_1Dominance_1_1RelationMap.html">RelationMap</a>&lt; ControlFlowGraph &gt; &amp;idom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a relation map for immediate dominator.  <a href="#536a69777a77863a168887b6f6e13f8a"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class ControlFlowGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structBinaryAnalysis_1_1Dominance_1_1RelationMap.html">RelationMap</a>&lt; ControlFlowGraph &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1Dominance.html#d49d7226a64ea1181fdd861f8f2893fe">build_postdom_relation_from_cfg</a> (const ControlFlowGraph &amp;<a class="el" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>, typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor start)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a relation map for immediate post dominator.  <a href="#d49d7226a64ea1181fdd861f8f2893fe"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class ControlFlowGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1Dominance.html#3f73b87ac39293a2edf22ecd788f2df7">build_postdom_relation_from_cfg</a> (const ControlFlowGraph &amp;<a class="el" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>, typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor start, <a class="el" href="structBinaryAnalysis_1_1Dominance_1_1RelationMap.html">RelationMap</a>&lt; ControlFlowGraph &gt; &amp;idom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a relation map for immediate post dominator.  <a href="#3f73b87ac39293a2edf22ecd788f2df7"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class DominanceGraph, class ControlFlowGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">DominanceGraph&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1Dominance.html#db0b29728bb9378cb69142d989f7365a">build_idom_graph_from_cfg</a> (const ControlFlowGraph &amp;<a class="el" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>, typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor start)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a dominance graph from a control flow graph.  <a href="#db0b29728bb9378cb69142d989f7365a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class ControlFlowGraph, class DominanceGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1Dominance.html#f28aecf896e093129e414a6d93857519">build_idom_graph_from_cfg</a> (const ControlFlowGraph &amp;<a class="el" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>, typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor start, DominanceGraph &amp;dg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a dominance graph from a control flow graph.  <a href="#f28aecf896e093129e414a6d93857519"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class DominanceGraph, class ControlFlowGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">DominanceGraph&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1Dominance.html#b393ab5c0e239567eb0a2ce5bb4758dc">build_postdom_graph_from_cfg</a> (const ControlFlowGraph &amp;<a class="el" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>, typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor start)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build a post dominator graph.  <a href="#b393ab5c0e239567eb0a2ce5bb4758dc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class ControlFlowGraph, class DominanceGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1Dominance.html#83f97de97f3f83706975fb66de19babe">build_postdom_graph_from_cfg</a> (const ControlFlowGraph &amp;<a class="el" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>, typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor start, DominanceGraph &amp;pdg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build a post dominator graph.  <a href="#83f97de97f3f83706975fb66de19babe"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class DominanceGraph, class ControlFlowGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">DominanceGraph&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1Dominance.html#7315fb0d8758a4bfe5cf06ca782c4f7d">build_graph_from_relation</a> (const ControlFlowGraph &amp;<a class="el" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>, const <a class="el" href="structBinaryAnalysis_1_1Dominance_1_1RelationMap.html">RelationMap</a>&lt; ControlFlowGraph &gt; &amp;relmap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a dominance graph from a relation map.  <a href="#7315fb0d8758a4bfe5cf06ca782c4f7d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class ControlFlowGraph, class DominanceGraph&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1Dominance.html#61f22101203838a7d4f459419dd9bc52">build_graph_from_relation</a> (const ControlFlowGraph &amp;<a class="el" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>, const <a class="el" href="structBinaryAnalysis_1_1Dominance_1_1RelationMap.html">RelationMap</a>&lt; ControlFlowGraph &gt; &amp;relmap, DominanceGraph &amp;dg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a dominance graph from a relation map.  <a href="#61f22101203838a7d4f459419dd9bc52"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">FILE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1Dominance.html#998b3910251b42464e8861d5e63ddbf9">debug</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Debugging stream, or null.  <a href="#998b3910251b42464e8861d5e63ddbf9"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBinaryAnalysis_1_1Dominance_1_1RelationMap.html">RelationMap</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vector representation of the dominance relation.  <a href="structBinaryAnalysis_1_1Dominance_1_1RelationMap.html#_details">More...</a><br></td></tr>
</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="d456be2c92fb7d272dce83216e388de6"></a><!-- doxytag: member="BinaryAnalysis::Dominance::Graph" ref="d456be2c92fb7d272dce83216e388de6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::adjacency_list&lt;boost::setS, boost::vecS, boost::bidirectionalS, boost::property&lt;boost::vertex_name_t, <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a>*&gt; &gt; <a class="el" href="classBinaryAnalysis_1_1Dominance.html#d456be2c92fb7d272dce83216e388de6">BinaryAnalysis::Dominance::Graph</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The default dominance graph type. 
<p>
A dominance graph (DG) is a Boost graph whose vertex descriptors are integers and whose vertices point to <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> nodes in the AST (via the boost::vertex_name property). Graph edges represent dominance relationships between the vertices. The particular relationship varies depending on the method by which the graph was built. For example, build_idom_graph() results in a graph whose edge (U,V) indicates that U is the immediate dominator of V, while build_sdom_graph() results in a graph whose edge (U,V) indicates that U is any strict dominator of V.<p>
Note that the edges of the graph are reversed from those stored in the AST. In the AST each block points to its immediate dominator, while in the graph each block has edges going to the blocks which it dominates. We do it this way because: <ul>
<li>
it's more succinct to store only the immediate dominator pointers in the AST, and </li>
<li>
most dominance graph algorithms use the edges in the direction we've made them, and </li>
<li>
it's easy to reverse the graph via the boost::reverse_graph if necessary, and </li>
<li>
having two directions natively stored gives more flexibility to algorithm writers. </li>
</ul>
<p>
When a dominance graph is built from a control flow graph, the vertices of the dominance graph will correspond with the vertices of the control flow graph. That is, vertex V in the dominance graph points to the same basic block as vertex V in the control flow graph.<p>
It is common to need a type for the vertices and edges. Boost graphs store this information in graph_traits and users should use that to obtain those types. Doing so will, in the long run, make your code more extensible since the only datatype you're depending on is the graph itself--change the graph type and the vertex and edge types will automatically adjust. See Boost Graph Library documentation for all the available types. The most common are:<p>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> boost::graph_traits&lt;Graph&gt;::vertex_descriptor Vertex;
  <span class="keyword">typedef</span> boost::graph_traits&lt;Graph&gt;::edge_descriptor Edge;
</pre></div> 
<p>
Definition at line <a class="el" href="BinaryDominance_8h-source.html#l00133">133</a> of file <a class="el" href="BinaryDominance_8h-source.html">BinaryDominance.h</a>.
</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="85761cc274d3548c02e50690dc471e2f"></a><!-- doxytag: member="BinaryAnalysis::Dominance::Dominance" ref="85761cc274d3548c02e50690dc471e2f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BinaryAnalysis::Dominance::Dominance           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="BinaryDominance_8h-source.html#l00095">95</a> of file <a class="el" href="BinaryDominance_8h-source.html">BinaryDominance.h</a>.
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="f93c7f30845c2ced2803cf18ab228d41"></a><!-- doxytag: member="BinaryAnalysis::Dominance::clear_ast" ref="f93c7f30845c2ced2803cf18ab228d41" args="(SgNode *ast)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BinaryAnalysis::Dominance::clear_ast           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>ast</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears immediate dominator pointers in a subtree. 
<p>
Traverses the specified AST and clears the immediate dominator pointer in each <a class="el" href="classSgAsmNode.html">SgAsmNode</a> in the subtree. The traversal follows the tree, not the immediate dominator pointers. Whether the algorithm follows the AST pointers or the dominance pointers during traversal is irrelevant when dominance has been calculated over a single function and specified AST to clear is that function since all immediate dominator pointers will point to other blocks within the same function. But it can make a difference in other use cases. 
</div>
</div><p>
<a class="anchor" name="2819be8ef29c2430011946e0d8b47425"></a><!-- doxytag: member="BinaryAnalysis::Dominance::apply_to_ast" ref="2819be8ef29c2430011946e0d8b47425" args="(const DominanceGraph &amp;idg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DominanceGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BinaryAnalysis::Dominance::apply_to_ast           </td>
          <td>(</td>
          <td class="paramtype">const DominanceGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>idg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies dominator information to the AST. 
<p>
Just as the dominance graph can be built from the immediate dominator pointers in the AST, a immediate dominance graph can be used to initialize the pointers in the AST. The AST can be initialized either from a dominance graph or the dominance relation map.<p>
Blocks that have an immediate dominator will have their dominator pointer updated (see <a class="el" href="classSgAsmBlock.html#34b8bf030607e694430f424f48d37de2">SgAsmBlock::get_immediate_dominator()</a>), but the pointer will not be set to null if the block has no dominator. Therefore, it is probably wise to call <a class="el" href="classBinaryAnalysis_1_1Dominance.html#f93c7f30845c2ced2803cf18ab228d41">clear_ast()</a> before <a class="el" href="classBinaryAnalysis_1_1Dominance.html#2819be8ef29c2430011946e0d8b47425">apply_to_ast()</a>. The reason this was designed like this is because it makes it possible to update just the subtree (e.g., <a class="el" href="classSgAsmFunction.html">SgAsmFunction</a>) over which dominance was computed even if the control flow graph covers more of the AST. 
<p>
Definition at line <a class="el" href="BinaryDominance_8h-source.html#l00389">389</a> of file <a class="el" href="BinaryDominance_8h-source.html">BinaryDominance.h</a>.
<p>
References <a class="el" href="BinaryDominance_8h-source.html#l00377">debug</a>, <a class="el" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">SgAsmStatement::get_address()</a>, and <a class="el" href="classSgAsmBlock.html#b3589f716d477920c10e25ede1991d9f">SgAsmBlock::set_immediate_dominator()</a>.
</div>
</div><p>
<a class="anchor" name="8d8a6b40b8b102830f65b8714d1bc738"></a><!-- doxytag: member="BinaryAnalysis::Dominance::apply_to_ast" ref="8d8a6b40b8b102830f65b8714d1bc738" args="(const ControlFlowGraph &amp;cfg, const RelationMap&lt; ControlFlowGraph &gt; &amp;relation_map)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BinaryAnalysis::Dominance::apply_to_ast           </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structBinaryAnalysis_1_1Dominance_1_1RelationMap.html">RelationMap</a>&lt; ControlFlowGraph &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>relation_map</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies dominator information to the AST. 
<p>
Just as the dominance graph can be built from the immediate dominator pointers in the AST, a immediate dominance graph can be used to initialize the pointers in the AST. The AST can be initialized either from a dominance graph or the dominance relation map.<p>
Blocks that have an immediate dominator will have their dominator pointer updated (see <a class="el" href="classSgAsmBlock.html#34b8bf030607e694430f424f48d37de2">SgAsmBlock::get_immediate_dominator()</a>), but the pointer will not be set to null if the block has no dominator. Therefore, it is probably wise to call <a class="el" href="classBinaryAnalysis_1_1Dominance.html#f93c7f30845c2ced2803cf18ab228d41">clear_ast()</a> before <a class="el" href="classBinaryAnalysis_1_1Dominance.html#2819be8ef29c2430011946e0d8b47425">apply_to_ast()</a>. The reason this was designed like this is because it makes it possible to update just the subtree (e.g., <a class="el" href="classSgAsmFunction.html">SgAsmFunction</a>) over which dominance was computed even if the control flow graph covers more of the AST. 
<p>
Definition at line <a class="el" href="BinaryDominance_8h-source.html#l00408">408</a> of file <a class="el" href="BinaryDominance_8h-source.html">BinaryDominance.h</a>.
</div>
</div><p>
<a class="anchor" name="7054e9fc776d89c8e1a660a8101a0d7e"></a><!-- doxytag: member="BinaryAnalysis::Dominance::cache_vertex_descriptors" ref="7054e9fc776d89c8e1a660a8101a0d7e" args="(const DominanceGraph &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DominanceGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BinaryAnalysis::Dominance::cache_vertex_descriptors           </td>
          <td>(</td>
          <td class="paramtype">const DominanceGraph &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cache vertex descriptors in AST. 
<p>
The vertices of a dominance graph are of type <a class="el" href="structVertex.html">Vertex</a>, and point at the basic blocks (<a class="el" href="classSgAsmBlock.html">SgAsmBlock</a>) of the AST. Although most graph algorithms will only need to map <a class="el" href="structVertex.html">Vertex</a> to <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a>, the inverse mapping is also sometimes useful. That mapping can be stored into an std::map via graph traversal, or stored in the AST itself attached to each <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a>. Using an std::map requires an O(log N) lookup each time we need to get the vertex descriptor from a block, while storing the vertex descriptor in the AST requires O(1) lookup time.<p>
The vertex descriptors are available via <a class="el" href="classSgAsmBlock.html#e7899513748bd3f925b56b2f8a78a8a7">SgAsmBlock::get_cached_vertex()</a>. Other graph types (e.g., control flow graphs) might also use the same cache line. The cached vertex is stored as a size_t, which is the same underlying type for dominance graph vertices. 
<p>
Definition at line <a class="el" href="BinaryDominance_8h-source.html#l00426">426</a> of file <a class="el" href="BinaryDominance_8h-source.html">BinaryDominance.h</a>.
</div>
</div><p>
<a class="anchor" name="51ace9ec99d31dac859f6c8cf8ff8d6f"></a><!-- doxytag: member="BinaryAnalysis::Dominance::is_consistent" ref="51ace9ec99d31dac859f6c8cf8ff8d6f" args="(SgNode *ast, std::set&lt; SgAsmBlock * &gt; *bad_blocks=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BinaryAnalysis::Dominance::is_consistent           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>ast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> * &gt; *&nbsp;</td>
          <td class="paramname"> <em>bad_blocks</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks that dominance relationships are consistent in an AST. 
<p>
This method traverses the given AST to ensure that dominance relationships are consistent. It checks the following conditions:<p>
<ul>
<li>
The entry block of a function has no immediate dominator. </li>
<li>
All non-entry blocks of a function have an immediate dominator. </li>
<li>
If block D is the immediate dominator of block I, then D and I belong to the same function. </li>
</ul>
<p>
Specifically, this method does not check for wild immediate dominator pointers, such a pointers to blocks that have been deleted.<p>
Returns true if no problems were detected, false otherwise. If the user supplies a pointer to a bad-blocks set, then blocks where problems were detected will be added to the set. The set is not cleared by this method. 
</div>
</div><p>
<a class="anchor" name="57d294cf70bb6c4aa0f5a5b830e022c6"></a><!-- doxytag: member="BinaryAnalysis::Dominance::build_idom_relation_from_cfg" ref="57d294cf70bb6c4aa0f5a5b830e022c6" args="(const ControlFlowGraph &amp;cfg, typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor start)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structBinaryAnalysis_1_1Dominance_1_1RelationMap.html">BinaryAnalysis::Dominance::RelationMap</a>&lt; ControlFlowGraph &gt; BinaryAnalysis::Dominance::build_idom_relation_from_cfg           </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor&nbsp;</td>
          <td class="paramname"> <em>start</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a relation map for immediate dominator. 
<p>
Given a control flow graph (CFG) and a starting vertex within that graph, calculate the immediate dominator of each vertex. The relationship is returned through the <code>idom</code> argument, which is a vector indexed by CFG vertices (which are just integers), and where each element is the CFG vertex which is the immediate dominator. For vertices that have no immediate dominator (e.g., function entry blocks or blocks that are not connected to the entry block in the CFG), the stored value is the null vertex. See <a class="el" href="structBinaryAnalysis_1_1Dominance_1_1RelationMap.html">RelationMap</a> for details.<p>
This method is intended to be the lowest level implementation for finding dominators; all other methods are built upon this one. This method uses an algorithm based on "A Simple, Fast Dominance Algorithm" by Keith D. Cooper, Timothy J. Harvey, and Ken Kennedy at Rice University, Houston, Texas. It has been extended in various ways to simplify it and make it slightly faster. Although run-time complexity is higher than the Lengauer-Tarjan algorithm, the algorithm is much simpler, and for CFGs typically encountered in practice is faster than Lengauer-Tarjan. 
<p>
Definition at line <a class="el" href="BinaryDominance_8h-source.html#l00464">464</a> of file <a class="el" href="BinaryDominance_8h-source.html">BinaryDominance.h</a>.
<p>
Referenced by <a class="el" href="BinaryDominance_8h-source.html#l00443">build_idom_graph_from_cfg()</a>, and <a class="el" href="BinaryDominance_8h-source.html#l00715">build_postdom_relation_from_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="536a69777a77863a168887b6f6e13f8a"></a><!-- doxytag: member="BinaryAnalysis::Dominance::build_idom_relation_from_cfg" ref="536a69777a77863a168887b6f6e13f8a" args="(const ControlFlowGraph &amp;cfg, typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor start, RelationMap&lt; ControlFlowGraph &gt; &amp;idom)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BinaryAnalysis::Dominance::build_idom_relation_from_cfg           </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBinaryAnalysis_1_1Dominance_1_1RelationMap.html">RelationMap</a>&lt; ControlFlowGraph &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>idom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a relation map for immediate dominator. 
<p>
Given a control flow graph (CFG) and a starting vertex within that graph, calculate the immediate dominator of each vertex. The relationship is returned through the <code>idom</code> argument, which is a vector indexed by CFG vertices (which are just integers), and where each element is the CFG vertex which is the immediate dominator. For vertices that have no immediate dominator (e.g., function entry blocks or blocks that are not connected to the entry block in the CFG), the stored value is the null vertex. See <a class="el" href="structBinaryAnalysis_1_1Dominance_1_1RelationMap.html">RelationMap</a> for details.<p>
This method is intended to be the lowest level implementation for finding dominators; all other methods are built upon this one. This method uses an algorithm based on "A Simple, Fast Dominance Algorithm" by Keith D. Cooper, Timothy J. Harvey, and Ken Kennedy at Rice University, Houston, Texas. It has been extended in various ways to simplify it and make it slightly faster. Although run-time complexity is higher than the Lengauer-Tarjan algorithm, the algorithm is much simpler, and for CFGs typically encountered in practice is faster than Lengauer-Tarjan. 
<p>
Definition at line <a class="el" href="BinaryDominance_8h-source.html#l00506">506</a> of file <a class="el" href="BinaryDominance_8h-source.html">BinaryDominance.h</a>.
<p>
References <a class="el" href="BinaryDominance_8h-source.html#l00377">debug</a>, <a class="el" href="classSgAsmBlock.html#bdd6257d93832cc2b0dcbdf07f9ccd3c">SgAsmBlock::get_enclosing_function()</a>, <a class="el" href="SgAsmFunction_8C-source.html#l00192">SgAsmFunction::get_entry_block()</a>, <a class="el" href="classSgAsmFunction.html#6edeeb78e01e2af6e59a5c6f7b0088af">SgAsmFunction::get_entry_va()</a>, and <a class="el" href="classSgAsmFunction.html#dfb6d9281f2d93a0ccc4974036ef2f1d">SgAsmFunction::get_name()</a>.
</div>
</div><p>
<a class="anchor" name="d49d7226a64ea1181fdd861f8f2893fe"></a><!-- doxytag: member="BinaryAnalysis::Dominance::build_postdom_relation_from_cfg" ref="d49d7226a64ea1181fdd861f8f2893fe" args="(const ControlFlowGraph &amp;cfg, typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor start)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structBinaryAnalysis_1_1Dominance_1_1RelationMap.html">BinaryAnalysis::Dominance::RelationMap</a>&lt; ControlFlowGraph &gt; BinaryAnalysis::Dominance::build_postdom_relation_from_cfg           </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor&nbsp;</td>
          <td class="paramname"> <em>start</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a relation map for immediate post dominator. 
<p>
Given a control flow graph (CFG) and a starting vertex within that graph, calculate the immediate post dominator of each vertex. The relationship is returned through the <code>pdom</code> argument, which is a vector indexed by CFG vertices (which are just integers), and where each element is the CFG vertex which is the immediate post dominator. For vertices that have no immediate post dominator (e.g., function exit blocks or blocks that eventually exit the function through multiple exit blocks), the stored value is the null vertex. See <a class="el" href="structBinaryAnalysis_1_1Dominance_1_1RelationMap.html">RelationMap</a> for details.<p>
This method finds post dominators by first locating the function exit blocks via <a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#a23ac98fe0507882b7b3e566d91f8cc5">ControlFlow::return_blocks()</a>. If the exit block is not unique, then a temporary exit vertex is added to the CFG and the original exit blocks are given control flow edges to this unique vertex. The CFG is then reversed and <a class="el" href="classBinaryAnalysis_1_1Dominance.html#57d294cf70bb6c4aa0f5a5b830e022c6">build_idom_relation_from_cfg()</a> is called. Finally, if a temporary unique exit vertex was added, it is removed from the result. 
<p>
Definition at line <a class="el" href="BinaryDominance_8h-source.html#l00705">705</a> of file <a class="el" href="BinaryDominance_8h-source.html">BinaryDominance.h</a>.
<p>
Referenced by <a class="el" href="BinaryDominance_8h-source.html#l00684">build_postdom_graph_from_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="3f73b87ac39293a2edf22ecd788f2df7"></a><!-- doxytag: member="BinaryAnalysis::Dominance::build_postdom_relation_from_cfg" ref="3f73b87ac39293a2edf22ecd788f2df7" args="(const ControlFlowGraph &amp;cfg, typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor start, RelationMap&lt; ControlFlowGraph &gt; &amp;idom)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BinaryAnalysis::Dominance::build_postdom_relation_from_cfg           </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBinaryAnalysis_1_1Dominance_1_1RelationMap.html">RelationMap</a>&lt; ControlFlowGraph &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>idom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a relation map for immediate post dominator. 
<p>
Given a control flow graph (CFG) and a starting vertex within that graph, calculate the immediate post dominator of each vertex. The relationship is returned through the <code>pdom</code> argument, which is a vector indexed by CFG vertices (which are just integers), and where each element is the CFG vertex which is the immediate post dominator. For vertices that have no immediate post dominator (e.g., function exit blocks or blocks that eventually exit the function through multiple exit blocks), the stored value is the null vertex. See <a class="el" href="structBinaryAnalysis_1_1Dominance_1_1RelationMap.html">RelationMap</a> for details.<p>
This method finds post dominators by first locating the function exit blocks via <a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#a23ac98fe0507882b7b3e566d91f8cc5">ControlFlow::return_blocks()</a>. If the exit block is not unique, then a temporary exit vertex is added to the CFG and the original exit blocks are given control flow edges to this unique vertex. The CFG is then reversed and <a class="el" href="classBinaryAnalysis_1_1Dominance.html#57d294cf70bb6c4aa0f5a5b830e022c6">build_idom_relation_from_cfg()</a> is called. Finally, if a temporary unique exit vertex was added, it is removed from the result. 
<p>
Definition at line <a class="el" href="BinaryDominance_8h-source.html#l00715">715</a> of file <a class="el" href="BinaryDominance_8h-source.html">BinaryDominance.h</a>.
<p>
References <a class="el" href="BinaryDominance_8h-source.html#l00464">build_idom_relation_from_cfg()</a>, <a class="el" href="yicesParserLib_8h-source.html#l01439">cfg</a>, <a class="el" href="BinaryDominance_8h-source.html#l00377">debug</a>, <a class="el" href="classSgAsmBlock.html#bdd6257d93832cc2b0dcbdf07f9ccd3c">SgAsmBlock::get_enclosing_function()</a>, <a class="el" href="SgAsmFunction_8C-source.html#l00192">SgAsmFunction::get_entry_block()</a>, <a class="el" href="classSgAsmFunction.html#6edeeb78e01e2af6e59a5c6f7b0088af">SgAsmFunction::get_entry_va()</a>, and <a class="el" href="classSgAsmFunction.html#dfb6d9281f2d93a0ccc4974036ef2f1d">SgAsmFunction::get_name()</a>.
</div>
</div><p>
<a class="anchor" name="db0b29728bb9378cb69142d989f7365a"></a><!-- doxytag: member="BinaryAnalysis::Dominance::build_idom_graph_from_cfg" ref="db0b29728bb9378cb69142d989f7365a" args="(const ControlFlowGraph &amp;cfg, typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor start)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DominanceGraph, class ControlFlowGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DominanceGraph BinaryAnalysis::Dominance::build_idom_graph_from_cfg           </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor&nbsp;</td>
          <td class="paramname"> <em>start</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a dominance graph from a control flow graph. 
<p>
This method traverses a given control flow graph (CFG) to build a graph where each vertex corresponds to a vertex in the CFG, and each edge, (U,V), represents the fact that U is the immediate dominator of V. This algorithm does not use information stored in the <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> nodes of the AST (specifically not the immediate dominator pointers) and does not modify the AST.<p>
See class documentation for a description of how dominance graph vertices correspond to CFG vertices. 
<p>
Definition at line <a class="el" href="BinaryDominance_8h-source.html#l00454">454</a> of file <a class="el" href="BinaryDominance_8h-source.html">BinaryDominance.h</a>.
</div>
</div><p>
<a class="anchor" name="f28aecf896e093129e414a6d93857519"></a><!-- doxytag: member="BinaryAnalysis::Dominance::build_idom_graph_from_cfg" ref="f28aecf896e093129e414a6d93857519" args="(const ControlFlowGraph &amp;cfg, typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor start, DominanceGraph &amp;dg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph, class DominanceGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BinaryAnalysis::Dominance::build_idom_graph_from_cfg           </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DominanceGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>dg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a dominance graph from a control flow graph. 
<p>
This method traverses a given control flow graph (CFG) to build a graph where each vertex corresponds to a vertex in the CFG, and each edge, (U,V), represents the fact that U is the immediate dominator of V. This algorithm does not use information stored in the <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> nodes of the AST (specifically not the immediate dominator pointers) and does not modify the AST.<p>
See class documentation for a description of how dominance graph vertices correspond to CFG vertices. 
<p>
Definition at line <a class="el" href="BinaryDominance_8h-source.html#l00443">443</a> of file <a class="el" href="BinaryDominance_8h-source.html">BinaryDominance.h</a>.
<p>
References <a class="el" href="BinaryDominance_8h-source.html#l00803">build_graph_from_relation()</a>, and <a class="el" href="BinaryDominance_8h-source.html#l00464">build_idom_relation_from_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="b393ab5c0e239567eb0a2ce5bb4758dc"></a><!-- doxytag: member="BinaryAnalysis::Dominance::build_postdom_graph_from_cfg" ref="b393ab5c0e239567eb0a2ce5bb4758dc" args="(const ControlFlowGraph &amp;cfg, typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor start)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DominanceGraph, class ControlFlowGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DominanceGraph BinaryAnalysis::Dominance::build_postdom_graph_from_cfg           </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor&nbsp;</td>
          <td class="paramname"> <em>start</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Build a post dominator graph. 
<p>
The post dominator relation is like the immediate dominator relation except instead of considering the control flow path from the entry block to the block in question, we consider the path from the block in question to the exit block. If every path from the block in question, B, to the exit block passes through vertex D, then D is is a post dominator of B. Immediate post dominance and strict post dominance are analogous to the (pre) dominance definitions presented above.<p>
<a class="el" href="namespaceROSE.html">ROSE</a> does not create a unique basic block to serve as a function exit vertex of the CFG (such a block would be empty of instructions and would have no virtual address, making it a bit problematic. Furthermore, the function may contain basic blocks whose successors are statically unknown (e.g., computed branches). Therefore, this method temporarily modifies the CFG (specifically, a copy thereof), if necessary, by adding a unique exit vertex and adjusting all vertices identified by <a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#a23ac98fe0507882b7b3e566d91f8cc5">BinaryAnalysis::ControlFlow::return_blocks()</a> so they point to the unique exit vertex. If the exit vertex was added, it will be removed (along with its edges) from the returned post dominator graph. 
<p>
Definition at line <a class="el" href="BinaryDominance_8h-source.html#l00695">695</a> of file <a class="el" href="BinaryDominance_8h-source.html">BinaryDominance.h</a>.
</div>
</div><p>
<a class="anchor" name="83f97de97f3f83706975fb66de19babe"></a><!-- doxytag: member="BinaryAnalysis::Dominance::build_postdom_graph_from_cfg" ref="83f97de97f3f83706975fb66de19babe" args="(const ControlFlowGraph &amp;cfg, typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor start, DominanceGraph &amp;pdg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph, class DominanceGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BinaryAnalysis::Dominance::build_postdom_graph_from_cfg           </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::graph_traits&lt; ControlFlowGraph &gt;::vertex_descriptor&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DominanceGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>pdg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Build a post dominator graph. 
<p>
The post dominator relation is like the immediate dominator relation except instead of considering the control flow path from the entry block to the block in question, we consider the path from the block in question to the exit block. If every path from the block in question, B, to the exit block passes through vertex D, then D is is a post dominator of B. Immediate post dominance and strict post dominance are analogous to the (pre) dominance definitions presented above.<p>
<a class="el" href="namespaceROSE.html">ROSE</a> does not create a unique basic block to serve as a function exit vertex of the CFG (such a block would be empty of instructions and would have no virtual address, making it a bit problematic. Furthermore, the function may contain basic blocks whose successors are statically unknown (e.g., computed branches). Therefore, this method temporarily modifies the CFG (specifically, a copy thereof), if necessary, by adding a unique exit vertex and adjusting all vertices identified by <a class="el" href="classBinaryAnalysis_1_1ControlFlow.html#a23ac98fe0507882b7b3e566d91f8cc5">BinaryAnalysis::ControlFlow::return_blocks()</a> so they point to the unique exit vertex. If the exit vertex was added, it will be removed (along with its edges) from the returned post dominator graph. 
<p>
Definition at line <a class="el" href="BinaryDominance_8h-source.html#l00684">684</a> of file <a class="el" href="BinaryDominance_8h-source.html">BinaryDominance.h</a>.
<p>
References <a class="el" href="BinaryDominance_8h-source.html#l00803">build_graph_from_relation()</a>, and <a class="el" href="BinaryDominance_8h-source.html#l00705">build_postdom_relation_from_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="7315fb0d8758a4bfe5cf06ca782c4f7d"></a><!-- doxytag: member="BinaryAnalysis::Dominance::build_graph_from_relation" ref="7315fb0d8758a4bfe5cf06ca782c4f7d" args="(const ControlFlowGraph &amp;cfg, const RelationMap&lt; ControlFlowGraph &gt; &amp;relmap)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DominanceGraph, class ControlFlowGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DominanceGraph BinaryAnalysis::Dominance::build_graph_from_relation           </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structBinaryAnalysis_1_1Dominance_1_1RelationMap.html">RelationMap</a>&lt; ControlFlowGraph &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>relmap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a dominance graph from a relation map. 
<p>
Given a control flow graph (CFG) and a dominance relation map, build a dominance graph where each vertex of the resulting dominance graph points to a basic block (<a class="el" href="classSgAsmBlock.html">SgAsmBlock</a>) represented in the CFG, and each edge, (U,V), represents the fact that U is the immediate dominator of V.<p>
See class documentation for a description of how dominance graph vertices correspond to CFG vertices. 
<p>
Definition at line <a class="el" href="BinaryDominance_8h-source.html#l00803">803</a> of file <a class="el" href="BinaryDominance_8h-source.html">BinaryDominance.h</a>.
<p>
Referenced by <a class="el" href="BinaryDominance_8h-source.html#l00443">build_idom_graph_from_cfg()</a>, and <a class="el" href="BinaryDominance_8h-source.html#l00684">build_postdom_graph_from_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="61f22101203838a7d4f459419dd9bc52"></a><!-- doxytag: member="BinaryAnalysis::Dominance::build_graph_from_relation" ref="61f22101203838a7d4f459419dd9bc52" args="(const ControlFlowGraph &amp;cfg, const RelationMap&lt; ControlFlowGraph &gt; &amp;relmap, DominanceGraph &amp;dg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ControlFlowGraph, class DominanceGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BinaryAnalysis::Dominance::build_graph_from_relation           </td>
          <td>(</td>
          <td class="paramtype">const ControlFlowGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structBinaryAnalysis_1_1Dominance_1_1RelationMap.html">RelationMap</a>&lt; ControlFlowGraph &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>relmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DominanceGraph &amp;&nbsp;</td>
          <td class="paramname"> <em>dg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a dominance graph from a relation map. 
<p>
Given a control flow graph (CFG) and a dominance relation map, build a dominance graph where each vertex of the resulting dominance graph points to a basic block (<a class="el" href="classSgAsmBlock.html">SgAsmBlock</a>) represented in the CFG, and each edge, (U,V), represents the fact that U is the immediate dominator of V.<p>
See class documentation for a description of how dominance graph vertices correspond to CFG vertices. 
<p>
Definition at line <a class="el" href="BinaryDominance_8h-source.html#l00813">813</a> of file <a class="el" href="BinaryDominance_8h-source.html">BinaryDominance.h</a>.
<p>
References <a class="el" href="BinaryDominance_8h-source.html#l00377">debug</a>.
</div>
</div><p>
<a class="anchor" name="9f4b205396253d22a2bdd857ac1c4638"></a><!-- doxytag: member="BinaryAnalysis::Dominance::set_debug" ref="9f4b205396253d22a2bdd857ac1c4638" args="(FILE *debug)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BinaryAnalysis::Dominance::set_debug           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>debug</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Control debugging output. 
<p>
If set to a non-null value, then some of the algorithms will produce debug traces on the specified file. 
<p>
Definition at line <a class="el" href="BinaryDominance_8h-source.html#l00368">368</a> of file <a class="el" href="BinaryDominance_8h-source.html">BinaryDominance.h</a>.
</div>
</div><p>
<a class="anchor" name="ab0a02321d6cdfc0d7df15b182ffd470"></a><!-- doxytag: member="BinaryAnalysis::Dominance::get_debug" ref="ab0a02321d6cdfc0d7df15b182ffd470" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* BinaryAnalysis::Dominance::get_debug           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtain debugging stream. 
<p>
Returns the current debug stream that was last set by <a class="el" href="classBinaryAnalysis_1_1Dominance.html#9f4b205396253d22a2bdd857ac1c4638">set_debug()</a>. A null value indicates that debugging is disabled. 
<p>
Definition at line <a class="el" href="BinaryDominance_8h-source.html#l00374">374</a> of file <a class="el" href="BinaryDominance_8h-source.html">BinaryDominance.h</a>.
<p>
References <a class="el" href="BinaryDominance_8h-source.html#l00377">debug</a>.
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="998b3910251b42464e8861d5e63ddbf9"></a><!-- doxytag: member="BinaryAnalysis::Dominance::debug" ref="998b3910251b42464e8861d5e63ddbf9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* <a class="el" href="classBinaryAnalysis_1_1Dominance.html#998b3910251b42464e8861d5e63ddbf9">BinaryAnalysis::Dominance::debug</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Debugging stream, or null. 
<p>

<p>
Definition at line <a class="el" href="BinaryDominance_8h-source.html#l00377">377</a> of file <a class="el" href="BinaryDominance_8h-source.html">BinaryDominance.h</a>.
<p>
Referenced by <a class="el" href="BinaryDominance_8h-source.html#l00389">apply_to_ast()</a>, <a class="el" href="BinaryDominance_8h-source.html#l00813">build_graph_from_relation()</a>, <a class="el" href="BinaryDominance_8h-source.html#l00506">build_idom_relation_from_cfg()</a>, <a class="el" href="BinaryDominance_8h-source.html#l00715">build_postdom_relation_from_cfg()</a>, and <a class="el" href="BinaryDominance_8h-source.html#l00374">get_debug()</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="BinaryDominance_8h-source.html">BinaryDominance.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
