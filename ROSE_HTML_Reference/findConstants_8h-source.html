<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: findConstants.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>findConstants.h</h1><a href="findConstants_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* The primary purpose of this header file is to define a "policy" for instruction semantics such as for the</span>
<a name="l00002"></a>00002 <span class="comment"> * X86InstructionSemantics class. This particular policy is for tracking the flow of constant values. */</span>
<a name="l00003"></a>00003 
<a name="l00004"></a>00004 <span class="preprocessor">#ifndef findConstants_H</span>
<a name="l00005"></a>00005 <span class="preprocessor"></span><span class="preprocessor">#define findConstants_H</span>
<a name="l00006"></a>00006 <span class="preprocessor"></span>
<a name="l00007"></a>00007 <span class="preprocessor">#include "<a class="code" href="x86InstructionSemantics_8h.html">x86InstructionSemantics.h</a>"</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include "<a class="code" href="integerOps_8h.html">integerOps.h</a>"</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include "<a class="code" href="flowEquations_8h.html">flowEquations.h</a>"</span>
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;cassert&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;cstdio&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;boost/lexical_cast.hpp&gt;</span>
<a name="l00014"></a>00014 
<a name="l00024"></a>00024 <span class="keyword">template</span> &lt;size_t Len&gt;                         <span class="comment">// Sums are modulo 2^Len</span>
<a name="l00025"></a><a class="code" href="structLatticeElement.html">00025</a> <span class="keyword">struct </span><a class="code" href="structLatticeElement.html">LatticeElement</a> {
<a name="l00026"></a><a class="code" href="structLatticeElement.html#4cf276f9d7e1d0dde19af9d40c8f7c5b">00026</a>     <span class="keywordtype">bool</span> <a class="code" href="structLatticeElement.html#4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>;
<a name="l00027"></a><a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">00027</a>     uint64_t <a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a>;                            <span class="comment">// 0 for constants, a nonzero ID number for everything else</span>
<a name="l00028"></a><a class="code" href="structLatticeElement.html#fb9076844cf7aeb97f205a872b685e1b">00028</a>     <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* <a class="code" href="structLatticeElement.html#fb9076844cf7aeb97f205a872b685e1b">definingInstruction</a>; <span class="comment">// Functionally dependent on name (mostly for debugging)</span>
<a name="l00029"></a><a class="code" href="structLatticeElement.html#6bfb90dd4b9e80a03cdef7d2f55d78f8">00029</a>     <span class="keywordtype">bool</span> <a class="code" href="structLatticeElement.html#6bfb90dd4b9e80a03cdef7d2f55d78f8">negate</a>;                              <span class="comment">// Switch between name+offset and -name+offset; should be false for constants</span>
<a name="l00030"></a><a class="code" href="structLatticeElement.html#5f7046b6efe5660c07b84883ee26a4cc">00030</a>     uint64_t <a class="code" href="structLatticeElement.html#5f7046b6efe5660c07b84883ee26a4cc">offset</a>;                          <span class="comment">// Offset from name</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032     <span class="comment">/* Constructs a "top" lattice element */</span>
<a name="l00033"></a><a class="code" href="structLatticeElement.html#100ba60a126161578eb3a603de93d1eb">00033</a>     <a class="code" href="structLatticeElement.html#100ba60a126161578eb3a603de93d1eb">LatticeElement</a>()
<a name="l00034"></a>00034         : <a class="code" href="structLatticeElement.html#4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>(true), <a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a>(0), <a class="code" href="structLatticeElement.html#fb9076844cf7aeb97f205a872b685e1b">definingInstruction</a>(NULL), <a class="code" href="structLatticeElement.html#6bfb90dd4b9e80a03cdef7d2f55d78f8">negate</a>(false), <a class="code" href="structLatticeElement.html#5f7046b6efe5660c07b84883ee26a4cc">offset</a>(0)
<a name="l00035"></a>00035         {}
<a name="l00036"></a>00036 
<a name="l00037"></a>00037     <span class="comment">/* Construct a named lattice element (no offset) */</span>
<a name="l00038"></a><a class="code" href="structLatticeElement.html#68f4d621d8c1df5143663efbec642574">00038</a>     <span class="keyword">static</span> <a class="code" href="structLatticeElement.html">LatticeElement</a> <a class="code" href="structLatticeElement.html#68f4d621d8c1df5143663efbec642574">nonconstant</a>(uint64_t <a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a>, <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* <a class="code" href="structLatticeElement.html#fb9076844cf7aeb97f205a872b685e1b">definingInstruction</a>) {
<a name="l00039"></a>00039         <span class="keywordflow">return</span> <a class="code" href="structLatticeElement.html#100ba60a126161578eb3a603de93d1eb">LatticeElement</a>(name, <a class="code" href="structLatticeElement.html#fb9076844cf7aeb97f205a872b685e1b">definingInstruction</a>, <span class="keyword">false</span>, 0);
<a name="l00040"></a>00040     }
<a name="l00041"></a>00041 
<a name="l00042"></a>00042     <span class="comment">/* Construct a non-top, named lattice element with optional offset. */</span>
<a name="l00043"></a><a class="code" href="structLatticeElement.html#06677733e32d97109956f0edd702a2cb">00043</a>     <a class="code" href="structLatticeElement.html#100ba60a126161578eb3a603de93d1eb">LatticeElement</a>(uint64_t <a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a>, <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* <a class="code" href="structLatticeElement.html#fb9076844cf7aeb97f205a872b685e1b">definingInstruction</a>, <span class="keywordtype">bool</span> <a class="code" href="structLatticeElement.html#6bfb90dd4b9e80a03cdef7d2f55d78f8">negate</a>, uint64_t <a class="code" href="structLatticeElement.html#5f7046b6efe5660c07b84883ee26a4cc">offset</a>)
<a name="l00044"></a>00044         : <a class="code" href="structLatticeElement.html#4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>(false), name(name), <a class="code" href="structLatticeElement.html#fb9076844cf7aeb97f205a872b685e1b">definingInstruction</a>(<a class="code" href="structLatticeElement.html#fb9076844cf7aeb97f205a872b685e1b">definingInstruction</a>), negate(negate),
<a name="l00045"></a>00045           offset(offset &amp; (IntegerOps::GenMask&lt;uint64_t, Len&gt;::value))
<a name="l00046"></a>00046         {}
<a name="l00047"></a>00047 
<a name="l00048"></a>00048     <span class="comment">/* Construct a named lattice element with optional offset. */</span>
<a name="l00049"></a><a class="code" href="structLatticeElement.html#6d3b3d1c4b1438daecd7b1a20b1d831c">00049</a>     <a class="code" href="structLatticeElement.html#100ba60a126161578eb3a603de93d1eb">LatticeElement</a>(<span class="keywordtype">bool</span> <a class="code" href="structLatticeElement.html#4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>, uint64_t <a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a>, <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* <a class="code" href="structLatticeElement.html#fb9076844cf7aeb97f205a872b685e1b">definingInstruction</a>, <span class="keywordtype">bool</span> <a class="code" href="structLatticeElement.html#6bfb90dd4b9e80a03cdef7d2f55d78f8">negate</a>, uint64_t <a class="code" href="structLatticeElement.html#5f7046b6efe5660c07b84883ee26a4cc">offset</a>)
<a name="l00050"></a>00050         : isTop(isTop), name(name), <a class="code" href="structLatticeElement.html#fb9076844cf7aeb97f205a872b685e1b">definingInstruction</a>(<a class="code" href="structLatticeElement.html#fb9076844cf7aeb97f205a872b685e1b">definingInstruction</a>), negate(negate),
<a name="l00051"></a>00051           offset(offset &amp; (IntegerOps::GenMask&lt;uint64_t, Len&gt;::value))
<a name="l00052"></a>00052         {}
<a name="l00053"></a>00053 
<a name="l00054"></a>00054     <span class="comment">/* Construct a constant lattice element */</span>
<a name="l00055"></a><a class="code" href="structLatticeElement.html#260c3631fc51e216ccbed10e2df772f2">00055</a>     <span class="keyword">static</span> <a class="code" href="structLatticeElement.html">LatticeElement</a> <a class="code" href="structLatticeElement.html#260c3631fc51e216ccbed10e2df772f2">constant</a>(uint64_t c, <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* <a class="code" href="structLatticeElement.html#fb9076844cf7aeb97f205a872b685e1b">definingInstruction</a>) {
<a name="l00056"></a>00056         <span class="keywordflow">return</span> <a class="code" href="structLatticeElement.html#100ba60a126161578eb3a603de93d1eb">LatticeElement</a>(0, <a class="code" href="structLatticeElement.html#fb9076844cf7aeb97f205a872b685e1b">definingInstruction</a>, <span class="keyword">false</span>, c);
<a name="l00057"></a>00057     }
<a name="l00058"></a>00058 
<a name="l00059"></a><a class="code" href="structLatticeElement.html#959696a386346cf3e0375340b65d114c">00059</a>     <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="structLatticeElement.html#959696a386346cf3e0375340b65d114c">operator==</a>(<span class="keyword">const</span> <a class="code" href="structLatticeElement.html">LatticeElement</a>&amp; a, <span class="keyword">const</span> <a class="code" href="structLatticeElement.html">LatticeElement</a>&amp; b) {
<a name="l00060"></a>00060         <span class="keywordflow">if</span> (a.<a class="code" href="structLatticeElement.html#4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a> != b.<a class="code" href="structLatticeElement.html#4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00061"></a>00061         <span class="keywordflow">if</span> (a.<a class="code" href="structLatticeElement.html#4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00062"></a>00062         <span class="keywordflow">return</span> a.<a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a> == b.<a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a> &amp;&amp; (a.<a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a> == 0 || a.<a class="code" href="structLatticeElement.html#6bfb90dd4b9e80a03cdef7d2f55d78f8">negate</a> == b.<a class="code" href="structLatticeElement.html#6bfb90dd4b9e80a03cdef7d2f55d78f8">negate</a>) &amp;&amp; a.<a class="code" href="structLatticeElement.html#5f7046b6efe5660c07b84883ee26a4cc">offset</a> == b.<a class="code" href="structLatticeElement.html#5f7046b6efe5660c07b84883ee26a4cc">offset</a>;
<a name="l00063"></a>00063     }
<a name="l00064"></a><a class="code" href="structLatticeElement.html#3b8f0baf79c98d6faa3aa6c6a8540806">00064</a>     <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="structLatticeElement.html#3b8f0baf79c98d6faa3aa6c6a8540806">operator&lt;</a>(<span class="keyword">const</span> <a class="code" href="structLatticeElement.html">LatticeElement</a>&amp; a, <span class="keyword">const</span> <a class="code" href="structLatticeElement.html">LatticeElement</a>&amp; b) { <span class="comment">// Arbitrary order</span>
<a name="l00065"></a>00065         <span class="keywordflow">if</span> (a.<a class="code" href="structLatticeElement.html#4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a> &lt; b.<a class="code" href="structLatticeElement.html#4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00066"></a>00066         <span class="keywordflow">if</span> (b.<a class="code" href="structLatticeElement.html#4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a> &lt; a.<a class="code" href="structLatticeElement.html#4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00067"></a>00067         <span class="keywordflow">if</span> (a.<a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a> &lt; b.<a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a>) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00068"></a>00068         <span class="keywordflow">if</span> (b.<a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a> &lt; a.<a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00069"></a>00069         <span class="keywordflow">if</span> (a.<a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a> != 0 &amp;&amp; a.<a class="code" href="structLatticeElement.html#6bfb90dd4b9e80a03cdef7d2f55d78f8">negate</a> &lt; b.<a class="code" href="structLatticeElement.html#6bfb90dd4b9e80a03cdef7d2f55d78f8">negate</a>) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00070"></a>00070         <span class="keywordflow">if</span> (a.<a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a> != 0 &amp;&amp; b.<a class="code" href="structLatticeElement.html#6bfb90dd4b9e80a03cdef7d2f55d78f8">negate</a> &lt; a.<a class="code" href="structLatticeElement.html#6bfb90dd4b9e80a03cdef7d2f55d78f8">negate</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00071"></a>00071         <span class="keywordflow">return</span> a.<a class="code" href="structLatticeElement.html#5f7046b6efe5660c07b84883ee26a4cc">offset</a> &lt; b.<a class="code" href="structLatticeElement.html#5f7046b6efe5660c07b84883ee26a4cc">offset</a>;
<a name="l00072"></a>00072     }
<a name="l00073"></a><a class="code" href="structLatticeElement.html#1fa61bab0a3202eb472eae5e8e989f16">00073</a>     <span class="keywordtype">void</span> <a class="code" href="structLatticeElement.html#1fa61bab0a3202eb472eae5e8e989f16">merge</a>(<span class="keyword">const</span> <a class="code" href="structLatticeElement.html">LatticeElement</a>&amp; elt, uint64_t newName, <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* def) {
<a name="l00074"></a>00074         <span class="keywordflow">if</span> (elt.<a class="code" href="structLatticeElement.html#4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>) <span class="keywordflow">return</span>;
<a name="l00075"></a>00075         <span class="keywordflow">if</span> (this-&gt;isTop) {
<a name="l00076"></a>00076             *<span class="keyword">this</span> = elt;
<a name="l00077"></a>00077             <span class="keywordflow">return</span>;
<a name="l00078"></a>00078         }
<a name="l00079"></a>00079         <span class="keywordflow">if</span> (*<span class="keyword">this</span> == elt)
<a name="l00080"></a>00080             <span class="keywordflow">return</span>;
<a name="l00081"></a>00081         this-&gt;<a class="code" href="structLatticeElement.html#4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a> = <span class="keyword">false</span>;
<a name="l00082"></a>00082         this-&gt;<a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a> = newName;
<a name="l00083"></a>00083         this-&gt;<a class="code" href="structLatticeElement.html#fb9076844cf7aeb97f205a872b685e1b">definingInstruction</a> = def;
<a name="l00084"></a>00084         this-&gt;<a class="code" href="structLatticeElement.html#6bfb90dd4b9e80a03cdef7d2f55d78f8">negate</a> = <span class="keyword">false</span>;
<a name="l00085"></a>00085         this-&gt;<a class="code" href="structLatticeElement.html#5f7046b6efe5660c07b84883ee26a4cc">offset</a> = 0;
<a name="l00086"></a>00086         <span class="keywordflow">return</span>;
<a name="l00087"></a>00087     }
<a name="l00088"></a>00088 };
<a name="l00089"></a>00089 
<a name="l00096"></a>00096 <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00097"></a><a class="code" href="findConstants_8h.html#957c50b42a7680621b6826e9867f0136">00097</a> std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, const LatticeElement&lt;Len&gt;&amp; e)
<a name="l00098"></a>00098 {
<a name="l00099"></a>00099     <span class="keywordflow">if</span> (e.isTop) {
<a name="l00100"></a>00100         o &lt;&lt; <span class="stringliteral">"&lt;top&gt;"</span>;
<a name="l00101"></a>00101     } <span class="keywordflow">else</span> {
<a name="l00102"></a>00102         uint64_t sign_bit = (uint64_t)1 &lt;&lt; (Len-1);  <span class="comment">/* e.g., 80000000 */</span>
<a name="l00103"></a>00103         uint64_t val_mask = sign_bit - 1;            <span class="comment">/* e.g., 7fffffff */</span>
<a name="l00104"></a>00104         uint64_t negative = (e.offset &amp; sign_bit) ? (~e.offset &amp; val_mask) + 1 : 0; <span class="comment">/*magnitude of negative value*/</span>
<a name="l00105"></a>00105 
<a name="l00106"></a>00106         <span class="keywordflow">if</span> (e.name!=0) {
<a name="l00107"></a>00107             <span class="comment">/* This is a named value rather than a constant. */</span>
<a name="l00108"></a>00108             <span class="keyword">const</span> <span class="keywordtype">char</span> *sign = e.negate ? <span class="stringliteral">"-"</span> : <span class="stringliteral">""</span>;
<a name="l00109"></a>00109             o &lt;&lt;sign &lt;&lt;<span class="stringliteral">"v"</span> &lt;&lt;std::dec &lt;&lt;e.name;
<a name="l00110"></a>00110             <span class="keywordflow">if</span> (negative) {
<a name="l00111"></a>00111                 o &lt;&lt;<span class="stringliteral">"-0x"</span> &lt;&lt;std::hex &lt;&lt;negative;
<a name="l00112"></a>00112             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (e.offset) {
<a name="l00113"></a>00113                 o &lt;&lt;<span class="stringliteral">"+0x"</span> &lt;&lt;std::hex &lt;&lt;e.offset;
<a name="l00114"></a>00114             }
<a name="l00115"></a>00115         } <span class="keywordflow">else</span> {
<a name="l00116"></a>00116             <span class="comment">/* This is a constant */</span>
<a name="l00117"></a>00117             ROSE_ASSERT(!e.negate);
<a name="l00118"></a>00118             o  &lt;&lt;<span class="stringliteral">"0x"</span> &lt;&lt;std::hex &lt;&lt;e.offset;
<a name="l00119"></a>00119             <span class="keywordflow">if</span> (negative)
<a name="l00120"></a>00120                 o &lt;&lt;<span class="stringliteral">" (-0x"</span> &lt;&lt;std::hex &lt;&lt;negative &lt;&lt;<span class="stringliteral">")"</span>;
<a name="l00121"></a>00121         }
<a name="l00122"></a>00122         <span class="keywordflow">if</span> (e.definingInstruction!=NULL)
<a name="l00123"></a>00123             o &lt;&lt; <span class="stringliteral">" [from "</span> &lt;&lt; <a class="code" href="AsmUnparser__compat_8h.html#3b979292833b85f5b059b2893250453c">unparseInstructionWithAddress</a>(e.definingInstruction) &lt;&lt; <span class="stringliteral">"]"</span>;
<a name="l00124"></a>00124     }
<a name="l00125"></a>00125     <span class="keywordflow">return</span> o;
<a name="l00126"></a>00126 }
<a name="l00127"></a>00127 
<a name="l00129"></a>00129 <span class="keyword">extern</span> uint64_t <a class="code" href="findConstants_8h.html#23853ba1fee40422cf7195fc41da1da6">xvarNameCounter</a>;
<a name="l00130"></a>00130 
<a name="l00133"></a>00133 <span class="keyword">extern</span> <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* <a class="code" href="findConstants_8h.html#95f018a40d9bdcb7c342a55a4503c9c1">currentInstruction</a>;
<a name="l00134"></a>00134 
<a name="l00135"></a>00135 <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00136"></a><a class="code" href="structXVariable.html">00136</a> <span class="keyword">struct </span><a class="code" href="structXVariable.html">XVariable</a>: <span class="keyword">public</span> <a class="code" href="classVariable.html">Variable</a> { <span class="comment">/*Variable defined in flowEquations.h*/</span>
<a name="l00137"></a><a class="code" href="structXVariable.html#1befcc7f34e931bf2b52a233e5693d70">00137</a>     <a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;</a> <a class="code" href="structXVariable.html#1befcc7f34e931bf2b52a233e5693d70">value</a>;
<a name="l00138"></a><a class="code" href="structXVariable.html#0462c7dbcdfdd6364af9d251b5cbbca3">00138</a>     uint64_t <a class="code" href="structXVariable.html#0462c7dbcdfdd6364af9d251b5cbbca3">myName</a>;
<a name="l00139"></a><a class="code" href="structXVariable.html#01f0d45c772847833cbe1afdf9fffc6b">00139</a>     <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* <a class="code" href="structXVariable.html#01f0d45c772847833cbe1afdf9fffc6b">def</a>;
<a name="l00140"></a><a class="code" href="structXVariable.html#dba4bf2707127da32af3f21caa9639ac">00140</a>     <a class="code" href="structXVariable.html#dba4bf2707127da32af3f21caa9639ac">XVariable</a>()
<a name="l00141"></a>00141         : <a class="code" href="structXVariable.html#1befcc7f34e931bf2b52a233e5693d70">value</a>(), <a class="code" href="structXVariable.html#0462c7dbcdfdd6364af9d251b5cbbca3">myName</a>(++<a class="code" href="findConstants_8h.html#23853ba1fee40422cf7195fc41da1da6">xvarNameCounter</a>), <a class="code" href="structXVariable.html#01f0d45c772847833cbe1afdf9fffc6b">def</a>(<a class="code" href="findConstants_8h.html#95f018a40d9bdcb7c342a55a4503c9c1">currentInstruction</a>)
<a name="l00142"></a>00142         {}
<a name="l00143"></a>00143 
<a name="l00145"></a><a class="code" href="structXVariable.html#df3fb4f7f70bf0933ea35fae24d60fb4">00145</a>     <span class="keywordtype">void</span> <a class="code" href="structXVariable.html#df3fb4f7f70bf0933ea35fae24d60fb4">set</a>(<span class="keyword">const</span> <a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;</a>&amp; le) {
<a name="l00146"></a>00146         <a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;</a> newValue = <a class="code" href="structXVariable.html#1befcc7f34e931bf2b52a233e5693d70">value</a>;
<a name="l00147"></a>00147         newValue.<a class="code" href="structLatticeElement.html#1fa61bab0a3202eb472eae5e8e989f16">merge</a>(le, <a class="code" href="structXVariable.html#0462c7dbcdfdd6364af9d251b5cbbca3">myName</a>, <a class="code" href="structXVariable.html#01f0d45c772847833cbe1afdf9fffc6b">def</a>);
<a name="l00148"></a>00148         <span class="keywordflow">if</span> (<a class="code" href="structXVariable.html#1befcc7f34e931bf2b52a233e5693d70">value</a> == newValue)
<a name="l00149"></a>00149             <span class="keywordflow">return</span>;
<a name="l00150"></a>00150         <a class="code" href="structXVariable.html#1befcc7f34e931bf2b52a233e5693d70">value</a> = newValue;
<a name="l00151"></a>00151         this-&gt;<a class="code" href="classVariable.html#76683fcd725489142f0397aa957a966d">pushChanges</a>();
<a name="l00152"></a>00152     }
<a name="l00153"></a>00153 
<a name="l00155"></a><a class="code" href="structXVariable.html#e4cfe6763f2180ecf193537649b4cd5c">00155</a>     <a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;</a> <a class="code" href="structXVariable.html#e4cfe6763f2180ecf193537649b4cd5c">get</a>()<span class="keyword"> const </span>{
<a name="l00156"></a>00156         <span class="keywordflow">return</span> <a class="code" href="structXVariable.html#1befcc7f34e931bf2b52a233e5693d70">value</a>;
<a name="l00157"></a>00157     }
<a name="l00158"></a>00158 };
<a name="l00159"></a>00159 
<a name="l00161"></a>00161 <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00162"></a><a class="code" href="structXVariablePtr.html">00162</a> <span class="keyword">struct </span><a class="code" href="structXVariablePtr.html">XVariablePtr</a> {
<a name="l00163"></a><a class="code" href="structXVariablePtr.html#23a0566e27ca0439deaf2acc3f2e032b">00163</a>     <a class="code" href="structXVariable.html">XVariable&lt;Len&gt;</a>* <a class="code" href="structXVariablePtr.html#23a0566e27ca0439deaf2acc3f2e032b">var</a>;
<a name="l00164"></a><a class="code" href="structXVariablePtr.html#730bc0bbb478a8b005ceae0dd4900ff9">00164</a>     <a class="code" href="structXVariablePtr.html#730bc0bbb478a8b005ceae0dd4900ff9">XVariablePtr</a>()
<a name="l00165"></a>00165         : <a class="code" href="structXVariablePtr.html#23a0566e27ca0439deaf2acc3f2e032b">var</a>(NULL)
<a name="l00166"></a>00166         {}
<a name="l00167"></a><a class="code" href="structXVariablePtr.html#3c5c912b2bf87aa05c686359faa50994">00167</a>     <a class="code" href="structXVariablePtr.html#730bc0bbb478a8b005ceae0dd4900ff9">XVariablePtr</a>(<a class="code" href="structXVariable.html">XVariable&lt;Len&gt;</a>* <a class="code" href="structXVariablePtr.html#23a0566e27ca0439deaf2acc3f2e032b">var</a>)
<a name="l00168"></a>00168         : <a class="code" href="structXVariablePtr.html#23a0566e27ca0439deaf2acc3f2e032b">var</a>(<a class="code" href="structXVariablePtr.html#23a0566e27ca0439deaf2acc3f2e032b">var</a>)
<a name="l00169"></a>00169         {}
<a name="l00170"></a><a class="code" href="structXVariablePtr.html#33cf436fb15a9b4f487da146537745b2">00170</a>     operator XVariable&lt;Len&gt;*()<span class="keyword"> const </span>{
<a name="l00171"></a>00171         <span class="keywordflow">return</span> <a class="code" href="structXVariablePtr.html#23a0566e27ca0439deaf2acc3f2e032b">var</a>;
<a name="l00172"></a>00172     }
<a name="l00173"></a><a class="code" href="structXVariablePtr.html#b4a5bff4958b2bc6e64b004249f8edd2">00173</a>     <a class="code" href="structXVariable.html">XVariable&lt;Len&gt;</a>* <a class="code" href="structXVariablePtr.html#b4a5bff4958b2bc6e64b004249f8edd2">operator-&gt;</a>()<span class="keyword"> const </span>{
<a name="l00174"></a>00174         <span class="keywordflow">return</span> <a class="code" href="structXVariablePtr.html#23a0566e27ca0439deaf2acc3f2e032b">var</a>;
<a name="l00175"></a>00175     }
<a name="l00176"></a><a class="code" href="structXVariablePtr.html#a88822e4d1dc3cdb2b6e58d73f5e2e34">00176</a>     <span class="keyword">static</span> <a class="code" href="structXVariablePtr.html">XVariablePtr</a> <a class="code" href="structXVariablePtr.html#a88822e4d1dc3cdb2b6e58d73f5e2e34">bottom</a>() {
<a name="l00177"></a>00177         <span class="keyword">struct </span>BottomConstraint: <span class="keyword">public</span> <a class="code" href="classConstraint.html">Constraint</a> {
<a name="l00178"></a>00178             <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> <a class="code" href="structXVariablePtr.html#23a0566e27ca0439deaf2acc3f2e032b">var</a>;
<a name="l00179"></a>00179             BottomConstraint(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> <a class="code" href="structXVariablePtr.html#23a0566e27ca0439deaf2acc3f2e032b">var</a>)
<a name="l00180"></a>00180                 : <a class="code" href="structXVariablePtr.html#23a0566e27ca0439deaf2acc3f2e032b">var</a>(<a class="code" href="structXVariablePtr.html#23a0566e27ca0439deaf2acc3f2e032b">var</a>)
<a name="l00181"></a>00181                 {}
<a name="l00182"></a>00182             <span class="keyword">virtual</span> <span class="keywordtype">void</span> run()<span class="keyword"> const </span>{
<a name="l00183"></a>00183                 <a class="code" href="structXVariablePtr.html#23a0566e27ca0439deaf2acc3f2e032b">var</a>-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;::nonconstant</a>(<a class="code" href="structXVariablePtr.html#23a0566e27ca0439deaf2acc3f2e032b">var</a>-&gt;myName, <a class="code" href="structXVariablePtr.html#23a0566e27ca0439deaf2acc3f2e032b">var</a>-&gt;def));
<a name="l00184"></a>00184             }
<a name="l00185"></a>00185             <span class="keyword">virtual</span> <span class="keywordtype">void</span> markDependencies() {}
<a name="l00186"></a>00186         };
<a name="l00187"></a>00187         <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> <a class="code" href="structXVariablePtr.html#23a0566e27ca0439deaf2acc3f2e032b">var</a> = <span class="keyword">new</span> <a class="code" href="structXVariable.html">XVariable&lt;Len&gt;</a>();
<a name="l00188"></a>00188         (<span class="keyword">new</span> BottomConstraint(<a class="code" href="structXVariablePtr.html#23a0566e27ca0439deaf2acc3f2e032b">var</a>))-&gt;activate();
<a name="l00189"></a>00189         <span class="keywordflow">return</span> <a class="code" href="structXVariablePtr.html#23a0566e27ca0439deaf2acc3f2e032b">var</a>;
<a name="l00190"></a>00190     }
<a name="l00191"></a>00191 };
<a name="l00192"></a>00192 
<a name="l00193"></a>00193 <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00194"></a><a class="code" href="findConstants_8h.html#a49c86243cb0984e3496120e3689c957">00194</a> std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, XVariablePtr&lt;Len&gt; v) {
<a name="l00195"></a>00195     o &lt;&lt; v-&gt;value;
<a name="l00196"></a>00196     <span class="keywordflow">return</span> o;
<a name="l00197"></a>00197 }
<a name="l00198"></a>00198 
<a name="l00201"></a><a class="code" href="structMemoryWrite.html">00201</a> <span class="keyword">struct </span><a class="code" href="structMemoryWrite.html">MemoryWrite</a> {
<a name="l00202"></a><a class="code" href="structMemoryWrite.html#dcf4704cebd9c4531cd9700527988b5f">00202</a>     <a class="code" href="structLatticeElement.html">LatticeElement&lt;32&gt;</a> <a class="code" href="structMemoryWrite.html#dcf4704cebd9c4531cd9700527988b5f">address</a>;
<a name="l00203"></a><a class="code" href="structMemoryWrite.html#f1c2a8cf93c214c396251533c66b5296">00203</a>     <a class="code" href="structLatticeElement.html">LatticeElement&lt;32&gt;</a> <a class="code" href="structMemoryWrite.html#f1c2a8cf93c214c396251533c66b5296">data</a>;
<a name="l00204"></a><a class="code" href="structMemoryWrite.html#35e235bb9134cc729b8a5174e13a9af1">00204</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structMemoryWrite.html#35e235bb9134cc729b8a5174e13a9af1">len</a>;
<a name="l00205"></a><a class="code" href="structMemoryWrite.html#e127a0b2e42c26626e060b79fd97df6b">00205</a>     <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="structMemoryWrite.html#e127a0b2e42c26626e060b79fd97df6b">operator==</a>(<span class="keyword">const</span> <a class="code" href="structMemoryWrite.html">MemoryWrite</a>&amp; a, <span class="keyword">const</span> <a class="code" href="structMemoryWrite.html">MemoryWrite</a>&amp; b) {
<a name="l00206"></a>00206         <span class="keywordflow">return</span> a.<a class="code" href="structMemoryWrite.html#dcf4704cebd9c4531cd9700527988b5f">address</a> == b.<a class="code" href="structMemoryWrite.html#dcf4704cebd9c4531cd9700527988b5f">address</a> &amp;&amp; a.<a class="code" href="structMemoryWrite.html#f1c2a8cf93c214c396251533c66b5296">data</a> == b.<a class="code" href="structMemoryWrite.html#f1c2a8cf93c214c396251533c66b5296">data</a> &amp;&amp; a.<a class="code" href="structMemoryWrite.html#35e235bb9134cc729b8a5174e13a9af1">len</a> == b.<a class="code" href="structMemoryWrite.html#35e235bb9134cc729b8a5174e13a9af1">len</a>;
<a name="l00207"></a>00207     }
<a name="l00208"></a><a class="code" href="structMemoryWrite.html#6bdd4bc6845b262ad56566b5fd6b5f5c">00208</a>     <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="structMemoryWrite.html#6bdd4bc6845b262ad56566b5fd6b5f5c">operator&lt;</a>(<span class="keyword">const</span> <a class="code" href="structMemoryWrite.html">MemoryWrite</a>&amp; a, <span class="keyword">const</span> <a class="code" href="structMemoryWrite.html">MemoryWrite</a>&amp; b) {
<a name="l00209"></a>00209         <span class="keywordflow">return</span> a.<a class="code" href="structMemoryWrite.html#dcf4704cebd9c4531cd9700527988b5f">address</a> &lt; b.<a class="code" href="structMemoryWrite.html#dcf4704cebd9c4531cd9700527988b5f">address</a>;
<a name="l00210"></a>00210     }
<a name="l00211"></a>00211 };
<a name="l00212"></a>00212 
<a name="l00213"></a>00213 <span class="keywordtype">bool</span> <a class="code" href="findConstants_8h.html#d533e286da133784685293ce0a44ee0f">mayAlias</a>(<span class="keyword">const</span> <a class="code" href="structMemoryWrite.html">MemoryWrite</a>&amp;, <span class="keyword">const</span> <a class="code" href="structMemoryWrite.html">MemoryWrite</a>&amp;);
<a name="l00214"></a>00214 <span class="keywordtype">bool</span> <a class="code" href="findConstants_8h.html#3d2a6c2edc28257d61a10d11cf67c5ec">mustAlias</a>(<span class="keyword">const</span> <a class="code" href="structMemoryWrite.html">MemoryWrite</a>&amp;, <span class="keyword">const</span> <a class="code" href="structMemoryWrite.html">MemoryWrite</a>&amp;);
<a name="l00215"></a>00215 
<a name="l00216"></a>00216 <span class="keyword">template</span> &lt;size_t From, size_t To&gt;
<a name="l00217"></a>00217 <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;To&gt;</a> <a class="code" href="findConstants_8h.html#5e45e0632183f44d7bc6dd40f1854340">unsignedExtend</a>(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;From&gt;</a>);
<a name="l00218"></a>00218 
<a name="l00219"></a>00219 <span class="keyword">template</span> &lt;size_t From, size_t To, size_t Len&gt;
<a name="l00220"></a>00220 <a class="code" href="structXVariablePtr.html">XVariablePtr</a>&lt;To - From&gt; <a class="code" href="findConstants_8h.html#95eaaa03e4ec3b28e19e249d96358ea1">extract</a>(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a>);
<a name="l00221"></a>00221 
<a name="l00223"></a>00223 <span class="comment">/* FIXME: Why are addresses and data always 32 bits? Will this work for a 64-bit architecture? [RPM 2009-02-03] */</span>
<a name="l00224"></a><a class="code" href="structMemoryWriteSet.html">00224</a> <span class="keyword">struct </span><a class="code" href="structMemoryWriteSet.html">MemoryWriteSet</a> {
<a name="l00225"></a><a class="code" href="structMemoryWriteSet.html#26845f2d2d0f83b00c0156a1642de9c0">00225</a>     <span class="keywordtype">bool</span> <a class="code" href="structMemoryWriteSet.html#26845f2d2d0f83b00c0156a1642de9c0">isTop</a>;
<a name="l00226"></a><a class="code" href="structMemoryWriteSet.html#ff1aab41effbd5b65c11bebd3e9294ca">00226</a>     std::vector&lt;MemoryWrite&gt; <a class="code" href="structMemoryWriteSet.html#ff1aab41effbd5b65c11bebd3e9294ca">writes</a>;         <span class="comment">/* Always sorted by address */</span>
<a name="l00227"></a>00227 
<a name="l00228"></a><a class="code" href="structMemoryWriteSet.html#e1ade7c6876c844d60df9bae3089d9e0">00228</a>     <a class="code" href="structMemoryWriteSet.html#e1ade7c6876c844d60df9bae3089d9e0">MemoryWriteSet</a>()
<a name="l00229"></a>00229         : <a class="code" href="structMemoryWriteSet.html#26845f2d2d0f83b00c0156a1642de9c0">isTop</a>(true), <a class="code" href="structMemoryWriteSet.html#ff1aab41effbd5b65c11bebd3e9294ca">writes</a>()
<a name="l00230"></a>00230         {}
<a name="l00231"></a>00231 
<a name="l00233"></a><a class="code" href="structMemoryWriteSet.html#0ffbc1b898a737117ce4d5210ba314a7">00233</a>     <span class="keywordtype">void</span> <a class="code" href="structMemoryWriteSet.html#0ffbc1b898a737117ce4d5210ba314a7">addWrite</a>(<a class="code" href="structLatticeElement.html">LatticeElement&lt;32&gt;</a> address, <a class="code" href="structLatticeElement.html">LatticeElement&lt;32&gt;</a> data, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len) {
<a name="l00234"></a>00234         <a class="code" href="structMemoryWriteSet.html#26845f2d2d0f83b00c0156a1642de9c0">isTop</a> = <span class="keyword">false</span>;
<a name="l00235"></a>00235         <a class="code" href="structMemoryWrite.html">MemoryWrite</a> mw;
<a name="l00236"></a>00236         mw.<a class="code" href="structMemoryWrite.html#dcf4704cebd9c4531cd9700527988b5f">address</a> = address;
<a name="l00237"></a>00237         mw.<a class="code" href="structMemoryWrite.html#f1c2a8cf93c214c396251533c66b5296">data</a> = data;
<a name="l00238"></a>00238         mw.<a class="code" href="structMemoryWrite.html#35e235bb9134cc729b8a5174e13a9af1">len</a> = len;
<a name="l00239"></a>00239         std::vector&lt;MemoryWrite&gt; newWrites;
<a name="l00240"></a>00240         <span class="keywordflow">for</span> (size_t i = 0; i &lt; <a class="code" href="structMemoryWriteSet.html#ff1aab41effbd5b65c11bebd3e9294ca">writes</a>.size(); ++i) {
<a name="l00241"></a>00241             <span class="keywordflow">if</span> (!<a class="code" href="findConstants_8h.html#d533e286da133784685293ce0a44ee0f">mayAlias</a>(<a class="code" href="structMemoryWriteSet.html#ff1aab41effbd5b65c11bebd3e9294ca">writes</a>[i], mw))
<a name="l00242"></a>00242                 newWrites.push_back(<a class="code" href="structMemoryWriteSet.html#ff1aab41effbd5b65c11bebd3e9294ca">writes</a>[i]);
<a name="l00243"></a>00243         }
<a name="l00244"></a>00244         newWrites.push_back(mw);
<a name="l00245"></a>00245         <a class="code" href="structMemoryWriteSet.html#ff1aab41effbd5b65c11bebd3e9294ca">writes</a> = newWrites;
<a name="l00246"></a>00246         std::sort(<a class="code" href="structMemoryWriteSet.html#ff1aab41effbd5b65c11bebd3e9294ca">writes</a>.begin(), <a class="code" href="structMemoryWriteSet.html#ff1aab41effbd5b65c11bebd3e9294ca">writes</a>.end());
<a name="l00247"></a>00247     }
<a name="l00248"></a>00248 
<a name="l00250"></a>00250     <span class="keyword">template</span> &lt;size_t Len&gt; <span class="comment">// In bits</span>
<a name="l00251"></a><a class="code" href="structMemoryWriteSet.html#00d40ef766dfec837e30794fed35ec85">00251</a>     <span class="keywordtype">bool</span> <a class="code" href="structMemoryWriteSet.html#00d40ef766dfec837e30794fed35ec85">getValueAtAddress</a>(<a class="code" href="structLatticeElement.html">LatticeElement&lt;32&gt;</a> address, <a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;</a>&amp; result, uint32_t resultName,
<a name="l00252"></a>00252                            <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* resultDef)<span class="keyword"> const </span>{
<a name="l00253"></a>00253         <span class="comment">/* Construct the MemoryWrite object for the address in question since it's needed by mustAlias() */</span>
<a name="l00254"></a>00254         <a class="code" href="structMemoryWrite.html">MemoryWrite</a> mw;
<a name="l00255"></a>00255         mw.<a class="code" href="structMemoryWrite.html#dcf4704cebd9c4531cd9700527988b5f">address</a> = address;
<a name="l00256"></a>00256         mw.<a class="code" href="structMemoryWrite.html#f1c2a8cf93c214c396251533c66b5296">data</a> = <a class="code" href="structLatticeElement.html#260c3631fc51e216ccbed10e2df772f2">LatticeElement&lt;32&gt;::constant</a>(0, resultDef);
<a name="l00257"></a>00257         mw.<a class="code" href="structMemoryWrite.html#35e235bb9134cc729b8a5174e13a9af1">len</a> = Len / 8;
<a name="l00258"></a>00258 
<a name="l00259"></a>00259         <span class="comment">/* Scan vector until we find a match and then return that value. */</span>
<a name="l00260"></a>00260         <span class="keywordflow">for</span> (size_t i = 0; i &lt; <a class="code" href="structMemoryWriteSet.html#ff1aab41effbd5b65c11bebd3e9294ca">writes</a>.size(); ++i) {
<a name="l00261"></a>00261             <span class="keywordflow">if</span> (<a class="code" href="findConstants_8h.html#3d2a6c2edc28257d61a10d11cf67c5ec">mustAlias</a>(<a class="code" href="structMemoryWriteSet.html#ff1aab41effbd5b65c11bebd3e9294ca">writes</a>[i], mw)) {
<a name="l00262"></a>00262                 <span class="comment">//std::cout &lt;&lt; "Found data " &lt;&lt; writes[i].data &lt;&lt; " for address " &lt;&lt; address &lt;&lt; std::endl;</span>
<a name="l00263"></a>00263                 <span class="keyword">const</span> <a class="code" href="structLatticeElement.html">LatticeElement&lt;32&gt;</a>&amp; data = <a class="code" href="structMemoryWriteSet.html#ff1aab41effbd5b65c11bebd3e9294ca">writes</a>[i].data;
<a name="l00264"></a>00264                 result = <a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;</a>(data.<a class="code" href="structLatticeElement.html#4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>, data.<a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a>, data.<a class="code" href="structLatticeElement.html#fb9076844cf7aeb97f205a872b685e1b">definingInstruction</a>, data.<a class="code" href="structLatticeElement.html#6bfb90dd4b9e80a03cdef7d2f55d78f8">negate</a>, data.<a class="code" href="structLatticeElement.html#5f7046b6efe5660c07b84883ee26a4cc">offset</a>);
<a name="l00265"></a>00265                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00266"></a>00266             }
<a name="l00267"></a>00267         }
<a name="l00268"></a>00268 
<a name="l00269"></a>00269         <span class="comment">/* No match found */</span>
<a name="l00270"></a>00270         result = <a class="code" href="structMemoryWriteSet.html#26845f2d2d0f83b00c0156a1642de9c0">isTop</a> ? <a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;</a>() : <a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;::nonconstant</a>(resultName, resultDef);
<a name="l00271"></a>00271         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273 
<a name="l00274"></a><a class="code" href="structMemoryWriteSet.html#5f96f9bfa7cc7ca000e22c9eb4b78261">00274</a>     <span class="keyword">static</span> <a class="code" href="structMemoryWriteSet.html">MemoryWriteSet</a> <a class="code" href="structMemoryWriteSet.html#5f96f9bfa7cc7ca000e22c9eb4b78261">bottom</a>() {
<a name="l00275"></a>00275         <a class="code" href="structMemoryWriteSet.html">MemoryWriteSet</a> mws;
<a name="l00276"></a>00276         mws.<a class="code" href="structMemoryWriteSet.html#26845f2d2d0f83b00c0156a1642de9c0">isTop</a> = <span class="keyword">false</span>;
<a name="l00277"></a>00277         mws.<a class="code" href="structMemoryWriteSet.html#ff1aab41effbd5b65c11bebd3e9294ca">writes</a>.clear();
<a name="l00278"></a>00278         <span class="keywordflow">return</span> mws;
<a name="l00279"></a>00279     }
<a name="l00280"></a>00280 
<a name="l00281"></a><a class="code" href="structMemoryWriteSet.html#839a6ff0937b5acae8b718c498a66e05">00281</a>     <span class="keywordtype">bool</span> <a class="code" href="structMemoryWriteSet.html#839a6ff0937b5acae8b718c498a66e05">mergeIn</a>(<span class="keyword">const</span> <a class="code" href="structMemoryWriteSet.html">MemoryWriteSet</a>&amp; o) { <span class="comment">// Returns to determine whether changes were made</span>
<a name="l00282"></a>00282         <span class="keywordflow">if</span> (o.<a class="code" href="structMemoryWriteSet.html#26845f2d2d0f83b00c0156a1642de9c0">isTop</a>)
<a name="l00283"></a>00283             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00284"></a>00284         <span class="keywordflow">if</span> (this-&gt;isTop) {
<a name="l00285"></a>00285             *<span class="keyword">this</span> = o;
<a name="l00286"></a>00286             <span class="keywordflow">return</span> !o.<a class="code" href="structMemoryWriteSet.html#26845f2d2d0f83b00c0156a1642de9c0">isTop</a>;
<a name="l00287"></a>00287         }
<a name="l00288"></a>00288         <span class="keywordtype">bool</span> result = !<a class="code" href="structMemoryWriteSet.html#ff1aab41effbd5b65c11bebd3e9294ca">writes</a>.empty();
<a name="l00289"></a>00289         *<span class="keyword">this</span> = <a class="code" href="structMemoryWriteSet.html#5f96f9bfa7cc7ca000e22c9eb4b78261">bottom</a>(); <span class="comment">// FIXME [JJW]</span>
<a name="l00290"></a>00290         <span class="keywordflow">return</span> result;
<a name="l00291"></a>00291     }
<a name="l00292"></a>00292 
<a name="l00293"></a><a class="code" href="structMemoryWriteSet.html#f87f4e252204fad19b236b5a076803b6">00293</a>     <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="structMemoryWriteSet.html#f87f4e252204fad19b236b5a076803b6">operator==</a>(<span class="keyword">const</span> <a class="code" href="structMemoryWriteSet.html">MemoryWriteSet</a>&amp; a, <span class="keyword">const</span> <a class="code" href="structMemoryWriteSet.html">MemoryWriteSet</a>&amp; b) {
<a name="l00294"></a>00294         <span class="keywordflow">return</span> a.<a class="code" href="structMemoryWriteSet.html#26845f2d2d0f83b00c0156a1642de9c0">isTop</a> == b.<a class="code" href="structMemoryWriteSet.html#26845f2d2d0f83b00c0156a1642de9c0">isTop</a> &amp;&amp; (a.<a class="code" href="structMemoryWriteSet.html#26845f2d2d0f83b00c0156a1642de9c0">isTop</a> || a.<a class="code" href="structMemoryWriteSet.html#ff1aab41effbd5b65c11bebd3e9294ca">writes</a> == b.<a class="code" href="structMemoryWriteSet.html#ff1aab41effbd5b65c11bebd3e9294ca">writes</a>);
<a name="l00295"></a>00295     }
<a name="l00296"></a>00296 };
<a name="l00297"></a>00297 
<a name="l00298"></a><a class="code" href="structMemoryVariable.html">00298</a> <span class="keyword">struct </span><a class="code" href="structMemoryVariable.html">MemoryVariable</a>: <span class="keyword">public</span> <a class="code" href="classVariable.html">Variable</a> {
<a name="l00299"></a><a class="code" href="structMemoryVariable.html#6a9cd5a38fd49bdf2aabbf8ead3ee0a4">00299</a>     <a class="code" href="structMemoryWriteSet.html">MemoryWriteSet</a> <a class="code" href="structMemoryVariable.html#6a9cd5a38fd49bdf2aabbf8ead3ee0a4">mws</a>;
<a name="l00300"></a><a class="code" href="structMemoryVariable.html#f6875e4d6e185fa0be4d1c74b4c527ef">00300</a>     <a class="code" href="structMemoryVariable.html#f6875e4d6e185fa0be4d1c74b4c527ef">MemoryVariable</a>()
<a name="l00301"></a>00301         : <a class="code" href="structMemoryVariable.html#6a9cd5a38fd49bdf2aabbf8ead3ee0a4">mws</a>()
<a name="l00302"></a>00302         {}
<a name="l00303"></a><a class="code" href="structMemoryVariable.html#00e681d73a045c3f44ce2758f69b75be">00303</a>     <span class="keywordtype">void</span> <a class="code" href="structMemoryVariable.html#00e681d73a045c3f44ce2758f69b75be">set</a>(<span class="keyword">const</span> <a class="code" href="structMemoryWriteSet.html">MemoryWriteSet</a>&amp; s) {
<a name="l00304"></a>00304         <span class="keywordflow">if</span> (<a class="code" href="structMemoryVariable.html#6a9cd5a38fd49bdf2aabbf8ead3ee0a4">mws</a>.<a class="code" href="structMemoryWriteSet.html#839a6ff0937b5acae8b718c498a66e05">mergeIn</a>(s)) this-&gt;pushChanges();
<a name="l00305"></a>00305     }
<a name="l00306"></a><a class="code" href="structMemoryVariable.html#afe7886f04c547485bb7b0fe23d2093b">00306</a>     <span class="keyword">const</span> <a class="code" href="structMemoryWriteSet.html">MemoryWriteSet</a>&amp; <a class="code" href="structMemoryVariable.html#afe7886f04c547485bb7b0fe23d2093b">get</a>()<span class="keyword"> const </span>{
<a name="l00307"></a>00307         <span class="keywordflow">return</span> <a class="code" href="structMemoryVariable.html#6a9cd5a38fd49bdf2aabbf8ead3ee0a4">mws</a>;
<a name="l00308"></a>00308     }
<a name="l00309"></a>00309 };
<a name="l00310"></a>00310 
<a name="l00311"></a>00311 <span class="keyword">template</span> &lt;size_t OutputLen&gt;
<a name="l00312"></a><a class="code" href="structNullaryConstraint.html">00312</a> <span class="keyword">struct </span><a class="code" href="structNullaryConstraint.html">NullaryConstraint</a>: <span class="keyword">public</span> <a class="code" href="classConstraint.html">Constraint</a> {
<a name="l00313"></a><a class="code" href="structNullaryConstraint.html#49fd150def191269619c8b9a7a903f9c">00313</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;OutputLen&gt;</a> <a class="code" href="structNullaryConstraint.html#49fd150def191269619c8b9a7a903f9c">result</a>;
<a name="l00314"></a><a class="code" href="structNullaryConstraint.html#46951471dbc9e2ec46abcb20ee326f77">00314</a>     <a class="code" href="structNullaryConstraint.html#46951471dbc9e2ec46abcb20ee326f77">NullaryConstraint</a>(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;OutputLen&gt;</a> <a class="code" href="structNullaryConstraint.html#49fd150def191269619c8b9a7a903f9c">result</a>): <a class="code" href="structNullaryConstraint.html#49fd150def191269619c8b9a7a903f9c">result</a>(<a class="code" href="structNullaryConstraint.html#49fd150def191269619c8b9a7a903f9c">result</a>) {}
<a name="l00315"></a><a class="code" href="structNullaryConstraint.html#da45762ee5b520957b18db4c17c9084e">00315</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structNullaryConstraint.html#da45762ee5b520957b18db4c17c9084e">run</a>()<span class="keyword"> const </span>{
<a name="l00316"></a>00316         uint64_t newVal = this-&gt;<a class="code" href="structNullaryConstraint.html#8cc9dfa2f454decab7eb5fd2a96eaf11">compute</a>();
<a name="l00317"></a>00317         <a class="code" href="structNullaryConstraint.html#49fd150def191269619c8b9a7a903f9c">result</a>-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;OutputLen&gt;::constant</a>(newVal, <a class="code" href="structNullaryConstraint.html#49fd150def191269619c8b9a7a903f9c">result</a>-&gt;def));
<a name="l00318"></a>00318     }
<a name="l00319"></a><a class="code" href="structNullaryConstraint.html#a078a1003047b3ae11689cd69619855e">00319</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structNullaryConstraint.html#a078a1003047b3ae11689cd69619855e">markDependencies</a>() {}
<a name="l00320"></a>00320     <span class="keyword">virtual</span> uint64_t <a class="code" href="structNullaryConstraint.html#8cc9dfa2f454decab7eb5fd2a96eaf11">compute</a>() <span class="keyword">const </span>= 0;
<a name="l00321"></a>00321 };
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 <span class="keyword">template</span> &lt;size_t InputLen, size_t OutputLen&gt;
<a name="l00324"></a><a class="code" href="structUnaryConstraint.html">00324</a> <span class="keyword">struct </span><a class="code" href="structUnaryConstraint.html">UnaryConstraint</a>: <span class="keyword">public</span> <a class="code" href="classConstraint.html">Constraint</a> {
<a name="l00325"></a><a class="code" href="structUnaryConstraint.html#eb585e2c7c0d5b9d0a124279f6f068d0">00325</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;OutputLen&gt;</a> <a class="code" href="structUnaryConstraint.html#eb585e2c7c0d5b9d0a124279f6f068d0">result</a>;
<a name="l00326"></a><a class="code" href="structUnaryConstraint.html#c400a879600dfa33358fd0450572dec3">00326</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;InputLen&gt;</a> <a class="code" href="structUnaryConstraint.html#c400a879600dfa33358fd0450572dec3">var</a>;
<a name="l00327"></a><a class="code" href="structUnaryConstraint.html#3ecf580e67e7aa19cc0c33f63bee4d5d">00327</a>     <a class="code" href="structUnaryConstraint.html#3ecf580e67e7aa19cc0c33f63bee4d5d">UnaryConstraint</a>(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;OutputLen&gt;</a> <a class="code" href="structUnaryConstraint.html#eb585e2c7c0d5b9d0a124279f6f068d0">result</a>, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;InputLen&gt;</a> <a class="code" href="structUnaryConstraint.html#c400a879600dfa33358fd0450572dec3">var</a>)
<a name="l00328"></a>00328         : <a class="code" href="structUnaryConstraint.html#eb585e2c7c0d5b9d0a124279f6f068d0">result</a>(<a class="code" href="structUnaryConstraint.html#eb585e2c7c0d5b9d0a124279f6f068d0">result</a>), <a class="code" href="structUnaryConstraint.html#c400a879600dfa33358fd0450572dec3">var</a>(<a class="code" href="structUnaryConstraint.html#c400a879600dfa33358fd0450572dec3">var</a>)
<a name="l00329"></a>00329         {}
<a name="l00330"></a><a class="code" href="structUnaryConstraint.html#f56691457ea071d4be7166196b3f9998">00330</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structUnaryConstraint.html#f56691457ea071d4be7166196b3f9998">run</a>()<span class="keyword"> const </span>{
<a name="l00331"></a>00331         <a class="code" href="structLatticeElement.html">LatticeElement&lt;InputLen&gt;</a> le = <a class="code" href="structUnaryConstraint.html#c400a879600dfa33358fd0450572dec3">var</a>-&gt;get();
<a name="l00332"></a>00332         <span class="keywordflow">if</span> (le.<a class="code" href="structLatticeElement.html#4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>) {<a class="code" href="structUnaryConstraint.html#eb585e2c7c0d5b9d0a124279f6f068d0">result</a>-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;OutputLen&gt;</a>()); <span class="keywordflow">return</span>;}
<a name="l00333"></a>00333         <span class="keywordflow">if</span> (le.<a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a> != 0) {<a class="code" href="structUnaryConstraint.html#eb585e2c7c0d5b9d0a124279f6f068d0">result</a>-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;OutputLen&gt;::nonconstant</a>(<a class="code" href="structUnaryConstraint.html#eb585e2c7c0d5b9d0a124279f6f068d0">result</a>-&gt;myName, <a class="code" href="structUnaryConstraint.html#eb585e2c7c0d5b9d0a124279f6f068d0">result</a>-&gt;def)); <span class="keywordflow">return</span>;}
<a name="l00334"></a>00334         uint64_t newVal = this-&gt;<a class="code" href="structUnaryConstraint.html#f43794932a7875a2d67ccc96d880a966">compute</a>(le.<a class="code" href="structLatticeElement.html#5f7046b6efe5660c07b84883ee26a4cc">offset</a>);
<a name="l00335"></a>00335         <a class="code" href="structUnaryConstraint.html#eb585e2c7c0d5b9d0a124279f6f068d0">result</a>-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;OutputLen&gt;::constant</a>(newVal, <a class="code" href="structUnaryConstraint.html#eb585e2c7c0d5b9d0a124279f6f068d0">result</a>-&gt;def));
<a name="l00336"></a>00336     }
<a name="l00337"></a><a class="code" href="structUnaryConstraint.html#ec2e1af9d980149154d8334dc7473926">00337</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structUnaryConstraint.html#ec2e1af9d980149154d8334dc7473926">markDependencies</a>() {
<a name="l00338"></a>00338         <a class="code" href="classConstraint.html#30feaf180bce5c1a0cfeee0be9983a93">addDependency</a>(<a class="code" href="structUnaryConstraint.html#c400a879600dfa33358fd0450572dec3">var</a>);
<a name="l00339"></a>00339     }
<a name="l00340"></a>00340     <span class="keyword">virtual</span> uint64_t <a class="code" href="structUnaryConstraint.html#f43794932a7875a2d67ccc96d880a966">compute</a>(uint64_t a) <span class="keyword">const </span>= 0;
<a name="l00341"></a>00341 };
<a name="l00342"></a>00342 
<a name="l00343"></a><a class="code" href="findConstants_8h.html#e7b82ea56326cd6904040a31de88c3c3">00343</a> <span class="preprocessor">#define UNARY_COMPUTATION(name, InLen, OutLen, Formula)                                                                        \</span>
<a name="l00344"></a>00344 <span class="preprocessor">    XVariablePtr&lt;(OutLen)&gt; name(XVariablePtr&lt;(InLen)&gt; a) {                                                                     \</span>
<a name="l00345"></a>00345 <span class="preprocessor">        XVariablePtr&lt;(OutLen)&gt; result = new XVariable&lt;(OutLen)&gt;();                                                             \</span>
<a name="l00346"></a>00346 <span class="preprocessor">        struct IC: public UnaryConstraint&lt;(InLen), (OutLen)&gt; {                                                                 \</span>
<a name="l00347"></a>00347 <span class="preprocessor">            IC(XVariablePtr&lt;(OutLen)&gt; result, XVariablePtr&lt;(InLen)&gt; var1)                                                      \</span>
<a name="l00348"></a>00348 <span class="preprocessor">                : UnaryConstraint&lt;(InLen), (OutLen)&gt;(result, var1)                                                             \</span>
<a name="l00349"></a>00349 <span class="preprocessor">                {}                                                                                                             \</span>
<a name="l00350"></a>00350 <span class="preprocessor">            virtual uint64_t compute(uint64_t a) const {                                                                       \</span>
<a name="l00351"></a>00351 <span class="preprocessor">                Formula                                                                                                        \</span>
<a name="l00352"></a>00352 <span class="preprocessor">            }                                                                                                                  \</span>
<a name="l00353"></a>00353 <span class="preprocessor">        };                                                                                                                     \</span>
<a name="l00354"></a>00354 <span class="preprocessor">        (new IC(result, a))-&gt;activate();                                                                                       \</span>
<a name="l00355"></a>00355 <span class="preprocessor">        return result;                                                                                                         \</span>
<a name="l00356"></a>00356 <span class="preprocessor">    }</span>
<a name="l00357"></a>00357 <span class="preprocessor"></span>
<a name="l00358"></a><a class="code" href="findConstants_8h.html#fad9707ae789a80804091a4b4cf02255">00358</a> <span class="preprocessor">#define UNARY_COMPUTATION_SPECIAL(name, InLen1, OutLen, Formula)                                                               \</span>
<a name="l00359"></a>00359 <span class="preprocessor">    XVariablePtr&lt;(OutLen)&gt; name(XVariablePtr&lt;(InLen1)&gt; a) {                                                                    \</span>
<a name="l00360"></a>00360 <span class="preprocessor">        XVariablePtr&lt;(OutLen)&gt; result = new XVariable&lt;(OutLen)&gt;();                                                             \</span>
<a name="l00361"></a>00361 <span class="preprocessor">        struct IC: public UnaryConstraint&lt;(InLen1), (OutLen)&gt; {                                                                \</span>
<a name="l00362"></a>00362 <span class="preprocessor">            IC(XVariablePtr&lt;(OutLen)&gt; result, XVariablePtr&lt;(InLen1)&gt; var1)                                                     \</span>
<a name="l00363"></a>00363 <span class="preprocessor">                : UnaryConstraint&lt;(InLen1), (OutLen)&gt;(result, var1)                                                            \</span>
<a name="l00364"></a>00364 <span class="preprocessor">                {}                                                                                                             \</span>
<a name="l00365"></a>00365 <span class="preprocessor">            virtual void run() const {                                                                                         \</span>
<a name="l00366"></a>00366 <span class="preprocessor">                LatticeElement&lt;(InLen1)&gt; le1 = UnaryConstraint&lt;(InLen1), (OutLen)&gt;::var-&gt;get();                                \</span>
<a name="l00367"></a>00367 <span class="preprocessor">                XVariablePtr&lt;(OutLen)&gt; result = UnaryConstraint&lt;(InLen1), (OutLen)&gt;::result;                                   \</span>
<a name="l00368"></a>00368 <span class="preprocessor">                if (le1.isTop) {result-&gt;set(LatticeElement&lt;(OutLen)&gt;()); return;}                                              \</span>
<a name="l00369"></a>00369 <span class="preprocessor">                Formula                                                                                                        \</span>
<a name="l00370"></a>00370 <span class="preprocessor">            }                                                                                                                  \</span>
<a name="l00371"></a>00371 <span class="preprocessor">            virtual uint64_t compute(uint64_t) const {abort();}                                                                \</span>
<a name="l00372"></a>00372 <span class="preprocessor">        };                                                                                                                     \</span>
<a name="l00373"></a>00373 <span class="preprocessor">        (new IC(result, a))-&gt;activate();                                                                                       \</span>
<a name="l00374"></a>00374 <span class="preprocessor">        return result;                                                                                                         \</span>
<a name="l00375"></a>00375 <span class="preprocessor">    }</span>
<a name="l00376"></a>00376 <span class="preprocessor"></span>
<a name="l00377"></a>00377 <span class="keyword">template</span> &lt;size_t InputLen1, size_t InputLen2, size_t OutputLen&gt;
<a name="l00378"></a><a class="code" href="structBinaryConstraint.html">00378</a> <span class="keyword">struct </span><a class="code" href="structBinaryConstraint.html">BinaryConstraint</a>: <span class="keyword">public</span> <a class="code" href="classConstraint.html">Constraint</a> {
<a name="l00379"></a><a class="code" href="structBinaryConstraint.html#d9d52240a0050909996e7adf94ba1540">00379</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;OutputLen&gt;</a> <a class="code" href="structBinaryConstraint.html#d9d52240a0050909996e7adf94ba1540">result</a>;
<a name="l00380"></a><a class="code" href="structBinaryConstraint.html#542b1bd52df0ceca1c8320e1f2048c9f">00380</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;InputLen1&gt;</a> <a class="code" href="structBinaryConstraint.html#542b1bd52df0ceca1c8320e1f2048c9f">var1</a>;
<a name="l00381"></a><a class="code" href="structBinaryConstraint.html#aada355823e276f040a2627de612fd8e">00381</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;InputLen2&gt;</a> <a class="code" href="structBinaryConstraint.html#aada355823e276f040a2627de612fd8e">var2</a>;
<a name="l00382"></a>00382 
<a name="l00383"></a><a class="code" href="structBinaryConstraint.html#26330bf8c82509bf61fe35fdf626aa65">00383</a>     <a class="code" href="structBinaryConstraint.html#26330bf8c82509bf61fe35fdf626aa65">BinaryConstraint</a>(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;OutputLen&gt;</a> <a class="code" href="structBinaryConstraint.html#d9d52240a0050909996e7adf94ba1540">result</a>, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;InputLen1&gt;</a> <a class="code" href="structBinaryConstraint.html#542b1bd52df0ceca1c8320e1f2048c9f">var1</a>, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;InputLen2&gt;</a> <a class="code" href="structBinaryConstraint.html#aada355823e276f040a2627de612fd8e">var2</a>)
<a name="l00384"></a>00384         : <a class="code" href="structBinaryConstraint.html#d9d52240a0050909996e7adf94ba1540">result</a>(<a class="code" href="structBinaryConstraint.html#d9d52240a0050909996e7adf94ba1540">result</a>), <a class="code" href="structBinaryConstraint.html#542b1bd52df0ceca1c8320e1f2048c9f">var1</a>(<a class="code" href="structBinaryConstraint.html#542b1bd52df0ceca1c8320e1f2048c9f">var1</a>), <a class="code" href="structBinaryConstraint.html#aada355823e276f040a2627de612fd8e">var2</a>(<a class="code" href="structBinaryConstraint.html#aada355823e276f040a2627de612fd8e">var2</a>)
<a name="l00385"></a>00385         {}
<a name="l00386"></a>00386 
<a name="l00387"></a><a class="code" href="structBinaryConstraint.html#64afc7dbfb8b656cdc24cff9cd081157">00387</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structBinaryConstraint.html#64afc7dbfb8b656cdc24cff9cd081157">run</a>()<span class="keyword"> const </span>{
<a name="l00388"></a>00388         <a class="code" href="structLatticeElement.html">LatticeElement&lt;InputLen1&gt;</a> le1 = <a class="code" href="structBinaryConstraint.html#542b1bd52df0ceca1c8320e1f2048c9f">var1</a>-&gt;get();
<a name="l00389"></a>00389         <a class="code" href="structLatticeElement.html">LatticeElement&lt;InputLen2&gt;</a> le2 = <a class="code" href="structBinaryConstraint.html#aada355823e276f040a2627de612fd8e">var2</a>-&gt;get();
<a name="l00390"></a>00390         <span class="keywordflow">if</span> (le1.<a class="code" href="structLatticeElement.html#4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a> || le2.<a class="code" href="structLatticeElement.html#4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>) {
<a name="l00391"></a>00391             <a class="code" href="structBinaryConstraint.html#d9d52240a0050909996e7adf94ba1540">result</a>-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;OutputLen&gt;</a>());
<a name="l00392"></a>00392             <span class="keywordflow">return</span>;
<a name="l00393"></a>00393         }
<a name="l00394"></a>00394         <span class="keywordflow">if</span> (le1.<a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a> != 0 || le2.<a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a> != 0) {
<a name="l00395"></a>00395             <a class="code" href="structBinaryConstraint.html#d9d52240a0050909996e7adf94ba1540">result</a>-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;OutputLen&gt;::nonconstant</a>(<a class="code" href="structBinaryConstraint.html#d9d52240a0050909996e7adf94ba1540">result</a>-&gt;myName, <a class="code" href="structBinaryConstraint.html#d9d52240a0050909996e7adf94ba1540">result</a>-&gt;def));
<a name="l00396"></a>00396             <span class="keywordflow">return</span>;
<a name="l00397"></a>00397         }
<a name="l00398"></a>00398         uint64_t newVal = this-&gt;<a class="code" href="structBinaryConstraint.html#892b2699bf75e092f00b32da011f4255">compute</a>(le1.<a class="code" href="structLatticeElement.html#5f7046b6efe5660c07b84883ee26a4cc">offset</a>, le2.<a class="code" href="structLatticeElement.html#5f7046b6efe5660c07b84883ee26a4cc">offset</a>);
<a name="l00399"></a>00399         <a class="code" href="structBinaryConstraint.html#d9d52240a0050909996e7adf94ba1540">result</a>-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;OutputLen&gt;::constant</a>(newVal, <a class="code" href="structBinaryConstraint.html#d9d52240a0050909996e7adf94ba1540">result</a>-&gt;def));
<a name="l00400"></a>00400     }
<a name="l00401"></a>00401 
<a name="l00402"></a><a class="code" href="structBinaryConstraint.html#3614385210c3c599b0d31fec62d3e129">00402</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structBinaryConstraint.html#3614385210c3c599b0d31fec62d3e129">markDependencies</a>() {
<a name="l00403"></a>00403         <a class="code" href="classConstraint.html#30feaf180bce5c1a0cfeee0be9983a93">addDependency</a>(<a class="code" href="structBinaryConstraint.html#542b1bd52df0ceca1c8320e1f2048c9f">var1</a>);
<a name="l00404"></a>00404         <a class="code" href="classConstraint.html#30feaf180bce5c1a0cfeee0be9983a93">addDependency</a>(<a class="code" href="structBinaryConstraint.html#aada355823e276f040a2627de612fd8e">var2</a>);
<a name="l00405"></a>00405     }
<a name="l00406"></a>00406     <span class="keyword">virtual</span> uint64_t <a class="code" href="structBinaryConstraint.html#892b2699bf75e092f00b32da011f4255">compute</a>(uint64_t a, uint64_t b) <span class="keyword">const </span>= 0;
<a name="l00407"></a>00407 };
<a name="l00408"></a>00408 
<a name="l00409"></a><a class="code" href="findConstants_8h.html#0c4b579c98b326eab605862dc73feb78">00409</a> <span class="preprocessor">#define BINARY_COMPUTATION(name, InLen1, InLen2, OutLen, Formula)                                                              \</span>
<a name="l00410"></a>00410 <span class="preprocessor">    XVariablePtr&lt;(OutLen)&gt; name(XVariablePtr&lt;(InLen1)&gt; a, XVariablePtr&lt;(InLen2)&gt; b) {                                          \</span>
<a name="l00411"></a>00411 <span class="preprocessor">        XVariablePtr&lt;(OutLen)&gt; result = new XVariable&lt;(OutLen)&gt;();                                                             \</span>
<a name="l00412"></a>00412 <span class="preprocessor">        struct IC: public BinaryConstraint&lt;(InLen1), (InLen2), (OutLen)&gt; {                                                     \</span>
<a name="l00413"></a>00413 <span class="preprocessor">            IC(XVariablePtr&lt;(OutLen)&gt; result, XVariablePtr&lt;(InLen1)&gt; var1, XVariablePtr&lt;(InLen2)&gt; var2)                        \</span>
<a name="l00414"></a>00414 <span class="preprocessor">                : BinaryConstraint&lt;(InLen1), (InLen2), (OutLen)&gt;(result, var1, var2)                                           \</span>
<a name="l00415"></a>00415 <span class="preprocessor">                {}                                                                                                             \</span>
<a name="l00416"></a>00416 <span class="preprocessor">            virtual uint64_t compute(uint64_t a, uint64_t b) const {                                                           \</span>
<a name="l00417"></a>00417 <span class="preprocessor">                Formula                                                                                                        \</span>
<a name="l00418"></a>00418 <span class="preprocessor">            }                                                                                                                  \</span>
<a name="l00419"></a>00419 <span class="preprocessor">        };                                                                                                                     \</span>
<a name="l00420"></a>00420 <span class="preprocessor">        (new IC(result, a, b))-&gt;activate();                                                                                    \</span>
<a name="l00421"></a>00421 <span class="preprocessor">        return result;                                                                                                         \</span>
<a name="l00422"></a>00422 <span class="preprocessor">    }</span>
<a name="l00423"></a>00423 <span class="preprocessor"></span>
<a name="l00424"></a><a class="code" href="findConstants_8h.html#b60e9a0c85be40774c6f3a44bf7bbc26">00424</a> <span class="preprocessor">#define BINARY_COMPUTATION_SPECIAL(name, InLen1, InLen2, OutLen, Formula)                                                      \</span>
<a name="l00425"></a>00425 <span class="preprocessor">    XVariablePtr&lt;(OutLen)&gt; name(XVariablePtr&lt;(InLen1)&gt; a, XVariablePtr&lt;(InLen2)&gt; b) {                                          \</span>
<a name="l00426"></a>00426 <span class="preprocessor">        XVariablePtr&lt;(OutLen)&gt; result = new XVariable&lt;(OutLen)&gt;();                                                             \</span>
<a name="l00427"></a>00427 <span class="preprocessor">        struct IC: public BinaryConstraint&lt;(InLen1), (InLen2), (OutLen)&gt; {                                                     \</span>
<a name="l00428"></a>00428 <span class="preprocessor">            IC(XVariablePtr&lt;(OutLen)&gt; result, XVariablePtr&lt;(InLen1)&gt; var1, XVariablePtr&lt;(InLen2)&gt; var2)                        \</span>
<a name="l00429"></a>00429 <span class="preprocessor">                : BinaryConstraint&lt;(InLen1), (InLen2), (OutLen)&gt;(result, var1, var2)                                           \</span>
<a name="l00430"></a>00430 <span class="preprocessor">                {}                                                                                                             \</span>
<a name="l00431"></a>00431 <span class="preprocessor">            virtual void run() const {                                                                                         \</span>
<a name="l00432"></a>00432 <span class="preprocessor">                LatticeElement&lt;(InLen1)&gt; le1 = BinaryConstraint&lt;(InLen1), (InLen2), (OutLen)&gt;::var1-&gt;get();                    \</span>
<a name="l00433"></a>00433 <span class="preprocessor">                LatticeElement&lt;(InLen2)&gt; le2 = BinaryConstraint&lt;(InLen1), (InLen2), (OutLen)&gt;::var2-&gt;get();                    \</span>
<a name="l00434"></a>00434 <span class="preprocessor">                XVariablePtr&lt;(OutLen)&gt; result = BinaryConstraint&lt;(InLen1), (InLen2), (OutLen)&gt;::result;                        \</span>
<a name="l00435"></a>00435 <span class="preprocessor">                if (le1.isTop || le2.isTop) {                                                                                  \</span>
<a name="l00436"></a>00436 <span class="preprocessor">                    result-&gt;set(LatticeElement&lt;(OutLen)&gt;());                                                                   \</span>
<a name="l00437"></a>00437 <span class="preprocessor">                    return;                                                                                                    \</span>
<a name="l00438"></a>00438 <span class="preprocessor">                }                                                                                                              \</span>
<a name="l00439"></a>00439 <span class="preprocessor">                Formula                                                                                                        \</span>
<a name="l00440"></a>00440 <span class="preprocessor">            }                                                                                                                  \</span>
<a name="l00441"></a>00441 <span class="preprocessor">            virtual uint64_t compute(uint64_t, uint64_t) const {                                                               \</span>
<a name="l00442"></a>00442 <span class="preprocessor">                abort();                                                                                                       \</span>
<a name="l00443"></a>00443 <span class="preprocessor">            }                                                                                                                  \</span>
<a name="l00444"></a>00444 <span class="preprocessor">        };                                                                                                                     \</span>
<a name="l00445"></a>00445 <span class="preprocessor">        (new IC(result, a, b))-&gt;activate();                                                                                    \</span>
<a name="l00446"></a>00446 <span class="preprocessor">        return result;                                                                                                         \</span>
<a name="l00447"></a>00447 <span class="preprocessor">    }</span>
<a name="l00448"></a>00448 <span class="preprocessor"></span>
<a name="l00449"></a>00449 <span class="keyword">template</span> &lt;size_t InputLen1, size_t InputLen2, size_t InputLen3, size_t OutputLen&gt;
<a name="l00450"></a><a class="code" href="structTernaryConstraint.html">00450</a> <span class="keyword">struct </span><a class="code" href="structTernaryConstraint.html">TernaryConstraint</a>: <span class="keyword">public</span> <a class="code" href="classConstraint.html">Constraint</a> {
<a name="l00451"></a><a class="code" href="structTernaryConstraint.html#7ef7798903c05d6335a6db862e1a11ac">00451</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;OutputLen&gt;</a> <a class="code" href="structTernaryConstraint.html#7ef7798903c05d6335a6db862e1a11ac">result</a>;
<a name="l00452"></a><a class="code" href="structTernaryConstraint.html#9263625a6a3ffe8d08e9939134a23a7f">00452</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;InputLen1&gt;</a> <a class="code" href="structTernaryConstraint.html#9263625a6a3ffe8d08e9939134a23a7f">var1</a>;
<a name="l00453"></a><a class="code" href="structTernaryConstraint.html#d154ce39959516e35d7932d1733a98a7">00453</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;InputLen2&gt;</a> <a class="code" href="structTernaryConstraint.html#d154ce39959516e35d7932d1733a98a7">var2</a>;
<a name="l00454"></a><a class="code" href="structTernaryConstraint.html#c4036ce47553d33afd80e9c4850a1dee">00454</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;InputLen3&gt;</a> <a class="code" href="structTernaryConstraint.html#c4036ce47553d33afd80e9c4850a1dee">var3</a>;
<a name="l00455"></a>00455 
<a name="l00456"></a><a class="code" href="structTernaryConstraint.html#325c61b765e7e13049c0b36d341ababb">00456</a>     <a class="code" href="structTernaryConstraint.html#325c61b765e7e13049c0b36d341ababb">TernaryConstraint</a>(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;OutputLen&gt;</a> <a class="code" href="structTernaryConstraint.html#7ef7798903c05d6335a6db862e1a11ac">result</a>,
<a name="l00457"></a>00457                       <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;InputLen1&gt;</a> <a class="code" href="structTernaryConstraint.html#9263625a6a3ffe8d08e9939134a23a7f">var1</a>, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;InputLen2&gt;</a> <a class="code" href="structTernaryConstraint.html#d154ce39959516e35d7932d1733a98a7">var2</a>, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;InputLen3&gt;</a> <a class="code" href="structTernaryConstraint.html#c4036ce47553d33afd80e9c4850a1dee">var3</a>)
<a name="l00458"></a>00458         : <a class="code" href="structTernaryConstraint.html#7ef7798903c05d6335a6db862e1a11ac">result</a>(<a class="code" href="structTernaryConstraint.html#7ef7798903c05d6335a6db862e1a11ac">result</a>), <a class="code" href="structTernaryConstraint.html#9263625a6a3ffe8d08e9939134a23a7f">var1</a>(<a class="code" href="structTernaryConstraint.html#9263625a6a3ffe8d08e9939134a23a7f">var1</a>), <a class="code" href="structTernaryConstraint.html#d154ce39959516e35d7932d1733a98a7">var2</a>(<a class="code" href="structTernaryConstraint.html#d154ce39959516e35d7932d1733a98a7">var2</a>), <a class="code" href="structTernaryConstraint.html#c4036ce47553d33afd80e9c4850a1dee">var3</a>(<a class="code" href="structTernaryConstraint.html#c4036ce47553d33afd80e9c4850a1dee">var3</a>)
<a name="l00459"></a>00459         {}
<a name="l00460"></a>00460 
<a name="l00461"></a><a class="code" href="structTernaryConstraint.html#23c2a3f6d6a876da11bbf3b90074ef0c">00461</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structTernaryConstraint.html#23c2a3f6d6a876da11bbf3b90074ef0c">run</a>()<span class="keyword"> const </span>{
<a name="l00462"></a>00462         <a class="code" href="structLatticeElement.html">LatticeElement&lt;InputLen1&gt;</a> le1 = <a class="code" href="structTernaryConstraint.html#9263625a6a3ffe8d08e9939134a23a7f">var1</a>-&gt;get();
<a name="l00463"></a>00463         <a class="code" href="structLatticeElement.html">LatticeElement&lt;InputLen2&gt;</a> le2 = <a class="code" href="structTernaryConstraint.html#d154ce39959516e35d7932d1733a98a7">var2</a>-&gt;get();
<a name="l00464"></a>00464         <a class="code" href="structLatticeElement.html">LatticeElement&lt;InputLen3&gt;</a> le3 = <a class="code" href="structTernaryConstraint.html#c4036ce47553d33afd80e9c4850a1dee">var3</a>-&gt;get();
<a name="l00465"></a>00465         <span class="keywordflow">if</span> (le1.<a class="code" href="structLatticeElement.html#4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a> || le2.<a class="code" href="structLatticeElement.html#4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a> || le3.<a class="code" href="structLatticeElement.html#4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>) {
<a name="l00466"></a>00466             <a class="code" href="structTernaryConstraint.html#7ef7798903c05d6335a6db862e1a11ac">result</a>-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;OutputLen&gt;</a>());
<a name="l00467"></a>00467             <span class="keywordflow">return</span>;
<a name="l00468"></a>00468         }
<a name="l00469"></a>00469         <span class="keywordflow">if</span> (le1.<a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a> != 0 || le2.<a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a> != 0 || le3.<a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a> != 0) {
<a name="l00470"></a>00470             <a class="code" href="structTernaryConstraint.html#7ef7798903c05d6335a6db862e1a11ac">result</a>-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;OutputLen&gt;::nonconstant</a>(<a class="code" href="structTernaryConstraint.html#7ef7798903c05d6335a6db862e1a11ac">result</a>-&gt;myName, <a class="code" href="structTernaryConstraint.html#7ef7798903c05d6335a6db862e1a11ac">result</a>-&gt;def));
<a name="l00471"></a>00471             <span class="keywordflow">return</span>;
<a name="l00472"></a>00472         }
<a name="l00473"></a>00473         uint64_t newVal = this-&gt;<a class="code" href="structTernaryConstraint.html#cb8a3f159a040412a12b631c13859387">compute</a>(le1.<a class="code" href="structLatticeElement.html#5f7046b6efe5660c07b84883ee26a4cc">offset</a>, le2.<a class="code" href="structLatticeElement.html#5f7046b6efe5660c07b84883ee26a4cc">offset</a>, le3.<a class="code" href="structLatticeElement.html#5f7046b6efe5660c07b84883ee26a4cc">offset</a>);
<a name="l00474"></a>00474         <a class="code" href="structTernaryConstraint.html#7ef7798903c05d6335a6db862e1a11ac">result</a>-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;OutputLen&gt;::constant</a>(newVal, <a class="code" href="structTernaryConstraint.html#7ef7798903c05d6335a6db862e1a11ac">result</a>-&gt;def));
<a name="l00475"></a>00475     }
<a name="l00476"></a>00476 
<a name="l00477"></a><a class="code" href="structTernaryConstraint.html#abe5c9b54e4449abc4949771d03af252">00477</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structTernaryConstraint.html#abe5c9b54e4449abc4949771d03af252">markDependencies</a>() {
<a name="l00478"></a>00478         <a class="code" href="classConstraint.html#30feaf180bce5c1a0cfeee0be9983a93">addDependency</a>(<a class="code" href="structTernaryConstraint.html#9263625a6a3ffe8d08e9939134a23a7f">var1</a>);
<a name="l00479"></a>00479         <a class="code" href="classConstraint.html#30feaf180bce5c1a0cfeee0be9983a93">addDependency</a>(<a class="code" href="structTernaryConstraint.html#d154ce39959516e35d7932d1733a98a7">var2</a>);
<a name="l00480"></a>00480         <a class="code" href="classConstraint.html#30feaf180bce5c1a0cfeee0be9983a93">addDependency</a>(<a class="code" href="structTernaryConstraint.html#c4036ce47553d33afd80e9c4850a1dee">var3</a>);
<a name="l00481"></a>00481     }
<a name="l00482"></a>00482 
<a name="l00483"></a>00483     <span class="keyword">virtual</span> uint64_t <a class="code" href="structTernaryConstraint.html#cb8a3f159a040412a12b631c13859387">compute</a>(uint64_t a, uint64_t b, uint64_t c) <span class="keyword">const </span>= 0;
<a name="l00484"></a>00484 };
<a name="l00485"></a>00485 
<a name="l00486"></a><a class="code" href="findConstants_8h.html#c665060a61498a5dc2f60f3fb9a0dd52">00486</a> <span class="preprocessor">#define TERNARY_COMPUTATION(name, InLen1, InLen2, InLen3, OutLen, Formula)                                                     \</span>
<a name="l00487"></a>00487 <span class="preprocessor">    XVariablePtr&lt;(OutLen)&gt; name(XVariablePtr&lt;(InLen1)&gt; a, XVariablePtr&lt;(InLen2)&gt; b, XVariablePtr&lt;(InLen3)&gt; c) {                \</span>
<a name="l00488"></a>00488 <span class="preprocessor">        XVariable&lt;(OutLen)&gt;* result = new XVariable&lt;(OutLen)&gt;();                                                               \</span>
<a name="l00489"></a>00489 <span class="preprocessor">        struct IC: public TernaryConstraint&lt;(InLen1), (InLen2), (InLen3), (OutLen)&gt; {                                          \</span>
<a name="l00490"></a>00490 <span class="preprocessor">            IC(XVariablePtr&lt;(OutLen)&gt; result,                                                                                  \</span>
<a name="l00491"></a>00491 <span class="preprocessor">               XVariablePtr&lt;(InLen1)&gt; var1, XVariablePtr&lt;(InLen2)&gt; var2, XVariablePtr&lt;(InLen3)&gt; var3)                          \</span>
<a name="l00492"></a>00492 <span class="preprocessor">                : TernaryConstraint&lt;(InLen1), (InLen2), (InLen3), (OutLen)&gt;(result, var1, var2, var3)                          \</span>
<a name="l00493"></a>00493 <span class="preprocessor">                {}                                                                                                             \</span>
<a name="l00494"></a>00494 <span class="preprocessor">            virtual uint64_t compute(uint64_t a, uint64_t b, uint64_t c) const {                                               \</span>
<a name="l00495"></a>00495 <span class="preprocessor">                Formula                                                                                                        \</span>
<a name="l00496"></a>00496 <span class="preprocessor">            }                                                                                                                  \</span>
<a name="l00497"></a>00497 <span class="preprocessor">        };                                                                                                                     \</span>
<a name="l00498"></a>00498 <span class="preprocessor">        (new IC(result, a, b, c))-&gt;activate();                                                                                 \</span>
<a name="l00499"></a>00499 <span class="preprocessor">        return result;                                                                                                         \</span>
<a name="l00500"></a>00500 <span class="preprocessor">    }</span>
<a name="l00501"></a>00501 <span class="preprocessor"></span>
<a name="l00502"></a><a class="code" href="findConstants_8h.html#cfeda32a953312c23784c6cd3c9ef85c">00502</a> <span class="preprocessor">#define TERNARY_COMPUTATION_SPECIAL(name, InLen1, InLen2, InLen3, OutLen, Formula)                                             \</span>
<a name="l00503"></a>00503 <span class="preprocessor">    XVariablePtr&lt;(OutLen)&gt; name(XVariablePtr&lt;(InLen1)&gt; a, XVariablePtr&lt;(InLen2)&gt; b, XVariablePtr&lt;(InLen3)&gt; c) {                \</span>
<a name="l00504"></a>00504 <span class="preprocessor">        XVariablePtr&lt;(OutLen)&gt; result = new XVariable&lt;(OutLen)&gt;();                                                             \</span>
<a name="l00505"></a>00505 <span class="preprocessor">        struct IC: public TernaryConstraint&lt;(InLen1), (InLen2), (InLen3), (OutLen)&gt; {                                          \</span>
<a name="l00506"></a>00506 <span class="preprocessor">            IC(XVariablePtr&lt;(OutLen)&gt; result,                                                                                  \</span>
<a name="l00507"></a>00507 <span class="preprocessor">               XVariablePtr&lt;(InLen1)&gt; var1, XVariablePtr&lt;(InLen2)&gt; var2, XVariablePtr&lt;(InLen3)&gt; var3)                          \</span>
<a name="l00508"></a>00508 <span class="preprocessor">                : TernaryConstraint&lt;(InLen1), (InLen2), (InLen3), (OutLen)&gt;(result, var1, var2, var3)                          \</span>
<a name="l00509"></a>00509 <span class="preprocessor">                {}                                                                                                             \</span>
<a name="l00510"></a>00510 <span class="preprocessor">            virtual void run() const {                                                                                         \</span>
<a name="l00511"></a>00511 <span class="preprocessor">                LatticeElement&lt;(InLen1)&gt; le1 = TernaryConstraint&lt;(InLen1), (InLen2), (InLen3), (OutLen)&gt;::var1-&gt;get();         \</span>
<a name="l00512"></a>00512 <span class="preprocessor">                LatticeElement&lt;(InLen2)&gt; le2 = TernaryConstraint&lt;(InLen1), (InLen2), (InLen3), (OutLen)&gt;::var2-&gt;get();         \</span>
<a name="l00513"></a>00513 <span class="preprocessor">                LatticeElement&lt;(InLen3)&gt; le3 = TernaryConstraint&lt;(InLen1), (InLen2), (InLen3), (OutLen)&gt;::var3-&gt;get();         \</span>
<a name="l00514"></a>00514 <span class="preprocessor">                XVariablePtr&lt;(OutLen)&gt; result = TernaryConstraint&lt;(InLen1), (InLen2), (InLen3), (OutLen)&gt;::result;             \</span>
<a name="l00515"></a>00515 <span class="preprocessor">                if (le1.isTop || le2.isTop || le3.isTop) {                                                                     \</span>
<a name="l00516"></a>00516 <span class="preprocessor">                    result-&gt;set(LatticeElement&lt;(OutLen)&gt;());                                                                   \</span>
<a name="l00517"></a>00517 <span class="preprocessor">                    return;                                                                                                    \</span>
<a name="l00518"></a>00518 <span class="preprocessor">                }                                                                                                              \</span>
<a name="l00519"></a>00519 <span class="preprocessor">                Formula                                                                                                        \</span>
<a name="l00520"></a>00520 <span class="preprocessor">            }                                                                                                                  \</span>
<a name="l00521"></a>00521 <span class="preprocessor">            virtual uint64_t compute(uint64_t, uint64_t, uint64_t) const {                                                     \</span>
<a name="l00522"></a>00522 <span class="preprocessor">                abort();                                                                                                       \</span>
<a name="l00523"></a>00523 <span class="preprocessor">            }                                                                                                                  \</span>
<a name="l00524"></a>00524 <span class="preprocessor">        };                                                                                                                     \</span>
<a name="l00525"></a>00525 <span class="preprocessor">        (new IC(result, a, b, c))-&gt;activate();                                                                                 \</span>
<a name="l00526"></a>00526 <span class="preprocessor">        return result;                                                                                                         \</span>
<a name="l00527"></a>00527 <span class="preprocessor">    }</span>
<a name="l00528"></a>00528 <span class="preprocessor"></span>
<a name="l00529"></a>00529 
<a name="l00530"></a>00530 <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00531"></a><a class="code" href="structMergeConstraint.html">00531</a> <span class="keyword">struct </span><a class="code" href="structMergeConstraint.html">MergeConstraint</a>: <span class="keyword">public</span> <a class="code" href="classConstraint.html">Constraint</a> {
<a name="l00532"></a><a class="code" href="structMergeConstraint.html#c157a836a0e36eb0dfcfa74c03d125e4">00532</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> <a class="code" href="structMergeConstraint.html#c157a836a0e36eb0dfcfa74c03d125e4">result</a>;
<a name="l00533"></a><a class="code" href="structMergeConstraint.html#c5f2f712832154cdff7028bbd3508424">00533</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> <a class="code" href="structMergeConstraint.html#c5f2f712832154cdff7028bbd3508424">var1</a>;
<a name="l00534"></a><a class="code" href="structMergeConstraint.html#d139b71af7af9ea9de1cab2237cb4b5d">00534</a>     <a class="code" href="structMergeConstraint.html#d139b71af7af9ea9de1cab2237cb4b5d">MergeConstraint</a>(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> <a class="code" href="structMergeConstraint.html#c157a836a0e36eb0dfcfa74c03d125e4">result</a>, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> <a class="code" href="structMergeConstraint.html#c5f2f712832154cdff7028bbd3508424">var1</a>)
<a name="l00535"></a>00535         : <a class="code" href="structMergeConstraint.html#c157a836a0e36eb0dfcfa74c03d125e4">result</a>(<a class="code" href="structMergeConstraint.html#c157a836a0e36eb0dfcfa74c03d125e4">result</a>), <a class="code" href="structMergeConstraint.html#c5f2f712832154cdff7028bbd3508424">var1</a>(<a class="code" href="structMergeConstraint.html#c5f2f712832154cdff7028bbd3508424">var1</a>)
<a name="l00536"></a>00536         {}
<a name="l00537"></a><a class="code" href="structMergeConstraint.html#7a4a2a146905677ed6c3884f1f0747b1">00537</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structMergeConstraint.html#7a4a2a146905677ed6c3884f1f0747b1">run</a>()<span class="keyword"> const </span>{
<a name="l00538"></a>00538         <a class="code" href="structMergeConstraint.html#c157a836a0e36eb0dfcfa74c03d125e4">result</a>-&gt;set(<a class="code" href="structMergeConstraint.html#c5f2f712832154cdff7028bbd3508424">var1</a>-&gt;get());
<a name="l00539"></a>00539     }
<a name="l00540"></a><a class="code" href="structMergeConstraint.html#dcb497b1002d813d1a17cd3a465feab5">00540</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structMergeConstraint.html#dcb497b1002d813d1a17cd3a465feab5">markDependencies</a>() {
<a name="l00541"></a>00541         <a class="code" href="classConstraint.html#30feaf180bce5c1a0cfeee0be9983a93">addDependency</a>(<a class="code" href="structMergeConstraint.html#c5f2f712832154cdff7028bbd3508424">var1</a>);
<a name="l00542"></a>00542     }
<a name="l00543"></a>00543 };
<a name="l00544"></a>00544 
<a name="l00545"></a><a class="code" href="structMemoryMergeConstraint.html">00545</a> <span class="keyword">struct </span><a class="code" href="structMemoryMergeConstraint.html">MemoryMergeConstraint</a>: <span class="keyword">public</span> <a class="code" href="classConstraint.html">Constraint</a> {
<a name="l00546"></a><a class="code" href="structMemoryMergeConstraint.html#9e613ec9f72d23bdedaa388f8c0f04ca">00546</a>     <a class="code" href="structMemoryVariable.html">MemoryVariable</a>* <a class="code" href="structMemoryMergeConstraint.html#9e613ec9f72d23bdedaa388f8c0f04ca">result</a>;
<a name="l00547"></a><a class="code" href="structMemoryMergeConstraint.html#a8887266f126a2c752dd7aefcaf24e92">00547</a>     <a class="code" href="structMemoryVariable.html">MemoryVariable</a>* <a class="code" href="structMemoryMergeConstraint.html#a8887266f126a2c752dd7aefcaf24e92">var1</a>;
<a name="l00548"></a><a class="code" href="structMemoryMergeConstraint.html#a9271776c910b510d3df5df8b4aca711">00548</a>     <a class="code" href="structMemoryMergeConstraint.html#a9271776c910b510d3df5df8b4aca711">MemoryMergeConstraint</a>(<a class="code" href="structMemoryVariable.html">MemoryVariable</a>* <a class="code" href="structMemoryMergeConstraint.html#9e613ec9f72d23bdedaa388f8c0f04ca">result</a>, <a class="code" href="structMemoryVariable.html">MemoryVariable</a>* <a class="code" href="structMemoryMergeConstraint.html#a8887266f126a2c752dd7aefcaf24e92">var1</a>)
<a name="l00549"></a>00549         : <a class="code" href="structMemoryMergeConstraint.html#9e613ec9f72d23bdedaa388f8c0f04ca">result</a>(<a class="code" href="structMemoryMergeConstraint.html#9e613ec9f72d23bdedaa388f8c0f04ca">result</a>), <a class="code" href="structMemoryMergeConstraint.html#a8887266f126a2c752dd7aefcaf24e92">var1</a>(<a class="code" href="structMemoryMergeConstraint.html#a8887266f126a2c752dd7aefcaf24e92">var1</a>)
<a name="l00550"></a>00550         {}
<a name="l00551"></a><a class="code" href="structMemoryMergeConstraint.html#54199e4a36b5aa84831e293587e49e60">00551</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structMemoryMergeConstraint.html#54199e4a36b5aa84831e293587e49e60">run</a>()<span class="keyword"> const </span>{
<a name="l00552"></a>00552         <a class="code" href="structMemoryMergeConstraint.html#9e613ec9f72d23bdedaa388f8c0f04ca">result</a>-&gt;<a class="code" href="structMemoryVariable.html#00e681d73a045c3f44ce2758f69b75be">set</a>(<a class="code" href="structMemoryMergeConstraint.html#a8887266f126a2c752dd7aefcaf24e92">var1</a>-&gt;<a class="code" href="structMemoryVariable.html#afe7886f04c547485bb7b0fe23d2093b">get</a>());
<a name="l00553"></a>00553     }
<a name="l00554"></a><a class="code" href="structMemoryMergeConstraint.html#eec1a4bf2b8c2b038efceafcb9d34573">00554</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structMemoryMergeConstraint.html#eec1a4bf2b8c2b038efceafcb9d34573">markDependencies</a>() {
<a name="l00555"></a>00555         <a class="code" href="classConstraint.html#30feaf180bce5c1a0cfeee0be9983a93">addDependency</a>(<a class="code" href="structMemoryMergeConstraint.html#a8887266f126a2c752dd7aefcaf24e92">var1</a>);
<a name="l00556"></a>00556     }
<a name="l00557"></a>00557 };
<a name="l00558"></a>00558 
<a name="l00559"></a><a class="code" href="structRegisterSet.html">00559</a> <span class="keyword">struct </span><a class="code" href="structRegisterSet.html">RegisterSet</a> {
<a name="l00560"></a>00560     <span class="keyword">struct </span>{
<a name="l00561"></a><a class="code" href="structRegisterSet.html#ca7f7c3e69d2ffce58c4ca2b6663fc95">00561</a>         <span class="keyword">static</span> <span class="keyword">const</span> size_t <a class="code" href="structRegisterSet.html#ca7f7c3e69d2ffce58c4ca2b6663fc95">n_gprs</a> = 8;             
<a name="l00562"></a><a class="code" href="structRegisterSet.html#a2d5cfd2bf952ad46208b753191ac390">00562</a>         <span class="keyword">static</span> <span class="keyword">const</span> size_t <a class="code" href="structRegisterSet.html#a2d5cfd2bf952ad46208b753191ac390">n_segregs</a> = 6;          
<a name="l00563"></a><a class="code" href="structRegisterSet.html#20c382949ffadda813b03c0edf8658a8">00563</a>         <span class="keyword">static</span> <span class="keyword">const</span> size_t <a class="code" href="structRegisterSet.html#20c382949ffadda813b03c0edf8658a8">n_flags</a> = 32;           
<a name="l00565"></a><a class="code" href="structRegisterSet.html#ee0cbc1009037414f2b247b93087720a">00565</a>         <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> <a class="code" href="structRegisterSet.html#ee0cbc1009037414f2b247b93087720a">gpr</a>[n_gprs];
<a name="l00566"></a><a class="code" href="structRegisterSet.html#cabc0abf4ccd74499a0c323a8b72672b">00566</a>         <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;16&gt;</a> <a class="code" href="structRegisterSet.html#cabc0abf4ccd74499a0c323a8b72672b">segreg</a>[n_segregs];
<a name="l00567"></a><a class="code" href="structRegisterSet.html#e3138843212bd817f69f74a17395eb48">00567</a>         <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;1&gt;</a> <a class="code" href="structRegisterSet.html#e3138843212bd817f69f74a17395eb48">flag</a>[n_flags];
<a name="l00568"></a>00568     } <a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>;
<a name="l00569"></a>00569     
<a name="l00570"></a><a class="code" href="structRegisterSet.html#70669dade0ea18fc20058fc72d36a69e">00570</a>     <a class="code" href="structMemoryVariable.html">MemoryVariable</a>* <a class="code" href="structRegisterSet.html#70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>; <span class="comment">// Undefined elements are bottom, no two elements can satisfy mayAlias</span>
<a name="l00571"></a>00571     
<a name="l00572"></a><a class="code" href="structRegisterSet.html#35b21a1b96090ad0fb0d69b02bfff8c5">00572</a>     <a class="code" href="structRegisterSet.html#35b21a1b96090ad0fb0d69b02bfff8c5">RegisterSet</a>() {
<a name="l00573"></a>00573         <span class="keywordflow">for</span> (size_t i = 0; i &lt; <a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.n_gprs; ++i)
<a name="l00574"></a>00574             <a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.gpr[i] = <span class="keyword">new</span> <a class="code" href="structXVariable.html">XVariable&lt;32&gt;</a>();
<a name="l00575"></a>00575         for (size_t i = 0; i &lt; <a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.n_segregs; ++i)
<a name="l00576"></a>00576             <a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.segreg[i] = <span class="keyword">new</span> <a class="code" href="structXVariable.html">XVariable&lt;16&gt;</a>();
<a name="l00577"></a>00577         for (size_t i = 0; i &lt; 16; ++i)
<a name="l00578"></a>00578             <a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.flag[i] = <span class="keyword">new</span> <a class="code" href="structXVariable.html">XVariable&lt;1&gt;</a>();
<a name="l00579"></a>00579         <a class="code" href="structRegisterSet.html#70669dade0ea18fc20058fc72d36a69e">memoryWrites</a> = <span class="keyword">new</span> <a class="code" href="structMemoryVariable.html">MemoryVariable</a>();
<a name="l00580"></a>00580     }
<a name="l00581"></a>00581 
<a name="l00582"></a><a class="code" href="structRegisterSet.html#bd97694302e8f6c77bc5013b82382923">00582</a>     <span class="keywordtype">void</span> <a class="code" href="structRegisterSet.html#bd97694302e8f6c77bc5013b82382923">setToBottom</a>() {
<a name="l00583"></a>00583         <span class="keywordflow">for</span> (size_t i = 0; i &lt; <a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.n_gprs; ++i)
<a name="l00584"></a>00584             <a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.gpr[i] = <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;::bottom</a>();
<a name="l00585"></a>00585         for (size_t i = 0; i &lt; <a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.n_segregs; ++i)
<a name="l00586"></a>00586             <a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.segreg[i] = <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;16&gt;::bottom</a>();
<a name="l00587"></a>00587         for (size_t i = 0; i &lt; 16; ++i)
<a name="l00588"></a>00588             <a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.flag[i] = <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;1&gt;::bottom</a>();
<a name="l00589"></a>00589         <a class="code" href="structRegisterSet.html#70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>-&gt;<a class="code" href="structMemoryVariable.html#00e681d73a045c3f44ce2758f69b75be">set</a>(<a class="code" href="structMemoryWriteSet.html#5f96f9bfa7cc7ca000e22c9eb4b78261">MemoryWriteSet::bottom</a>());
<a name="l00590"></a>00590     }
<a name="l00591"></a>00591 
<a name="l00592"></a><a class="code" href="structRegisterSet.html#8e135e626e5f37509718f1245fa3da11">00592</a>     <span class="keywordtype">void</span> <a class="code" href="structRegisterSet.html#8e135e626e5f37509718f1245fa3da11">mergeIn</a>(<span class="keyword">const</span> <a class="code" href="structRegisterSet.html">RegisterSet</a>&amp; rs) {
<a name="l00593"></a>00593         <span class="keywordflow">for</span> (size_t i = 0; i &lt; <a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.n_gprs; ++i)
<a name="l00594"></a>00594             (<span class="keyword">new</span> <a class="code" href="structMergeConstraint.html">MergeConstraint&lt;32&gt;</a>(<a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.gpr[i], rs.<a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.<a class="code" href="structRegisterSet.html#ee0cbc1009037414f2b247b93087720a">gpr</a>[i]))-&gt;activate();
<a name="l00595"></a>00595         <span class="keywordflow">for</span> (size_t i = 0; i &lt; <a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.n_segregs; ++i)
<a name="l00596"></a>00596             (<span class="keyword">new</span> <a class="code" href="structMergeConstraint.html">MergeConstraint&lt;16&gt;</a>(<a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.segreg[i], rs.<a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.<a class="code" href="structRegisterSet.html#cabc0abf4ccd74499a0c323a8b72672b">segreg</a>[i]))-&gt;activate();
<a name="l00597"></a>00597         <span class="keywordflow">for</span> (size_t i = 0; i &lt; 16; ++i)
<a name="l00598"></a>00598             (<span class="keyword">new</span> <a class="code" href="structMergeConstraint.html">MergeConstraint&lt;1&gt;</a>(<a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.flag[i], rs.<a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.<a class="code" href="structRegisterSet.html#e3138843212bd817f69f74a17395eb48">flag</a>[i]))-&gt;activate();
<a name="l00599"></a>00599         (<span class="keyword">new</span> <a class="code" href="structMemoryMergeConstraint.html">MemoryMergeConstraint</a>(<a class="code" href="structRegisterSet.html#70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>, rs.<a class="code" href="structRegisterSet.html#70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>))-&gt;activate();
<a name="l00600"></a>00600     }
<a name="l00601"></a>00601 
<a name="l00603"></a><a class="code" href="structRegisterSet.html#088acefbd0251e18550839a020727b9c">00603</a>     std::string <a class="code" href="structRegisterSet.html#088acefbd0251e18550839a020727b9c">diff</a>(<span class="keyword">const</span> <a class="code" href="structRegisterSet.html">RegisterSet</a> &amp;orig, std::string <a class="code" href="SgUnaryOp_8docs.html#c6cf1576467b95ef29f025f8e47eea437afa939f8bd773f5f7e326990b07580c">prefix</a>=<span class="stringliteral">""</span>) {
<a name="l00604"></a>00604         std::ostringstream s;
<a name="l00605"></a>00605         <span class="keywordflow">for</span> (size_t i=0; i&lt;<a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.n_gprs; i++) {
<a name="l00606"></a>00606             <span class="keywordflow">if</span> (!(orig.<a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.<a class="code" href="structRegisterSet.html#ee0cbc1009037414f2b247b93087720a">gpr</a>[i]-&gt;get()==<a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.gpr[i]-&gt;get())) {
<a name="l00607"></a>00607                 s &lt;&lt;<a class="code" href="SgUnaryOp_8docs.html#c6cf1576467b95ef29f025f8e47eea437afa939f8bd773f5f7e326990b07580c">prefix</a> &lt;&lt;gprToString((<a class="code" href="InstructionEnumsX86_8h.html#5069ca462f85d162797843f48bc6bced">X86GeneralPurposeRegister</a>)i) &lt;&lt;<span class="stringliteral">" = "</span> &lt;&lt;<a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.gpr[i] &lt;&lt;<span class="stringliteral">"\n"</span>;
<a name="l00608"></a>00608             }
<a name="l00609"></a>00609         }
<a name="l00610"></a>00610         <span class="keywordflow">for</span> (size_t i=0; i&lt;<a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.n_segregs; i++) {
<a name="l00611"></a>00611             <span class="keywordflow">if</span> (!(orig.<a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.<a class="code" href="structRegisterSet.html#cabc0abf4ccd74499a0c323a8b72672b">segreg</a>[i]-&gt;get()==<a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.segreg[i]-&gt;get())) {
<a name="l00612"></a>00612                 s &lt;&lt;<a class="code" href="SgUnaryOp_8docs.html#c6cf1576467b95ef29f025f8e47eea437afa939f8bd773f5f7e326990b07580c">prefix</a> &lt;&lt;segregToString((<a class="code" href="InstructionEnumsX86_8h.html#0b09709b1ff4de1bbe47357b6d7b0e64">X86SegmentRegister</a>)i) &lt;&lt;<span class="stringliteral">" = "</span> &lt;&lt;<a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.segreg[i] &lt;&lt;<span class="stringliteral">"\n"</span>;
<a name="l00613"></a>00613             }
<a name="l00614"></a>00614         }
<a name="l00615"></a>00615         <span class="keywordflow">for</span> (size_t i=0; i&lt;16; i++) {
<a name="l00616"></a>00616             <span class="keywordflow">if</span> (!(orig.<a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.<a class="code" href="structRegisterSet.html#e3138843212bd817f69f74a17395eb48">flag</a>[i]-&gt;get()==<a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.flag[i]-&gt;get())) {
<a name="l00617"></a>00617                 s &lt;&lt;<a class="code" href="SgUnaryOp_8docs.html#c6cf1576467b95ef29f025f8e47eea437afa939f8bd773f5f7e326990b07580c">prefix</a> &lt;&lt;flagToString((<a class="code" href="InstructionEnumsX86_8h.html#b8c1069abaa6534f3481d52cfe950881">X86Flag</a>)i) &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt;<a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.flag[i] &lt;&lt;<span class="stringliteral">"\n"</span>;
<a name="l00618"></a>00618             }
<a name="l00619"></a>00619         }
<a name="l00620"></a>00620         <span class="comment">/* Show memory in this register set that is different than the original */</span>
<a name="l00621"></a>00621         <span class="keywordflow">if</span> (!<a class="code" href="structRegisterSet.html#70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>-&gt;<a class="code" href="structMemoryVariable.html#afe7886f04c547485bb7b0fe23d2093b">get</a>().<a class="code" href="structMemoryWriteSet.html#26845f2d2d0f83b00c0156a1642de9c0">isTop</a>) {
<a name="l00622"></a>00622             <span class="keywordflow">for</span> (size_t i=0; i&lt;<a class="code" href="structRegisterSet.html#70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>-&gt;<a class="code" href="structMemoryVariable.html#afe7886f04c547485bb7b0fe23d2093b">get</a>().<a class="code" href="structMemoryWriteSet.html#ff1aab41effbd5b65c11bebd3e9294ca">writes</a>.size(); i++) {
<a name="l00623"></a>00623                 <a class="code" href="structLatticeElement.html">LatticeElement&lt;32&gt;</a> addr = <a class="code" href="structRegisterSet.html#70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>-&gt;<a class="code" href="structMemoryVariable.html#afe7886f04c547485bb7b0fe23d2093b">get</a>().<a class="code" href="structMemoryWriteSet.html#ff1aab41effbd5b65c11bebd3e9294ca">writes</a>[i].address;
<a name="l00624"></a>00624                 <a class="code" href="structLatticeElement.html">LatticeElement&lt;32&gt;</a> orig_data;
<a name="l00625"></a>00625                 <span class="keywordflow">if</span> (!orig.<a class="code" href="structRegisterSet.html#70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>-&gt;<a class="code" href="structMemoryVariable.html#afe7886f04c547485bb7b0fe23d2093b">get</a>().<a class="code" href="structMemoryWriteSet.html#00d40ef766dfec837e30794fed35ec85">getValueAtAddress</a>(addr, orig_data<span class="comment">/*out*/</span>, 0, NULL) ||
<a name="l00626"></a>00626                     !(orig_data==<a class="code" href="structRegisterSet.html#70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>-&gt;<a class="code" href="structMemoryVariable.html#afe7886f04c547485bb7b0fe23d2093b">get</a>().<a class="code" href="structMemoryWriteSet.html#ff1aab41effbd5b65c11bebd3e9294ca">writes</a>[i].data)) {
<a name="l00627"></a>00627                     s &lt;&lt;<a class="code" href="SgUnaryOp_8docs.html#c6cf1576467b95ef29f025f8e47eea437afa939f8bd773f5f7e326990b07580c">prefix</a> &lt;&lt;<span class="stringliteral">"mem @ "</span> &lt;&lt;addr &lt;&lt;<span class="stringliteral">" = "</span> &lt;&lt;<a class="code" href="structRegisterSet.html#70669dade0ea18fc20058fc72d36a69e">memoryWrites</a>-&gt;<a class="code" href="structMemoryVariable.html#afe7886f04c547485bb7b0fe23d2093b">get</a>().<a class="code" href="structMemoryWriteSet.html#ff1aab41effbd5b65c11bebd3e9294ca">writes</a>[i].data &lt;&lt;<span class="stringliteral">"\n"</span>;
<a name="l00628"></a>00628                 }
<a name="l00629"></a>00629             }
<a name="l00630"></a>00630         }
<a name="l00631"></a>00631         
<a name="l00632"></a>00632 
<a name="l00633"></a>00633         <span class="keywordflow">return</span> s.str();
<a name="l00634"></a>00634     }
<a name="l00635"></a>00635     
<a name="l00636"></a>00636 };
<a name="l00637"></a>00637 
<a name="l00638"></a>00638 std::ostream&amp;
<a name="l00639"></a>00639 <a class="code" href="Cxx__Grammar_8h.html#db4215b461ab8236ea979e9ab81c61ff">operator&lt;&lt;</a>(std::ostream&amp; o, <span class="keyword">const</span> <a class="code" href="structRegisterSet.html">RegisterSet</a>&amp; rs);
<a name="l00640"></a>00640 
<a name="l00641"></a><a class="code" href="structFindConstantsPolicy.html">00641</a> <span class="keyword">struct </span><a class="code" href="structFindConstantsPolicy.html">FindConstantsPolicy</a> {
<a name="l00642"></a><a class="code" href="structFindConstantsPolicy.html#86ad83f3a1aeb15f05c22295a649c304">00642</a>     std::map&lt;uint64_t, RegisterSet&gt; <a class="code" href="structFindConstantsPolicy.html#86ad83f3a1aeb15f05c22295a649c304">rsets</a>;
<a name="l00643"></a><a class="code" href="structFindConstantsPolicy.html#d4f4934357d0febbc0fa56b7f51c57ac">00643</a>     <a class="code" href="structRegisterSet.html">RegisterSet</a> <a class="code" href="structFindConstantsPolicy.html#082de1b51d4e70ec27fe6c5a3e5b3bb2">cur_state</a>, *<a class="code" href="structFindConstantsPolicy.html#d4f4934357d0febbc0fa56b7f51c57ac">orig_state</a>;
<a name="l00644"></a><a class="code" href="structFindConstantsPolicy.html#4dd275e0c7fde0df2396d2239c845bbe">00644</a>     uint32_t <a class="code" href="structFindConstantsPolicy.html#4dd275e0c7fde0df2396d2239c845bbe">addr</a>;
<a name="l00645"></a><a class="code" href="structFindConstantsPolicy.html#94a536bbac269a2f5d6e9c087c392616">00645</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> <a class="code" href="structFindConstantsPolicy.html#94a536bbac269a2f5d6e9c087c392616">newIp</a>; <span class="comment">// To determine if it is a constant</span>
<a name="l00646"></a><a class="code" href="structFindConstantsPolicy.html#59dd50d1957fe573aec77a22a973daf8">00646</a>     <span class="keyword">const</span> <a class="code" href="classRegisterDictionary.html">RegisterDictionary</a> *<a class="code" href="structFindConstantsPolicy.html#59dd50d1957fe573aec77a22a973daf8">regdict</a>;
<a name="l00647"></a>00647     
<a name="l00648"></a><a class="code" href="structFindConstantsPolicy_1_1Exception.html">00648</a>     <span class="keyword">struct </span><a class="code" href="structFindConstantsPolicy_1_1Exception.html">Exception</a> {
<a name="l00649"></a><a class="code" href="structFindConstantsPolicy_1_1Exception.html#d53e098d2581065ad2d7d1668b2ba4f4">00649</a>         <a class="code" href="structFindConstantsPolicy_1_1Exception.html#d53e098d2581065ad2d7d1668b2ba4f4">Exception</a>(<span class="keyword">const</span> std::string &amp;<a class="code" href="structFindConstantsPolicy_1_1Exception.html#73f2f36052e497260eb68cb4e6c64fc2">mesg</a>): mesg(mesg) {}
<a name="l00650"></a><a class="code" href="structFindConstantsPolicy_1_1Exception.html#3a99c7cd470628c0af113622ae26a6a1">00650</a>         <span class="keyword">friend</span> std::ostream&amp; <a class="code" href="structFindConstantsPolicy_1_1Exception.html#3a99c7cd470628c0af113622ae26a6a1">operator&lt;&lt;</a>(std::ostream &amp;o, <span class="keyword">const</span> <a class="code" href="structFindConstantsPolicy_1_1Exception.html">Exception</a> &amp;e) {
<a name="l00651"></a>00651             o &lt;&lt;<span class="stringliteral">"FindConstantsPolicy exception: "</span> &lt;&lt;e.<a class="code" href="structFindConstantsPolicy_1_1Exception.html#73f2f36052e497260eb68cb4e6c64fc2">mesg</a>;
<a name="l00652"></a>00652             <span class="keywordflow">return</span> o;
<a name="l00653"></a>00653         }
<a name="l00654"></a><a class="code" href="structFindConstantsPolicy_1_1Exception.html#73f2f36052e497260eb68cb4e6c64fc2">00654</a>         std::string <a class="code" href="structFindConstantsPolicy_1_1Exception.html#73f2f36052e497260eb68cb4e6c64fc2">mesg</a>;
<a name="l00655"></a>00655     };
<a name="l00656"></a>00656 
<a name="l00657"></a><a class="code" href="structFindConstantsPolicy.html#afa9f6990560e4ae40295a47c9c71035">00657</a>     <a class="code" href="structFindConstantsPolicy.html#afa9f6990560e4ae40295a47c9c71035">FindConstantsPolicy</a>()
<a name="l00658"></a>00658         : <a class="code" href="structFindConstantsPolicy.html#d4f4934357d0febbc0fa56b7f51c57ac">orig_state</a>(NULL), <a class="code" href="structFindConstantsPolicy.html#4dd275e0c7fde0df2396d2239c845bbe">addr</a>(0), <a class="code" href="structFindConstantsPolicy.html#59dd50d1957fe573aec77a22a973daf8">regdict</a>(NULL)
<a name="l00659"></a>00659         {
<a name="l00660"></a>00660             <a class="code" href="structFindConstantsPolicy.html#94a536bbac269a2f5d6e9c087c392616">newIp</a> = number&lt;32&gt;(0);
<a name="l00661"></a>00661         }
<a name="l00662"></a>00662 
<a name="l00663"></a>00663     <span class="comment">/* Use this constructor when performing constant propagation analysis on a function where you want the entry point of the</span>
<a name="l00664"></a>00664 <span class="comment">     * function to use the specified initial values. See FindConstantsPolicy::startInstruction() for how this is used. */</span>
<a name="l00665"></a><a class="code" href="structFindConstantsPolicy.html#bb1ac6c415f1794acd8bebacc3715c10">00665</a>     <a class="code" href="structFindConstantsPolicy.html#afa9f6990560e4ae40295a47c9c71035">FindConstantsPolicy</a>(<a class="code" href="structRegisterSet.html">RegisterSet</a> *initial_rs)
<a name="l00666"></a>00666         : <a class="code" href="structFindConstantsPolicy.html#d4f4934357d0febbc0fa56b7f51c57ac">orig_state</a>(initial_rs), <a class="code" href="structFindConstantsPolicy.html#4dd275e0c7fde0df2396d2239c845bbe">addr</a>(0), <a class="code" href="structFindConstantsPolicy.html#59dd50d1957fe573aec77a22a973daf8">regdict</a>(NULL) {}
<a name="l00667"></a>00667 
<a name="l00669"></a><a class="code" href="structFindConstantsPolicy.html#80a3e3d403ef2f38dccc9d00fb8d872d">00669</a>     <span class="keyword">const</span> <a class="code" href="classRegisterDictionary.html">RegisterDictionary</a> *<a class="code" href="structFindConstantsPolicy.html#80a3e3d403ef2f38dccc9d00fb8d872d">get_register_dictionary</a>()<span class="keyword"> const </span>{
<a name="l00670"></a>00670         <span class="keywordflow">return</span> <a class="code" href="structFindConstantsPolicy.html#59dd50d1957fe573aec77a22a973daf8">regdict</a> ? <a class="code" href="structFindConstantsPolicy.html#59dd50d1957fe573aec77a22a973daf8">regdict</a> : <a class="code" href="classRegisterDictionary.html#f488b379372d284eda3574fe7dc4f2f0">RegisterDictionary::dictionary_pentium4</a>();
<a name="l00671"></a>00671     }
<a name="l00672"></a>00672 
<a name="l00674"></a><a class="code" href="structFindConstantsPolicy.html#12b2bfcf7ffaf9c410381010d9ce426d">00674</a>     <span class="keywordtype">void</span> <a class="code" href="structFindConstantsPolicy.html#12b2bfcf7ffaf9c410381010d9ce426d">set_register_dictionary</a>(<span class="keyword">const</span> <a class="code" href="classRegisterDictionary.html">RegisterDictionary</a> *<a class="code" href="structFindConstantsPolicy.html#59dd50d1957fe573aec77a22a973daf8">regdict</a>) {
<a name="l00675"></a>00675         this-&gt;<a class="code" href="structFindConstantsPolicy.html#59dd50d1957fe573aec77a22a973daf8">regdict</a> = <a class="code" href="structFindConstantsPolicy.html#59dd50d1957fe573aec77a22a973daf8">regdict</a>;
<a name="l00676"></a>00676     }
<a name="l00677"></a>00677 
<a name="l00678"></a>00678     <span class="comment">/* Only used by number&lt;&gt;(uint64_t) below, but gcc-4.0.1 on OSX (Apple Inc. build 5484) does not like this struct to be</span>
<a name="l00679"></a>00679 <span class="comment">     * defined inside that function.  It results in strange warnings about an unrelated function in</span>
<a name="l00680"></a>00680 <span class="comment">     * x86InstructionSemantics.C having no return value. [RPM 2010-05-27] */</span>
<a name="l00681"></a>00681     <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00682"></a><a class="code" href="structFindConstantsPolicy_1_1NumberConstraint.html">00682</a>     <span class="keyword">struct </span><a class="code" href="structFindConstantsPolicy_1_1NumberConstraint.html">NumberConstraint</a>: <span class="keyword">public</span> <a class="code" href="structNullaryConstraint.html">NullaryConstraint</a>&lt;Len&gt; {
<a name="l00683"></a><a class="code" href="structFindConstantsPolicy_1_1NumberConstraint.html#47dbd53f3748a04314717747e6c2d5c1">00683</a>         uint64_t <a class="code" href="structFindConstantsPolicy_1_1NumberConstraint.html#47dbd53f3748a04314717747e6c2d5c1">val</a>;
<a name="l00684"></a><a class="code" href="structFindConstantsPolicy_1_1NumberConstraint.html#05fbe942832e2f5c45db3602b02dfc78">00684</a>         <a class="code" href="structFindConstantsPolicy_1_1NumberConstraint.html#05fbe942832e2f5c45db3602b02dfc78">NumberConstraint</a>(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> var, uint64_t <a class="code" href="structFindConstantsPolicy_1_1NumberConstraint.html#47dbd53f3748a04314717747e6c2d5c1">val</a>)
<a name="l00685"></a>00685             : <a class="code" href="structNullaryConstraint.html">NullaryConstraint</a>&lt;<a class="code" href="structFindConstantsPolicy.html#54dbfd93eae48399930ad8875b51d183">Len</a>&gt;(var), val(val)
<a name="l00686"></a>00686             {}
<a name="l00687"></a><a class="code" href="structFindConstantsPolicy_1_1NumberConstraint.html#5466bf734060acf1f7386cc8344e3055">00687</a>         <span class="keyword">virtual</span> uint64_t <a class="code" href="structFindConstantsPolicy_1_1NumberConstraint.html#5466bf734060acf1f7386cc8344e3055">compute</a>()<span class="keyword"> const </span>{
<a name="l00688"></a>00688             <span class="keywordflow">return</span> <a class="code" href="structFindConstantsPolicy_1_1NumberConstraint.html#47dbd53f3748a04314717747e6c2d5c1">val</a>;
<a name="l00689"></a>00689         }
<a name="l00690"></a>00690     };
<a name="l00691"></a>00691         
<a name="l00692"></a>00692     <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00693"></a><a class="code" href="structFindConstantsPolicy.html#d3fc05b0757291daadd6290cf83dcd61">00693</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> <a class="code" href="structFindConstantsPolicy.html#d3fc05b0757291daadd6290cf83dcd61">number</a>(uint64_t n) {
<a name="l00694"></a>00694         <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> var = <span class="keyword">new</span> <a class="code" href="structXVariable.html">XVariable&lt;Len&gt;</a>();
<a name="l00695"></a>00695         (<span class="keyword">new</span> <a class="code" href="structFindConstantsPolicy_1_1NumberConstraint.html">NumberConstraint&lt;Len&gt;</a>(var, n))-&gt;activate();
<a name="l00696"></a>00696         <span class="keywordflow">return</span> var;
<a name="l00697"></a>00697     }
<a name="l00698"></a>00698 
<a name="l00699"></a>00699     <span class="comment">// Only safe when MSBs don't matter (i.e., you can't extract bits from something and then use this to put in zeros -- the</span>
<a name="l00700"></a>00700     <span class="comment">// original bits will probably appear again)</span>
<a name="l00701"></a>00701     <span class="keyword">template</span> &lt;size_t Len, size_t Len2&gt;
<a name="l00702"></a>00702     <span class="keyword">static</span> <a class="code" href="structFindConstantsPolicy.html#c64d8f8c019c657d5d8be0fbbeec60c8">UNARY_COMPUTATION_SPECIAL</a>(<a class="code" href="findConstants_8h.html#5e45e0632183f44d7bc6dd40f1854340">unsignedExtend</a>, <a class="code" href="structFindConstantsPolicy.html#54dbfd93eae48399930ad8875b51d183">Len</a>, Len2, {
<a name="l00703"></a>00703             result-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;Len2&gt;</a>(le1.name, le1.definingInstruction, le1.negate, le1.offset));
<a name="l00704"></a>00704         })
<a name="l00705"></a>00705 
<a name="l00706"></a><a class="code" href="structFindConstantsPolicy.html#d0d0205878273e563d9a396a26593e5e">00706</a>     template &lt;size_t From, size_t To, size_t Len&gt;
<a name="l00707"></a>00707     <span class="keyword">static</span> <a class="code" href="structFindConstantsPolicy.html#c64d8f8c019c657d5d8be0fbbeec60c8">UNARY_COMPUTATION_SPECIAL</a>(<a class="code" href="findConstants_8h.html#95eaaa03e4ec3b28e19e249d96358ea1">extract</a>, <a class="code" href="structFindConstantsPolicy.html#54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#d0d0205878273e563d9a396a26593e5e">To</a> - From, {
<a name="l00708"></a>00708             <span class="keywordflow">if</span> (From == 0) {
<a name="l00709"></a>00709                 result-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;To - From&gt;</a>(le1.name, le1.definingInstruction, le1.negate, le1.offset));
<a name="l00710"></a>00710                 <span class="keywordflow">return</span>;
<a name="l00711"></a>00711             }
<a name="l00712"></a>00712             <span class="keywordflow">if</span> (le1.name != 0) {
<a name="l00713"></a>00713                 result-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;To - From&gt;::nonconstant</a>(result-&gt;myName, result-&gt;def));
<a name="l00714"></a>00714                 <span class="keywordflow">return</span>;
<a name="l00715"></a>00715             }
<a name="l00716"></a>00716             result-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;To - From&gt;::constant</a>((le1.offset &gt;&gt; From) &amp; (<a class="code" href="structIntegerOps_1_1SHL1.html">IntegerOps::SHL1&lt;uint64_t, To - From&gt;::value</a> - 1),
<a name="l00717"></a>00717                                                             result-&gt;def));
<a name="l00718"></a>00718         })
<a name="l00719"></a>00719 
<a name="l00720"></a>00720 
<a name="l00721"></a>00721     template &lt;size_t Len1, size_t Len2&gt;
<a name="l00722"></a><a class="code" href="structFindConstantsPolicy.html#de8017e5b68d1137a1bec5590f5eeab8">00722</a>     <a class="code" href="structFindConstantsPolicy.html#de8017e5b68d1137a1bec5590f5eeab8">BINARY_COMPUTATION</a>(concat, Len1, Len2, Len1 + Len2, {
<a name="l00723"></a>00723             <span class="keywordflow">return</span> a | (b &lt;&lt; Len1);
<a name="l00724"></a>00724         })
<a name="l00725"></a>00725 
<a name="l00726"></a>00726     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;1&gt;</a> false_() {
<a name="l00727"></a>00727         <span class="keywordflow">return</span> number&lt;1&gt;(0);
<a name="l00728"></a>00728     }
<a name="l00729"></a><a class="code" href="structFindConstantsPolicy.html#cbcfb93595f2854c4a5a631d554ecbb5">00729</a>     XVariablePtr&lt;1&gt; <a class="code" href="structFindConstantsPolicy.html#cbcfb93595f2854c4a5a631d554ecbb5">true_</a>() {
<a name="l00730"></a>00730         <span class="keywordflow">return</span> number&lt;1&gt;(1);
<a name="l00731"></a>00731     }
<a name="l00732"></a>00732 
<a name="l00733"></a>00733     <span class="keyword">template</span>&lt;size_t Len&gt;
<a name="l00734"></a><a class="code" href="structFindConstantsPolicy.html#d963a3bb0a389afd684e5f1fb7429196">00734</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> <a class="code" href="structFindConstantsPolicy.html#d963a3bb0a389afd684e5f1fb7429196">undefined_</a>() {
<a name="l00735"></a>00735         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="structXVariable.html">XVariable&lt;Len&gt;</a>();
<a name="l00736"></a>00736     }
<a name="l00737"></a>00737 
<a name="l00738"></a>00738     <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00739"></a>00739     <a class="code" href="structFindConstantsPolicy.html#c64d8f8c019c657d5d8be0fbbeec60c8">UNARY_COMPUTATION_SPECIAL</a>(invert, <a class="code" href="structFindConstantsPolicy.html#54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#54dbfd93eae48399930ad8875b51d183">Len</a>, {
<a name="l00740"></a>00740             <span class="keywordflow">if</span> (le1.name == 0)
<a name="l00741"></a>00741                 result-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;::constant</a>(~le1.offset, result-&gt;def));
<a name="l00742"></a>00742             <span class="keywordflow">else</span>
<a name="l00743"></a>00743                 result-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;</a>(le1.name, le1.definingInstruction, !le1.negate, ~le1.offset));
<a name="l00744"></a>00744         })
<a name="l00745"></a>00745 
<a name="l00746"></a>00746     template &lt;size_t Len&gt;
<a name="l00747"></a><a class="code" href="structFindConstantsPolicy.html#54dbfd93eae48399930ad8875b51d183">00747</a>     <a class="code" href="structFindConstantsPolicy.html#c64d8f8c019c657d5d8be0fbbeec60c8">UNARY_COMPUTATION_SPECIAL</a>(negate, <a class="code" href="structFindConstantsPolicy.html#54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#54dbfd93eae48399930ad8875b51d183">Len</a>, {
<a name="l00748"></a>00748             <span class="keywordflow">if</span> (le1.name == 0)
<a name="l00749"></a>00749                 result-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;::constant</a>(-le1.offset, result-&gt;def));
<a name="l00750"></a>00750             <span class="keywordflow">else</span>
<a name="l00751"></a>00751                 result-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;</a>(le1.name, le1.definingInstruction, !le1.negate, -le1.offset));
<a name="l00752"></a>00752         })
<a name="l00753"></a>00753 
<a name="l00754"></a>00754     template &lt;size_t Len&gt;
<a name="l00755"></a>00755     <a class="code" href="structFindConstantsPolicy.html#de8017e5b68d1137a1bec5590f5eeab8">BINARY_COMPUTATION</a>(and_, <a class="code" href="structFindConstantsPolicy.html#54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#54dbfd93eae48399930ad8875b51d183">Len</a>, {<span class="keywordflow">return</span> (a &amp; b);})
<a name="l00756"></a>00756 
<a name="l00757"></a>00757     template &lt;size_t Len&gt;
<a name="l00758"></a>00758     <a class="code" href="structFindConstantsPolicy.html#de8017e5b68d1137a1bec5590f5eeab8">BINARY_COMPUTATION</a>(or_, <a class="code" href="structFindConstantsPolicy.html#54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#54dbfd93eae48399930ad8875b51d183">Len</a>, {<span class="keywordflow">return</span> (a | b);})
<a name="l00759"></a>00759 
<a name="l00760"></a>00760     template &lt;size_t Len&gt;
<a name="l00761"></a>00761     <a class="code" href="findConstants_8h.html#b60e9a0c85be40774c6f3a44bf7bbc26">BINARY_COMPUTATION_SPECIAL</a>(xor_, <a class="code" href="structFindConstantsPolicy.html#54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#54dbfd93eae48399930ad8875b51d183">Len</a>, {
<a name="l00762"></a>00762             <span class="keywordflow">if</span> (le1 == le2) {
<a name="l00763"></a>00763                 result-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;::constant</a>(0, result-&gt;def));
<a name="l00764"></a>00764                 <span class="keywordflow">return</span>;
<a name="l00765"></a>00765             }
<a name="l00766"></a>00766             <span class="keywordflow">if</span> (le1.name == 0 &amp;&amp; le2.name == 0) {
<a name="l00767"></a>00767                 result-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;::constant</a>(le1.offset ^ le2.offset, result-&gt;def));
<a name="l00768"></a>00768                 <span class="keywordflow">return</span>;
<a name="l00769"></a>00769             }
<a name="l00770"></a>00770             result-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;::nonconstant</a>(result-&gt;myName, result-&gt;def));
<a name="l00771"></a>00771         })
<a name="l00772"></a>00772 
<a name="l00773"></a>00773     template &lt;size_t From, size_t To&gt;
<a name="l00774"></a>00774     <a class="code" href="structFindConstantsPolicy.html#98c6aa5182dea8f9128421b7e92f7757">UNARY_COMPUTATION</a>(<a class="code" href="namespaceIntegerOps.html#3873b9519dcd249ee89a15d0fefe4ee0">signExtend</a>, From, <a class="code" href="structFindConstantsPolicy.html#d0d0205878273e563d9a396a26593e5e">To</a>, {<span class="keywordflow">return</span> (From==<a class="code" href="structFindConstantsPolicy.html#d0d0205878273e563d9a396a26593e5e">To</a> ? (a) : IntegerOps::signExtend&lt;From, To&gt;(a));})
<a name="l00775"></a>00775 
<a name="l00776"></a>00776     template &lt;size_t Len&gt;
<a name="l00777"></a><a class="code" href="structFindConstantsPolicy.html#b416604da9233aa2cd9d0ddc17d0742e">00777</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> ite(XVariablePtr&lt;1&gt; sel, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> <a class="code" href="structFindConstantsPolicy.html#b416604da9233aa2cd9d0ddc17d0742e">ifTrue</a>, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> ifFalse) {
<a name="l00778"></a>00778         <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> result = <span class="keyword">new</span> <a class="code" href="structXVariable.html">XVariable&lt;Len&gt;</a>();
<a name="l00779"></a>00779         <span class="keyword">struct </span>IteConstraint: <span class="keyword">public</span> <a class="code" href="classConstraint.html">Constraint</a> {
<a name="l00780"></a>00780             <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> result;
<a name="l00781"></a>00781             <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> <a class="code" href="structFindConstantsPolicy.html#b416604da9233aa2cd9d0ddc17d0742e">ifTrue</a>;
<a name="l00782"></a>00782             <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> ifFalse;
<a name="l00783"></a>00783             XVariablePtr&lt;1&gt; sel;
<a name="l00784"></a>00784             IteConstraint(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> result, XVariablePtr&lt;1&gt; sel, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> <a class="code" href="structFindConstantsPolicy.html#b416604da9233aa2cd9d0ddc17d0742e">ifTrue</a>, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> ifFalse)
<a name="l00785"></a>00785                 : result(result), <a class="code" href="structFindConstantsPolicy.html#b416604da9233aa2cd9d0ddc17d0742e">ifTrue</a>(<a class="code" href="structFindConstantsPolicy.html#b416604da9233aa2cd9d0ddc17d0742e">ifTrue</a>), ifFalse(ifFalse), sel(sel)
<a name="l00786"></a>00786                 {}
<a name="l00787"></a>00787             <span class="keyword">virtual</span> <span class="keywordtype">void</span> run()<span class="keyword"> const </span>{
<a name="l00788"></a>00788                 <a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;</a> res;
<a name="l00789"></a>00789                 <span class="keywordflow">if</span> (sel-&gt;get().name != 0 || (sel-&gt;get().name == 0 &amp;&amp; sel-&gt;get().offset == 1)) {
<a name="l00790"></a>00790                     res.<a class="code" href="structLatticeElement.html#1fa61bab0a3202eb472eae5e8e989f16">merge</a>(<a class="code" href="structFindConstantsPolicy.html#b416604da9233aa2cd9d0ddc17d0742e">ifTrue</a>-&gt;get(), result-&gt;myName, result-&gt;def);
<a name="l00791"></a>00791                 }
<a name="l00792"></a>00792                 <span class="keywordflow">if</span> (sel-&gt;get().name != 0 || (sel-&gt;get().name == 0 &amp;&amp; sel-&gt;get().offset == 0)) {
<a name="l00793"></a>00793                     res.<a class="code" href="structLatticeElement.html#1fa61bab0a3202eb472eae5e8e989f16">merge</a>(ifFalse-&gt;get(), result-&gt;myName, result-&gt;def);
<a name="l00794"></a>00794                 }
<a name="l00795"></a>00795                 result-&gt;set(res);
<a name="l00796"></a>00796             }
<a name="l00797"></a>00797             <span class="keyword">virtual</span> <span class="keywordtype">void</span> markDependencies() {
<a name="l00798"></a>00798                 addDependency(sel);
<a name="l00799"></a>00799                 addDependency(<a class="code" href="structFindConstantsPolicy.html#b416604da9233aa2cd9d0ddc17d0742e">ifTrue</a>);
<a name="l00800"></a>00800                 addDependency(ifFalse);
<a name="l00801"></a>00801             }
<a name="l00802"></a>00802         };
<a name="l00803"></a>00803         (<span class="keyword">new</span> IteConstraint(result, sel, <a class="code" href="structFindConstantsPolicy.html#b416604da9233aa2cd9d0ddc17d0742e">ifTrue</a>, ifFalse))-&gt;activate();
<a name="l00804"></a>00804         <span class="keywordflow">return</span> result;
<a name="l00805"></a>00805     }
<a name="l00806"></a>00806 
<a name="l00807"></a>00807     <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00808"></a>00808     <a class="code" href="structFindConstantsPolicy.html#98c6aa5182dea8f9128421b7e92f7757">UNARY_COMPUTATION</a>(equalToZero, <a class="code" href="structFindConstantsPolicy.html#54dbfd93eae48399930ad8875b51d183">Len</a>, 1, {<span class="keywordflow">return</span> (a == 0);})
<a name="l00809"></a>00809 
<a name="l00810"></a>00810     template &lt;size_t Len, size_t SCLen&gt;
<a name="l00811"></a>00811     <a class="code" href="structFindConstantsPolicy.html#98c6aa5182dea8f9128421b7e92f7757">UNARY_COMPUTATION</a>(generateMask, SCLen, <a class="code" href="structFindConstantsPolicy.html#54dbfd93eae48399930ad8875b51d183">Len</a>, {<span class="keywordflow">return</span> IntegerOps::genMask&lt;uint64_t&gt;(a);})
<a name="l00812"></a>00812 
<a name="l00813"></a>00813 #<span class="keywordflow">if</span> 1
<a name="l00814"></a>00814     template &lt;size_t Len&gt;
<a name="l00815"></a><a class="code" href="structFindConstantsPolicy.html#ea0af22cd2fa76a42b432e5d96fbefaf">00815</a>     <a class="code" href="findConstants_8h.html#b60e9a0c85be40774c6f3a44bf7bbc26">BINARY_COMPUTATION_SPECIAL</a>(<a class="code" href="namespacecfgUtils.html#495bbf2d6fb84a47ca0cc937068ab793">add</a>, <a class="code" href="structFindConstantsPolicy.html#54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#54dbfd93eae48399930ad8875b51d183">Len</a>, <a class="code" href="structFindConstantsPolicy.html#54dbfd93eae48399930ad8875b51d183">Len</a>, {
<a name="l00816"></a>00816             <span class="keywordflow">if</span> (le1.name == 0 || le2.name == 0) {
<a name="l00817"></a>00817                 result-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;</a>(le1.name + le2.name, result-&gt;def,
<a name="l00818"></a>00818                                                 le1.negate || le2.negate, le1.offset + le2.offset));
<a name="l00819"></a>00819                 <span class="keywordflow">return</span>;
<a name="l00820"></a>00820             }
<a name="l00821"></a>00821             <span class="keywordflow">if</span> (le1.name == le2.name &amp;&amp; le1.negate == !le2.negate) {
<a name="l00822"></a>00822                 result-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;::constant</a>(le1.offset + le2.offset, result-&gt;def));
<a name="l00823"></a>00823                 <span class="keywordflow">return</span>;
<a name="l00824"></a>00824             }
<a name="l00825"></a>00825             result-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;::nonconstant</a>(result-&gt;myName, result-&gt;def));
<a name="l00826"></a>00826         })
<a name="l00827"></a>00827 #<span class="keywordflow">else</span>
<a name="l00828"></a>00828     template &lt;size_t Len&gt;
<a name="l00829"></a>00829     <a class="code" href="findConstants_8h.html#0c4b579c98b326eab605862dc73feb78">BINARY_COMPUTATION</a>(<a class="code" href="namespacecfgUtils.html#495bbf2d6fb84a47ca0cc937068ab793">add</a>, Len, Len, Len, {<span class="keywordflow">return</span> (a &amp; b);})
<a name="l00830"></a>00830 
<a name="l00831"></a>00831 #endif
<a name="l00832"></a>00832 
<a name="l00833"></a>00833 
<a name="l00834"></a>00834     template &lt;size_t Len&gt;
<a name="l00835"></a>00835     <a class="code" href="findConstants_8h.html#cfeda32a953312c23784c6cd3c9ef85c">TERNARY_COMPUTATION_SPECIAL</a>(add3, Len, Len, 1, Len, {
<a name="l00836"></a>00836             <span class="keywordflow">if</span> ((le1.name == 0) + (le2.name == 0) + (le3.name == 0)) {
<a name="l00837"></a>00837                 result-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;</a>(le1.name + le2.name + le3.name, result-&gt;def,
<a name="l00838"></a>00838                                                 le1.negate || le2.negate || le3.negate,
<a name="l00839"></a>00839                                                 le1.offset + le2.offset + le3.offset));
<a name="l00840"></a>00840                 <span class="keywordflow">return</span>;
<a name="l00841"></a>00841             }
<a name="l00842"></a>00842             <span class="keywordflow">if</span> (le1.name == le2.name &amp;&amp; le3.name == 0 &amp;&amp; le1.negate == !le2.negate) {
<a name="l00843"></a>00843                 result-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;::constant</a>(le1.offset + le2.offset + le3.offset, result-&gt;def));
<a name="l00844"></a>00844                 <span class="keywordflow">return</span>;
<a name="l00845"></a>00845             }
<a name="l00846"></a>00846             result-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;::nonconstant</a>(result-&gt;myName, result-&gt;def));
<a name="l00847"></a>00847         })
<a name="l00848"></a>00848 
<a name="l00849"></a>00849     template &lt;size_t Len&gt;
<a name="l00850"></a>00850     <a class="code" href="findConstants_8h.html#c665060a61498a5dc2f60f3fb9a0dd52">TERNARY_COMPUTATION</a>(xor3, Len, Len, Len, Len, {<span class="keywordflow">return</span> (a ^ b ^ c);})
<a name="l00851"></a>00851 
<a name="l00852"></a>00852     template &lt;size_t Len&gt;
<a name="l00853"></a>00853     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> addWithCarries(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> a, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> b, XVariablePtr&lt;1&gt; carryIn,
<a name="l00854"></a>00854                                      <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a>&amp; carries) { <span class="comment">// Full case</span>
<a name="l00855"></a>00855         <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len + 1&gt;</a> aa = unsignedExtend&lt;Len, Len + 1&gt;(a);
<a name="l00856"></a>00856         <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len + 1&gt;</a> bb = unsignedExtend&lt;Len, Len + 1&gt;(b);
<a name="l00857"></a>00857         <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len + 1&gt;</a> result = add3(aa, bb, carryIn);
<a name="l00858"></a>00858         carries = extract&lt;1, Len + 1&gt;(xor3(aa, bb, result));
<a name="l00859"></a>00859         <span class="keywordflow">return</span> extract&lt;0, Len&gt;(result);
<a name="l00860"></a>00860     }
<a name="l00861"></a>00861 
<a name="l00862"></a>00862     <span class="keyword">template</span> &lt;size_t Len, size_t SALen&gt;
<a name="l00863"></a>00863     <a class="code" href="findConstants_8h.html#0c4b579c98b326eab605862dc73feb78">BINARY_COMPUTATION</a>(<a class="code" href="namespaceIntegerOps.html#a9ad618b00dd29b0e1de197599a629ed">rotateLeft</a>, Len, SALen, Len, {
<a name="l00864"></a>00864             <span class="keywordflow">return</span> IntegerOps::rotateLeft&lt;Len&gt;(a, b);
<a name="l00865"></a>00865         })
<a name="l00866"></a>00866 
<a name="l00867"></a>00867     template &lt;size_t Len, size_t SALen&gt;
<a name="l00868"></a>00868     <a class="code" href="findConstants_8h.html#0c4b579c98b326eab605862dc73feb78">BINARY_COMPUTATION</a>(<a class="code" href="namespaceIntegerOps.html#fa7a644d6e51ff9c9e1a709b65918f04">rotateRight</a>, Len, SALen, Len, {
<a name="l00869"></a>00869             <span class="keywordflow">return</span> IntegerOps::rotateRight&lt;Len&gt;(a, b);
<a name="l00870"></a>00870         })
<a name="l00871"></a>00871 
<a name="l00872"></a>00872     template &lt;size_t Len, size_t SALen&gt;
<a name="l00873"></a>00873     <a class="code" href="findConstants_8h.html#0c4b579c98b326eab605862dc73feb78">BINARY_COMPUTATION</a>(<a class="code" href="namespaceIntegerOps.html#ee89739520fac27f3fd0c0722af8f9e4">shiftLeft</a>, Len, SALen, Len, {
<a name="l00874"></a>00874             <span class="keywordflow">return</span> IntegerOps::shiftLeft&lt;Len&gt;(a, b);
<a name="l00875"></a>00875         })
<a name="l00876"></a>00876 
<a name="l00877"></a>00877     template &lt;size_t Len, size_t SALen&gt;
<a name="l00878"></a>00878     <a class="code" href="findConstants_8h.html#0c4b579c98b326eab605862dc73feb78">BINARY_COMPUTATION</a>(shiftRight, Len, SALen, Len, {
<a name="l00879"></a>00879             <span class="keywordflow">return</span> IntegerOps::shiftRightLogical&lt;Len&gt;(a, b);
<a name="l00880"></a>00880         })
<a name="l00881"></a>00881 
<a name="l00882"></a>00882     template &lt;size_t Len, size_t SALen&gt;
<a name="l00883"></a>00883     <a class="code" href="findConstants_8h.html#0c4b579c98b326eab605862dc73feb78">BINARY_COMPUTATION</a>(<a class="code" href="namespaceIntegerOps.html#20fd16b646b248063813270484fe7b63">shiftRightArithmetic</a>, Len, SALen, Len, {
<a name="l00884"></a>00884             <span class="keywordflow">return</span> IntegerOps::shiftRightArithmetic&lt;Len&gt;(a, b);
<a name="l00885"></a>00885         })
<a name="l00886"></a>00886 
<a name="l00887"></a>00887     template &lt;size_t Len1, size_t Len2&gt;
<a name="l00888"></a>00888     <a class="code" href="findConstants_8h.html#0c4b579c98b326eab605862dc73feb78">BINARY_COMPUTATION</a>(signedMultiply, Len1, Len2, Len1 + Len2, {
<a name="l00889"></a>00889             <span class="keywordflow">return</span> (IntegerOps::signExtend&lt;Len1, 64&gt;(a) * IntegerOps::signExtend&lt;Len2, 64&gt;(b));
<a name="l00890"></a>00890         })
<a name="l00891"></a>00891 
<a name="l00892"></a>00892     template &lt;size_t Len1, size_t Len2&gt;
<a name="l00893"></a>00893     <a class="code" href="findConstants_8h.html#0c4b579c98b326eab605862dc73feb78">BINARY_COMPUTATION</a>(unsignedMultiply, Len1, Len2, Len1 + Len2, {
<a name="l00894"></a>00894             <span class="keywordflow">return</span> (a * b);
<a name="l00895"></a>00895         })
<a name="l00896"></a>00896 
<a name="l00897"></a>00897     template &lt;size_t Len1, size_t Len2&gt;
<a name="l00898"></a>00898     <a class="code" href="findConstants_8h.html#0c4b579c98b326eab605862dc73feb78">BINARY_COMPUTATION</a>(signedDivide, Len1, Len2, Len1, {
<a name="l00899"></a>00899             <span class="keywordflow">return</span> (IntegerOps::signExtend&lt;Len1, 64&gt;(a) / IntegerOps::signExtend&lt;Len2, 64&gt;(b));
<a name="l00900"></a>00900         })
<a name="l00901"></a>00901 
<a name="l00902"></a>00902     template &lt;size_t Len1, size_t Len2&gt;
<a name="l00903"></a>00903     <a class="code" href="findConstants_8h.html#0c4b579c98b326eab605862dc73feb78">BINARY_COMPUTATION</a>(signedModulo, Len1, Len2, Len2, {
<a name="l00904"></a>00904             <span class="keywordflow">return</span> (IntegerOps::signExtend&lt;Len1, 64&gt;(a) % IntegerOps::signExtend&lt;Len2, 64&gt;(b))
<a name="l00905"></a>00905                 ;})
<a name="l00906"></a>00906 
<a name="l00907"></a>00907     template &lt;size_t Len1, size_t Len2&gt;
<a name="l00908"></a>00908     <a class="code" href="findConstants_8h.html#0c4b579c98b326eab605862dc73feb78">BINARY_COMPUTATION</a>(unsignedDivide, Len1, Len2, Len1, {
<a name="l00909"></a>00909             <span class="keywordflow">if</span> (0==b) <span class="keywordflow">throw</span> std::string(<span class="stringliteral">"division by zero"</span>);
<a name="l00910"></a>00910             <span class="keywordflow">return</span> (a / b);
<a name="l00911"></a>00911         })
<a name="l00912"></a>00912 
<a name="l00913"></a>00913     template &lt;size_t Len1, size_t Len2&gt;
<a name="l00914"></a>00914     <a class="code" href="findConstants_8h.html#0c4b579c98b326eab605862dc73feb78">BINARY_COMPUTATION</a>(unsignedModulo, Len1, Len2, Len2, {
<a name="l00915"></a>00915             <span class="keywordflow">return</span> (a % b);
<a name="l00916"></a>00916         })
<a name="l00917"></a>00917 
<a name="l00918"></a>00918     template &lt;size_t Len&gt;
<a name="l00919"></a><a class="code" href="structFindConstantsPolicy.html#54dbfd93eae48399930ad8875b51d183">00919</a>     <a class="code" href="findConstants_8h.html#e7b82ea56326cd6904040a31de88c3c3">UNARY_COMPUTATION</a>(leastSignificantSetBit, Len, Len, {
<a name="l00920"></a>00920             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (int)Len; ++i) {
<a name="l00921"></a>00921                 <span class="keywordflow">if</span> (a &amp; IntegerOps::shl1&lt;uint64_t&gt;(i))
<a name="l00922"></a>00922                     <span class="keywordflow">return</span> i;
<a name="l00923"></a>00923             }
<a name="l00924"></a>00924             <span class="keywordflow">return</span> 0;
<a name="l00925"></a>00925         })
<a name="l00926"></a>00926 
<a name="l00927"></a>00927     template &lt;size_t Len&gt;
<a name="l00928"></a>00928     <a class="code" href="findConstants_8h.html#e7b82ea56326cd6904040a31de88c3c3">UNARY_COMPUTATION</a>(mostSignificantSetBit, Len, Len, {
<a name="l00929"></a>00929             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = (<span class="keywordtype">int</span>)Len - 1; i &gt;= 0; --i) {
<a name="l00930"></a>00930                 <span class="keywordflow">if</span> (a &amp; IntegerOps::shl1&lt;uint64_t&gt;(i))
<a name="l00931"></a>00931                     <span class="keywordflow">return</span> i;
<a name="l00932"></a>00932             }
<a name="l00933"></a>00933             <span class="keywordflow">return</span> 0;
<a name="l00934"></a>00934         })
<a name="l00935"></a>00935 
<a name="l00936"></a>00936     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> filterIndirectJumpTarget(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> x) {
<a name="l00937"></a>00937         <span class="keywordflow">return</span> x;
<a name="l00938"></a>00938     }
<a name="l00939"></a>00939     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> filterCallTarget(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> x) {
<a name="l00940"></a>00940         <span class="keywordflow">return</span> x;
<a name="l00941"></a>00941     }
<a name="l00942"></a>00942     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> filterReturnTarget(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> x) {
<a name="l00943"></a>00943         <span class="keywordflow">return</span> x;
<a name="l00944"></a>00944     }
<a name="l00945"></a>00945 
<a name="l00946"></a>00946     <span class="keyword">template</span> &lt;size_t Len&gt; <span class="comment">// In bits</span>
<a name="l00947"></a>00947     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> readMemory(<a class="code" href="InstructionEnumsX86_8h.html#0b09709b1ff4de1bbe47357b6d7b0e64">X86SegmentRegister</a> segreg, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> addr, XVariablePtr&lt;1&gt; cond) {
<a name="l00948"></a>00948         <span class="keyword">struct </span>ReadMemoryConstraint: <span class="keyword">public</span> <a class="code" href="classConstraint.html">Constraint</a> {
<a name="l00949"></a>00949             <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> result;
<a name="l00950"></a>00950             <a class="code" href="structMemoryVariable.html">MemoryVariable</a>* memory;
<a name="l00951"></a>00951             <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> addr;
<a name="l00952"></a>00952             <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classConstraint.html#fcd47b251bab4ac412cb8df1dd2061e1">run</a>()<span class="keyword"> const </span>{
<a name="l00953"></a>00953                 <a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;</a> resultRaw;
<a name="l00954"></a>00954                 <span class="keyword">const</span> <a class="code" href="structMemoryWriteSet.html">MemoryWriteSet</a> &amp;mws = memory-&gt;get();
<a name="l00955"></a>00955                 mws.<a class="code" href="structMemoryWriteSet.html#00d40ef766dfec837e30794fed35ec85">getValueAtAddress</a>&lt;Len&gt;(addr-&gt;get(), resultRaw, result-&gt;myName, result-&gt;def);
<a name="l00956"></a>00956                 result-&gt;set(resultRaw);
<a name="l00957"></a>00957             }
<a name="l00958"></a>00958             <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classConstraint.html#2e1c1df843248f378b1850b6becfa77a">markDependencies</a>() {
<a name="l00959"></a>00959                 <a class="code" href="classConstraint.html#30feaf180bce5c1a0cfeee0be9983a93">addDependency</a>(memory);
<a name="l00960"></a>00960                 <a class="code" href="classConstraint.html#30feaf180bce5c1a0cfeee0be9983a93">addDependency</a>(addr);
<a name="l00961"></a>00961             }
<a name="l00962"></a>00962         };
<a name="l00963"></a>00963         ReadMemoryConstraint* c = <span class="keyword">new</span> ReadMemoryConstraint();
<a name="l00964"></a>00964         c-&gt;result = <span class="keyword">new</span> <a class="code" href="structXVariable.html">XVariable&lt;Len&gt;</a>();
<a name="l00965"></a>00965         c-&gt;memory = cur_state.memoryWrites;
<a name="l00966"></a>00966         c-&gt;addr = addr;
<a name="l00967"></a>00967         c-&gt;activate();
<a name="l00968"></a>00968         <span class="keywordflow">return</span> c-&gt;result;
<a name="l00969"></a>00969     }
<a name="l00970"></a>00970 
<a name="l00971"></a>00971     <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00972"></a>00972     <span class="keyword">static</span> <a class="code" href="structMemoryVariable.html">MemoryVariable</a>* memoryWriteHelper(<a class="code" href="structMemoryVariable.html">MemoryVariable</a>* memory, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> address, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> data) {
<a name="l00973"></a>00973         <span class="keyword">struct </span>C: <span class="keyword">public</span> <a class="code" href="classConstraint.html">Constraint</a> {
<a name="l00974"></a>00974             <a class="code" href="structMemoryVariable.html">MemoryVariable</a>* memory;
<a name="l00975"></a>00975             <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> address;
<a name="l00976"></a>00976             <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> data;
<a name="l00977"></a>00977             <a class="code" href="structMemoryVariable.html">MemoryVariable</a>* memoryOut;
<a name="l00978"></a>00978             <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classConstraint.html#fcd47b251bab4ac412cb8df1dd2061e1">run</a>()<span class="keyword"> const </span>{
<a name="l00979"></a>00979                 <a class="code" href="structMemoryWriteSet.html">MemoryWriteSet</a> mws = memory-&gt;<a class="code" href="structMemoryVariable.html#afe7886f04c547485bb7b0fe23d2093b">get</a>();
<a name="l00980"></a>00980                 mws.<a class="code" href="structMemoryWriteSet.html#0ffbc1b898a737117ce4d5210ba314a7">addWrite</a>(address-&gt;get(), unsignedExtend&lt;Len, 32&gt;(data)-&gt;get(), Len / 8);
<a name="l00981"></a>00981                 memoryOut-&gt;set(mws);
<a name="l00982"></a>00982             }
<a name="l00983"></a>00983             <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classConstraint.html#2e1c1df843248f378b1850b6becfa77a">markDependencies</a>() {<a class="code" href="classConstraint.html#30feaf180bce5c1a0cfeee0be9983a93">addDependency</a>(memory); <a class="code" href="classConstraint.html#30feaf180bce5c1a0cfeee0be9983a93">addDependency</a>(address); <a class="code" href="classConstraint.html#30feaf180bce5c1a0cfeee0be9983a93">addDependency</a>(data);}
<a name="l00984"></a>00984         };
<a name="l00985"></a>00985         C* c = <span class="keyword">new</span> C();
<a name="l00986"></a>00986         c-&gt;memory = memory;
<a name="l00987"></a>00987         c-&gt;address = address;
<a name="l00988"></a>00988         c-&gt;data = data;
<a name="l00989"></a>00989         c-&gt;memoryOut = <span class="keyword">new</span> <a class="code" href="structMemoryVariable.html">MemoryVariable</a>();
<a name="l00990"></a>00990         c-&gt;activate();
<a name="l00991"></a>00991         <span class="keywordflow">return</span> c-&gt;memoryOut;
<a name="l00992"></a>00992     }
<a name="l00993"></a>00993 
<a name="l00995"></a>00995     <span class="keyword">template</span> &lt;size_t Len&gt;
<a name="l00996"></a>00996     <span class="keywordtype">void</span> writeMemory(<a class="code" href="InstructionEnumsX86_8h.html#0b09709b1ff4de1bbe47357b6d7b0e64">X86SegmentRegister</a> segreg, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> addr, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> data, XVariablePtr&lt;1&gt; cond) {
<a name="l00997"></a>00997         cur_state.memoryWrites = memoryWriteHelper(cur_state.memoryWrites, addr, data);
<a name="l00998"></a>00998     }
<a name="l00999"></a>00999 
<a name="l01001"></a>01001     <span class="keyword">template</span> &lt;size_t nbits&gt;
<a name="l01002"></a>01002     <span class="keywordtype">void</span> writeMemory(<a class="code" href="InstructionEnumsX86_8h.html#0b09709b1ff4de1bbe47357b6d7b0e64">X86SegmentRegister</a> segreg, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> addr, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;nbits&gt;</a> data, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> repeat,
<a name="l01003"></a>01003                      XVariablePtr&lt;1&gt; cond) {
<a name="l01004"></a>01004         <span class="comment">/* If repeat is a constant then perform the write that number of times. */</span>
<a name="l01005"></a>01005         <span class="keywordflow">if</span> (0==repeat-&gt;get().name) {
<a name="l01006"></a>01006             <span class="keywordflow">for</span> (size_t i=0; i&lt;repeat-&gt;get().offset; i++) {
<a name="l01007"></a>01007                 <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;32&gt;</a> tmp_addr = <a class="code" href="namespacecfgUtils.html#495bbf2d6fb84a47ca0cc937068ab793">add</a>(addr, number&lt;32&gt;(i*nbits/8));
<a name="l01008"></a>01008                 cur_state.memoryWrites = memoryWriteHelper(cur_state.memoryWrites, tmp_addr, data);
<a name="l01009"></a>01009             }
<a name="l01010"></a>01010         } <span class="keywordflow">else</span> {
<a name="l01011"></a>01011             cur_state.memoryWrites = memoryWriteHelper(cur_state.memoryWrites, addr, data);
<a name="l01012"></a>01012         }
<a name="l01013"></a>01013     }
<a name="l01014"></a>01014 
<a name="l01015"></a>01015     <span class="keywordtype">void</span> hlt() {} <span class="comment">// FIXME</span>
<a name="l01016"></a>01016 
<a name="l01017"></a>01017     <span class="keywordtype">void</span> cpuid() {} <span class="comment">// FIXME</span>
<a name="l01018"></a>01018 
<a name="l01019"></a>01019     <span class="keywordtype">void</span> interrupt(uint8_t num) {
<a name="l01020"></a>01020         cur_state.setToBottom();
<a name="l01021"></a>01021     }
<a name="l01022"></a>01022 
<a name="l01023"></a>01023     <span class="keywordtype">void</span> sysenter() {
<a name="l01024"></a>01024         cur_state.setToBottom();
<a name="l01025"></a>01025     }
<a name="l01026"></a>01026 
<a name="l01027"></a>01027     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;64&gt;</a> rdtsc() { <span class="comment">// FIXME</span>
<a name="l01028"></a>01028         <span class="keywordflow">return</span> number&lt;64&gt;(0);
<a name="l01029"></a>01029     }
<a name="l01030"></a>01030     <span class="keywordtype">void</span> startBlock(uint64_t addr) {}
<a name="l01031"></a>01031 
<a name="l01032"></a>01032     <span class="keywordtype">void</span> finishBlock(uint64_t addr) {}
<a name="l01033"></a>01033 
<a name="l01038"></a>01038     <span class="keywordtype">bool</span> isInstructionExternallyVisible(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a>* insn)<span class="keyword"> const </span>{
<a name="l01039"></a>01039         <span class="keywordflow">return</span> isFunctionEntry(insn);
<a name="l01040"></a>01040     }
<a name="l01041"></a>01041 
<a name="l01043"></a>01043     <span class="keywordtype">bool</span> isFunctionEntry(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn)<span class="keyword"> const </span>{
<a name="l01044"></a>01044         <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *fdefn = containingFunction(insn);
<a name="l01045"></a>01045         ROSE_ASSERT(fdefn);
<a name="l01046"></a>01046         <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *first_bb = <a class="code" href="Cxx__Grammar_8h.html#0f21c6b7a4aede1900e16a5122233a83">isSgAsmBlock</a>(fdefn-&gt;<a class="code" href="classSgAsmFunction.html#08fe036249766f5c7bca4403851f9cab">get_statementList</a>()[0]);
<a name="l01047"></a>01047         <span class="keywordflow">return</span> first_bb-&gt;<a class="code" href="classSgAsmBlock.html#db50d2cc18f2d004a62c4b5f29c36643">get_id</a>()==insn-&gt;<a class="code" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>();
<a name="l01048"></a>01048     }
<a name="l01049"></a>01049     
<a name="l01051"></a>01051     <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *
<a name="l01052"></a>01052     containingFunction(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn)<span class="keyword"> const </span>{
<a name="l01053"></a>01053         <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *bb = <a class="code" href="Cxx__Grammar_8h.html#0f21c6b7a4aede1900e16a5122233a83">isSgAsmBlock</a>(insn-&gt;<a class="code" href="classSgNode.html#aa13b978be2c93c2d6d78f14fbc0e314">get_parent</a>());
<a name="l01054"></a>01054         ROSE_ASSERT(bb!=NULL);
<a name="l01055"></a>01055         <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *fdefn = <a class="code" href="Cxx__Grammar_8h.html#3374b86a87959b6a02d8ca8f792d693e">isSgAsmFunction</a>(bb-&gt;<a class="code" href="classSgNode.html#aa13b978be2c93c2d6d78f14fbc0e314">get_parent</a>());
<a name="l01056"></a>01056         ROSE_ASSERT(fdefn!=NULL);
<a name="l01057"></a>01057         <span class="keywordflow">return</span> fdefn;
<a name="l01058"></a>01058     }
<a name="l01059"></a>01059 
<a name="l01061"></a>01061     <span class="keywordtype">void</span> startInstruction(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a>* insn) {
<a name="l01062"></a>01062         addr = insn-&gt;<a class="code" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>();
<a name="l01063"></a>01063         newIp = number&lt;32&gt;(addr);
<a name="l01064"></a>01064         <span class="keywordflow">if</span> (isInstructionExternallyVisible(insn)) {
<a name="l01065"></a>01065             <span class="keywordflow">if</span> (orig_state) {
<a name="l01066"></a>01066                 rsets[addr] = *orig_state;
<a name="l01067"></a>01067                 orig_state = NULL;
<a name="l01068"></a>01068             } <span class="keywordflow">else</span> {
<a name="l01069"></a>01069                 rsets[addr].setToBottom();
<a name="l01070"></a>01070             }
<a name="l01071"></a>01071         }
<a name="l01072"></a>01072         cur_state = rsets[addr];
<a name="l01073"></a>01073         <a class="code" href="findConstants_8h.html#95f018a40d9bdcb7c342a55a4503c9c1">currentInstruction</a> = <a class="code" href="Cxx__Grammar_8h.html#a821b70974acc822c032fddf101296e9">isSgAsmx86Instruction</a>(insn);
<a name="l01074"></a>01074     }
<a name="l01075"></a>01075 
<a name="l01078"></a>01078     <span class="keywordtype">void</span> finishInstruction(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a>* insn) {
<a name="l01079"></a>01079         <a class="code" href="findConstants_8h.html#95f018a40d9bdcb7c342a55a4503c9c1">currentInstruction</a> = NULL;
<a name="l01080"></a>01080         <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* insnx = <a class="code" href="Cxx__Grammar_8h.html#a821b70974acc822c032fddf101296e9">isSgAsmx86Instruction</a>(insn);
<a name="l01081"></a>01081         ROSE_ASSERT (insnx);
<a name="l01082"></a>01082         std::vector&lt;uint64_t&gt; succs;
<a name="l01083"></a>01083         <span class="keywordflow">if</span> (newIp-&gt;get().name == 0) {
<a name="l01084"></a>01084             <span class="comment">/* We know the address of the next instruction. */</span>
<a name="l01085"></a>01085             succs.push_back(newIp-&gt;get().offset);
<a name="l01086"></a>01086         } <span class="keywordflow">else</span> {
<a name="l01087"></a>01087             <span class="comment">/* We don't know the address of the next instruction, so compute it from successors */</span>
<a name="l01088"></a>01088             uint64_t nextAddr = insnx-&gt;<a class="code" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>() + insnx-&gt;<a class="code" href="classSgAsmInstruction.html#c239f0d80ab88127b2543fb0990803c3">get_raw_bytes</a>().size();
<a name="l01089"></a>01089             <span class="keywordflow">if</span> (!x86InstructionIsUnconditionalBranch(insnx)) {
<a name="l01090"></a>01090                 succs.push_back(nextAddr);
<a name="l01091"></a>01091             }
<a name="l01092"></a>01092             <span class="keywordflow">if</span> (isAsmBranch(insnx)) {
<a name="l01093"></a>01093                 uint64_t addr = 0;
<a name="l01094"></a>01094                 <span class="keywordtype">bool</span> knownTarget = getAsmKnownBranchTarget(insnx, addr);
<a name="l01095"></a>01095                 <span class="keywordflow">if</span> (knownTarget) {
<a name="l01096"></a>01096                     succs.push_back(addr);
<a name="l01097"></a>01097                 }
<a name="l01098"></a>01098             }
<a name="l01099"></a>01099         }
<a name="l01100"></a>01100 
<a name="l01101"></a>01101         <span class="comment">/* Merge result of processing instruction into register sets for successors */</span>
<a name="l01102"></a>01102         <span class="keywordflow">for</span> (size_t i = 0; i &lt; succs.size(); ++i) {
<a name="l01103"></a>01103             uint64_t s = succs[i];
<a name="l01104"></a>01104             rsets[s].mergeIn(cur_state);
<a name="l01105"></a>01105         }
<a name="l01106"></a>01106     }
<a name="l01107"></a>01107 
<a name="l01108"></a>01108 <span class="preprocessor">#define ValueType XVariablePtr</span>
<a name="l01109"></a>01109 <span class="preprocessor"></span><span class="preprocessor">#define EIP_LOCATION newIp</span>
<a name="l01110"></a>01110 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="ReadWriteRegisterFragment_8h.html">ReadWriteRegisterFragment.h</a>"</span>
<a name="l01111"></a>01111 <span class="preprocessor">#undef ValueType</span>
<a name="l01112"></a>01112 <span class="preprocessor"></span>    
<a name="l01113"></a>01113 };
<a name="l01114"></a>01114 
<a name="l01116"></a><a class="code" href="classCdeclFunctionPolicy.html">01116</a> <span class="keyword">class </span><a class="code" href="classCdeclFunctionPolicy.html">CdeclFunctionPolicy</a> : <span class="keyword">public</span> <a class="code" href="structFindConstantsPolicy.html">FindConstantsPolicy</a> {
<a name="l01117"></a><a class="code" href="classCdeclFunctionPolicy.html#73d074e7e22a7df4ed3b4ff5b3d21c60">01117</a>     <a class="code" href="structVirtualBinCFG_1_1AuxiliaryInformation.html">VirtualBinCFG::AuxiliaryInformation</a> *<a class="code" href="classCdeclFunctionPolicy.html#73d074e7e22a7df4ed3b4ff5b3d21c60">info</a>;
<a name="l01118"></a>01118 <span class="keyword">public</span>:
<a name="l01119"></a><a class="code" href="classCdeclFunctionPolicy.html#0effeecd6ac9860e36bb1110acb4c2ac">01119</a>     <a class="code" href="classCdeclFunctionPolicy.html#0effeecd6ac9860e36bb1110acb4c2ac">CdeclFunctionPolicy</a>(<a class="code" href="structVirtualBinCFG_1_1AuxiliaryInformation.html">VirtualBinCFG::AuxiliaryInformation</a> *<a class="code" href="classCdeclFunctionPolicy.html#73d074e7e22a7df4ed3b4ff5b3d21c60">info</a>, <a class="code" href="structRegisterSet.html">RegisterSet</a> *rs)
<a name="l01120"></a>01120         : <a class="code" href="structFindConstantsPolicy.html">FindConstantsPolicy</a>(rs), <a class="code" href="classCdeclFunctionPolicy.html#73d074e7e22a7df4ed3b4ff5b3d21c60">info</a>(<a class="code" href="classCdeclFunctionPolicy.html#73d074e7e22a7df4ed3b4ff5b3d21c60">info</a>) {}
<a name="l01121"></a>01121 
<a name="l01123"></a><a class="code" href="classCdeclFunctionPolicy.html#e4136b6bffb4c46c7f16476906b24d31">01123</a>     <span class="keywordtype">void</span> <a class="code" href="classCdeclFunctionPolicy.html#e4136b6bffb4c46c7f16476906b24d31">startInstruction</a>(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a>* insn) {
<a name="l01124"></a>01124         <span class="comment">/* Any instruction that is a branch target should set the registerset to bottom rather than top. This isn't actually</span>
<a name="l01125"></a>01125 <span class="comment">         * the accurate thing to do, but it turns out that it works better this way for finding the signal handlers. */</span>
<a name="l01126"></a>01126         VirtualBinCFG::InstructionToAddressesMap::iterator found = <a class="code" href="classCdeclFunctionPolicy.html#73d074e7e22a7df4ed3b4ff5b3d21c60">info</a>-&gt;<a class="code" href="structVirtualBinCFG_1_1AuxiliaryInformation.html#44cd3f1f8fa5ec7e5d896bdda75850b5">incomingEdges</a>.find(insn);
<a name="l01127"></a>01127         <span class="keywordflow">if</span> (found!=<a class="code" href="classCdeclFunctionPolicy.html#73d074e7e22a7df4ed3b4ff5b3d21c60">info</a>-&gt;<a class="code" href="structVirtualBinCFG_1_1AuxiliaryInformation.html#44cd3f1f8fa5ec7e5d896bdda75850b5">incomingEdges</a>.end() &amp;&amp; found-&gt;second.size()&gt;1) {
<a name="l01128"></a>01128             <a class="code" href="structRegisterSet.html">RegisterSet</a> &amp;rs = <a class="code" href="structFindConstantsPolicy.html#86ad83f3a1aeb15f05c22295a649c304">rsets</a>[insn-&gt;<a class="code" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>()];
<a name="l01129"></a>01129             <a class="code" href="structMemoryWriteSet.html">MemoryWriteSet</a> saved = rs.memoryWrites-&gt;get();
<a name="l01130"></a>01130             rs.setToBottom();
<a name="l01131"></a>01131             rs.memoryWrites-&gt;set(saved);
<a name="l01132"></a>01132         }
<a name="l01133"></a>01133 
<a name="l01134"></a>01134         FindConstantsPolicy::startInstruction(insn);
<a name="l01135"></a>01135 
<a name="l01136"></a>01136         <span class="comment">/* GCC assumes that the direction flag (df) is zero on function entry. See gcc man page for -mcld switch. */</span>
<a name="l01137"></a>01137         <a class="code" href="structLatticeElement.html">LatticeElement&lt;1&gt;</a> df = <a class="code" href="structFindConstantsPolicy.html#86ad83f3a1aeb15f05c22295a649c304">rsets</a>[insn-&gt;<a class="code" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>()].registers.flag[<a class="code" href="InstructionEnumsX86_8h.html#b8c1069abaa6534f3481d52cfe950881749200f06e597afec773e54419dad228">x86_flag_df</a>]-&gt;get();
<a name="l01138"></a>01138         <span class="keywordflow">if</span> (df.<a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a>!=0)
<a name="l01139"></a>01139             <a class="code" href="ReadWriteRegisterFragment_8h.html#a3a47604d11466752f2df25a16618c38">writeRegister</a>(<span class="stringliteral">"df"</span>, false_());
<a name="l01140"></a>01140 
<a name="l01141"></a>01141 <span class="preprocessor">#if 0   </span><span class="comment">/*DEBUGGING: Show register set at start of instruction */</span>
<a name="l01142"></a>01142         std::cout &lt;&lt;<span class="stringliteral">"Initial RSET for ["</span> &lt;&lt;<a class="code" href="AsmUnparser__compat_8h.html#3b979292833b85f5b059b2893250453c">unparseInstructionWithAddress</a>(insn) &lt;&lt;<span class="stringliteral">"]\n"</span> &lt;&lt;<a class="code" href="structFindConstantsPolicy.html#082de1b51d4e70ec27fe6c5a3e5b3bb2">cur_state</a>;
<a name="l01143"></a>01143 <span class="preprocessor">#endif</span>
<a name="l01144"></a>01144 <span class="preprocessor"></span>    }
<a name="l01145"></a>01145 
<a name="l01146"></a>01146     <span class="comment">/* It is common for a function to align local variables on a particular boundary and this happens near the beginning of a</span>
<a name="l01147"></a>01147 <span class="comment">     * function by masking off the low-order bits of the stack pointer. For example:</span>
<a name="l01148"></a>01148 <span class="comment">     *     push ebp                   -- save stack frame</span>
<a name="l01149"></a>01149 <span class="comment">     *     mov  ebp, esp              -- create new stack frame</span>
<a name="l01150"></a>01150 <span class="comment">     *     sub  esp, 0xa8             -- allocate stack space for locals</span>
<a name="l01151"></a>01151 <span class="comment">     *     and  esp, 0xfffffff0       -- align stack on 16-byte boundary</span>
<a name="l01152"></a>01152 <span class="comment">     * The FindConstantsPolicy, when it encounters such an AND instruction with a named value (non-constant) in %esp, simply</span>
<a name="l01153"></a>01153 <span class="comment">     * gives %esp a new named value.  What we want to do instead is subtract 16 from the stack pointer, thus introducing some</span>
<a name="l01154"></a>01154 <span class="comment">     * padding between the top local variable and the bottom of the call frame. The stack after the AND looks like this:</span>
<a name="l01155"></a>01155 <span class="comment">     *     argN</span>
<a name="l01156"></a>01156 <span class="comment">     *     ...</span>
<a name="l01157"></a>01157 <span class="comment">     *     arg0</span>
<a name="l01158"></a>01158 <span class="comment">     *     return address</span>
<a name="l01159"></a>01159 <span class="comment">     *     old stack frame from [push ebp]</span>
<a name="l01160"></a>01160 <span class="comment">     *     padding we inserted from [and esp, 0xfffffff0]</span>
<a name="l01161"></a>01161 <span class="comment">     *     top local variable</span>
<a name="l01162"></a>01162 <span class="comment">     *     ...</span>
<a name="l01163"></a>01163 <span class="comment">     *     bottom local variable          &lt;--- stack pointer points here</span>
<a name="l01164"></a>01164 <span class="comment">     *     </span>
<a name="l01165"></a>01165 <span class="comment">     * Note: The policy "and_" method is called for other instructions besides AND, some of which don't have two operands.</span>
<a name="l01166"></a>01166 <span class="comment">     */</span>
<a name="l01167"></a>01167     <span class="keyword">template</span>&lt;size_t Len&gt;
<a name="l01168"></a><a class="code" href="classCdeclFunctionPolicy.html#8a077ee7430213cc8f649cb8488dcad4">01168</a>     <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> <a class="code" href="classCdeclFunctionPolicy.html#8a077ee7430213cc8f649cb8488dcad4">and_</a>(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> a, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> b) {
<a name="l01169"></a>01169         <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> result = <span class="keyword">new</span> <a class="code" href="structXVariable.html">XVariable&lt;Len&gt;</a>();
<a name="l01170"></a>01170         <span class="keyword">struct </span>IC: <span class="keyword">public</span> <a class="code" href="structBinaryConstraint.html">BinaryConstraint</a>&lt;Len, Len, Len&gt; {
<a name="l01171"></a>01171             IC(<a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> result, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> var1, <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> var2)
<a name="l01172"></a>01172                 : <a class="code" href="structBinaryConstraint.html">BinaryConstraint&lt;Len, Len, Len&gt;</a>(result, var1, var2)
<a name="l01173"></a>01173                 {}
<a name="l01174"></a>01174             <span class="keyword">virtual</span> <span class="keywordtype">void</span> run() <span class="keyword">const</span> {
<a name="l01175"></a>01175                 <span class="comment">/* "var1", "var2", and "result" here are initialized from "a", "b", and "result" above */</span>
<a name="l01176"></a>01176                 <a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;</a> le1 = <a class="code" href="structBinaryConstraint.html">BinaryConstraint&lt;Len, Len, Len&gt;::var1</a>-&gt;get();
<a name="l01177"></a>01177                 <a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;</a> le2 = <a class="code" href="structBinaryConstraint.html">BinaryConstraint&lt;Len, Len, Len&gt;::var2</a>-&gt;get();
<a name="l01178"></a>01178                 <a class="code" href="structXVariablePtr.html">XVariablePtr&lt;Len&gt;</a> result = <a class="code" href="structBinaryConstraint.html">BinaryConstraint&lt;Len, Len, Len&gt;::result</a>;
<a name="l01179"></a>01179 
<a name="l01180"></a>01180                 <span class="comment">/* The instruction for which this policy method is being invoked. */</span>
<a name="l01181"></a>01181                 <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *insn = <a class="code" href="Cxx__Grammar_8h.html#a821b70974acc822c032fddf101296e9">isSgAsmx86Instruction</a>(result-&gt;def);
<a name="l01182"></a>01182                 ROSE_ASSERT(insn);
<a name="l01183"></a>01183                 <a class="code" href="Cxx__Grammar_8h.html#5ba40394e1b351b2d55384ed355a4077">SgAsmExpressionPtrList</a> &amp;opands = insn-&gt;<a class="code" href="classSgAsmInstruction.html#264e86d032b0a589d9dc520e79d09eb8">get_operandList</a>()-&gt;<a class="code" href="classSgAsmOperandList.html#bb5638c0533863030ad7acee019f1f17">get_operands</a>();
<a name="l01184"></a>01184 
<a name="l01185"></a>01185                 <span class="keywordflow">if</span> (!le1.<a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a> &amp;&amp; !le2.<a class="code" href="structLatticeElement.html#9434c239626487fec51c305b64ac46d0">name</a>) {
<a name="l01186"></a>01186                     <span class="comment">/* Operands are known constants, so the result will be a known constant. */</span>
<a name="l01187"></a>01187                     result-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;::constant</a>(le1.<a class="code" href="structLatticeElement.html#5f7046b6efe5660c07b84883ee26a4cc">offset</a> &amp; le2.<a class="code" href="structLatticeElement.html#5f7046b6efe5660c07b84883ee26a4cc">offset</a>, result-&gt;def));
<a name="l01188"></a>01188                 } <span class="keywordflow">else</span> {
<a name="l01189"></a>01189                     <span class="comment">/* Is this instruction aligning the stack pointer? */</span>
<a name="l01190"></a>01190                     <a class="code" href="classSgAsmx86RegisterReferenceExpression.html">SgAsmx86RegisterReferenceExpression</a> *op1 = (opands.size()==2 ?
<a name="l01191"></a>01191                                                                 <a class="code" href="Cxx__Grammar_8h.html#5e5ead71a8653e1d062d92582359e574">isSgAsmx86RegisterReferenceExpression</a>(opands[0]) : NULL);
<a name="l01192"></a>01192                     <span class="keywordflow">if</span> (op1 &amp;&amp; insn-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()==<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca55717e08555010e9e899f138ebf6ff01bfab">x86_and</a> &amp;&amp;
<a name="l01193"></a>01193                         op1-&gt;<a class="code" href="classSgAsmRegisterReferenceExpression.html#e4a2ae3037e897d983674a61bbf16ec0">get_descriptor</a>().<a class="code" href="structRegisterDescriptor.html#00a1b8b124f547095b6409606276a65c">get_major</a>()==<a class="code" href="InstructionEnumsX86_8h.html#12229bfc0029dbc592944d1d6514e30fbcab68a004f857b0eb9dc6a5b736b1ec">x86_regclass_gpr</a> &amp;&amp; op1-&gt;<a class="code" href="classSgAsmRegisterReferenceExpression.html#e4a2ae3037e897d983674a61bbf16ec0">get_descriptor</a>().<a class="code" href="structRegisterDescriptor.html#2e01183db39faae43a9d6671dd27a12b">get_minor</a>()==<a class="code" href="InstructionEnumsX86_8h.html#5069ca462f85d162797843f48bc6bced1f5849637e513ff627dc7360562d1ca0">x86_gpr_sp</a> &amp;&amp;
<a name="l01194"></a>01194                         !le2.<a class="code" href="structLatticeElement.html#4cf276f9d7e1d0dde19af9d40c8f7c5b">isTop</a>) {
<a name="l01195"></a>01195                         <span class="comment">/* Yes, we're aligning the stack pointer. */</span>
<a name="l01196"></a>01196                         <a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;</a> newval = le1; <span class="comment">/* stack pointer */</span>
<a name="l01197"></a>01197                         uint32_t alignment = ~(uint32_t)le2.<a class="code" href="structLatticeElement.html#5f7046b6efe5660c07b84883ee26a4cc">offset</a> + 1; <span class="comment">/*two's complement*/</span>
<a name="l01198"></a>01198                         <span class="comment">//std::cout &lt;&lt;"ROBB: aligning stack on "&lt;&lt;std::dec &lt;&lt;alignment &lt;&lt;"-byte boundary"</span>
<a name="l01199"></a>01199                         <span class="comment">//          &lt;&lt;" [" &lt;&lt;unparseInstructionWithAddress(insn) &lt;&lt;"]\n";</span>
<a name="l01200"></a>01200                         newval.offset -= alignment;
<a name="l01201"></a>01201                         newval.definingInstruction = insn;
<a name="l01202"></a>01202                         result-&gt;set(newval);
<a name="l01203"></a>01203                     } <span class="keywordflow">else</span> {
<a name="l01204"></a>01204                         <span class="comment">/* No, it is some other use of AND and one or both of the operands are unknown values */</span>
<a name="l01205"></a>01205                         result-&gt;set(<a class="code" href="structLatticeElement.html">LatticeElement&lt;Len&gt;</a>());
<a name="l01206"></a>01206                     }
<a name="l01207"></a>01207                 }
<a name="l01208"></a>01208             }
<a name="l01209"></a>01209             <span class="keyword">virtual</span> uint64_t compute(uint64_t, uint64_t)<span class="keyword"> const </span>{
<a name="l01210"></a>01210                 abort(); <span class="comment">/* handled by run() above */</span>
<a name="l01211"></a>01211             }
<a name="l01212"></a>01212         };
<a name="l01213"></a>01213         (<span class="keyword">new</span> IC(result, a, b))-&gt;activate(); <span class="comment">/*invokes the run() method above*/</span>
<a name="l01214"></a>01214         <span class="keywordflow">return</span> result;
<a name="l01215"></a>01215     }
<a name="l01216"></a>01216 };
<a name="l01217"></a>01217 
<a name="l01222"></a><a class="code" href="classFindConstantsABIPolicy.html">01222</a> <span class="keyword">class </span><a class="code" href="classFindConstantsABIPolicy.html">FindConstantsABIPolicy</a>: <span class="keyword">public</span> <a class="code" href="structFindConstantsPolicy.html">FindConstantsPolicy</a> {
<a name="l01223"></a>01223 <span class="keyword">public</span>:
<a name="l01224"></a>01224     <span class="comment">/* Returns the function containing the instruction. */</span>
<a name="l01225"></a><a class="code" href="classFindConstantsABIPolicy.html#2c0c3d921f404ebe181b7e83974f3364">01225</a>     <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a>* find_function(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a>* insn) {
<a name="l01226"></a>01226         <a class="code" href="classSgNode.html">SgNode</a>* n=insn;
<a name="l01227"></a>01227         <span class="keywordflow">while</span> (n &amp;&amp; !<a class="code" href="Cxx__Grammar_8h.html#3374b86a87959b6a02d8ca8f792d693e">isSgAsmFunction</a>(n))
<a name="l01228"></a>01228             n = n-&gt;<a class="code" href="classSgNode.html#aa13b978be2c93c2d6d78f14fbc0e314">get_parent</a>();
<a name="l01229"></a>01229         <span class="keywordflow">return</span> <a class="code" href="Cxx__Grammar_8h.html#3374b86a87959b6a02d8ca8f792d693e">isSgAsmFunction</a>(n);
<a name="l01230"></a>01230     }
<a name="l01231"></a>01231 
<a name="l01232"></a>01232     <span class="comment">/* Determines if the function contains an instruction at the specified address. */</span>
<a name="l01233"></a><a class="code" href="classFindConstantsABIPolicy.html#65e6121810c2d31fd23675819192f629">01233</a>     <span class="keywordtype">bool</span> function_contains_address(<a class="code" href="classSgAsmFunction.html">SgAsmFunction</a>* f, <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va) {
<a name="l01234"></a>01234         <span class="keywordflow">for</span> (size_t i=0; i&lt;f-&gt;<a class="code" href="classSgAsmFunction.html#08fe036249766f5c7bca4403851f9cab">get_statementList</a>().size(); ++i) {
<a name="l01235"></a>01235             <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a>* block = <a class="code" href="Cxx__Grammar_8h.html#0f21c6b7a4aede1900e16a5122233a83">isSgAsmBlock</a>(f-&gt;<a class="code" href="classSgAsmFunction.html#08fe036249766f5c7bca4403851f9cab">get_statementList</a>()[i]);
<a name="l01236"></a>01236             ROSE_ASSERT(block!=NULL);
<a name="l01237"></a>01237             <span class="keywordflow">for</span> (size_t j=0; j&lt;block-&gt;get_statementList().size(); ++j) {
<a name="l01238"></a>01238                 <a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a>* insn = <a class="code" href="Cxx__Grammar_8h.html#8ea3968ea14e6511567d5e5b654315f1">isSgAsmInstruction</a>(block-&gt;get_statementList()[j]);
<a name="l01239"></a>01239                 <span class="keywordflow">if</span> (insn &amp;&amp; insn-&gt;<a class="code" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>()==va)
<a name="l01240"></a>01240                     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01241"></a>01241             }
<a name="l01242"></a>01242         }
<a name="l01243"></a>01243         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01244"></a>01244     }
<a name="l01245"></a>01245 
<a name="l01246"></a>01246     <span class="comment">/* Returns true if the function at the specified address complies with the ABI */</span>
<a name="l01247"></a><a class="code" href="classFindConstantsABIPolicy.html#a6db69906d2c0258ebf0b3afa93c262d">01247</a>     <span class="keywordtype">bool</span> is_abi_compliant(<a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>) {
<a name="l01248"></a>01248         <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">/* left as an exercise for later ;-) */</span>
<a name="l01249"></a>01249     }
<a name="l01250"></a>01250 
<a name="l01251"></a>01251     <span class="comment">/* Determines if a CALL instruction in fact calls a function. Malware sometimes uses CALL instructions for unconditional</span>
<a name="l01252"></a>01252 <span class="comment">     * jumps, in which case the instruction partitioner (Partitioner class) would have placed the call target in the same</span>
<a name="l01253"></a>01253 <span class="comment">     * function as the CALL instruction (note that recursive calls are to the entry address of the function). */</span>
<a name="l01254"></a><a class="code" href="classFindConstantsABIPolicy.html#10e0b74511c877dfc306aae065597df5">01254</a>     <span class="keywordtype">bool</span> is_abi_function_call(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a>* insn_) {
<a name="l01255"></a>01255         <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* insn = <a class="code" href="Cxx__Grammar_8h.html#a821b70974acc822c032fddf101296e9">isSgAsmx86Instruction</a>(insn_);
<a name="l01256"></a>01256         ROSE_ASSERT(insn!=NULL);
<a name="l01257"></a>01257         <span class="keywordflow">if</span> (insn-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()!=<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571221e4d163bb7557e57e351140aa7855e">x86_call</a> &amp;&amp; insn-&gt;<a class="code" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">get_kind</a>()!=<a class="code" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca55714edb34feaf8cb03afb49361a9a0b26c4">x86_farcall</a>)
<a name="l01258"></a>01258             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01259"></a>01259         <span class="keywordflow">if</span> (<a class="code" href="structFindConstantsPolicy.html#94a536bbac269a2f5d6e9c087c392616">newIp</a>-&gt;get().name!=0)
<a name="l01260"></a>01260             <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">/*if we don't know the call target then assume it's a function call*/</span>
<a name="l01261"></a>01261         <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a> *caller = find_function(insn);
<a name="l01262"></a>01262         <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> callee = <a class="code" href="structFindConstantsPolicy.html#94a536bbac269a2f5d6e9c087c392616">newIp</a>-&gt;get().offset;
<a name="l01263"></a>01263         <span class="keywordflow">if</span> (function_contains_address(caller, callee) &amp;&amp; caller-&gt;<a class="code" href="classSgAsmFunction.html#6edeeb78e01e2af6e59a5c6f7b0088af">get_entry_va</a>()!=callee)
<a name="l01264"></a>01264             <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">/*intra-function branch*/</span>
<a name="l01265"></a>01265         <span class="keywordflow">return</span> is_abi_compliant(callee);
<a name="l01266"></a>01266     }
<a name="l01267"></a>01267 
<a name="l01268"></a>01268     <span class="comment">/* Augments superclass method so that the instruction following a CALL (provided this is really a function call and not</span>
<a name="l01269"></a>01269 <span class="comment">     * just an intra-function branch) has a register set whose callee-preserved registers are actually reserved across the</span>
<a name="l01270"></a>01270 <span class="comment">     * CALL instruction. We also preserve the stack pointer, frame pointer, and all memory. */</span>
<a name="l01271"></a><a class="code" href="classFindConstantsABIPolicy.html#32e1434e92af6ac7c21b6a173e0d340e">01271</a>     <span class="keywordtype">void</span> finishInstruction(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a>* insn_) {
<a name="l01272"></a>01272         <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a>* insn = <a class="code" href="Cxx__Grammar_8h.html#a821b70974acc822c032fddf101296e9">isSgAsmx86Instruction</a>(insn_);
<a name="l01273"></a>01273         ROSE_ASSERT(insn!=NULL);
<a name="l01274"></a>01274         <span class="keywordflow">if</span> (is_abi_function_call(insn)) {
<a name="l01275"></a>01275             <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> call_va = insn-&gt;<a class="code" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>();
<a name="l01276"></a>01276             <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> next_va = insn-&gt;<a class="code" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>() + insn-&gt;<a class="code" href="classSgAsmInstruction.html#c239f0d80ab88127b2543fb0990803c3">get_raw_bytes</a>().size();
<a name="l01277"></a>01277             <a class="code" href="structRegisterSet.html">RegisterSet</a> rset;
<a name="l01278"></a>01278             rset.<a class="code" href="structRegisterSet.html#bd97694302e8f6c77bc5013b82382923">setToBottom</a>();
<a name="l01279"></a>01279             rset.<a class="code" href="structRegisterSet.html#70669dade0ea18fc20058fc72d36a69e">memoryWrites</a> = <a class="code" href="structFindConstantsPolicy.html#86ad83f3a1aeb15f05c22295a649c304">rsets</a>[call_va].memoryWrites;
<a name="l01280"></a>01280             rset.<a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.<a class="code" href="structRegisterSet.html#ee0cbc1009037414f2b247b93087720a">gpr</a>[<a class="code" href="InstructionEnumsX86_8h.html#5069ca462f85d162797843f48bc6bced655fe4130e38fe77197bc264779da97d">x86_gpr_bx</a>] = <a class="code" href="structFindConstantsPolicy.html#86ad83f3a1aeb15f05c22295a649c304">rsets</a>[call_va].registers.gpr[<a class="code" href="InstructionEnumsX86_8h.html#5069ca462f85d162797843f48bc6bced655fe4130e38fe77197bc264779da97d">x86_gpr_bx</a>];
<a name="l01281"></a>01281             rset.<a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.<a class="code" href="structRegisterSet.html#ee0cbc1009037414f2b247b93087720a">gpr</a>[<a class="code" href="InstructionEnumsX86_8h.html#5069ca462f85d162797843f48bc6bced4e00b4b002bfe801084a2c7648bf884e">x86_gpr_di</a>] = <a class="code" href="structFindConstantsPolicy.html#86ad83f3a1aeb15f05c22295a649c304">rsets</a>[call_va].registers.gpr[<a class="code" href="InstructionEnumsX86_8h.html#5069ca462f85d162797843f48bc6bced4e00b4b002bfe801084a2c7648bf884e">x86_gpr_di</a>];
<a name="l01282"></a>01282             rset.<a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.<a class="code" href="structRegisterSet.html#ee0cbc1009037414f2b247b93087720a">gpr</a>[<a class="code" href="InstructionEnumsX86_8h.html#5069ca462f85d162797843f48bc6bced0b2a4d9f03643be4cb0e519175695e45">x86_gpr_si</a>] = <a class="code" href="structFindConstantsPolicy.html#86ad83f3a1aeb15f05c22295a649c304">rsets</a>[call_va].registers.gpr[<a class="code" href="InstructionEnumsX86_8h.html#5069ca462f85d162797843f48bc6bced0b2a4d9f03643be4cb0e519175695e45">x86_gpr_si</a>];
<a name="l01283"></a>01283             rset.<a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.<a class="code" href="structRegisterSet.html#ee0cbc1009037414f2b247b93087720a">gpr</a>[<a class="code" href="InstructionEnumsX86_8h.html#5069ca462f85d162797843f48bc6bced1f5849637e513ff627dc7360562d1ca0">x86_gpr_sp</a>] = <a class="code" href="structFindConstantsPolicy.html#86ad83f3a1aeb15f05c22295a649c304">rsets</a>[call_va].registers.gpr[<a class="code" href="InstructionEnumsX86_8h.html#5069ca462f85d162797843f48bc6bced1f5849637e513ff627dc7360562d1ca0">x86_gpr_sp</a>];
<a name="l01284"></a>01284             rset.<a class="code" href="structRegisterSet.html#89c62d92f66efde67b055f05438beb85">registers</a>.<a class="code" href="structRegisterSet.html#ee0cbc1009037414f2b247b93087720a">gpr</a>[<a class="code" href="InstructionEnumsX86_8h.html#5069ca462f85d162797843f48bc6bceda9ec94ced24945de2d3e64be23e8a19b">x86_gpr_bp</a>] = <a class="code" href="structFindConstantsPolicy.html#86ad83f3a1aeb15f05c22295a649c304">rsets</a>[call_va].registers.gpr[<a class="code" href="InstructionEnumsX86_8h.html#5069ca462f85d162797843f48bc6bceda9ec94ced24945de2d3e64be23e8a19b">x86_gpr_bp</a>];
<a name="l01285"></a>01285             <a class="code" href="structFindConstantsPolicy.html#86ad83f3a1aeb15f05c22295a649c304">rsets</a>[next_va].mergeIn(rset);
<a name="l01286"></a>01286         }
<a name="l01287"></a>01287         FindConstantsPolicy::finishInstruction(insn);
<a name="l01288"></a>01288     }
<a name="l01289"></a>01289 };
<a name="l01290"></a>01290 
<a name="l01291"></a>01291 <span class="preprocessor">#endif </span><span class="comment">/* !findConstants_H */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
