<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ROSE: graphProcessing.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.9.5a</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('graphProcessing_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">graphProcessing.h</div>  </div>
</div>
<div class="contents">
<a href="graphProcessing_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">FINISH TEMPFLATPATH CODE</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">*/</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="comment">// Original Author (SgGraphTraversal mechanisms): Michael Hoffman</span>
<a name="l00011"></a>00011 <span class="comment">//$id$</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include&lt;<a class="code" href="omp_8h.html">omp.h</a>&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;boost/regex.hpp&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;<a class="code" href="graphTemplate_8h.html">graphTemplate.h</a>&gt;</span>
<a name="l00018"></a>00018 
<a name="l00055"></a>00055 <span class="comment">//#include &lt;rose.h&gt;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &lt;boost/graph/adjacency_list.hpp&gt;</span>
<a name="l00057"></a>00057 <span class="preprocessor">#include &lt;boost/bind.hpp&gt;</span>
<a name="l00058"></a>00058 <span class="preprocessor">#include &lt;boost/foreach.hpp&gt;</span>
<a name="l00059"></a>00059 <span class="preprocessor">#include &lt;boost/tuple/tuple.hpp&gt;</span>
<a name="l00060"></a>00060 <span class="preprocessor">#include &lt;boost/graph/graphviz.hpp&gt;</span>
<a name="l00061"></a>00061 <span class="preprocessor">#include &lt;boost/graph/dominator_tree.hpp&gt;</span>
<a name="l00062"></a>00062 <span class="preprocessor">#include &lt;boost/graph/reverse_graph.hpp&gt;</span>
<a name="l00063"></a>00063 <span class="preprocessor">#include &lt;boost/graph/transpose_graph.hpp&gt;</span>
<a name="l00064"></a>00064 <span class="preprocessor">#include &lt;boost/algorithm/string.hpp&gt;</span>
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 <span class="comment">//#include &quot;staticCFG.h&quot;</span>
<a name="l00069"></a>00069 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00070"></a>00070 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00071"></a>00071 <span class="preprocessor">#include &lt;utility&gt;</span>
<a name="l00072"></a>00072 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00073"></a>00073 <span class="preprocessor">#include &lt;sys/time.h&gt;</span>
<a name="l00074"></a>00074 <span class="preprocessor">#include &lt;sys/resource.h&gt;</span>
<a name="l00075"></a>00075 <span class="comment">//#include &quot;graphBot.h&quot;</span>
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 <span class="comment">//This is necessary for technical reasons with regards to the graphnodeinheritedmap</span>
<a name="l00078"></a>00078 
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="comment">//using namespace Backstroke;</span>
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 <span class="comment">//int gos;</span>
<a name="l00090"></a>00090 
<a name="l00091"></a><a class="code" href="graphProcessing_8h.html#aeb93c9ce91540e46efedb9093f0f4445">00091</a> std::string <a class="code" href="graphProcessing_8h.html#aeb93c9ce91540e46efedb9093f0f4445">printnum</a>(<span class="keywordtype">int</span> i)
<a name="l00092"></a>00092 {
<a name="l00093"></a>00093     std::string s;
<a name="l00094"></a>00094     std::stringstream out;
<a name="l00095"></a>00095     out &lt;&lt; i;
<a name="l00096"></a>00096     s = out.str();
<a name="l00097"></a>00097     <span class="keywordflow">return</span> s;
<a name="l00098"></a>00098 }
<a name="l00099"></a>00099 <span class="comment">/*</span>
<a name="l00100"></a>00100 <span class="comment">void printCFGNode(FilteredCFGNode&lt;CFGNodeFilter2&gt;* cf, CFG* cfg, int nodenum)</span>
<a name="l00101"></a>00101 <span class="comment">{</span>
<a name="l00102"></a>00102 <span class="comment"></span>
<a name="l00103"></a>00103 <span class="comment">        SgNode* node = cf-&gt;getNode();</span>
<a name="l00104"></a>00104 <span class="comment"></span>
<a name="l00105"></a>00105 <span class="comment">//       if (nodenums.find(node) == nodenums.end()) {</span>
<a name="l00106"></a>00106 <span class="comment">//            nodenums[node] = currnodenum;</span>
<a name="l00107"></a>00107 <span class="comment">//            currnodenum++;</span>
<a name="l00108"></a>00108 <span class="comment">//        }</span>
<a name="l00109"></a>00109 <span class="comment"></span>
<a name="l00110"></a>00110 <span class="comment">        ROSE_ASSERT(node);</span>
<a name="l00111"></a>00111 <span class="comment"></span>
<a name="l00112"></a>00112 <span class="comment">        std::string nodeColor = &quot;black&quot;;</span>
<a name="l00113"></a>00113 <span class="comment">        if (isSgStatement(node))</span>
<a name="l00114"></a>00114 <span class="comment">                nodeColor = &quot;blue&quot;;</span>
<a name="l00115"></a>00115 <span class="comment">        else if (isSgExpression(node))</span>
<a name="l00116"></a>00116 <span class="comment">                nodeColor = &quot;green&quot;;</span>
<a name="l00117"></a>00117 <span class="comment">        else if (isSgInitializedName(node))</span>
<a name="l00118"></a>00118 <span class="comment">                nodeColor = &quot;red&quot;;</span>
<a name="l00119"></a>00119 <span class="comment"></span>
<a name="l00120"></a>00120 <span class="comment">        std::string label;</span>
<a name="l00121"></a>00121 <span class="comment"></span>
<a name="l00122"></a>00122 <span class="comment">        if (SgFunctionDefinition* funcDef = isSgFunctionDefinition(node))</span>
<a name="l00123"></a>00123 <span class="comment">        {</span>
<a name="l00124"></a>00124 <span class="comment">                std::string funcName = funcDef-&gt;get_declaration()-&gt;get_name().str();</span>
<a name="l00125"></a>00125 <span class="comment">                if (cf-&gt;getIndex() == 0)</span>
<a name="l00126"></a>00126 <span class="comment">                        label = &quot;Entry\\n&quot; + funcName;</span>
<a name="l00127"></a>00127 <span class="comment">                else if (cf-&gt;getIndex() == 3)</span>
<a name="l00128"></a>00128 <span class="comment">                        label = &quot;Exit\\n&quot; + funcName;</span>
<a name="l00129"></a>00129 <span class="comment">        }</span>
<a name="l00130"></a>00130 <span class="comment"></span>
<a name="l00131"></a>00131 <span class="comment">        if (!isSgScopeStatement(node) &amp;&amp; !isSgCaseOptionStmt(node) &amp;&amp; !isSgDefaultOptionStmt(node))</span>
<a name="l00132"></a>00132 <span class="comment">        {</span>
<a name="l00133"></a>00133 <span class="comment">                std::string content = node-&gt;unparseToString();</span>
<a name="l00134"></a>00134 <span class="comment">                content += printnum(nodenum);</span>
<a name="l00135"></a>00135 <span class="comment">                boost::replace_all(content, &quot;\&quot;&quot;, &quot;\\\&quot;&quot;);</span>
<a name="l00136"></a>00136 <span class="comment">                boost::replace_all(content, &quot;\\n&quot;, &quot;\\\\n&quot;);</span>
<a name="l00137"></a>00137 <span class="comment">                label += content;</span>
<a name="l00138"></a>00138 <span class="comment">        }</span>
<a name="l00139"></a>00139 <span class="comment">        else</span>
<a name="l00140"></a>00140 <span class="comment">                label += &quot;&lt;&quot; + node-&gt;class_name() + &quot;&gt;&quot;;</span>
<a name="l00141"></a>00141 <span class="comment"></span>
<a name="l00142"></a>00142 <span class="comment">        if (label == &quot;&quot;)</span>
<a name="l00143"></a>00143 <span class="comment">                label += &quot;&lt;&quot; + node-&gt;class_name() + &quot; &quot; + printnum(nodenum) + &quot; &quot; + printnum(cf-&gt;getIndex()) + &quot;&gt;&quot;;</span>
<a name="l00144"></a>00144 <span class="comment"></span>
<a name="l00145"></a>00145 <span class="comment">        std::cout &lt;&lt; label &lt;&lt; std::endl;</span>
<a name="l00146"></a>00146 <span class="comment">}</span>
<a name="l00147"></a>00147 <span class="comment"></span>
<a name="l00148"></a>00148 <span class="comment">*/</span>
<a name="l00149"></a>00149 
<a name="l00150"></a><a class="code" href="structBot.html">00150</a> <span class="keyword">struct </span><a class="code" href="structBot.html">Bot</a>
<a name="l00151"></a>00151 {
<a name="l00152"></a><a class="code" href="structBot.html#a921887c740102f0e2899599311e1af31">00152</a>     std::vector&lt;std::vector&lt;int&gt; &gt; <a class="code" href="structBot.html#a921887c740102f0e2899599311e1af31">path</a>;
<a name="l00153"></a><a class="code" href="structBot.html#ac9a69748bb185d987f7ef7898dd2aca4">00153</a>     std::vector&lt;std::set&lt;int&gt; &gt; <a class="code" href="structBot.html#ac9a69748bb185d987f7ef7898dd2aca4">pthloops</a>;
<a name="l00154"></a><a class="code" href="structBot.html#ab5f7df14761543c1a3099340ca6cbf36">00154</a>     std::vector&lt;int&gt; <a class="code" href="structBot.html#ab5f7df14761543c1a3099340ca6cbf36">currpth</a>;
<a name="l00155"></a><a class="code" href="structBot.html#af2ec8653b7cd8dfd6c1bb279f4980a3e">00155</a>     std::vector&lt;std::pair&lt;int, int&gt; &gt; <a class="code" href="structBot.html#af2ec8653b7cd8dfd6c1bb279f4980a3e">nodelst</a>;
<a name="l00156"></a><a class="code" href="structBot.html#a8fc3e19ff7ef78630332371059abb1c6">00156</a>     <span class="keywordtype">bool</span> <a class="code" href="structBot.html#a8fc3e19ff7ef78630332371059abb1c6">on</a>;
<a name="l00157"></a><a class="code" href="structBot.html#a926f7879741af9852bcaf8c49a8e6ad9">00157</a>     <span class="keywordtype">bool</span> <span class="keyword">remove</span>;
<a name="l00158"></a>00158 };
<a name="l00159"></a>00159 
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 
<a name="l00162"></a>00162 
<a name="l00163"></a><a class="code" href="graphProcessing_8h.html#ae0e3d51bc94bbc9201f1125a8407492f">00163</a> <span class="keywordtype">double</span> <a class="code" href="graphProcessing_8h.html#ae0e3d51bc94bbc9201f1125a8407492f">timeDifference</a>( <span class="keyword">struct</span> timeval&amp; end,  <span class="keyword">struct</span> timeval&amp; begin)
<a name="l00164"></a>00164 {
<a name="l00165"></a>00165     <span class="keywordflow">return</span> (end.tv_sec + end.tv_usec / 1.0e6) - (begin.tv_sec + begin.tv_usec / 1.0e6);
<a name="l00166"></a>00166 }
<a name="l00167"></a>00167 
<a name="l00168"></a><a class="code" href="graphProcessing_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">00168</a> <span class="keyword">static</span> <span class="keyword">inline</span> timeval <a class="code" href="graphProcessing_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>()
<a name="l00169"></a>00169 {
<a name="l00170"></a>00170     rusage ru;
<a name="l00171"></a>00171     getrusage(RUSAGE_SELF, &amp;ru);
<a name="l00172"></a>00172     <span class="keywordflow">return</span> ru.ru_utime;
<a name="l00173"></a>00173 }
<a name="l00174"></a>00174 
<a name="l00175"></a>00175 <span class="comment">/*</span>
<a name="l00176"></a>00176 <span class="comment">struct compareSgGraphNode {</span>
<a name="l00177"></a>00177 <span class="comment">    bool operator()( int a,  int b)</span>
<a name="l00178"></a>00178 <span class="comment">    {</span>
<a name="l00179"></a>00179 <span class="comment">        return a==b;</span>
<a name="l00180"></a>00180 <span class="comment">    }</span>
<a name="l00181"></a>00181 <span class="comment">};</span>
<a name="l00182"></a>00182 <span class="comment">*/</span>
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 
<a name="l00185"></a>00185 <span class="comment">/* The SgGraphTraversal class is utilized specifically for StaticCFG traversals,</span>
<a name="l00186"></a>00186 <span class="comment">though the input must be in terms of a CFG*/</span>
<a name="l00187"></a>00187 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l00188"></a><a class="code" href="classSgGraphTraversal.html">00188</a> <span class="keyword">class </span><a class="code" href="classSgGraphTraversal.html">SgGraphTraversal</a>
<a name="l00189"></a>00189 {
<a name="l00190"></a>00190 
<a name="l00191"></a>00191 <span class="keyword">public</span>:
<a name="l00192"></a>00192     <span class="comment">//CFG* completeGraph;</span>
<a name="l00193"></a>00193     <span class="comment">//currvert = 0;</span>
<a name="l00194"></a>00194     <span class="comment">//gos = 0;</span>
<a name="l00195"></a><a class="code" href="classSgGraphTraversal.html#a3347055fc33f2c5105a567f9798f6a5c">00195</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::graph_traits&lt;CFG&gt;::vertex_descriptor <a class="code" href="classSgGraphTraversal.html#a3347055fc33f2c5105a567f9798f6a5c">Vertex</a>;
<a name="l00196"></a><a class="code" href="classSgGraphTraversal.html#a7472f81cd33241d5f733e950e36247b7">00196</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::graph_traits&lt;CFG&gt;:: edge_descriptor <a class="code" href="classSgGraphTraversal.html#a7472f81cd33241d5f733e950e36247b7">Edge</a>;
<a name="l00197"></a>00197     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#afa7781ad505ac354a94c889c1b3cc973">printHotness</a>(<span class="keyword">const</span> CFG*&amp; g);
<a name="l00198"></a>00198     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#a5db6bb8812576bd43146c6aab69908a8">printCFGEdge</a>(<span class="keywordtype">int</span> ed, <span class="keyword">const</span> CFG*&amp; g, std::ofstream&amp; o);
<a name="l00199"></a>00199     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#a6fd50d9df16d2690f548524a3071a5bb">printCFGNode</a>(<span class="keywordtype">int</span> n, std::ofstream&amp; o);
<a name="l00200"></a>00200     <span class="comment">//typedef typename CFG::Vertex Vertex;</span>
<a name="l00201"></a>00201     <span class="comment">//typedef typename CFG::Edge Edge;</span>
<a name="l00202"></a><a class="code" href="classSgGraphTraversal.html#a6eaf6918f211ac66aa12eb452d761f22">00202</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::graph_traits&lt;CFG&gt;::vertex_iterator <a class="code" href="classSgGraphTraversal.html#a6eaf6918f211ac66aa12eb452d761f22">vertex_iterator</a>;
<a name="l00203"></a><a class="code" href="classSgGraphTraversal.html#a5af9b01a8f9ef8dd55596e619d4f6c5f">00203</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::graph_traits&lt;CFG&gt;::out_edge_iterator <a class="code" href="classSgGraphTraversal.html#a5af9b01a8f9ef8dd55596e619d4f6c5f">out_edge_iterator</a>;
<a name="l00204"></a><a class="code" href="classSgGraphTraversal.html#a0880679ae13a21afee2280891da06b92">00204</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::graph_traits&lt;CFG&gt;::in_edge_iterator <a class="code" href="classSgGraphTraversal.html#a0880679ae13a21afee2280891da06b92">in_edge_iterator</a>;
<a name="l00205"></a><a class="code" href="classSgGraphTraversal.html#a49f0402773be87248387897070120ab0">00205</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::graph_traits&lt;CFG&gt;::edge_iterator <a class="code" href="classSgGraphTraversal.html#a49f0402773be87248387897070120ab0">edge_iterator</a>;
<a name="l00206"></a>00206     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#aadbfec7028c38362b875a0a2a8ce700a">getEntryExit</a>(<span class="keyword">const</span> CFG*&amp; cfg);
<a name="l00207"></a><a class="code" href="classSgGraphTraversal.html#ab41d0203e899e70a139aed80dabd90bb">00207</a>     std::vector&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#ab41d0203e899e70a139aed80dabd90bb">sources</a>;
<a name="l00208"></a><a class="code" href="classSgGraphTraversal.html#ad6a050d0264a790afacb828922778b76">00208</a>     std::vector&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#ad6a050d0264a790afacb828922778b76">sinks</a>;
<a name="l00209"></a><a class="code" href="classSgGraphTraversal.html#a722c218ff44eafc7902db1a075b94f6f">00209</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a722c218ff44eafc7902db1a075b94f6f">pathnum</a>;
<a name="l00210"></a><a class="code" href="classSgGraphTraversal.html#a610e5b83e5ed44fcb38c910d19b69f41">00210</a>     std::map&lt;Vertex, int&gt; <a class="code" href="classSgGraphTraversal.html#a610e5b83e5ed44fcb38c910d19b69f41">intVertex</a>;
<a name="l00211"></a><a class="code" href="classSgGraphTraversal.html#a018277ffddde6e8147f81166e208a59f">00211</a>     std::map&lt;int, Vertex&gt; <a class="code" href="classSgGraphTraversal.html#a018277ffddde6e8147f81166e208a59f">Vertexint</a>;
<a name="l00212"></a>00212     <a class="code" href="classSgGraphTraversal.html#a9a20dc8d3bb63d107a81929187c72673">SgGraphTraversal</a>();
<a name="l00213"></a><a class="code" href="classSgGraphTraversal.html#afea7285025827aea865d8d19edb27efc">00213</a>     std::set&lt;std::map&lt;int, std::set&lt;int&gt; &gt; &gt; <a class="code" href="classSgGraphTraversal.html#afea7285025827aea865d8d19edb27efc">subpathmap</a>;
<a name="l00214"></a><a class="code" href="classSgGraphTraversal.html#a2a7a4163971673b004c06ef672c3f379">00214</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a2a7a4163971673b004c06ef672c3f379">loopNum</a>;
<a name="l00215"></a><a class="code" href="classSgGraphTraversal.html#a80f870b4362ed6c7d69f3a07f5f90301">00215</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a80f870b4362ed6c7d69f3a07f5f90301">nullNum</a>;
<a name="l00216"></a><a class="code" href="classSgGraphTraversal.html#a4760b5d3fb9da5cc103d93199f2ed792">00216</a>     std::set&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#a4760b5d3fb9da5cc103d93199f2ed792">nullEdgesOrdered</a>;
<a name="l00217"></a><a class="code" href="classSgGraphTraversal.html#a877d5e5ed1f9495506b193cecdf58d67">00217</a>     std::map&lt;int, int&gt; <a class="code" href="classSgGraphTraversal.html#a877d5e5ed1f9495506b193cecdf58d67">loopNumMap</a>;
<a name="l00218"></a><a class="code" href="classSgGraphTraversal.html#a331b4a102ab89c770e04eb8824e1406d">00218</a>     std::map&lt;int, int&gt; <a class="code" href="classSgGraphTraversal.html#a331b4a102ab89c770e04eb8824e1406d">pathValMap</a>;
<a name="l00219"></a><a class="code" href="classSgGraphTraversal.html#a61d4b1defc45ebf7aa6c8af6fb24e35e">00219</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a61d4b1defc45ebf7aa6c8af6fb24e35e">nullloops</a>;
<a name="l00220"></a><a class="code" href="classSgGraphTraversal.html#ad3551e04ba7dfe67c610257a9bbe0972">00220</a>     std::vector&lt;std::vector&lt;int&gt; &gt; <a class="code" href="classSgGraphTraversal.html#ad3551e04ba7dfe67c610257a9bbe0972">looppaths</a>;
<a name="l00221"></a><a class="code" href="classSgGraphTraversal.html#a5275a754b3a1246ee041046b98f38986">00221</a>     std::vector&lt;std::vector&lt;int&gt; &gt; <a class="code" href="classSgGraphTraversal.html#a5275a754b3a1246ee041046b98f38986">iLoops</a>;
<a name="l00222"></a><a class="code" href="classSgGraphTraversal.html#a0f53a49fdf469d130c87fd5d279eb016">00222</a>     std::vector&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#a0f53a49fdf469d130c87fd5d279eb016">ifstatements</a>;
<a name="l00223"></a>00223     <span class="keyword">virtual</span> <a class="code" href="classSgGraphTraversal.html#a88455ca855d3460510a2d6cfe9cb0b38">~SgGraphTraversal</a>();
<a name="l00224"></a>00224     <span class="comment">//SgGraphTraversal();</span>
<a name="l00225"></a>00225     <span class="comment">// Copy operations</span>
<a name="l00226"></a><a class="code" href="classSgGraphTraversal.html#af27cb30367c033466a4cdca4a11b8535">00226</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#af27cb30367c033466a4cdca4a11b8535">nullEdgesPaths</a>;
<a name="l00227"></a><a class="code" href="classSgGraphTraversal.html#a6645743b2a28141ddf7fb0778154072d">00227</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a6645743b2a28141ddf7fb0778154072d">turns</a>;
<a name="l00228"></a>00228     <a class="code" href="classSgGraphTraversal.html#a9a20dc8d3bb63d107a81929187c72673">SgGraphTraversal</a>( <a class="code" href="classSgGraphTraversal.html">SgGraphTraversal</a> &amp;);
<a name="l00229"></a>00229     <a class="code" href="classSgGraphTraversal.html">SgGraphTraversal</a> &amp;<a class="code" href="classSgGraphTraversal.html#a9066477debed9798e60fe3a767151364">operator=</a>( <a class="code" href="classSgGraphTraversal.html">SgGraphTraversal</a> &amp;);
<a name="l00230"></a>00230     <span class="comment">//This is not used, but will be important if SynthesizedAttributes become useful</span>
<a name="l00231"></a><a class="code" href="classSgGraphTraversal.html#ad8970fc30ffc6127100d5a2699c6ac8e">00231</a>     <span class="keyword">typedef</span> <a class="code" href="classStackFrameVector.html">StackFrameVector&lt;SynthesizedAttributeType&gt;</a> <a class="code" href="classSgGraphTraversal.html#ad8970fc30ffc6127100d5a2699c6ac8e">SynthesizedAttributesList</a>;
<a name="l00232"></a>00232     <span class="comment">//one of the most important structures in the algorithm, this attaches ints to InheritedAttributeTypes so that</span>
<a name="l00233"></a>00233     <span class="comment">//looking up the values is possible.</span>
<a name="l00234"></a>00234     <span class="comment">//int numnodes;</span>
<a name="l00235"></a>00235     <span class="comment">//std::map&lt;int, InheritedAttributeType&gt; seen;</span>
<a name="l00236"></a><a class="code" href="classSgGraphTraversal.html#a3786ab1d3d63cca878d748238375f8a0">00236</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a3786ab1d3d63cca878d748238375f8a0">numnodes</a>;
<a name="l00237"></a>00237     <span class="comment">//InheritedAttributeType pthgraphinherit;</span>
<a name="l00238"></a>00238     <span class="comment">//StaticCFG::CFG* SgCFG;</span>
<a name="l00239"></a><a class="code" href="classSgGraphTraversal.html#a0767da0411a33605446f45cf8c3543c1">00239</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a0767da0411a33605446f45cf8c3543c1">nullnode</a>;
<a name="l00240"></a><a class="code" href="classSgGraphTraversal.html#a2d37320a69ed4175bc596cc6cdf2fc60">00240</a>     std::map&lt;int, int&gt; <a class="code" href="classSgGraphTraversal.html#a2d37320a69ed4175bc596cc6cdf2fc60">primenode</a>;
<a name="l00241"></a><a class="code" href="classSgGraphTraversal.html#a5b366f99397c86b7e6d3df5c9850cb70">00241</a>     <span class="keywordtype">bool</span> <a class="code" href="classSgGraphTraversal.html#a5b366f99397c86b7e6d3df5c9850cb70">done</a>;
<a name="l00242"></a><a class="code" href="classSgGraphTraversal.html#a6f9ca5edfa12612f9bdf404f1d518791">00242</a>     std::vector&lt;std::vector&lt;int&gt; &gt; <a class="code" href="classSgGraphTraversal.html#a6f9ca5edfa12612f9bdf404f1d518791">senpaths</a>;
<a name="l00243"></a>00243     <span class="comment">//std::set&lt;int&gt; startnodes;</span>
<a name="l00244"></a><a class="code" href="classSgGraphTraversal.html#aed96594567071232e31bb66bdf6704db">00244</a>     std::set&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#aed96594567071232e31bb66bdf6704db">lstN</a>;
<a name="l00245"></a><a class="code" href="classSgGraphTraversal.html#a734d07dd8032614d26a66a2c4e67f54d">00245</a>     std::map&lt;int, std::vector&lt;std::set&lt;int&gt; &gt; &gt; <a class="code" href="classSgGraphTraversal.html#a734d07dd8032614d26a66a2c4e67f54d">lstordmap</a>;
<a name="l00246"></a><a class="code" href="classSgGraphTraversal.html#ae11101d9ca6389e05fef17bb46bf3e71">00246</a>     std::set&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#ae11101d9ca6389e05fef17bb46bf3e71">solvedLoops</a>;
<a name="l00247"></a><a class="code" href="classSgGraphTraversal.html#a460656479fd973c1da3974366d1d0df2">00247</a>     std::map&lt;int, std::vector&lt;int&gt; &gt; <a class="code" href="classSgGraphTraversal.html#a460656479fd973c1da3974366d1d0df2">checkednodes</a>;
<a name="l00248"></a><a class="code" href="classSgGraphTraversal.html#aaf41ed025270f6c412a5e64a920a1842">00248</a>     std::map&lt;int, std::set&lt;int&gt; &gt; <a class="code" href="classSgGraphTraversal.html#aaf41ed025270f6c412a5e64a920a1842">downed</a>;
<a name="l00249"></a>00249 
<a name="l00250"></a>00250     <span class="comment">//std::map&lt;int, int&gt; nodeinedgordmap;</span>
<a name="l00251"></a>00251     <span class="comment">//a value for nodes that have no value, set in the traverse function</span>
<a name="l00252"></a><a class="code" href="classSgGraphTraversal.html#a6bf1613b154789a97fbb1bad9b299a7b">00252</a>     InheritedAttributeType <a class="code" href="classSgGraphTraversal.html#a6bf1613b154789a97fbb1bad9b299a7b">nullInherit</a>;
<a name="l00253"></a><a class="code" href="classSgGraphTraversal.html#ab8a8f441799c69c4be9ad7d7a3314788">00253</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#ab8a8f441799c69c4be9ad7d7a3314788">loopdetectnum</a>;
<a name="l00254"></a>00254 
<a name="l00255"></a><a class="code" href="classSgGraphTraversal.html#a4ac84e166d3f4a0976c8d882ee343e2d">00255</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a4ac84e166d3f4a0976c8d882ee343e2d">pnum</a>;
<a name="l00256"></a>00256     <span class="comment">//the user invoked function, runs the algorithm</span>
<a name="l00257"></a>00257     InheritedAttributeType <a class="code" href="classSgGraphTraversal.html#a9b6874b8b18d2368b29e17eb63a15034">traverse</a>(<a class="code" href="classSgGraphTraversal.html#a3347055fc33f2c5105a567f9798f6a5c">Vertex</a> &amp;basenode, CFG* &amp; g,
<a name="l00258"></a>00258                                     InheritedAttributeType &amp;inheritedValue, InheritedAttributeType&amp; <a class="code" href="classSgGraphTraversal.html#a6bf1613b154789a97fbb1bad9b299a7b">nullInherit</a>,
<a name="l00259"></a>00259                                     <a class="code" href="classSgGraphTraversal.html#a3347055fc33f2c5105a567f9798f6a5c">Vertex</a> &amp;endnode, <span class="keywordtype">bool</span> insep = <span class="keyword">false</span>, <span class="keywordtype">bool</span> pcHk = <span class="keyword">false</span>);
<a name="l00260"></a><a class="code" href="classSgGraphTraversal.html#af118b4cbde8df79d427fbb3bc1f6218a">00260</a>     std::set&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#af118b4cbde8df79d427fbb3bc1f6218a">loopSet</a>;
<a name="l00261"></a>00261 
<a name="l00262"></a>00262 <span class="keyword">protected</span>:
<a name="l00263"></a>00263     <span class="comment">//User defined functions to do whatever is needed in evaluation</span>
<a name="l00264"></a>00264     <span class="comment">//All the user gets access to is the node in question</span>
<a name="l00265"></a>00265     <span class="comment">//and the values of the parent nodes (this should be all that is necessary)</span>
<a name="l00266"></a>00266     <span class="keyword">virtual</span> InheritedAttributeType <a class="code" href="classSgGraphTraversal.html#a02a67d526647e3d5a2bf391c0fde7310">evaluateInheritedAttribute</a>(<a class="code" href="classSgGraphTraversal.html#a3347055fc33f2c5105a567f9798f6a5c">Vertex</a> &amp;n,
<a name="l00267"></a>00267             std::vector&lt;InheritedAttributeType&gt; &amp;inheritedValues) = 0;
<a name="l00268"></a>00268     <span class="comment">//Not used, but may be useful if SynthesizedAttributes become workable in this context</span>
<a name="l00269"></a>00269     <span class="comment">//virtual SynthesizedAttributeType evaluateSynthesizedAttribute( int &amp;n,</span>
<a name="l00270"></a>00270     <span class="comment">//         InheritedAttributeType &amp;in,</span>
<a name="l00271"></a>00271     <span class="comment">//         SynthesizedAttributesList &amp;l) = 0;</span>
<a name="l00272"></a>00272 
<a name="l00273"></a>00273 <span class="preprocessor">#if !USE_ROSE</span>
<a name="l00274"></a>00274 <span class="preprocessor"></span> <span class="comment">// DQ (11/3/2011): EDG compilains about this (but GNU allowed it, I think that EDG might be correct,</span>
<a name="l00275"></a>00275  <span class="comment">// namely that the value of a reference must be an lvalue (not NULL).  But since we are only trying </span>
<a name="l00276"></a>00276  <span class="comment">// to compile ROSE with ROSE (using the new EDG 4.3 front-end as a tests) we can just skip this case for now.</span>
<a name="l00277"></a>00277     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#ac3700958711d628fcf55a3410931dca7">pathAnalyze</a>( std::vector&lt;int&gt; &amp;pth, <span class="keywordtype">bool</span> loop=<span class="keyword">false</span>,  std::set&lt;std::vector&lt;int&gt; &gt;&amp; incloops=NULL) = 0;
<a name="l00278"></a>00278 <span class="preprocessor">#else</span>
<a name="l00279"></a>00279 <span class="preprocessor"></span>    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#ac3700958711d628fcf55a3410931dca7">pathAnalyze</a>( std::vector&lt;int&gt; &amp;pth, <span class="keywordtype">bool</span> loop,  std::set&lt;std::vector&lt;int&gt; &gt;&amp; incloops) = 0;
<a name="l00280"></a>00280 <span class="preprocessor">#endif</span>
<a name="l00281"></a>00281 <span class="preprocessor"></span>
<a name="l00282"></a>00282     <span class="comment">//virtual bool subPathFilter(std::vector&lt;int&gt; &amp;subpath);</span>
<a name="l00283"></a>00283     <span class="comment">//virtual CFG getChildren(</span>
<a name="l00284"></a>00284     <span class="comment">//also not used, but important for possible later use of SynthesizedAttributes</span>
<a name="l00285"></a>00285     SynthesizedAttributeType <a class="code" href="classSgGraphTraversal.html#a518fd34370e6be9c357524280421d7e9">defaultSynthesizedAttribute</a>(InheritedAttributeType);
<a name="l00286"></a>00286 <span class="keyword">private</span>:
<a name="l00287"></a><a class="code" href="classSgGraphTraversal.html#a3362fef3719a570efb8f2b7da0f0d3ce">00287</a>     <span class="keywordtype">double</span> <a class="code" href="classSgGraphTraversal.html#a3362fef3719a570efb8f2b7da0f0d3ce">distime</a>;
<a name="l00288"></a>00288     <span class="comment">//CFG* completeGraph;</span>
<a name="l00289"></a>00289     <span class="comment">//std::set&lt;std::pair&lt;std::pair&lt;int, int&gt;, std::pair&lt;int, int&gt; &gt; &gt; flpset;</span>
<a name="l00290"></a>00290     <span class="comment">//std::set&lt;std::pair&lt;std::pair&lt;int, int&gt;, std::pair&lt;int, int&gt; &gt; &gt; goodset;</span>
<a name="l00291"></a><a class="code" href="classSgGraphTraversal.html#a9f54d3edf09383af67dbcd72ed40e7e6">00291</a>     std::set&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#a9f54d3edf09383af67dbcd72ed40e7e6">ploops</a>;
<a name="l00292"></a><a class="code" href="classSgGraphTraversal.html#a36076d6c00cc7f97c859098a725548aa">00292</a>     std::map&lt;int, std::set&lt;std::vector&lt;int&gt; &gt; &gt; <a class="code" href="classSgGraphTraversal.html#a36076d6c00cc7f97c859098a725548aa">lpbegins</a>;
<a name="l00293"></a><a class="code" href="classSgGraphTraversal.html#ada28eb165c3844fea7196c25aba5180a">00293</a>     std::map&lt;int, int&gt; <a class="code" href="classSgGraphTraversal.html#ada28eb165c3844fea7196c25aba5180a">frksLeft</a>;
<a name="l00294"></a><a class="code" href="classSgGraphTraversal.html#af7ac460d0ea02e7713db020370979820">00294</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#af7ac460d0ea02e7713db020370979820">currm</a>;
<a name="l00295"></a><a class="code" href="classSgGraphTraversal.html#a34eeb5582f97c4a69b9ba9256c062877">00295</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a34eeb5582f97c4a69b9ba9256c062877">dpMax</a>;
<a name="l00296"></a><a class="code" href="classSgGraphTraversal.html#ae7c04eef5356511034140d597cd0674c">00296</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#ae7c04eef5356511034140d597cd0674c">repEval</a>;
<a name="l00297"></a><a class="code" href="classSgGraphTraversal.html#ac8d780ea63ecbb78a26f1ad3c842cdd2">00297</a>     <span class="keywordtype">bool</span> <a class="code" href="classSgGraphTraversal.html#ac8d780ea63ecbb78a26f1ad3c842cdd2">pathCheck</a>;
<a name="l00298"></a><a class="code" href="classSgGraphTraversal.html#a4d3e877f548057b1554c12c018b43e19">00298</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a4d3e877f548057b1554c12c018b43e19">pathsSize</a>;
<a name="l00299"></a><a class="code" href="classSgGraphTraversal.html#ad4327b9793a2a998ef51c1401c228a50">00299</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#ad4327b9793a2a998ef51c1401c228a50">loopcount</a>;
<a name="l00300"></a>00300     <span class="comment">//this ructs the graph tree for computation of inheritedValues</span>
<a name="l00301"></a>00301 
<a name="l00302"></a>00302 
<a name="l00303"></a><a class="code" href="classSgGraphTraversal.html#aba004e520b52afd5a861a74b100a197a">00303</a>     std::map&lt;int, InheritedAttributeType&gt; <a class="code" href="classSgGraphTraversal.html#aba004e520b52afd5a861a74b100a197a">known</a>;
<a name="l00304"></a><a class="code" href="classSgGraphTraversal.html#a0a5623a049cb9000115396666dac237c">00304</a>     std::vector&lt;InheritedAttributeType&gt; <a class="code" href="classSgGraphTraversal.html#a0a5623a049cb9000115396666dac237c">connectNodes</a>;
<a name="l00305"></a><a class="code" href="classSgGraphTraversal.html#a86010f5d39cb6778cf4a047ca0d98845">00305</a>     std::map&lt;int, bool&gt; <a class="code" href="classSgGraphTraversal.html#a86010f5d39cb6778cf4a047ca0d98845">solved</a>;
<a name="l00306"></a><a class="code" href="classSgGraphTraversal.html#a0a77cc1585cde8ba9481c6d6504f5900">00306</a>     std::set&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#a0a77cc1585cde8ba9481c6d6504f5900">solvedset</a>;
<a name="l00307"></a>00307     <span class="comment">//these two are not used, but will be important if SynthesizedAttributes are made reasonable in this context</span>
<a name="l00308"></a><a class="code" href="classSgGraphTraversal.html#a24d9602a7d69c8eda287a73c5f60711a">00308</a>     <a class="code" href="classStackFrameVector.html">SynthesizedAttributesList</a> *<a class="code" href="classSgGraphTraversal.html#a24d9602a7d69c8eda287a73c5f60711a">synthesizedAttributes</a>;
<a name="l00309"></a>00309     SynthesizedAttributeType <a class="code" href="classSgGraphTraversal.html#a4f1c08da96585098634f104dd7051f11">traversalResult</a>();
<a name="l00310"></a>00310     <span class="comment">//finally we have two functions necessary for parallel processing if that is chosen to be used by the user</span>
<a name="l00311"></a>00311 
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 
<a name="l00314"></a>00314 
<a name="l00315"></a>00315 
<a name="l00316"></a><a class="code" href="classSgGraphTraversal.html#a1e865dbe71bc76ac609d33130669b61f">00316</a>     std::map&lt;int, int&gt; <a class="code" href="classSgGraphTraversal.html#a1e865dbe71bc76ac609d33130669b61f">nodeInEdgesNum</a>;
<a name="l00317"></a><a class="code" href="classSgGraphTraversal.html#af2b56afd75dd2d833002afb02f7a347b">00317</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#af2b56afd75dd2d833002afb02f7a347b">currprime</a>;
<a name="l00318"></a><a class="code" href="classSgGraphTraversal.html#a176b5f94e412138da111d4336d5803e6">00318</a>     std::vector&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#a176b5f94e412138da111d4336d5803e6">endnodefakes</a>;
<a name="l00319"></a><a class="code" href="classSgGraphTraversal.html#a535f018a8f9b9222307ea16d02ff0aea">00319</a>     std::map&lt;int, std::vector&lt;std::vector&lt;int&gt; &gt; &gt; <a class="code" href="classSgGraphTraversal.html#a535f018a8f9b9222307ea16d02ff0aea">pathsAtMk</a>;
<a name="l00320"></a><a class="code" href="classSgGraphTraversal.html#ab7eae8014134e4dfa672920c0efc553f">00320</a>     std::set&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#ab7eae8014134e4dfa672920c0efc553f">mkloops</a>;
<a name="l00321"></a><a class="code" href="classSgGraphTraversal.html#a2c122b986f97362f1e7a820047708fbf">00321</a>     std::map&lt;int, std::set&lt;std::vector&lt;int&gt; &gt; &gt; <a class="code" href="classSgGraphTraversal.html#a2c122b986f97362f1e7a820047708fbf">mkloopmap</a>;
<a name="l00322"></a><a class="code" href="classSgGraphTraversal.html#af525aa9efd66603496d6d28bb1abcc19">00322</a>     std::map&lt;int, std::set&lt;std::vector&lt;int&gt; &gt; &gt; <a class="code" href="classSgGraphTraversal.html#af525aa9efd66603496d6d28bb1abcc19">subPathsAtMk</a>;
<a name="l00323"></a><a class="code" href="classSgGraphTraversal.html#af742e34395ef9c423624bcec254dfe7e">00323</a>     std::vector&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#af742e34395ef9c423624bcec254dfe7e">mkglobal</a>;
<a name="l00324"></a><a class="code" href="classSgGraphTraversal.html#a611de56a9973e80941b672db2e0d5460">00324</a>     std::vector&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#a611de56a9973e80941b672db2e0d5460">clglobal</a>;
<a name="l00325"></a><a class="code" href="classSgGraphTraversal.html#aa55d310c1cafc7c634b62962b81f1249">00325</a>     <span class="keywordtype">bool</span> <a class="code" href="classSgGraphTraversal.html#aa55d310c1cafc7c634b62962b81f1249">inseparable</a>;
<a name="l00326"></a>00326     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#a1a9736b9bd3eeef8ee9b75b6cdfbdfc5">solvePaths</a>(<span class="keyword">const</span> CFG* &amp;g, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;n, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;endnode);
<a name="l00327"></a>00327     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#a6c6b340b187637a17fe26185ef0e9cf8" title="Runs preliminary analysis of the graph to allow for quick path calculations.">solvePaths2</a>(<span class="keyword">const</span> CFG* &amp;g, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;n, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;endnode);
<a name="l00328"></a>00328 
<a name="l00329"></a><a class="code" href="classSgGraphTraversal.html#a2581bf8595f34ea969f835debdb80d40">00329</a>     std::vector&lt;std::set&lt;int&gt; &gt; <a class="code" href="classSgGraphTraversal.html#a2581bf8595f34ea969f835debdb80d40">closuresVec</a>;
<a name="l00330"></a>00330     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#a4e0b975fa0d59c80d4d1422b56c4c486" title="runs the users evaluation function on all paths, thus is responsible for getting the paths to the use...">evaluatePaths</a>(<span class="keyword">const</span> CFG* &amp; g, <span class="keywordtype">int</span> realstartnode<span class="comment">/*, const int &amp;endnode*/</span>);
<a name="l00331"></a>00331     <span class="comment">//void evaluatePathsPar(CFG* g, int realstartnode, int endnode);</span>
<a name="l00332"></a>00332     <span class="keywordtype">bool</span> <a class="code" href="classSgGraphTraversal.html#acbb2fd1717a78e47023ac1d30ea9f409">disjoint</a>(std::vector&lt;int&gt;&amp; path, std::vector&lt;int&gt;&amp; vec2) ;
<a name="l00333"></a><a class="code" href="classSgGraphTraversal.html#a5a0a8762fad4488c10661b6c2aec1dae">00333</a>     std::set&lt;std::vector&lt;int&gt; &gt; <a class="code" href="classSgGraphTraversal.html#a5a0a8762fad4488c10661b6c2aec1dae">flatpaths</a>;
<a name="l00334"></a>00334 <span class="comment">//    void evalNode(CFG* g, int n);</span>
<a name="l00335"></a>00335     <span class="keywordtype">bool</span> <a class="code" href="classSgGraphTraversal.html#a93b3e1973bdd6755a6de10da79f92e26" title="::canSolve">canSolve</a>(<span class="keyword">const</span> CFG* &amp;g, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;n);
<a name="l00336"></a><a class="code" href="classSgGraphTraversal.html#a56e669929bad7f00e21c50c181a24f4c">00336</a>     std::map&lt;int, InheritedAttributeType&gt; <a class="code" href="classSgGraphTraversal.html#a56e669929bad7f00e21c50c181a24f4c">inhVals</a>;
<a name="l00337"></a>00337     <span class="comment">//std::set&lt;CFG::CFGEdgePtr&gt; seenEdges;</span>
<a name="l00338"></a><a class="code" href="classSgGraphTraversal.html#aeb083cab44769f8cc4e8176315185047">00338</a>     std::set&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#aeb083cab44769f8cc4e8176315185047">nullEdges</a>;
<a name="l00339"></a><a class="code" href="classSgGraphTraversal.html#a14441aadbaaec9ffb18d43a727551cb1">00339</a>     std::set&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#a14441aadbaaec9ffb18d43a727551cb1">clsT</a>;
<a name="l00340"></a>00340     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#ae984130d098c298843f480cd7a818542" title="This is the function that is used by the user directly to start the algorithm.">computeOrder</a>(<span class="keyword">const</span> CFG* &amp;g, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; endnode);
<a name="l00341"></a>00341     <span class="comment">//void computeOrder(CFG* g, int n, int endnode);</span>
<a name="l00342"></a>00342 
<a name="l00343"></a>00343     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#ac025d6d43427e39209560ec3ac1e8833" title="computes the InheritedAttribute values on each of the nodes">computeInheritedOrdered</a>(<span class="keyword">const</span> CFG* &amp;g, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;n);
<a name="l00344"></a>00344     std::pair&lt;bool, int&gt; <a class="code" href="classSgGraphTraversal.html#a1dc4b927b3eb7781dc6a1adb9c5e884b" title="computes the next parent node to calculate similar to getNextChild">getNextPar</a>(<span class="keyword">const</span> CFG* &amp;g, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;n);
<a name="l00345"></a>00345     std::pair&lt;bool, int&gt; <a class="code" href="classSgGraphTraversal.html#a202ad77e0c9f4edfe12b1e348d811c88" title="computes the next child node to evaluate, used in computing inheritedAttributes, picks the child that...">getNextChild</a>(<span class="keyword">const</span> CFG* &amp;g, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;n);
<a name="l00346"></a>00346     <span class="keywordtype">bool</span> <a class="code" href="classSgGraphTraversal.html#aea7df8b5b0fbc8f50e5e328634b24137" title="Checks whether or not the node can be computed for InheritedAttribute evaluation.">computable</a>( <span class="keyword">const</span> CFG* &amp;g, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;n);
<a name="l00347"></a>00347     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#adb0bdc7cf8fe6c427f1aeb748a20ba33" title="evaluates the node directly, used within computeInheritedOrdered SgGraphTraversal::evalNodeOrdered In...">evalNodeOrdered</a>(<span class="keyword">const</span> CFG* &amp;g, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;n);
<a name="l00348"></a><a class="code" href="classSgGraphTraversal.html#a3ec177c03ec8df55786427d9b708d0b1">00348</a>     std::map&lt;int, int&gt; <a class="code" href="classSgGraphTraversal.html#a3ec177c03ec8df55786427d9b708d0b1">oVals</a>;
<a name="l00349"></a>00349     <span class="keywordtype">bool</span> <a class="code" href="classSgGraphTraversal.html#abb4e5a24cad4e13c6e040df8ae60ba9b" title="Checks whether or not the node can be evaluated (deprecated)">canEval</a>(<span class="keyword">const</span> CFG* &amp;g,<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;n);
<a name="l00350"></a>00350     <span class="comment">//void setPathVal(CFG* g, int n);</span>
<a name="l00351"></a>00351     <span class="comment">//void printNodePlusEdgesForAnalysis(CFG* g, int n, int loopNum, int pathVal, std::ofstream&amp; ss);</span>
<a name="l00352"></a>00352     <span class="comment">//void printNodePlusEdgesForAnalysisPath(CFG* g, std::vector&lt;int&gt; n, int loopNum, int pathVal, std::ofstream&amp; ss);</span>
<a name="l00353"></a>00353     <span class="comment">//void printNodeForAnalysis(int n, int loopNum, int pathNum, std::ofstream&amp; ss);</span>
<a name="l00354"></a><a class="code" href="classSgGraphTraversal.html#ac1a100a2c0d24865d535c84960900421">00354</a>     std::set&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#ac1a100a2c0d24865d535c84960900421">completedNodesPath</a>;
<a name="l00355"></a><a class="code" href="classSgGraphTraversal.html#af3a2dee1c2c364f7f2e20ee202f0ae57">00355</a>     std::set&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#af3a2dee1c2c364f7f2e20ee202f0ae57">completedEdgesPath</a>;
<a name="l00356"></a>00356     <span class="comment">//void printEdgeForAnalysis(CFG::CFGEdgePtr e, bool isNullEdge, std::ofstream&amp; ss);</span>
<a name="l00357"></a>00357     <span class="comment">//void printEdgeForAnalysisPath(int g1, int g2, std::ofstream&amp; ss);</span>
<a name="l00358"></a><a class="code" href="classSgGraphTraversal.html#afcee56182d4ec5ebd1d4d4ca0faaceef">00358</a>     std::map&lt;int, int&gt; <a class="code" href="classSgGraphTraversal.html#afcee56182d4ec5ebd1d4d4ca0faaceef">iVals</a>;
<a name="l00359"></a>00359 
<a name="l00360"></a>00360     <span class="comment">//std::set&lt;CFG::CFGEdgePtr&gt; nullEdgesOrderedOut;</span>
<a name="l00361"></a><a class="code" href="classSgGraphTraversal.html#a2e39ed69fab47b2f4ff77622b1be9fe3">00361</a>     std::set&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#a2e39ed69fab47b2f4ff77622b1be9fe3">completedEdgesOut</a>;
<a name="l00362"></a><a class="code" href="classSgGraphTraversal.html#a67a2f8531528eeea7f79d7bfa732b705">00362</a>     std::set&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#a67a2f8531528eeea7f79d7bfa732b705">completedEdges</a>;
<a name="l00363"></a><a class="code" href="classSgGraphTraversal.html#ab419e40a12952e57d49b06023d48a39e">00363</a>     std::set&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#ab419e40a12952e57d49b06023d48a39e">compPar</a>;
<a name="l00364"></a><a class="code" href="classSgGraphTraversal.html#a03f365be3063c9e8410fae59a89e75f6">00364</a>     std::set&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#a03f365be3063c9e8410fae59a89e75f6">compChild</a>;
<a name="l00365"></a><a class="code" href="classSgGraphTraversal.html#a125315036357b2787436ec7b53e5fbc4">00365</a>     std::set&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#a125315036357b2787436ec7b53e5fbc4">computedNodes</a>;
<a name="l00366"></a><a class="code" href="classSgGraphTraversal.html#a9640876401a1fdc9013f862b863cf42c">00366</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a9640876401a1fdc9013f862b863cf42c">st</a>;
<a name="l00367"></a><a class="code" href="classSgGraphTraversal.html#aedc643b799c372dfb6cd4153db815aa0">00367</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#aedc643b799c372dfb6cd4153db815aa0">en</a>;
<a name="l00368"></a><a class="code" href="classSgGraphTraversal.html#a0726f1ca41084a575979799aaa36b934">00368</a>     <span class="keywordtype">double</span> <a class="code" href="classSgGraphTraversal.html#a0726f1ca41084a575979799aaa36b934">fllp</a>;
<a name="l00369"></a><a class="code" href="classSgGraphTraversal.html#a1e12879d752278baf2ef8612d481cf04">00369</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a1e12879d752278baf2ef8612d481cf04">loopnum</a>;
<a name="l00370"></a>00370     <span class="comment">//std::map&lt;int, std::pair&lt;CFG::CFGEdgePtr, CFG::CFGEdgePtr&gt; &gt; badEdgesIn;</span>
<a name="l00371"></a>00371     <span class="comment">//std::map&lt;int, std::pair&lt;CFG::CFGEdgePtr, CFG::CFGEdgePtr&gt; &gt; badEdgesOut;</span>
<a name="l00372"></a><a class="code" href="classSgGraphTraversal.html#a5333156c81231c361c39f142c4bdbfdd">00372</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a5333156c81231c361c39f142c4bdbfdd">currmkloopint</a>;
<a name="l00373"></a><a class="code" href="classSgGraphTraversal.html#a84977d7a64e0eba141348c2d10a04905">00373</a>     std::map&lt;int, int&gt; <a class="code" href="classSgGraphTraversal.html#a84977d7a64e0eba141348c2d10a04905">mkLoopInt</a>;
<a name="l00374"></a>00374 
<a name="l00375"></a><a class="code" href="classSgGraphTraversal.html#a2cc7cadfaa9b9aeb686182afe866fc9f">00375</a>     std::vector&lt;std::vector&lt;int&gt; &gt; <a class="code" href="classSgGraphTraversal.html#a2cc7cadfaa9b9aeb686182afe866fc9f">mkloopmapstore</a>;
<a name="l00376"></a>00376     std::vector&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#a6d4ec75b9e8c69d5ce9bdd8d1ae95ac3">getOutEdges</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keyword">const</span> CFG*&amp; g);
<a name="l00377"></a>00377     std::vector&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#a9a845a70aa43aca3e2aebaad4b33e9b5">getInEdges</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keyword">const</span> CFG*&amp; g);
<a name="l00378"></a>00378     std::vector&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#a3c6f278afef4025017da55fa6ba5688e">getInNodes</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keyword">const</span> CFG*&amp; g);
<a name="l00379"></a>00379     std::vector&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#a1980bee8d663118992055d94eb8763ce">getOutNodes</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;n, <span class="keyword">const</span> CFG*&amp; g);
<a name="l00380"></a>00380     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#ad2d92c824f75f832a1c1eb978c428579">getSource</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; e, <span class="keyword">const</span> CFG*&amp; g);
<a name="l00381"></a>00381     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a0b7e91d070514371552efcdb86900a06">getTarget</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;e, <span class="keyword">const</span> CFG*&amp; g);
<a name="l00382"></a><a class="code" href="classSgGraphTraversal.html#ad258da4a5fd6b642889995892f4ff6a1">00382</a>     std::map&lt;int, Vertex&gt; <a class="code" href="classSgGraphTraversal.html#ad258da4a5fd6b642889995892f4ff6a1">intvertmap</a>;
<a name="l00383"></a><a class="code" href="classSgGraphTraversal.html#a084fa444c0721d93cd103c49bd4596b4">00383</a>     std::map&lt;int, Edge&gt; <a class="code" href="classSgGraphTraversal.html#a084fa444c0721d93cd103c49bd4596b4">intedgemap</a>;
<a name="l00384"></a><a class="code" href="classSgGraphTraversal.html#a4c2f363dde5f6f8ce6dfeba9d1e9f509">00384</a>     std::map&lt;Edge, int&gt; <a class="code" href="classSgGraphTraversal.html#a4c2f363dde5f6f8ce6dfeba9d1e9f509">edgeintmap</a>;
<a name="l00385"></a><a class="code" href="classSgGraphTraversal.html#a1aee43550daac8cc84baeb40c0b5b1c8">00385</a>     std::map&lt;Vertex, int&gt; <a class="code" href="classSgGraphTraversal.html#a1aee43550daac8cc84baeb40c0b5b1c8">vertintmap</a>;
<a name="l00386"></a>00386     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#a06bcd8bfde6efd796304cc85046a603e">numerate</a>(<span class="keyword">const</span> CFG*&amp; g);
<a name="l00387"></a>00387     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#a271e2b79661b8e68ff5796739e605c8f" title="This is the function that is used by the user directly to start the algorithm.">findclmk</a>(<span class="keyword">const</span> CFG*&amp; g);
<a name="l00388"></a><a class="code" href="classSgGraphTraversal.html#ad522ef7d554cd05974ed480a6772118c">00388</a>     std::set&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#ad522ef7d554cd05974ed480a6772118c">cls</a>;
<a name="l00389"></a><a class="code" href="classSgGraphTraversal.html#aba7fdb74c2509532649df9a105e2e349">00389</a>     std::set&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#aba7fdb74c2509532649df9a105e2e349">mks</a>;
<a name="l00390"></a><a class="code" href="classSgGraphTraversal.html#aa811affc355ffb98944fbdf291a41540">00390</a>     std::set&lt;std::vector&lt;int&gt; &gt; <a class="code" href="classSgGraphTraversal.html#aa811affc355ffb98944fbdf291a41540">collected_loops</a>;
<a name="l00391"></a>00391     <span class="comment">//std::set&lt;int&gt; solved;</span>
<a name="l00392"></a>00392     <span class="comment">//InheritedAttributeType findAndReverse(int n, CFG* g);</span>
<a name="l00393"></a>00393     <span class="comment">//evaluateAllInheritedAttribute(std::vector&lt;InheritedAttributeType&gt; endNodeInhVec, int endnode, std::vector&lt;int&gt; nodes, std::vector&lt;InheritedAttributeType&gt; inh);</span>
<a name="l00394"></a>00394 <span class="comment">//std::vector&lt;InheritedAttributeType&gt; getZeroInhs(std::vector&lt;std::vector&lt;std::vector&lt;int&gt; &gt; &gt; qAnsSetSet, std::vector&lt;InheritedAttributeType&gt; endnodeInhVec, int node);</span>
<a name="l00395"></a>00395 
<a name="l00396"></a>00396 };
<a name="l00397"></a>00397 
<a name="l00398"></a>00398 
<a name="l00399"></a>00399 
<a name="l00400"></a>00400 <span class="comment">/*</span>
<a name="l00401"></a>00401 <span class="comment">template &lt;class InheritedAttributeType, class SynthesizedAttributeType, class CFG&gt;</span>
<a name="l00402"></a>00402 <span class="comment">void</span>
<a name="l00403"></a>00403 <span class="comment">GraphBot&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</span>
<a name="l00404"></a>00404 <span class="comment">travelDown(CFG* g) {</span>
<a name="l00405"></a>00405 <span class="comment">    std::pair&lt;CFG::CFGEdgePtr, CFG::CFGEdgePtr&gt; oedgs = g-&gt;out_edges(iAmHere);</span>
<a name="l00406"></a>00406 <span class="comment">    bool taken = false;</span>
<a name="l00407"></a>00407 <span class="comment">    if (oedgs.size() &gt; 1) {</span>
<a name="l00408"></a>00408 <span class="comment">        std::pair&lt;CFG::CFGEdgePtr, CFG::CFGEdgePtr&gt; edgeTrav = clEdgeTrav[iAmHere];</span>
<a name="l00409"></a>00409 <span class="comment">        ROSE_ASSERT(clEdgeTrav.find(iAmHere) != clEdgeTrav.end());</span>
<a name="l00410"></a>00410 <span class="comment">        for (std::pair&lt;CFG::CFGEdgePtr, CFG::CFGEdgePtr&gt;::iterator i = oedgs.begin(); i != oedgs.end(); i++) {</span>
<a name="l00411"></a>00411 <span class="comment">            if (edgTrav.find(*i) == edgTrav.end() || !taken) {</span>
<a name="l00412"></a>00412 <span class="comment">                taken = true;</span>
<a name="l00413"></a>00413 <span class="comment">                iAmHere = (*i)-&gt;get_to();</span>
<a name="l00414"></a>00414 <span class="comment">                lastEdge = *i;</span>
<a name="l00415"></a>00415 <span class="comment">            }</span>
<a name="l00416"></a>00416 <span class="comment">        }</span>
<a name="l00417"></a>00417 <span class="comment">    }</span>
<a name="l00418"></a>00418 <span class="comment">    else {</span>
<a name="l00419"></a>00419 <span class="comment">        iAmHere = (*(oedgs.begin())-&gt;get_to();</span>
<a name="l00420"></a>00420 <span class="comment">    }</span>
<a name="l00421"></a>00421 <span class="comment">}</span>
<a name="l00422"></a>00422 <span class="comment">*/</span>
<a name="l00423"></a>00423 
<a name="l00424"></a>00424 
<a name="l00425"></a>00425 
<a name="l00426"></a>00426 
<a name="l00427"></a>00427 
<a name="l00428"></a>00428 
<a name="l00429"></a>00429 <span class="comment">/*</span>
<a name="l00430"></a>00430 <span class="comment">***************************</span>
<a name="l00431"></a>00431 <span class="comment">Various Admin Functions</span>
<a name="l00432"></a>00432 <span class="comment">***************************</span>
<a name="l00433"></a>00433 <span class="comment">*/</span>
<a name="l00434"></a>00434 
<a name="l00435"></a>00435 
<a name="l00436"></a>00436 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l00437"></a>00437 <a class="code" href="classSgGraphTraversal.html#a9a20dc8d3bb63d107a81929187c72673">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l00438"></a><a class="code" href="classSgGraphTraversal.html#a9a20dc8d3bb63d107a81929187c72673">00438</a> <a class="code" href="classSgGraphTraversal.html#a9a20dc8d3bb63d107a81929187c72673">SgGraphTraversal</a>()
<a name="l00439"></a>00439     : synthesizedAttributes(new <a class="code" href="classStackFrameVector.html">SynthesizedAttributesList</a>())
<a name="l00440"></a>00440 {
<a name="l00441"></a>00441 }
<a name="l00442"></a>00442 
<a name="l00443"></a>00443 
<a name="l00444"></a>00444 <span class="preprocessor">#ifndef SWIG</span>
<a name="l00445"></a>00445 <span class="preprocessor"></span>
<a name="l00446"></a>00446 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l00447"></a>00447 <a class="code" href="classSgGraphTraversal.html#a88455ca855d3460510a2d6cfe9cb0b38">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l00448"></a><a class="code" href="classSgGraphTraversal.html#a88455ca855d3460510a2d6cfe9cb0b38">00448</a> <a class="code" href="classSgGraphTraversal.html#a88455ca855d3460510a2d6cfe9cb0b38">~SgGraphTraversal</a>()
<a name="l00449"></a>00449 {
<a name="l00450"></a>00450     ROSE_ASSERT(synthesizedAttributes != NULL);
<a name="l00451"></a>00451     <span class="keyword">delete</span> synthesizedAttributes;
<a name="l00452"></a>00452     synthesizedAttributes = NULL;
<a name="l00453"></a>00453 }
<a name="l00454"></a>00454 
<a name="l00455"></a>00455 <span class="preprocessor">#endif</span>
<a name="l00456"></a>00456 <span class="preprocessor"></span>
<a name="l00457"></a>00457 
<a name="l00458"></a>00458 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l00459"></a>00459 <a class="code" href="classSgGraphTraversal.html">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;</a> &amp;
<a name="l00460"></a>00460 <a class="code" href="classSgGraphTraversal.html#a9066477debed9798e60fe3a767151364">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l00461"></a><a class="code" href="classSgGraphTraversal.html#a9066477debed9798e60fe3a767151364">00461</a> <a class="code" href="classSgGraphTraversal.html#a9066477debed9798e60fe3a767151364">operator=</a>( <a class="code" href="classSgGraphTraversal.html">SgGraphTraversal</a> &amp;other)
<a name="l00462"></a>00462 {
<a name="l00463"></a>00463 
<a name="l00464"></a>00464     ROSE_ASSERT(synthesizedAttributes != NULL);
<a name="l00465"></a>00465     <span class="keyword">delete</span> synthesizedAttributes;
<a name="l00466"></a>00466     synthesizedAttributes = other.<a class="code" href="classSgGraphTraversal.html#a24d9602a7d69c8eda287a73c5f60711a">synthesizedAttributes</a>-&gt;<a class="code" href="classStackFrameVector.html#ac067807e279a237ef4b642c665bc741f">deepCopy</a>();
<a name="l00467"></a>00467 
<a name="l00468"></a>00468     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00469"></a>00469 }
<a name="l00470"></a>00470 
<a name="l00471"></a>00471 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l00472"></a>00472 <span class="keywordtype">void</span>
<a name="l00473"></a>00473 <a class="code" href="classSgGraphTraversal.html#a6fd50d9df16d2690f548524a3071a5bb">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l00474"></a><a class="code" href="classSgGraphTraversal.html#a6fd50d9df16d2690f548524a3071a5bb">00474</a> <a class="code" href="classSgGraphTraversal.html#a6fd50d9df16d2690f548524a3071a5bb">printCFGNode</a>(<span class="keywordtype">int</span> cf, std::ofstream&amp; o)
<a name="l00475"></a>00475 {
<a name="l00476"></a>00476     std::string nodeColor = <span class="stringliteral">&quot;black&quot;</span>;
<a name="l00477"></a>00477     o &lt;&lt; cf &lt;&lt; <span class="stringliteral">&quot; [label=\&quot;&quot;</span> &lt;&lt; <span class="stringliteral">&quot; num:&quot;</span> &lt;&lt; cf &lt;&lt; <span class="stringliteral">&quot;\&quot;, color=\&quot;&quot;</span> &lt;&lt; nodeColor &lt;&lt; <span class="stringliteral">&quot;\&quot;, style=\&quot;&quot;</span> &lt;&lt; <span class="stringliteral">&quot;solid&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\&quot;];\n&quot;</span>;
<a name="l00478"></a>00478     <span class="comment">/*</span>
<a name="l00479"></a>00479 <span class="comment">        std::string label;</span>
<a name="l00480"></a>00480 <span class="comment">            if (preVal.find(cf) == preVal.end()) {</span>
<a name="l00481"></a>00481 <span class="comment">                preVal[cf] = 0;</span>
<a name="l00482"></a>00482 <span class="comment">            }</span>
<a name="l00483"></a>00483 <span class="comment">            if (hotVal.find(cf) == hotVal.end()) {</span>
<a name="l00484"></a>00484 <span class="comment">                hotVal[cf] = 0;</span>
<a name="l00485"></a>00485 <span class="comment">            }</span>
<a name="l00486"></a>00486 <span class="comment">        o &lt;&lt; cf &lt;&lt; &quot; [label=\&quot;&quot; &lt;&lt; &quot;preV:&quot; &lt;&lt; preVal[cf] &lt;&lt; &quot; hotV:&quot; &lt;&lt; hotVal[cf] &lt;&lt; &quot; num:&quot; &lt;&lt; cf &lt;&lt; &quot;\&quot;, color=\&quot;&quot; &lt;&lt; nodeColor &lt;&lt; &quot;\&quot;, style=\&quot;&quot; &lt;&lt; &quot;solid&quot; &lt;&lt; &quot;\&quot;];\n&quot;;</span>
<a name="l00487"></a>00487 <span class="comment">    */</span>
<a name="l00488"></a>00488 }
<a name="l00489"></a>00489 
<a name="l00490"></a>00490 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l00491"></a>00491 <span class="keywordtype">void</span>
<a name="l00492"></a>00492 <a class="code" href="classSgGraphTraversal.html#a5db6bb8812576bd43146c6aab69908a8">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l00493"></a><a class="code" href="classSgGraphTraversal.html#a5db6bb8812576bd43146c6aab69908a8">00493</a> <a class="code" href="classSgGraphTraversal.html#a5db6bb8812576bd43146c6aab69908a8">printCFGEdge</a>(<span class="keywordtype">int</span> cf, <span class="keyword">const</span> CFG*&amp; cfg, std::ofstream&amp; o)
<a name="l00494"></a>00494 {
<a name="l00495"></a>00495     <span class="keywordtype">int</span> src = getSource(cf, cfg);
<a name="l00496"></a>00496     <span class="keywordtype">int</span> tar = getTarget(cf, cfg);
<a name="l00497"></a>00497     o &lt;&lt; src &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span> &lt;&lt; tar &lt;&lt; <span class="stringliteral">&quot; [label=\&quot;&quot;</span> &lt;&lt; src &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; tar &lt;&lt; <span class="stringliteral">&quot;\&quot;, style=\&quot;&quot;</span> &lt;&lt; <span class="stringliteral">&quot;solid&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\&quot;];\n&quot;</span>;
<a name="l00498"></a>00498 }
<a name="l00499"></a>00499 
<a name="l00500"></a>00500 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l00501"></a>00501 <span class="keywordtype">void</span>
<a name="l00502"></a>00502 <a class="code" href="classSgGraphTraversal.html#afa7781ad505ac354a94c889c1b3cc973">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l00503"></a><a class="code" href="classSgGraphTraversal.html#afa7781ad505ac354a94c889c1b3cc973">00503</a> <a class="code" href="classSgGraphTraversal.html#afa7781ad505ac354a94c889c1b3cc973">printHotness</a>(<span class="keyword">const</span> CFG*&amp; g)
<a name="l00504"></a>00504 {
<a name="l00505"></a>00505     <span class="comment">//vertices(*g);</span>
<a name="l00506"></a>00506     <span class="comment">//edges(*g);</span>
<a name="l00507"></a>00507     std::ofstream mf;
<a name="l00508"></a>00508     mf.open(<span class="stringliteral">&quot;hotness.dot&quot;</span>);
<a name="l00509"></a>00509     mf &lt;&lt; <span class="stringliteral">&quot;digraph defaultName { \n&quot;</span>;
<a name="l00510"></a>00510     <a class="code" href="classSgGraphTraversal.html#a6eaf6918f211ac66aa12eb452d761f22">vertex_iterator</a> v, vend;
<a name="l00511"></a>00511     <a class="code" href="classSgGraphTraversal.html#a49f0402773be87248387897070120ab0">edge_iterator</a> e, eend;
<a name="l00512"></a>00512     <span class="keywordflow">for</span> (tie(v, vend) = vertices(*g); v != vend; ++v)
<a name="l00513"></a>00513     {
<a name="l00514"></a>00514         printCFGNode(vertintmap[*v], mf);
<a name="l00515"></a>00515     }
<a name="l00516"></a>00516     <span class="keywordflow">for</span> (tie(e, eend) = edges(*g); e != eend; ++e)
<a name="l00517"></a>00517     {
<a name="l00518"></a>00518         printCFGEdge(edgeintmap[*e], g, mf);
<a name="l00519"></a>00519     }
<a name="l00520"></a>00520     mf.close();
<a name="l00521"></a>00521 }
<a name="l00522"></a>00522 
<a name="l00523"></a>00523 
<a name="l00524"></a>00524 
<a name="l00541"></a>00541 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l00542"></a>00542 <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00543"></a>00543 <a class="code" href="classSgGraphTraversal.html#a271e2b79661b8e68ff5796739e605c8f" title="This is the function that is used by the user directly to start the algorithm.">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l00544"></a><a class="code" href="classSgGraphTraversal.html#a271e2b79661b8e68ff5796739e605c8f">00544</a> <a class="code" href="classSgGraphTraversal.html#a271e2b79661b8e68ff5796739e605c8f" title="This is the function that is used by the user directly to start the algorithm.">findclmk</a>(<span class="keyword">const</span> CFG*&amp; g)
<a name="l00545"></a>00545 {
<a name="l00546"></a>00546     <span class="comment">//vertices(*g);</span>
<a name="l00547"></a>00547     <span class="comment">//edges(*g);</span>
<a name="l00548"></a>00548     <span class="keywordtype">int</span> nextEdge = 1;
<a name="l00549"></a>00549     <span class="keywordtype">int</span> nextNode = 1;
<a name="l00550"></a>00550     <a class="code" href="classSgGraphTraversal.html#a6eaf6918f211ac66aa12eb452d761f22">vertex_iterator</a> v, vend;
<a name="l00551"></a>00551     <span class="keywordflow">for</span> (tie(v, vend) = vertices(*g); v != vend; ++v)
<a name="l00552"></a>00552     {
<a name="l00553"></a>00553         <span class="comment">//out_edge_iterator i, j;</span>
<a name="l00554"></a>00554         <span class="comment">//in_edge_iterator k, l;</span>
<a name="l00555"></a>00555         <span class="comment">//boost::tie(i, j) = boost::out_edges(*v, *g);</span>
<a name="l00556"></a>00556         <span class="comment">//boost::tie(k, l) = boost::in_edges(*v, *g);</span>
<a name="l00557"></a>00557         std::vector&lt;int&gt; outs = getOutEdges(vertintmap[*v], g);
<a name="l00558"></a>00558         std::vector&lt;int&gt; ins = getInEdges(vertintmap[*v], g);
<a name="l00559"></a>00559         <span class="keywordflow">if</span> (outs.size() &gt; 1)
<a name="l00560"></a>00560         {
<a name="l00561"></a>00561             mks.insert(vertintmap[*v]);
<a name="l00562"></a>00562         }
<a name="l00563"></a>00563         <span class="keywordflow">if</span> (ins.size() &gt; 1)
<a name="l00564"></a>00564         {
<a name="l00565"></a>00565             cls.insert(vertintmap[*v]);
<a name="l00566"></a>00566             mkloops.insert(vertintmap[*v]);
<a name="l00567"></a>00567         }
<a name="l00568"></a>00568     }
<a name="l00569"></a>00569     std::cout &lt;&lt; <span class="stringliteral">&quot;cls&#39;s: &quot;</span> &lt;&lt; cls.size() &lt;&lt; std::endl;
<a name="l00570"></a>00570     std::cout &lt;&lt; <span class="stringliteral">&quot;mks&#39;s: &quot;</span> &lt;&lt; mks.size() &lt;&lt; std::endl;
<a name="l00571"></a>00571     <span class="keywordflow">for</span> (std::set&lt;int&gt;::iterator i = mks.begin(); i != mks.end(); i++)
<a name="l00572"></a>00572     {
<a name="l00573"></a>00573         std::cout &lt;&lt; *i &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;
<a name="l00574"></a>00574     }
<a name="l00575"></a>00575     std::cout &lt;&lt; std::endl;
<a name="l00576"></a>00576     std::cout &lt;&lt; <span class="stringliteral">&quot;completed find clmk&quot;</span> &lt;&lt; std::endl;
<a name="l00577"></a>00577 }
<a name="l00578"></a>00578 
<a name="l00579"></a>00579 
<a name="l00580"></a>00580 
<a name="l00581"></a>00581 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l00582"></a>00582 InheritedAttributeType
<a name="l00583"></a>00583 <a class="code" href="classSgGraphTraversal.html#a9b6874b8b18d2368b29e17eb63a15034">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l00584"></a><a class="code" href="classSgGraphTraversal.html#a9b6874b8b18d2368b29e17eb63a15034">00584</a> <a class="code" href="classSgGraphTraversal.html#a9b6874b8b18d2368b29e17eb63a15034">traverse</a>(<a class="code" href="classSgGraphTraversal.html#a3347055fc33f2c5105a567f9798f6a5c">Vertex</a> &amp;nVert, CFG* &amp;g, InheritedAttributeType &amp;inheritedValue, InheritedAttributeType &amp;nullI, <a class="code" href="classSgGraphTraversal.html#a3347055fc33f2c5105a567f9798f6a5c">Vertex</a> &amp;endnodeVert, <span class="keywordtype">bool</span> insep, <span class="keywordtype">bool</span> binary)
<a name="l00585"></a>00585 {
<a name="l00586"></a>00586     <span class="comment">//numnodes = 0;</span>
<a name="l00587"></a>00587     <span class="comment">//primes.clear();</span>
<a name="l00588"></a>00588     <span class="comment">//std::set&lt;std::vector&lt;int&gt; &gt; collected_paths;</span>
<a name="l00589"></a>00589     <span class="keywordtype">int</span> loopdetectnum = 0;
<a name="l00590"></a>00590     <span class="keyword">const</span> CFG* gc = g;
<a name="l00591"></a>00591     numerate(gc);
<a name="l00592"></a>00592     findclmk(gc);
<a name="l00593"></a>00593     printHotness(gc);
<a name="l00594"></a>00594     getEntryExit(gc);
<a name="l00595"></a>00595     <span class="keywordflow">if</span> (nVert == NULL)
<a name="l00596"></a>00596     {
<a name="l00597"></a>00597         nVert = sources[0];
<a name="l00598"></a>00598     }
<a name="l00599"></a>00599     <span class="keywordflow">if</span> (endnodeVert == NULL)
<a name="l00600"></a>00600     {
<a name="l00601"></a>00601         endnodeVert = sinks[0];
<a name="l00602"></a>00602     }
<a name="l00603"></a>00603     <span class="keyword">const</span> <a class="code" href="classSgGraphTraversal.html#a3347055fc33f2c5105a567f9798f6a5c">Vertex</a> nVertc = nVert;
<a name="l00604"></a>00604     <span class="keyword">const</span> <a class="code" href="classSgGraphTraversal.html#a3347055fc33f2c5105a567f9798f6a5c">Vertex</a> endnodevertc = endnodeVert;
<a name="l00605"></a>00605     <span class="keywordtype">int</span> endnode = vertintmap[endnodeVert];
<a name="l00606"></a>00606     <span class="keyword">const</span> <span class="keywordtype">int</span> endnodec = endnode;
<a name="l00607"></a>00607     <span class="keywordtype">int</span> n = vertintmap[nVert];
<a name="l00608"></a>00608     <span class="keyword">const</span> <span class="keywordtype">int</span> nc = n;
<a name="l00609"></a>00609     intvertmap[n] = nVert;
<a name="l00610"></a>00610     intvertmap[endnode] = endnodeVert;
<a name="l00611"></a>00611     pathnum = 0;
<a name="l00612"></a>00612     <span class="comment">//int n = intvertmap[endnodeVert];</span>
<a name="l00613"></a>00613     <span class="comment">//intvertmap[0] = nVert;</span>
<a name="l00614"></a>00614     <span class="comment">//vertintmap[nVert] = 0;</span>
<a name="l00615"></a>00615     <span class="comment">//intvertmap[-1] = endnodeVert;</span>
<a name="l00616"></a>00616     <span class="comment">//intvertmap[endnodeVert] = -1;</span>
<a name="l00617"></a>00617     loopcount = 0;
<a name="l00618"></a>00618     currmkloopint = 0;
<a name="l00619"></a>00619     looppaths.clear();
<a name="l00620"></a>00620     iLoops.clear();
<a name="l00621"></a>00621     completedEdgesPath.clear();
<a name="l00622"></a>00622     pathValMap.clear();
<a name="l00623"></a>00623     loopNumMap.clear();
<a name="l00624"></a>00624     nullloops = 0;
<a name="l00625"></a>00625     nullEdgesPaths = 0;
<a name="l00626"></a>00626     fllp = 0.0;
<a name="l00627"></a>00627     mkglobal.clear();
<a name="l00628"></a>00628     clglobal.clear();
<a name="l00629"></a>00629     CFG* gU = g;
<a name="l00630"></a>00630     <span class="keywordtype">int</span> nU = n;
<a name="l00631"></a>00631     <span class="keywordtype">int</span> endnodeU = endnode;
<a name="l00632"></a>00632     lpbegins.clear();
<a name="l00633"></a>00633     <span class="comment">//currents.clear();</span>
<a name="l00634"></a>00634     inhVals.clear();
<a name="l00635"></a>00635     iVals.clear();
<a name="l00636"></a>00636     oVals.clear();
<a name="l00637"></a>00637     <span class="comment">//reservedEdges.clear();</span>
<a name="l00638"></a>00638     completedEdges.clear();
<a name="l00639"></a>00639     completedEdgesOut.clear();
<a name="l00640"></a>00640     <span class="comment">//completedNodes.clear();</span>
<a name="l00641"></a>00641     computedNodes.clear();
<a name="l00642"></a>00642     nullEdgesOrdered.clear();
<a name="l00643"></a>00643 <span class="comment">//   nullEdgesOrderedOut.clear();</span>
<a name="l00644"></a>00644     loopSet.clear();
<a name="l00645"></a>00645     pathsAtMk.clear();
<a name="l00646"></a>00646 
<a name="l00647"></a>00647     st = n;
<a name="l00648"></a>00648     en = endnode;
<a name="l00649"></a>00649     distime = 0.0;
<a name="l00650"></a>00650     <span class="keywordtype">int</span> currm = 1;
<a name="l00651"></a>00651     <span class="keywordtype">int</span> turns = 0;
<a name="l00652"></a>00652     pathsSize = 0;
<a name="l00653"></a>00653     done = <span class="keyword">false</span>;
<a name="l00654"></a>00654     numnodes = 1;
<a name="l00655"></a>00655     std::cout &lt;&lt; <span class="stringliteral">&quot;starting traversal&quot;</span> &lt;&lt; std::endl;
<a name="l00656"></a>00656 <span class="comment">//   pathCheck = pCh;</span>
<a name="l00657"></a>00657     currprime = 1;
<a name="l00658"></a>00658     inseparable = insep;
<a name="l00659"></a>00659     synthesizedAttributes-&gt;resetStack();
<a name="l00660"></a>00660     ROSE_ASSERT(synthesizedAttributes-&gt;debugSize() == 0);
<a name="l00661"></a>00661     <span class="comment">//SgCFG = cfg;</span>
<a name="l00662"></a>00662     inhVals[n] = inheritedValue;
<a name="l00663"></a>00663     <span class="comment">//GraphBot&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::inhVals[n] = inheritedValue;</span>
<a name="l00664"></a>00664     <span class="comment">//primes = generatePrimesSieve();</span>
<a name="l00665"></a>00665 
<a name="l00666"></a>00666 
<a name="l00667"></a>00667 <span class="comment">//   graphnodeinheritedordmap[ncpy] = inheritedValue;</span>
<a name="l00668"></a>00668 <span class="comment">//   nodenodeordmap[ncpy] = n;</span>
<a name="l00669"></a>00669 <span class="comment">//   std::vector&lt;int&gt; lst;</span>
<a name="l00670"></a>00670 <span class="comment">//   lst.push_back(n);</span>
<a name="l00671"></a>00671 <span class="comment">//   lstordmap[ncpy] = lst;</span>
<a name="l00672"></a>00672 
<a name="l00673"></a>00673     nullInherit = nullI;
<a name="l00674"></a>00674     InheritedAttributeType inh;
<a name="l00675"></a>00675     <span class="keyword">struct </span>timeval t1, t2, t3, t4, t5, t6, t7, t8;
<a name="l00676"></a>00676     <span class="comment">//else {</span>
<a name="l00677"></a>00677     loopnum = 0;
<a name="l00678"></a>00678     <span class="comment">//InheritedAttributeType inh;</span>
<a name="l00679"></a>00679     t1 = <a class="code" href="graphProcessing_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l00680"></a>00680 
<a name="l00681"></a>00681     <span class="comment">//this function essentially sets up for the evaluate later, it makes putting together the paths much easier</span>
<a name="l00682"></a>00682     solvePaths2(gc, nc, endnodec);
<a name="l00683"></a>00683 
<a name="l00684"></a>00684     t2 = <a class="code" href="graphProcessing_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l00685"></a>00685 
<a name="l00686"></a>00686 <span class="comment">//making sure that endnode hasn&#39;t already been evaluated before the traversal starts, unlikely but just in case</span>
<a name="l00687"></a>00687 <span class="comment">//       ROSE_ASSERT(inhVals.find(endnode) == inhVals.end());</span>
<a name="l00688"></a>00688 
<a name="l00689"></a>00689     <span class="comment">//std::cout &lt;&lt; &quot;solvePaths done&quot; &lt;&lt; std::endl;</span>
<a name="l00690"></a>00690     <span class="keywordtype">double</span> diff = <a class="code" href="graphProcessing_8h.html#ae0e3d51bc94bbc9201f1125a8407492f">timeDifference</a>(t2, t1);
<a name="l00691"></a>00691     t5 = <a class="code" href="graphProcessing_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l00692"></a>00692     <span class="comment">//InheritedAttributeType pthgraphinherit = botTraverse(g, n, endnode);</span>
<a name="l00693"></a>00693     oVals[n] = 0;
<a name="l00694"></a>00694     iVals[0] = n;
<a name="l00695"></a>00695     pathValMap[n] = 1;
<a name="l00696"></a>00696     pnum = 0;
<a name="l00697"></a>00697 <span class="comment">//inserting n as a computed node</span>
<a name="l00698"></a>00698     computedNodes.insert(n);
<a name="l00699"></a>00699 <span class="comment">//computes the order in which the nodes must be evaluated, makes computeInheritedOrdered much faster</span>
<a name="l00700"></a>00700     computeOrder(gc, nc, endnodec);
<a name="l00701"></a>00701     std::cout &lt;&lt; <span class="stringliteral">&quot;order computed&quot;</span> &lt;&lt; std::endl;
<a name="l00702"></a>00702 <span class="comment">//computes the nodal inheritance values</span>
<a name="l00703"></a>00703     computeInheritedOrdered(gc, nc);
<a name="l00704"></a>00704     std::cout &lt;&lt; <span class="stringliteral">&quot;inheritance computed&quot;</span> &lt;&lt; std::endl;
<a name="l00705"></a>00705     <span class="comment">//ROSE_ASSERT(oVals.find(endnode) != oVals.end());</span>
<a name="l00706"></a>00706     <span class="comment">//ROSE_ASSERT(inhVals.find(endnode) != inhVals.end());</span>
<a name="l00707"></a>00707 <span class="comment">//value at the endnode</span>
<a name="l00708"></a>00708     InheritedAttributeType pthgraphinherit = inhVals[endnode];
<a name="l00709"></a>00709     <span class="comment">//= evaluateGraph(g, n, endnode, inheritedValue);</span>
<a name="l00710"></a>00710     t6 = <a class="code" href="graphProcessing_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l00711"></a>00711     std::cout &lt;&lt; <span class="stringliteral">&quot;evaluateGraph done&quot;</span> &lt;&lt; std::endl;
<a name="l00712"></a>00712     <span class="keywordtype">double</span> diff3 = <a class="code" href="graphProcessing_8h.html#ae0e3d51bc94bbc9201f1125a8407492f">timeDifference</a>(t6, t5);
<a name="l00713"></a>00713     t3 = <a class="code" href="graphProcessing_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l00714"></a>00714 <span class="comment">//actually evaluates every path with a user defined pathAnalyze function</span>
<a name="l00715"></a>00715     <span class="comment">//for (int i = 0; i &lt; 10; i++) {</span>
<a name="l00716"></a>00716     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; sources.size(); i++)
<a name="l00717"></a>00717     {
<a name="l00718"></a>00718         <span class="keyword">const</span> <span class="keywordtype">int</span> ni = sources[i];
<a name="l00719"></a>00719         std::vector&lt;int&gt; si = getOutEdges(ni, gc);
<a name="l00720"></a>00720         <span class="keywordflow">if</span> (si.size() != 0)
<a name="l00721"></a>00721         {
<a name="l00722"></a>00722             evaluatePaths(gc, ni<span class="comment">/*, endnodec*/</span>);
<a name="l00723"></a>00723         }
<a name="l00724"></a>00724     }
<a name="l00725"></a>00725     <span class="comment">//}</span>
<a name="l00726"></a>00726     t4 = <a class="code" href="graphProcessing_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l00727"></a>00727 
<a name="l00728"></a>00728     t7 = <a class="code" href="graphProcessing_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l00729"></a>00729     <span class="comment">//evaluatePathsPar(g, n, endnode);</span>
<a name="l00730"></a>00730     t8 = <a class="code" href="graphProcessing_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l00731"></a>00731     std::cout &lt;&lt; <span class="stringliteral">&quot;loops found: &quot;</span> &lt;&lt; collected_loops.size() &lt;&lt; std::endl;
<a name="l00732"></a>00732     std::cout &lt;&lt; <span class="stringliteral">&quot;evaluatePaths done &quot;</span> &lt;&lt; std::endl;
<a name="l00733"></a>00733     std::cout &lt;&lt; <span class="stringliteral">&quot;pnum: &quot;</span> &lt;&lt; pnum &lt;&lt; std::endl;
<a name="l00734"></a>00734     <span class="keywordtype">double</span> diff2 = <a class="code" href="graphProcessing_8h.html#ae0e3d51bc94bbc9201f1125a8407492f">timeDifference</a>(t4, t3);
<a name="l00735"></a>00735     <span class="keywordtype">double</span> diff2Par = <a class="code" href="graphProcessing_8h.html#ae0e3d51bc94bbc9201f1125a8407492f">timeDifference</a>(t8, t7);
<a name="l00736"></a>00736     std::cout &lt;&lt; <span class="stringliteral">&quot;pathsolve took: &quot;</span> &lt;&lt; diff &lt;&lt; std::endl;
<a name="l00737"></a>00737     std::cout &lt;&lt; <span class="stringliteral">&quot;patheval took: &quot;</span> &lt;&lt; diff2 &lt;&lt; std::endl;
<a name="l00738"></a>00738     std::cout &lt;&lt; <span class="stringliteral">&quot;parpatheval took: &quot;</span> &lt;&lt; diff2Par &lt;&lt; std::endl;
<a name="l00739"></a>00739     std::cout &lt;&lt; <span class="stringliteral">&quot;grapheval took: &quot;</span> &lt;&lt; diff3 &lt;&lt; std::endl;
<a name="l00740"></a>00740     std::cout &lt;&lt; <span class="stringliteral">&quot;entire pathsolve took: &quot;</span> &lt;&lt; diff+diff2+diff3+diff2Par &lt;&lt; std::endl;
<a name="l00741"></a>00741     std::cout &lt;&lt; <span class="stringliteral">&quot;potential loops: &quot;</span> &lt;&lt; nullEdgesOrdered.size() &lt;&lt; std::endl;
<a name="l00742"></a>00742     std::cout &lt;&lt; <span class="stringliteral">&quot;nullNum: &quot;</span> &lt;&lt; nullNum &lt;&lt; std::endl;
<a name="l00743"></a>00743     <span class="comment">//std::cout &lt;&lt; &quot;goodsets: &quot; &lt;&lt; goodset.size() &lt;&lt; std::endl;</span>
<a name="l00744"></a>00744     <span class="comment">//std::cout &lt;&lt; &quot;flpsets: &quot; &lt;&lt; flpset.size() &lt;&lt; std::endl;</span>
<a name="l00745"></a>00745     std::cout &lt;&lt; <span class="stringliteral">&quot;mkloops: &quot;</span> &lt;&lt; mkloops.size() &lt;&lt; std::endl;
<a name="l00746"></a>00746     <span class="keywordflow">for</span> (std::set&lt;int&gt;::iterator i = mkloops.begin(); i != mkloops.end(); i++)
<a name="l00747"></a>00747     {
<a name="l00748"></a>00748         std::cout &lt;&lt; *i &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;
<a name="l00749"></a>00749     }
<a name="l00750"></a>00750     std::cout &lt;&lt; std::endl;
<a name="l00751"></a>00751     <span class="keywordtype">int</span> lnum = 1;
<a name="l00752"></a>00752     <span class="keywordflow">for</span> (std::set&lt;std::vector&lt;int&gt; &gt;::iterator i = collected_loops.begin(); i != collected_loops.end(); i++) {
<a name="l00753"></a>00753         std::cout &lt;&lt; <span class="stringliteral">&quot;loop num: &quot;</span> &lt;&lt; lnum &lt;&lt; std::endl;
<a name="l00754"></a>00754         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; (*i).size(); j++) {
<a name="l00755"></a>00755             std::cout &lt;&lt; (*i)[j] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;
<a name="l00756"></a>00756         }
<a name="l00757"></a>00757         lnum++;
<a name="l00758"></a>00758     }
<a name="l00759"></a>00759 
<a name="l00760"></a>00760     std::cout &lt;&lt; <span class="stringliteral">&quot;distime: &quot;</span> &lt;&lt; distime &lt;&lt; std::endl;
<a name="l00761"></a>00761     std::cout &lt;&lt; <span class="stringliteral">&quot;fllp: &quot;</span> &lt;&lt; fllp &lt;&lt; std::endl;
<a name="l00762"></a>00762     std::cout &lt;&lt; <span class="stringliteral">&quot;/*************************************************&quot;</span> &lt;&lt; std::endl;
<a name="l00763"></a>00763     std::cout &lt;&lt; <span class="stringliteral">&quot;pathsAtMk: &quot;</span> &lt;&lt; std::endl;
<a name="l00764"></a>00764     <span class="keywordflow">for</span> (std::set&lt;int&gt;::iterator i = mks.begin(); i != mks.end(); i++)
<a name="l00765"></a>00765     {
<a name="l00766"></a>00766 
<a name="l00767"></a>00767         <span class="keywordflow">if</span> (pathsAtMk.find(*i) != pathsAtMk.end())
<a name="l00768"></a>00768         {
<a name="l00769"></a>00769             std::cout &lt;&lt; <span class="stringliteral">&quot;at: &quot;</span> &lt;&lt; *i &lt;&lt; std::endl;
<a name="l00770"></a>00770             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; pathsAtMk[*i].size(); j++)
<a name="l00771"></a>00771             {
<a name="l00772"></a>00772                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; pathsAtMk[*i][j].size(); k++)
<a name="l00773"></a>00773                 {
<a name="l00774"></a>00774                     std::cout &lt;&lt; pathsAtMk[*i][j][k] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;
<a name="l00775"></a>00775                 }
<a name="l00776"></a>00776                 std::cout &lt;&lt; std::endl;
<a name="l00777"></a>00777             }
<a name="l00778"></a>00778             std::cout &lt;&lt; std::endl;
<a name="l00779"></a>00779         }
<a name="l00780"></a>00780         std::cout &lt;&lt; std::endl;
<a name="l00781"></a>00781     }
<a name="l00782"></a>00782 
<a name="l00783"></a>00783 
<a name="l00784"></a>00784     <span class="keywordflow">return</span> pthgraphinherit;
<a name="l00785"></a>00785     <span class="comment">//}</span>
<a name="l00786"></a>00786     <span class="comment">//std::cout &lt;&lt; &quot;number of endnodefakes: &quot; &lt;&lt; endnodefakes.size() &lt;&lt; std::endl;</span>
<a name="l00787"></a>00787     <span class="comment">//std::cout &lt;&lt; &quot;should be number of nodes: &quot; &lt;&lt; currprime &lt;&lt; std::endl;</span>
<a name="l00788"></a>00788     <span class="comment">//if (pathanalysis == true) {</span>
<a name="l00789"></a>00789     <span class="comment">// analyzepaths(endnode, g);</span>
<a name="l00790"></a>00790     <span class="comment">//}</span>
<a name="l00791"></a>00791     <span class="comment">//return inh;</span>
<a name="l00792"></a>00792     <span class="comment">//Currently this is not very useful, but it does nothing if traversalResult is not set.</span>
<a name="l00793"></a>00793 }
<a name="l00794"></a>00794 
<a name="l00795"></a>00795 <span class="comment">/* WARNING:</span>
<a name="l00796"></a>00796 <span class="comment">   This is not a general is_disjoint. It skips the</span>
<a name="l00797"></a>00797 <span class="comment">first element of the second set because in the way I assemble</span>
<a name="l00798"></a>00798 <span class="comment">paths the last element of the path and the first element of addend</span>
<a name="l00799"></a>00799 <span class="comment">must be the same. Hence I simply skip the first node</span>
<a name="l00800"></a>00800 <span class="comment">*/</span>
<a name="l00801"></a>00801 <span class="comment">/*</span>
<a name="l00802"></a>00802 <span class="comment">bool is_disjoint(std::set&lt;int&gt; set1, std::set&lt;int&gt; set2) {</span>
<a name="l00803"></a>00803 <span class="comment"></span>
<a name="l00804"></a>00804 <span class="comment">   if (set1.empty() || set2.empty()) {</span>
<a name="l00805"></a>00805 <span class="comment">       return true;</span>
<a name="l00806"></a>00806 <span class="comment">   }</span>
<a name="l00807"></a>00807 <span class="comment">   std::set&lt;int&gt;::iterator it1 = set1.begin();</span>
<a name="l00808"></a>00808 <span class="comment">   std::set&lt;int&gt;::iterator it2 = set2.begin();</span>
<a name="l00809"></a>00809 <span class="comment">   std::set&lt;int&gt;::iterator it1End = set1.end();</span>
<a name="l00810"></a>00810 <span class="comment">   std::set&lt;int&gt;::iterator it2End = set2.end();</span>
<a name="l00811"></a>00811 <span class="comment"></span>
<a name="l00812"></a>00812 <span class="comment">    if (*it1 &gt; *set2.rbegin() || *it2 &gt; *set1.rbegin()) {</span>
<a name="l00813"></a>00813 <span class="comment">        return true;</span>
<a name="l00814"></a>00814 <span class="comment">    }</span>
<a name="l00815"></a>00815 <span class="comment"></span>
<a name="l00816"></a>00816 <span class="comment">    while (it1 != it1End &amp;&amp; it2 != it2End) {</span>
<a name="l00817"></a>00817 <span class="comment">        if (*it1 == *it2) {</span>
<a name="l00818"></a>00818 <span class="comment">            return false;</span>
<a name="l00819"></a>00819 <span class="comment">        }</span>
<a name="l00820"></a>00820 <span class="comment">        if (*it1 &lt; *it2) {</span>
<a name="l00821"></a>00821 <span class="comment">            it1++;</span>
<a name="l00822"></a>00822 <span class="comment">        }</span>
<a name="l00823"></a>00823 <span class="comment">        else {</span>
<a name="l00824"></a>00824 <span class="comment">            it2++;</span>
<a name="l00825"></a>00825 <span class="comment">        }</span>
<a name="l00826"></a>00826 <span class="comment">     }</span>
<a name="l00827"></a>00827 <span class="comment">     return true;</span>
<a name="l00828"></a>00828 <span class="comment">}</span>
<a name="l00829"></a>00829 <span class="comment">*/</span>
<a name="l00830"></a>00830 
<a name="l00831"></a>00831 
<a name="l00832"></a>00832 
<a name="l00848"></a>00848 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l00849"></a>00849 <span class="keywordtype">bool</span>
<a name="l00850"></a>00850 <a class="code" href="classSgGraphTraversal.html#a93b3e1973bdd6755a6de10da79f92e26" title="::canSolve">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l00851"></a><a class="code" href="classSgGraphTraversal.html#a93b3e1973bdd6755a6de10da79f92e26">00851</a> <a class="code" href="classSgGraphTraversal.html#a93b3e1973bdd6755a6de10da79f92e26" title="::canSolve">canSolve</a>(<span class="keyword">const</span> CFG* &amp;g, <span class="keyword">const</span>  <span class="keywordtype">int</span> &amp;n)
<a name="l00852"></a>00852 {
<a name="l00853"></a>00853     <span class="keywordtype">bool</span> loop = <span class="keyword">false</span>;
<a name="l00854"></a>00854     <span class="keywordflow">if</span> (inhVals.find(n) != inhVals.end())
<a name="l00855"></a>00855     {
<a name="l00856"></a>00856         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00857"></a>00857     }
<a name="l00858"></a>00858     <span class="comment">//std::pair&lt;CFG::CFGEdgePtr, CFG::CFGEdgePtr&gt; oed = boost::in_edges(*n, *g);</span>
<a name="l00859"></a>00859     <span class="comment">//if (oed.first == oed.second) {</span>
<a name="l00860"></a>00860     <span class="comment">//    return false;</span>
<a name="l00861"></a>00861     <span class="comment">// }</span>
<a name="l00862"></a>00862     <span class="comment">//in_edge_iterator i, j;</span>
<a name="l00863"></a>00863     std::vector&lt;int&gt; inds = getInNodes(n, g);
<a name="l00864"></a>00864     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; inds.size(); i++)
<a name="l00865"></a>00865     {
<a name="l00866"></a>00866         <span class="comment">//CFG* gra = *g;</span>
<a name="l00867"></a>00867         <span class="comment">//Edge* ed = *i;</span>
<a name="l00868"></a>00868         <span class="comment">//Edge* edF = &amp;(*gra[ed]);</span>
<a name="l00869"></a>00869         <span class="keywordflow">if</span> (inhVals.find(inds[i]) == inhVals.end() &amp;&amp; nullEdges.find(inds[i]) == nullEdges.end())
<a name="l00870"></a>00870         {
<a name="l00871"></a>00871             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00872"></a>00872         }
<a name="l00873"></a>00873     }
<a name="l00874"></a>00874     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00875"></a>00875 }
<a name="l00876"></a>00876 
<a name="l00877"></a>00877 
<a name="l00891"></a>00891 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l00892"></a>00892 <span class="keywordtype">void</span>
<a name="l00893"></a>00893 <a class="code" href="classSgGraphTraversal.html#a4e0b975fa0d59c80d4d1422b56c4c486" title="runs the users evaluation function on all paths, thus is responsible for getting the paths to the use...">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l00894"></a><a class="code" href="classSgGraphTraversal.html#a4e0b975fa0d59c80d4d1422b56c4c486">00894</a> <a class="code" href="classSgGraphTraversal.html#a4e0b975fa0d59c80d4d1422b56c4c486" title="runs the users evaluation function on all paths, thus is responsible for getting the paths to the use...">evaluatePaths</a>(<span class="keyword">const</span> CFG* &amp;g, <span class="keywordtype">int</span> n<span class="comment">/*, const  int &amp;endn*/</span>)
<a name="l00895"></a>00895 {
<a name="l00896"></a>00896 <span class="comment">//std::set&lt;int&gt; seen;</span>
<a name="l00897"></a>00897 <span class="comment">//for (std::map&lt;int, std::vector&lt;std::vector&lt;int&gt; &gt; &gt;::iterator i = pathsAtMk.begin(); i != pathsAtMk.end(); i++) {</span>
<a name="l00898"></a>00898     <span class="comment">/*</span>
<a name="l00899"></a>00899 <span class="comment">        std::vector&lt;std::vector&lt;int&gt; &gt; tocheck = (*i).second;</span>
<a name="l00900"></a>00900 <span class="comment">        for (int j = 0; j &lt; tocheck.size(); j++) {</span>
<a name="l00901"></a>00901 <span class="comment">            for (int k = 0; k &lt; tocheck[j].size(); k++) {</span>
<a name="l00902"></a>00902 <span class="comment">                if (seen.find(tocheck[j][k]) != seen.end()) {</span>
<a name="l00903"></a>00903 <span class="comment">                    ploops.insert(tocheck[j][k]);</span>
<a name="l00904"></a>00904 <span class="comment">                }</span>
<a name="l00905"></a>00905 <span class="comment">                else {</span>
<a name="l00906"></a>00906 <span class="comment">                    seen.insert(tocheck[j][k]);</span>
<a name="l00907"></a>00907 <span class="comment">                }</span>
<a name="l00908"></a>00908 <span class="comment">            }</span>
<a name="l00909"></a>00909 <span class="comment">        }</span>
<a name="l00910"></a>00910 <span class="comment">    }</span>
<a name="l00911"></a>00911 <span class="comment">    */</span>
<a name="l00912"></a>00912 
<a name="l00913"></a>00913 <span class="comment">//currents.clear();</span>
<a name="l00914"></a>00914     <span class="comment">//std::set&lt;std::vector&lt;int&gt; &gt; collected_loops;</span>
<a name="l00915"></a>00915     std::vector&lt;std::vector&lt;int&gt; &gt; path;
<a name="l00916"></a>00916     std::vector&lt;int&gt; spath;
<a name="l00917"></a>00917 <span class="comment">//int n = realstartnode;</span>
<a name="l00918"></a>00918 <span class="comment">//int endn = endnode;</span>
<a name="l00919"></a>00919     <span class="keywordtype">int</span> successes = 0;
<a name="l00920"></a>00920     <span class="keywordtype">int</span> failures = 0;
<a name="l00921"></a>00921     <span class="keywordtype">int</span> j = 0;
<a name="l00922"></a>00922     std::vector&lt;int&gt; currpth;
<a name="l00923"></a>00923     <span class="keywordtype">int</span> currint = 0;
<a name="l00924"></a>00924     std::map&lt;int, int&gt; intPath;
<a name="l00925"></a>00925 <span class="comment">//intPath[n] = currint;</span>
<a name="l00926"></a>00926     currint++;
<a name="l00927"></a>00927     std::map&lt;int, int&gt; currents;
<a name="l00928"></a>00928     currents.clear();
<a name="l00929"></a>00929     <span class="keywordtype">int</span> currnode;
<a name="l00930"></a>00930     <span class="keywordtype">bool</span> step = <span class="keyword">false</span>;
<a name="l00931"></a>00931     <span class="keywordtype">bool</span> midstep = <span class="keyword">false</span>;
<a name="l00932"></a>00932 <span class="comment">//int pnum = 0;</span>
<a name="l00933"></a>00933 <span class="comment">//note: pathsAtMk is referring to subpaths connected to that marker, a marker is a split in the graph (usually an if statement)</span>
<a name="l00934"></a>00934     <span class="keywordflow">if</span> (pathsAtMk[n].size() == 0)
<a name="l00935"></a>00935     {
<a name="l00936"></a>00936         <span class="keywordflow">return</span>;
<a name="l00937"></a>00937     }
<a name="l00938"></a>00938     std::vector&lt;std::vector&lt;int&gt; &gt; pth = pathsAtMk[n];
<a name="l00939"></a>00939     std::vector&lt;std::vector&lt;int&gt; &gt; cpth = pathsAtMk[n];
<a name="l00940"></a>00940     path.clear();
<a name="l00941"></a>00941     <span class="keywordtype">int</span> disjoints = 0;
<a name="l00942"></a>00942     <span class="keywordtype">int</span> disjointtrues = 0;
<a name="l00943"></a>00943     currpth = pth[0];
<a name="l00944"></a>00944     intPath[pth[0].front()] = currint;
<a name="l00945"></a>00945     std::set&lt;int&gt; pthloopstmp;
<a name="l00946"></a>00946     <span class="keywordtype">int</span> fakenode;
<a name="l00947"></a>00947     pthloopstmp.insert(fakenode);
<a name="l00948"></a>00948     std::vector&lt;std::set&lt;int&gt; &gt; pthloops;
<a name="l00949"></a>00949     pthloops.push_back(pthloopstmp);
<a name="l00950"></a>00950     pthloopstmp.clear();
<a name="l00951"></a>00951     currint++;
<a name="l00952"></a>00952 
<a name="l00953"></a>00953     <span class="keywordtype">int</span> stepnum = 0;
<a name="l00954"></a>00954     std::vector&lt;int&gt; rs;
<a name="l00955"></a>00955     rs.push_back(n);
<a name="l00956"></a>00956     path.push_back(rs);
<a name="l00957"></a>00957     <span class="comment">//currflat.push_back(realstartnode);</span>
<a name="l00958"></a>00958     currents.clear();
<a name="l00959"></a>00959 
<a name="l00960"></a>00960     step = <span class="keyword">false</span>;
<a name="l00961"></a>00961     <span class="comment">//std::vector&lt;int&gt; currflat;</span>
<a name="l00962"></a>00962     std::vector&lt;int&gt; sub;
<a name="l00963"></a>00963 
<a name="l00964"></a>00964     <span class="comment">/*</span>
<a name="l00965"></a>00965 <span class="comment">        std::ofstream mz;</span>
<a name="l00966"></a>00966 <span class="comment">        mz.open(&quot;pathanalysis.dot&quot;);</span>
<a name="l00967"></a>00967 <span class="comment">        mz &lt;&lt; &quot;digraph defaultName { \n&quot;;</span>
<a name="l00968"></a>00968 <span class="comment">    */</span>
<a name="l00969"></a>00969     <span class="comment">//std::set&lt;std::vector&lt;int&gt; &gt; nullIncLoops;</span>
<a name="l00970"></a>00970 
<a name="l00971"></a>00971 <span class="comment">/*</span>
<a name="l00972"></a>00972 <span class="comment">    for (unsigned int p = 0; p &lt; looppaths.size(); p++)</span>
<a name="l00973"></a>00973 <span class="comment">    {</span>
<a name="l00974"></a>00974 <span class="comment">        std::vector&lt;int&gt; lp = looppaths[p];</span>
<a name="l00975"></a>00975 <span class="comment"></span>
<a name="l00976"></a>00976 <span class="comment">        for (unsigned int i = 0; i &lt; lp.size()-1; i++)</span>
<a name="l00977"></a>00977 <span class="comment">        {</span>
<a name="l00978"></a>00978 <span class="comment">            for (unsigned int l = i+1; l &lt; lp.size(); l++)</span>
<a name="l00979"></a>00979 <span class="comment">            {</span>
<a name="l00980"></a>00980 <span class="comment">                if (lp[i] == lp[l]/* &amp;&amp; lp[i] != n &amp;&amp; lp[i] != endn*/</span><span class="comment">//)</span>
<a name="l00981"></a>00981 <span class="comment">/*</span>
<a name="l00982"></a>00982 <span class="comment">                {</span>
<a name="l00983"></a>00983 <span class="comment">                    std::vector&lt;int&gt; interiorloop;</span>
<a name="l00984"></a>00984 <span class="comment">                    //std::vector&lt;Vertex&gt; interiorloopToSolve;</span>
<a name="l00985"></a>00985 <span class="comment">                    interiorloop.clear();</span>
<a name="l00986"></a>00986 <span class="comment">                    //interiorloopToSolve.clear();</span>
<a name="l00987"></a>00987 <span class="comment">                    for (unsigned int j = i; j &lt; l+1; j++)</span>
<a name="l00988"></a>00988 <span class="comment">                    {</span>
<a name="l00989"></a>00989 <span class="comment">                        //interiorloopToSolve.push_back(vertintmap[lp[j]]);</span>
<a name="l00990"></a>00990 <span class="comment">                        interiorloop.push_back(lp[j]);</span>
<a name="l00991"></a>00991 <span class="comment">                    }</span>
<a name="l00992"></a>00992 <span class="comment">                    if (interiorloop.size() &gt; 2 /*&amp;&amp; interiorloop.back() != endn*/</span><span class="comment">//)</span>
<a name="l00993"></a>00993 <span class="comment">/*</span>
<a name="l00994"></a>00994 <span class="comment">                    {</span>
<a name="l00995"></a>00995 <span class="comment">                        if (find(iLoops.begin(), iLoops.end(), interiorloop) == iLoops.end())</span>
<a name="l00996"></a>00996 <span class="comment">                        {</span>
<a name="l00997"></a>00997 <span class="comment">                            if (find(looppaths.begin(), looppaths.end(), interiorloop) == looppaths.end())</span>
<a name="l00998"></a>00998 <span class="comment">                            {</span>
<a name="l00999"></a>00999 <span class="comment">                                iLoops.push_back(interiorloop);</span>
<a name="l01000"></a>01000 <span class="comment">                                loopnum++;</span>
<a name="l01001"></a>01001 <span class="comment">                                for (unsigned int k = 0; k &lt; interiorloop.size(); k++)</span>
<a name="l01002"></a>01002 <span class="comment">                                {</span>
<a name="l01003"></a>01003 <span class="comment">                                    loopNumMap[interiorloop[k]] = loopnum;</span>
<a name="l01004"></a>01004 <span class="comment">                                }</span>
<a name="l01005"></a>01005 <span class="comment">                                lpbegins[interiorloop.front()].insert(interiorloop);</span>
<a name="l01006"></a>01006 <span class="comment">                                pathAnalyze(interiorloop, true, nullIncLoops);</span>
<a name="l01007"></a>01007 <span class="comment"></span>
<a name="l01008"></a>01008 <span class="comment">                            }</span>
<a name="l01009"></a>01009 <span class="comment">                        }</span>
<a name="l01010"></a>01010 <span class="comment">                    }</span>
<a name="l01011"></a>01011 <span class="comment">                }</span>
<a name="l01012"></a>01012 <span class="comment">            }</span>
<a name="l01013"></a>01013 <span class="comment">        }</span>
<a name="l01014"></a>01014 <span class="comment">        std::vector&lt;int&gt; lpt;</span>
<a name="l01015"></a>01015 <span class="comment">        if (lp.size() &gt; 2)</span>
<a name="l01016"></a>01016 <span class="comment">        {</span>
<a name="l01017"></a>01017 <span class="comment">            lpbegins[lp.front()].insert(lp);</span>
<a name="l01018"></a>01018 <span class="comment">            //for (int i = 0; i &lt; lp.size(); i++) {</span>
<a name="l01019"></a>01019 <span class="comment">            //    lpt.push_back(vertintmap[lp[i]]);</span>
<a name="l01020"></a>01020 <span class="comment">            //}</span>
<a name="l01021"></a>01021 <span class="comment">            pathAnalyze(lp, true, nullIncLoops);</span>
<a name="l01022"></a>01022 <span class="comment">            //for (unsigned int i = 1; i &lt; lp.size(); i++) {</span>
<a name="l01023"></a>01023 <span class="comment">            //    printNodePlusEdgesForAnalysisPath(g, lp, p, p, mz);</span>
<a name="l01024"></a>01024 <span class="comment">            //}</span>
<a name="l01025"></a>01025 <span class="comment">        }</span>
<a name="l01026"></a>01026 <span class="comment">    }</span>
<a name="l01027"></a>01027 <span class="comment">*/</span>
<a name="l01028"></a>01028 
<a name="l01029"></a>01029     <span class="keywordflow">while</span> (step == <span class="keyword">false</span>)
<a name="l01030"></a>01030     {
<a name="l01031"></a>01031         stepnum++;
<a name="l01032"></a>01032         <span class="comment">//std::cout &lt;&lt; &quot;currpth: &quot; &lt;&lt; std::endl;</span>
<a name="l01033"></a>01033         <span class="comment">//for (int i = 0; i &lt; currpth.size(); i++)</span>
<a name="l01034"></a>01034        <span class="comment">// {</span>
<a name="l01035"></a>01035        <span class="comment">//     std::cout &lt;&lt; currpth[i] &lt;&lt; &quot;, &quot;;</span>
<a name="l01036"></a>01036        <span class="comment">// }</span>
<a name="l01037"></a>01037         <span class="comment">//std::cout &lt;&lt; std::endl;</span>
<a name="l01038"></a>01038        <span class="comment">// std::cout &lt;&lt; &quot;stepnum: &quot; &lt;&lt; stepnum &lt;&lt; std::endl;</span>
<a name="l01039"></a>01039 
<a name="l01040"></a>01040         std::vector&lt;int&gt; onds = getOutEdges(currpth.back(), g);
<a name="l01041"></a>01041         <span class="keywordflow">if</span> (onds.size() == 0)
<a name="l01042"></a>01042         {
<a name="l01043"></a>01043             path.push_back(currpth);
<a name="l01044"></a>01044             <span class="comment">//for (int i = 0; i &lt; currpth.size(); i++) {</span>
<a name="l01045"></a>01045             <span class="comment">//    currflat.push_back(currpth[i]);</span>
<a name="l01046"></a>01046             <span class="comment">//}</span>
<a name="l01047"></a>01047             std::vector&lt;int&gt; flatpath;
<a name="l01048"></a>01048             <span class="comment">//std::vector&lt;int&gt; sub;</span>
<a name="l01049"></a>01049             std::set&lt;std::vector&lt;int&gt; &gt; incloops;
<a name="l01050"></a>01050             <span class="comment">//std::set&lt;std::vector&lt;Vertex&gt; &gt; incloopsToSolve;</span>
<a name="l01051"></a>01051             <span class="keyword">struct </span>timeval q1, q2;
<a name="l01052"></a>01052             <span class="comment">//std::cout &lt;&lt; &quot;path.size(): &quot; &lt;&lt; path.size() &lt;&lt; std::endl;</span>
<a name="l01053"></a>01053             <span class="comment">//std::cout &lt;&lt; &quot;pthloops.size(): &quot; &lt;&lt; pthloops.size() &lt;&lt; std::endl;</span>
<a name="l01054"></a>01054             ROSE_ASSERT(path.size() == pthloops.size() + 1);
<a name="l01055"></a>01055             q1 = <a class="code" href="graphProcessing_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l01056"></a>01056 
<a name="l01057"></a>01057             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; pthloops.size(); q++)
<a name="l01058"></a>01058             {
<a name="l01059"></a>01059                 <span class="comment">//sub = path[q];</span>
<a name="l01060"></a>01060                 <span class="comment">//sub.pop_back();</span>
<a name="l01061"></a>01061                 <span class="comment">//for (unsigned int r = 0; r &lt; path[q].size(); r++) {</span>
<a name="l01062"></a>01062                 flatpath.insert(flatpath.end(), path[q].begin(), path[q].end());
<a name="l01063"></a>01063                 <span class="comment">//flatpath.push_back(intvertmap[path[q][r]]);</span>
<a name="l01064"></a>01064                 <span class="comment">//}</span>
<a name="l01065"></a>01065                 <span class="keywordflow">for</span> (std::set&lt;int&gt;::iterator p = pthloops[q].begin(); p != pthloops[q].end(); p++)
<a name="l01066"></a>01066                 {
<a name="l01067"></a>01067                     <span class="keywordflow">for</span> (std::set&lt;std::vector&lt;int&gt; &gt;::iterator o = mkloopmap[*p].begin(); o != mkloopmap[*p].end(); o++)
<a name="l01068"></a>01068                     {
<a name="l01069"></a>01069                         incloops.insert(*o);
<a name="l01070"></a>01070                         std::vector&lt;Vertex&gt; incpre;
<a name="l01071"></a>01071                         <span class="comment">//for (int ni = 0; ni &lt; (*o).size(); ni++) {</span>
<a name="l01072"></a>01072                         <span class="comment">//    incpre.push_back(intvertmap[(*o)[ni]]);</span>
<a name="l01073"></a>01073                         <span class="comment">// }</span>
<a name="l01074"></a>01074                         <span class="comment">//incloopsToSolve.insert(incpre);</span>
<a name="l01075"></a>01075                     }
<a name="l01076"></a>01076                 }
<a name="l01077"></a>01077             }
<a name="l01078"></a>01078             <span class="comment">/*</span>
<a name="l01079"></a>01079 <span class="comment">                         for (int pt2 = 0; pt2 &lt; path.size(); pt2++) {</span>
<a name="l01080"></a>01080 <span class="comment">                             for (int pt3 = 0; pt3 &lt; path[pt2].size(); pt3++) {</span>
<a name="l01081"></a>01081 <span class="comment">                                 flatpath.push_back(intvertmap[path[pt2][pt3]])</span>
<a name="l01082"></a>01082 <span class="comment">                             }</span>
<a name="l01083"></a>01083 <span class="comment">                         }</span>
<a name="l01084"></a>01084 <span class="comment">            */</span>
<a name="l01085"></a>01085 
<a name="l01086"></a>01086             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pt2 = 0; pt2 &lt; path[path.size()-1].size(); pt2++)
<a name="l01087"></a>01087             {
<a name="l01088"></a>01088                 flatpath.push_back(path[path.size()-1][pt2]);
<a name="l01089"></a>01089             }
<a name="l01090"></a>01090 
<a name="l01091"></a>01091 
<a name="l01092"></a>01092             q2 = <a class="code" href="graphProcessing_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l01093"></a>01093             fllp += <a class="code" href="graphProcessing_8h.html#ae0e3d51bc94bbc9201f1125a8407492f">timeDifference</a>(q2,q1);
<a name="l01094"></a>01094             <span class="comment">//std::cout &lt;&lt; &quot;sent path: &quot;;</span>
<a name="l01095"></a>01095             <span class="comment">//std::vector&lt;int&gt; senpath;</span>
<a name="l01096"></a>01096             <span class="comment">//for (int i = 0; i &lt; flatpath.size(); i++) {</span>
<a name="l01097"></a>01097             <span class="comment">//    std::cout &lt;&lt; &quot;, &quot; &lt;&lt; vertintmap[flatpath[i]];</span>
<a name="l01098"></a>01098             <span class="comment">//    senpath.push_back(vertintmap[flatpath[i]]);</span>
<a name="l01099"></a>01099             <span class="comment">//}</span>
<a name="l01100"></a>01100             <span class="comment">//ROSE_ASSERT(find(senpaths.begin(), senpaths.end(), senpath) == senpaths.end());</span>
<a name="l01101"></a>01101             <span class="comment">//senpaths.push_back(senpath);</span>
<a name="l01102"></a>01102             <span class="comment">//std::cout &lt;&lt; &quot;\n path num: &quot; &lt;&lt; pathnum &lt;&lt; std::endl;</span>
<a name="l01103"></a>01103             <span class="comment">//pathnum++;</span>
<a name="l01104"></a>01104             flatpath.push_back(currpth.back());
<a name="l01105"></a>01105 
<a name="l01106"></a>01106 <span class="comment">/*            for (unsigned int ps = 0; ps &lt; flatpath.size(); ps++)</span>
<a name="l01107"></a>01107 <span class="comment">            {</span>
<a name="l01108"></a>01108 <span class="comment">                if (lpbegins.find(flatpath[ps]) != lpbegins.end())</span>
<a name="l01109"></a>01109 <span class="comment">                {</span>
<a name="l01110"></a>01110 <span class="comment">                    for (std::set&lt;std::vector&lt;int&gt; &gt;::iterator sv = lpbegins[flatpath[ps]].begin(); sv != lpbegins[flatpath[ps]].end(); sv++)</span>
<a name="l01111"></a>01111 <span class="comment">                    {</span>
<a name="l01112"></a>01112 <span class="comment">                        incloops.insert(*sv);</span>
<a name="l01113"></a>01113 <span class="comment">                    }</span>
<a name="l01114"></a>01114 <span class="comment">                }</span>
<a name="l01115"></a>01115 <span class="comment">            }</span>
<a name="l01116"></a>01116 <span class="comment">*/</span>
<a name="l01117"></a>01117 <span class="comment">//user defined function, run on the final path, gives the user loops that are included via &quot;incloops&quot; a set of vectors that contain the individual loops</span>
<a name="l01118"></a>01118             <span class="comment">//std::cout &lt;&lt; &quot;analyzing pth: &quot; &lt;&lt; pnum &lt;&lt; std::endl;</span>
<a name="l01119"></a>01119             pathAnalyze(flatpath, <span class="keyword">false</span>, incloops);
<a name="l01120"></a>01120             <span class="keywordflow">if</span> (pnum % 1000 == 0) {
<a name="l01121"></a>01121             std::cout &lt;&lt; <span class="stringliteral">&quot;pth: &quot;</span> &lt;&lt; pnum &lt;&lt; std::endl;
<a name="l01122"></a>01122             <span class="comment">//for (int qe = 0; qe &lt; flatpath.size(); qe++)</span>
<a name="l01123"></a>01123            <span class="comment">// {</span>
<a name="l01124"></a>01124            <span class="comment">//     std::cout &lt;&lt; flatpath[qe] &lt;&lt; &quot;, &quot;;</span>
<a name="l01125"></a>01125             <span class="comment">//}</span>
<a name="l01126"></a>01126             <span class="comment">//std::cout &lt;&lt; std::endl;</span>
<a name="l01127"></a>01127             std::cout &lt;&lt; <span class="stringliteral">&quot;completed analysis&quot;</span> &lt;&lt; std::endl;
<a name="l01128"></a>01128             }
<a name="l01129"></a>01129             pnum++;
<a name="l01130"></a>01130             incloops.clear();
<a name="l01131"></a>01131             <span class="comment">//printNodePlusEdgesForAnalysisPath(g, flatpath, -1, -1, mz);</span>
<a name="l01132"></a>01132 
<a name="l01133"></a>01133             <span class="keywordtype">int</span> pts = pathsSize++;
<a name="l01134"></a>01134             pathsSize += 1;
<a name="l01135"></a>01135 
<a name="l01136"></a>01136             flatpath.clear();
<a name="l01137"></a>01137             path.pop_back();
<a name="l01138"></a>01138             <span class="keywordtype">int</span> rounds = 0;
<a name="l01139"></a>01139             <span class="keywordtype">bool</span> starter = <span class="keyword">false</span>;
<a name="l01140"></a>01140 
<a name="l01141"></a>01141 <span class="comment">// This gets a bit complicated so here is an overview:</span>
<a name="l01142"></a>01142 <span class="comment">// This is running down the graph and finding the endnode. Once it finds the endnode it goes back up to the last unevaluated subpath. It does this quickly with an integer that counts how many times that node has been used for a path. If this ends up being the number of outnodes, we don&#39;t need that node anymore, so we clear it to zero, then continue up the graph. We HAVE to reset because every time a new pathway is chosen above that node, it needs to have the ability to traverse that node.</span>
<a name="l01143"></a>01143 
<a name="l01144"></a>01144 
<a name="l01145"></a>01145             <span class="keywordflow">while</span> (<span class="keyword">true</span>)
<a name="l01146"></a>01146             {
<a name="l01147"></a>01147                 rounds++;
<a name="l01148"></a>01148                 ROSE_ASSERT(pathsAtMk.find((path.back()).back()) != pathsAtMk.end());
<a name="l01149"></a>01149                 std::vector&lt;int&gt; inEd = getInEdges(path.back().front(), g);
<a name="l01150"></a>01150                 <span class="keywordflow">if</span> (inEd.size() == 0 &amp;&amp; currents[(path.back()).back()] &gt;= (pathsAtMk[(path.back()).back()].size()))
<a name="l01151"></a>01151                 {
<a name="l01152"></a>01152                     ROSE_ASSERT(path.back().front() == n);
<a name="l01153"></a>01153                     starter = <span class="keyword">true</span>;
<a name="l01154"></a>01154                 }
<a name="l01155"></a>01155                 <span class="keywordflow">if</span> (currents[(path.back()).back()] &lt; (pathsAtMk[(path.back()).back()].size()) <span class="comment">/*|| (path.back()).front() == realstartnode*/</span>)
<a name="l01156"></a>01156                 {
<a name="l01157"></a>01157                     std::vector&lt;std::vector&lt;int&gt; &gt; cpths = pathsAtMk[(path.back()).back()];
<a name="l01158"></a>01158                     currpth = cpths[currents[(path.back()).back()]];
<a name="l01159"></a>01159                     <span class="comment">//if (currpth.back() != currpth.front()) {</span>
<a name="l01160"></a>01160                     currents[(path.back()).back()]++;
<a name="l01161"></a>01161                     <span class="comment">//}</span>
<a name="l01162"></a>01162                     <span class="keywordflow">break</span>;
<a name="l01163"></a>01163                 }
<a name="l01164"></a>01164                 <span class="keywordflow">else</span>
<a name="l01165"></a>01165                 {
<a name="l01166"></a>01166                     currents[(path.back()).back()] = 0;
<a name="l01167"></a>01167                     path.pop_back();
<a name="l01168"></a>01168                     pthloops.pop_back();
<a name="l01169"></a>01169                 }
<a name="l01170"></a>01170                 <span class="keywordflow">if</span> (starter == <span class="keyword">true</span>)
<a name="l01171"></a>01171                 {
<a name="l01172"></a>01172                     step = <span class="keyword">true</span>;
<a name="l01173"></a>01173                     <span class="keywordflow">break</span>;
<a name="l01174"></a>01174                 }
<a name="l01175"></a>01175 
<a name="l01176"></a>01176             }
<a name="l01177"></a>01177         }
<a name="l01178"></a>01178         <span class="keywordflow">else</span>
<a name="l01179"></a>01179         {
<a name="l01180"></a>01180             <span class="comment">//std::cout &lt;&lt; &quot;current subpath&quot; &lt;&lt; std::endl;</span>
<a name="l01181"></a>01181             <span class="comment">//std::vector&lt;int&gt; senpath;</span>
<a name="l01182"></a>01182             <span class="comment">//for (int i = 0; i &lt; path.size(); i++) {</span>
<a name="l01183"></a>01183             <span class="comment">//    for (int j = 0; j &lt; path[i].size(); j++)</span>
<a name="l01184"></a>01184             <span class="comment">//    std::cout &lt;&lt; &quot;, &quot; &lt;&lt; vertintmap[path[i][j]];</span>
<a name="l01185"></a>01185             <span class="comment">//senpath.push_back(vertintmap[path[i][j]]);</span>
<a name="l01186"></a>01186             <span class="comment">//}</span>
<a name="l01187"></a>01187             <span class="comment">//std::cout &lt;&lt; std::endl;</span>
<a name="l01188"></a>01188 <span class="comment">//this checks first to see if we have any loops in our path. If not it continues down, if there is it goes back to the last nonloop node</span>
<a name="l01189"></a>01189             <span class="comment">//  int disj = 0;</span>
<a name="l01190"></a>01190             ROSE_ASSERT(currpth.front() == path.back().back());
<a name="l01191"></a>01191             <span class="keywordtype">bool</span> disj = <span class="keyword">true</span>;
<a name="l01192"></a>01192             <span class="keywordtype">int</span> disjI = -1;
<a name="l01193"></a>01193             <span class="keywordtype">int</span> disjNode = -1;
<a name="l01194"></a>01194             <span class="keyword">struct </span>timeval tdisb, tdise;
<a name="l01195"></a>01195             tdisb = <a class="code" href="graphProcessing_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l01196"></a>01196             <span class="comment">//while (true) {</span>
<a name="l01197"></a>01197             
<a name="l01198"></a>01198             <span class="comment">//std::cout &lt;&lt; std::endl;</span>
<a name="l01199"></a>01199 <span class="comment">/*</span>
<a name="l01200"></a>01200 <span class="comment">            for (int i = 0; i &lt; pthloops.size(); i++)</span>
<a name="l01201"></a>01201 <span class="comment">            {</span>
<a name="l01202"></a>01202 <span class="comment">                for (std::set&lt;int&gt;::iterator j = pthloops[i].begin(); j != pthloops[i].end(); j++)</span>
<a name="l01203"></a>01203 <span class="comment">                {</span>
<a name="l01204"></a>01204 <span class="comment">                    if (find(currpth.begin()+1, currpth.end()-1, *j) != currpth.end() &amp;&amp; disj)</span>
<a name="l01205"></a>01205 <span class="comment">                    {</span>
<a name="l01206"></a>01206 <span class="comment">*/</span>
<a name="l01207"></a>01207            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; path.size(); i++) {
<a name="l01208"></a>01208                <span class="keywordflow">if</span> (disj) {
<a name="l01209"></a>01209                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; currpth.size(); j++) {
<a name="l01210"></a>01210                    <span class="keywordflow">if</span> (<a class="code" href="namespaceSageInterface.html#aff5394b21cf11cd338671af3a11a7f92">find</a>(path[i].begin(), path[i].end(), currpth[j]) != path[i].end()) {
<a name="l01211"></a>01211                        <span class="keywordflow">if</span> (currpth[j] != path.back().back()) {
<a name="l01212"></a>01212                            <span class="keywordflow">if</span> (j != 0) {
<a name="l01213"></a>01213                         <span class="comment">//disjo = *j;</span>
<a name="l01214"></a>01214                             disj = <span class="keyword">false</span>;
<a name="l01215"></a>01215                             disjI = i;
<a name="l01216"></a>01216                             disjNode = currpth[j];
<a name="l01217"></a>01217                             <span class="comment">//std::cout &lt;&lt; &quot;loop detected&quot; &lt;&lt; std::endl;</span>
<a name="l01218"></a>01218                             <span class="comment">//std::cout &lt;&lt; &quot;loop detect: &quot; &lt;&lt; loopdetectnum &lt;&lt; std::endl;</span>
<a name="l01219"></a>01219                             loopdetectnum++;
<a name="l01220"></a>01220                             }
<a name="l01221"></a>01221                        }
<a name="l01222"></a>01222                     }
<a name="l01223"></a>01223                }
<a name="l01224"></a>01224                }
<a name="l01225"></a>01225           }
<a name="l01226"></a>01226 <span class="comment">/*</span>
<a name="l01227"></a>01227 <span class="comment">            if (disj == false &amp;&amp; pathsAtMk[currpth.front()].size() &lt;= currents[currpth.front()] || disj == true) {</span>
<a name="l01228"></a>01228 <span class="comment">                break;</span>
<a name="l01229"></a>01229 <span class="comment">            }</span>
<a name="l01230"></a>01230 <span class="comment">            else {</span>
<a name="l01231"></a>01231 <span class="comment">                //std::cout &lt;&lt; &quot;disjoint&quot; &lt;&lt; std::endl;</span>
<a name="l01232"></a>01232 <span class="comment">                std::vector&lt;int&gt; ocpth = currpth;</span>
<a name="l01233"></a>01233 <span class="comment">                //std::cout &lt;&lt; &quot;currpth is: &quot; &lt;&lt; std::endl;</span>
<a name="l01234"></a>01234 <span class="comment">                for (int k = 0; k &lt; currpth.size(); k++) {</span>
<a name="l01235"></a>01235 <span class="comment">                //    std::cout &lt;&lt; currpth[k] &lt;&lt; &quot;, &quot;;</span>
<a name="l01236"></a>01236 <span class="comment">                }</span>
<a name="l01237"></a>01237 <span class="comment"></span>
<a name="l01238"></a>01238 <span class="comment">                currpth = pathsAtMk[currpth.front()][currents[currpth.front()]];</span>
<a name="l01239"></a>01239 <span class="comment">                ROSE_ASSERT(currpth != ocpth);</span>
<a name="l01240"></a>01240 <span class="comment">                currents[currpth.front()]++;</span>
<a name="l01241"></a>01241 <span class="comment">                disj = true;</span>
<a name="l01242"></a>01242 <span class="comment">            }</span>
<a name="l01243"></a>01243 <span class="comment">*/</span>
<a name="l01244"></a>01244             <span class="comment">//}</span>
<a name="l01245"></a>01245             <span class="comment">/*</span>
<a name="l01246"></a>01246 <span class="comment">                    #pragma omp parallel for num_threads(4) private(i,j)</span>
<a name="l01247"></a>01247 <span class="comment">                    for (i = 0; i &lt; pthloops.size(); i++) {</span>
<a name="l01248"></a>01248 <span class="comment">                        if (disj) {</span>
<a name="l01249"></a>01249 <span class="comment">                        for (std::set&lt;int&gt;::iterator j = pthloops[i].begin(); j != pthloops[i].end(); j++) {</span>
<a name="l01250"></a>01250 <span class="comment">                            if (find(currpth.begin(), currpth.end(), *j) != currpth.end()) {</span>
<a name="l01251"></a>01251 <span class="comment">                                disj = false;</span>
<a name="l01252"></a>01252 <span class="comment">                                //j = pthloops[i].size();</span>
<a name="l01253"></a>01253 <span class="comment">                            }</span>
<a name="l01254"></a>01254 <span class="comment">                        }</span>
<a name="l01255"></a>01255 <span class="comment">                        }</span>
<a name="l01256"></a>01256 <span class="comment"></span>
<a name="l01257"></a>01257 <span class="comment">                    }</span>
<a name="l01258"></a>01258 <span class="comment">            */</span>
<a name="l01259"></a>01259             tdise = <a class="code" href="graphProcessing_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l01260"></a>01260             distime += <a class="code" href="graphProcessing_8h.html#ae0e3d51bc94bbc9201f1125a8407492f">timeDifference</a>(tdise, tdisb);
<a name="l01261"></a>01261             <span class="keywordflow">if</span> (disj)
<a name="l01262"></a>01262             {
<a name="l01263"></a>01263                 <span class="comment">//      std::cout &lt;&lt; &quot;path: &quot; &lt;&lt; std::endl;</span>
<a name="l01264"></a>01264                 <span class="comment">//      for (int w = 0; w &lt; path.size(); w++) {</span>
<a name="l01265"></a>01265                 <span class="comment">//          for (int v = 0; v &lt; path[w].size(); v++) {</span>
<a name="l01266"></a>01266                 <span class="comment">//              std::cout &lt;&lt; path[w][v] &lt;&lt; &quot;, &quot;;</span>
<a name="l01267"></a>01267                 <span class="comment">//          }</span>
<a name="l01268"></a>01268                 <span class="comment">//       }</span>
<a name="l01269"></a>01269                 <span class="comment">//       std::cout &lt;&lt; std::endl;</span>
<a name="l01270"></a>01270 
<a name="l01271"></a>01271                 disjointtrues++;
<a name="l01272"></a>01272                 <span class="comment">//std::cout &lt;&lt; &quot;disjoints: &quot; &lt;&lt; disjointtrues &lt;&lt; std::endl;</span>
<a name="l01273"></a>01273                 midstep = <span class="keyword">false</span>;
<a name="l01274"></a>01274                 std::set&lt;int&gt; pthloopstmp;
<a name="l01275"></a>01275                 pthloopstmp.clear();
<a name="l01276"></a>01276                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; currpth.size(); i++)
<a name="l01277"></a>01277                 {
<a name="l01278"></a>01278                     <span class="comment">//currflat.push_back(currpth[i]);</span>
<a name="l01279"></a>01279                     <span class="keywordflow">if</span> (mkloops.find(currpth[i]) != mkloops.end())
<a name="l01280"></a>01280                     {
<a name="l01281"></a>01281                         pthloopstmp.insert(currpth[i]);
<a name="l01282"></a>01282                     }
<a name="l01283"></a>01283                 }
<a name="l01284"></a>01284                 pthloops.push_back(pthloopstmp);
<a name="l01285"></a>01285                 path.push_back(currpth);
<a name="l01286"></a>01286                 pthloopstmp.clear();
<a name="l01287"></a>01287 
<a name="l01288"></a>01288                 <span class="comment">//std::set&lt;std::vector&lt;int&gt; &gt; lpth;</span>
<a name="l01289"></a>01289                 std::vector&lt;int&gt; oldcurrpth = currpth;
<a name="l01290"></a>01290                 currpth.clear();
<a name="l01291"></a>01291                 <span class="keywordflow">if</span> (currents.find((path.back()).back()) == currents.end())
<a name="l01292"></a>01292                 {
<a name="l01293"></a>01293                     currents[(path.back()).back()] = 0;
<a name="l01294"></a>01294                 }
<a name="l01295"></a>01295                 <span class="keywordtype">int</span> frontnode = (path.back()).front();
<a name="l01296"></a>01296                 <span class="keywordtype">int</span> backnode = (path.back()).back();
<a name="l01297"></a>01297 
<a name="l01298"></a>01298                 <span class="comment">//ROSE_ASSERT(pathsAtMk.find(backnode) != pathsAtMk.end() || backnode == endnode);</span>
<a name="l01299"></a>01299                 <span class="comment">//ROSE_ASSERT(pathsAtMk.find(frontnode) != pathsAtMk.end());</span>
<a name="l01300"></a>01300                 <span class="comment">//if (currents.find(backnode) == currents.end()) {</span>
<a name="l01301"></a>01301                 <span class="comment">//    currents[backnode] = 0;</span>
<a name="l01302"></a>01302                 <span class="comment">// }</span>
<a name="l01303"></a>01303                 <span class="comment">//if (currents[backnode] != 0) {</span>
<a name="l01304"></a>01304                 <span class="comment">//    currents[backnode] = 0;</span>
<a name="l01305"></a>01305                 <span class="comment">// }</span>
<a name="l01306"></a>01306                 <span class="comment">//std::cout &lt;&lt; &quot;backnode: &quot; &lt;&lt; backnode &lt;&lt; std::endl;</span>
<a name="l01307"></a>01307                 std::vector&lt;std::vector&lt;int&gt; &gt; tmppths = pathsAtMk[backnode];
<a name="l01308"></a>01308 
<a name="l01309"></a>01309                 currpth = tmppths[currents[backnode]];
<a name="l01310"></a>01310                 <span class="comment">//std::cout &lt;&lt; &quot;used backnode&quot; &lt;&lt; std::endl;</span>
<a name="l01311"></a>01311                 ROSE_ASSERT(currpth != oldcurrpth);
<a name="l01312"></a>01312                 <span class="comment">//if (frontnode != backnode) {</span>
<a name="l01313"></a>01313                 currents[backnode]++;
<a name="l01314"></a>01314                 <span class="comment">//}</span>
<a name="l01315"></a>01315             }
<a name="l01316"></a>01316             <span class="keywordflow">else</span>
<a name="l01317"></a>01317             {
<a name="l01318"></a>01318                 std::vector&lt;int&gt; lpq;
<a name="l01319"></a>01319                 disjoints++;
<a name="l01320"></a>01320                 <span class="comment">//std::cout &lt;&lt; &quot;disjoint false: &quot; &lt;&lt; s &lt;&lt; std::endl;</span>
<a name="l01321"></a>01321                 ROSE_ASSERT(currpth.front() == path.back().back());
<a name="l01322"></a>01322                 <span class="comment">//path.push_back(currpth);</span>
<a name="l01323"></a>01323                 
<a name="l01324"></a>01324                 <span class="comment">//ROSE_ASSERT(path[disjI][d] == disjNode);</span>
<a name="l01325"></a>01325                 <span class="keywordtype">int</span> ps = path.size();
<a name="l01326"></a>01326                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> p1 = ps-1; p1 &gt;= disjI+1; p1--) {
<a name="l01327"></a>01327                     lpq.insert(lpq.end(), path[p1].begin(), path[p1].end());
<a name="l01328"></a>01328                     currents[path.back().back()] = 0;
<a name="l01329"></a>01329                     
<a name="l01330"></a>01330 path.pop_back();
<a name="l01331"></a>01331                     pthloops.pop_back();
<a name="l01332"></a>01332                 }
<a name="l01333"></a>01333                 <span class="comment">//std::cout &lt;&lt; &quot;lpq.size(): &quot; &lt;&lt; lpq.size() &lt;&lt; std::endl;</span>
<a name="l01334"></a>01334                 <span class="comment">//std::cout &lt;&lt; &quot;disjNode: &quot; &lt;&lt; disjNode &lt;&lt; std::endl;</span>
<a name="l01335"></a>01335                 <span class="comment">//std::cout &lt;&lt; &quot;path + currpth: &quot; &lt;&lt; std::endl;</span>
<a name="l01336"></a>01336                 <span class="comment">//for (int i = 0; i &lt; path.size(); i++) {</span>
<a name="l01337"></a>01337                 <span class="comment">//    for (int j = 0; j &lt; path[i].size(); j++) {</span>
<a name="l01338"></a>01338                 <span class="comment">//        std::cout &lt;&lt; path[i][j] &lt;&lt; &quot;, &quot;;</span>
<a name="l01339"></a>01339                 <span class="comment">//    }</span>
<a name="l01340"></a>01340                 <span class="comment">//}</span>
<a name="l01341"></a>01341                 <span class="comment">//std::cout &lt;&lt; std::endl;</span>
<a name="l01342"></a>01342                 <span class="comment">//std::cout &lt;&lt; &quot;currpth&quot; &lt;&lt; std::endl;</span>
<a name="l01343"></a>01343                 <span class="comment">//for (int k = 0; k &lt; currpth.size(); k++) {</span>
<a name="l01344"></a>01344                 <span class="comment">//    std::cout &lt;&lt; currpth[k] &lt;&lt; &quot;, &quot;;</span>
<a name="l01345"></a>01345                <span class="comment">// }</span>
<a name="l01346"></a>01346                 <span class="comment">//std::cout &lt;&lt; std::endl;</span>
<a name="l01347"></a>01347                 <span class="keywordtype">int</span> d = path[disjI].size()-1;
<a name="l01348"></a>01348                 <span class="keywordflow">while</span> (path[disjI][d] != disjNode) {
<a name="l01349"></a>01349                     d--;
<a name="l01350"></a>01350                     lpq.push_back(path[disjI][d]);
<a name="l01351"></a>01351                 }
<a name="l01352"></a>01352                 currents[path.back().back()] = 0;
<a name="l01353"></a>01353                 path.pop_back();
<a name="l01354"></a>01354                 pthloops.pop_back();
<a name="l01355"></a>01355                 std::set&lt;std::vector&lt;int&gt; &gt; nullincloops;
<a name="l01356"></a>01356                 pathAnalyze(lpq, <span class="keyword">true</span>, nullincloops);
<a name="l01357"></a>01357                 collected_loops.insert(lpq);
<a name="l01358"></a>01358                 <span class="keywordtype">int</span> k = path.size() - 1;
<a name="l01359"></a>01359                 <span class="keywordflow">while</span> (pathsAtMk[path[k].back()].size() &lt;= currents[path[k].back()]) {
<a name="l01360"></a>01360                     currents[path[k].back()] = 0;
<a name="l01361"></a>01361                     path.pop_back();
<a name="l01362"></a>01362                     pthloops.pop_back();
<a name="l01363"></a>01363                     k--;                    
<a name="l01364"></a>01364                 }
<a name="l01365"></a>01365                 
<a name="l01366"></a>01366 
<a name="l01367"></a>01367           
<a name="l01368"></a>01368                 currpth = pathsAtMk[path.back().back()][currents[path.back().back()]];
<a name="l01369"></a>01369                 <span class="comment">//path.pop_back();</span>
<a name="l01370"></a>01370                 currents[path.back().back()]++;
<a name="l01371"></a>01371             }
<a name="l01372"></a>01372 <span class="comment">/*                </span>
<a name="l01373"></a>01373 <span class="comment">                </span>
<a name="l01374"></a>01374 <span class="comment"></span>
<a name="l01375"></a>01375 <span class="comment">                    //std::vector&lt;int&gt; ieds = getInEdges(path.back().back(), g);</span>
<a name="l01376"></a>01376 <span class="comment">                    if (currents[(path.back()).back()] &lt; pathsAtMk[(path.back()).back()].size()*/</span><span class="comment">/* || ieds.size() == 0*/</span><span class="comment">//)</span>
<a name="l01377"></a>01377                     <span class="comment">//{</span>
<a name="l01378"></a>01378                     <span class="comment">//    break;</span>
<a name="l01379"></a>01379                     <span class="comment">//}</span>
<a name="l01380"></a>01380                     <span class="comment">//currents[(path.back()).back()] = 0;</span>
<a name="l01381"></a>01381                     <span class="comment">//int prevback = pth.back().back();</span>
<a name="l01382"></a>01382                    <span class="comment">// path.pop_back();</span>
<a name="l01383"></a>01383                     <span class="comment">//if (prevback ==</span>
<a name="l01384"></a>01384                    <span class="comment">// pthloops.pop_back();</span>
<a name="l01385"></a>01385                <span class="comment">// }</span>
<a name="l01386"></a>01386 <span class="comment">/*</span>
<a name="l01387"></a>01387 <span class="comment">                std::vector&lt;int&gt; ieds = getInEdges(path.back().back(), g);</span>
<a name="l01388"></a>01388 <span class="comment">                if (ieds.size() != 0)</span>
<a name="l01389"></a>01389 <span class="comment">                {</span>
<a name="l01390"></a>01390 <span class="comment">                    bool add = true;</span>
<a name="l01391"></a>01391 <span class="comment">                    currpth = (pathsAtMk[(path.back()).back()])[currents[(path.back()).back()]];</span>
<a name="l01392"></a>01392 <span class="comment">                    //if (currpth.back() == currpth.front()) {</span>
<a name="l01393"></a>01393 <span class="comment">                    //    add = false;</span>
<a name="l01394"></a>01394 <span class="comment">                    // }</span>
<a name="l01395"></a>01395 <span class="comment">                    //if (add) {</span>
<a name="l01396"></a>01396 <span class="comment">                    currents[(path.back()).back()]++;</span>
<a name="l01397"></a>01397 <span class="comment">                    //}</span>
<a name="l01398"></a>01398 <span class="comment">                }</span>
<a name="l01399"></a>01399 <span class="comment">                else</span>
<a name="l01400"></a>01400 <span class="comment">*/</span>
<a name="l01401"></a>01401                 std::vector&lt;int&gt; ieds = getInEdges(path.back().back(), g);
<a name="l01402"></a>01402                 <span class="keywordflow">if</span> (ieds.size() == 0)
<a name="l01403"></a>01403                 {
<a name="l01404"></a>01404                     step = <span class="keyword">true</span>;
<a name="l01405"></a>01405                 }
<a name="l01406"></a>01406             }
<a name="l01407"></a>01407         }
<a name="l01408"></a>01408         std::cout &lt;&lt; <span class="stringliteral">&quot;loops: &quot;</span> &lt;&lt; collected_loops.size() &lt;&lt; std::endl;
<a name="l01409"></a>01409         std::cout &lt;&lt; <span class="stringliteral">&quot;detected loops: &quot;</span> &lt;&lt; loopdetectnum &lt;&lt; std::endl;
<a name="l01410"></a>01410         
<a name="l01411"></a>01411 
<a name="l01412"></a>01412     
<a name="l01413"></a>01413 <span class="comment">//std::cout &lt;&lt; &quot;successes: &quot; &lt;&lt; successes &lt;&lt; std::endl;</span>
<a name="l01414"></a>01414 <span class="comment">//std::cout &lt;&lt; &quot;failures: &quot; &lt;&lt; failures &lt;&lt; std::endl;</span>
<a name="l01415"></a>01415 <span class="comment">//std::cout &lt;&lt; &quot;pnum: &quot; &lt;&lt; pnum &lt;&lt; std::endl;</span>
<a name="l01416"></a>01416     <span class="keywordflow">return</span>;
<a name="l01417"></a>01417 }
<a name="l01418"></a>01418 
<a name="l01419"></a>01419 
<a name="l01420"></a>01420 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l01421"></a>01421 <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l01422"></a>01422 <a class="code" href="classSgGraphTraversal.html#a06bcd8bfde6efd796304cc85046a603e">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l01423"></a><a class="code" href="classSgGraphTraversal.html#a06bcd8bfde6efd796304cc85046a603e">01423</a> <a class="code" href="classSgGraphTraversal.html#a06bcd8bfde6efd796304cc85046a603e">numerate</a>(<span class="keyword">const</span> CFG*&amp; g)
<a name="l01424"></a>01424 {
<a name="l01425"></a>01425     <span class="comment">//vertices(*g);</span>
<a name="l01426"></a>01426     <span class="comment">//edges(*g);</span>
<a name="l01427"></a>01427     <span class="keywordtype">int</span> nextEdge = 1;
<a name="l01428"></a>01428     <span class="keywordtype">int</span> nextNode = 1;
<a name="l01429"></a>01429     <a class="code" href="classSgGraphTraversal.html#a6eaf6918f211ac66aa12eb452d761f22">vertex_iterator</a> v, vend;
<a name="l01430"></a>01430     <a class="code" href="classSgGraphTraversal.html#a49f0402773be87248387897070120ab0">edge_iterator</a> e, eend;
<a name="l01431"></a>01431     <span class="keywordflow">for</span> (tie(v, vend) = vertices(*g); v != vend; ++v)
<a name="l01432"></a>01432     {
<a name="l01433"></a>01433         intvertmap[nextNode] = *v;
<a name="l01434"></a>01434         vertintmap[*v] = nextNode;
<a name="l01435"></a>01435         nextNode++;
<a name="l01436"></a>01436     }
<a name="l01437"></a>01437     <span class="keywordflow">for</span> (tie(e, eend) = edges(*g); e != eend; ++e)
<a name="l01438"></a>01438     {
<a name="l01439"></a>01439         intedgemap[nextEdge] = *e;
<a name="l01440"></a>01440         edgeintmap[*e] = nextEdge;
<a name="l01441"></a>01441         nextEdge++;
<a name="l01442"></a>01442     }
<a name="l01443"></a>01443 }
<a name="l01444"></a>01444 
<a name="l01445"></a>01445 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l01446"></a>01446 <span class="keywordtype">void</span>
<a name="l01447"></a>01447 <a class="code" href="classSgGraphTraversal.html#aadbfec7028c38362b875a0a2a8ce700a">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l01448"></a><a class="code" href="classSgGraphTraversal.html#aadbfec7028c38362b875a0a2a8ce700a">01448</a> <a class="code" href="classSgGraphTraversal.html#aadbfec7028c38362b875a0a2a8ce700a">getEntryExit</a>(<span class="keyword">const</span> CFG*&amp; g)
<a name="l01449"></a>01449 {
<a name="l01450"></a>01450     <a class="code" href="classSgGraphTraversal.html#a6eaf6918f211ac66aa12eb452d761f22">vertex_iterator</a> v, vend;
<a name="l01451"></a>01451     <span class="comment">//edge_iterator e, eend;</span>
<a name="l01452"></a>01452     <a class="code" href="classSgGraphTraversal.html#a5af9b01a8f9ef8dd55596e619d4f6c5f">out_edge_iterator</a> i, j;
<a name="l01453"></a>01453     <a class="code" href="classSgGraphTraversal.html#a0880679ae13a21afee2280891da06b92">in_edge_iterator</a> k, l;
<a name="l01454"></a>01454     <span class="keywordflow">for</span> (tie(v, vend) = vertices(*g); v != vend; ++v)
<a name="l01455"></a>01455     {
<a name="l01456"></a>01456         <span class="comment">//boost::tie(i, j) = boost::out_edges(*v, *g);</span>
<a name="l01457"></a>01457         <span class="comment">//boost::tie(k, l) = boost::in_edges(*v, *g);</span>
<a name="l01458"></a>01458         std::vector&lt;int&gt; ot = getOutEdges(vertintmap[*v], g);
<a name="l01459"></a>01459         std::vector&lt;int&gt; in = getInEdges(vertintmap[*v], g);
<a name="l01460"></a>01460         <span class="keywordflow">if</span> (ot.size() == 0)
<a name="l01461"></a>01461         {
<a name="l01462"></a>01462             sinks.push_back(vertintmap[*v]);
<a name="l01463"></a>01463         }
<a name="l01464"></a>01464         <span class="keywordflow">if</span> (in.size() == 0)
<a name="l01465"></a>01465         {
<a name="l01466"></a>01466             sources.push_back(vertintmap[*v]);
<a name="l01467"></a>01467         }
<a name="l01468"></a>01468 
<a name="l01469"></a>01469     }
<a name="l01470"></a>01470     std::cout &lt;&lt; <span class="stringliteral">&quot;sinks: &quot;</span> &lt;&lt; sinks.size() &lt;&lt; std::endl;
<a name="l01471"></a>01471     std::cout &lt;&lt; <span class="stringliteral">&quot;sources: &quot;</span> &lt;&lt; sources.size() &lt;&lt; std::endl;
<a name="l01472"></a>01472 }
<a name="l01473"></a>01473 
<a name="l01474"></a>01474 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l01475"></a>01475 <span class="keyword">inline</span> std::vector&lt;int&gt;
<a name="l01476"></a>01476 <a class="code" href="classSgGraphTraversal.html#a1980bee8d663118992055d94eb8763ce">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l01477"></a><a class="code" href="classSgGraphTraversal.html#a1980bee8d663118992055d94eb8763ce">01477</a> <a class="code" href="classSgGraphTraversal.html#a1980bee8d663118992055d94eb8763ce">getOutNodes</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; node, <span class="keyword">const</span> CFG*&amp; g)
<a name="l01478"></a>01478 {
<a name="l01479"></a>01479     std::vector&lt;int&gt; outNodes;
<a name="l01480"></a>01480     <a class="code" href="classSgGraphTraversal.html#a3347055fc33f2c5105a567f9798f6a5c">Vertex</a> getOuts = vertintmap[node];
<a name="l01481"></a>01481     <a class="code" href="classSgGraphTraversal.html#a5af9b01a8f9ef8dd55596e619d4f6c5f">out_edge_iterator</a> i, j;
<a name="l01482"></a>01482     <span class="keywordflow">for</span> (boost::tie(i, j) = boost::out_edges(getOuts, *g); i != j; ++i)
<a name="l01483"></a>01483     {
<a name="l01484"></a>01484         <a class="code" href="classSgGraphTraversal.html#a3347055fc33f2c5105a567f9798f6a5c">Vertex</a> iv = boost::target(*i, *g);
<a name="l01485"></a>01485         <span class="comment">//if (intvertmap.find(iv) == intvertmap.end()) {</span>
<a name="l01486"></a>01486         <span class="comment">//    intvertmap[nextVertInt] = iv;</span>
<a name="l01487"></a>01487         <span class="comment">//    vertintmap[iv] = nextVertInt;</span>
<a name="l01488"></a>01488         <span class="comment">//    nextVertInt++;</span>
<a name="l01489"></a>01489         <span class="comment">//}</span>
<a name="l01490"></a>01490         outNodes.push_back(intvertmap[iv]);
<a name="l01491"></a>01491     }
<a name="l01492"></a>01492     <span class="keywordflow">return</span> outNodes;
<a name="l01493"></a>01493 }
<a name="l01494"></a>01494 
<a name="l01495"></a>01495 
<a name="l01496"></a>01496 
<a name="l01497"></a>01497 
<a name="l01498"></a>01498 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l01499"></a>01499 <span class="keyword">inline</span> std::vector&lt;int&gt;
<a name="l01500"></a>01500 <a class="code" href="classSgGraphTraversal.html#a6d4ec75b9e8c69d5ce9bdd8d1ae95ac3">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l01501"></a><a class="code" href="classSgGraphTraversal.html#a6d4ec75b9e8c69d5ce9bdd8d1ae95ac3">01501</a> <a class="code" href="classSgGraphTraversal.html#a6d4ec75b9e8c69d5ce9bdd8d1ae95ac3">getOutEdges</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;node, <span class="keyword">const</span> CFG*&amp; g)
<a name="l01502"></a>01502 {
<a name="l01503"></a>01503 
<a name="l01504"></a>01504     <a class="code" href="classSgGraphTraversal.html#a3347055fc33f2c5105a567f9798f6a5c">Vertex</a> getOuts = intvertmap[node];
<a name="l01505"></a>01505     std::vector&lt;int&gt; outedges;
<a name="l01506"></a>01506     <a class="code" href="classSgGraphTraversal.html#a5af9b01a8f9ef8dd55596e619d4f6c5f">out_edge_iterator</a> i, j;
<a name="l01507"></a>01507     <span class="keywordflow">for</span> (boost::tie(i, j) = boost::out_edges(getOuts, *g); i != j; ++i)
<a name="l01508"></a>01508     {
<a name="l01509"></a>01509         outedges.push_back(edgeintmap[*i]);
<a name="l01510"></a>01510     }
<a name="l01511"></a>01511     <span class="keywordflow">return</span> outedges;
<a name="l01512"></a>01512 }
<a name="l01513"></a>01513 
<a name="l01514"></a>01514 
<a name="l01515"></a>01515 
<a name="l01516"></a>01516 
<a name="l01517"></a>01517 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l01518"></a>01518 <span class="keyword">inline</span> std::vector&lt;int&gt;
<a name="l01519"></a>01519 <a class="code" href="classSgGraphTraversal.html#a3c6f278afef4025017da55fa6ba5688e">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l01520"></a><a class="code" href="classSgGraphTraversal.html#a3c6f278afef4025017da55fa6ba5688e">01520</a> <a class="code" href="classSgGraphTraversal.html#a3c6f278afef4025017da55fa6ba5688e">getInNodes</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; node, <span class="keyword">const</span> CFG*&amp; g)
<a name="l01521"></a>01521 {
<a name="l01522"></a>01522     std::vector&lt;int&gt; inNodes;
<a name="l01523"></a>01523     <a class="code" href="classSgGraphTraversal.html#a3347055fc33f2c5105a567f9798f6a5c">Vertex</a> getIns = vertintmap[node];
<a name="l01524"></a>01524     <a class="code" href="classSgGraphTraversal.html#a0880679ae13a21afee2280891da06b92">in_edge_iterator</a> i, j;
<a name="l01525"></a>01525     <span class="keywordflow">for</span> (boost::tie(i, j) = boost::in_edges(getIns, *g); i != j; ++i)
<a name="l01526"></a>01526     {
<a name="l01527"></a>01527         <a class="code" href="classSgGraphTraversal.html#a3347055fc33f2c5105a567f9798f6a5c">Vertex</a> iv = boost::source(*i, *g);
<a name="l01528"></a>01528         inNodes.push_back(intvertmap[iv]);
<a name="l01529"></a>01529     }
<a name="l01530"></a>01530     <span class="keywordflow">return</span> inNodes;
<a name="l01531"></a>01531 }
<a name="l01532"></a>01532 
<a name="l01533"></a>01533 
<a name="l01534"></a>01534 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l01535"></a>01535 <span class="keyword">inline</span> std::vector&lt;int&gt;
<a name="l01536"></a>01536 <a class="code" href="classSgGraphTraversal.html#a9a845a70aa43aca3e2aebaad4b33e9b5">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l01537"></a><a class="code" href="classSgGraphTraversal.html#a9a845a70aa43aca3e2aebaad4b33e9b5">01537</a> <a class="code" href="classSgGraphTraversal.html#a9a845a70aa43aca3e2aebaad4b33e9b5">getInEdges</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; node, <span class="keyword">const</span> CFG*&amp; g)
<a name="l01538"></a>01538 {
<a name="l01539"></a>01539     <a class="code" href="classSgGraphTraversal.html#a3347055fc33f2c5105a567f9798f6a5c">Vertex</a> getIns = intvertmap[node];
<a name="l01540"></a>01540     std::vector&lt;int&gt; inedges;
<a name="l01541"></a>01541     <a class="code" href="classSgGraphTraversal.html#a0880679ae13a21afee2280891da06b92">in_edge_iterator</a> i, j;
<a name="l01542"></a>01542     <span class="keywordflow">for</span> (boost::tie(i, j) = boost::in_edges(getIns, *g); i != j; ++i)
<a name="l01543"></a>01543     {
<a name="l01544"></a>01544         inedges.push_back(edgeintmap[*i]);
<a name="l01545"></a>01545     }
<a name="l01546"></a>01546     <span class="keywordflow">return</span> inedges;
<a name="l01547"></a>01547 }
<a name="l01548"></a>01548 
<a name="l01549"></a>01549 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l01550"></a>01550 <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l01551"></a>01551 <a class="code" href="classSgGraphTraversal.html#ad2d92c824f75f832a1c1eb978c428579">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l01552"></a><a class="code" href="classSgGraphTraversal.html#ad2d92c824f75f832a1c1eb978c428579">01552</a> <a class="code" href="classSgGraphTraversal.html#ad2d92c824f75f832a1c1eb978c428579">getSource</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; edge, <span class="keyword">const</span> CFG*&amp; g)
<a name="l01553"></a>01553 {
<a name="l01554"></a>01554     <a class="code" href="classSgGraphTraversal.html#a7472f81cd33241d5f733e950e36247b7">Edge</a> e = intedgemap[edge];
<a name="l01555"></a>01555     <a class="code" href="classSgGraphTraversal.html#a3347055fc33f2c5105a567f9798f6a5c">Vertex</a> v = boost::source(e, *g);
<a name="l01556"></a>01556     <span class="keywordflow">return</span>(vertintmap[v]);
<a name="l01557"></a>01557 }
<a name="l01558"></a>01558 
<a name="l01559"></a>01559 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l01560"></a>01560 <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l01561"></a>01561 <a class="code" href="classSgGraphTraversal.html#a0b7e91d070514371552efcdb86900a06">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l01562"></a><a class="code" href="classSgGraphTraversal.html#a0b7e91d070514371552efcdb86900a06">01562</a> <a class="code" href="classSgGraphTraversal.html#a0b7e91d070514371552efcdb86900a06">getTarget</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; edge, <span class="keyword">const</span> CFG*&amp; g)
<a name="l01563"></a>01563 {
<a name="l01564"></a>01564     <a class="code" href="classSgGraphTraversal.html#a7472f81cd33241d5f733e950e36247b7">Edge</a> e = intedgemap[edge];
<a name="l01565"></a>01565     <a class="code" href="classSgGraphTraversal.html#a3347055fc33f2c5105a567f9798f6a5c">Vertex</a> v = boost::target(e, *g);
<a name="l01566"></a>01566     <span class="keywordflow">return</span>(vertintmap[v]);
<a name="l01567"></a>01567 }
<a name="l01568"></a>01568 
<a name="l01569"></a>01569 
<a name="l01570"></a>01570 
<a name="l01571"></a>01571 
<a name="l01584"></a>01584 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l01585"></a>01585 <span class="keywordtype">void</span>
<a name="l01586"></a>01586 <a class="code" href="classSgGraphTraversal.html#a6c6b340b187637a17fe26185ef0e9cf8" title="Runs preliminary analysis of the graph to allow for quick path calculations.">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l01587"></a><a class="code" href="classSgGraphTraversal.html#a6c6b340b187637a17fe26185ef0e9cf8">01587</a> <a class="code" href="classSgGraphTraversal.html#a6c6b340b187637a17fe26185ef0e9cf8" title="Runs preliminary analysis of the graph to allow for quick path calculations.">solvePaths2</a>(<span class="keyword">const</span> CFG* &amp;g, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;n, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;endnode)
<a name="l01588"></a>01588 {
<a name="l01589"></a>01589     std::set&lt;int&gt; seennodes;
<a name="l01590"></a>01590     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; sources.size(); j++)
<a name="l01591"></a>01591     {
<a name="l01592"></a>01592         <span class="keyword">const</span> <span class="keywordtype">int</span> sj = sources[j];
<a name="l01593"></a>01593         std::vector&lt;int&gt; oeds = getOutEdges(sources[j], g);
<a name="l01594"></a>01594         <span class="keywordflow">if</span> (oeds.size() != 0)
<a name="l01595"></a>01595         {
<a name="l01596"></a>01596             mks.insert(sources[j]);
<a name="l01597"></a>01597         }
<a name="l01598"></a>01598     }
<a name="l01599"></a>01599     <span class="keywordflow">for</span> (std::set&lt;int&gt;::iterator i = mks.begin(); i != mks.end(); i++)
<a name="l01600"></a>01600     {
<a name="l01601"></a>01601         <span class="comment">//seennodes.insert(*i);</span>
<a name="l01602"></a>01602         std::vector&lt;int&gt; ondsE = getOutEdges(*i, g);
<a name="l01603"></a>01603         std::vector&lt;int&gt; onds;
<a name="l01604"></a>01604         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> q = 0; q &lt; ondsE.size(); q++)
<a name="l01605"></a>01605         {
<a name="l01606"></a>01606             onds.push_back(getTarget(ondsE[q], g));
<a name="l01607"></a>01607 
<a name="l01608"></a>01608         }
<a name="l01609"></a>01609         <span class="comment">//std::cout &lt;&lt; &quot;mk: &quot; &lt;&lt; *i &lt;&lt; std::endl;</span>
<a name="l01610"></a>01610         <span class="comment">//std::cout &lt;&lt; &quot;onds: &quot; &lt;&lt; std::endl;</span>
<a name="l01611"></a>01611         <span class="comment">//for (int q = 0; q &lt; onds.size(); q++)</span>
<a name="l01612"></a>01612         <span class="comment">//{</span>
<a name="l01613"></a>01613         <span class="comment">//    std::cout &lt;&lt; onds[q] &lt;&lt; &quot;, &quot;;</span>
<a name="l01614"></a>01614         <span class="comment">//}</span>
<a name="l01615"></a>01615         <span class="comment">//std::cout &lt;&lt; std::endl;</span>
<a name="l01616"></a>01616         <span class="comment">//if (onds.size() == 0) {</span>
<a name="l01617"></a>01617         <span class="comment">//std::vector&lt;int&gt; cr;</span>
<a name="l01618"></a>01618         <span class="comment">//cr.push_back(*i);</span>
<a name="l01619"></a>01619         <span class="comment">//pathsAtMk[*i].push_back(cr);</span>
<a name="l01620"></a>01620         <span class="comment">//}</span>
<a name="l01621"></a>01621         <span class="comment">//else {</span>
<a name="l01622"></a>01622         std::vector&lt;int&gt; currpth;
<a name="l01623"></a>01623         <span class="keywordtype">int</span> currn;
<a name="l01624"></a>01624         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; onds.size(); j++)
<a name="l01625"></a>01625         {
<a name="l01626"></a>01626             currpth.clear();
<a name="l01627"></a>01627             currpth.push_back(*i);
<a name="l01628"></a>01628             currpth.push_back(onds[j]);
<a name="l01629"></a>01629             <span class="keywordtype">int</span> currn = onds[j];
<a name="l01630"></a>01630             <span class="keywordflow">while</span> (mks.find(currn) == mks.end())
<a name="l01631"></a>01631             {
<a name="l01632"></a>01632                 <span class="comment">/*</span>
<a name="l01633"></a>01633 <span class="comment">                                if (seennodes.find(currn) != seennodes.end()) {</span>
<a name="l01634"></a>01634 <span class="comment">                                    //mkloops.insert(currn);</span>
<a name="l01635"></a>01635 <span class="comment">                                }</span>
<a name="l01636"></a>01636 <span class="comment">                                else {</span>
<a name="l01637"></a>01637 <span class="comment">                                    seennodes.insert(currn);</span>
<a name="l01638"></a>01638 <span class="comment">                                }</span>
<a name="l01639"></a>01639 <span class="comment">                */</span>
<a name="l01640"></a>01640                 <span class="comment">//std::cout &lt;&lt; &quot;currn: &quot; &lt;&lt; currn &lt;&lt; std::endl;</span>
<a name="l01641"></a>01641                 std::vector&lt;int&gt; ons = getOutEdges(currn, g);
<a name="l01642"></a>01642                 <span class="comment">//std::cout &lt;&lt; &quot;ons.size(): &quot; &lt;&lt; ons.size() &lt;&lt; std::endl;</span>
<a name="l01643"></a>01643                 ROSE_ASSERT(ons.size() == 1 || ons.size() == 0);
<a name="l01644"></a>01644                 <span class="keywordflow">if</span> (ons.size() == 0)
<a name="l01645"></a>01645                 {
<a name="l01646"></a>01646                     <span class="keywordflow">break</span>;
<a name="l01647"></a>01647                 }
<a name="l01648"></a>01648                 <span class="keywordflow">else</span>
<a name="l01649"></a>01649                 {
<a name="l01650"></a>01650                     <span class="comment">/*</span>
<a name="l01651"></a>01651 <span class="comment">                                        if (seennodes.find(getTarget(ons[0], g)) != seennodes.end()) {</span>
<a name="l01652"></a>01652 <span class="comment">                                            //mkloops.insert(getTarget(ons[0], g));</span>
<a name="l01653"></a>01653 <span class="comment">                                        }</span>
<a name="l01654"></a>01654 <span class="comment">                                        else {</span>
<a name="l01655"></a>01655 <span class="comment">                                            seennodes.insert(getTarget(ons[0], g));</span>
<a name="l01656"></a>01656 <span class="comment">                                        }</span>
<a name="l01657"></a>01657 <span class="comment">                                    }</span>
<a name="l01658"></a>01658 <span class="comment">                                    if (mks.find(getTarget(ons[0], g)) != mks.end()) {</span>
<a name="l01659"></a>01659 <span class="comment">                                        currpth.push_back(getTarget(ons[0], g));</span>
<a name="l01660"></a>01660 <span class="comment">                                        break;</span>
<a name="l01661"></a>01661 <span class="comment">                                    }</span>
<a name="l01662"></a>01662 <span class="comment">                                    else if (find(currpth.begin(), currpth.end(), getTarget(ons[0], g)) != currpth.end()) {</span>
<a name="l01663"></a>01663 <span class="comment">                                        currpth.push_back(getTarget(ons[0], g));</span>
<a name="l01664"></a>01664 <span class="comment">                                        break;</span>
<a name="l01665"></a>01665 <span class="comment">                                    }</span>
<a name="l01666"></a>01666 <span class="comment">                                    else {</span>
<a name="l01667"></a>01667 <span class="comment">                    */</span>
<a name="l01668"></a>01668                     currpth.push_back(getTarget(ons[0], g));
<a name="l01669"></a>01669                     currn = getTarget(ons[0], g);
<a name="l01670"></a>01670                     <span class="comment">//seennodes.insert(currn);</span>
<a name="l01671"></a>01671                     <span class="comment">//}</span>
<a name="l01672"></a>01672 
<a name="l01673"></a>01673                 }
<a name="l01674"></a>01674             }
<a name="l01675"></a>01675             <span class="keywordflow">if</span> (currpth.front() != currpth.back() || currpth.size() == 1) {
<a name="l01676"></a>01676                 pathsAtMk[*i].push_back(currpth);
<a name="l01677"></a>01677             }
<a name="l01678"></a>01678         }
<a name="l01679"></a>01679         <span class="comment">//}</span>
<a name="l01680"></a>01680     }
<a name="l01681"></a>01681     <span class="comment">//std::cout &lt;&lt; &quot;pnum: &quot; &lt;&lt; pnum;</span>
<a name="l01682"></a>01682 }
<a name="l01683"></a>01683 
<a name="l01684"></a>01684 
<a name="l01685"></a>01685 
<a name="l01686"></a>01686 
<a name="l01687"></a>01687 
<a name="l01688"></a>01688 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l01689"></a>01689 <span class="keywordtype">void</span>
<a name="l01690"></a>01690 <a class="code" href="classSgGraphTraversal.html#a1a9736b9bd3eeef8ee9b75b6cdfbdfc5">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l01691"></a><a class="code" href="classSgGraphTraversal.html#a1a9736b9bd3eeef8ee9b75b6cdfbdfc5">01691</a> <a class="code" href="classSgGraphTraversal.html#a1a9736b9bd3eeef8ee9b75b6cdfbdfc5">solvePaths</a>(<span class="keyword">const</span> CFG* &amp;g, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;n, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;endnode)
<a name="l01692"></a>01692 {
<a name="l01693"></a>01693     <span class="keywordtype">bool</span> done = <span class="keyword">false</span>;
<a name="l01694"></a>01694     <span class="keywordtype">bool</span> edges = <span class="keyword">true</span>;
<a name="l01695"></a>01695     <span class="keywordtype">bool</span> tookone = <span class="keyword">false</span>;
<a name="l01696"></a>01696 
<a name="l01697"></a>01697     <span class="comment">//currn = _cast&lt;int&gt; (n);</span>
<a name="l01698"></a>01698     <span class="comment">//currn = _cast&lt;int&gt; (n);</span>
<a name="l01699"></a>01699     std::vector&lt;int&gt; mkpath;
<a name="l01700"></a>01700     <span class="comment">//loopcount = 0;</span>
<a name="l01701"></a>01701     std::vector&lt;int&gt; marks;
<a name="l01702"></a>01702     marks.push_back(n);
<a name="l01703"></a>01703     mkglobal.push_back(n);
<a name="l01704"></a>01704     <span class="comment">// int currn; /*= new int/;</span>
<a name="l01705"></a>01705     <span class="comment">// currn = _cast&lt;int&gt; (n);</span>
<a name="l01706"></a>01706     <span class="comment">//int took = new Vertex;</span>
<a name="l01707"></a>01707     <span class="keywordtype">int</span> tookv;
<a name="l01708"></a>01708     std::set&lt;int&gt; taken;
<a name="l01709"></a>01709     std::vector&lt;int&gt; toTake;
<a name="l01710"></a>01710     std::vector&lt;int&gt; path;
<a name="l01711"></a>01711     path.push_back(n);
<a name="l01712"></a>01712     mkpath.push_back(n);
<a name="l01713"></a>01713     <span class="keywordtype">int</span> itr = 0;
<a name="l01714"></a>01714     <span class="keywordtype">int</span> bifurcations = 0;
<a name="l01715"></a>01715     <span class="keywordtype">int</span> runs = 0;
<a name="l01716"></a>01716     <span class="keywordtype">int</span> currnodenum = 0;
<a name="l01717"></a>01717     <span class="keywordtype">bool</span> first = <span class="keyword">true</span>;
<a name="l01718"></a>01718     <span class="comment">//std::map&lt;FilteredCFGNode&lt;CFGNodeFilter2&gt;*, int&gt; nodenums;</span>
<a name="l01719"></a>01719     std::map&lt;int, bool&gt; completed;
<a name="l01720"></a>01720     <span class="keywordtype">int</span> currn = n;
<a name="l01721"></a>01721     <span class="keywordtype">int</span> took;
<a name="l01722"></a>01722     <span class="comment">//std::cout &lt;&lt; &quot;n: &quot; &lt;&lt; n &lt;&lt; std::endl;</span>
<a name="l01723"></a>01723     <span class="keywordflow">while</span> (done == <span class="keyword">false</span>)
<a name="l01724"></a>01724     {
<a name="l01725"></a>01725         <span class="comment">/*</span>
<a name="l01726"></a>01726 <span class="comment">                     runs++;</span>
<a name="l01727"></a>01727 <span class="comment">                     CFG gra = *g;</span>
<a name="l01728"></a>01728 <span class="comment">                     FilteredCFGNode&lt;CFGNodeFilter2&gt;* tq;</span>
<a name="l01729"></a>01729 <span class="comment">                     Vertex tookv = *currn;</span>
<a name="l01730"></a>01730 <span class="comment">                     tq = &amp;(*gra[tookv]);</span>
<a name="l01731"></a>01731 <span class="comment">                     if (nodenums.find(tq) == nodenums.end()) {</span>
<a name="l01732"></a>01732 <span class="comment">                         nodenums[tq] = currnodenum++;</span>
<a name="l01733"></a>01733 <span class="comment">                     }</span>
<a name="l01734"></a>01734 <span class="comment">                     printCFGNode(tq,g, nodenums[tq]);</span>
<a name="l01735"></a>01735 <span class="comment">        */</span>
<a name="l01736"></a>01736         <span class="comment">//std::cout &lt;&lt; &quot;currn: &quot; &lt;&lt; currn &lt;&lt; std::endl;</span>
<a name="l01737"></a>01737         <span class="comment">//std::cout &lt;&lt; &quot;runs: &quot; &lt;&lt; runs &lt;&lt; std::endl;</span>
<a name="l01738"></a>01738         <span class="comment">//if (nodenums.find(currn) == nodenums.end()) {</span>
<a name="l01739"></a>01739         <span class="comment">//    nodenums[currn] = currnodenum++;</span>
<a name="l01740"></a>01740         <span class="comment">//}</span>
<a name="l01741"></a>01741 
<a name="l01742"></a>01742         <span class="comment">//ROSE_ASSERT(currn != NULL);</span>
<a name="l01743"></a>01743         <span class="comment">/*</span>
<a name="l01744"></a>01744 <span class="comment">                     out_edge_iterator k1, l1;</span>
<a name="l01745"></a>01745 <span class="comment">                     boost::tie(k1, l1) = boost::out_edges(*currn, *g);</span>
<a name="l01746"></a>01746 <span class="comment">                     in_edge_iterator k2, l2;</span>
<a name="l01747"></a>01747 <span class="comment">                     boost::tie(k2, l2) = boost::in_edges(*currn, *g);</span>
<a name="l01748"></a>01748 <span class="comment">        */</span>
<a name="l01749"></a>01749 
<a name="l01750"></a>01750         <span class="comment">/*</span>
<a name="l01751"></a>01751 <span class="comment"></span>
<a name="l01752"></a>01752 <span class="comment"></span>
<a name="l01753"></a>01753 <span class="comment">                     //std::cout &lt;&lt; &quot;\n&quot;;</span>
<a name="l01754"></a>01754 <span class="comment">                     std::cout &lt;&lt; &quot;l1-k1&quot; &lt;&lt; l1 - k1 &lt;&lt; std::endl;</span>
<a name="l01755"></a>01755 <span class="comment">                     std::cout &lt;&lt; &quot;l2-k2&quot; &lt;&lt; l2-k2 &lt;&lt; std::endl;</span>
<a name="l01756"></a>01756 <span class="comment">                     if (l1 - k1 &gt; 1 || l2 - k2 &gt; 1) {</span>
<a name="l01757"></a>01757 <span class="comment">                         //printCFGNode(currn,g,nodenums[took]);</span>
<a name="l01758"></a>01758 <span class="comment"></span>
<a name="l01759"></a>01759 <span class="comment">                         //std::cout &lt;&lt; &quot;outedges: &quot; &lt;&lt; l1 - k1 &lt;&lt; std::endl;</span>
<a name="l01760"></a>01760 <span class="comment">                         //std::cout &lt;&lt; &quot;targets: &quot; &lt;&lt; std::endl;</span>
<a name="l01761"></a>01761 <span class="comment">                        for (boost::tie(k1, l1) = boost::out_edges(*currn, *g); k1 != l1; ++k1) {</span>
<a name="l01762"></a>01762 <span class="comment">                             //Vertex tookvPre = boost::target(*k1, *g);</span>
<a name="l01763"></a>01763 <span class="comment">                             *took = boost::target(*k1, *g);</span>
<a name="l01764"></a>01764 <span class="comment"></span>
<a name="l01765"></a>01765 <span class="comment">                             //if (nodenums.find(took) == nodenums.end()) {</span>
<a name="l01766"></a>01766 <span class="comment">                             //    nodenums[took] = currnodenum++;</span>
<a name="l01767"></a>01767 <span class="comment">                            // }</span>
<a name="l01768"></a>01768 <span class="comment"></span>
<a name="l01769"></a>01769 <span class="comment">                           //  printCFGNode(took,g, nodenums[took]);</span>
<a name="l01770"></a>01770 <span class="comment">                         }</span>
<a name="l01771"></a>01771 <span class="comment">                         //std::cout &lt;&lt; &quot;inedges: &quot; &lt;&lt; l2 - k2 &lt;&lt; std::endl;</span>
<a name="l01772"></a>01772 <span class="comment">                         //std::cout &lt;&lt; &quot;sources&quot; &lt;&lt; std::endl;</span>
<a name="l01773"></a>01773 <span class="comment">                         for (boost::tie(k2, l2) = boost::in_edges(*currn, *g); k2 != l2; ++k2) {</span>
<a name="l01774"></a>01774 <span class="comment">                             //Vertex tookvPre = boost::source(*k2, *g);</span>
<a name="l01775"></a>01775 <span class="comment">                             *took = boost::source(*k2, *g);</span>
<a name="l01776"></a>01776 <span class="comment">                             //int vt = tookv;</span>
<a name="l01777"></a>01777 <span class="comment">                             //CFG* gra = *g;</span>
<a name="l01778"></a>01778 <span class="comment"></span>
<a name="l01779"></a>01779 <span class="comment">                             //took = &amp;(*gra[tookv]);</span>
<a name="l01780"></a>01780 <span class="comment">                     //if (nodenums.find(took) == nodenums.end()) {</span>
<a name="l01781"></a>01781 <span class="comment">                       //  nodenums[took] = currnodenum++;</span>
<a name="l01782"></a>01782 <span class="comment">                     //}</span>
<a name="l01783"></a>01783 <span class="comment"></span>
<a name="l01784"></a>01784 <span class="comment">                            // printCFGNode(took,g,nodenums[took]);</span>
<a name="l01785"></a>01785 <span class="comment">                         }</span>
<a name="l01786"></a>01786 <span class="comment"></span>
<a name="l01787"></a>01787 <span class="comment"></span>
<a name="l01788"></a>01788 <span class="comment">                     }</span>
<a name="l01789"></a>01789 <span class="comment">                     else {</span>
<a name="l01790"></a>01790 <span class="comment">                         //std::cout &lt;&lt; &quot;simplenode&quot; &lt;&lt; std::endl;</span>
<a name="l01791"></a>01791 <span class="comment">                         //printCFGNode(currn, g, -1);</span>
<a name="l01792"></a>01792 <span class="comment">                     }</span>
<a name="l01793"></a>01793 <span class="comment">                     //std::cout &lt;&lt; &quot;\n&quot;;</span>
<a name="l01794"></a>01794 <span class="comment">        */</span>
<a name="l01795"></a>01795 
<a name="l01796"></a>01796 
<a name="l01797"></a>01797 
<a name="l01798"></a>01798 
<a name="l01799"></a>01799         <span class="comment">//std::cout &lt;&lt; &quot;runs&quot; &lt;&lt; runs &lt;&lt; std::endl;</span>
<a name="l01800"></a>01800         <span class="comment">//ROSE_ASSERT(currn != NULL);</span>
<a name="l01801"></a>01801 
<a name="l01802"></a>01802 <span class="comment">//check to see if we&#39;ve hit the endnode or if we&#39;re done, if not continue, if so push the subpath into the &quot;pathsAtMk&quot; repository</span>
<a name="l01803"></a>01803         <span class="keywordflow">if</span> (currn == endnode || completed.find(currn) != completed.end() || (mkpath.size() &gt; 1 &amp;&amp; mkpath.front() == mkpath.back()))
<a name="l01804"></a>01804         {
<a name="l01805"></a>01805 
<a name="l01806"></a>01806             <span class="keywordflow">if</span> (currn == endnode)
<a name="l01807"></a>01807             {
<a name="l01808"></a>01808                 <span class="comment">//std::cout &lt;&lt; &quot;found endnode&quot; &lt;&lt; std::endl;</span>
<a name="l01809"></a>01809             }
<a name="l01810"></a>01810             <span class="keywordflow">if</span> (completed.find(currn) != completed.end())
<a name="l01811"></a>01811             {
<a name="l01812"></a>01812                 <span class="comment">//std::cout &lt;&lt; &quot;currn completed&quot; &lt;&lt; std::endl;</span>
<a name="l01813"></a>01813             }
<a name="l01814"></a>01814             <span class="keywordflow">if</span> (mkpath.size() &gt; 1 &amp;&amp; mkpath.front() == mkpath.back())
<a name="l01815"></a>01815             {
<a name="l01816"></a>01816                 <span class="comment">//std::cout &lt;&lt; &quot;mkpathsize &gt; 1, it is &quot; &lt;&lt; mkpath.size() &lt;&lt; &quot; and mkpath.front() == mkpath.back()&quot; &lt;&lt; std::endl;</span>
<a name="l01817"></a>01817             }
<a name="l01818"></a>01818             <span class="keywordflow">if</span> (pathsAtMk.find(marks.back()) == pathsAtMk.end())
<a name="l01819"></a>01819             {
<a name="l01820"></a>01820                 std::vector&lt;std::vector&lt;int&gt; &gt; emptypath;
<a name="l01821"></a>01821                 pathsAtMk[marks.back()] = emptypath;
<a name="l01822"></a>01822             }
<a name="l01823"></a>01823             edges = <span class="keyword">false</span>;
<a name="l01824"></a>01824             pathsAtMk[marks.back()].push_back(mkpath);
<a name="l01825"></a>01825             <span class="comment">//std::cout &lt;&lt; &quot;marks.back(): &quot; &lt;&lt; std::endl;</span>
<a name="l01826"></a>01826             <span class="comment">//printCFGNode(marks.back(), g);</span>
<a name="l01827"></a>01827             <span class="comment">//for (int mk = 0; mk &lt; mkpath.size(); mk++) {</span>
<a name="l01828"></a>01828             <span class="comment">//   std::pair&lt;CFG::CFGEdgePtr, CFG::CFGEdgePtr&gt; iedg = g-&gt;in_edges(mkpath[mk]);</span>
<a name="l01829"></a>01829             <span class="comment">//if (iedg.size() &gt; 1) {</span>
<a name="l01830"></a>01830             <span class="comment">//    ploops.insert(mkpath[mk]);</span>
<a name="l01831"></a>01831             <span class="comment">// }</span>
<a name="l01832"></a>01832             <span class="comment">//}</span>
<a name="l01833"></a>01833             ROSE_ASSERT(mkpath.size() != 0);
<a name="l01834"></a>01834             <span class="comment">//std::cout &lt;&lt; &quot;mkpath: &quot;;</span>
<a name="l01835"></a>01835             <span class="comment">//for (int i = 0; i &lt; mkpath.size(); i++) {</span>
<a name="l01836"></a>01836             <span class="comment">//  std::cout &lt;&lt; mkpath[i] &lt;&lt; &quot;, &quot;;</span>
<a name="l01837"></a>01837             <span class="comment">//}</span>
<a name="l01838"></a>01838             <span class="comment">//std::cout &lt;&lt; &quot;end&quot; &lt;&lt; std::endl;</span>
<a name="l01839"></a>01839 
<a name="l01840"></a>01840             <span class="comment">//std::cout &lt;&lt; &quot;marks: &quot; &lt;&lt; marks.back() &lt;&lt; std::endl;</span>
<a name="l01841"></a>01841             ROSE_ASSERT(marks.size() != 0);
<a name="l01842"></a>01842             <span class="comment">//for (int i = 0; i &lt; marks.size(); i++)</span>
<a name="l01843"></a>01843             <span class="comment">//{</span>
<a name="l01844"></a>01844             <span class="comment">//    std::cout &lt;&lt; marks[i] &lt;&lt; &quot; ,&quot;;</span>
<a name="l01845"></a>01845             <span class="comment">//}</span>
<a name="l01846"></a>01846             <span class="comment">//std::cout &lt;&lt; std::endl;</span>
<a name="l01847"></a>01847             ROSE_ASSERT(mkpath.front() == marks.back());
<a name="l01848"></a>01848             <span class="keywordflow">if</span> (marks.size() == 0)
<a name="l01849"></a>01849             {
<a name="l01850"></a>01850                 <span class="comment">//std::cout &lt;&lt; &quot;marks size == 0&quot; &lt;&lt; std::endl;</span>
<a name="l01851"></a>01851                 <span class="keywordflow">return</span>;
<a name="l01852"></a>01852             }
<a name="l01853"></a>01853             <span class="comment">/*</span>
<a name="l01854"></a>01854 <span class="comment">                            if (mkpath.front() == mkpath.back() &amp;&amp; mkpath.size() &gt; 1) {</span>
<a name="l01855"></a>01855 <span class="comment">                                Edge* ede = boost::edge(*mkpath[mkpath.size()-2],*mkpath[mkpath.size()-1], *g).first;</span>
<a name="l01856"></a>01856 <span class="comment">                                Edge* ed = &amp;ede;</span>
<a name="l01857"></a>01857 <span class="comment">                                Edge* ed2e = boost::edge(*mkpath[0],*mkpath[1], *g).first;</span>
<a name="l01858"></a>01858 <span class="comment">                                Edge* ed2 = &amp;ed2e;</span>
<a name="l01859"></a>01859 <span class="comment">                                std::set&lt;Edge*&gt; totake;</span>
<a name="l01860"></a>01860 <span class="comment">                                totake.insert(ed);</span>
<a name="l01861"></a>01861 <span class="comment">                                std::set&lt;Edge*&gt; toout;</span>
<a name="l01862"></a>01862 <span class="comment">                                toout.insert(ed2);</span>
<a name="l01863"></a>01863 <span class="comment">                                //badEdgesIn[mkpath[mkpath.size()-1]].insert(*totake.begin());</span>
<a name="l01864"></a>01864 <span class="comment">                                //badEdgesOut[mkpath[0]].insert(*toout.begin());</span>
<a name="l01865"></a>01865 <span class="comment">                                ROSE_ASSERT(totake.size() &lt; 2 &amp;&amp; toout.size() &lt; 2);</span>
<a name="l01866"></a>01866 <span class="comment">                                taken.insert(*totake.begin());</span>
<a name="l01867"></a>01867 <span class="comment">                            }</span>
<a name="l01868"></a>01868 <span class="comment">            */</span>
<a name="l01869"></a>01869 
<a name="l01870"></a>01870             mkpath.clear();
<a name="l01871"></a>01871             <span class="keywordtype">bool</span> y = <span class="keyword">true</span>;
<a name="l01872"></a>01872             <span class="keywordtype">bool</span> haventtaken = <span class="keyword">false</span>;
<a name="l01873"></a>01873             <span class="keywordtype">bool</span> p = <span class="keyword">true</span>;
<a name="l01874"></a>01874             <span class="keywordtype">int</span> place;
<a name="l01875"></a>01875             <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;
<a name="l01876"></a>01876             <span class="keywordflow">while</span> (found == <span class="keyword">false</span>)
<a name="l01877"></a>01877             {
<a name="l01878"></a>01878 
<a name="l01879"></a>01879                 <span class="keywordflow">if</span> (marks.size() == 0)
<a name="l01880"></a>01880                 {
<a name="l01881"></a>01881                     <span class="comment">//std::cout &lt;&lt; &quot;marks.size() == 0, former&quot; &lt;&lt; std::endl;</span>
<a name="l01882"></a>01882                     <span class="keywordflow">return</span>;
<a name="l01883"></a>01883                 }
<a name="l01884"></a>01884                 <span class="keywordtype">int</span> tooked;
<a name="l01885"></a>01885                 <span class="keywordtype">int</span> ted;
<a name="l01886"></a>01886                 <span class="keywordtype">int</span> mark1 = marks.back();
<a name="l01887"></a>01887                 std::vector&lt;int&gt; ode = getOutEdges(mark1, g);
<a name="l01888"></a>01888 
<a name="l01889"></a>01889                 <span class="comment">//std::pair&lt;CFG::CFGEdgePtr, CFG::CFGEdgePtr&gt; oedg = boost::out_edges(mark1, *g);</span>
<a name="l01890"></a>01890                 <span class="comment">//std::cout &lt;&lt; &quot;oedg.first - oedg.second: &quot; &lt;&lt; oedg.first - oedg.second &lt;&lt; std::endl;</span>
<a name="l01891"></a>01891 <span class="comment">//                    int ted;</span>
<a name="l01892"></a>01892                 ROSE_ASSERT(ode.size() &gt; 1 || mark1 == n);
<a name="l01893"></a>01893                 <span class="keywordtype">int</span> ik;
<a name="l01894"></a>01894                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ode.size(); i++)
<a name="l01895"></a>01895                 {
<a name="l01896"></a>01896                     ik = ode[i];
<a name="l01897"></a>01897                     <span class="keywordflow">if</span> (taken.find(ik) == taken.end() &amp;&amp; haventtaken == <span class="keyword">false</span>)
<a name="l01898"></a>01898                     {
<a name="l01899"></a>01899                         tooked = ik;
<a name="l01900"></a>01900                         ted = ode[i];
<a name="l01901"></a>01901                         haventtaken = <span class="keyword">true</span>;
<a name="l01902"></a>01902                     }
<a name="l01903"></a>01903                 }
<a name="l01904"></a>01904                 <span class="keywordflow">if</span> (haventtaken == <span class="keyword">true</span>)
<a name="l01905"></a>01905                 {
<a name="l01906"></a>01906                     <span class="keywordflow">if</span> (marks.back() == n)
<a name="l01907"></a>01907                     {
<a name="l01908"></a>01908                         path.clear();
<a name="l01909"></a>01909                     }
<a name="l01910"></a>01910                     <span class="comment">//if (path.back() != marks.back()) {</span>
<a name="l01911"></a>01911                     path.push_back(marks.back());
<a name="l01912"></a>01912                     <span class="comment">//}</span>
<a name="l01913"></a>01913                     <span class="keywordflow">if</span> (mkpath.back() != marks.back())
<a name="l01914"></a>01914                     {
<a name="l01915"></a>01915                         mkpath.push_back(marks.back());
<a name="l01916"></a>01916                     }
<a name="l01917"></a>01917                     taken.insert(tooked);
<a name="l01918"></a>01918                     took = getTarget(ted, g);
<a name="l01919"></a>01919                     <span class="comment">//Vertex tookPre = boost::target(*ted,*g);</span>
<a name="l01920"></a>01920                     <span class="comment">//took = &amp;tookPre;</span>
<a name="l01921"></a>01921                     <span class="comment">//int vt = tookv;</span>
<a name="l01922"></a>01922                     <span class="comment">//CFG* gra = *g;</span>
<a name="l01923"></a>01923                     <span class="comment">//took = tookv;</span>
<a name="l01924"></a>01924                     found = <span class="keyword">true</span>;
<a name="l01925"></a>01925                 }
<a name="l01926"></a>01926                 <span class="keywordflow">else</span>
<a name="l01927"></a>01927                 {
<a name="l01928"></a>01928                     completed[marks.back()] = <span class="keyword">true</span>;
<a name="l01929"></a>01929                     bifurcations++;
<a name="l01930"></a>01930                     marks.pop_back();
<a name="l01931"></a>01931                 }
<a name="l01932"></a>01932             }
<a name="l01933"></a>01933             <span class="keywordflow">if</span> (marks.size() == 0)
<a name="l01934"></a>01934             {
<a name="l01935"></a>01935                 <span class="comment">//std::cout &lt;&lt; &quot;marks.size() == 0, latter&quot; &lt;&lt; std::endl;</span>
<a name="l01936"></a>01936                 <span class="keywordflow">return</span>;
<a name="l01937"></a>01937             }
<a name="l01938"></a>01938             haventtaken = <span class="keyword">false</span>;
<a name="l01939"></a>01939             found = <span class="keyword">false</span>;
<a name="l01940"></a>01940 
<a name="l01941"></a>01941         }
<a name="l01942"></a>01942 <span class="comment">//if we haven&#39;t reached the endnode or completed, continue down the graph</span>
<a name="l01943"></a>01943         <span class="keywordflow">else</span>
<a name="l01944"></a>01944         {
<a name="l01945"></a>01945 <span class="comment">//            std::pair&lt;CFG::CFGEdgePtr, CFG::CFGEdgePtr&gt; oedg = boost::out_edges(currn, *g);</span>
<a name="l01946"></a>01946 <span class="comment">//            std::pair&lt;CFG::CFGEdgePtr, CFG::CFGEdgePtr&gt; iedg = boost::in_edges(currn, *g);</span>
<a name="l01947"></a>01947             <span class="comment">//ROSE_ASSERT(currn != NULL);</span>
<a name="l01948"></a>01948             std::vector&lt;int&gt; ode = getOutEdges(currn, g);
<a name="l01949"></a>01949             <span class="comment">/*</span>
<a name="l01950"></a>01950 <span class="comment"></span>
<a name="l01951"></a>01951 <span class="comment">                                    for (boost::tie(k, l) = boost::out_edges(*currn, *g); k != l; ++k) {</span>
<a name="l01952"></a>01952 <span class="comment">                                        ode++;</span>
<a name="l01953"></a>01953 <span class="comment">                                    }</span>
<a name="l01954"></a>01954 <span class="comment">            */</span>
<a name="l01955"></a>01955 
<a name="l01956"></a>01956             <span class="keywordflow">if</span> (ode.size() &gt; 1) <span class="comment">/*out_edges(*currn,*g).second != boost::out_edges(*currn,*g).first)*/</span>
<a name="l01957"></a>01957             {
<a name="l01958"></a>01958                 <span class="keywordflow">if</span> (mkpath.back() != currn)
<a name="l01959"></a>01959                 {
<a name="l01960"></a>01960                     mkpath.push_back(currn);
<a name="l01961"></a>01961                 }
<a name="l01962"></a>01962                 pathsAtMk[marks.back()].push_back(mkpath);
<a name="l01963"></a>01963                 mkpath.clear();
<a name="l01964"></a>01964                 mkpath.push_back(currn);
<a name="l01965"></a>01965                 marks.push_back(currn);
<a name="l01966"></a>01966                 <span class="keywordflow">if</span> (<a class="code" href="namespaceSageInterface.html#aff5394b21cf11cd338671af3a11a7f92">find</a>(mkglobal.begin(), mkglobal.end(), currn) == mkglobal.end())
<a name="l01967"></a>01967                 {
<a name="l01968"></a>01968                     mkglobal.push_back(currn);
<a name="l01969"></a>01969                 }
<a name="l01970"></a>01970                 <span class="keywordtype">int</span> ik;
<a name="l01971"></a>01971                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ode.size(); i++)
<a name="l01972"></a>01972                 {
<a name="l01973"></a>01973                     ik = ode[i];
<a name="l01974"></a>01974                     <span class="keywordflow">if</span> (taken.find(ik) == taken.end() &amp;&amp; tookone == <span class="keyword">false</span>)
<a name="l01975"></a>01975                     {
<a name="l01976"></a>01976                         taken.insert(ik);
<a name="l01977"></a>01977                         tookone = <span class="keyword">true</span>;
<a name="l01978"></a>01978                         <span class="comment">//Vertex tookpre;</span>
<a name="l01979"></a>01979                         <span class="comment">//tookpre = boost::target(*i,*g);</span>
<a name="l01980"></a>01980                         <span class="comment">//took = &amp;tookpre;</span>
<a name="l01981"></a>01981                         took = getTarget(ik, g);
<a name="l01982"></a>01982                         <span class="comment">//int vt = tookv;</span>
<a name="l01983"></a>01983                         <span class="comment">//CFG* gra = *g;</span>
<a name="l01984"></a>01984                         <span class="comment">//took = &amp;(*gra[tookv]);</span>
<a name="l01985"></a>01985                     }
<a name="l01986"></a>01986                     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (taken.find(ik) == taken.end() &amp;&amp; tookone == <span class="keyword">true</span>)
<a name="l01987"></a>01987                     {
<a name="l01988"></a>01988                         <span class="comment">//toTake.push_back((*i)-&gt;get_to());</span>
<a name="l01989"></a>01989                     }
<a name="l01990"></a>01990                 }
<a name="l01991"></a>01991                 tookone = <span class="keyword">false</span>;
<a name="l01992"></a>01992             }
<a name="l01993"></a>01993             <span class="keywordflow">else</span>
<a name="l01994"></a>01994             {
<a name="l01995"></a>01995                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ode.size(); i++)
<a name="l01996"></a>01996                 {
<a name="l01997"></a>01997                     <span class="comment">//tookpre = boost::target(*i, *g);</span>
<a name="l01998"></a>01998                     <span class="comment">//took = &amp;tookpre;</span>
<a name="l01999"></a>01999                     took = getTarget(ode[i], g);
<a name="l02000"></a>02000                     <span class="comment">//int vt = tookv;</span>
<a name="l02001"></a>02001                     <span class="comment">//CFG* gra = *g;</span>
<a name="l02002"></a>02002                     <span class="comment">//took = &amp;(*gra[tookv]);</span>
<a name="l02003"></a>02003                 }
<a name="l02004"></a>02004                 <span class="comment">/*</span>
<a name="l02005"></a>02005 <span class="comment">                               for (boost::tie(i, j) = boost::out_edges(*currn, *g); i != j; ++i) {</span>
<a name="l02006"></a>02006 <span class="comment">                                   int tookv = &amp;boost::target(*i,*g);</span>
<a name="l02007"></a>02007 <span class="comment">                                   took = &amp;tookv;</span>
<a name="l02008"></a>02008 <span class="comment">                               }</span>
<a name="l02009"></a>02009 <span class="comment">                */</span>
<a name="l02010"></a>02010 
<a name="l02011"></a>02011             }
<a name="l02012"></a>02012         }
<a name="l02013"></a>02013         itr++;
<a name="l02014"></a>02014         <span class="comment">//ROSE_ASSERT(took != NULL);</span>
<a name="l02015"></a>02015         <span class="comment">//std::cout &lt;&lt; &quot;path so far: &quot; &lt;&lt; std::endl;</span>
<a name="l02016"></a>02016 <span class="comment">//               FilteredCFGNode&lt;CFGNodeFilter2&gt;* tq;</span>
<a name="l02017"></a>02017 <span class="comment">//               CFG gra;</span>
<a name="l02018"></a>02018 <span class="comment">//               Vertex tookv;</span>
<a name="l02019"></a>02019 
<a name="l02020"></a>02020         <span class="comment">//for (int i = 0; i &lt; path.size(); i++) {</span>
<a name="l02021"></a>02021 <span class="comment">//                   gra = *g;</span>
<a name="l02022"></a>02022 <span class="comment">//                   tookv = *path[i];</span>
<a name="l02023"></a>02023 <span class="comment">//                   tq = &amp;(*gra[tookv]);</span>
<a name="l02024"></a>02024         <span class="comment">//   std::cout &lt;&lt; path[i] &lt;&lt; &quot;, &quot;;</span>
<a name="l02025"></a>02025         <span class="comment">//}</span>
<a name="l02026"></a>02026         <span class="comment">//std::cout &lt;&lt; std::endl;</span>
<a name="l02027"></a>02027 
<a name="l02028"></a>02028         <span class="keywordflow">if</span> (<a class="code" href="namespaceSageInterface.html#aff5394b21cf11cd338671af3a11a7f92">find</a>(path.begin(), path.end(), took) == path.end())
<a name="l02029"></a>02029         {
<a name="l02030"></a>02030             <span class="comment">//std::cout &lt;&lt; &quot;no loop&quot; &lt;&lt; std::endl;</span>
<a name="l02031"></a>02031             <span class="comment">//for (int i = 0; i &lt; path.size(); i++) {</span>
<a name="l02032"></a>02032             <span class="comment">//    printCFGNode(path[i], g);</span>
<a name="l02033"></a>02033             <span class="comment">//}</span>
<a name="l02034"></a>02034             <span class="comment">//std::cout &lt;&lt; &quot;printed path&quot; &lt;&lt; std::endl;</span>
<a name="l02035"></a>02035             mkpath.push_back(took);
<a name="l02036"></a>02036             path.push_back(took);
<a name="l02037"></a>02037             <span class="comment">//int currn = new Vertex;</span>
<a name="l02038"></a>02038             currn = took;
<a name="l02039"></a>02039         }
<a name="l02040"></a>02040         <span class="keywordflow">else</span>
<a name="l02041"></a>02041         {
<a name="l02042"></a>02042             <span class="comment">//std::cout &lt;&lt; &quot;loop&quot; &lt;&lt; std::endl;</span>
<a name="l02043"></a>02043 
<a name="l02044"></a>02044             <span class="comment">//std::cout &lt;&lt; &quot;currn&quot; &lt;&lt; std::endl;</span>
<a name="l02045"></a>02045             <span class="comment">//if (nodenums.find(currn) == nodenums.end()) {</span>
<a name="l02046"></a>02046             <span class="comment">//  nodenums[took] = currnodenum++;</span>
<a name="l02047"></a>02047             <span class="comment">// }</span>
<a name="l02048"></a>02048             <span class="comment">//  printCFGNode(currn, g, nodenums[currn]);</span>
<a name="l02049"></a>02049 
<a name="l02050"></a>02050             <span class="comment">//    std::cout &lt;&lt; &quot;took&quot; &lt;&lt; std::endl;</span>
<a name="l02051"></a>02051             <span class="comment">//if (nodenums.find(took) == nodenums.end()) {</span>
<a name="l02052"></a>02052             <span class="comment">//    nodenums[took] = currnodenum++;</span>
<a name="l02053"></a>02053             <span class="comment">//}</span>
<a name="l02054"></a>02054             <span class="comment">// printCFGNode(took, g, nodenums[took]);</span>
<a name="l02055"></a>02055             <span class="comment">//std::cout &lt;&lt; &quot;printing took: &quot; &lt;&lt; std::endl;</span>
<a name="l02056"></a>02056             <span class="comment">//printCFGNode(took, g);</span>
<a name="l02057"></a>02057             <span class="comment">//std::cout &lt;&lt; &quot;printing path&quot; &lt;&lt; std::endl;</span>
<a name="l02058"></a>02058             <span class="comment">//for (int i = 0; i &lt; path.size(); i++) {</span>
<a name="l02059"></a>02059             <span class="comment">//CFG* g1 = *g;</span>
<a name="l02060"></a>02060             <span class="comment">//int c2 = &amp;(*g1[took]);</span>
<a name="l02061"></a>02061             <span class="comment">//    if (i != path.size() - 1) {</span>
<a name="l02062"></a>02062             <span class="comment">//    if (path[i] == path[i+1]) {</span>
<a name="l02063"></a>02063             <span class="comment">//        std::cout &lt;&lt; &quot;self loop&quot; &lt;&lt; std::endl;</span>
<a name="l02064"></a>02064             <span class="comment">//    }</span>
<a name="l02065"></a>02065             <span class="comment">//    }</span>
<a name="l02066"></a>02066             <span class="comment">//    printCFGNode(path[i], g);</span>
<a name="l02067"></a>02067             <span class="comment">//}</span>
<a name="l02068"></a>02068             <span class="comment">//std::cout &lt;&lt; &quot;finding loop&quot; &lt;&lt; std::endl;</span>
<a name="l02069"></a>02069             mkloops.insert(took);
<a name="l02070"></a>02070             std::vector&lt;int&gt; lptemp;
<a name="l02071"></a>02071             lptemp.clear();
<a name="l02072"></a>02072             lptemp.push_back(took);
<a name="l02073"></a>02073             <span class="keywordtype">int</span> loopstep = 0;
<a name="l02074"></a>02074             <span class="keywordflow">while</span> (path.back() != took)
<a name="l02075"></a>02075             {
<a name="l02076"></a>02076                 <span class="comment">//std::cout &lt;&lt; &quot;loopstep = &quot; &lt;&lt; loopstep &lt;&lt; &quot;\n&quot;;</span>
<a name="l02077"></a>02077                 loopstep++;
<a name="l02078"></a>02078                 path.pop_back();
<a name="l02079"></a>02079 
<a name="l02080"></a>02080                 lptemp.push_back(path.back());
<a name="l02081"></a>02081 
<a name="l02082"></a>02082             }
<a name="l02083"></a>02083             <span class="keywordflow">if</span> (<a class="code" href="namespaceSageInterface.html#aff5394b21cf11cd338671af3a11a7f92">find</a>(mkloopmapstore.begin(), mkloopmapstore.end(), lptemp) == mkloopmapstore.end())
<a name="l02084"></a>02084             {
<a name="l02085"></a>02085                 mkloopmapstore.push_back(lptemp);
<a name="l02086"></a>02086                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> lpt = 0; lpt &lt; lptemp.size(); lpt++)
<a name="l02087"></a>02087                 {
<a name="l02088"></a>02088                     <span class="keywordflow">if</span> (mkLoopInt.find(lptemp[lpt]) == mkLoopInt.end())
<a name="l02089"></a>02089                     {
<a name="l02090"></a>02090                         mkLoopInt[lptemp[lpt]] = currmkloopint;
<a name="l02091"></a>02091                         currmkloopint++;
<a name="l02092"></a>02092                     }
<a name="l02093"></a>02093                     <span class="comment">//std::cout &lt;&lt; &quot;--&gt; &quot; &lt;&lt; mkLoopInt[lptemp[lpt]];</span>
<a name="l02094"></a>02094                 }
<a name="l02095"></a>02095                 <span class="comment">//std::cout &lt;&lt; &quot;found loop&quot; &lt;&lt; std::endl;</span>
<a name="l02096"></a>02096                 <span class="comment">//std::cout &lt;&lt; &quot;\n&quot;;</span>
<a name="l02097"></a>02097                 (mkloopmap[took]).insert(lptemp);
<a name="l02098"></a>02098                 loopcount++;
<a name="l02099"></a>02099                 lptemp.clear();
<a name="l02100"></a>02100                 <span class="comment">//std::cout &lt;&lt; &quot;num loops: &quot; &lt;&lt; loopcount &lt;&lt; std::endl;</span>
<a name="l02101"></a>02101 
<a name="l02102"></a>02102             }
<a name="l02103"></a>02103             <span class="keywordflow">else</span>
<a name="l02104"></a>02104             {
<a name="l02105"></a>02105                 <span class="comment">//std::cout &lt;&lt; &quot;found repeat loop&quot; &lt;&lt; std::endl;</span>
<a name="l02106"></a>02106                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> lpt = 0; lpt &lt; lptemp.size(); lpt++)
<a name="l02107"></a>02107                 {
<a name="l02108"></a>02108                     <span class="keywordflow">if</span> (mkLoopInt.find(lptemp[lpt]) == mkLoopInt.end())
<a name="l02109"></a>02109                     {
<a name="l02110"></a>02110                         mkLoopInt[lptemp[lpt]] = currmkloopint;
<a name="l02111"></a>02111                         currmkloopint++;
<a name="l02112"></a>02112                     }
<a name="l02113"></a>02113                     <span class="comment">//    std::cout &lt;&lt; &quot;--&gt; &quot; &lt;&lt; mkLoopInt[lptemp[lpt]];</span>
<a name="l02114"></a>02114                 }
<a name="l02115"></a>02115                 <span class="comment">//std::cout &lt;&lt; &quot;\n&quot;;</span>
<a name="l02116"></a>02116             }
<a name="l02117"></a>02117 
<a name="l02118"></a>02118 
<a name="l02119"></a>02119             <span class="keywordflow">if</span> (lptemp.size() &gt; 1)
<a name="l02120"></a>02120             {
<a name="l02121"></a>02121                 <span class="keywordflow">if</span> (<a class="code" href="namespaceSageInterface.html#aff5394b21cf11cd338671af3a11a7f92">find</a>(looppaths.begin(), looppaths.end(), lptemp) == looppaths.end() &amp;&amp; <a class="code" href="namespaceSageInterface.html#aff5394b21cf11cd338671af3a11a7f92">find</a>(lptemp.begin(), lptemp.end(), st) == lptemp.end() &amp;&amp; <a class="code" href="namespaceSageInterface.html#aff5394b21cf11cd338671af3a11a7f92">find</a>(lptemp.begin(), lptemp.end(), endnode) == lptemp.end())
<a name="l02122"></a>02122                 {
<a name="l02123"></a>02123                     looppaths.push_back(lptemp);
<a name="l02124"></a>02124                     loopnum++;
<a name="l02125"></a>02125                     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; lptemp.size(); i++)
<a name="l02126"></a>02126                     {
<a name="l02127"></a>02127                         loopNumMap[lptemp[i]] = loopnum;
<a name="l02128"></a>02128                     }
<a name="l02129"></a>02129                 }
<a name="l02130"></a>02130             }
<a name="l02131"></a>02131             <span class="comment">//int currn = new Vertex;</span>
<a name="l02132"></a>02132             path.push_back(took);
<a name="l02133"></a>02133             currn = took;
<a name="l02134"></a>02134             mkpath.push_back(took);
<a name="l02135"></a>02135             <span class="comment">/*</span>
<a name="l02136"></a>02136 <span class="comment">                                          std::cout &lt;&lt; &quot;end path&quot; &lt;&lt; std::endl;</span>
<a name="l02137"></a>02137 <span class="comment">                               std::cout &lt;&lt; &quot;took&quot; &lt;&lt; std::endl;</span>
<a name="l02138"></a>02138 <span class="comment">                               CFG gra = *g;</span>
<a name="l02139"></a>02139 <span class="comment">                               Vertex tookv = *took;</span>
<a name="l02140"></a>02140 <span class="comment">                               FilteredCFGNode&lt;CFGNodeFilter2&gt;* tq;</span>
<a name="l02141"></a>02141 <span class="comment">                               tq = &amp;(*gra[tookv]);</span>
<a name="l02142"></a>02142 <span class="comment">                               //if (nodenums.find(tq) == nodenums.end()) {</span>
<a name="l02143"></a>02143 <span class="comment">                               //    nodenums[tq] = currnodenum++;</span>
<a name="l02144"></a>02144 <span class="comment">                              // }</span>
<a name="l02145"></a>02145 <span class="comment">                               printCFGNode(tq,g, 0);</span>
<a name="l02146"></a>02146 <span class="comment">            */</span>
<a name="l02147"></a>02147 
<a name="l02148"></a>02148 
<a name="l02149"></a>02149         }
<a name="l02150"></a>02150 
<a name="l02151"></a>02151 
<a name="l02152"></a>02152     }
<a name="l02153"></a>02153     <span class="keywordflow">return</span>;
<a name="l02154"></a>02154 }
<a name="l02155"></a>02155 
<a name="l02156"></a>02156 <span class="comment">/* END DEBUGGING */</span>
<a name="l02157"></a>02157 
<a name="l02158"></a>02158 <span class="comment">//This function sets up the graph so that the evaluatePath function can easily traverse the paths</span>
<a name="l02159"></a>02159 <span class="comment">/*</span>
<a name="l02160"></a>02160 <span class="comment">template&lt;class InheritedAttributeType, class SynthesizedAttributeType, class CFG&gt;</span>
<a name="l02161"></a>02161 <span class="comment">void</span>
<a name="l02162"></a>02162 <span class="comment">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</span>
<a name="l02163"></a>02163 <span class="comment">solvePaths(CFG* g, int n, int endnode) {</span>
<a name="l02164"></a>02164 <span class="comment">    bool done = false;</span>
<a name="l02165"></a>02165 <span class="comment">    bool edges = true;</span>
<a name="l02166"></a>02166 <span class="comment">    bool tookone = false;</span>
<a name="l02167"></a>02167 <span class="comment">    std::vector&lt;int&gt; mkpath;</span>
<a name="l02168"></a>02168 <span class="comment">    std::vector&lt;int&gt; marks;</span>
<a name="l02169"></a>02169 <span class="comment">    marks.push_back(n);</span>
<a name="l02170"></a>02170 <span class="comment">    mkglobal.push_back(n);</span>
<a name="l02171"></a>02171 <span class="comment">    int currn = n;</span>
<a name="l02172"></a>02172 <span class="comment">    int took;</span>
<a name="l02173"></a>02173 <span class="comment">    std::pair&lt;CFG::CFGEdgePtr, CFG::CFGEdgePtr&gt; taken;</span>
<a name="l02174"></a>02174 <span class="comment">    std::vector&lt;int&gt; toTake;</span>
<a name="l02175"></a>02175 <span class="comment">    std::vector&lt;int&gt; path;</span>
<a name="l02176"></a>02176 <span class="comment">    path.push_back(n);</span>
<a name="l02177"></a>02177 <span class="comment">    mkpath.push_back(n);</span>
<a name="l02178"></a>02178 <span class="comment">    int itr = 0;</span>
<a name="l02179"></a>02179 <span class="comment">    int bifurcations = 0;</span>
<a name="l02180"></a>02180 <span class="comment">    std::map&lt;int, bool&gt; completed;</span>
<a name="l02181"></a>02181 <span class="comment">    while (done == false) {</span>
<a name="l02182"></a>02182 <span class="comment">             ROSE_ASSERT(currn != NULL);</span>
<a name="l02183"></a>02183 <span class="comment">//check to see if we&#39;ve hit the endnode or if we&#39;re done, if not continue, if so push the subpath into the &quot;pathsAtMk&quot; repository</span>
<a name="l02184"></a>02184 <span class="comment">               if (currn == endnode || completed.find(currn) != completed.end()) {</span>
<a name="l02185"></a>02185 <span class="comment">                if (pathsAtMk.find(marks.back()) == pathsAtMk.end()) {</span>
<a name="l02186"></a>02186 <span class="comment">                    std::vector&lt;std::vector&lt;int&gt; &gt; emptypath;</span>
<a name="l02187"></a>02187 <span class="comment">                    pathsAtMk[marks.back()] = emptypath;</span>
<a name="l02188"></a>02188 <span class="comment">                }</span>
<a name="l02189"></a>02189 <span class="comment">                edges = false;</span>
<a name="l02190"></a>02190 <span class="comment">                pathsAtMk[marks.back()].push_back(mkpath);</span>
<a name="l02191"></a>02191 <span class="comment">                //for (int mk = 0; mk &lt; mkpath.size(); mk++) {</span>
<a name="l02192"></a>02192 <span class="comment">                 //   std::pair&lt;CFG::CFGEdgePtr, CFG::CFGEdgePtr&gt; iedg = g-&gt;in_edges(mkpath[mk]);</span>
<a name="l02193"></a>02193 <span class="comment">                    //if (iedg.size() &gt; 1) {</span>
<a name="l02194"></a>02194 <span class="comment">                    //    ploops.insert(mkpath[mk]);</span>
<a name="l02195"></a>02195 <span class="comment">                   // }</span>
<a name="l02196"></a>02196 <span class="comment">                //}</span>
<a name="l02197"></a>02197 <span class="comment">                ROSE_ASSERT(mkpath.front() == marks.back());</span>
<a name="l02198"></a>02198 <span class="comment">                if (marks.size() == 0) {</span>
<a name="l02199"></a>02199 <span class="comment">                    return;</span>
<a name="l02200"></a>02200 <span class="comment">                }</span>
<a name="l02201"></a>02201 <span class="comment">                mkpath.clear();</span>
<a name="l02202"></a>02202 <span class="comment">                bool y = true;</span>
<a name="l02203"></a>02203 <span class="comment">                bool haventtaken = false;</span>
<a name="l02204"></a>02204 <span class="comment">                bool p = true;</span>
<a name="l02205"></a>02205 <span class="comment">                int place;</span>
<a name="l02206"></a>02206 <span class="comment">                bool found = false;</span>
<a name="l02207"></a>02207 <span class="comment">                while (found == false) {</span>
<a name="l02208"></a>02208 <span class="comment">                    if (marks.size() == 0) {</span>
<a name="l02209"></a>02209 <span class="comment">                        return;</span>
<a name="l02210"></a>02210 <span class="comment">                    }</span>
<a name="l02211"></a>02211 <span class="comment">                    CFG::CFGEdgePtr tooked;</span>
<a name="l02212"></a>02212 <span class="comment">                    int mark1 = marks.back();</span>
<a name="l02213"></a>02213 <span class="comment">                    std::pair&lt;CFG::CFGEdgePtr, CFG::CFGEdgePtr&gt; oedg = g-&gt;out_edges(mark1);</span>
<a name="l02214"></a>02214 <span class="comment">                    ROSE_ASSERT(oedg.size() &gt; 1 || mark1 == n);</span>
<a name="l02215"></a>02215 <span class="comment">                        for (std::pair&lt;CFG::CFGEdgePtr, CFG::CFGEdgePtr&gt;::iterator j = oedg.begin(); j != oedg.end(); j++) {</span>
<a name="l02216"></a>02216 <span class="comment">                            if (taken.find(*j) == taken.end() &amp;&amp; haventtaken == false) {</span>
<a name="l02217"></a>02217 <span class="comment">                                tooked = *j;</span>
<a name="l02218"></a>02218 <span class="comment">                                haventtaken = true;</span>
<a name="l02219"></a>02219 <span class="comment">                            }</span>
<a name="l02220"></a>02220 <span class="comment">                        }</span>
<a name="l02221"></a>02221 <span class="comment">                       // if (mkpath.back() == mkpath.front() &amp;&amp; mkpath.size() &gt; 1) {</span>
<a name="l02222"></a>02222 <span class="comment">                       //      ROSE_ASSERT(false);</span>
<a name="l02223"></a>02223 <span class="comment">                       // }</span>
<a name="l02224"></a>02224 <span class="comment">                        if (haventtaken == true) {</span>
<a name="l02225"></a>02225 <span class="comment">                            if (marks.back() == n) {</span>
<a name="l02226"></a>02226 <span class="comment">                                path.clear();</span>
<a name="l02227"></a>02227 <span class="comment">                            }</span>
<a name="l02228"></a>02228 <span class="comment">                            path.push_back(marks.back());</span>
<a name="l02229"></a>02229 <span class="comment">                            if (mkpath.back() != marks.back()) {</span>
<a name="l02230"></a>02230 <span class="comment">                            mkpath.push_back(marks.back());</span>
<a name="l02231"></a>02231 <span class="comment">                            }</span>
<a name="l02232"></a>02232 <span class="comment">                            taken.insert(tooked);</span>
<a name="l02233"></a>02233 <span class="comment">                            took = tooked-&gt;get_to();</span>
<a name="l02234"></a>02234 <span class="comment">                            found = true;</span>
<a name="l02235"></a>02235 <span class="comment">                        }</span>
<a name="l02236"></a>02236 <span class="comment">                        else {</span>
<a name="l02237"></a>02237 <span class="comment">                            completed[marks.back()] = true;</span>
<a name="l02238"></a>02238 <span class="comment">                            bifurcations++;</span>
<a name="l02239"></a>02239 <span class="comment">                            marks.pop_back();</span>
<a name="l02240"></a>02240 <span class="comment">                        }</span>
<a name="l02241"></a>02241 <span class="comment">                    }</span>
<a name="l02242"></a>02242 <span class="comment">                    if (marks.size() == 0) {</span>
<a name="l02243"></a>02243 <span class="comment">                        return;</span>
<a name="l02244"></a>02244 <span class="comment">                    }</span>
<a name="l02245"></a>02245 <span class="comment">                    haventtaken = false;</span>
<a name="l02246"></a>02246 <span class="comment">                    found = false;</span>
<a name="l02247"></a>02247 <span class="comment"></span>
<a name="l02248"></a>02248 <span class="comment">             }</span>
<a name="l02249"></a>02249 <span class="comment">//if we haven&#39;t reached the endnode or completed, continue down the graph</span>
<a name="l02250"></a>02250 <span class="comment">             else {</span>
<a name="l02251"></a>02251 <span class="comment">            std::pair&lt;CFG::CFGEdgePtr, CFG::CFGEdgePtr&gt; oedg = g-&gt;out_edges(currn);</span>
<a name="l02252"></a>02252 <span class="comment">            std::pair&lt;CFG::CFGEdgePtr, CFG::CFGEdgePtr&gt; iedg = g-&gt;in_edges(currn);</span>
<a name="l02253"></a>02253 <span class="comment">            if (oedg.size() &gt; 1) {</span>
<a name="l02254"></a>02254 <span class="comment">                     if (mkpath.back() != currn) {</span>
<a name="l02255"></a>02255 <span class="comment">                     mkpath.push_back(currn);</span>
<a name="l02256"></a>02256 <span class="comment">                     }</span>
<a name="l02257"></a>02257 <span class="comment">                     pathsAtMk[marks.back()].push_back(mkpath);</span>
<a name="l02258"></a>02258 <span class="comment">                     mkpath.clear();</span>
<a name="l02259"></a>02259 <span class="comment">                     mkpath.push_back(currn);</span>
<a name="l02260"></a>02260 <span class="comment">                     marks.push_back(currn);</span>
<a name="l02261"></a>02261 <span class="comment">                     if (find(mkglobal.begin(), mkglobal.end(), currn) == mkglobal.end()) {</span>
<a name="l02262"></a>02262 <span class="comment">                         mkglobal.push_back(currn);</span>
<a name="l02263"></a>02263 <span class="comment">                     }</span>
<a name="l02264"></a>02264 <span class="comment">                     for (std::pair&lt;CFG::CFGEdgePtr, CFG::CFGEdgePtr&gt;::iterator i = oedg.begin(); i != oedg.end(); i++) {</span>
<a name="l02265"></a>02265 <span class="comment">                          if (taken.find(*i) == taken.end() &amp;&amp; tookone == false) {</span>
<a name="l02266"></a>02266 <span class="comment">                               taken.insert(*i);</span>
<a name="l02267"></a>02267 <span class="comment">                               tookone = true;</span>
<a name="l02268"></a>02268 <span class="comment">                               took = (*i)-&gt;get_to();</span>
<a name="l02269"></a>02269 <span class="comment">                          }</span>
<a name="l02270"></a>02270 <span class="comment">                          else if (taken.find(*i) == taken.end() &amp;&amp; tookone == true) {</span>
<a name="l02271"></a>02271 <span class="comment">                               //toTake.push_back((*i)-&gt;get_to());</span>
<a name="l02272"></a>02272 <span class="comment">                          }</span>
<a name="l02273"></a>02273 <span class="comment">                   }</span>
<a name="l02274"></a>02274 <span class="comment">                   tookone = false;</span>
<a name="l02275"></a>02275 <span class="comment">           }</span>
<a name="l02276"></a>02276 <span class="comment">           else {</span>
<a name="l02277"></a>02277 <span class="comment">                took = (*(oedg.begin()))-&gt;get_to();</span>
<a name="l02278"></a>02278 <span class="comment">           }</span>
<a name="l02279"></a>02279 <span class="comment">           }</span>
<a name="l02280"></a>02280 <span class="comment">           itr++;</span>
<a name="l02281"></a>02281 <span class="comment"></span>
<a name="l02282"></a>02282 <span class="comment">           if (find(path.begin(), path.end(), took) == path.end()) {</span>
<a name="l02283"></a>02283 <span class="comment">               mkpath.push_back(took);</span>
<a name="l02284"></a>02284 <span class="comment">               path.push_back(took);</span>
<a name="l02285"></a>02285 <span class="comment">               currn = took;</span>
<a name="l02286"></a>02286 <span class="comment">           }</span>
<a name="l02287"></a>02287 <span class="comment">           else {</span>
<a name="l02288"></a>02288 <span class="comment">               mkloops.insert(took);</span>
<a name="l02289"></a>02289 <span class="comment">               std::vector&lt;int&gt; lptemp;</span>
<a name="l02290"></a>02290 <span class="comment">               lptemp.clear();</span>
<a name="l02291"></a>02291 <span class="comment">               lptemp.push_back(took);</span>
<a name="l02292"></a>02292 <span class="comment">               while (path.back() != took) {</span>
<a name="l02293"></a>02293 <span class="comment"></span>
<a name="l02294"></a>02294 <span class="comment">                   path.pop_back();</span>
<a name="l02295"></a>02295 <span class="comment"></span>
<a name="l02296"></a>02296 <span class="comment">                   lptemp.push_back(path.back());</span>
<a name="l02297"></a>02297 <span class="comment"></span>
<a name="l02298"></a>02298 <span class="comment">               }</span>
<a name="l02299"></a>02299 <span class="comment">               (mkloopmap[took]).insert(lptemp);</span>
<a name="l02300"></a>02300 <span class="comment"></span>
<a name="l02301"></a>02301 <span class="comment">               if (lptemp.size() &gt; 1) {</span>
<a name="l02302"></a>02302 <span class="comment">               if (find(looppaths.begin(), looppaths.end(), lptemp) == looppaths.end() &amp;&amp; find(lptemp.begin(), lptemp.end(), st) == lptemp.end() &amp;&amp; find(lptemp.begin(), lptemp.end(), endnode) == lptemp.end()) {</span>
<a name="l02303"></a>02303 <span class="comment">                   looppaths.push_back(lptemp);</span>
<a name="l02304"></a>02304 <span class="comment">                   loopnum++;</span>
<a name="l02305"></a>02305 <span class="comment">                   for (unsigned int i = 0; i &lt; lptemp.size(); i++) {</span>
<a name="l02306"></a>02306 <span class="comment">                       loopNumMap[lptemp[i]] = loopnum;</span>
<a name="l02307"></a>02307 <span class="comment">                   }</span>
<a name="l02308"></a>02308 <span class="comment">               }</span>
<a name="l02309"></a>02309 <span class="comment">               }</span>
<a name="l02310"></a>02310 <span class="comment"></span>
<a name="l02311"></a>02311 <span class="comment">               path.push_back(took);</span>
<a name="l02312"></a>02312 <span class="comment">               currn = path.back();</span>
<a name="l02313"></a>02313 <span class="comment">               mkpath.push_back(took);</span>
<a name="l02314"></a>02314 <span class="comment">           }</span>
<a name="l02315"></a>02315 <span class="comment"></span>
<a name="l02316"></a>02316 <span class="comment"></span>
<a name="l02317"></a>02317 <span class="comment">}</span>
<a name="l02318"></a>02318 <span class="comment">           return;</span>
<a name="l02319"></a>02319 <span class="comment">}</span>
<a name="l02320"></a>02320 <span class="comment">*/</span>
<a name="l02321"></a>02321 <span class="comment">//not currently useful</span>
<a name="l02322"></a>02322 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l02323"></a>02323 SynthesizedAttributeType
<a name="l02324"></a>02324 <a class="code" href="classSgGraphTraversal.html#a518fd34370e6be9c357524280421d7e9">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l02325"></a><a class="code" href="classSgGraphTraversal.html#a518fd34370e6be9c357524280421d7e9">02325</a> <a class="code" href="classSgGraphTraversal.html#a518fd34370e6be9c357524280421d7e9">defaultSynthesizedAttribute</a>(InheritedAttributeType inh)
<a name="l02326"></a>02326 {
<a name="l02327"></a>02327     SynthesizedAttributeType s = SynthesizedAttributeType();
<a name="l02328"></a>02328     <span class="keywordflow">return</span> s;
<a name="l02329"></a>02329 }
<a name="l02330"></a>02330 
<a name="l02331"></a>02331 
<a name="l02332"></a>02332 <span class="comment">//computes the order in which to evaluate the nodes in nodal analysis so that you don&#39;t evaluate a node before you evaluate its parents</span>
<a name="l02333"></a>02333 
<a name="l02347"></a>02347 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l02348"></a>02348 <span class="keywordtype">void</span>
<a name="l02349"></a>02349 <a class="code" href="classSgGraphTraversal.html#ae984130d098c298843f480cd7a818542" title="This is the function that is used by the user directly to start the algorithm.">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l02350"></a><a class="code" href="classSgGraphTraversal.html#ae984130d098c298843f480cd7a818542">02350</a> <a class="code" href="classSgGraphTraversal.html#ae984130d098c298843f480cd7a818542" title="This is the function that is used by the user directly to start the algorithm.">computeOrder</a>(<span class="keyword">const</span> CFG*&amp; g, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; endnode)
<a name="l02351"></a>02351 {
<a name="l02352"></a>02352     std::map&lt;int, int&gt; incomputables;
<a name="l02353"></a>02353     std::set&lt;int&gt; lpposs;
<a name="l02354"></a>02354     <span class="comment">//std::set&lt;int&gt; lps;</span>
<a name="l02355"></a>02355     <span class="keywordtype">int</span> currn;
<a name="l02356"></a>02356     currn = n;
<a name="l02357"></a>02357     <span class="keywordtype">int</span> orders = 0;
<a name="l02358"></a>02358     <span class="keywordflow">while</span> (<span class="keyword">true</span>)
<a name="l02359"></a>02359     {
<a name="l02360"></a>02360         <span class="comment">//std::cout &lt;&lt; &quot;currn = &quot; &lt;&lt; currn;</span>
<a name="l02361"></a>02361         <span class="comment">//fg</span>
<a name="l02362"></a>02362 <span class="comment">//std::vector&lt;InheritedAttributeType&gt; inh;</span>
<a name="l02363"></a>02363         <span class="comment">//evaluateInheritedAttribute(currn, inh);</span>
<a name="l02364"></a>02364         <span class="comment">//if (orders % 10000 == 0) {</span>
<a name="l02365"></a>02365         <span class="comment">//  std::cout &lt;&lt; &quot;orders: &quot; &lt;&lt; orders &lt;&lt; std::endl;</span>
<a name="l02366"></a>02366         <span class="comment">//}</span>
<a name="l02367"></a>02367         orders++;
<a name="l02368"></a>02368         <span class="keywordflow">if</span> (currn == endnode)
<a name="l02369"></a>02369         {
<a name="l02370"></a>02370         }
<a name="l02371"></a>02371         <span class="comment">// int currnC = currn;</span>
<a name="l02372"></a>02372         <span class="keywordflow">if</span> (computable(g, currn) || currn == n)
<a name="l02373"></a>02373         {
<a name="l02374"></a>02374             <span class="keywordtype">int</span> mp;
<a name="l02375"></a>02375             <span class="keywordflow">if</span> (oVals.find(currn) == oVals.end())
<a name="l02376"></a>02376             {
<a name="l02377"></a>02377                 oVals[currn] = currm++;
<a name="l02378"></a>02378                 iVals[currm++] = currn;
<a name="l02379"></a>02379                 currm += 1;
<a name="l02380"></a>02380             }
<a name="l02381"></a>02381             <span class="keywordflow">if</span> (currn == endnode)
<a name="l02382"></a>02382             {
<a name="l02383"></a>02383                 ROSE_ASSERT(computable(g, endnode));
<a name="l02384"></a>02384                 <span class="comment">//oVals[endnode] = currm++;</span>
<a name="l02385"></a>02385                 <span class="comment">//iVals[currm++] = endnode;</span>
<a name="l02386"></a>02386                 <span class="comment">//currm += 1;</span>
<a name="l02387"></a>02387                 <span class="comment">//std::cout &lt;&lt; &quot;currm: &quot; &lt;&lt; currm &lt;&lt; std::endl;</span>
<a name="l02388"></a>02388                 <span class="keywordflow">break</span>;
<a name="l02389"></a>02389             }
<a name="l02390"></a>02390             std::pair&lt;bool, int&gt; pbs = getNextChild(g, currn);
<a name="l02391"></a>02391             computedNodes.insert(currn);
<a name="l02392"></a>02392             ROSE_ASSERT(pbs.first == <span class="keyword">true</span>);
<a name="l02393"></a>02393             currn = pbs.second;
<a name="l02394"></a>02394         }
<a name="l02395"></a>02395         <span class="keywordflow">else</span>
<a name="l02396"></a>02396         {
<a name="l02397"></a>02397             std::pair&lt;bool, int&gt; pbp = getNextPar(g, currn);
<a name="l02398"></a>02398             ROSE_ASSERT(pbp.first == <span class="keyword">true</span>);
<a name="l02399"></a>02399 <span class="comment">//            ROSE_ASSERT(pbp.second != NULL);</span>
<a name="l02400"></a>02400             currn = pbp.second;
<a name="l02401"></a>02401 
<a name="l02402"></a>02402         }
<a name="l02403"></a>02403 
<a name="l02404"></a>02404     }
<a name="l02405"></a>02405     std::cout &lt;&lt; <span class="stringliteral">&quot;required orders&quot;</span> &lt;&lt; orders &lt;&lt; std::endl;
<a name="l02406"></a>02406     <span class="comment">//std::cout &lt;&lt; &quot;incomputables.size() &quot; &lt;&lt; incomputables.size() &lt;&lt; std::endl;</span>
<a name="l02407"></a>02407 }
<a name="l02408"></a>02408 
<a name="l02409"></a>02409 
<a name="l02410"></a>02410 
<a name="l02411"></a>02411 
<a name="l02412"></a>02412 
<a name="l02413"></a>02413 
<a name="l02414"></a>02414 
<a name="l02415"></a>02415 
<a name="l02416"></a>02416 
<a name="l02417"></a>02417 
<a name="l02418"></a>02418 <span class="comment">//simple fucntion to check the computability under nodal analysis</span>
<a name="l02419"></a>02419 
<a name="l02431"></a>02431 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l02432"></a>02432 <span class="keywordtype">bool</span>
<a name="l02433"></a>02433 <a class="code" href="classSgGraphTraversal.html#aea7df8b5b0fbc8f50e5e328634b24137" title="Checks whether or not the node can be computed for InheritedAttribute evaluation.">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l02434"></a><a class="code" href="classSgGraphTraversal.html#aea7df8b5b0fbc8f50e5e328634b24137">02434</a> <a class="code" href="classSgGraphTraversal.html#aea7df8b5b0fbc8f50e5e328634b24137" title="Checks whether or not the node can be computed for InheritedAttribute evaluation.">computable</a>(<span class="keyword">const</span> CFG* &amp;g, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;n)
<a name="l02435"></a>02435 {
<a name="l02436"></a>02436     <span class="keywordflow">if</span> (computedNodes.find(n) != computedNodes.end())
<a name="l02437"></a>02437     {
<a name="l02438"></a>02438         <span class="comment">//std::cout &lt;&lt; &quot;already known value&quot; &lt;&lt; std::endl;</span>
<a name="l02439"></a>02439         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02440"></a>02440     }
<a name="l02441"></a>02441     <span class="comment">//std::pair&lt;CFG::CFGEdgePtr, CFG::CFGEdgePtr&gt; ed = boost::in_edges(g-&gt;getVertex**ForNode(*n), *g);</span>
<a name="l02442"></a>02442     <span class="keywordtype">bool</span> comp = <span class="keyword">true</span>;
<a name="l02443"></a>02443     <span class="comment">//in_edge_iterator i, j;</span>
<a name="l02444"></a>02444     <span class="keywordtype">int</span> took;
<a name="l02445"></a>02445     <span class="comment">//int* vt;</span>
<a name="l02446"></a>02446     <span class="comment">//CFG* gra = *g;</span>
<a name="l02447"></a>02447     <span class="comment">//int* took;</span>
<a name="l02448"></a>02448     <span class="comment">//Edge* ted;</span>
<a name="l02449"></a>02449     std::vector&lt;int&gt; ieds = getInEdges(n, g);
<a name="l02450"></a>02450     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ieds.size(); i++)
<a name="l02451"></a>02451     {
<a name="l02452"></a>02452         took = getSource(ieds[i], g);
<a name="l02453"></a>02453         <span class="comment">//vt = tookv;</span>
<a name="l02454"></a>02454         <span class="comment">//took = &amp;(*gra[&amp;boost::source(*i, *g)]);</span>
<a name="l02455"></a>02455         <span class="comment">//ted = &amp;(*gra[*i]);</span>
<a name="l02456"></a>02456         <span class="comment">//std::pair&lt;int*, int*&gt; pairnodes;</span>
<a name="l02457"></a>02457         <span class="comment">//*ted = *i;</span>
<a name="l02458"></a>02458         <span class="keywordflow">if</span> (oVals.find(took) == oVals.end() &amp;&amp; nullEdgesOrdered.find(ieds[i]) == nullEdgesOrdered.end())
<a name="l02459"></a>02459         {
<a name="l02460"></a>02460             comp = <span class="keyword">false</span>;
<a name="l02461"></a>02461         }
<a name="l02462"></a>02462     }
<a name="l02463"></a>02463     <span class="keywordflow">if</span> (comp)
<a name="l02464"></a>02464     {
<a name="l02465"></a>02465         <span class="comment">//std::cout &lt;&lt; &quot;computable&quot; &lt;&lt; std::endl;</span>
<a name="l02466"></a>02466     }
<a name="l02467"></a>02467     <span class="keywordflow">else</span>
<a name="l02468"></a>02468     {
<a name="l02469"></a>02469         <span class="comment">//std::cout &lt;&lt; &quot;incomputable&quot; &lt;&lt; std::endl;</span>
<a name="l02470"></a>02470         <span class="comment">//std::cout &lt;&lt; &quot;node is:&quot; &lt;&lt; std::endl;</span>
<a name="l02471"></a>02471         <span class="comment">//printCFGNode(n, g, -2);</span>
<a name="l02472"></a>02472     }
<a name="l02473"></a>02473     <span class="keywordflow">return</span> comp;
<a name="l02474"></a>02474 }
<a name="l02475"></a>02475 
<a name="l02476"></a>02476 
<a name="l02477"></a>02477 <span class="comment">//computes the inherited attribute values in nodal analysis</span>
<a name="l02478"></a>02478 
<a name="l02491"></a>02491 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l02492"></a>02492 <span class="keywordtype">void</span>
<a name="l02493"></a>02493 <a class="code" href="classSgGraphTraversal.html#ac025d6d43427e39209560ec3ac1e8833" title="computes the InheritedAttribute values on each of the nodes">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l02494"></a><a class="code" href="classSgGraphTraversal.html#ac025d6d43427e39209560ec3ac1e8833">02494</a> <a class="code" href="classSgGraphTraversal.html#ac025d6d43427e39209560ec3ac1e8833" title="computes the InheritedAttribute values on each of the nodes">computeInheritedOrdered</a>(<span class="keyword">const</span> CFG* &amp;g, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;n)
<a name="l02495"></a>02495 {
<a name="l02496"></a>02496     <span class="keywordtype">int</span> runs = 0;
<a name="l02497"></a>02497 <span class="comment">//    std::ofstream mf;</span>
<a name="l02498"></a>02498 <span class="comment">//    mf.open(&quot;analysis.dot&quot;);</span>
<a name="l02499"></a>02499 <span class="comment">//    mf &lt;&lt; &quot;digraph defaultName { \n&quot;;</span>
<a name="l02500"></a>02500     <span class="comment">//std::cout &lt;&lt; &quot;iVals.size(): &quot; &lt;&lt; iVals.size() &lt;&lt; std::endl;</span>
<a name="l02501"></a>02501     <span class="keywordflow">for</span> (std::map&lt;int, int&gt;::iterator i = iVals.begin(); i != iVals.end(); i++)
<a name="l02502"></a>02502     {
<a name="l02503"></a>02503         runs++;
<a name="l02504"></a>02504         ROSE_ASSERT(canEval(g, (*i).second));
<a name="l02505"></a>02505         <span class="comment">//setPathVal(g, n);</span>
<a name="l02506"></a>02506         <span class="comment">//printNodePlusEdgesForAnalysis(g, (*i).second, loopNumMap[(*i).second], pathValMap[(*i).second], mf);</span>
<a name="l02507"></a>02507         evalNodeOrdered(g, (*i).second);
<a name="l02508"></a>02508     }
<a name="l02509"></a>02509 }
<a name="l02510"></a>02510 
<a name="l02522"></a>02522 <span class="comment">//checks to see if evaluation is possible under nodal analysis</span>
<a name="l02523"></a>02523 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l02524"></a>02524 <span class="keywordtype">bool</span>
<a name="l02525"></a>02525 <a class="code" href="classSgGraphTraversal.html#abb4e5a24cad4e13c6e040df8ae60ba9b" title="Checks whether or not the node can be evaluated (deprecated)">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l02526"></a><a class="code" href="classSgGraphTraversal.html#abb4e5a24cad4e13c6e040df8ae60ba9b">02526</a> <a class="code" href="classSgGraphTraversal.html#abb4e5a24cad4e13c6e040df8ae60ba9b" title="Checks whether or not the node can be evaluated (deprecated)">canEval</a>(<span class="keyword">const</span> CFG* &amp; g, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; n)
<a name="l02527"></a>02527 {
<a name="l02528"></a>02528     <span class="keywordtype">bool</span> evaled = <span class="keyword">true</span>;
<a name="l02529"></a>02529     <span class="comment">//Edge* ted;</span>
<a name="l02530"></a>02530     <span class="keywordflow">if</span> (inhVals.find(n) == inhVals.end())
<a name="l02531"></a>02531     {
<a name="l02532"></a>02532         <span class="comment">//std::pair&lt;CFG::CFGEdgePtr, CFG::CFGEdgePtr&gt; ins = boost::in_edges(g-&gt;getVertex**ForNode(*n), *g);</span>
<a name="l02533"></a>02533         std::vector&lt;int&gt; ieds = getInEdges(n, g);
<a name="l02534"></a>02534         <span class="comment">//in_edge_iterator i, j;</span>
<a name="l02535"></a>02535         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ieds.size(); i++)
<a name="l02536"></a>02536         {
<a name="l02537"></a>02537             <span class="comment">//int* tookv = &amp;boost::source(*i, *g);</span>
<a name="l02538"></a>02538             <span class="comment">//int* vt = tookv;</span>
<a name="l02539"></a>02539             <span class="comment">//CFG* gra = *g;</span>
<a name="l02540"></a>02540             <span class="keywordtype">int</span> bs = getSource(ieds[i], g);
<a name="l02541"></a>02541             <span class="keywordflow">if</span> (inhVals.find(bs) == inhVals.end() &amp;&amp; nullEdgesOrdered.find(ieds[i]) == nullEdgesOrdered.end())
<a name="l02542"></a>02542             {
<a name="l02543"></a>02543                 evaled = <span class="keyword">false</span>;
<a name="l02544"></a>02544             }
<a name="l02545"></a>02545         }
<a name="l02546"></a>02546     }
<a name="l02547"></a>02547     <span class="keywordflow">return</span> evaled;
<a name="l02548"></a>02548 }
<a name="l02549"></a>02549 
<a name="l02550"></a>02550 
<a name="l02551"></a>02551 
<a name="l02552"></a>02552 <span class="comment">//actually does the evaluation</span>
<a name="l02563"></a>02563 <span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l02564"></a>02564 <span class="keywordtype">void</span>
<a name="l02565"></a>02565 <a class="code" href="classSgGraphTraversal.html#adb0bdc7cf8fe6c427f1aeb748a20ba33" title="evaluates the node directly, used within computeInheritedOrdered SgGraphTraversal::evalNodeOrdered In...">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l02566"></a><a class="code" href="classSgGraphTraversal.html#adb0bdc7cf8fe6c427f1aeb748a20ba33">02566</a> <a class="code" href="classSgGraphTraversal.html#adb0bdc7cf8fe6c427f1aeb748a20ba33" title="evaluates the node directly, used within computeInheritedOrdered SgGraphTraversal::evalNodeOrdered In...">evalNodeOrdered</a>(<span class="keyword">const</span> CFG* &amp;g, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;n)
<a name="l02567"></a>02567 {
<a name="l02568"></a>02568     <span class="keywordflow">if</span> (inhVals.find(n) != inhVals.end())
<a name="l02569"></a>02569     {
<a name="l02570"></a>02570         <span class="keywordflow">return</span>;
<a name="l02571"></a>02571     }
<a name="l02572"></a>02572     InheritedAttributeType inhX;
<a name="l02573"></a>02573     <span class="comment">//std::pair&lt;CFG::CFGEdgePtr, CFG::CFGEdgePtr&gt; par = boost::in_edges(g-&gt;getVertex**ForNode(*n), *g);</span>
<a name="l02574"></a>02574     std::vector&lt;int&gt; ieds = getInEdges(n, g);
<a name="l02575"></a>02575     std::vector&lt;InheritedAttributeType&gt; inh;
<a name="l02576"></a>02576     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ieds.size(); i++)
<a name="l02577"></a>02577     {
<a name="l02578"></a>02578         <span class="comment">//int* tookv = &amp;boost::source(*i, *g);</span>
<a name="l02579"></a>02579         <span class="comment">//int* vt = tookv;</span>
<a name="l02580"></a>02580         <span class="keywordtype">int</span> bs;
<a name="l02581"></a>02581         bs = getSource(ieds[i], g);
<a name="l02582"></a>02582 
<a name="l02583"></a>02583         <span class="keywordflow">if</span> (inhVals.find(bs) != inhVals.end())
<a name="l02584"></a>02584         {
<a name="l02585"></a>02585             inh.push_back(inhVals[bs]);
<a name="l02586"></a>02586         }
<a name="l02587"></a>02587         <span class="keywordflow">else</span>
<a name="l02588"></a>02588         {
<a name="l02589"></a>02589             <span class="comment">//std::cout &lt;&lt; &quot;no inhval found&quot; &lt;&lt; std::endl;</span>
<a name="l02590"></a>02590         }
<a name="l02591"></a>02591     }
<a name="l02592"></a>02592 
<a name="l02593"></a>02593     <span class="keywordflow">if</span> (n != st || inh.size() &gt; 0)
<a name="l02594"></a>02594     {
<a name="l02595"></a>02595         <a class="code" href="classSgGraphTraversal.html#a3347055fc33f2c5105a567f9798f6a5c">Vertex</a> v = intvertmap[n];
<a name="l02596"></a>02596         inhX = evaluateInheritedAttribute(v, inh);
<a name="l02597"></a>02597         inhVals[n] = inhX;
<a name="l02598"></a>02598     }
<a name="l02599"></a>02599     <span class="comment">//std::cout &lt;&lt; &quot;num of inhVals: &quot; &lt;&lt; inh.size() &lt;&lt; std::endl;</span>
<a name="l02600"></a>02600 
<a name="l02601"></a>02601 }
<a name="l02602"></a>02602 
<a name="l02603"></a>02603 
<a name="l02604"></a>02604 <span class="comment">//debugging function, currently not useful for the end user</span>
<a name="l02605"></a>02605 <span class="comment">/*</span>
<a name="l02606"></a>02606 <span class="comment">template &lt;class InheritedAttributeType, class SynthesizedAttributeType, class CFG&gt;</span>
<a name="l02607"></a>02607 <span class="comment">void</span>
<a name="l02608"></a>02608 <span class="comment">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</span>
<a name="l02609"></a>02609 <span class="comment">setPathVal(CFG* g, int* currn) {</span>
<a name="l02610"></a>02610 <span class="comment">       if (pathValMap.find(currn) != pathValMap.end()) {</span>
<a name="l02611"></a>02611 <span class="comment">           return;</span>
<a name="l02612"></a>02612 <span class="comment">       }</span>
<a name="l02613"></a>02613 <span class="comment">       //std::pair&lt;CFG::CFGEdgePtr, CFG::CFGEdgePtr&gt; ined = boost::in_edges(g-&gt;getVertex**ForNode(*currn), *g);</span>
<a name="l02614"></a>02614 <span class="comment">       int tmppathcount = 0;</span>
<a name="l02615"></a>02615 <span class="comment">       in_edge_iterator i, j;</span>
<a name="l02616"></a>02616 <span class="comment">       //cout &lt;&lt; &quot;inedges = &quot; &lt;&lt; j - i &lt;&lt; std::endl;</span>
<a name="l02617"></a>02617 <span class="comment">       for (boost::tie(i, j) = boost::in_edges(g-&gt;getVertex**ForNode(*currn), *g); i != j; ++i) {</span>
<a name="l02618"></a>02618 <span class="comment">            //int* tookv = &amp;boost::source(*i, *g);</span>
<a name="l02619"></a>02619 <span class="comment">            //int* vt = tookv;</span>
<a name="l02620"></a>02620 <span class="comment">            CFG* gra = *g;</span>
<a name="l02621"></a>02621 <span class="comment">            int* bs = &amp;(*gra[&amp;boost::source(*i, *g)]);</span>
<a name="l02622"></a>02622 <span class="comment"></span>
<a name="l02623"></a>02623 <span class="comment">           ROSE_ASSERT(pathValMap.find(bs) != pathValMap.end() /*|| nullEdgesOrdered.find(*i) != nullEdgesOrdered.end());</span>
<a name="l02624"></a>02624 <span class="comment">            //if (nullEdgesOrdered.find(*i) != nullEdgesOrdered.end()) {</span>
<a name="l02625"></a>02625 <span class="comment">            //    pathValMap[(*i)-&gt;get_from()] = 0;</span>
<a name="l02626"></a>02626 <span class="comment">           // }</span>
<a name="l02627"></a>02627 <span class="comment">            int pv = pathValMap[bs];</span>
<a name="l02628"></a>02628 <span class="comment">            if (pv != 0) {</span>
<a name="l02629"></a>02629 <span class="comment">            tmppathcount += pv;</span>
<a name="l02630"></a>02630 <span class="comment">            }</span>
<a name="l02631"></a>02631 <span class="comment">        }</span>
<a name="l02632"></a>02632 <span class="comment">        pathValMap[currn] = tmppathcount;</span>
<a name="l02633"></a>02633 <span class="comment">        return;</span>
<a name="l02634"></a>02634 <span class="comment">    }</span>
<a name="l02635"></a>02635 <span class="comment">*/</span>
<a name="l02636"></a>02636 
<a name="l02637"></a>02637 <span class="comment">//computes the next child to be analyzed in nodal analysis</span>
<a name="l02650"></a>02650 <span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l02651"></a>02651 std::pair&lt;bool, int&gt;
<a name="l02652"></a>02652 <a class="code" href="classSgGraphTraversal.html#a202ad77e0c9f4edfe12b1e348d811c88" title="computes the next child node to evaluate, used in computing inheritedAttributes, picks the child that...">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l02653"></a><a class="code" href="classSgGraphTraversal.html#a202ad77e0c9f4edfe12b1e348d811c88">02653</a> <a class="code" href="classSgGraphTraversal.html#a202ad77e0c9f4edfe12b1e348d811c88" title="computes the next child node to evaluate, used in computing inheritedAttributes, picks the child that...">getNextChild</a>(<span class="keyword">const</span> CFG* &amp;g, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;n)
<a name="l02654"></a>02654 {
<a name="l02655"></a>02655     <span class="keywordtype">bool</span> nullPoss = <span class="keyword">false</span>;
<a name="l02656"></a>02656     <span class="comment">//std::cout &lt;&lt; &quot;nextChild&quot; &lt;&lt; std::endl;</span>
<a name="l02657"></a>02657     <span class="comment">//std::pair&lt;CFG::CFGEdgePtr, CFG::CFGEdgePtr&gt; outs = boost::out_edges(g-&gt;getVertex**ForNode(*n), *g);</span>
<a name="l02658"></a>02658     <span class="comment">//std::cout &lt;&lt; &quot;outs.size(): &quot; &lt;&lt; outs.size() &lt;&lt; std::endl;</span>
<a name="l02659"></a>02659     <span class="comment">//std::cout &lt;&lt; &quot;outs: &quot; &lt;&lt; outs.size() &lt;&lt; std::endl;</span>
<a name="l02660"></a>02660     <span class="comment">//int* nextNode;</span>
<a name="l02661"></a>02661     <span class="keywordtype">int</span> nullNode = -1;
<a name="l02662"></a>02662     <span class="keywordtype">int</span> prepNextNode;
<a name="l02663"></a>02663     <span class="comment">//Edge* ted;</span>
<a name="l02664"></a>02664 
<a name="l02665"></a>02665     <span class="keywordtype">bool</span> completed = <span class="keyword">false</span>;
<a name="l02666"></a>02666     <span class="keywordtype">bool</span> completeNull = <span class="keyword">false</span>;
<a name="l02667"></a>02667     <span class="comment">//int* nN;</span>
<a name="l02668"></a>02668     <span class="comment">//CFG* gra = *g;</span>
<a name="l02669"></a>02669     <span class="comment">//out_edge_iterator i, j;</span>
<a name="l02670"></a>02670     <span class="comment">//int* vN = g-&gt;getVertex**ForNode(*n);</span>
<a name="l02671"></a>02671     <span class="comment">//boost::tie(i, j) = boost::out_edges(vN, *g);</span>
<a name="l02672"></a>02672     <span class="comment">//printCFGNode(n, g, -1);</span>
<a name="l02673"></a>02673     <span class="comment">//std::cout &lt;&lt; &quot;outedges&quot; &lt;&lt; j - i &lt;&lt; std::endl;</span>
<a name="l02674"></a>02674     <span class="comment">//std::pair&lt;int*, int*&gt; pairnodes;</span>
<a name="l02675"></a>02675     <span class="keywordtype">int</span> nextNode;
<a name="l02676"></a>02676     std::vector&lt;int&gt; oeds = getOutEdges(n, g);
<a name="l02677"></a>02677     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; oeds.size(); i++)
<a name="l02678"></a>02678     {
<a name="l02679"></a>02679         prepNextNode = getTarget(oeds[i], g);
<a name="l02680"></a>02680         <span class="keywordflow">if</span> (oeds.size() == 1)
<a name="l02681"></a>02681         {
<a name="l02682"></a>02682             <span class="comment">//nextNode = &amp;(*gra[&amp;boost::target(*i,*g)]);</span>
<a name="l02683"></a>02683             <span class="comment">//std::pair&lt;int*, int*&gt; pairnodes;</span>
<a name="l02684"></a>02684             <span class="comment">//pairnodes.first = n;</span>
<a name="l02685"></a>02685             <span class="comment">//pairnodes.second = prepNextNode;</span>
<a name="l02686"></a>02686             <span class="comment">//*ted = *i;</span>
<a name="l02687"></a>02687             <span class="keywordflow">if</span> (nullEdgesOrdered.find(oeds[i]) != nullEdgesOrdered.end())
<a name="l02688"></a>02688             {
<a name="l02689"></a>02689                 nullNum++;
<a name="l02690"></a>02690             }
<a name="l02691"></a>02691             nextNode = getTarget(oeds[i], g);
<a name="l02692"></a>02692             <span class="comment">//completedEdges.insert(*i);</span>
<a name="l02693"></a>02693             completed = <span class="keyword">true</span>;
<a name="l02694"></a>02694         }
<a name="l02695"></a>02695         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (completed == <span class="keyword">false</span> &amp;&amp; computedNodes.find(prepNextNode) == computedNodes.end())
<a name="l02696"></a>02696         {
<a name="l02697"></a>02697             completed = <span class="keyword">true</span>;
<a name="l02698"></a>02698             <span class="comment">//nextNode = &amp;(*gra[&amp;boost::target(*i,*g)]);</span>
<a name="l02699"></a>02699             <span class="comment">//std::pair&lt;int*, int*&gt; pairnodes;</span>
<a name="l02700"></a>02700             <span class="comment">//*ted = *i;</span>
<a name="l02701"></a>02701             <span class="keywordflow">if</span> (nullEdgesOrdered.find(oeds[i]) != nullEdgesOrdered.end())
<a name="l02702"></a>02702             {
<a name="l02703"></a>02703                 nullNum++;
<a name="l02704"></a>02704             }
<a name="l02705"></a>02705             nextNode = getTarget(oeds[i], g);
<a name="l02706"></a>02706             completedEdgesOut.insert(oeds[i]);
<a name="l02707"></a>02707             completed = <span class="keyword">true</span>;
<a name="l02708"></a>02708         }
<a name="l02709"></a>02709 
<a name="l02710"></a>02710 
<a name="l02711"></a>02711     }
<a name="l02712"></a>02712     std::pair&lt;bool, int&gt; pr;
<a name="l02713"></a>02713     ROSE_ASSERT (completed == <span class="keyword">true</span> || completeNull == <span class="keyword">true</span>);
<a name="l02714"></a>02714     <span class="keywordflow">if</span> (completed == <span class="keyword">true</span>)
<a name="l02715"></a>02715     {
<a name="l02716"></a>02716         <span class="comment">//std::cout &lt;&lt; &quot;completed&quot; &lt;&lt; std::endl;</span>
<a name="l02717"></a>02717         pr.first = completed;
<a name="l02718"></a>02718         pr.second = nextNode;
<a name="l02719"></a>02719         <span class="keywordflow">return</span> pr;
<a name="l02720"></a>02720     }
<a name="l02721"></a>02721     <span class="keywordflow">else</span>
<a name="l02722"></a>02722     {
<a name="l02723"></a>02723         <span class="comment">//std::cout &lt;&lt; &quot;bad node&quot; &lt;&lt; std::endl;</span>
<a name="l02724"></a>02724         pr.first = <span class="keyword">true</span>;
<a name="l02725"></a>02725         pr.second = n;
<a name="l02726"></a>02726         <span class="keywordflow">return</span> pr;
<a name="l02727"></a>02727     }
<a name="l02728"></a>02728 
<a name="l02729"></a>02729 }
<a name="l02730"></a>02730 
<a name="l02742"></a>02742 <span class="comment">//computes the next parent to be analyzed in nodal analysis</span>
<a name="l02743"></a>02743 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType, <span class="keyword">class</span> CFG&gt;
<a name="l02744"></a>02744 std::pair&lt;bool, int&gt;
<a name="l02745"></a>02745 <a class="code" href="classSgGraphTraversal.html#a1dc4b927b3eb7781dc6a1adb9c5e884b" title="computes the next parent node to calculate similar to getNextChild">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType, CFG&gt;::</a>
<a name="l02746"></a><a class="code" href="classSgGraphTraversal.html#a1dc4b927b3eb7781dc6a1adb9c5e884b">02746</a> <a class="code" href="classSgGraphTraversal.html#a1dc4b927b3eb7781dc6a1adb9c5e884b" title="computes the next parent node to calculate similar to getNextChild">getNextPar</a>(<span class="keyword">const</span> CFG* &amp;g, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;n)
<a name="l02747"></a>02747 {
<a name="l02748"></a>02748 
<a name="l02749"></a>02749     <span class="keywordtype">int</span> prepNextNode;
<a name="l02750"></a>02750     <span class="keywordtype">int</span> nextPar;
<a name="l02751"></a>02751     <span class="comment">//Edge* ted;</span>
<a name="l02752"></a>02752     <span class="keywordtype">bool</span> completed = <span class="keyword">false</span>;
<a name="l02753"></a>02753     <span class="keywordtype">bool</span> completeNull = <span class="keyword">false</span>;
<a name="l02754"></a>02754     std::vector&lt;int&gt; ieds = getInEdges(n, g);
<a name="l02755"></a>02755     <span class="comment">//std::cout &lt;&lt; &quot;inedges: &quot; &lt;&lt; ieds.size() &lt;&lt; std::endl;</span>
<a name="l02756"></a>02756     <span class="comment">//in_edge_iterator i, j;</span>
<a name="l02757"></a>02757     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ieds.size(); i++)
<a name="l02758"></a>02758     {
<a name="l02759"></a>02759         prepNextNode = getSource(ieds[i], g);
<a name="l02760"></a>02760         <span class="comment">//*ted = *i;</span>
<a name="l02761"></a>02761         <span class="keywordflow">if</span> (ieds.size() == 1 <span class="comment">/*&amp;&amp; completedEdges.find(ieds[i]) == completedEdges.end()*/</span>)
<a name="l02762"></a>02762         {
<a name="l02763"></a>02763             <span class="comment">//std::pair&lt;int*, int*&gt; pairnodes;</span>
<a name="l02764"></a>02764             completed = <span class="keyword">true</span>;
<a name="l02765"></a>02765             completedEdges.insert(ieds[i]);
<a name="l02766"></a>02766             nextPar = prepNextNode;
<a name="l02767"></a>02767         }
<a name="l02768"></a>02768 
<a name="l02769"></a>02769         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (completedEdges.find(ieds[i]) == completedEdges.end() &amp;&amp; completed == <span class="keyword">false</span>)
<a name="l02770"></a>02770         {
<a name="l02771"></a>02771             completed = <span class="keyword">true</span>;
<a name="l02772"></a>02772             completedEdges.insert(ieds[i]);
<a name="l02773"></a>02773             nextPar = prepNextNode;
<a name="l02774"></a>02774         }
<a name="l02775"></a>02775         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (completedEdges.find(ieds[i]) != completedEdges.end() &amp;&amp; computedNodes.find(prepNextNode) == computedNodes.end() &amp;&amp; completed == <span class="keyword">false</span>)
<a name="l02776"></a>02776         {
<a name="l02777"></a>02777             completeNull = <span class="keyword">true</span>;
<a name="l02778"></a>02778             nextPar = n;
<a name="l02779"></a>02779             nullEdgesOrdered.insert(ieds[i]);
<a name="l02780"></a>02780             nullEdgesPaths++;
<a name="l02781"></a>02781 
<a name="l02782"></a>02782         }
<a name="l02783"></a>02783     }
<a name="l02784"></a>02784     ROSE_ASSERT(completed == <span class="keyword">true</span> || completeNull == <span class="keyword">true</span>);
<a name="l02785"></a>02785     std::pair&lt;bool, int&gt; pr;
<a name="l02786"></a>02786     pr.first = completed;
<a name="l02787"></a>02787     pr.second = nextPar;
<a name="l02788"></a>02788     <span class="keywordflow">if</span> (completeNull == <span class="keyword">true</span> &amp;&amp; completed == <span class="keyword">false</span>)
<a name="l02789"></a>02789     {
<a name="l02790"></a>02790         pr.first = completeNull;
<a name="l02791"></a>02791         pr.second = nextPar;
<a name="l02792"></a>02792     }
<a name="l02793"></a>02793 
<a name="l02794"></a>02794     <span class="keywordflow">return</span> pr;
<a name="l02795"></a>02795 }
<a name="l02796"></a>02796 
<a name="l02797"></a>02797 
<a name="l02798"></a>02798 
<a name="l02799"></a>02799 
<a name="l02800"></a>02800 
<a name="l02801"></a>02801 
<a name="l02802"></a>02802 
<a name="l02803"></a>02803 
<a name="l02804"></a>02804 
<a name="l02805"></a>02805 
<a name="l02806"></a>02806 
<a name="l02807"></a>02807 
<a name="l02808"></a>02808 
<a name="l02809"></a>02809 
<a name="l02810"></a>02810 
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="graphProcessing_8h.html">graphProcessing.h</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Thu Dec 1 2011 16:31:43 for ROSE by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
