<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: liveDeadVarAnalysis.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>liveDeadVarAnalysis.h</h1><a href="liveDeadVarAnalysis_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef LIVE_DEAD_VAR_ANALYSIS_H</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define LIVE_DEAD_VAR_ANALYSIS_H</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="preprocessor">#include "<a class="code" href="genericDataflowCommon_8h.html">genericDataflowCommon.h</a>"</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include "<a class="code" href="VirtualCFGIterator_8h.html">VirtualCFGIterator.h</a>"</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include "<a class="code" href="cfgUtils_8h.html">cfgUtils.h</a>"</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include "<a class="code" href="CallGraphTraverse_8h.html">CallGraphTraverse.h</a>"</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include "<a class="code" href="analysisCommon_8h.html">analysisCommon.h</a>"</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include "<a class="code" href="analysis_8h.html">analysis.h</a>"</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include "<a class="code" href="dataflow_8h.html">dataflow.h</a>"</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include "<a class="code" href="latticeFull_8h.html">latticeFull.h</a>"</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include "<a class="code" href="printAnalysisStates_8h.html">printAnalysisStates.h</a>"</span>
<a name="l00013"></a>00013 
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;set&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="liveDeadVarAnalysis_8h.html#294ee9524aec43b4324de5d2d4811fbe">liveDeadAnalysisDebugLevel</a>;
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="comment">// Lattice that stores the variables that are live at a given DataflowNode</span>
<a name="l00023"></a><a class="code" href="classLiveVarsLattice.html">00023</a> <span class="keyword">class </span><a class="code" href="classLiveVarsLattice.html">LiveVarsLattice</a> : <span class="keyword">public</span> <a class="code" href="classFiniteLattice.html">FiniteLattice</a>
<a name="l00024"></a>00024 {
<a name="l00025"></a>00025         <span class="keyword">public</span>:
<a name="l00026"></a><a class="code" href="classLiveVarsLattice.html#e19fdd040172076b900b4e845d3845d8">00026</a>         std::set&lt;varID&gt; <a class="code" href="classLiveVarsLattice.html#e19fdd040172076b900b4e845d3845d8">liveVars</a>;
<a name="l00027"></a>00027         
<a name="l00028"></a>00028         <span class="keyword">public</span>:
<a name="l00029"></a>00029         <a class="code" href="classLiveVarsLattice.html#767bfef6069f7f48e4c8062c6ce850fd">LiveVarsLattice</a>();
<a name="l00030"></a>00030         <a class="code" href="classLiveVarsLattice.html#767bfef6069f7f48e4c8062c6ce850fd">LiveVarsLattice</a>(<span class="keyword">const</span> <a class="code" href="classvarID.html">varID</a>&amp; var);
<a name="l00031"></a>00031         <a class="code" href="classLiveVarsLattice.html#767bfef6069f7f48e4c8062c6ce850fd">LiveVarsLattice</a>(<span class="keyword">const</span> std::set&lt;varID&gt;&amp; <a class="code" href="classLiveVarsLattice.html#e19fdd040172076b900b4e845d3845d8">liveVars</a>);
<a name="l00032"></a>00032                 
<a name="l00033"></a>00033         <span class="comment">// Initializes this Lattice to its default state, if it is not already initialized</span>
<a name="l00034"></a>00034         <span class="keywordtype">void</span> <a class="code" href="classLiveVarsLattice.html#882bc0a9b99665e3d8a1cac0969085c5">initialize</a>();
<a name="l00035"></a>00035         
<a name="l00036"></a>00036         <span class="comment">// Returns a copy of this lattice</span>
<a name="l00037"></a>00037         <a class="code" href="classLattice.html">Lattice</a>* <a class="code" href="classLiveVarsLattice.html#065f9024b6ecdae93e60a352868d3d11">copy</a>() <span class="keyword">const</span>;
<a name="l00038"></a>00038         
<a name="l00039"></a>00039         <span class="comment">// Overwrites the state of this Lattice with that of that Lattice</span>
<a name="l00040"></a>00040         <span class="keywordtype">void</span> <a class="code" href="classLiveVarsLattice.html#065f9024b6ecdae93e60a352868d3d11">copy</a>(<a class="code" href="classLattice.html">Lattice</a>* that);
<a name="l00041"></a>00041         
<a name="l00042"></a>00042         <span class="comment">// Called by analyses to create a copy of this lattice. However, if this lattice maintains any </span>
<a name="l00043"></a>00043         <span class="comment">//    information on a per-variable basis, these per-variable mappings must be converted from </span>
<a name="l00044"></a>00044         <span class="comment">//    the current set of variables to another set. This may be needed during function calls, </span>
<a name="l00045"></a>00045         <span class="comment">//    when dataflow information from the caller/callee needs to be transferred to the callee/calleer.</span>
<a name="l00046"></a>00046         <span class="comment">// We do not force child classes to define their own versions of this function since not all</span>
<a name="l00047"></a>00047         <span class="comment">//    Lattices have per-variable information.</span>
<a name="l00048"></a>00048         <span class="comment">// varNameMap - maps all variable names that have changed, in each mapping pair, pair-&gt;first is the </span>
<a name="l00049"></a>00049         <span class="comment">//              old variable and pair-&gt;second is the new variable</span>
<a name="l00050"></a>00050         <span class="comment">// func - the function that the copy Lattice will now be associated with</span>
<a name="l00051"></a>00051         <span class="keywordtype">void</span> <a class="code" href="classLiveVarsLattice.html#3eb0fbbb71e0b7d3aedb8d8ca73ba5af">remapVars</a>(<span class="keyword">const</span> std::map&lt;varID, varID&gt;&amp; varNameMap, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function</a>&amp; newFunc);
<a name="l00052"></a>00052         
<a name="l00053"></a>00053         <span class="comment">// Called by analyses to copy over from the that Lattice dataflow information into this Lattice.</span>
<a name="l00054"></a>00054         <span class="comment">// that contains data for a set of variables and incorporateVars must overwrite the state of just</span>
<a name="l00055"></a>00055         <span class="comment">// those variables, while leaving its state for other variables alone.</span>
<a name="l00056"></a>00056         <span class="comment">// We do not force child classes to define their own versions of this function since not all</span>
<a name="l00057"></a>00057         <span class="comment">//    Lattices have per-variable information.</span>
<a name="l00058"></a>00058         <span class="keywordtype">void</span> <a class="code" href="classLiveVarsLattice.html#6f2376c00a52ae7428a965c0adc1f1b9">incorporateVars</a>(<a class="code" href="classLattice.html">Lattice</a>* that_arg);
<a name="l00059"></a>00059         
<a name="l00060"></a>00060         <span class="comment">// Returns a Lattice that describes the information known within this lattice</span>
<a name="l00061"></a>00061         <span class="comment">// about the given expression. By default this could be the entire lattice or any portion of it.</span>
<a name="l00062"></a>00062         <span class="comment">// For example, a lattice that maintains lattices for different known variables and expression will </span>
<a name="l00063"></a>00063         <span class="comment">// return a lattice for the given expression. Similarly, a lattice that keeps track of constraints</span>
<a name="l00064"></a>00064         <span class="comment">// on values of variables and expressions will return the portion of the lattice that relates to</span>
<a name="l00065"></a>00065         <span class="comment">// the given expression. </span>
<a name="l00066"></a>00066         <span class="comment">// It it legal for this function to return NULL if no information is available.</span>
<a name="l00067"></a>00067         <span class="comment">// The function's caller is responsible for deallocating the returned object</span>
<a name="l00068"></a>00068         <a class="code" href="classLattice.html">Lattice</a>* <a class="code" href="classLiveVarsLattice.html#ab2b50c4edfc4e96d9eaec22a94e5a96">project</a>(<a class="code" href="classSgExpression.html">SgExpression</a>* expr);
<a name="l00069"></a>00069         
<a name="l00070"></a>00070         <span class="comment">// The inverse of project(). The call is provided with an expression and a Lattice that describes</span>
<a name="l00071"></a>00071         <span class="comment">// the dataflow state that relates to expression. This Lattice must be of the same type as the lattice</span>
<a name="l00072"></a>00072         <span class="comment">// returned by project(). unProject() must incorporate this dataflow state into the overall state it holds.</span>
<a name="l00073"></a>00073         <span class="comment">// Call must make an internal copy of the passed-in lattice and the caller is responsible for deallocating it.</span>
<a name="l00074"></a>00074         <span class="comment">// Returns true if this causes this to change and false otherwise.</span>
<a name="l00075"></a>00075         <span class="keywordtype">bool</span> <a class="code" href="classLiveVarsLattice.html#d064813b02bdff176849706b62685a91">unProject</a>(<a class="code" href="classSgExpression.html">SgExpression</a>* expr, <a class="code" href="classLattice.html">Lattice</a>* exprState);
<a name="l00076"></a>00076         
<a name="l00077"></a>00077         <span class="comment">// computes the meet of this and that and saves the result in this</span>
<a name="l00078"></a>00078         <span class="comment">// returns true if this causes this to change and false otherwise</span>
<a name="l00079"></a>00079         <span class="keywordtype">bool</span> <a class="code" href="classLiveVarsLattice.html#1adfb547527fef1709a6a70025074563">meetUpdate</a>(<a class="code" href="classLattice.html">Lattice</a>* that_arg);
<a name="l00080"></a>00080         
<a name="l00081"></a>00081         <span class="keywordtype">bool</span> <a class="code" href="classLiveVarsLattice.html#684eeb157a55d745e277265f93ce12dd">operator==</a>(<a class="code" href="classLattice.html">Lattice</a>* that);
<a name="l00082"></a>00082         
<a name="l00083"></a>00083         <span class="comment">// Functions used to inform this lattice that a given variable is now in use (e.g. a variable has entered </span>
<a name="l00084"></a>00084         <span class="comment">//    scope or an expression is being analyzed) or is no longer in use (e.g. a variable has exited scope or</span>
<a name="l00085"></a>00085         <span class="comment">//    an expression or variable is dead).</span>
<a name="l00086"></a>00086         <span class="comment">// It is assumed that a newly-added variable has not been added before and that a variable that is being</span>
<a name="l00087"></a>00087         <span class="comment">//    removed was previously added</span>
<a name="l00088"></a>00088         <span class="comment">// Returns true if this causes the lattice to change and false otherwise.</span>
<a name="l00089"></a>00089         <span class="keywordtype">bool</span> <a class="code" href="classLiveVarsLattice.html#da85f51109cdcf76ea5301dd29110a7d">addVar</a>(<span class="keyword">const</span> <a class="code" href="classvarID.html">varID</a>&amp; var);
<a name="l00090"></a>00090         <span class="keywordtype">bool</span> <a class="code" href="classLiveVarsLattice.html#c28df65fae30e7dee11aba8724dd56a8">remVar</a>(<span class="keyword">const</span> <a class="code" href="classvarID.html">varID</a>&amp; var);
<a name="l00091"></a>00091         
<a name="l00092"></a>00092         <span class="comment">// Returns true if the given variable is recorded as live and false otherwise</span>
<a name="l00093"></a>00093         <span class="keywordtype">bool</span> <a class="code" href="classLiveVarsLattice.html#fbb0ed479d200ec7c10c3c94a66183ba">isLiveVar</a>(<a class="code" href="classvarID.html">varID</a> var);
<a name="l00094"></a>00094                         
<a name="l00095"></a>00095         <span class="comment">// The string that represents this object</span>
<a name="l00096"></a>00096         <span class="comment">// If indent!="", every line of this string must be prefixed by indent</span>
<a name="l00097"></a>00097         <span class="comment">// The last character of the returned string should not be '\n', even if it is a multi-line string.</span>
<a name="l00098"></a>00098         std::string <a class="code" href="classLiveVarsLattice.html#2ec971db504aa7555bb6a63a7734e4bd">str</a>(std::string indent=<span class="stringliteral">""</span>);
<a name="l00099"></a>00099 };
<a name="l00100"></a>00100 
<a name="l00101"></a>00101 <span class="comment">// Virtual class that allows users of the LiveDeadVarsAnalysis to mark certain variables as </span>
<a name="l00102"></a>00102 <span class="comment">// being used inside a function call if the function's body is not available.</span>
<a name="l00103"></a><a class="code" href="classfuncSideEffectUses.html">00103</a> <span class="keyword">class </span><a class="code" href="classfuncSideEffectUses.html">funcSideEffectUses</a>
<a name="l00104"></a>00104 {
<a name="l00105"></a>00105 <span class="keyword">public</span>:
<a name="l00106"></a>00106   <span class="comment">// Returns the set of variables that are used in a call to the given function for which a body has not been provided.</span>
<a name="l00107"></a>00107   <span class="comment">// The function is also provided with the DataflowNode where the function was called, as well as its state.</span>
<a name="l00108"></a>00108   <span class="keyword">virtual</span> std::set&lt;varID&gt; <a class="code" href="classfuncSideEffectUses.html#c450919e6981211599fc7d06aa20f42a">usedVarsInFunc</a>(<span class="keyword">const</span> <a class="code" href="classFunction.html">Function</a>&amp; func, <span class="keyword">const</span> <a class="code" href="classVirtualCFG_1_1DataflowNode.html">DataflowNode</a>&amp; n, <a class="code" href="classNodeState.html">NodeState</a>&amp; state)=0;
<a name="l00109"></a>00109 };
<a name="l00110"></a>00110 
<a name="l00111"></a><a class="code" href="classLiveDeadVarsTransfer.html">00111</a> <span class="keyword">class </span><a class="code" href="classLiveDeadVarsTransfer.html">LiveDeadVarsTransfer</a> : <span class="keyword">public</span> <a class="code" href="classIntraDFTransferVisitor.html">IntraDFTransferVisitor</a>
<a name="l00112"></a>00112 {
<a name="l00113"></a><a class="code" href="classLiveDeadVarsTransfer.html#b051766966bec9ee075e5deb7647ed8a">00113</a>   std::string <a class="code" href="classLiveDeadVarsTransfer.html#b051766966bec9ee075e5deb7647ed8a">indent</a>;
<a name="l00114"></a><a class="code" href="classLiveDeadVarsTransfer.html#a496e77f8418ed09213ed90c91fff7df">00114</a>   <a class="code" href="classLiveVarsLattice.html">LiveVarsLattice</a>* <a class="code" href="classLiveDeadVarsTransfer.html#a496e77f8418ed09213ed90c91fff7df">liveLat</a>;
<a name="l00115"></a>00115 
<a name="l00116"></a><a class="code" href="classLiveDeadVarsTransfer.html#cea5ecd39972884c4b54049f1f96017f">00116</a>   <span class="keywordtype">bool</span> <a class="code" href="classLiveDeadVarsTransfer.html#cea5ecd39972884c4b54049f1f96017f">modified</a>;
<a name="l00117"></a>00117   <span class="comment">// Expressions that are assigned by the current operation</span>
<a name="l00118"></a><a class="code" href="classLiveDeadVarsTransfer.html#6d468e0a1a968d88b3e28932e995e967">00118</a>   std::set&lt;SgExpression*&gt; <a class="code" href="classLiveDeadVarsTransfer.html#6d468e0a1a968d88b3e28932e995e967">assignedExprs</a>;
<a name="l00119"></a>00119   <span class="comment">// Variables that are assigned by the current operation</span>
<a name="l00120"></a><a class="code" href="classLiveDeadVarsTransfer.html#6bbb73fb23a2070e9a1682d1a44e0ab9">00120</a>   std::set&lt;varID&gt; <a class="code" href="classLiveDeadVarsTransfer.html#6bbb73fb23a2070e9a1682d1a44e0ab9">assignedVars</a>;
<a name="l00121"></a>00121   <span class="comment">// Variables that are used/read by the current operation</span>
<a name="l00122"></a><a class="code" href="classLiveDeadVarsTransfer.html#f390a3fbb0e61bffa4ce550a54f211b5">00122</a>   std::set&lt;varID&gt; <a class="code" href="classLiveDeadVarsTransfer.html#f390a3fbb0e61bffa4ce550a54f211b5">usedVars</a>;
<a name="l00123"></a>00123 
<a name="l00124"></a><a class="code" href="classLiveDeadVarsTransfer.html#ca3557c6b2781f6a44bcf26fc7a3e6ad">00124</a>   <a class="code" href="classfuncSideEffectUses.html">funcSideEffectUses</a> *<a class="code" href="classLiveDeadVarsTransfer.html#ca3557c6b2781f6a44bcf26fc7a3e6ad">fseu</a>;
<a name="l00125"></a>00125 
<a name="l00126"></a><a class="code" href="classLiveDeadVarsTransfer.html#e20587794f8c90a6f358c24222b2d34f">00126</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classLiveDeadVarsTransfer.html#e20587794f8c90a6f358c24222b2d34f">LDVAExpressionTransfer</a>;
<a name="l00127"></a>00127 
<a name="l00128"></a>00128   <span class="comment">// Note that the variable corresponding to this expression is used</span>
<a name="l00129"></a>00129   <span class="keywordtype">void</span> <a class="code" href="classLiveDeadVarsTransfer.html#3c50476a5a562d553a9ee3ba5a36663b">used</a>(<a class="code" href="classSgExpression.html">SgExpression</a> *);
<a name="l00130"></a>00130 
<a name="l00131"></a>00131 <span class="keyword">public</span>:
<a name="l00132"></a><a class="code" href="classLiveDeadVarsTransfer.html#d7578c81d04583d3b0fcb024bb268db6">00132</a>   <a class="code" href="classLiveDeadVarsTransfer.html#d7578c81d04583d3b0fcb024bb268db6">LiveDeadVarsTransfer</a>(<span class="keyword">const</span> <a class="code" href="classFunction.html">Function</a> &amp;f, <span class="keyword">const</span> <a class="code" href="classVirtualCFG_1_1DataflowNode.html">DataflowNode</a> &amp;n, <a class="code" href="classNodeState.html">NodeState</a> &amp;s, <span class="keyword">const</span> std::vector&lt;Lattice*&gt; &amp;d, <a class="code" href="classfuncSideEffectUses.html">funcSideEffectUses</a> *fseu_)
<a name="l00133"></a>00133     : <a class="code" href="classIntraDFTransferVisitor.html">IntraDFTransferVisitor</a>(f, n, s, d), <a class="code" href="classLiveDeadVarsTransfer.html#b051766966bec9ee075e5deb7647ed8a">indent</a>(<span class="stringliteral">"    "</span>), <a class="code" href="classLiveDeadVarsTransfer.html#a496e77f8418ed09213ed90c91fff7df">liveLat</a>(dynamic_cast&lt;<a class="code" href="classLiveVarsLattice.html">LiveVarsLattice</a>*&gt;(*(<a class="code" href="classIntraDFTransferVisitor.html#9374517e2f2ef98abba6171beddf1810">dfInfo</a>.begin()))), <a class="code" href="classLiveDeadVarsTransfer.html#cea5ecd39972884c4b54049f1f96017f">modified</a>(false), <a class="code" href="classLiveDeadVarsTransfer.html#ca3557c6b2781f6a44bcf26fc7a3e6ad">fseu</a>(fseu_)
<a name="l00134"></a>00134   {
<a name="l00135"></a>00135         <span class="keywordflow">if</span>(<a class="code" href="liveDeadVarAnalysis_8h.html#294ee9524aec43b4324de5d2d4811fbe">liveDeadAnalysisDebugLevel</a>&gt;=1) <a class="code" href="namespaceDbg.html#427d995a89e499a49f0ebd89eec90858">Dbg::dbg</a> &lt;&lt; <a class="code" href="classLiveDeadVarsTransfer.html#b051766966bec9ee075e5deb7647ed8a">indent</a> &lt;&lt; <span class="stringliteral">"liveLat="</span>&lt;&lt;<a class="code" href="classLiveDeadVarsTransfer.html#a496e77f8418ed09213ed90c91fff7df">liveLat</a>-&gt;<a class="code" href="classLiveVarsLattice.html#2ec971db504aa7555bb6a63a7734e4bd">str</a>(<a class="code" href="classLiveDeadVarsTransfer.html#b051766966bec9ee075e5deb7647ed8a">indent</a> + <span class="stringliteral">"    "</span>)&lt;&lt;std::endl;
<a name="l00136"></a>00136         <span class="comment">// Make sure that all the lattice is initialized</span>
<a name="l00137"></a>00137         <a class="code" href="classLiveDeadVarsTransfer.html#a496e77f8418ed09213ed90c91fff7df">liveLat</a>-&gt;<a class="code" href="classLiveVarsLattice.html#882bc0a9b99665e3d8a1cac0969085c5">initialize</a>();
<a name="l00138"></a>00138   }
<a name="l00139"></a>00139 
<a name="l00140"></a>00140   <span class="keywordtype">bool</span> <a class="code" href="classLiveDeadVarsTransfer.html#fc4d14952b51e1ee24c6f818e7c25f3a">finish</a>();
<a name="l00141"></a>00141 
<a name="l00142"></a>00142   <span class="keywordtype">void</span> <a class="code" href="classLiveDeadVarsTransfer.html#bd8e1f071c266a55693e27d85cfefd9f">visit</a>(<a class="code" href="classSgExpression.html">SgExpression</a> *);
<a name="l00143"></a>00143   <span class="keywordtype">void</span> <a class="code" href="classLiveDeadVarsTransfer.html#bd8e1f071c266a55693e27d85cfefd9f">visit</a>(<a class="code" href="classSgInitializedName.html">SgInitializedName</a> *);
<a name="l00144"></a>00144   <span class="keywordtype">void</span> <a class="code" href="classLiveDeadVarsTransfer.html#bd8e1f071c266a55693e27d85cfefd9f">visit</a>(<a class="code" href="classSgReturnStmt.html">SgReturnStmt</a> *);
<a name="l00145"></a>00145   <span class="keywordtype">void</span> <a class="code" href="classLiveDeadVarsTransfer.html#bd8e1f071c266a55693e27d85cfefd9f">visit</a>(<a class="code" href="classSgExprStatement.html">SgExprStatement</a> *);
<a name="l00146"></a>00146   <span class="keywordtype">void</span> <a class="code" href="classLiveDeadVarsTransfer.html#bd8e1f071c266a55693e27d85cfefd9f">visit</a>(<a class="code" href="classSgCaseOptionStmt.html">SgCaseOptionStmt</a> *);
<a name="l00147"></a>00147   <span class="keywordtype">void</span> <a class="code" href="classLiveDeadVarsTransfer.html#bd8e1f071c266a55693e27d85cfefd9f">visit</a>(<a class="code" href="classSgIfStmt.html">SgIfStmt</a> *);
<a name="l00148"></a>00148   <span class="keywordtype">void</span> <a class="code" href="classLiveDeadVarsTransfer.html#bd8e1f071c266a55693e27d85cfefd9f">visit</a>(<a class="code" href="classSgForStatement.html">SgForStatement</a> *);
<a name="l00149"></a>00149   <span class="keywordtype">void</span> <a class="code" href="classLiveDeadVarsTransfer.html#bd8e1f071c266a55693e27d85cfefd9f">visit</a>(<a class="code" href="classSgWhileStmt.html">SgWhileStmt</a> *);
<a name="l00150"></a>00150   <span class="keywordtype">void</span> <a class="code" href="classLiveDeadVarsTransfer.html#bd8e1f071c266a55693e27d85cfefd9f">visit</a>(<a class="code" href="classSgDoWhileStmt.html">SgDoWhileStmt</a> *);
<a name="l00151"></a>00151 };
<a name="l00152"></a>00152 
<a name="l00153"></a>00153 <span class="comment">/* Computes an over-approximation of the set of variables that are live at each DataflowNode. It may consider a given</span>
<a name="l00154"></a>00154 <span class="comment">   variable as live when in fact it is not. */</span>
<a name="l00155"></a>00155 <span class="comment">// !!! CURRENTLY THE ANALYSIS IS IMPRECISE BECAUSE:</span>
<a name="l00156"></a>00156 <span class="comment">// !!!    - IF THERE IS A VARIABLE USE WHERE THE IDENTITY OF THE VARIABLE IS COMPUTED THROUGH AN EXPRESSION, WE DO NOT </span>
<a name="l00157"></a>00157 <span class="comment">// !!!         RESPOND BY CONSERVATIVELY MAKING ALL VARIABLES LIVE.</span>
<a name="l00158"></a>00158 <span class="comment">// !!!    - IT DOES NOT CONSIDER INTERNALS OF ARRAYS OR OTHER HEAP MEMORY</span>
<a name="l00159"></a><a class="code" href="classLiveDeadVarsAnalysis.html">00159</a> <span class="keyword">class </span><a class="code" href="classLiveDeadVarsAnalysis.html">LiveDeadVarsAnalysis</a> : <span class="keyword">public</span> <a class="code" href="classIntraBWDataflow.html">IntraBWDataflow</a>
<a name="l00160"></a>00160 {
<a name="l00161"></a>00161         <span class="keyword">protected</span>:
<a name="l00162"></a><a class="code" href="classLiveDeadVarsAnalysis.html#71a592f6e043276901d61a0f5652b083">00162</a>         <a class="code" href="classfuncSideEffectUses.html">funcSideEffectUses</a>* <a class="code" href="classLiveDeadVarsAnalysis.html#71a592f6e043276901d61a0f5652b083">fseu</a>;
<a name="l00163"></a>00163         
<a name="l00164"></a>00164         <span class="keyword">public</span>:
<a name="l00165"></a>00165         <a class="code" href="classLiveDeadVarsAnalysis.html#56000141af34af1bb49f069c98f1bb0f">LiveDeadVarsAnalysis</a>(<a class="code" href="classSgProject.html">SgProject</a> *<a class="code" href="namespacecfgUtils.html#ce4abf2beca5826144d69d3a0283050f">project</a>, <a class="code" href="classfuncSideEffectUses.html">funcSideEffectUses</a>* <a class="code" href="classLiveDeadVarsAnalysis.html#71a592f6e043276901d61a0f5652b083">fseu</a>=NULL);
<a name="l00166"></a>00166         
<a name="l00167"></a>00167         <span class="comment">// Generates the initial lattice state for the given dataflow node, in the given function, with the given NodeState</span>
<a name="l00168"></a>00168         <span class="keywordtype">void</span> <a class="code" href="classLiveDeadVarsAnalysis.html#b9d0634cab402e3334e4cf83538ac2ef">genInitState</a>(<span class="keyword">const</span> <a class="code" href="classFunction.html">Function</a>&amp; func, <span class="keyword">const</span> <a class="code" href="classVirtualCFG_1_1DataflowNode.html">DataflowNode</a>&amp; n, <span class="keyword">const</span> <a class="code" href="classNodeState.html">NodeState</a>&amp; state,
<a name="l00169"></a>00169                           std::vector&lt;Lattice*&gt;&amp; initLattices, std::vector&lt;NodeFact*&gt;&amp; initFacts);
<a name="l00170"></a>00170         
<a name="l00171"></a><a class="code" href="classLiveDeadVarsAnalysis.html#18687a792775e2575aef4906d8020fc1">00171</a>   boost::shared_ptr&lt;IntraDFTransferVisitor&gt; <a class="code" href="classLiveDeadVarsAnalysis.html#18687a792775e2575aef4906d8020fc1">getTransferVisitor</a>(<span class="keyword">const</span> <a class="code" href="classFunction.html">Function</a>&amp; func, <span class="keyword">const</span> <a class="code" href="classVirtualCFG_1_1DataflowNode.html">DataflowNode</a>&amp; n,
<a name="l00172"></a>00172                                                                <a class="code" href="classNodeState.html">NodeState</a>&amp; state, <span class="keyword">const</span> std::vector&lt;Lattice*&gt;&amp; dfInfo)
<a name="l00173"></a>00173   { <span class="keywordflow">return</span> boost::shared_ptr&lt;IntraDFTransferVisitor&gt;(<span class="keyword">new</span> <a class="code" href="classLiveDeadVarsTransfer.html">LiveDeadVarsTransfer</a>(func, n, state, dfInfo, <a class="code" href="classLiveDeadVarsAnalysis.html#71a592f6e043276901d61a0f5652b083">fseu</a>)); }
<a name="l00174"></a>00174 
<a name="l00175"></a><a class="code" href="classLiveDeadVarsAnalysis.html#f97e9efab63fe0476fe506b4342f554b">00175</a>   <span class="keywordtype">bool</span> <a class="code" href="classLiveDeadVarsAnalysis.html#f97e9efab63fe0476fe506b4342f554b">transfer</a>(<span class="keyword">const</span> <a class="code" href="classFunction.html">Function</a>&amp; func, <span class="keyword">const</span> <a class="code" href="classVirtualCFG_1_1DataflowNode.html">DataflowNode</a>&amp; n, <a class="code" href="classNodeState.html">NodeState</a>&amp; state, <span class="keyword">const</span> std::vector&lt;Lattice*&gt;&amp; dfInfo) { assert(0); <span class="keywordflow">return</span> <span class="keyword">false</span>; }
<a name="l00176"></a>00176 };
<a name="l00177"></a>00177 
<a name="l00178"></a>00178 <span class="comment">// Initialize vars to hold all the variables and expressions that are live at DataflowNode n</span>
<a name="l00179"></a>00179 <span class="comment">//void getAllLiveVarsAt(LiveDeadVarsAnalysis* ldva, const DataflowNode&amp; n, const NodeState&amp; state, std::set&lt;varID&gt;&amp; vars, std::string indent="");</span>
<a name="l00180"></a>00180 <span class="keywordtype">void</span> <a class="code" href="liveDeadVarAnalysis_8h.html#65964ee3d53b062bc712764864133dda">getAllLiveVarsAt</a>(<a class="code" href="classLiveDeadVarsAnalysis.html">LiveDeadVarsAnalysis</a>* ldva, <span class="keyword">const</span> <a class="code" href="classNodeState.html">NodeState</a>&amp; state, std::set&lt;varID&gt;&amp; vars, std::string indent=<span class="stringliteral">""</span>);
<a name="l00181"></a>00181 
<a name="l00182"></a>00182 <span class="comment">// Returns the set of variables and expressions that are live at DataflowNode n</span>
<a name="l00183"></a>00183 <span class="comment">//std::set&lt;varID&gt; getAllLiveVarsAt(LiveDeadVarsAnalysis* ldva, const DataflowNode&amp; n, const NodeState&amp; state, std::string indent="");</span>
<a name="l00184"></a>00184 std::set&lt;varID&gt; <a class="code" href="liveDeadVarAnalysis_8h.html#65964ee3d53b062bc712764864133dda">getAllLiveVarsAt</a>(<a class="code" href="classLiveDeadVarsAnalysis.html">LiveDeadVarsAnalysis</a>* ldva, <span class="keyword">const</span> <a class="code" href="classNodeState.html">NodeState</a>&amp; state, std::string indent=<span class="stringliteral">""</span>);
<a name="l00185"></a>00185 
<a name="l00186"></a>00186 <span class="comment">// get Live-In lattice for a control flow graph node generated from a SgNode with an index</span>
<a name="l00187"></a>00187 <a class="code" href="classLiveVarsLattice.html">LiveVarsLattice</a>* <a class="code" href="liveDeadVarAnalysis_8h.html#35cfad1edd99c487c505eb96023b9769">getLiveInVarsAt</a>(<a class="code" href="classLiveDeadVarsAnalysis.html">LiveDeadVarsAnalysis</a>* ldva, <a class="code" href="classSgNode.html">SgNode</a>* n, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = 0);
<a name="l00188"></a>00188 
<a name="l00189"></a>00189 <span class="comment">// get Live-Out lattice for a control flow graph node generated from a SgNode with an index</span>
<a name="l00190"></a>00190 <a class="code" href="classLiveVarsLattice.html">LiveVarsLattice</a>* <a class="code" href="liveDeadVarAnalysis_8h.html#8be523965cb1d5ad8230e5221d257a8f">getLiveOutVarsAt</a>(<a class="code" href="classLiveDeadVarsAnalysis.html">LiveDeadVarsAnalysis</a>* ldva, <a class="code" href="classSgNode.html">SgNode</a>* n, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = 0);
<a name="l00191"></a>00191 
<a name="l00192"></a><a class="code" href="classVarsExprsProductLattice.html">00192</a> <span class="keyword">class </span><a class="code" href="classVarsExprsProductLattice.html">VarsExprsProductLattice</a>: <span class="keyword">public</span> <span class="keyword">virtual</span> <a class="code" href="classProductLattice.html">ProductLattice</a>
<a name="l00193"></a>00193 {
<a name="l00194"></a>00194         <span class="keyword">protected</span>:
<a name="l00195"></a>00195         <span class="comment">// Sample lattice that will be initially associated with every variable (before the analysis)</span>
<a name="l00196"></a><a class="code" href="classVarsExprsProductLattice.html#60be6c4c0285c84a591089b261e35c81">00196</a>         <a class="code" href="classLattice.html">Lattice</a>* <a class="code" href="classVarsExprsProductLattice.html#60be6c4c0285c84a591089b261e35c81">perVarLattice</a>;
<a name="l00197"></a>00197                 
<a name="l00198"></a>00198         <span class="comment">// Lattice that corresponds to allVar;</span>
<a name="l00199"></a><a class="code" href="classVarsExprsProductLattice.html#8fcf7861ee26ea29e3ac26d0d59f8f75">00199</a>         <a class="code" href="classLattice.html">Lattice</a>* <a class="code" href="classVarsExprsProductLattice.html#8fcf7861ee26ea29e3ac26d0d59f8f75">allVarLattice</a>;
<a name="l00200"></a>00200         
<a name="l00201"></a>00201         <span class="comment">// Map of lattices that correspond to constant variables</span>
<a name="l00202"></a><a class="code" href="classVarsExprsProductLattice.html#57e84a072ea92b6e309a80e82d31fb7d">00202</a>         std::map&lt;varID, Lattice*&gt; <a class="code" href="classVarsExprsProductLattice.html#57e84a072ea92b6e309a80e82d31fb7d">constVarLattices</a>;
<a name="l00203"></a>00203         
<a name="l00204"></a>00204         <span class="comment">// Maps variables in a given function to the index of their respective Lattice objects in </span>
<a name="l00205"></a>00205         <span class="comment">// the ProductLattice::lattice[] array</span>
<a name="l00206"></a><a class="code" href="classVarsExprsProductLattice.html#ddb0d47dd8e732c51b5f18a8870b81e5">00206</a>         std::map&lt;varID, int&gt; <a class="code" href="classVarsExprsProductLattice.html#ddb0d47dd8e732c51b5f18a8870b81e5">varLatticeIndex</a>;
<a name="l00207"></a>00207         
<a name="l00208"></a>00208         <span class="comment">// The analysis that identified the variables that are live at this Dataflow node</span>
<a name="l00209"></a><a class="code" href="classVarsExprsProductLattice.html#38953d1260384d62ffe1047c9c40a8ec">00209</a>         <a class="code" href="classLiveDeadVarsAnalysis.html">LiveDeadVarsAnalysis</a>* <a class="code" href="classVarsExprsProductLattice.html#38953d1260384d62ffe1047c9c40a8ec">ldva</a>;
<a name="l00210"></a>00210        
<a name="l00211"></a>00211         bool (*<a class="code" href="classVarsExprsProductLattice.html#8be934c19996977d7665c85988e5cccb">filter</a>) (<a class="code" href="classVirtualCFG_1_1CFGNode.html">CFGNode</a> cfgn);
<a name="l00212"></a>00212 
<a name="l00213"></a>00213         <span class="comment">// Dataflow node that this lattice is associated with and its corresponding node state.</span>
<a name="l00214"></a><a class="code" href="classVarsExprsProductLattice.html#a49c730dc3c72461d30313af8073eb04">00214</a>         <a class="code" href="classVirtualCFG_1_1DataflowNode.html">DataflowNode</a> <a class="code" href="classVarsExprsProductLattice.html#a49c730dc3c72461d30313af8073eb04">n</a>;
<a name="l00215"></a><a class="code" href="classVarsExprsProductLattice.html#f00be775e7f61bdc42ca1e0b798aab51">00215</a>         <span class="keyword">const</span> <a class="code" href="classNodeState.html">NodeState</a>&amp; <a class="code" href="classVarsExprsProductLattice.html#f00be775e7f61bdc42ca1e0b798aab51">state</a>;
<a name="l00216"></a>00216         
<a name="l00217"></a>00217         <span class="keyword">protected</span>:
<a name="l00218"></a>00218         <span class="comment">// Minimal constructor that initializes just the portions of the object required to make an </span>
<a name="l00219"></a>00219         <span class="comment">// initial blank VarsExprsProductLattice</span>
<a name="l00220"></a>00220         <a class="code" href="classVarsExprsProductLattice.html#a7824ca5cbba3954c0bf75d4bcd7fb00">VarsExprsProductLattice</a>(<span class="keyword">const</span> <a class="code" href="classVirtualCFG_1_1DataflowNode.html">DataflowNode</a>&amp; <a class="code" href="classVarsExprsProductLattice.html#a49c730dc3c72461d30313af8073eb04">n</a>, <span class="keyword">const</span> <a class="code" href="classNodeState.html">NodeState</a>&amp; <a class="code" href="classVarsExprsProductLattice.html#f00be775e7f61bdc42ca1e0b798aab51">state</a>, <span class="keywordtype">bool</span> (*<a class="code" href="classVarsExprsProductLattice.html#8be934c19996977d7665c85988e5cccb">filter</a>) (<a class="code" href="classVirtualCFG_1_1CFGNode.html">CFGNode</a> cfgn));
<a name="l00221"></a>00221         
<a name="l00222"></a>00222         <span class="comment">// Returns a blank instance of a VarsExprsProductLattice that only has the fields n and state set</span>
<a name="l00223"></a>00223         <span class="keyword">virtual</span> <a class="code" href="classVarsExprsProductLattice.html">VarsExprsProductLattice</a>* <a class="code" href="classVarsExprsProductLattice.html#e24eb8c39c8aedd1ab28b05216f4c367">blankVEPL</a>(<span class="keyword">const</span> <a class="code" href="classVirtualCFG_1_1DataflowNode.html">DataflowNode</a>&amp; <a class="code" href="classVarsExprsProductLattice.html#a49c730dc3c72461d30313af8073eb04">n</a>, <span class="keyword">const</span> <a class="code" href="classNodeState.html">NodeState</a>&amp; <a class="code" href="classVarsExprsProductLattice.html#f00be775e7f61bdc42ca1e0b798aab51">state</a>)=0;
<a name="l00224"></a>00224         
<a name="l00225"></a>00225         <span class="keyword">public</span>:
<a name="l00226"></a>00226         <span class="comment">// creates a new VarsExprsProductLattice</span>
<a name="l00227"></a>00227         <span class="comment">// perVarLattice - sample lattice that will be associated with every variable in scope at node n</span>
<a name="l00228"></a>00228         <span class="comment">//     it should be assumed that the object pointed to by perVarLattice will be either</span>
<a name="l00229"></a>00229         <span class="comment">//     used internally by this VarsExprsProductLatticeobject or deallocated</span>
<a name="l00230"></a>00230         <span class="comment">// constVarLattices - map of additional variables and their associated lattices, that will be </span>
<a name="l00231"></a>00231         <span class="comment">//     incorporated into this VarsExprsProductLatticein addition to any other lattices for </span>
<a name="l00232"></a>00232         <span class="comment">//     currently live variables (these correspond to various useful constant variables like zeroVar)</span>
<a name="l00233"></a>00233         <span class="comment">// allVarLattice - the lattice associated with allVar (the variable that represents all of memory)</span>
<a name="l00234"></a>00234         <span class="comment">//     if allVarLattice==NULL, no support is provided for allVar</span>
<a name="l00235"></a>00235         <span class="comment">// ldva - liveness analysis result. This can be set to NULL. Or only live variables at a CFG node will be used to initialize the product lattice</span>
<a name="l00236"></a>00236         <span class="comment">// n - the dataflow node that this lattice will be associated with</span>
<a name="l00237"></a>00237         <span class="comment">// state - the NodeState at this dataflow node</span>
<a name="l00238"></a>00238         <a class="code" href="classVarsExprsProductLattice.html#a7824ca5cbba3954c0bf75d4bcd7fb00">VarsExprsProductLattice</a>(<a class="code" href="classLattice.html">Lattice</a>* <a class="code" href="classVarsExprsProductLattice.html#60be6c4c0285c84a591089b261e35c81">perVarLattice</a>, 
<a name="l00239"></a>00239                                 <span class="keyword">const</span> std::map&lt;varID, Lattice*&gt;&amp; <a class="code" href="classVarsExprsProductLattice.html#57e84a072ea92b6e309a80e82d31fb7d">constVarLattices</a>, 
<a name="l00240"></a>00240                                 <a class="code" href="classLattice.html">Lattice</a>* <a class="code" href="classVarsExprsProductLattice.html#8fcf7861ee26ea29e3ac26d0d59f8f75">allVarLattice</a>,
<a name="l00241"></a>00241                                 <a class="code" href="classLiveDeadVarsAnalysis.html">LiveDeadVarsAnalysis</a>* <a class="code" href="classVarsExprsProductLattice.html#38953d1260384d62ffe1047c9c40a8ec">ldva</a>, 
<a name="l00242"></a>00242                                 <span class="keyword">const</span> <a class="code" href="classVirtualCFG_1_1DataflowNode.html">DataflowNode</a>&amp; <a class="code" href="classVarsExprsProductLattice.html#a49c730dc3c72461d30313af8073eb04">n</a>, <span class="keyword">const</span> <a class="code" href="classNodeState.html">NodeState</a>&amp; <a class="code" href="classVarsExprsProductLattice.html#f00be775e7f61bdc42ca1e0b798aab51">state</a>);
<a name="l00243"></a>00243                                 
<a name="l00244"></a>00244         <span class="comment">// Create a copy of that. It is assumed that the types of all the lattices in  VarsExprsProductLattice that are</span>
<a name="l00245"></a>00245         <span class="comment">// the same as in this.</span>
<a name="l00246"></a>00246         <a class="code" href="classVarsExprsProductLattice.html#a7824ca5cbba3954c0bf75d4bcd7fb00">VarsExprsProductLattice</a>(<span class="keyword">const</span> <a class="code" href="classVarsExprsProductLattice.html">VarsExprsProductLattice</a>&amp; that);
<a name="l00247"></a>00247         
<a name="l00248"></a>00248         <a class="code" href="classVarsExprsProductLattice.html#f1968f50a2eeb1c4fa7584679e68b36d">~VarsExprsProductLattice</a>();
<a name="l00249"></a>00249         
<a name="l00250"></a>00250         <span class="keyword">public</span>:
<a name="l00251"></a>00251         
<a name="l00252"></a>00252         <span class="comment">// Returns the Lattice mapped to the given variable or NULL if nothing is mapped to it</span>
<a name="l00253"></a>00253         <a class="code" href="classLattice.html">Lattice</a>* <a class="code" href="classVarsExprsProductLattice.html#85aa617d7832ccaaa4f6ed6804c0e571">getVarLattice</a>(<span class="keyword">const</span> <a class="code" href="classvarID.html">varID</a>&amp; var);
<a name="l00254"></a>00254         
<a name="l00255"></a>00255         <span class="comment">// Returns the set of all variables mapped by this VarsExprsProductLattice</span>
<a name="l00256"></a>00256         std::set&lt;varID&gt; <a class="code" href="classVarsExprsProductLattice.html#de25edea3e3b1be85497701f0cf5208d">getAllVars</a>();
<a name="l00257"></a>00257         
<a name="l00258"></a>00258         <span class="keyword">protected</span>:
<a name="l00259"></a>00259         
<a name="l00260"></a>00260         <span class="comment">// Returns the index of var among the variables associated with func</span>
<a name="l00261"></a>00261         <span class="comment">// or -1 otherwise</span>
<a name="l00262"></a>00262         <span class="keywordtype">int</span> <a class="code" href="classVarsExprsProductLattice.html#fc2fa0ff99ab85c9ece33c861caf3ed4">getVarIndex</a>(<span class="keyword">const</span> <a class="code" href="classvarID.html">varID</a>&amp; var);
<a name="l00263"></a>00263         
<a name="l00264"></a>00264         <span class="keyword">public</span>:
<a name="l00265"></a>00265         
<a name="l00266"></a>00266         <span class="comment">// Overwrites the state of this Lattice with that of that Lattice</span>
<a name="l00267"></a>00267         <span class="keywordtype">void</span> <a class="code" href="classLattice.html#e87c5a14f6d44db4f278f58d785b42b4">copy</a>(<a class="code" href="classLattice.html">Lattice</a>* that);
<a name="l00268"></a>00268         <span class="comment">// Set this to be a copy of that. It is assumed that the types of all the lattices in  VarsExprsProductLattice </span>
<a name="l00269"></a>00269         <span class="comment">// that are the same as in this.</span>
<a name="l00270"></a>00270         <span class="keywordtype">void</span> <a class="code" href="classLattice.html#e87c5a14f6d44db4f278f58d785b42b4">copy</a>(<span class="keyword">const</span> <a class="code" href="classVarsExprsProductLattice.html">VarsExprsProductLattice</a>* that);
<a name="l00271"></a>00271         
<a name="l00272"></a>00272         <span class="keywordtype">bool</span> <a class="code" href="classVarsExprsProductLattice.html#21c84a3debdbdbc860c5bd3b2ce873b0">meetUpdate</a>(<a class="code" href="classLattice.html">Lattice</a> *that);
<a name="l00273"></a>00273 
<a name="l00274"></a>00274         <span class="comment">// Called by analyses to create a copy of this lattice. However, if this lattice maintains any </span>
<a name="l00275"></a>00275         <span class="comment">//    information on a per-variable basis, these per-variable mappings must be converted from </span>
<a name="l00276"></a>00276         <span class="comment">//    the current set of variables to another set. This may be needed during function calls, </span>
<a name="l00277"></a>00277         <span class="comment">//    when dataflow information from the caller/callee needs to be transferred to the callee/calleer.</span>
<a name="l00278"></a>00278         <span class="comment">// We do not force child classes to define their own versions of this function since not all</span>
<a name="l00279"></a>00279         <span class="comment">//    Lattices have per-variable information.</span>
<a name="l00280"></a>00280         <span class="comment">// varNameMap - maps all variable names that have changed, in each mapping pair, pair-&gt;first is the </span>
<a name="l00281"></a>00281         <span class="comment">//              old variable and pair-&gt;second is the new variable</span>
<a name="l00282"></a>00282         <span class="comment">// func - the function that the copy Lattice will now be associated with</span>
<a name="l00283"></a>00283 
<a name="l00285"></a>00285         <span class="comment">/*Lattice**/</span><span class="keywordtype">void</span> <a class="code" href="classVarsExprsProductLattice.html#0a51cd7ff764b8dcd2df102a65ad5dde">remapVars</a>(<span class="keyword">const</span> std::map&lt;varID, varID&gt;&amp; varNameMap, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function</a>&amp; newFunc);
<a name="l00286"></a>00286         
<a name="l00287"></a>00287         <span class="comment">// Called by analyses to copy over from the that Lattice dataflow information into this Lattice.</span>
<a name="l00288"></a>00288         <span class="comment">// that contains data for a set of variables and incorporateVars must overwrite the state of just</span>
<a name="l00289"></a>00289         <span class="comment">// those variables, while leaving its state for other variables alone.</span>
<a name="l00290"></a>00290         <span class="comment">// We do not force child classes to define their own versions of this function since not all</span>
<a name="l00291"></a>00291         <span class="comment">//    Lattices have per-variable information.</span>
<a name="l00292"></a>00292         <span class="keywordtype">void</span> <a class="code" href="classVarsExprsProductLattice.html#b29ed44ff0c0097347065720a388b68d">incorporateVars</a>(<a class="code" href="classLattice.html">Lattice</a>* that);
<a name="l00293"></a>00293         
<a name="l00294"></a>00294         <span class="comment">// Returns a Lattice that describes the information known within this lattice</span>
<a name="l00295"></a>00295         <span class="comment">// about the given expression. By default this could be the entire lattice or any portion of it.</span>
<a name="l00296"></a>00296         <span class="comment">// For example, a lattice that maintains lattices for different known variables and expression will </span>
<a name="l00297"></a>00297         <span class="comment">// return a lattice for the given expression. Similarly, a lattice that keeps track of constraints</span>
<a name="l00298"></a>00298         <span class="comment">// on values of variables and expressions will return the portion of the lattice that relates to</span>
<a name="l00299"></a>00299         <span class="comment">// the given expression. </span>
<a name="l00300"></a>00300         <span class="comment">// It it legal for this function to return NULL if no information is available.</span>
<a name="l00301"></a>00301         <span class="comment">// The function's caller is responsible for deallocating the returned object</span>
<a name="l00302"></a>00302         <a class="code" href="classLattice.html">Lattice</a>* <a class="code" href="classVarsExprsProductLattice.html#92742509528116b97afe8f86e44340ac">project</a>(<a class="code" href="classSgExpression.html">SgExpression</a>* expr);
<a name="l00303"></a>00303         
<a name="l00304"></a>00304         <span class="comment">// The inverse of project(). The call is provided with an expression and a Lattice that describes</span>
<a name="l00305"></a>00305         <span class="comment">// the dataflow state that relates to expression. This Lattice must be of the same type as the lattice</span>
<a name="l00306"></a>00306         <span class="comment">// returned by project(). unProject() must incorporate this dataflow state into the overall state it holds.</span>
<a name="l00307"></a>00307         <span class="comment">// Call must make an internal copy of the passed-in lattice and the caller is responsible for deallocating it.</span>
<a name="l00308"></a>00308         <span class="comment">// Returns true if this causes this to change and false otherwise.</span>
<a name="l00309"></a>00309         <span class="keywordtype">bool</span> <a class="code" href="classVarsExprsProductLattice.html#96ddc39cfa7b01b7bd8e349d2912d188">unProject</a>(<a class="code" href="classSgExpression.html">SgExpression</a>* expr, <a class="code" href="classLattice.html">Lattice</a>* exprState);
<a name="l00310"></a>00310         
<a name="l00311"></a>00311         <span class="comment">// Functions used to inform this lattice that a given variable is now in use (e.g. a variable has entered </span>
<a name="l00312"></a>00312         <span class="comment">//    scope or an expression is being analyzed) or is no longer in use (e.g. a variable has exited scope or</span>
<a name="l00313"></a>00313         <span class="comment">//    an expression or variable is dead).</span>
<a name="l00314"></a>00314         <span class="comment">// Returns true if this causes this Lattice to change and false otherwise.</span>
<a name="l00315"></a>00315         <span class="keywordtype">bool</span> <a class="code" href="classVarsExprsProductLattice.html#76628c1320b5f50df9243498b08cb95d">addVar</a>(<span class="keyword">const</span> <a class="code" href="classvarID.html">varID</a>&amp; var);
<a name="l00316"></a>00316         <span class="keywordtype">bool</span> <a class="code" href="classVarsExprsProductLattice.html#d014061d353e93cae7ea6603fa91ef4c">remVar</a>(<span class="keyword">const</span> <a class="code" href="classvarID.html">varID</a>&amp; var);
<a name="l00317"></a>00317         
<a name="l00318"></a>00318         <span class="comment">// Sets the lattice of the given var to be lat. </span>
<a name="l00319"></a>00319         <span class="comment">// If the variable is already mapped to some other Lattice, </span>
<a name="l00320"></a>00320         <span class="comment">//   If *(the current lattice) == *lat, the mapping is not changed</span>
<a name="l00321"></a>00321         <span class="comment">//   If *(the current lattice) != *lat, the current lattice is deallocated and var is mapped to lat-&gt;copy()</span>
<a name="l00322"></a>00322         <span class="comment">// Returns true if this causes this Lattice to change and false otherwise.</span>
<a name="l00323"></a>00323         <span class="keywordtype">bool</span> <a class="code" href="classVarsExprsProductLattice.html#76628c1320b5f50df9243498b08cb95d">addVar</a>(<span class="keyword">const</span> <a class="code" href="classvarID.html">varID</a>&amp; var, <a class="code" href="classLattice.html">Lattice</a>* lat);
<a name="l00324"></a>00324         
<a name="l00325"></a>00325         <span class="comment">// The string that represents this object</span>
<a name="l00326"></a>00326         <span class="comment">// If indent!="", every line of this string must be prefixed by indent</span>
<a name="l00327"></a>00327         <span class="comment">// The last character of the returned string should not be '\n', even if it is a multi-line string.</span>
<a name="l00328"></a>00328         std::string <a class="code" href="classVarsExprsProductLattice.html#94b019cfb95249e7ac9fae496ed4cbc9">str</a>(std::string indent=<span class="stringliteral">""</span>);
<a name="l00329"></a>00329 };
<a name="l00330"></a>00330 
<a name="l00331"></a><a class="code" href="classFiniteVarsExprsProductLattice.html">00331</a> <span class="keyword">class </span><a class="code" href="classFiniteVarsExprsProductLattice.html">FiniteVarsExprsProductLattice</a> : <span class="keyword">public</span> <span class="keyword">virtual</span> <a class="code" href="classVarsExprsProductLattice.html">VarsExprsProductLattice</a>, <span class="keyword">public</span> <span class="keyword">virtual</span> <a class="code" href="classFiniteProductLattice.html">FiniteProductLattice</a>
<a name="l00332"></a>00332 {
<a name="l00333"></a>00333         <span class="keyword">protected</span>:
<a name="l00334"></a>00334         <span class="comment">// Minimal constructor that initializes just the portions of the object required to make an </span>
<a name="l00335"></a>00335         <span class="comment">// initial blank VarsExprsProductLattice</span>
<a name="l00336"></a>00336         <a class="code" href="classFiniteVarsExprsProductLattice.html#aac2fb172ce510b30e1ec7d5cc5bb4d5">FiniteVarsExprsProductLattice</a>(<span class="keyword">const</span> <a class="code" href="classVirtualCFG_1_1DataflowNode.html">DataflowNode</a>&amp; <a class="code" href="classVarsExprsProductLattice.html#a49c730dc3c72461d30313af8073eb04">n</a>, <span class="keyword">const</span> <a class="code" href="classNodeState.html">NodeState</a>&amp; <a class="code" href="classVarsExprsProductLattice.html#f00be775e7f61bdc42ca1e0b798aab51">state</a>);
<a name="l00337"></a>00337         
<a name="l00338"></a>00338         <span class="comment">// Returns a blank instance of a VarsExprsProductLattice that only has the fields n and state set</span>
<a name="l00339"></a>00339         <a class="code" href="classVarsExprsProductLattice.html">VarsExprsProductLattice</a>* <a class="code" href="classFiniteVarsExprsProductLattice.html#2335fac89367d9dd049c95657d220890">blankVEPL</a>(<span class="keyword">const</span> <a class="code" href="classVirtualCFG_1_1DataflowNode.html">DataflowNode</a>&amp; <a class="code" href="classVarsExprsProductLattice.html#a49c730dc3c72461d30313af8073eb04">n</a>, <span class="keyword">const</span> <a class="code" href="classNodeState.html">NodeState</a>&amp; <a class="code" href="classVarsExprsProductLattice.html#f00be775e7f61bdc42ca1e0b798aab51">state</a>);
<a name="l00340"></a>00340                 
<a name="l00341"></a>00341         <span class="keyword">public</span>:
<a name="l00342"></a>00342         <span class="comment">// creates a new VarsExprsProductLattice</span>
<a name="l00343"></a>00343         <span class="comment">// perVarLattice - sample lattice that will be associated with every variable in scope at node n</span>
<a name="l00344"></a>00344         <span class="comment">//     it should be assumed that the object pointed to by perVarLattice will be either</span>
<a name="l00345"></a>00345         <span class="comment">//     used internally by this VarsExprsProductLattice object or deallocated</span>
<a name="l00346"></a>00346         <span class="comment">// constVarLattices - map of additional variables and their associated lattices, that will be </span>
<a name="l00347"></a>00347         <span class="comment">//     incorporated into this VarsExprsProductLattice in addition to any other lattices for </span>
<a name="l00348"></a>00348         <span class="comment">//     currently live variables (these correspond to various useful constant variables like zeroVar)</span>
<a name="l00349"></a>00349         <span class="comment">// allVarLattice - the lattice associated with allVar (the variable that represents all of memory)</span>
<a name="l00350"></a>00350         <span class="comment">//     if allVarLattice==NULL, no support is provided for allVar</span>
<a name="l00351"></a>00351         <span class="comment">// func - the current function</span>
<a name="l00352"></a>00352         <span class="comment">// n - the dataflow node that this lattice will be associated with</span>
<a name="l00353"></a>00353         <span class="comment">// state - the NodeState at this dataflow node</span>
<a name="l00354"></a>00354         <a class="code" href="classFiniteVarsExprsProductLattice.html#aac2fb172ce510b30e1ec7d5cc5bb4d5">FiniteVarsExprsProductLattice</a>(<a class="code" href="classLattice.html">Lattice</a>* <a class="code" href="classVarsExprsProductLattice.html#60be6c4c0285c84a591089b261e35c81">perVarLattice</a>, 
<a name="l00355"></a>00355                                      <span class="keyword">const</span> std::map&lt;varID, Lattice*&gt;&amp; <a class="code" href="classVarsExprsProductLattice.html#57e84a072ea92b6e309a80e82d31fb7d">constVarLattices</a>, 
<a name="l00356"></a>00356                                      <a class="code" href="classLattice.html">Lattice</a>* <a class="code" href="classVarsExprsProductLattice.html#8fcf7861ee26ea29e3ac26d0d59f8f75">allVarLattice</a>,
<a name="l00357"></a>00357                                      <a class="code" href="classLiveDeadVarsAnalysis.html">LiveDeadVarsAnalysis</a>* <a class="code" href="classVarsExprsProductLattice.html#38953d1260384d62ffe1047c9c40a8ec">ldva</a>, 
<a name="l00358"></a>00358                                      <span class="keyword">const</span> <a class="code" href="classVirtualCFG_1_1DataflowNode.html">DataflowNode</a>&amp; <a class="code" href="classVarsExprsProductLattice.html#a49c730dc3c72461d30313af8073eb04">n</a>, <span class="keyword">const</span> <a class="code" href="classNodeState.html">NodeState</a>&amp; <a class="code" href="classVarsExprsProductLattice.html#f00be775e7f61bdc42ca1e0b798aab51">state</a>);
<a name="l00359"></a>00359         
<a name="l00360"></a>00360         <a class="code" href="classFiniteVarsExprsProductLattice.html#aac2fb172ce510b30e1ec7d5cc5bb4d5">FiniteVarsExprsProductLattice</a>(<span class="keyword">const</span> <a class="code" href="classFiniteVarsExprsProductLattice.html">FiniteVarsExprsProductLattice</a>&amp; that);
<a name="l00361"></a>00361         
<a name="l00362"></a>00362         <span class="comment">// returns a copy of this lattice</span>
<a name="l00363"></a>00363         <a class="code" href="classLattice.html">Lattice</a>* <a class="code" href="classFiniteVarsExprsProductLattice.html#475d41305258702aa0360646cf1c28bc">copy</a>() <span class="keyword">const</span>;
<a name="l00364"></a>00364 };
<a name="l00365"></a>00365 
<a name="l00366"></a><a class="code" href="classInfiniteVarsExprsProductLattice.html">00366</a> <span class="keyword">class </span><a class="code" href="classInfiniteVarsExprsProductLattice.html">InfiniteVarsExprsProductLattice</a>: <span class="keyword">public</span> <span class="keyword">virtual</span> <a class="code" href="classVarsExprsProductLattice.html">VarsExprsProductLattice</a>, <span class="keyword">public</span> <span class="keyword">virtual</span> <a class="code" href="classInfiniteProductLattice.html">InfiniteProductLattice</a>
<a name="l00367"></a>00367 {
<a name="l00368"></a>00368         <span class="keyword">protected</span>:
<a name="l00369"></a>00369         <span class="comment">// Minimal constructor that initializes just the portions of the object required to make an </span>
<a name="l00370"></a>00370         <span class="comment">// initial blank VarsExprsProductLattice</span>
<a name="l00371"></a>00371         <a class="code" href="classInfiniteVarsExprsProductLattice.html#3d9767afb82b0d9fad8f9bdeee384ee1">InfiniteVarsExprsProductLattice</a>(<span class="keyword">const</span> <a class="code" href="classVirtualCFG_1_1DataflowNode.html">DataflowNode</a>&amp; <a class="code" href="classVarsExprsProductLattice.html#a49c730dc3c72461d30313af8073eb04">n</a>, <span class="keyword">const</span> <a class="code" href="classNodeState.html">NodeState</a>&amp; <a class="code" href="classVarsExprsProductLattice.html#f00be775e7f61bdc42ca1e0b798aab51">state</a>);
<a name="l00372"></a>00372         
<a name="l00373"></a>00373         <span class="comment">// Returns a blank instance of a VarsExprsProductLattice that only has the fields n and state set</span>
<a name="l00374"></a>00374         <a class="code" href="classVarsExprsProductLattice.html">VarsExprsProductLattice</a>* <a class="code" href="classInfiniteVarsExprsProductLattice.html#8702156479e8c1c4739af7efa7b547a5">blankVEPL</a>(<span class="keyword">const</span> <a class="code" href="classVirtualCFG_1_1DataflowNode.html">DataflowNode</a>&amp; <a class="code" href="classVarsExprsProductLattice.html#a49c730dc3c72461d30313af8073eb04">n</a>, <span class="keyword">const</span> <a class="code" href="classNodeState.html">NodeState</a>&amp; <a class="code" href="classVarsExprsProductLattice.html#f00be775e7f61bdc42ca1e0b798aab51">state</a>);
<a name="l00375"></a>00375         
<a name="l00376"></a>00376         <span class="keyword">public</span>:
<a name="l00377"></a>00377         <span class="comment">// creates a new VarsExprsProductLattice</span>
<a name="l00378"></a>00378         <span class="comment">// perVarLattice - sample lattice that will be associated with every variable in scope at node n</span>
<a name="l00379"></a>00379         <span class="comment">//     it should be assumed that the object pointed to by perVarLattice will be either</span>
<a name="l00380"></a>00380         <span class="comment">//     used internally by this VarsExprsProductLatticeobject or deallocated</span>
<a name="l00381"></a>00381         <span class="comment">// constVarLattices - map of additional variables and their associated lattices, that will be </span>
<a name="l00382"></a>00382         <span class="comment">//     incorporated into this VarsExprsProductLatticein addition to any other lattices for </span>
<a name="l00383"></a>00383         <span class="comment">//     currently live variables (these correspond to various useful constant variables like zeroVar)</span>
<a name="l00384"></a>00384         <span class="comment">// allVarLattice - the lattice associated with allVar (the variable that represents all of memory)</span>
<a name="l00385"></a>00385         <span class="comment">//     if allVarLattice==NULL, no support is provided for allVar</span>
<a name="l00386"></a>00386         <span class="comment">// func - the current function</span>
<a name="l00387"></a>00387         <span class="comment">// n - the dataflow node that this lattice will be associated with</span>
<a name="l00388"></a>00388         <span class="comment">// state - the NodeState at this dataflow node</span>
<a name="l00389"></a>00389         <a class="code" href="classInfiniteVarsExprsProductLattice.html#3d9767afb82b0d9fad8f9bdeee384ee1">InfiniteVarsExprsProductLattice</a>(<a class="code" href="classLattice.html">Lattice</a>* <a class="code" href="classVarsExprsProductLattice.html#60be6c4c0285c84a591089b261e35c81">perVarLattice</a>, 
<a name="l00390"></a>00390                                         <span class="keyword">const</span> std::map&lt;varID, Lattice*&gt;&amp; <a class="code" href="classVarsExprsProductLattice.html#57e84a072ea92b6e309a80e82d31fb7d">constVarLattices</a>, 
<a name="l00391"></a>00391                                         <a class="code" href="classLattice.html">Lattice</a>* <a class="code" href="classVarsExprsProductLattice.html#8fcf7861ee26ea29e3ac26d0d59f8f75">allVarLattice</a>,
<a name="l00392"></a>00392                                         <a class="code" href="classLiveDeadVarsAnalysis.html">LiveDeadVarsAnalysis</a>* <a class="code" href="classVarsExprsProductLattice.html#38953d1260384d62ffe1047c9c40a8ec">ldva</a>, 
<a name="l00393"></a>00393                                         <span class="keyword">const</span> <a class="code" href="classVirtualCFG_1_1DataflowNode.html">DataflowNode</a>&amp; <a class="code" href="classVarsExprsProductLattice.html#a49c730dc3c72461d30313af8073eb04">n</a>, <span class="keyword">const</span> <a class="code" href="classNodeState.html">NodeState</a>&amp; <a class="code" href="classVarsExprsProductLattice.html#f00be775e7f61bdc42ca1e0b798aab51">state</a>);
<a name="l00394"></a>00394         
<a name="l00395"></a>00395         <a class="code" href="classInfiniteVarsExprsProductLattice.html#3d9767afb82b0d9fad8f9bdeee384ee1">InfiniteVarsExprsProductLattice</a>(<span class="keyword">const</span> <a class="code" href="classFiniteVarsExprsProductLattice.html">FiniteVarsExprsProductLattice</a>&amp; that);
<a name="l00396"></a>00396         
<a name="l00397"></a>00397         <span class="comment">// returns a copy of this lattice</span>
<a name="l00398"></a>00398         <a class="code" href="classLattice.html">Lattice</a>* <a class="code" href="classInfiniteVarsExprsProductLattice.html#33982d51a219b8746cf080877803a96b">copy</a>() <span class="keyword">const</span>;
<a name="l00399"></a>00399 };
<a name="l00400"></a>00400 
<a name="l00401"></a>00401 <span class="comment">// prints the Lattices set by the given LiveDeadVarsAnalysis </span>
<a name="l00402"></a>00402 <span class="keywordtype">void</span> <a class="code" href="liveDeadVarAnalysis_8h.html#d448d62cda9b33cadbd0c47548a41811">printLiveDeadVarsAnalysisStates</a>(<a class="code" href="classLiveDeadVarsAnalysis.html">LiveDeadVarsAnalysis</a>* da, std::string indent=<span class="stringliteral">""</span>);
<a name="l00403"></a>00403 
<a name="l00404"></a>00404 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
