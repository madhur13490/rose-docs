<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: BinaryAnalysis::InstructionSemantics::MultiSemantics&lt; ValueType0, State0, Policy0, ValueType1, State1, Policy1, ValueType2, State2, Policy2, ValueType3, State3, Policy3 &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceBinaryAnalysis.html">BinaryAnalysis</a>::<a class="el" href="namespaceBinaryAnalysis_1_1InstructionSemantics.html">InstructionSemantics</a>::<a class="el" href="classBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics.html">MultiSemantics</a></div>
<h1>BinaryAnalysis::InstructionSemantics::MultiSemantics&lt; ValueType0, State0, Policy0, ValueType1, State1, Policy1, ValueType2, State2, Policy2, ValueType3, State3, Policy3 &gt; Class Template Reference</h1><!-- doxytag: class="BinaryAnalysis::InstructionSemantics::MultiSemantics" --><code>#include &lt;<a class="el" href="MultiSemantics_8h-source.html">MultiSemantics.h</a>&gt;</code>
<p>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;template&lt; size_t nBits &gt; class ValueType0, template&lt; template&lt; size_t &gt; class ValueType &gt; class State0, template&lt; template&lt; template&lt; size_t &gt; class ValueType &gt; class State, template&lt; size_t &gt; class ValueType &gt; class Policy0, template&lt; size_t nBits &gt; class ValueType1 = NullSemantics::ValueType, template&lt; template&lt; size_t &gt; class ValueType &gt; class State1 = NullSemantics::State, template&lt; template&lt; template&lt; size_t &gt; class ValueType &gt; class State, template&lt; size_t &gt; class ValueType &gt; class Policy1 = NullSemantics::Policy, template&lt; size_t nBits &gt; class ValueType2 = NullSemantics::ValueType, template&lt; template&lt; size_t &gt; class ValueType &gt; class State2 = NullSemantics::State, template&lt; template&lt; template&lt; size_t &gt; class ValueType &gt; class State, template&lt; size_t &gt; class ValueType &gt; class Policy2 = NullSemantics::Policy, template&lt; size_t nBits &gt; class ValueType3 = NullSemantics::ValueType, template&lt; template&lt; size_t &gt; class ValueType &gt; class State3 = NullSemantics::State, template&lt; template&lt; template&lt; size_t &gt; class ValueType &gt; class State, template&lt; size_t &gt; class ValueType &gt; class Policy3 = NullSemantics::Policy&gt;<br>
 class BinaryAnalysis::InstructionSemantics::MultiSemantics&lt; ValueType0, State0, Policy0, ValueType1, State1, Policy1, ValueType2, State2, Policy2, ValueType3, State3, Policy3 &gt;</h3>

Semantic domain composed of sub-domains. 
<p>
The <a class="el" href="classBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics.html">MultiSemantics</a> semantic domain is a pseudo domain composed of one or more sub-domains. Each of the RISC-like operations implemented in this policy invoke the operation in each of the sub-policies. The type of values manipulated by this policy are the union of values from each of the sub-policies. One could accomplish the same thing by instantiating multiple instruction semantic objects and calling each one for each instruction. However, using this <a class="el" href="classBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics.html">MultiSemantics</a> policy is cleaner and easier to specialize.<p>
A multi-policy is created by listing all the sub-policy value types, state types, and policy types in the MultiPolicy template class. For instance, to declare a multi-policy that does both full-symbolic semantics (<a class="el" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1SymbolicSemantics.html">SymbolicSemantics</a>) and partial-symbolic semantics (<a class="el" href="namespaceBinaryAnalysis_1_1InstructionSemantics_1_1PartialSymbolicSemantics.html">PartialSymbolicSemantics</a>) do this:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include "<a class="code" href="MultiSemantics_8h.html">MultiSemantics.h</a>"</span>
<span class="preprocessor">  #include "<a class="code" href="SymbolicSemantics_8h.html">SymbolicSemantics.h</a>"</span>
<span class="preprocessor">  #include "<a class="code" href="PartialSymbolicSemantics_8h.html">PartialSymbolicSemantics.h</a>"</span>

  <span class="keyword">typedef</span> MultiSemantics&lt;
      SymbolicSemantics::ValueType,           <span class="comment">// first data type</span>
      SymbolicSemantics::State,               <span class="comment">// first state</span>
      SymbolicSemantics::Policy,              <span class="comment">// first policy</span>
      PartialSymbolicSemantics::ValueType,    <span class="comment">// second data type</span>
      PartialSymbolicSemantics::State,        <span class="comment">// second state</span>
      PartialSymbolicSemantics::Policy        <span class="comment">// second policy</span>
      <span class="comment">// etc.</span>
                         &gt;::Policy Policy;
</pre></div><p>
Note that <a class="el" href="classBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics.html">MultiSemantics</a> is a class while many of the other semantic domains are implemented as name spaces. We used a class here so that template arguments could be specified for the <a class="el" href="classBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics.html">MultiSemantics</a> as a whole rather than specifying them repeatedly for the <a class="el" href="classBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics_1_1Policy.html">Policy</a>, <a class="el" href="classBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics_1_1State.html">State</a>, and <a class="el" href="classBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics_1_1ValueType.html">ValueType</a> classes. Those inner classes also take template arguments similar to their counterparts in other semantic domains.<p>
The sub-policies are identified by the tag types <a class="el" href="structBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics_1_1SP0.html">SP0</a>, <a class="el" href="structBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics_1_1SP1.html">SP1</a>, etc.:<p>
<div class="fragment"><pre class="fragment">  SymbolicSemantics::Policy&lt;&gt;        &amp;sp0 = get_subpolicy(SP0());
  PartialSymbolicSemantics::Policy&lt;&gt; &amp;sp1 = get_subpolicy(SP1());
</pre></div><p>
A multi-value has one sub-value for each sub-policy. Like the sub-policies themselves, the sub-values are identified by the <a class="el" href="structBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics_1_1SP0.html">SP0</a>, <a class="el" href="structBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics_1_1SP1.html">SP1</a>, etc., tags:<p>
<div class="fragment"><pre class="fragment">  ValueType&lt;32&gt; v = ....; <span class="comment">// the multi-policy value, or "multi-value"</span>
  SymbolicSemantics::ValueType&lt;32&gt;        v0 = v.get_subvalue(SP0());
  PartialSymbolicSemantics::ValueType&lt;32&gt; v1 = v.get_subvalue(SP1());
</pre></div><p>
Individual sub-values of a multi-value can be marked as invalid. A sub-value must still necessarily be stored at that slot in the multi-value:<p>
<div class="fragment"><pre class="fragment">  ValueType&lt;32&gt; v = ....; <span class="comment">// the multi-value</span>
  <span class="keywordflow">if</span> (v.is_valid(SP0())) {
      std::cout &lt;&lt;<span class="stringliteral">"sub-value 0 is "</span> &lt;&lt;v.get_subvalue(SP0()) &lt;&lt;std::endl;
      v.set_valid(SP0(), <span class="keyword">false</span>); <span class="comment">// or v.clear_valid(SP0())</span>
  }
</pre></div><p>
A sub-value can be modified with the set_subvalue() method, which also (by default) makes that sub-value slot valid.<p>
Similar to marking a sub-value as invalid, a sub-policy can be marked as inactive. When the a RISC operation is called in the multi-policy, the same operation will be invoked in each of the active sub-policies (provided the operation's inputs are valid for that sub-policy). If the operation returns a multi-value (as most do), then the sub-values corresponding to called sub-policies will be marked valid and the other sub-values are marked invalid.<p>
Using a multi-policy directly is not all that interesting. Where the real convenience comes is in specializing the multi-policy to do things like convert values from one domain to another. For example, consider two semantic domains called Alpha and Beta implemented by policies, AlphaPolicy and BetaPolicy, and operating on values of type AlphaValue and BetaValue. Assume that for some reason, and ADD operation in BetaPolicy is expensive and that a BetaValue can be constructed from an AlphaValue. Therefore, it is more efficient to skip the ADD operation in BetaPolicy and instead compute the Beta sum from the Alpha sum, like this:<p>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> MultiPolicy&lt;AlphaType, AlphaState, AlphaPolicy, BetaType, BetaState, BetaPolicy&gt; BaseClass;
  <span class="keyword">class </span>MyPolicy: <span class="keyword">public</span> BaseClass {
  <span class="keyword">public</span>:
      <span class="keyword">template</span>&lt;size_t nBits&gt;
      ValueType&lt;nBits&gt; <a class="code" href="namespacecfgUtils.html#495bbf2d6fb84a47ca0cc937068ab793">add</a>(<span class="keyword">const</span> ValueType&lt;nBits&gt; &amp;a, <span class="keyword">const</span> ValueType&lt;nBits&gt; &amp;b)<span class="keyword"> const </span>{
          ActiveMask old_active = get_active_policies(); <span class="comment">// what sub-policies are active?</span>
          <span class="keywordflow">try</span> {
              disable_policy(SP1()); <span class="comment">// temporarily disable BetaPolicy</span>
              ValueType&lt;nBits&gt; retval = BaseClass::add&lt;nBits&gt;(a, b);
              assert(!retval.is_valid(SP1())); <span class="comment">// the beta value is not valid, its "add" having not been called</span>
              BetaValue betaValue = retval.get_subvalue(SP1()); <span class="comment">// construct the beta value from alpha</span>
              retval.set_subvalue(betaValue); <span class="comment">// define the beta value and make it valid</span>
              set_active_policies(old_active); <span class="comment">// restore original value</span>
          } <span class="keywordflow">catch</span>(...) {
              set_active_policies(old_active); <span class="comment">// restore on error</span>
          }
          <span class="keywordflow">return</span> retval;
      }
  };
</pre></div><p>
The convenience of using a MultiPolicy increases with the number of sub-policies it contains. 
<p>

<p>
Definition at line <a class="el" href="MultiSemantics_8h-source.html#l00135">135</a> of file <a class="el" href="MultiSemantics_8h-source.html">MultiSemantics.h</a>.<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics_1_1Policy.html">Policy</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implements the RISC operations.  <a href="classBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics_1_1Policy.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics_1_1SP0.html">SP0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag to identify a certain sub-policy or sub-value.  <a href="structBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics_1_1SP0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics_1_1SP1.html">SP1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">&lt; See <a class="el" href="structBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics_1_1SP0.html">SP0</a>.  <a href="structBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics_1_1SP1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics_1_1SP2.html">SP2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">&lt; See <a class="el" href="structBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics_1_1SP0.html">SP0</a>.  <a href="structBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics_1_1SP2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics_1_1SP3.html">SP3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">&lt; See <a class="el" href="structBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics_1_1SP0.html">SP0</a>.  <a href="structBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics_1_1SP3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics_1_1State.html">State</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">MultiSemanics global state.  <a href="classBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics_1_1State.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics_1_1ValueType.html">ValueType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of each MultiSemantic value.  <a href="classBinaryAnalysis_1_1InstructionSemantics_1_1MultiSemantics_1_1ValueType.html#_details">More...</a><br></td></tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="MultiSemantics_8h-source.html">MultiSemantics.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
