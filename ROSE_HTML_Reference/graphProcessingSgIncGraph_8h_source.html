<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ROSE: graphProcessingSgIncGraph.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.9.5a</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('graphProcessingSgIncGraph_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">graphProcessingSgIncGraph.h</div>  </div>
</div>
<div class="contents">
<a href="graphProcessingSgIncGraph_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">FINISH TEMPFLATPATH CODE</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">*/</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="comment">// Original Author (SgGraphTraversal mechanisms): Michael Hoffman</span>
<a name="l00011"></a>00011 <span class="comment">//$id$</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include&lt;<a class="code" href="omp_8h.html">omp.h</a>&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;boost/regex.hpp&gt;</span> 
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00017"></a>00017 
<a name="l00071"></a>00071 <span class="preprocessor">#include &quot;<a class="code" href="staticCFG_8h.html">staticCFG.h</a>&quot;</span>
<a name="l00072"></a>00072 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00073"></a>00073 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00074"></a>00074 <span class="preprocessor">#include &lt;utility&gt;</span>
<a name="l00075"></a>00075 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00076"></a>00076 <span class="preprocessor">#include &lt;sys/time.h&gt;</span>
<a name="l00077"></a>00077 <span class="preprocessor">#include &lt;sys/resource.h&gt;</span>
<a name="l00078"></a>00078 <span class="comment">//#include &quot;graphBot.h&quot;</span>
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 <span class="comment">//This is necessary for technical reasons with regards to the graphnodeinheritedmap</span>
<a name="l00081"></a>00081 
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 <span class="keyword">struct </span><a class="code" href="structBot.html">Bot</a> {
<a name="l00085"></a><a class="code" href="structBot.html#a084e3d4addb541c1194ba6c9d96a2616">00085</a>     std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; <a class="code" href="structBot.html#a084e3d4addb541c1194ba6c9d96a2616">path</a>;
<a name="l00086"></a><a class="code" href="structBot.html#a9bdf9738d9a5b2d9414e3b64d0cadaab">00086</a>     std::vector&lt;std::set&lt;SgGraphNode*&gt; &gt; <a class="code" href="structBot.html#a9bdf9738d9a5b2d9414e3b64d0cadaab">pthloops</a>;
<a name="l00087"></a><a class="code" href="structBot.html#a193d61aaab58ff5ef4cc7aefa7d3b26c">00087</a>     std::vector&lt;SgGraphNode*&gt; <a class="code" href="structBot.html#a193d61aaab58ff5ef4cc7aefa7d3b26c">currpth</a>;
<a name="l00088"></a><a class="code" href="structBot.html#a342114ebd967891434f6bca94cc71fa5">00088</a>     std::vector&lt;std::pair&lt;SgGraphNode*, int&gt; &gt; <a class="code" href="structBot.html#a342114ebd967891434f6bca94cc71fa5">nodelst</a>;
<a name="l00089"></a>00089     <span class="keywordtype">bool</span> <a class="code" href="structBot.html#a8fc3e19ff7ef78630332371059abb1c6">on</a>;
<a name="l00090"></a>00090     <span class="keywordtype">bool</span> <span class="keyword">remove</span>;
<a name="l00091"></a>00091 };
<a name="l00092"></a>00092 
<a name="l00093"></a><a class="code" href="graphProcessingSgIncGraph_8h.html#a40a1fde73ef84f6eabd6cb8ad29f67ef">00093</a> <span class="keywordtype">double</span> <a class="code" href="graphProcessing_8h.html#ae0e3d51bc94bbc9201f1125a8407492f">timeDifference</a>(<span class="keyword">const</span> <span class="keyword">struct</span> timeval&amp; end, <span class="keyword">const</span> <span class="keyword">struct</span> timeval&amp; begin)
<a name="l00094"></a>00094 {
<a name="l00095"></a>00095     <span class="keywordflow">return</span> (end.tv_sec + end.tv_usec / 1.0e6) - (begin.tv_sec + begin.tv_usec / 1.0e6);
<a name="l00096"></a>00096 }
<a name="l00097"></a>00097 
<a name="l00098"></a><a class="code" href="graphProcessingSgIncGraph_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">00098</a> <span class="keyword">static</span> <span class="keyword">inline</span> timeval <a class="code" href="graphProcessingSgIncGraph_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>() {
<a name="l00099"></a>00099   rusage ru;
<a name="l00100"></a>00100   getrusage(RUSAGE_SELF, &amp;ru);
<a name="l00101"></a>00101   <span class="keywordflow">return</span> ru.ru_utime;
<a name="l00102"></a>00102 }
<a name="l00103"></a>00103 
<a name="l00104"></a>00104 
<a name="l00105"></a><a class="code" href="structcompareSgGraphNode.html">00105</a> <span class="keyword">struct </span><a class="code" href="structcompareSgGraphNode.html">compareSgGraphNode</a> {
<a name="l00106"></a><a class="code" href="structcompareSgGraphNode.html#a3041199e8c70cbdfec1d219bd79db1a9">00106</a>     <span class="keywordtype">bool</span> <a class="code" href="structcompareSgGraphNode.html#a3041199e8c70cbdfec1d219bd79db1a9">operator()</a>(<span class="keyword">const</span> <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* a, <span class="keyword">const</span> <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* b)<span class="keyword"> const</span>
<a name="l00107"></a>00107 <span class="keyword">    </span>{
<a name="l00108"></a>00108         <span class="keywordflow">return</span> a==b;
<a name="l00109"></a>00109     }
<a name="l00110"></a>00110 };
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 
<a name="l00113"></a>00113 <span class="comment">/* The SgGraphTraversal class is utilized specifically for StaticCFG traversals,</span>
<a name="l00114"></a>00114 <span class="comment">though the input must be in terms of a SgIncidenceDirectedGraph*/</span>
<a name="l00115"></a>00115 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType&gt;
<a name="l00116"></a>00116 <span class="keyword">class </span><a class="code" href="classSgGraphTraversal.html">SgGraphTraversal</a>
<a name="l00117"></a>00117 {
<a name="l00118"></a>00118    <span class="keyword">public</span>:
<a name="l00119"></a>00119     std::set&lt;std::map&lt;int, std::set&lt;int&gt; &gt; &gt; <a class="code" href="classSgGraphTraversal.html#afea7285025827aea865d8d19edb27efc">subpathmap</a>;
<a name="l00120"></a>00120     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a2a7a4163971673b004c06ef672c3f379">loopNum</a>;
<a name="l00121"></a>00121     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a80f870b4362ed6c7d69f3a07f5f90301">nullNum</a>;
<a name="l00122"></a><a class="code" href="classSgGraphTraversal.html#a2c6dc558579af5cca58387105009d99c">00122</a>     std::set&lt;SgDirectedGraphEdge*&gt; <a class="code" href="classSgGraphTraversal.html#a2c6dc558579af5cca58387105009d99c">nullEdgesOrdered</a>;
<a name="l00123"></a><a class="code" href="classSgGraphTraversal.html#a9000b3ebe5924022166ca593c52f768c">00123</a>     std::map&lt;SgGraphNode*, int&gt; <a class="code" href="classSgGraphTraversal.html#a9000b3ebe5924022166ca593c52f768c">loopNumMap</a>;
<a name="l00124"></a><a class="code" href="classSgGraphTraversal.html#a51ecd68e3214f4b5b73fd9f333512db5">00124</a>     std::map&lt;SgGraphNode*, int&gt; <a class="code" href="classSgGraphTraversal.html#a51ecd68e3214f4b5b73fd9f333512db5">pathValMap</a>;
<a name="l00125"></a>00125     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a61d4b1defc45ebf7aa6c8af6fb24e35e">nullloops</a>;
<a name="l00126"></a><a class="code" href="classSgGraphTraversal.html#a537c95d074446bc2b668c095a1cbbbaf">00126</a>     std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; <a class="code" href="classSgGraphTraversal.html#a537c95d074446bc2b668c095a1cbbbaf">looppaths</a>;
<a name="l00127"></a><a class="code" href="classSgGraphTraversal.html#a79425d6bb0441cc2bcea2642b68a9eb4">00127</a>     std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; <a class="code" href="classSgGraphTraversal.html#a79425d6bb0441cc2bcea2642b68a9eb4">iLoops</a>;
<a name="l00128"></a><a class="code" href="classSgGraphTraversal.html#afd1647279dc66602bbcd4f60ee21e33e">00128</a>     std::vector&lt;SgGraphNode*&gt; <a class="code" href="classSgGraphTraversal.html#afd1647279dc66602bbcd4f60ee21e33e">ifstatements</a>;
<a name="l00129"></a>00129     <span class="keyword">virtual</span> <a class="code" href="classSgGraphTraversal.html#a88455ca855d3460510a2d6cfe9cb0b38">~SgGraphTraversal</a>(); 
<a name="l00130"></a>00130     <a class="code" href="classSgGraphTraversal.html#a9a20dc8d3bb63d107a81929187c72673">SgGraphTraversal</a>(); 
<a name="l00131"></a>00131     <span class="comment">// Copy operations</span>
<a name="l00132"></a>00132     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#af27cb30367c033466a4cdca4a11b8535">nullEdgesPaths</a>;
<a name="l00133"></a>00133     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a6645743b2a28141ddf7fb0778154072d">turns</a>;
<a name="l00134"></a>00134     <a class="code" href="classSgGraphTraversal.html#a9a20dc8d3bb63d107a81929187c72673">SgGraphTraversal</a>(<span class="keyword">const</span> <a class="code" href="classSgGraphTraversal.html">SgGraphTraversal</a> &amp;);
<a name="l00135"></a>00135     <span class="keyword">const</span> <a class="code" href="classSgGraphTraversal.html">SgGraphTraversal</a> &amp;<a class="code" href="classSgGraphTraversal.html#a9066477debed9798e60fe3a767151364">operator=</a>(<span class="keyword">const</span> <a class="code" href="classSgGraphTraversal.html">SgGraphTraversal</a> &amp;);
<a name="l00136"></a>00136     <span class="comment">//This is not used, but will be important if SynthesizedAttributes become useful</span>
<a name="l00137"></a><a class="code" href="classSgGraphTraversal.html#ad8970fc30ffc6127100d5a2699c6ac8e">00137</a>     <span class="keyword">typedef</span> <a class="code" href="classStackFrameVector.html">StackFrameVector&lt;SynthesizedAttributeType&gt;</a> <a class="code" href="classSgGraphTraversal.html#ad8970fc30ffc6127100d5a2699c6ac8e">SynthesizedAttributesList</a>;
<a name="l00138"></a>00138     <span class="comment">//one of the most important structures in the algorithm, this attaches SgGraphNode*s to InheritedAttributeTypes so that</span>
<a name="l00139"></a>00139     <span class="comment">//looking up the values is possible.</span>
<a name="l00140"></a>00140     <span class="comment">//int numnodes;</span>
<a name="l00141"></a>00141     <span class="comment">//std::map&lt;SgGraphNode*, InheritedAttributeType&gt; seen;</span>
<a name="l00142"></a>00142     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a3786ab1d3d63cca878d748238375f8a0">numnodes</a>;
<a name="l00143"></a>00143     <span class="comment">//InheritedAttributeType pthgraphinherit;</span>
<a name="l00144"></a>00144     <span class="comment">//StaticCFG::CFG* SgCFG;</span>
<a name="l00145"></a><a class="code" href="classSgGraphTraversal.html#a948c2bc00b192e3521393cfc910eb1bf">00145</a>     <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* <a class="code" href="classSgGraphTraversal.html#a948c2bc00b192e3521393cfc910eb1bf">nullnode</a>;
<a name="l00146"></a><a class="code" href="classSgGraphTraversal.html#aacd4bf9a994a1750ed3e5121ab63f7e5">00146</a>     std::map&lt;SgGraphNode*, int&gt; <a class="code" href="classSgGraphTraversal.html#aacd4bf9a994a1750ed3e5121ab63f7e5">primenode</a>;
<a name="l00147"></a>00147     <span class="keywordtype">bool</span> <a class="code" href="classSgGraphTraversal.html#a5b366f99397c86b7e6d3df5c9850cb70">done</a>;
<a name="l00148"></a>00148     <span class="comment">//std::set&lt;SgGraphNode*&gt; startnodes;</span>
<a name="l00149"></a><a class="code" href="classSgGraphTraversal.html#ab7543e197384bc9761787ccfc683133d">00149</a>     std::set&lt;SgGraphNode*&gt; <a class="code" href="classSgGraphTraversal.html#ab7543e197384bc9761787ccfc683133d">lstN</a>;
<a name="l00150"></a><a class="code" href="classSgGraphTraversal.html#a6e30b5c23301ab471d90a0375e0dc9be">00150</a>     std::map&lt;SgGraphNode*, std::vector&lt;std::set&lt;int&gt; &gt; &gt; <a class="code" href="classSgGraphTraversal.html#a6e30b5c23301ab471d90a0375e0dc9be">lstordmap</a>;
<a name="l00151"></a><a class="code" href="classSgGraphTraversal.html#a1a0d7da6d66358b845d139a92651f433">00151</a>     std::set&lt;SgGraphNode*&gt; <a class="code" href="classSgGraphTraversal.html#a1a0d7da6d66358b845d139a92651f433">solvedLoops</a>;
<a name="l00152"></a><a class="code" href="classSgGraphTraversal.html#a3f6bd96e37ad18fed62dbcb6d6ab8234">00152</a>     std::map&lt;SgGraphNode*, std::vector&lt;SgGraphNode*&gt; &gt; <a class="code" href="classSgGraphTraversal.html#a3f6bd96e37ad18fed62dbcb6d6ab8234">checkednodes</a>; 
<a name="l00153"></a><a class="code" href="classSgGraphTraversal.html#acc574cd40da1b410573a35e93c1648c3">00153</a>     std::map&lt;SgGraphNode*, std::set&lt;SgGraphNode*&gt; &gt; <a class="code" href="classSgGraphTraversal.html#acc574cd40da1b410573a35e93c1648c3">downed</a>;
<a name="l00154"></a>00154    
<a name="l00155"></a>00155     <span class="comment">//std::map&lt;SgGraphNode*, int&gt; nodeinedgordmap;</span>
<a name="l00156"></a>00156     <span class="comment">//a value for nodes that have no value, set in the traverse function</span>
<a name="l00157"></a>00157     InheritedAttributeType <a class="code" href="classSgGraphTraversal.html#a6bf1613b154789a97fbb1bad9b299a7b">nullInherit</a>;
<a name="l00158"></a>00158     <span class="comment">//the user invoked function, runs the algorithm</span>
<a name="l00159"></a>00159     InheritedAttributeType <a class="code" href="classSgGraphTraversal.html#a9b6874b8b18d2368b29e17eb63a15034">traverse</a>(<a class="code" href="classSgGraphNode.html">SgGraphNode</a>* basenode, <a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g,
<a name="l00160"></a>00160             InheritedAttributeType inheritedValue, InheritedAttributeType <a class="code" href="classSgGraphTraversal.html#a6bf1613b154789a97fbb1bad9b299a7b">nullInherit</a>,
<a name="l00161"></a>00161             <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* endnode, <span class="keywordtype">bool</span> insep = <span class="keyword">false</span>, <span class="keywordtype">bool</span> pcHk = <span class="keyword">false</span>);
<a name="l00162"></a><a class="code" href="classSgGraphTraversal.html#acc771a39e65bd047cf9ab60be4443283">00162</a>     std::set&lt;SgGraphNode*&gt; <a class="code" href="classSgGraphTraversal.html#acc771a39e65bd047cf9ab60be4443283">loopSet</a>;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164    <span class="keyword">protected</span>:
<a name="l00165"></a>00165     <span class="comment">//User defined functions to do whatever is needed in evaluation</span>
<a name="l00166"></a>00166     <span class="comment">//All the user gets access to is the node in question</span>
<a name="l00167"></a>00167     <span class="comment">//and the values of the parent nodes (this should be all that is necessary)</span>
<a name="l00168"></a>00168     <span class="keyword">virtual</span> InheritedAttributeType <a class="code" href="classSgGraphTraversal.html#a02a67d526647e3d5a2bf391c0fde7310">evaluateInheritedAttribute</a>(<a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n,
<a name="l00169"></a>00169             std::vector&lt;InheritedAttributeType&gt; inheritedValues) = 0;
<a name="l00170"></a>00170     <span class="comment">//Not used, but may be useful if SynthesizedAttributes become workable in this context</span>
<a name="l00171"></a>00171     <span class="keyword">virtual</span> SynthesizedAttributeType <a class="code" href="classSgGraphTraversal.html#ad450227a87a9a93ff59971cce027a8f2">evaluateSynthesizedAttribute</a>(<a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n,
<a name="l00172"></a>00172             InheritedAttributeType in,
<a name="l00173"></a>00173             <a class="code" href="classStackFrameVector.html">SynthesizedAttributesList</a> l) = 0;
<a name="l00174"></a>00174 
<a name="l00175"></a>00175 <span class="preprocessor">#if !USE_ROSE</span>
<a name="l00176"></a>00176 <span class="preprocessor"></span> <span class="comment">// DQ (11/3/2011): EDG compilains about this (but GNU allowed it, I think that EDG might be correct,</span>
<a name="l00177"></a>00177  <span class="comment">// namely that the value of a reference must be an lvalue (not NULL).  But since we are only trying </span>
<a name="l00178"></a>00178  <span class="comment">// to compile ROSE with ROSE (using the new EDG 4.3 front-end as a tests) we can just skip this case for now.</span>
<a name="l00179"></a>00179     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#ac3700958711d628fcf55a3410931dca7">pathAnalyze</a>(std::vector&lt;SgGraphNode*&gt;&amp; pth, <span class="keywordtype">bool</span> loop=<span class="keyword">false</span>, std::set&lt;std::vector&lt;SgGraphNode*&gt; &gt;&amp; incloops=NULL) = 0;
<a name="l00180"></a>00180 <span class="preprocessor">#else</span>
<a name="l00181"></a>00181 <span class="preprocessor"></span>    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#ac3700958711d628fcf55a3410931dca7">pathAnalyze</a>(std::vector&lt;SgGraphNode*&gt;&amp; pth, <span class="keywordtype">bool</span> loop, std::set&lt;std::vector&lt;SgGraphNode*&gt; &gt;&amp; incloops) = 0;
<a name="l00182"></a>00182 <span class="preprocessor">#endif</span>
<a name="l00183"></a>00183 <span class="preprocessor"></span>
<a name="l00184"></a>00184     <span class="comment">//also not used, but important for possible later use of SynthesizedAttributes</span>
<a name="l00185"></a>00185     SynthesizedAttributeType <a class="code" href="classSgGraphTraversal.html#a518fd34370e6be9c357524280421d7e9">defaultSynthesizedAttribute</a>(InheritedAttributeType);
<a name="l00186"></a>00186    <span class="keyword">private</span>:
<a name="l00187"></a>00187     <span class="keywordtype">double</span> <a class="code" href="classSgGraphTraversal.html#a3362fef3719a570efb8f2b7da0f0d3ce">distime</a>;
<a name="l00188"></a>00188     <span class="comment">//std::set&lt;std::pair&lt;std::pair&lt;SgGraphNode*, SgGraphNode*&gt;, std::pair&lt;SgGraphNode*, SgGraphNode*&gt; &gt; &gt; flpset;</span>
<a name="l00189"></a>00189     <span class="comment">//std::set&lt;std::pair&lt;std::pair&lt;SgGraphNode*, SgGraphNode*&gt;, std::pair&lt;SgGraphNode*, SgGraphNode*&gt; &gt; &gt; goodset;</span>
<a name="l00190"></a><a class="code" href="classSgGraphTraversal.html#a86c0397c0c1029ac7c003b80ab6b3797">00190</a>     std::set&lt;SgGraphNode*&gt; <a class="code" href="classSgGraphTraversal.html#a86c0397c0c1029ac7c003b80ab6b3797">ploops</a>;
<a name="l00191"></a><a class="code" href="classSgGraphTraversal.html#a088b474b2e9c79bf3bc5c6108d49335c">00191</a>     std::map&lt;SgGraphNode*, std::set&lt;std::vector&lt;SgGraphNode*&gt; &gt; &gt; <a class="code" href="classSgGraphTraversal.html#a088b474b2e9c79bf3bc5c6108d49335c">lpbegins</a>;
<a name="l00192"></a><a class="code" href="classSgGraphTraversal.html#af117402da3547acf62b4c3a36cecac2c">00192</a>     std::map&lt;SgGraphNode*, int&gt; <a class="code" href="classSgGraphTraversal.html#af117402da3547acf62b4c3a36cecac2c">frksLeft</a>;
<a name="l00193"></a>00193     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#af7ac460d0ea02e7713db020370979820">currm</a>;
<a name="l00194"></a>00194     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a34eeb5582f97c4a69b9ba9256c062877">dpMax</a>;
<a name="l00195"></a>00195     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#ae7c04eef5356511034140d597cd0674c">repEval</a>;
<a name="l00196"></a>00196     <span class="keywordtype">bool</span> <a class="code" href="classSgGraphTraversal.html#ac8d780ea63ecbb78a26f1ad3c842cdd2">pathCheck</a>;
<a name="l00197"></a>00197     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a4d3e877f548057b1554c12c018b43e19">pathsSize</a>;
<a name="l00198"></a>00198     <span class="comment">//this constructs the graph tree for computation of inheritedValues</span>
<a name="l00199"></a>00199 
<a name="l00200"></a>00200 
<a name="l00201"></a><a class="code" href="classSgGraphTraversal.html#a29fa5b295fcf56f8b48fd99a50f211e1">00201</a>     std::map&lt;SgGraphNode*, InheritedAttributeType&gt; <a class="code" href="classSgGraphTraversal.html#a29fa5b295fcf56f8b48fd99a50f211e1">known</a>;
<a name="l00202"></a>00202     std::vector&lt;InheritedAttributeType&gt; <a class="code" href="classSgGraphTraversal.html#a0a5623a049cb9000115396666dac237c">connectNodes</a>;
<a name="l00203"></a><a class="code" href="classSgGraphTraversal.html#a92e9fadf5cf9032ed945d2f69f25b14a">00203</a>     std::map&lt;SgGraphNode*, bool&gt; <a class="code" href="classSgGraphTraversal.html#a92e9fadf5cf9032ed945d2f69f25b14a">solved</a>;
<a name="l00204"></a><a class="code" href="classSgGraphTraversal.html#a55417e1caec9f50563082c82502a1808">00204</a>     std::set&lt;SgGraphNode*&gt; <a class="code" href="classSgGraphTraversal.html#a55417e1caec9f50563082c82502a1808">solvedset</a>;
<a name="l00205"></a>00205     <span class="comment">//these two are not used, but will be important if SynthesizedAttributes are made reasonable in this context</span>
<a name="l00206"></a>00206     <a class="code" href="classStackFrameVector.html">SynthesizedAttributesList</a> *<a class="code" href="classSgGraphTraversal.html#a24d9602a7d69c8eda287a73c5f60711a">synthesizedAttributes</a>;
<a name="l00207"></a>00207     SynthesizedAttributeType <a class="code" href="classSgGraphTraversal.html#a4f1c08da96585098634f104dd7051f11">traversalResult</a>();
<a name="l00208"></a>00208     <span class="comment">//finally we have two functions necessary for parallel processing if that is chosen to be used by the user</span>
<a name="l00209"></a>00209  
<a name="l00210"></a>00210 
<a name="l00211"></a>00211     
<a name="l00212"></a>00212   
<a name="l00213"></a><a class="code" href="classSgGraphTraversal.html#aa4837c88ed78d94c258e7337228e6c20">00213</a>     std::map&lt;SgGraphNode*, int&gt; <a class="code" href="classSgGraphTraversal.html#aa4837c88ed78d94c258e7337228e6c20">nodeInEdgesNum</a>;
<a name="l00214"></a>00214     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#af2b56afd75dd2d833002afb02f7a347b">currprime</a>;
<a name="l00215"></a><a class="code" href="classSgGraphTraversal.html#af57f4c88dd3a0e5d75325d1a82f86bff">00215</a>     std::vector&lt;SgGraphNode*&gt; <a class="code" href="classSgGraphTraversal.html#af57f4c88dd3a0e5d75325d1a82f86bff">endnodefakes</a>;
<a name="l00216"></a><a class="code" href="classSgGraphTraversal.html#a37361ff31f80be70112f15392d26a4d9">00216</a>     std::map&lt;SgGraphNode*, std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; &gt; <a class="code" href="classSgGraphTraversal.html#a37361ff31f80be70112f15392d26a4d9">pathsAtMk</a>;
<a name="l00217"></a><a class="code" href="classSgGraphTraversal.html#a9189f1e1d70ef275c47aaff725df3bb1">00217</a>     std::set&lt;SgGraphNode*&gt; <a class="code" href="classSgGraphTraversal.html#a9189f1e1d70ef275c47aaff725df3bb1">mkloops</a>;
<a name="l00218"></a><a class="code" href="classSgGraphTraversal.html#ad8315abc1cbc9fbfa0fb657681fa935c">00218</a>     std::map&lt;SgGraphNode*, std::set&lt;std::vector&lt;SgGraphNode*&gt; &gt; &gt; <a class="code" href="classSgGraphTraversal.html#ad8315abc1cbc9fbfa0fb657681fa935c">mkloopmap</a>;
<a name="l00219"></a><a class="code" href="classSgGraphTraversal.html#a730279236c8256506b8e4bd90048800c">00219</a>     std::map&lt;SgGraphNode*, std::set&lt;std::vector&lt;SgGraphNode*&gt; &gt; &gt; <a class="code" href="classSgGraphTraversal.html#a730279236c8256506b8e4bd90048800c">subPathsAtMk</a>;
<a name="l00220"></a><a class="code" href="classSgGraphTraversal.html#aa49b22a1de322913a79c2785dbd13668">00220</a>     std::vector&lt;SgGraphNode*&gt; <a class="code" href="classSgGraphTraversal.html#aa49b22a1de322913a79c2785dbd13668">mkglobal</a>;
<a name="l00221"></a><a class="code" href="classSgGraphTraversal.html#ae2756d9b1e4a5aee3ac8dbcd444b0e1a">00221</a>     std::vector&lt;SgGraphNode*&gt; <a class="code" href="classSgGraphTraversal.html#ae2756d9b1e4a5aee3ac8dbcd444b0e1a">clglobal</a>;
<a name="l00222"></a>00222     <span class="keywordtype">bool</span> <a class="code" href="classSgGraphTraversal.html#aa55d310c1cafc7c634b62962b81f1249">inseparable</a>;
<a name="l00223"></a>00223     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#a1a9736b9bd3eeef8ee9b75b6cdfbdfc5">solvePaths</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* endnode);
<a name="l00224"></a><a class="code" href="classSgGraphTraversal.html#ab7d1af4b9dd60d9fad7a5fba1ef72994">00224</a>     std::vector&lt;std::set&lt;SgGraphNode*&gt; &gt; <a class="code" href="classSgGraphTraversal.html#ab7d1af4b9dd60d9fad7a5fba1ef72994">closuresVec</a>;
<a name="l00225"></a>00225     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#a4e0b975fa0d59c80d4d1422b56c4c486" title="runs the users evaluation function on all paths, thus is responsible for getting the paths to the use...">evaluatePaths</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* realstartnode, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* endnode);
<a name="l00226"></a>00226     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#a30efa62d65d191a0b6b9bc58d77517b9">evaluatePathsPar</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* realstartnode, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* endnode);
<a name="l00227"></a>00227     <span class="keywordtype">bool</span> <a class="code" href="classSgGraphTraversal.html#acbb2fd1717a78e47023ac1d30ea9f409">disjoint</a>(std::vector&lt;SgGraphNode*&gt;&amp; path, std::vector&lt;SgGraphNode*&gt;&amp; vec2) <span class="keyword">const</span>;
<a name="l00228"></a><a class="code" href="classSgGraphTraversal.html#afb672d887ec87d242a6646e08d12e76d">00228</a>     std::set&lt;std::vector&lt;SgGraphNode*&gt; &gt; <a class="code" href="classSgGraphTraversal.html#afb672d887ec87d242a6646e08d12e76d">flatpaths</a>;
<a name="l00229"></a>00229 <span class="comment">//    void evalNode(SgIncidenceDirectedGraph* g, SgGraphNode* n);</span>
<a name="l00230"></a>00230     <span class="keywordtype">bool</span> <a class="code" href="classSgGraphTraversal.html#a93b3e1973bdd6755a6de10da79f92e26" title="::canSolve">canSolve</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n);
<a name="l00231"></a><a class="code" href="classSgGraphTraversal.html#ac35dce594ee51012149b420cc20b99c9">00231</a>     std::map&lt;SgGraphNode*, InheritedAttributeType&gt; <a class="code" href="classSgGraphTraversal.html#ac35dce594ee51012149b420cc20b99c9">inhVals</a>;
<a name="l00232"></a><a class="code" href="classSgGraphTraversal.html#aa1caac856e04f3bdf76bb76e9be8dc7c">00232</a>     std::set&lt;SgDirectedGraphEdge*&gt; <a class="code" href="classSgGraphTraversal.html#aa1caac856e04f3bdf76bb76e9be8dc7c">seenEdges</a>;
<a name="l00233"></a><a class="code" href="classSgGraphTraversal.html#a99e3401723e3b8db8ff011166344c49f">00233</a>     std::set&lt;SgDirectedGraphEdge*&gt; <a class="code" href="classSgGraphTraversal.html#a99e3401723e3b8db8ff011166344c49f">nullEdges</a>;
<a name="l00234"></a><a class="code" href="classSgGraphTraversal.html#a42a0bbf91de5481e46ad0cfb93a2dae5">00234</a>     std::set&lt;SgGraphNode*&gt; <a class="code" href="classSgGraphTraversal.html#a42a0bbf91de5481e46ad0cfb93a2dae5">clsT</a>;
<a name="l00235"></a>00235     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#ae984130d098c298843f480cd7a818542" title="This is the function that is used by the user directly to start the algorithm.">computeOrder</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* endnode);
<a name="l00236"></a>00236     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#ac025d6d43427e39209560ec3ac1e8833" title="computes the InheritedAttribute values on each of the nodes">computeInheritedOrdered</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n);
<a name="l00237"></a>00237     std::pair&lt;bool, SgGraphNode*&gt; <a class="code" href="classSgGraphTraversal.html#a1dc4b927b3eb7781dc6a1adb9c5e884b" title="computes the next parent node to calculate similar to getNextChild">getNextPar</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n);
<a name="l00238"></a>00238     std::pair&lt;bool, SgGraphNode*&gt; <a class="code" href="classSgGraphTraversal.html#a202ad77e0c9f4edfe12b1e348d811c88" title="computes the next child node to evaluate, used in computing inheritedAttributes, picks the child that...">getNextChild</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n);
<a name="l00239"></a>00239     <span class="keywordtype">bool</span> <a class="code" href="classSgGraphTraversal.html#aea7df8b5b0fbc8f50e5e328634b24137" title="Checks whether or not the node can be computed for InheritedAttribute evaluation.">computable</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n);
<a name="l00240"></a>00240     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#adb0bdc7cf8fe6c427f1aeb748a20ba33" title="evaluates the node directly, used within computeInheritedOrdered SgGraphTraversal::evalNodeOrdered In...">evalNodeOrdered</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n);
<a name="l00241"></a><a class="code" href="classSgGraphTraversal.html#aff4d6f6050407169b1121486a764f3f6">00241</a>     std::map&lt;SgGraphNode*, int&gt; <a class="code" href="classSgGraphTraversal.html#aff4d6f6050407169b1121486a764f3f6">oVals</a>;
<a name="l00242"></a>00242     <span class="keywordtype">bool</span> <a class="code" href="classSgGraphTraversal.html#abb4e5a24cad4e13c6e040df8ae60ba9b" title="Checks whether or not the node can be evaluated (deprecated)">canEval</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n);
<a name="l00243"></a>00243     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#a446d0ed49b6ba81dbc0b1626aac5d6bd">setPathVal</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>*g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n);
<a name="l00244"></a>00244     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#affa8a10ae10b229fa790a11bf7d0d0f6">printNodePlusEdgesForAnalysis</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n, <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a2a7a4163971673b004c06ef672c3f379">loopNum</a>, <span class="keywordtype">int</span> pathVal, std::ofstream&amp; ss);
<a name="l00245"></a>00245     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#ab897274ca07ab604307e624b39d63563">printNodePlusEdgesForAnalysisPath</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, std::vector&lt;SgGraphNode*&gt; n, <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a2a7a4163971673b004c06ef672c3f379">loopNum</a>, <span class="keywordtype">int</span> pathVal, std::ofstream&amp; ss);
<a name="l00246"></a>00246     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#aaa17519821f913b3271d741d6058a8eb">printNodeForAnalysis</a>(<a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n, <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a2a7a4163971673b004c06ef672c3f379">loopNum</a>, <span class="keywordtype">int</span> pathNum, std::ofstream&amp; ss);
<a name="l00247"></a><a class="code" href="classSgGraphTraversal.html#a604fe1211592775ee0d63baa20243095">00247</a>     std::set&lt;SgGraphNode*&gt; <a class="code" href="classSgGraphTraversal.html#a604fe1211592775ee0d63baa20243095">completedNodesPath</a>;
<a name="l00248"></a><a class="code" href="classSgGraphTraversal.html#a244bee87540118f361f7c7659a193912">00248</a>     std::set&lt;std::pair&lt;SgGraphNode*, SgGraphNode*&gt; &gt; <a class="code" href="classSgGraphTraversal.html#a244bee87540118f361f7c7659a193912">completedEdgesPath</a>;
<a name="l00249"></a>00249     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#a089d55063e076d774796bb9f406dc43e">printEdgeForAnalysis</a>(<a class="code" href="classSgDirectedGraphEdge.html">SgDirectedGraphEdge</a>* e, <span class="keywordtype">bool</span> isNullEdge, std::ofstream&amp; ss);
<a name="l00250"></a>00250     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#a7d22a63580636774eca3e252b50a9d7a">printEdgeForAnalysisPath</a>(<a class="code" href="classSgGraphNode.html">SgGraphNode</a>* g1, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* g2, std::ofstream&amp; ss);
<a name="l00251"></a><a class="code" href="classSgGraphTraversal.html#a4b72b59944ef517c798608f615491738">00251</a>     std::map&lt;int, SgGraphNode*&gt; <a class="code" href="classSgGraphTraversal.html#a4b72b59944ef517c798608f615491738">iVals</a>;
<a name="l00252"></a>00252     
<a name="l00253"></a><a class="code" href="classSgGraphTraversal.html#a7f387bbad8a908e111333179bea83644">00253</a>     std::set&lt;SgDirectedGraphEdge*&gt; <a class="code" href="classSgGraphTraversal.html#a7f387bbad8a908e111333179bea83644">nullEdgesOrderedOut</a>;
<a name="l00254"></a><a class="code" href="classSgGraphTraversal.html#a53853ac03def8fb10513d7e04abca787">00254</a>     std::set&lt;SgDirectedGraphEdge*&gt; <a class="code" href="classSgGraphTraversal.html#a53853ac03def8fb10513d7e04abca787">completedEdgesOut</a>;
<a name="l00255"></a><a class="code" href="classSgGraphTraversal.html#a0f7b6ff2e3312b34001c1ace5c47435e">00255</a>     std::set&lt;SgDirectedGraphEdge*&gt; <a class="code" href="classSgGraphTraversal.html#a0f7b6ff2e3312b34001c1ace5c47435e">completedEdges</a>;
<a name="l00256"></a><a class="code" href="classSgGraphTraversal.html#a359407ea2694e76269cb55db7d4abb5f">00256</a>     std::set&lt;SgGraphNode*&gt; <a class="code" href="classSgGraphTraversal.html#a359407ea2694e76269cb55db7d4abb5f">compPar</a>;
<a name="l00257"></a><a class="code" href="classSgGraphTraversal.html#a61fb6ea4e0bdaaf59fd3c2e1d0186702">00257</a>     std::set&lt;SgGraphNode*&gt; <a class="code" href="classSgGraphTraversal.html#a61fb6ea4e0bdaaf59fd3c2e1d0186702">compChild</a>;
<a name="l00258"></a><a class="code" href="classSgGraphTraversal.html#ac07eedc1fc75c16bb0b4605afb827656">00258</a>     std::set&lt;SgGraphNode*&gt; <a class="code" href="classSgGraphTraversal.html#ac07eedc1fc75c16bb0b4605afb827656">computedNodes</a>;
<a name="l00259"></a><a class="code" href="classSgGraphTraversal.html#abae7198768b11e359f6519cbbea01a29">00259</a>     <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* <a class="code" href="classSgGraphTraversal.html#abae7198768b11e359f6519cbbea01a29">st</a>;
<a name="l00260"></a><a class="code" href="classSgGraphTraversal.html#a816d31a8bd9dfae3cbd9eab051d4ac02">00260</a>     <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* <a class="code" href="classSgGraphTraversal.html#a816d31a8bd9dfae3cbd9eab051d4ac02">en</a>;
<a name="l00261"></a>00261     <span class="keywordtype">double</span> <a class="code" href="classSgGraphTraversal.html#a0726f1ca41084a575979799aaa36b934">fllp</a>;
<a name="l00262"></a>00262     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a1e12879d752278baf2ef8612d481cf04">loopnum</a>;
<a name="l00263"></a>00263     <span class="comment">//std::set&lt;SgGraphNode*&gt; solved;</span>
<a name="l00264"></a>00264     <span class="comment">//InheritedAttributeType findAndReverse(SgGraphNode* n, SgIncidenceDirectedGraph* g);</span>
<a name="l00265"></a>00265      <span class="comment">//evaluateAllInheritedAttribute(std::vector&lt;InheritedAttributeType&gt; endNodeInhVec, SgGraphNode* endnode, std::vector&lt;SgGraphNode*&gt; nodes, std::vector&lt;InheritedAttributeType&gt; inh);</span>
<a name="l00266"></a>00266 <span class="comment">//std::vector&lt;InheritedAttributeType&gt; getZeroInhs(std::vector&lt;std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; &gt; qAnsSetSet, std::vector&lt;InheritedAttributeType&gt; endnodeInhVec, SgGraphNode* node);</span>
<a name="l00267"></a>00267 
<a name="l00268"></a>00268 };
<a name="l00269"></a>00269 
<a name="l00270"></a>00270 
<a name="l00271"></a>00271 
<a name="l00272"></a>00272 <span class="comment">/*</span>
<a name="l00273"></a>00273 <span class="comment">template &lt;class InheritedAttributeType, class SynthesizedAttributeType&gt;</span>
<a name="l00274"></a>00274 <span class="comment">void</span>
<a name="l00275"></a>00275 <span class="comment">GraphBot&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</span>
<a name="l00276"></a>00276 <span class="comment">travelDown(SgIncidenceDirectedGraph* g) {</span>
<a name="l00277"></a>00277 <span class="comment">    std::set&lt;SgDirectedGraphEdge*&gt; oedgs = g-&gt;computeEdgeSetOut(iAmHere);</span>
<a name="l00278"></a>00278 <span class="comment">    bool taken = false;</span>
<a name="l00279"></a>00279 <span class="comment">    if (oedgs.size() &gt; 1) {</span>
<a name="l00280"></a>00280 <span class="comment">        std::set&lt;SgDirectedGraphEdge*&gt; edgeTrav = clEdgeTrav[iAmHere];</span>
<a name="l00281"></a>00281 <span class="comment">        ROSE_ASSERT(clEdgeTrav.find(iAmHere) != clEdgeTrav.end());</span>
<a name="l00282"></a>00282 <span class="comment">        for (std::set&lt;SgDirectedGraphEdge*&gt;::iterator i = oedgs.begin(); i != oedgs.end(); i++) {</span>
<a name="l00283"></a>00283 <span class="comment">            if (edgTrav.find(*i) == edgTrav.end() || !taken) {</span>
<a name="l00284"></a>00284 <span class="comment">                taken = true;</span>
<a name="l00285"></a>00285 <span class="comment">                iAmHere = (*i)-&gt;get_to();</span>
<a name="l00286"></a>00286 <span class="comment">                lastEdge = *i;</span>
<a name="l00287"></a>00287 <span class="comment">            }</span>
<a name="l00288"></a>00288 <span class="comment">        }</span>
<a name="l00289"></a>00289 <span class="comment">    }</span>
<a name="l00290"></a>00290 <span class="comment">    else {</span>
<a name="l00291"></a>00291 <span class="comment">        iAmHere = (*(oedgs.begin())-&gt;get_to();</span>
<a name="l00292"></a>00292 <span class="comment">    }</span>
<a name="l00293"></a>00293 <span class="comment">}</span>
<a name="l00294"></a>00294 <span class="comment">*/</span>
<a name="l00295"></a>00295 
<a name="l00296"></a>00296 
<a name="l00297"></a>00297 
<a name="l00298"></a>00298 
<a name="l00299"></a>00299 
<a name="l00300"></a>00300 
<a name="l00301"></a>00301 <span class="comment">/*</span>
<a name="l00302"></a>00302 <span class="comment">***************************</span>
<a name="l00303"></a>00303 <span class="comment">Various Admin Functions</span>
<a name="l00304"></a>00304 <span class="comment">***************************</span>
<a name="l00305"></a>00305 <span class="comment">*/</span>
<a name="l00306"></a>00306 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType&gt;
<a name="l00307"></a>00307 <a class="code" href="classSgGraphTraversal.html#a9a20dc8d3bb63d107a81929187c72673">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</a>
<a name="l00308"></a>00308 <a class="code" href="classSgGraphTraversal.html#a9a20dc8d3bb63d107a81929187c72673">SgGraphTraversal</a>()
<a name="l00309"></a>00309   : synthesizedAttributes(new SynthesizedAttributesList())
<a name="l00310"></a>00310 {
<a name="l00311"></a>00311 }
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 <span class="preprocessor">#ifndef SWIG</span>
<a name="l00314"></a>00314 <span class="preprocessor"></span>
<a name="l00315"></a>00315 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType&gt;
<a name="l00316"></a>00316 <a class="code" href="classSgGraphTraversal.html#a88455ca855d3460510a2d6cfe9cb0b38">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</a>
<a name="l00317"></a>00317 <a class="code" href="classSgGraphTraversal.html#a88455ca855d3460510a2d6cfe9cb0b38">~SgGraphTraversal</a>()
<a name="l00318"></a>00318 {
<a name="l00319"></a>00319         ROSE_ASSERT(synthesizedAttributes != NULL);
<a name="l00320"></a>00320         <span class="keyword">delete</span> synthesizedAttributes;
<a name="l00321"></a>00321         synthesizedAttributes = NULL;
<a name="l00322"></a>00322 }
<a name="l00323"></a>00323 
<a name="l00324"></a>00324 <span class="preprocessor">#endif</span>
<a name="l00325"></a>00325 <span class="preprocessor"></span>
<a name="l00326"></a>00326 
<a name="l00327"></a>00327 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType&gt;
<a name="l00328"></a>00328 <span class="keyword">const</span> <a class="code" href="classSgGraphTraversal.html">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType&gt;</a> &amp;
<a name="l00329"></a>00329 <a class="code" href="classSgGraphTraversal.html#a9066477debed9798e60fe3a767151364">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</a>
<a name="l00330"></a><a class="code" href="classSgGraphTraversal.html#aea6eb025f605828a83483e55d1c5bcf7">00330</a> <a class="code" href="classSgGraphTraversal.html#a9066477debed9798e60fe3a767151364">operator=</a>(<span class="keyword">const</span> <a class="code" href="classSgGraphTraversal.html">SgGraphTraversal</a> &amp;other)
<a name="l00331"></a>00331 {
<a name="l00332"></a>00332 
<a name="l00333"></a>00333     ROSE_ASSERT(synthesizedAttributes != NULL);
<a name="l00334"></a>00334     <span class="keyword">delete</span> synthesizedAttributes;
<a name="l00335"></a>00335     synthesizedAttributes = other.<a class="code" href="classSgGraphTraversal.html#a24d9602a7d69c8eda287a73c5f60711a">synthesizedAttributes</a>-&gt;<a class="code" href="classStackFrameVector.html#ac067807e279a237ef4b642c665bc741f">deepCopy</a>();
<a name="l00336"></a>00336 
<a name="l00337"></a>00337     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00338"></a>00338 }
<a name="l00339"></a>00339 
<a name="l00357"></a>00357 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType&gt;
<a name="l00358"></a>00358 InheritedAttributeType
<a name="l00359"></a>00359 <a class="code" href="classSgGraphTraversal.html#a9b6874b8b18d2368b29e17eb63a15034">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</a>
<a name="l00360"></a><a class="code" href="classSgGraphTraversal.html#aad4c56552cd9903b8d16a82a6a12885d">00360</a> <a class="code" href="classSgGraphTraversal.html#a9b6874b8b18d2368b29e17eb63a15034">traverse</a>(<a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n, <a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, InheritedAttributeType inheritedValue, InheritedAttributeType nullI, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* endnode, <span class="keywordtype">bool</span> insep, <span class="keywordtype">bool</span> pCh) {
<a name="l00361"></a>00361    <span class="comment">//numnodes = 0;</span>
<a name="l00362"></a>00362    <span class="comment">//primes.clear();</span>
<a name="l00363"></a>00363     looppaths.clear();
<a name="l00364"></a>00364     iLoops.clear();
<a name="l00365"></a>00365     completedEdgesPath.clear();
<a name="l00366"></a>00366     pathValMap.clear();
<a name="l00367"></a>00367     loopNumMap.clear();
<a name="l00368"></a>00368     nullloops = 0;
<a name="l00369"></a>00369     nullEdgesPaths = 0;
<a name="l00370"></a>00370     fllp = 0.0;
<a name="l00371"></a>00371     mkglobal.clear();
<a name="l00372"></a>00372     clglobal.clear();
<a name="l00373"></a>00373   
<a name="l00374"></a>00374     lpbegins.clear();
<a name="l00375"></a>00375     <span class="comment">//currents.clear();</span>
<a name="l00376"></a>00376    inhVals.clear();
<a name="l00377"></a>00377    iVals.clear();
<a name="l00378"></a>00378    oVals.clear();
<a name="l00379"></a>00379    <span class="comment">//reservedEdges.clear();</span>
<a name="l00380"></a>00380    completedEdges.clear();
<a name="l00381"></a>00381    completedEdgesOut.clear();
<a name="l00382"></a>00382    <span class="comment">//completedNodes.clear();</span>
<a name="l00383"></a>00383    computedNodes.clear();
<a name="l00384"></a>00384    nullEdgesOrdered.clear();
<a name="l00385"></a>00385    nullEdgesOrderedOut.clear();
<a name="l00386"></a>00386    loopSet.clear();
<a name="l00387"></a>00387    pathsAtMk.clear();
<a name="l00388"></a>00388    
<a name="l00389"></a>00389    st = n;
<a name="l00390"></a>00390    en = endnode;
<a name="l00391"></a>00391    distime = 0.0;
<a name="l00392"></a>00392    <span class="keywordtype">int</span> currm = 1;
<a name="l00393"></a>00393    <span class="keywordtype">int</span> turns = 0;
<a name="l00394"></a>00394    pathsSize = 0;
<a name="l00395"></a>00395    done = <span class="keyword">false</span>;
<a name="l00396"></a>00396    numnodes = 1;
<a name="l00397"></a>00397    std::cout &lt;&lt; <span class="stringliteral">&quot;starting traversal&quot;</span> &lt;&lt; std::endl;
<a name="l00398"></a>00398    pathCheck = pCh;
<a name="l00399"></a>00399    currprime = 1;
<a name="l00400"></a>00400    inseparable = insep;
<a name="l00401"></a>00401    synthesizedAttributes-&gt;resetStack();
<a name="l00402"></a>00402    ROSE_ASSERT(synthesizedAttributes-&gt;debugSize() == 0);
<a name="l00403"></a>00403    <span class="comment">//SgCFG = cfg;</span>
<a name="l00404"></a>00404    inhVals[n] = inheritedValue;
<a name="l00405"></a>00405    <span class="comment">//GraphBot&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::inhVals[n] = inheritedValue;</span>
<a name="l00406"></a>00406    <span class="comment">//primes = generatePrimesSieve();</span>
<a name="l00407"></a>00407    
<a name="l00408"></a>00408   
<a name="l00409"></a>00409 <span class="comment">//   graphnodeinheritedordmap[ncpy] = inheritedValue;</span>
<a name="l00410"></a>00410 <span class="comment">//   nodenodeordmap[ncpy] = n;</span>
<a name="l00411"></a>00411 <span class="comment">//   std::vector&lt;SgGraphNode*&gt; lst;</span>
<a name="l00412"></a>00412 <span class="comment">//   lst.push_back(n);</span>
<a name="l00413"></a>00413 <span class="comment">//   lstordmap[ncpy] = lst;</span>
<a name="l00414"></a>00414 
<a name="l00415"></a>00415    nullInherit = nullI;
<a name="l00416"></a>00416 InheritedAttributeType inh;
<a name="l00417"></a>00417    <span class="keyword">struct </span>timeval t1, t2, t3, t4, t5, t6, t7, t8;
<a name="l00418"></a>00418    <span class="comment">//else {</span>
<a name="l00419"></a>00419        loopnum = 0;
<a name="l00420"></a>00420        <span class="comment">//InheritedAttributeType inh;</span>
<a name="l00421"></a>00421        t1 = <a class="code" href="graphProcessingSgIncGraph_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l00422"></a>00422        
<a name="l00423"></a>00423        <span class="comment">//this function essentially sets up for the evaluate later, it makes putting together the paths much easier</span>
<a name="l00424"></a>00424        solvePaths(g, n, endnode);
<a name="l00425"></a>00425 
<a name="l00426"></a>00426        t2 = <a class="code" href="graphProcessingSgIncGraph_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l00427"></a>00427 
<a name="l00428"></a>00428 <span class="comment">//making sure that endnode hasn&#39;t already been evaluated before the traversal starts, unlikely but just in case</span>
<a name="l00429"></a>00429        ROSE_ASSERT(inhVals.find(endnode) == inhVals.end());
<a name="l00430"></a>00430 
<a name="l00431"></a>00431        std::cout &lt;&lt; <span class="stringliteral">&quot;solvePaths done&quot;</span> &lt;&lt; std::endl;
<a name="l00432"></a>00432        <span class="keywordtype">double</span> diff = <a class="code" href="graphProcessing_8h.html#ae0e3d51bc94bbc9201f1125a8407492f">timeDifference</a>(t2, t1);
<a name="l00433"></a>00433        t5 = <a class="code" href="graphProcessingSgIncGraph_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l00434"></a>00434        <span class="comment">//InheritedAttributeType pthgraphinherit = botTraverse(g, n, endnode);</span>
<a name="l00435"></a>00435        oVals[n] = 0;
<a name="l00436"></a>00436        iVals[0] = n;
<a name="l00437"></a>00437        pathValMap[n] = 1;
<a name="l00438"></a>00438 <span class="comment">//inserting n as a computed node</span>
<a name="l00439"></a>00439        computedNodes.insert(n);
<a name="l00440"></a>00440 <span class="comment">//computes the order in which the nodes must be evaluated, makes computeInheritedOrdered much faster</span>
<a name="l00441"></a>00441        computeOrder(g, n, endnode);
<a name="l00442"></a>00442        std::cout &lt;&lt; <span class="stringliteral">&quot;order computed&quot;</span> &lt;&lt; std::endl;
<a name="l00443"></a>00443 <span class="comment">//computes the nodal inheritance values</span>
<a name="l00444"></a>00444        computeInheritedOrdered(g, n);
<a name="l00445"></a>00445        std::cout &lt;&lt; <span class="stringliteral">&quot;inheritance computed&quot;</span> &lt;&lt; std::endl;
<a name="l00446"></a>00446        ROSE_ASSERT(oVals.find(endnode) != oVals.end());
<a name="l00447"></a>00447        ROSE_ASSERT(inhVals.find(endnode) != inhVals.end());
<a name="l00448"></a>00448 <span class="comment">//value at the endnode</span>
<a name="l00449"></a>00449        InheritedAttributeType pthgraphinherit = inhVals[endnode];
<a name="l00450"></a>00450        <span class="comment">//= evaluateGraph(g, n, endnode, inheritedValue);</span>
<a name="l00451"></a>00451        t6 = <a class="code" href="graphProcessingSgIncGraph_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l00452"></a>00452        std::cout &lt;&lt; <span class="stringliteral">&quot;evaluateGraph done&quot;</span> &lt;&lt; std::endl;
<a name="l00453"></a>00453        <span class="keywordtype">double</span> diff3 = <a class="code" href="graphProcessing_8h.html#ae0e3d51bc94bbc9201f1125a8407492f">timeDifference</a>(t6, t5);
<a name="l00454"></a>00454        t3 = <a class="code" href="graphProcessingSgIncGraph_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l00455"></a>00455 <span class="comment">//actually evaluates every path with a user defined pathAnalyze function</span>
<a name="l00456"></a>00456        <span class="comment">//for (int i = 0; i &lt; 10; i++) {</span>
<a name="l00457"></a>00457        evaluatePaths(g, n, endnode);
<a name="l00458"></a>00458        <span class="comment">//}</span>
<a name="l00459"></a>00459        t4 = <a class="code" href="graphProcessingSgIncGraph_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l00460"></a>00460        
<a name="l00461"></a>00461        t7 = <a class="code" href="graphProcessingSgIncGraph_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l00462"></a>00462        <span class="comment">//evaluatePathsPar(g, n, endnode);</span>
<a name="l00463"></a>00463        t8 = <a class="code" href="graphProcessingSgIncGraph_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l00464"></a>00464        
<a name="l00465"></a>00465        std::cout &lt;&lt; <span class="stringliteral">&quot;evaluatePaths done &quot;</span> &lt;&lt; std::endl;
<a name="l00466"></a>00466        <span class="keywordtype">double</span> diff2 = <a class="code" href="graphProcessing_8h.html#ae0e3d51bc94bbc9201f1125a8407492f">timeDifference</a>(t4, t3);
<a name="l00467"></a>00467        <span class="keywordtype">double</span> diff2Par = <a class="code" href="graphProcessing_8h.html#ae0e3d51bc94bbc9201f1125a8407492f">timeDifference</a>(t8, t7);
<a name="l00468"></a>00468        std::cout &lt;&lt; <span class="stringliteral">&quot;pathsolve took: &quot;</span> &lt;&lt; diff &lt;&lt; std::endl;
<a name="l00469"></a>00469        std::cout &lt;&lt; <span class="stringliteral">&quot;patheval took: &quot;</span> &lt;&lt; diff2 &lt;&lt; std::endl;
<a name="l00470"></a>00470        std::cout &lt;&lt; <span class="stringliteral">&quot;parpatheval took: &quot;</span> &lt;&lt; diff2Par &lt;&lt; std::endl;
<a name="l00471"></a>00471        std::cout &lt;&lt; <span class="stringliteral">&quot;grapheval took: &quot;</span> &lt;&lt; diff3 &lt;&lt; std::endl;
<a name="l00472"></a>00472        std::cout &lt;&lt; <span class="stringliteral">&quot;entire pathsolve took: &quot;</span> &lt;&lt; diff+diff2+diff3+diff2Par &lt;&lt; std::endl;
<a name="l00473"></a>00473        std::cout &lt;&lt; <span class="stringliteral">&quot;potential loops: &quot;</span> &lt;&lt; nullEdgesOrdered.size() &lt;&lt; std::endl;
<a name="l00474"></a>00474        std::cout &lt;&lt; <span class="stringliteral">&quot;nullNum: &quot;</span> &lt;&lt; nullNum &lt;&lt; std::endl;
<a name="l00475"></a>00475        <span class="comment">//std::cout &lt;&lt; &quot;goodsets: &quot; &lt;&lt; goodset.size() &lt;&lt; std::endl;</span>
<a name="l00476"></a>00476        <span class="comment">//std::cout &lt;&lt; &quot;flpsets: &quot; &lt;&lt; flpset.size() &lt;&lt; std::endl;</span>
<a name="l00477"></a>00477        std::cout &lt;&lt; <span class="stringliteral">&quot;mkloops: &quot;</span> &lt;&lt; mkloops.size() &lt;&lt; std::endl;
<a name="l00478"></a>00478        std::cout &lt;&lt; <span class="stringliteral">&quot;distime: &quot;</span> &lt;&lt; distime &lt;&lt; std::endl;
<a name="l00479"></a>00479        std::cout &lt;&lt; <span class="stringliteral">&quot;fllp: &quot;</span> &lt;&lt; fllp &lt;&lt; std::endl;
<a name="l00480"></a>00480        <span class="keywordflow">return</span> pthgraphinherit;
<a name="l00481"></a>00481    <span class="comment">//}</span>
<a name="l00482"></a>00482    <span class="comment">//std::cout &lt;&lt; &quot;number of endnodefakes: &quot; &lt;&lt; endnodefakes.size() &lt;&lt; std::endl;</span>
<a name="l00483"></a>00483    <span class="comment">//std::cout &lt;&lt; &quot;should be number of nodes: &quot; &lt;&lt; currprime &lt;&lt; std::endl;</span>
<a name="l00484"></a>00484    <span class="comment">//if (pathanalysis == true) {</span>
<a name="l00485"></a>00485      <span class="comment">// analyzepaths(endnode, g);</span>
<a name="l00486"></a>00486    <span class="comment">//}</span>
<a name="l00487"></a>00487    <span class="comment">//return inh;</span>
<a name="l00488"></a>00488    <span class="comment">//Currently this is not very useful, but it does nothing if traversalResult is not set.</span>
<a name="l00489"></a>00489 }
<a name="l00490"></a>00490 
<a name="l00491"></a>00491 <span class="comment">/* WARNING:</span>
<a name="l00492"></a>00492 <span class="comment">   This is not a general is_disjoint. It skips the </span>
<a name="l00493"></a>00493 <span class="comment">first element of the second set because in the way I assemble</span>
<a name="l00494"></a>00494 <span class="comment">paths the last element of the path and the first element of addend</span>
<a name="l00495"></a>00495 <span class="comment">must be the same. Hence I simply skip the first node</span>
<a name="l00496"></a>00496 <span class="comment">*/</span>
<a name="l00497"></a><a class="code" href="graphProcessingSgIncGraph_8h.html#a134c763ebeedd5c629296ace4bd38b20">00497</a> <span class="keywordtype">bool</span> <a class="code" href="graphProcessingSgIncGraph_8h.html#a134c763ebeedd5c629296ace4bd38b20">is_disjoint</a>(std::set&lt;SgGraphNode*&gt; set1, std::set&lt;SgGraphNode*&gt; set2) {
<a name="l00498"></a>00498  
<a name="l00499"></a>00499    <span class="keywordflow">if</span> (set1.empty() || set2.empty()) {
<a name="l00500"></a>00500        <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00501"></a>00501    }
<a name="l00502"></a>00502    std::set&lt;SgGraphNode*&gt;::iterator it1 = set1.begin();
<a name="l00503"></a>00503    std::set&lt;SgGraphNode*&gt;::iterator it2 = set2.begin();
<a name="l00504"></a>00504    std::set&lt;SgGraphNode*&gt;::iterator it1End = set1.end();
<a name="l00505"></a>00505    std::set&lt;SgGraphNode*&gt;::iterator it2End = set2.end();
<a name="l00506"></a>00506 
<a name="l00507"></a>00507     <span class="keywordflow">if</span> (*it1 &gt; *set2.rbegin() || *it2 &gt; *set1.rbegin()) {
<a name="l00508"></a>00508         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00509"></a>00509     }
<a name="l00510"></a>00510     
<a name="l00511"></a>00511     <span class="keywordflow">while</span> (it1 != it1End &amp;&amp; it2 != it2End) {
<a name="l00512"></a>00512         <span class="keywordflow">if</span> (*it1 == *it2) {
<a name="l00513"></a>00513             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00514"></a>00514         }
<a name="l00515"></a>00515         <span class="keywordflow">if</span> (*it1 &lt; *it2) {
<a name="l00516"></a>00516             it1++;
<a name="l00517"></a>00517         }
<a name="l00518"></a>00518         <span class="keywordflow">else</span> {
<a name="l00519"></a>00519             it2++;
<a name="l00520"></a>00520         }
<a name="l00521"></a>00521      }
<a name="l00522"></a>00522      <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00523"></a>00523 }   
<a name="l00524"></a>00524 
<a name="l00525"></a>00525 
<a name="l00526"></a>00526 
<a name="l00527"></a>00527 <span class="comment">//Checks for disjoint, necessary in computing the paths</span>
<a name="l00528"></a>00528 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType&gt;
<a name="l00529"></a>00529 <span class="keywordtype">bool</span>
<a name="l00530"></a>00530 <a class="code" href="classSgGraphTraversal.html#acbb2fd1717a78e47023ac1d30ea9f409">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</a>
<a name="l00531"></a><a class="code" href="classSgGraphTraversal.html#ac09c7b7722ef2f201145dca5aec21714">00531</a> <a class="code" href="classSgGraphTraversal.html#acbb2fd1717a78e47023ac1d30ea9f409">disjoint</a>(std::vector&lt;SgGraphNode*&gt;&amp; pthloops, std::vector&lt;SgGraphNode*&gt;&amp; vec2)<span class="keyword"> const </span>{
<a name="l00532"></a>00532 <span class="comment">/*</span>
<a name="l00533"></a>00533 <span class="comment">    time_t t1, t2;</span>
<a name="l00534"></a>00534 <span class="comment">    time(&amp;t1);</span>
<a name="l00535"></a>00535 <span class="comment">    int a = 0;</span>
<a name="l00536"></a>00536 <span class="comment">    std::set&lt;SgGraphNode*&gt; s1;</span>
<a name="l00537"></a>00537 <span class="comment">    std::set&lt;SgGraphNode*&gt; s2;</span>
<a name="l00538"></a>00538 <span class="comment">    std::vector&lt;SgGraphNode*&gt; mkloopvec;</span>
<a name="l00539"></a>00539 <span class="comment">    bool goodsetbool;</span>
<a name="l00540"></a>00540 <span class="comment">    bool pbool = true;</span>
<a name="l00541"></a>00541 <span class="comment">    //std::cout &lt;&lt; &quot;calculating disjoint&quot; &lt;&lt; std::endl;</span>
<a name="l00542"></a>00542 <span class="comment">    ROSE_ASSERT((path.back()).back() == vec2.front());</span>
<a name="l00543"></a>00543 <span class="comment"></span>
<a name="l00544"></a>00544 <span class="comment">    //copy(vec2.begin(), vec2.end(), inserter(s2, s2.end()));</span>
<a name="l00545"></a>00545 <span class="comment">/*</span>
<a name="l00546"></a>00546 <span class="comment">    for (int i = 0; i &lt; vec2.size(); i++) {</span>
<a name="l00547"></a>00547 <span class="comment">        if (ploops.find(vec2[i]) != ploops.end()) {</span>
<a name="l00548"></a>00548 <span class="comment">            pbool = false;</span>
<a name="l00549"></a>00549 <span class="comment">        }</span>
<a name="l00550"></a>00550 <span class="comment">    }</span>
<a name="l00551"></a>00551 <span class="comment">    if (pbool) {</span>
<a name="l00552"></a>00552 <span class="comment">        return true;</span>
<a name="l00553"></a>00553 <span class="comment">    }</span>
<a name="l00554"></a>00554 <span class="comment">    if (</span>
<a name="l00555"></a>00555 <span class="comment">*/</span>  <span class="comment">//for (int q = 0; q &lt; pthloops-&gt;size(); q++) {</span>
<a name="l00556"></a>00556         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; pthloops.size(); i++) {
<a name="l00557"></a>00557             <span class="keywordflow">if</span> (<a class="code" href="namespaceSageInterface.html#aff5394b21cf11cd338671af3a11a7f92">find</a>(vec2.begin(), vec2.end(), pthloops[i]) != vec2.end()) {
<a name="l00558"></a>00558                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00559"></a>00559             }
<a name="l00560"></a>00560         }
<a name="l00561"></a>00561         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00562"></a>00562 }
<a name="l00563"></a>00563 <span class="comment">/*</span>
<a name="l00564"></a>00564 <span class="comment">    if (pbool) {</span>
<a name="l00565"></a>00565 <span class="comment">        time(&amp;t2);</span>
<a name="l00566"></a>00566 <span class="comment">        double diff = difftime(t2, t1);</span>
<a name="l00567"></a>00567 <span class="comment">        distime += diff;</span>
<a name="l00568"></a>00568 <span class="comment">        return true;</span>
<a name="l00569"></a>00569 <span class="comment">    }</span>
<a name="l00570"></a>00570 <span class="comment">    for (unsigned int k = 0; k &lt; path.size(); k++) {</span>
<a name="l00571"></a>00571 <span class="comment">        s1.clear();</span>
<a name="l00572"></a>00572 <span class="comment">*/</span>
<a name="l00573"></a>00573 <span class="comment">/*</span>
<a name="l00574"></a>00574 <span class="comment">        pbool = true;</span>
<a name="l00575"></a>00575 <span class="comment">        for (int p = 0; p &lt; path[k].size(); p++) {</span>
<a name="l00576"></a>00576 <span class="comment">            if (ploops.find(path[k][p]) != ploops.end()) {</span>
<a name="l00577"></a>00577 <span class="comment">                pbool = false;</span>
<a name="l00578"></a>00578 <span class="comment">            }</span>
<a name="l00579"></a>00579 <span class="comment">        }</span>
<a name="l00580"></a>00580 <span class="comment">//        copy(path[k].begin(), path[k].end(), inserter(s1, s1.end()));</span>
<a name="l00581"></a>00581 <span class="comment">        if (!pbool) {</span>
<a name="l00582"></a>00582 <span class="comment">*/</span>
<a name="l00583"></a>00583 <span class="comment">/*</span>
<a name="l00584"></a>00584 <span class="comment">        std::pair&lt;std::pair&lt;SgGraphNode*, SgGraphNode*&gt;, std::pair&lt;SgGraphNode*, SgGraphNode*&gt; &gt; flp;</span>
<a name="l00585"></a>00585 <span class="comment">        flp.second.first = vec2[0];</span>
<a name="l00586"></a>00586 <span class="comment">        flp.second.first = vec2[1];</span>
<a name="l00587"></a>00587 <span class="comment"></span>
<a name="l00588"></a>00588 <span class="comment">        flp.first.first = path[k][0];</span>
<a name="l00589"></a>00589 <span class="comment">        flp.first.second = path[k][1];</span>
<a name="l00590"></a>00590 <span class="comment">        if (vec2.front() == vec2.back()) {</span>
<a name="l00591"></a>00591 <span class="comment">        time(&amp;t2);</span>
<a name="l00592"></a>00592 <span class="comment">        double diff = difftime(t2, t1);</span>
<a name="l00593"></a>00593 <span class="comment">        distime += diff;</span>
<a name="l00594"></a>00594 <span class="comment"></span>
<a name="l00595"></a>00595 <span class="comment">            return false;</span>
<a name="l00596"></a>00596 <span class="comment">        }</span>
<a name="l00597"></a>00597 <span class="comment">        if (flpset.find(flp) != flpset.end()) {</span>
<a name="l00598"></a>00598 <span class="comment">            //std::cout &lt;&lt; &quot;already seen&quot; &lt;&lt; std::endl;</span>
<a name="l00599"></a>00599 <span class="comment">        time(&amp;t2);</span>
<a name="l00600"></a>00600 <span class="comment">        double diff = difftime(t2, t1);</span>
<a name="l00601"></a>00601 <span class="comment">        distime += diff;</span>
<a name="l00602"></a>00602 <span class="comment"></span>
<a name="l00603"></a>00603 <span class="comment">            return false;</span>
<a name="l00604"></a>00604 <span class="comment">        }</span>
<a name="l00605"></a>00605 <span class="comment">*/</span>
<a name="l00606"></a>00606 <span class="comment">/*</span>
<a name="l00607"></a>00607 <span class="comment">        else if (goodset.find(flp) != goodset.end()) {</span>
<a name="l00608"></a>00608 <span class="comment">            goodsetbool = true;</span>
<a name="l00609"></a>00609 <span class="comment">        }</span>
<a name="l00610"></a>00610 <span class="comment">*/</span>
<a name="l00611"></a>00611 <span class="comment">/*</span>
<a name="l00612"></a>00612 <span class="comment">        if (is_disjoint(s1,s2)) {</span>
<a name="l00613"></a>00613 <span class="comment">            //goodset.insert(flp);</span>
<a name="l00614"></a>00614 <span class="comment">            continue;</span>
<a name="l00615"></a>00615 <span class="comment">        }</span>
<a name="l00616"></a>00616 <span class="comment">        else {</span>
<a name="l00617"></a>00617 <span class="comment">            return false;</span>
<a name="l00618"></a>00618 <span class="comment">        }</span>
<a name="l00619"></a>00619 <span class="comment">*/</span>
<a name="l00620"></a>00620 <span class="comment">/*</span>
<a name="l00621"></a>00621 <span class="comment">       else {</span>
<a name="l00622"></a>00622 <span class="comment">        std::vector&lt;SgGraphNode*&gt; vec1 = path[k];</span>
<a name="l00623"></a>00623 <span class="comment">        </span>
<a name="l00624"></a>00624 <span class="comment">        //for (unsigned int i = 0; i &lt; vec1.size(); i++) {</span>
<a name="l00625"></a>00625 <span class="comment">            for (unsigned int j = 0; j &lt; mkloopvec.size(); j++) {</span>
<a name="l00626"></a>00626 <span class="comment">                std::vector&lt;SgGraphNode*&gt;::iterator q = find(vec1.begin(), vec1.end(), mkloopvec[j]);</span>
<a name="l00627"></a>00627 <span class="comment">                if (q != vec1.end()) {</span>
<a name="l00628"></a>00628 <span class="comment">                    if (*q != vec1[vec1.size() - 1] || j != 0) {</span>
<a name="l00629"></a>00629 <span class="comment">                        </span>
<a name="l00630"></a>00630 <span class="comment">                        flpset.insert(flp);</span>
<a name="l00631"></a>00631 <span class="comment">      //                  std::cout &lt;&lt; &quot;not disjoint&quot; &lt;&lt; std::endl;</span>
<a name="l00632"></a>00632 <span class="comment">        time(&amp;t2);</span>
<a name="l00633"></a>00633 <span class="comment">        double diff = difftime(t2, t1);</span>
<a name="l00634"></a>00634 <span class="comment">        distime += diff;</span>
<a name="l00635"></a>00635 <span class="comment"></span>
<a name="l00636"></a>00636 <span class="comment">                        return false;</span>
<a name="l00637"></a>00637 <span class="comment">                    }</span>
<a name="l00638"></a>00638 <span class="comment">                }</span>
<a name="l00639"></a>00639 <span class="comment">            }</span>
<a name="l00640"></a>00640 <span class="comment">        //}</span>
<a name="l00641"></a>00641 <span class="comment">        //goodset.insert(flp);</span>
<a name="l00642"></a>00642 <span class="comment">    }</span>
<a name="l00643"></a>00643 <span class="comment">    }</span>
<a name="l00644"></a>00644 <span class="comment">    //}</span>
<a name="l00645"></a>00645 <span class="comment">*/</span>
<a name="l00646"></a>00646 
<a name="l00647"></a>00647     
<a name="l00648"></a>00648 <span class="comment">/*</span>
<a name="l00649"></a>00649 <span class="comment">    for (unsigned int p = 0; p &lt; vec2.size(); p++) {</span>
<a name="l00650"></a>00650 <span class="comment">        for (unsigned int q = 0; q &lt; vec2.size(); q++) {</span>
<a name="l00651"></a>00651 <span class="comment">            if (p != q) {</span>
<a name="l00652"></a>00652 <span class="comment">                if (vec2[p] == vec2[q]) {</span>
<a name="l00653"></a>00653 <span class="comment">                    return false;</span>
<a name="l00654"></a>00654 <span class="comment">                }</span>
<a name="l00655"></a>00655 <span class="comment">            }</span>
<a name="l00656"></a>00656 <span class="comment">        }</span>
<a name="l00657"></a>00657 <span class="comment">    }</span>
<a name="l00658"></a>00658 <span class="comment">*/</span>
<a name="l00659"></a>00659 <span class="comment">/*</span>
<a name="l00660"></a>00660 <span class="comment">        time(&amp;t2);</span>
<a name="l00661"></a>00661 <span class="comment">        double diff = difftime(t2, t1);</span>
<a name="l00662"></a>00662 <span class="comment">        distime += diff;</span>
<a name="l00663"></a>00663 <span class="comment"></span>
<a name="l00664"></a>00664 <span class="comment">    return true;</span>
<a name="l00665"></a>00665 <span class="comment">}</span>
<a name="l00666"></a>00666 <span class="comment">*/</span>
<a name="l00667"></a>00667 <span class="comment">//checks for solvability of a node in nodal analysis</span>
<a name="l00668"></a>00668 
<a name="l00669"></a>00669 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType&gt;
<a name="l00670"></a>00670 <span class="keywordtype">bool</span>
<a name="l00671"></a>00671 <a class="code" href="classSgGraphTraversal.html#a93b3e1973bdd6755a6de10da79f92e26" title="::canSolve">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</a>
<a name="l00672"></a><a class="code" href="classSgGraphTraversal.html#a38d60f1413ffce035af7294382e4e013">00672</a> <a class="code" href="classSgGraphTraversal.html#a93b3e1973bdd6755a6de10da79f92e26" title="::canSolve">canSolve</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n) {
<a name="l00673"></a>00673     <span class="keywordtype">bool</span> loop = <span class="keyword">false</span>;
<a name="l00674"></a>00674     <span class="keywordflow">if</span> (inhVals.find(n) != inhVals.end()) {
<a name="l00675"></a>00675         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00676"></a>00676     }
<a name="l00677"></a>00677     std::set&lt;SgDirectedGraphEdge*&gt; oed = g-&gt;<a class="code" href="classSgIncidenceDirectedGraph.html#a109c80348472be5c09a0d9b9bcc2d9a1">computeEdgeSetIn</a>(n);
<a name="l00678"></a>00678     <span class="keywordflow">if</span> (oed.size() == 0) {
<a name="l00679"></a>00679         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00680"></a>00680     }
<a name="l00681"></a>00681         <span class="keywordflow">for</span> (std::set&lt;SgDirectedGraphEdge*&gt;::iterator i = oed.begin(); i != oed.end(); i++) {
<a name="l00682"></a>00682             <span class="keywordflow">if</span> (inhVals.find((*i)-&gt;get_from()) == inhVals.end() &amp;&amp; nullEdges.find(*i) == nullEdges.end()) {
<a name="l00683"></a>00683                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00684"></a>00684             }
<a name="l00685"></a>00685         }
<a name="l00686"></a>00686    <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00687"></a>00687 } 
<a name="l00688"></a>00688 
<a name="l00689"></a>00689 <span class="comment">//this function evaluates values of paths via the user-defined pathAnalyze function</span>
<a name="l00690"></a>00690 
<a name="l00691"></a>00691 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType&gt;
<a name="l00692"></a>00692 <span class="keywordtype">void</span>
<a name="l00693"></a>00693 <a class="code" href="classSgGraphTraversal.html#a30efa62d65d191a0b6b9bc58d77517b9">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</a>
<a name="l00694"></a><a class="code" href="classSgGraphTraversal.html#a30efa62d65d191a0b6b9bc58d77517b9">00694</a> <a class="code" href="classSgGraphTraversal.html#a30efa62d65d191a0b6b9bc58d77517b9">evaluatePathsPar</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* realstartnode, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* endnode) {
<a name="l00695"></a>00695 std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; path;
<a name="l00696"></a>00696 std::vector&lt;SgGraphNode*&gt; spath;
<a name="l00697"></a>00697 <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n = realstartnode;
<a name="l00698"></a>00698 <span class="keywordtype">int</span> successes = 0;
<a name="l00699"></a>00699 <span class="keywordtype">int</span> failures = 0;
<a name="l00700"></a>00700 <span class="keywordtype">int</span> j = 0;
<a name="l00701"></a>00701 std::vector&lt;SgGraphNode*&gt; currpthorg;
<a name="l00702"></a>00702 <span class="keywordtype">int</span> currint = 0;
<a name="l00703"></a>00703 std::map&lt;SgGraphNode*, int&gt; intPath;
<a name="l00704"></a>00704 intPath[n] = currint;
<a name="l00705"></a>00705 currint++;
<a name="l00706"></a>00706 std::map&lt;SgGraphNode*, int&gt; currents;
<a name="l00707"></a>00707 <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* currnode;
<a name="l00708"></a>00708 <span class="keywordtype">bool</span> step = <span class="keyword">false</span>;
<a name="l00709"></a>00709 <span class="keywordtype">bool</span> midstep = <span class="keyword">false</span>;
<a name="l00710"></a>00710 
<a name="l00711"></a>00711 <span class="comment">//note: pathsAtMk is referring to subpaths connected to that marker, a marker is a split in the graph (usually an if statement)</span>
<a name="l00712"></a>00712 
<a name="l00713"></a>00713 std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; pth = pathsAtMk[realstartnode];
<a name="l00714"></a>00714 std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; cpth = pathsAtMk[realstartnode];
<a name="l00715"></a>00715     path.clear();
<a name="l00716"></a>00716     <span class="keywordtype">int</span> disjoints = 0;
<a name="l00717"></a>00717     <span class="keywordtype">int</span> disjointtrues = 0;
<a name="l00718"></a>00718     currpthorg = pth[0];
<a name="l00719"></a>00719     intPath[pth[0].front()] = currint;
<a name="l00720"></a>00720     std::set&lt;SgGraphNode*&gt; pthloopstmp;
<a name="l00721"></a>00721     <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* fakenode;
<a name="l00722"></a>00722     pthloopstmp.insert(fakenode);
<a name="l00723"></a>00723     std::vector&lt;std::set&lt;SgGraphNode*&gt; &gt; pthloops;
<a name="l00724"></a>00724     pthloops.push_back(pthloopstmp);
<a name="l00725"></a>00725     pthloopstmp.clear();
<a name="l00726"></a>00726     currint++;
<a name="l00727"></a>00727     
<a name="l00728"></a>00728     <span class="keywordtype">int</span> stepnum = 0;
<a name="l00729"></a>00729     std::vector&lt;SgGraphNode*&gt; rs;
<a name="l00730"></a>00730     rs.push_back(realstartnode);
<a name="l00731"></a>00731     path.push_back(rs);
<a name="l00732"></a>00732     currents.clear();
<a name="l00733"></a>00733 
<a name="l00734"></a>00734     step = <span class="keyword">false</span>;
<a name="l00735"></a>00735     std::vector&lt;SgGraphNode*&gt; sub;
<a name="l00736"></a>00736 
<a name="l00737"></a>00737 
<a name="l00738"></a>00738     std::set&lt;std::vector&lt;SgGraphNode*&gt; &gt; nullIncLoops;
<a name="l00739"></a>00739     std::vector&lt;struct Bot*&gt; todobotlst;
<a name="l00740"></a>00740     std::vector&lt;struct Bot*&gt; botlst;
<a name="l00741"></a>00741     <span class="keyword">struct </span><a class="code" href="structBot.html">Bot</a>* rootBot = <span class="keyword">new</span> <a class="code" href="structBot.html">Bot</a>;
<a name="l00742"></a>00742     rootBot-&gt;<a class="code" href="structBot.html#a926f7879741af9852bcaf8c49a8e6ad9">remove</a> = <span class="keyword">false</span>;
<a name="l00743"></a>00743     
<a name="l00744"></a>00744     rootBot-&gt;<a class="code" href="structBot.html#a921887c740102f0e2899599311e1af31">path</a> = <a class="code" href="structBot.html#a921887c740102f0e2899599311e1af31">path</a>;
<a name="l00745"></a>00745     rootBot-&gt;<a class="code" href="structBot.html#ab5f7df14761543c1a3099340ca6cbf36">currpth</a> = currpthorg;
<a name="l00746"></a>00746     rootBot-&gt;<a class="code" href="structBot.html#ac9a69748bb185d987f7ef7898dd2aca4">pthloops</a> = <a class="code" href="structBot.html#ac9a69748bb185d987f7ef7898dd2aca4">pthloops</a>;
<a name="l00747"></a>00747     rootBot-&gt;<a class="code" href="structBot.html#a8fc3e19ff7ef78630332371059abb1c6">on</a> = <span class="keyword">true</span>;
<a name="l00748"></a>00748      botlst.push_back(rootBot);
<a name="l00749"></a>00749     <span class="keywordtype">int</span> tip = 1;
<a name="l00750"></a>00750     <span class="keywordtype">int</span> ti = 1;
<a name="l00751"></a>00751     std::vector&lt;std::pair&lt;std::vector&lt;SgGraphNode*&gt;, std::vector&lt;std::set&lt;SgGraphNode*&gt; &gt; &gt; &gt; collectedPaths;
<a name="l00752"></a>00752     <span class="keywordtype">int</span> maxlst = 0;
<a name="l00753"></a>00753     <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l00754"></a>00754     <span class="keywordflow">if</span> (todobotlst.size()+botlst.size() &gt; maxlst) {
<a name="l00755"></a>00755         maxlst = todobotlst.size()+botlst.size();
<a name="l00756"></a>00756         std::cout &lt;&lt; <span class="stringliteral">&quot;maxlst: &quot;</span> &lt;&lt; maxlst &lt;&lt; std::endl;
<a name="l00757"></a>00757         std::cout &lt;&lt; <span class="stringliteral">&quot;todobotlst.size(): &quot;</span> &lt;&lt; todobotlst.size() &lt;&lt; std::endl;
<a name="l00758"></a>00758         std::cout &lt;&lt; <span class="stringliteral">&quot;botlst.size(): &quot;</span> &lt;&lt; botlst.size() &lt;&lt; std::endl;
<a name="l00759"></a>00759     }
<a name="l00760"></a>00760     <span class="keywordtype">int</span> MAXBOTS = 10000;
<a name="l00761"></a>00761     <span class="keywordtype">int</span> MINPATHS = 1000;
<a name="l00762"></a>00762     <span class="keywordtype">int</span> LOCALMAXBOTS = 10;
<a name="l00763"></a>00763     <span class="keywordtype">int</span> LOCALMAXNODES = 0;
<a name="l00764"></a>00764     std::vector&lt;struct Bot*&gt; lstnullbot;
<a name="l00765"></a>00765     std::vector&lt;std::vector&lt;struct Bot*&gt; &gt; newbotlsts (MAXBOTS, lstnullbot);
<a name="l00766"></a>00766     <span class="comment">//std::vector&lt;struct Bot*&gt; newbotlsts (MAXBOTS, lstnullbot);</span>
<a name="l00767"></a>00767     <span class="comment">//tip = ti;</span>
<a name="l00768"></a>00768     <span class="comment">//ti = 0;</span>
<a name="l00769"></a>00769     ROSE_ASSERT(botlst.size() &gt;= 0);
<a name="l00770"></a>00770     <span class="keywordflow">if</span> (botlst.size() == 0) {
<a name="l00771"></a>00771         <span class="keywordflow">if</span> (todobotlst.size() != 0) {
<a name="l00772"></a>00772             <span class="keywordflow">while</span> (todobotlst.size() &gt; 0 &amp;&amp; botlst.size() &lt; MAXBOTS) {
<a name="l00773"></a>00773                 todobotlst.back()-&gt;on = <span class="keyword">true</span>;
<a name="l00774"></a>00774                 botlst.push_back(todobotlst.back());
<a name="l00775"></a>00775                 todobotlst.pop_back();
<a name="l00776"></a>00776             }
<a name="l00777"></a>00777         }
<a name="l00778"></a>00778         <span class="keywordflow">else</span> {
<a name="l00779"></a>00779             <span class="keywordflow">if</span> (collectedPaths.size() &gt; 0) {
<a name="l00780"></a>00780                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; collectedPaths.size(); i++) {
<a name="l00781"></a>00781                   std::set&lt;std::vector&lt;SgGraphNode*&gt; &gt; incloops;
<a name="l00782"></a>00782                   std::vector&lt;std::set&lt;SgGraphNode*&gt; &gt; pthloops = collectedPaths[i].second;
<a name="l00783"></a>00783                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> q = 0; q &lt; pthloops.size(); q++) {
<a name="l00784"></a>00784                   <span class="keywordflow">for</span> (std::set&lt;SgGraphNode*&gt;::iterator p = pthloops[q].begin(); p != pthloops[q].end(); p++) {
<a name="l00785"></a>00785                     <span class="keywordflow">for</span> (std::set&lt;std::vector&lt;SgGraphNode*&gt; &gt;::iterator o = mkloopmap[*p].begin(); o != mkloopmap[*p].end(); o++) {
<a name="l00786"></a>00786                         incloops.insert(*o);
<a name="l00787"></a>00787                     }
<a name="l00788"></a>00788                  }
<a name="l00789"></a>00789                  }
<a name="l00790"></a>00790 
<a name="l00791"></a>00791 
<a name="l00792"></a>00792         pathAnalyze(collectedPaths[i].first, <span class="keyword">false</span>, incloops);
<a name="l00793"></a>00793     }
<a name="l00794"></a>00794     collectedPaths.clear();
<a name="l00795"></a>00795             }
<a name="l00796"></a>00796             <span class="keywordflow">break</span>;
<a name="l00797"></a>00797         }
<a name="l00798"></a>00798     }
<a name="l00799"></a>00799     <span class="keywordflow">if</span> (botlst.size() &gt; 0) {
<a name="l00800"></a>00800     std::pair&lt;std::vector&lt;SgGraphNode*&gt;, std::vector&lt;std::set&lt;SgGraphNode*&gt; &gt; &gt; nullpr;
<a name="l00801"></a>00801     std::vector&lt;std::pair&lt;std::vector&lt;SgGraphNode*&gt;, std::vector&lt;std::set&lt;SgGraphNode*&gt; &gt; &gt; &gt; newpathslst (MAXBOTS, nullpr);
<a name="l00802"></a>00802 <span class="preprocessor">    #pragma omp parallel for</span>
<a name="l00803"></a>00803 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; botlst.size(); i++) {
<a name="l00804"></a>00804         <span class="comment">//std::map&lt;SgGraphNode*, std::set&lt;std::vector&lt;SgGraphNode*&gt; &gt; &gt; mkloopmaptmp = mkloopmap;</span>
<a name="l00805"></a>00805         std::vector&lt;struct Bot*&gt; localbotlst;
<a name="l00806"></a>00806         std::pair&lt;std::vector&lt;SgGraphNode*&gt;, std::vector&lt;std::set&lt;SgGraphNode*&gt; &gt; &gt; localnewpath;
<a name="l00807"></a>00807         <span class="keyword">struct </span><a class="code" href="structBot.html">Bot</a>* currBot = botlst[i];
<a name="l00808"></a>00808         <span class="keywordflow">if</span> (currBot-&gt;<a class="code" href="structBot.html#a8fc3e19ff7ef78630332371059abb1c6">on</a>) {
<a name="l00809"></a>00809         std::vector&lt;SgGraphNode*&gt; <a class="code" href="structBot.html#ab5f7df14761543c1a3099340ca6cbf36">currpth</a> = currBot-&gt;<a class="code" href="structBot.html#ab5f7df14761543c1a3099340ca6cbf36">currpth</a>;
<a name="l00810"></a>00810         std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; path = currBot-&gt;<a class="code" href="structBot.html#a921887c740102f0e2899599311e1af31">path</a>;
<a name="l00811"></a>00811         std::vector&lt;std::set&lt;SgGraphNode*&gt; &gt; pthloops = currBot-&gt;<a class="code" href="structBot.html#ac9a69748bb185d987f7ef7898dd2aca4">pthloops</a>;
<a name="l00812"></a>00812         
<a name="l00813"></a>00813             <span class="keywordflow">if</span> (currpth.back() == endnode) {
<a name="l00814"></a>00814             path.push_back(currpth);
<a name="l00815"></a>00815             std::vector&lt;SgGraphNode*&gt; flatpath;
<a name="l00816"></a>00816             std::set&lt;std::vector&lt;SgGraphNode*&gt; &gt; incloops;
<a name="l00817"></a>00817             <span class="keyword">struct </span>timeval q1, q2;
<a name="l00818"></a>00818             ROSE_ASSERT(path.size() == pthloops.size() + 1);
<a name="l00819"></a>00819             q1 = <a class="code" href="graphProcessingSgIncGraph_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l00820"></a>00820             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; pthloops.size(); q++) {
<a name="l00821"></a>00821                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> r = 0; r &lt; path[q].size(); r++) {
<a name="l00822"></a>00822                     flatpath.push_back(path[q][r]);
<a name="l00823"></a>00823                 }
<a name="l00824"></a>00824 
<a name="l00825"></a>00825 <span class="comment">/*</span>
<a name="l00826"></a>00826 <span class="comment">#pragma omp critical</span>
<a name="l00827"></a>00827 <span class="comment">{</span>
<a name="l00828"></a>00828 <span class="comment">                for (std::set&lt;SgGraphNode*&gt;::iterator p = pthloops[q].begin(); p != pthloops[q].end(); p++) {</span>
<a name="l00829"></a>00829 <span class="comment">                    for (std::set&lt;std::vector&lt;SgGraphNode*&gt; &gt;::iterator o = mkloopmap[*p].begin(); o != mkloopmap[*p].end(); o++) {</span>
<a name="l00830"></a>00830 <span class="comment">                        incloops.insert(*o);</span>
<a name="l00831"></a>00831 <span class="comment">                    }</span>
<a name="l00832"></a>00832 <span class="comment">                 }</span>
<a name="l00833"></a>00833 <span class="comment">}</span>
<a name="l00834"></a>00834 <span class="comment">*/</span>
<a name="l00835"></a>00835 
<a name="l00836"></a>00836              }
<a name="l00837"></a>00837 
<a name="l00838"></a>00838              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pt2 = 0; pt2 &lt; path[path.size()-1].size(); pt2++) {
<a name="l00839"></a>00839                      flatpath.push_back(path[path.size()-1][pt2]);
<a name="l00840"></a>00840              }             
<a name="l00841"></a>00841              q2 = <a class="code" href="graphProcessingSgIncGraph_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l00842"></a>00842              fllp += <a class="code" href="graphProcessing_8h.html#ae0e3d51bc94bbc9201f1125a8407492f">timeDifference</a>(q2,q1);
<a name="l00843"></a>00843              flatpath.push_back(endnode);
<a name="l00844"></a>00844 <span class="comment">//user defined function, run on the final path, gives the user loops that are included via &quot;incloops&quot; a set of vectors that contain the individual loops</span>
<a name="l00845"></a>00845 <span class="comment">/*</span>
<a name="l00846"></a>00846 <span class="comment">             #pragma omp critical (analyze)</span>
<a name="l00847"></a>00847 <span class="comment">{</span>
<a name="l00848"></a>00848 <span class="comment">             pathAnalyze(flatpath, false, incloops);</span>
<a name="l00849"></a>00849 <span class="comment">}</span>
<a name="l00850"></a>00850 <span class="comment">*/</span>
<a name="l00851"></a>00851              std::pair&lt;std::vector&lt;SgGraphNode*&gt; , std::vector&lt;std::set&lt;SgGraphNode*&gt; &gt; &gt; newcol;
<a name="l00852"></a>00852              newcol.first = flatpath;
<a name="l00853"></a>00853              newcol.second = pthloops;
<a name="l00854"></a>00854              localnewpath = newcol;
<a name="l00855"></a>00855              incloops.clear();
<a name="l00856"></a>00856 
<a name="l00857"></a>00857              <span class="keywordtype">int</span> pts = pathsSize++;
<a name="l00858"></a>00858              pathsSize += 1;
<a name="l00859"></a>00859             
<a name="l00860"></a>00860              flatpath.clear();
<a name="l00861"></a>00861              path.pop_back();
<a name="l00862"></a>00862              <span class="keywordtype">int</span> rounds = 0;
<a name="l00863"></a>00863              <span class="keywordtype">bool</span> starter = <span class="keyword">false</span>;
<a name="l00864"></a>00864 
<a name="l00865"></a>00865 <span class="comment">// This gets a bit complicated so here is an overview:</span>
<a name="l00866"></a>00866 <span class="comment">// This is running down the graph and finding the endnode. Once it finds the endnode it goes back up to the last unevaluated subpath. It does this quickly with an integer that counts how many times that node has been used for a path. If this ends up being the number of outnodes, we don&#39;t need that node anymore, so we clear it to zero, then continue up the graph. We HAVE to reset because every time a new pathway is chosen above that node, it needs to have the ability to traverse that node.</span>
<a name="l00867"></a>00867 <span class="comment">/*</span>
<a name="l00868"></a>00868 <span class="comment">              if (currBot-&gt;nodelst.size() != 0) {</span>
<a name="l00869"></a>00869 <span class="comment">                   while (path.back().back() != currBot-&gt;nodelst.back().first) {</span>
<a name="l00870"></a>00870 <span class="comment">                       ROSE_ASSERT(path.size() != 0);</span>
<a name="l00871"></a>00871 <span class="comment">                       path.pop_back();</span>
<a name="l00872"></a>00872 <span class="comment">                       pthloops.pop_back();</span>
<a name="l00873"></a>00873 <span class="comment">                       </span>
<a name="l00874"></a>00874 <span class="comment">                   }</span>
<a name="l00875"></a>00875 <span class="comment">                   currBot-&gt;path = path;</span>
<a name="l00876"></a>00876 <span class="comment">                   currBot-&gt;pthloops = pthloops;</span>
<a name="l00877"></a>00877 <span class="comment">                   currBot-&gt;currpth = pathsAtMk[(path.back()).back()][currBot-&gt;nodelst.back().second];</span>
<a name="l00878"></a>00878 <span class="comment">                   currBot-&gt;nodelst.pop_back();</span>
<a name="l00879"></a>00879 <span class="comment">                   localbotlst.push_back(currBot);</span>
<a name="l00880"></a>00880 <span class="comment">             }</span>
<a name="l00881"></a>00881 <span class="comment">             else {</span>
<a name="l00882"></a>00882 <span class="comment">*/</span>
<a name="l00883"></a>00883                  currBot-&gt;<a class="code" href="structBot.html#a926f7879741af9852bcaf8c49a8e6ad9">remove</a> = <span class="keyword">true</span>;
<a name="l00884"></a>00884                  localbotlst.push_back(currBot);
<a name="l00885"></a>00885              <span class="comment">//}</span>
<a name="l00886"></a>00886          }
<a name="l00887"></a>00887          <span class="keywordflow">else</span> {
<a name="l00888"></a>00888 
<a name="l00889"></a>00889 <span class="comment">//this checks first to see if we have any loops in our path. If not it continues down, if there is it goes back to the last nonloop node</span>
<a name="l00890"></a>00890         <span class="keywordtype">bool</span> disj = <span class="keyword">true</span>;
<a name="l00891"></a>00891         <span class="keyword">struct </span>timeval tdisb, tdise;
<a name="l00892"></a>00892         <span class="comment">//tdisb = getCPUTime();</span>
<a name="l00893"></a>00893         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; pthloops.size(); x++) {
<a name="l00894"></a>00894             <span class="keywordflow">for</span> (std::set&lt;SgGraphNode*&gt;::iterator j = pthloops[x].begin(); j != pthloops[x].end(); j++) {
<a name="l00895"></a>00895                 <span class="keywordflow">if</span> (<a class="code" href="namespaceSageInterface.html#aff5394b21cf11cd338671af3a11a7f92">find</a>(currpth.begin(), currpth.end(), *j) != currpth.end()) {
<a name="l00896"></a>00896                     disj = <span class="keyword">false</span>;
<a name="l00897"></a>00897                 }
<a name="l00898"></a>00898              }
<a name="l00899"></a>00899         }
<a name="l00900"></a>00900         <span class="comment">//tdise = getCPUTime();</span>
<a name="l00901"></a>00901         <span class="comment">//distime += timeDifference(tdise, tdisb);</span>
<a name="l00902"></a>00902         <span class="keywordflow">if</span> (disj) {
<a name="l00903"></a>00903             
<a name="l00904"></a>00904             disjointtrues++;
<a name="l00905"></a>00905             <span class="comment">//std::cout &lt;&lt; &quot;disjoints: &quot; &lt;&lt; disjointtrues &lt;&lt; std::endl;</span>
<a name="l00906"></a>00906             midstep = <span class="keyword">false</span>;
<a name="l00907"></a>00907 std::set&lt;SgGraphNode*&gt; pthloopstmp;
<a name="l00908"></a>00908             pthloopstmp.clear();
<a name="l00909"></a>00909                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; currpth.size(); i++) {
<a name="l00910"></a>00910                     <span class="comment">//currflat.push_back(currpth[i]);</span>
<a name="l00911"></a>00911                     <span class="keywordflow">if</span> (mkloops.find(currpth[i]) != mkloops.end()) {
<a name="l00912"></a>00912                        pthloopstmp.insert(currpth[i]);
<a name="l00913"></a>00913                     }
<a name="l00914"></a>00914                 }
<a name="l00915"></a>00915                 pthloops.push_back(pthloopstmp);
<a name="l00916"></a>00916                 path.push_back(currpth);
<a name="l00917"></a>00917                 pthloopstmp.clear();
<a name="l00918"></a>00918                 
<a name="l00919"></a>00919                 <span class="comment">//std::set&lt;std::vector&lt;SgGraphNode*&gt; &gt; lpth;</span>
<a name="l00920"></a>00920                 std::vector&lt;SgGraphNode*&gt; oldcurrpth = currpth;
<a name="l00921"></a>00921                 currpth.clear();
<a name="l00922"></a>00922                         <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* frontnode = (path.back()).front();
<a name="l00923"></a>00923                         <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* backnode = (path.back()).back();
<a name="l00924"></a>00924      
<a name="l00925"></a>00925                         ROSE_ASSERT(pathsAtMk.find(backnode) != pathsAtMk.end() || backnode == endnode);
<a name="l00926"></a>00926                         ROSE_ASSERT(pathsAtMk.find(frontnode) != pathsAtMk.end());
<a name="l00927"></a>00927                         std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; tmppths = pathsAtMk[backnode];
<a name="l00928"></a>00928                         currBot-&gt;<a class="code" href="structBot.html#ab5f7df14761543c1a3099340ca6cbf36">currpth</a> = tmppths[0];
<a name="l00929"></a>00929                         currBot-&gt;<a class="code" href="structBot.html#a921887c740102f0e2899599311e1af31">path</a> = path;
<a name="l00930"></a>00930                         currBot-&gt;<a class="code" href="structBot.html#ac9a69748bb185d987f7ef7898dd2aca4">pthloops</a> = pthloops;
<a name="l00931"></a>00931                         <span class="comment">//newbotlst.push_back(currBot);</span>
<a name="l00932"></a>00932                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> tp = 1; tp &lt; tmppths.size(); tp++) {
<a name="l00933"></a>00933                             <span class="comment">//if (localbotlst.size() &lt; LOCALMAXBOTS) {</span>
<a name="l00934"></a>00934 <span class="comment">/*</span>
<a name="l00935"></a>00935 <span class="comment">                            if (currBot-&gt;nodelst.size() &lt; LOCALMAXNODES) {</span>
<a name="l00936"></a>00936 <span class="comment">                                std::pair&lt;SgGraphNode*, int&gt; cur;</span>
<a name="l00937"></a>00937 <span class="comment">                                cur.second = tp;</span>
<a name="l00938"></a>00938 <span class="comment">                                cur.first = path.back().back();</span>
<a name="l00939"></a>00939 <span class="comment">                                currBot-&gt;nodelst.push_back(cur);</span>
<a name="l00940"></a>00940 <span class="comment">                            }</span>
<a name="l00941"></a>00941 <span class="comment">                            else {</span>
<a name="l00942"></a>00942 <span class="comment">*/</span>
<a name="l00943"></a>00943                                 <span class="keyword">struct </span><a class="code" href="structBot.html">Bot</a>* newBot = <span class="keyword">new</span> <a class="code" href="structBot.html">Bot</a>;
<a name="l00944"></a>00944                                 newBot-&gt;<a class="code" href="structBot.html#a926f7879741af9852bcaf8c49a8e6ad9">remove</a> = <span class="keyword">false</span>;
<a name="l00945"></a>00945                                 newBot-&gt;<a class="code" href="structBot.html#ab5f7df14761543c1a3099340ca6cbf36">currpth</a> = tmppths[tp];
<a name="l00946"></a>00946                                 newBot-&gt;<a class="code" href="structBot.html#a921887c740102f0e2899599311e1af31">path</a> = <a class="code" href="structBot.html#a921887c740102f0e2899599311e1af31">path</a>;
<a name="l00947"></a>00947                                 newBot-&gt;<a class="code" href="structBot.html#ac9a69748bb185d987f7ef7898dd2aca4">pthloops</a> = <a class="code" href="structBot.html#ac9a69748bb185d987f7ef7898dd2aca4">pthloops</a>;
<a name="l00948"></a>00948                                 localbotlst.push_back(newBot);
<a name="l00949"></a>00949                                 <span class="comment">//ti++;</span>
<a name="l00950"></a>00950  <span class="comment">//                           }</span>
<a name="l00951"></a>00951                         }
<a name="l00952"></a>00952                         localbotlst.push_back(currBot);
<a name="l00953"></a>00953                         <span class="comment">//ti++;</span>
<a name="l00954"></a>00954          }          
<a name="l00955"></a>00955          <span class="keywordflow">else</span> {
<a name="l00956"></a>00956 <span class="comment">/*</span>
<a name="l00957"></a>00957 <span class="comment">               if (currBot-&gt;nodelst.size() != 0) {</span>
<a name="l00958"></a>00958 <span class="comment">                   while (path.back().back() != currBot-&gt;nodelst.back().first) {</span>
<a name="l00959"></a>00959 <span class="comment">                       ROSE_ASSERT(path.size() != 0);</span>
<a name="l00960"></a>00960 <span class="comment">                       path.pop_back();</span>
<a name="l00961"></a>00961 <span class="comment">                       pthloops.pop_back();</span>
<a name="l00962"></a>00962 <span class="comment">                       </span>
<a name="l00963"></a>00963 <span class="comment">                   }</span>
<a name="l00964"></a>00964 <span class="comment">                   currBot-&gt;path = path;</span>
<a name="l00965"></a>00965 <span class="comment">                   currBot-&gt;pthloops = pthloops;</span>
<a name="l00966"></a>00966 <span class="comment">                   currBot-&gt;currpth =  pathsAtMk[(path.back()).back()][currBot-&gt;nodelst.back().second];</span>
<a name="l00967"></a>00967 <span class="comment">                   currBot-&gt;nodelst.pop_back();</span>
<a name="l00968"></a>00968 <span class="comment">                   localbotlst.push_back(currBot);</span>
<a name="l00969"></a>00969 <span class="comment">                   //ti++;</span>
<a name="l00970"></a>00970 <span class="comment">             }</span>
<a name="l00971"></a>00971 <span class="comment"></span>
<a name="l00972"></a>00972 <span class="comment">             else {</span>
<a name="l00973"></a>00973 <span class="comment">*/</span>
<a name="l00974"></a>00974                  currBot-&gt;<a class="code" href="structBot.html#a926f7879741af9852bcaf8c49a8e6ad9">remove</a> = <span class="keyword">true</span>;
<a name="l00975"></a>00975                  localbotlst.push_back(currBot);
<a name="l00976"></a>00976                  <span class="comment">//delete currBot;</span>
<a name="l00977"></a>00977  <span class="comment">//            }</span>
<a name="l00978"></a>00978 
<a name="l00979"></a>00979         }
<a name="l00980"></a>00980      }
<a name="l00981"></a>00981  newpathslst[i] = localnewpath;
<a name="l00982"></a>00982  newbotlsts[i] = localbotlst;
<a name="l00983"></a>00983  }
<a name="l00984"></a>00984 }
<a name="l00985"></a>00985  botlst.clear();
<a name="l00986"></a>00986  <span class="keywordtype">int</span> num = 0;
<a name="l00987"></a>00987 
<a name="l00988"></a>00988  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; newbotlsts.size(); i++) {
<a name="l00989"></a>00989     <span class="keywordflow">if</span> (newpathslst[i].first.size() &gt; 0) {
<a name="l00990"></a>00990         collectedPaths.push_back(newpathslst[i]);
<a name="l00991"></a>00991     }
<a name="l00992"></a>00992     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; newbotlsts[i].size(); j++) {
<a name="l00993"></a>00993         <span class="keywordflow">if</span> (newbotlsts[i][j]-&gt;<span class="keyword">remove</span> == <span class="keyword">true</span>) {
<a name="l00994"></a>00994             <span class="keyword">delete</span> newbotlsts[i][j];
<a name="l00995"></a>00995         }
<a name="l00996"></a>00996         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (num &lt; MAXBOTS) {
<a name="l00997"></a>00997             newbotlsts[i][j]-&gt;on = <span class="keyword">true</span>;
<a name="l00998"></a>00998             botlst.push_back(newbotlsts[i][j]);
<a name="l00999"></a>00999             num++;
<a name="l01000"></a>01000         }
<a name="l01001"></a>01001         <span class="keywordflow">else</span> {
<a name="l01002"></a>01002             newbotlsts[i][j]-&gt;on = <span class="keyword">false</span>;
<a name="l01003"></a>01003             todobotlst.push_back(newbotlsts[i][j]);
<a name="l01004"></a>01004         }
<a name="l01005"></a>01005     }
<a name="l01006"></a>01006 }
<a name="l01007"></a>01007 
<a name="l01008"></a>01008 <span class="keywordflow">if</span> (collectedPaths.size() &gt; MINPATHS) {
<a name="l01009"></a>01009           
<a name="l01010"></a>01010     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; collectedPaths.size(); i++) {
<a name="l01011"></a>01011                  std::vector&lt;std::set&lt;SgGraphNode*&gt; &gt; <a class="code" href="structBot.html#ac9a69748bb185d987f7ef7898dd2aca4">pthloops</a>;   
<a name="l01012"></a>01012                 std::set&lt;std::vector&lt;SgGraphNode*&gt; &gt; incloops;
<a name="l01013"></a>01013                 pthloops = collectedPaths[i].second;
<a name="l01014"></a>01014                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> q = 0; q &lt; pthloops.size(); q++) {
<a name="l01015"></a>01015                 <span class="keywordflow">for</span> (std::set&lt;SgGraphNode*&gt;::iterator p = pthloops[q].begin(); p != pthloops[q].end(); p++) {
<a name="l01016"></a>01016                     <span class="keywordflow">for</span> (std::set&lt;std::vector&lt;SgGraphNode*&gt; &gt;::iterator o = mkloopmap[*p].begin(); o != mkloopmap[*p].end(); o++) {
<a name="l01017"></a>01017                         incloops.insert(*o);
<a name="l01018"></a>01018                     }
<a name="l01019"></a>01019                  }
<a name="l01020"></a>01020                }
<a name="l01021"></a>01021 
<a name="l01022"></a>01022         pathAnalyze(collectedPaths[i].first, <span class="keyword">false</span>, incloops);
<a name="l01023"></a>01023     }
<a name="l01024"></a>01024     collectedPaths.clear();
<a name="l01025"></a>01025 }
<a name="l01026"></a>01026 }
<a name="l01027"></a>01027  <span class="keywordflow">else</span> {
<a name="l01028"></a>01028             <span class="keywordflow">if</span> (collectedPaths.size() &gt; 0) {
<a name="l01029"></a>01029             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; collectedPaths.size(); i++) {
<a name="l01030"></a>01030                 std::set&lt;std::vector&lt;SgGraphNode*&gt; &gt; incloops;
<a name="l01031"></a>01031                 pthloops = collectedPaths[i].second;
<a name="l01032"></a>01032                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> q = 0; q &lt; pthloops.size(); q++) {
<a name="l01033"></a>01033                 <span class="keywordflow">for</span> (std::set&lt;SgGraphNode*&gt;::iterator p = pthloops[q].begin(); p != pthloops[q].end(); p++) {
<a name="l01034"></a>01034                     <span class="keywordflow">for</span> (std::set&lt;std::vector&lt;SgGraphNode*&gt; &gt;::iterator o = mkloopmap[*p].begin(); o != mkloopmap[*p].end(); o++) {
<a name="l01035"></a>01035                         incloops.insert(*o);
<a name="l01036"></a>01036                     }
<a name="l01037"></a>01037                  }
<a name="l01038"></a>01038                }
<a name="l01039"></a>01039  
<a name="l01040"></a>01040         pathAnalyze(collectedPaths[i].first, <span class="keyword">false</span>, incloops);
<a name="l01041"></a>01041     }
<a name="l01042"></a>01042     }
<a name="l01043"></a>01043     collectedPaths.clear();
<a name="l01044"></a>01044  <span class="keywordflow">break</span>;
<a name="l01045"></a>01045  }
<a name="l01046"></a>01046 }
<a name="l01047"></a>01047 
<a name="l01048"></a>01048 std::cout &lt;&lt; <span class="stringliteral">&quot;successes: &quot;</span> &lt;&lt; successes &lt;&lt; std::endl;
<a name="l01049"></a>01049 std::cout &lt;&lt; <span class="stringliteral">&quot;failures: &quot;</span> &lt;&lt; failures &lt;&lt; std::endl;
<a name="l01050"></a>01050 std::cout &lt;&lt; <span class="stringliteral">&quot;maxlst: &quot;</span> &lt;&lt; maxlst &lt;&lt; std::endl;
<a name="l01051"></a>01051 <span class="keywordflow">return</span>;
<a name="l01052"></a>01052 }
<a name="l01053"></a>01053 
<a name="l01054"></a>01054 
<a name="l01055"></a>01055 
<a name="l01056"></a>01056 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType&gt;
<a name="l01057"></a>01057 <span class="keywordtype">void</span>
<a name="l01058"></a>01058 <a class="code" href="classSgGraphTraversal.html#a4e0b975fa0d59c80d4d1422b56c4c486" title="runs the users evaluation function on all paths, thus is responsible for getting the paths to the use...">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</a>
<a name="l01059"></a><a class="code" href="classSgGraphTraversal.html#aff129df1b62a0b9d9add6996838f6c91">01059</a> <a class="code" href="classSgGraphTraversal.html#a4e0b975fa0d59c80d4d1422b56c4c486" title="runs the users evaluation function on all paths, thus is responsible for getting the paths to the use...">evaluatePaths</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* realstartnode, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* endnode) {
<a name="l01060"></a>01060 <span class="comment">//std::set&lt;SgGraphNode*&gt; seen;</span>
<a name="l01061"></a>01061 <span class="comment">//for (std::map&lt;SgGraphNode*, std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; &gt;::iterator i = pathsAtMk.begin(); i != pathsAtMk.end(); i++) {</span>
<a name="l01062"></a>01062 <span class="comment">/*    </span>
<a name="l01063"></a>01063 <span class="comment">    std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; tocheck = (*i).second;</span>
<a name="l01064"></a>01064 <span class="comment">    for (int j = 0; j &lt; tocheck.size(); j++) {</span>
<a name="l01065"></a>01065 <span class="comment">        for (int k = 0; k &lt; tocheck[j].size(); k++) {</span>
<a name="l01066"></a>01066 <span class="comment">            if (seen.find(tocheck[j][k]) != seen.end()) {</span>
<a name="l01067"></a>01067 <span class="comment">                ploops.insert(tocheck[j][k]);</span>
<a name="l01068"></a>01068 <span class="comment">            }</span>
<a name="l01069"></a>01069 <span class="comment">            else {</span>
<a name="l01070"></a>01070 <span class="comment">                seen.insert(tocheck[j][k]);</span>
<a name="l01071"></a>01071 <span class="comment">            }</span>
<a name="l01072"></a>01072 <span class="comment">        }</span>
<a name="l01073"></a>01073 <span class="comment">    }</span>
<a name="l01074"></a>01074 <span class="comment">}</span>
<a name="l01075"></a>01075 <span class="comment">*/</span>     
<a name="l01076"></a>01076 std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; <a class="code" href="structBot.html#a921887c740102f0e2899599311e1af31">path</a>;
<a name="l01077"></a>01077 std::vector&lt;SgGraphNode*&gt; spath;
<a name="l01078"></a>01078 <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n = realstartnode;
<a name="l01079"></a>01079 <span class="keywordtype">int</span> successes = 0;
<a name="l01080"></a>01080 <span class="keywordtype">int</span> failures = 0;
<a name="l01081"></a>01081 <span class="keywordtype">int</span> j = 0;
<a name="l01082"></a>01082 std::vector&lt;SgGraphNode*&gt; <a class="code" href="structBot.html#ab5f7df14761543c1a3099340ca6cbf36">currpth</a>;
<a name="l01083"></a>01083 <span class="keywordtype">int</span> currint = 0;
<a name="l01084"></a>01084 std::map&lt;SgGraphNode*, int&gt; intPath;
<a name="l01085"></a>01085 intPath[n] = currint;
<a name="l01086"></a>01086 currint++;
<a name="l01087"></a>01087 std::map&lt;SgGraphNode*, int&gt; currents;
<a name="l01088"></a>01088 <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* currnode;
<a name="l01089"></a>01089 <span class="keywordtype">bool</span> step = <span class="keyword">false</span>;
<a name="l01090"></a>01090 <span class="keywordtype">bool</span> midstep = <span class="keyword">false</span>;
<a name="l01091"></a>01091 
<a name="l01092"></a>01092 <span class="comment">//note: pathsAtMk is referring to subpaths connected to that marker, a marker is a split in the graph (usually an if statement)</span>
<a name="l01093"></a>01093 
<a name="l01094"></a>01094 std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; pth = pathsAtMk[realstartnode];
<a name="l01095"></a>01095 std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; cpth = pathsAtMk[realstartnode];
<a name="l01096"></a>01096     path.clear();
<a name="l01097"></a>01097     <span class="keywordtype">int</span> disjoints = 0;
<a name="l01098"></a>01098     <span class="keywordtype">int</span> disjointtrues = 0;
<a name="l01099"></a>01099     currpth = pth[0];
<a name="l01100"></a>01100     intPath[pth[0].front()] = currint;
<a name="l01101"></a>01101     std::set&lt;SgGraphNode*&gt; pthloopstmp;
<a name="l01102"></a>01102     <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* fakenode;
<a name="l01103"></a>01103     pthloopstmp.insert(fakenode);
<a name="l01104"></a>01104     std::vector&lt;std::set&lt;SgGraphNode*&gt; &gt; <a class="code" href="structBot.html#ac9a69748bb185d987f7ef7898dd2aca4">pthloops</a>;
<a name="l01105"></a>01105     pthloops.push_back(pthloopstmp);
<a name="l01106"></a>01106     pthloopstmp.clear();
<a name="l01107"></a>01107     currint++;
<a name="l01108"></a>01108     
<a name="l01109"></a>01109     <span class="keywordtype">int</span> stepnum = 0;
<a name="l01110"></a>01110     std::vector&lt;SgGraphNode*&gt; rs;
<a name="l01111"></a>01111     rs.push_back(realstartnode);
<a name="l01112"></a>01112     path.push_back(rs);
<a name="l01113"></a>01113     <span class="comment">//currflat.push_back(realstartnode);</span>
<a name="l01114"></a>01114     currents.clear();
<a name="l01115"></a>01115 
<a name="l01116"></a>01116     step = <span class="keyword">false</span>;
<a name="l01117"></a>01117     <span class="comment">//std::vector&lt;SgGraphNode*&gt; currflat;</span>
<a name="l01118"></a>01118     std::vector&lt;SgGraphNode*&gt; sub;
<a name="l01119"></a>01119 
<a name="l01120"></a>01120 <span class="comment">/*</span>
<a name="l01121"></a>01121 <span class="comment">    std::ofstream mz;</span>
<a name="l01122"></a>01122 <span class="comment">    mz.open(&quot;pathanalysis.dot&quot;);</span>
<a name="l01123"></a>01123 <span class="comment">    mz &lt;&lt; &quot;digraph defaultName { \n&quot;;</span>
<a name="l01124"></a>01124 <span class="comment">*/</span>
<a name="l01125"></a>01125     std::set&lt;std::vector&lt;SgGraphNode*&gt; &gt; nullIncLoops;
<a name="l01126"></a>01126 
<a name="l01127"></a>01127 <span class="comment">/*</span>
<a name="l01128"></a>01128 <span class="comment">    for (unsigned int p = 0; p &lt; looppaths.size(); p++) {</span>
<a name="l01129"></a>01129 <span class="comment">        std::vector&lt;SgGraphNode*&gt; lp = looppaths[p];</span>
<a name="l01130"></a>01130 <span class="comment"></span>
<a name="l01131"></a>01131 <span class="comment">        for (unsigned int i = 0; i &lt; lp.size()-1; i++) {</span>
<a name="l01132"></a>01132 <span class="comment">            for (unsigned int l = i+1; l &lt; lp.size(); l++) {</span>
<a name="l01133"></a>01133 <span class="comment">                if (lp[i] == lp[l] &amp;&amp; lp[i] != realstartnode &amp;&amp; lp[i] != endnode) {</span>
<a name="l01134"></a>01134 <span class="comment">                std::vector&lt;SgGraphNode*&gt; interiorloop;</span>
<a name="l01135"></a>01135 <span class="comment">                interiorloop.clear();</span>
<a name="l01136"></a>01136 <span class="comment">                for (unsigned int j = i; j &lt; l+1; j++) {</span>
<a name="l01137"></a>01137 <span class="comment">                    interiorloop.push_back(lp[j]);</span>
<a name="l01138"></a>01138 <span class="comment">                }</span>
<a name="l01139"></a>01139 <span class="comment">                if (interiorloop.size() &gt; 2) {</span>
<a name="l01140"></a>01140 <span class="comment">                }</span>
<a name="l01141"></a>01141 <span class="comment">                if (interiorloop.size() &gt; 2 &amp;&amp; interiorloop.back() != endnode) {</span>
<a name="l01142"></a>01142 <span class="comment">                if (find(iLoops.begin(), iLoops.end(), interiorloop) == iLoops.end()) {</span>
<a name="l01143"></a>01143 <span class="comment">                    if (find(looppaths.begin(), looppaths.end(), interiorloop) == looppaths.end()) {</span>
<a name="l01144"></a>01144 <span class="comment">                        iLoops.push_back(interiorloop);</span>
<a name="l01145"></a>01145 <span class="comment">                        loopnum++;</span>
<a name="l01146"></a>01146 <span class="comment">                        for (unsigned int k = 0; k &lt; interiorloop.size(); k++) {</span>
<a name="l01147"></a>01147 <span class="comment">                             loopNumMap[interiorloop[k]] = loopnum;</span>
<a name="l01148"></a>01148 <span class="comment">                        }</span>
<a name="l01149"></a>01149 <span class="comment">                        lpbegins[interiorloop.front()].insert(interiorloop);</span>
<a name="l01150"></a>01150 <span class="comment">                        pathAnalyze(interiorloop, true, nullIncLoops);</span>
<a name="l01151"></a>01151 <span class="comment">                        </span>
<a name="l01152"></a>01152 <span class="comment">                    }</span>
<a name="l01153"></a>01153 <span class="comment">                }</span>
<a name="l01154"></a>01154 <span class="comment">                }</span>
<a name="l01155"></a>01155 <span class="comment">                }</span>
<a name="l01156"></a>01156 <span class="comment">            }</span>
<a name="l01157"></a>01157 <span class="comment">        }</span>
<a name="l01158"></a>01158 <span class="comment">        if (lp.size() &gt; 2) {   </span>
<a name="l01159"></a>01159 <span class="comment">            lpbegins[lp.front()].insert(lp);      </span>
<a name="l01160"></a>01160 <span class="comment">            pathAnalyze(lp, true, nullIncLoops);</span>
<a name="l01161"></a>01161 <span class="comment">            //for (unsigned int i = 1; i &lt; lp.size(); i++) {</span>
<a name="l01162"></a>01162 <span class="comment">            //    printNodePlusEdgesForAnalysisPath(g, lp, p, p, mz);</span>
<a name="l01163"></a>01163 <span class="comment">            //}</span>
<a name="l01164"></a>01164 <span class="comment">        }</span>
<a name="l01165"></a>01165 <span class="comment">    }</span>
<a name="l01166"></a>01166 <span class="comment">*/</span>
<a name="l01167"></a>01167     <span class="keywordflow">while</span> (step == <span class="keyword">false</span>) {
<a name="l01168"></a>01168         stepnum++;
<a name="l01169"></a>01169         
<a name="l01170"></a>01170         <span class="keywordflow">if</span> (currpth.back() == endnode) {
<a name="l01171"></a>01171             path.push_back(currpth);
<a name="l01172"></a>01172             <span class="comment">//for (int i = 0; i &lt; currpth.size(); i++) {</span>
<a name="l01173"></a>01173             <span class="comment">//    currflat.push_back(currpth[i]);</span>
<a name="l01174"></a>01174             <span class="comment">//}</span>
<a name="l01175"></a>01175             std::vector&lt;SgGraphNode*&gt; flatpath;
<a name="l01176"></a>01176             <span class="comment">//std::vector&lt;SgGraphNode*&gt; sub;</span>
<a name="l01177"></a>01177             std::set&lt;std::vector&lt;SgGraphNode*&gt; &gt; incloops;
<a name="l01178"></a>01178             <span class="keyword">struct </span>timeval q1, q2;
<a name="l01179"></a>01179             <span class="comment">//std::cout &lt;&lt; &quot;path.size(): &quot; &lt;&lt; path.size() &lt;&lt; std::endl;</span>
<a name="l01180"></a>01180             <span class="comment">//std::cout &lt;&lt; &quot;pthloops.size(): &quot; &lt;&lt; pthloops.size() &lt;&lt; std::endl;</span>
<a name="l01181"></a>01181             ROSE_ASSERT(path.size() == pthloops.size() + 1);
<a name="l01182"></a>01182             q1 = <a class="code" href="graphProcessingSgIncGraph_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l01183"></a>01183             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; pthloops.size(); q++) {
<a name="l01184"></a>01184                 <span class="comment">//sub = path[q];</span>
<a name="l01185"></a>01185                 <span class="comment">//sub.pop_back();</span>
<a name="l01186"></a>01186                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> r = 0; r &lt; path[q].size(); r++) {
<a name="l01187"></a>01187                     flatpath.push_back(path[q][r]);
<a name="l01188"></a>01188                 }
<a name="l01189"></a>01189                 <span class="keywordflow">for</span> (std::set&lt;SgGraphNode*&gt;::iterator p = pthloops[q].begin(); p != pthloops[q].end(); p++) {
<a name="l01190"></a>01190                     <span class="keywordflow">for</span> (std::set&lt;std::vector&lt;SgGraphNode*&gt; &gt;::iterator o = mkloopmap[*p].begin(); o != mkloopmap[*p].end(); o++) {
<a name="l01191"></a>01191                         incloops.insert(*o);
<a name="l01192"></a>01192                     }
<a name="l01193"></a>01193                  }
<a name="l01194"></a>01194              }
<a name="l01195"></a>01195              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pt2 = 0; pt2 &lt; path[path.size()-1].size(); pt2++) {
<a name="l01196"></a>01196                      flatpath.push_back(path[path.size()-1][pt2]);
<a name="l01197"></a>01197              }
<a name="l01198"></a>01198              
<a name="l01199"></a>01199              q2 = <a class="code" href="graphProcessingSgIncGraph_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l01200"></a>01200              fllp += <a class="code" href="graphProcessing_8h.html#ae0e3d51bc94bbc9201f1125a8407492f">timeDifference</a>(q2,q1);
<a name="l01201"></a>01201              flatpath.push_back(endnode);
<a name="l01202"></a>01202 <span class="comment">/* </span>
<a name="l01203"></a>01203 <span class="comment">            for (unsigned int ps = 0; ps &lt; flatpath.size(); ps++) {</span>
<a name="l01204"></a>01204 <span class="comment">                 if (lpbegins.find(flatpath[ps]) != lpbegins.end()) {</span>
<a name="l01205"></a>01205 <span class="comment">                     for (std::set&lt;std::vector&lt;SgGraphNode*&gt; &gt;::iterator sv = lpbegins[flatpath[ps]].begin(); sv != lpbegins[flatpath[ps]].end(); sv++) {</span>
<a name="l01206"></a>01206 <span class="comment">                         incloops.insert(*sv);</span>
<a name="l01207"></a>01207 <span class="comment">                     }</span>
<a name="l01208"></a>01208 <span class="comment">                 }</span>
<a name="l01209"></a>01209 <span class="comment">             }</span>
<a name="l01210"></a>01210 <span class="comment">*/</span>
<a name="l01211"></a>01211 <span class="comment">//user defined function, run on the final path, gives the user loops that are included via &quot;incloops&quot; a set of vectors that contain the individual loops</span>
<a name="l01212"></a>01212              pathAnalyze(flatpath, <span class="keyword">false</span>, incloops);
<a name="l01213"></a>01213              incloops.clear();
<a name="l01214"></a>01214                 <span class="comment">//printNodePlusEdgesForAnalysisPath(g, flatpath, -1, -1, mz);</span>
<a name="l01215"></a>01215 
<a name="l01216"></a>01216              <span class="keywordtype">int</span> pts = pathsSize++;
<a name="l01217"></a>01217              pathsSize += 1;
<a name="l01218"></a>01218             
<a name="l01219"></a>01219              flatpath.clear();
<a name="l01220"></a>01220              path.pop_back();
<a name="l01221"></a>01221              <span class="keywordtype">int</span> rounds = 0;
<a name="l01222"></a>01222              <span class="keywordtype">bool</span> starter = <span class="keyword">false</span>;
<a name="l01223"></a>01223 
<a name="l01224"></a>01224 <span class="comment">// This gets a bit complicated so here is an overview:</span>
<a name="l01225"></a>01225 <span class="comment">// This is running down the graph and finding the endnode. Once it finds the endnode it goes back up to the last unevaluated subpath. It does this quickly with an integer that counts how many times that node has been used for a path. If this ends up being the number of outnodes, we don&#39;t need that node anymore, so we clear it to zero, then continue up the graph. We HAVE to reset because every time a new pathway is chosen above that node, it needs to have the ability to traverse that node.</span>
<a name="l01226"></a>01226 
<a name="l01227"></a>01227 
<a name="l01228"></a>01228               <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l01229"></a>01229                    rounds++;
<a name="l01230"></a>01230                    ROSE_ASSERT(pathsAtMk.find((path.back()).back()) != pathsAtMk.end());
<a name="l01231"></a>01231                    <span class="keywordflow">if</span> ((path.back()).front() == realstartnode) {
<a name="l01232"></a>01232                        starter = <span class="keyword">true</span>;
<a name="l01233"></a>01233                    }
<a name="l01234"></a>01234                    <span class="keywordflow">if</span> (currents[(path.back()).back()] &lt; (pathsAtMk[(path.back()).back()].size()) <span class="comment">/*|| (path.back()).front() == realstartnode*/</span>) {
<a name="l01235"></a>01235                               std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; cpths = pathsAtMk[(path.back()).back()];
<a name="l01236"></a>01236                               currpth = cpths[currents[(path.back()).back()]];
<a name="l01237"></a>01237                               currents[(path.back()).back()]++;
<a name="l01238"></a>01238                               <span class="keywordflow">break</span>;
<a name="l01239"></a>01239                    }
<a name="l01240"></a>01240                    <span class="keywordflow">else</span> {
<a name="l01241"></a>01241                        currents[(path.back()).back()] = 0;
<a name="l01242"></a>01242                        path.pop_back();
<a name="l01243"></a>01243                        pthloops.pop_back();
<a name="l01244"></a>01244                    }
<a name="l01245"></a>01245                    <span class="keywordflow">if</span> (starter == <span class="keyword">true</span>) {
<a name="l01246"></a>01246                        step = <span class="keyword">true</span>;
<a name="l01247"></a>01247                        <span class="keywordflow">break</span>;
<a name="l01248"></a>01248                    }
<a name="l01249"></a>01249 
<a name="l01250"></a>01250            }
<a name="l01251"></a>01251         }
<a name="l01252"></a>01252         <span class="keywordflow">else</span> {
<a name="l01253"></a>01253 
<a name="l01254"></a>01254 <span class="comment">//this checks first to see if we have any loops in our path. If not it continues down, if there is it goes back to the last nonloop node</span>
<a name="l01255"></a>01255         <span class="keywordtype">bool</span> disj = <span class="keyword">true</span>;
<a name="l01256"></a>01256         <span class="keyword">struct </span>timeval tdisb, tdise;
<a name="l01257"></a>01257         tdisb = <a class="code" href="graphProcessingSgIncGraph_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l01258"></a>01258         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; pthloops.size(); i++) {
<a name="l01259"></a>01259             <span class="keywordflow">for</span> (std::set&lt;SgGraphNode*&gt;::iterator j = pthloops[i].begin(); j != pthloops[i].end(); j++) {
<a name="l01260"></a>01260                 <span class="keywordflow">if</span> (<a class="code" href="namespaceSageInterface.html#aff5394b21cf11cd338671af3a11a7f92">find</a>(currpth.begin(), currpth.end(), *j) != currpth.end()) {
<a name="l01261"></a>01261                     disj = <span class="keyword">false</span>;
<a name="l01262"></a>01262                 }
<a name="l01263"></a>01263              }
<a name="l01264"></a>01264         }
<a name="l01265"></a>01265 <span class="comment">/*</span>
<a name="l01266"></a>01266 <span class="comment">        #pragma omp parallel for num_threads(4) private(i,j)</span>
<a name="l01267"></a>01267 <span class="comment">        for (i = 0; i &lt; pthloops.size(); i++) {</span>
<a name="l01268"></a>01268 <span class="comment">            if (disj) {</span>
<a name="l01269"></a>01269 <span class="comment">            for (std::set&lt;SgGraphNode*&gt;::iterator j = pthloops[i].begin(); j != pthloops[i].end(); j++) {</span>
<a name="l01270"></a>01270 <span class="comment">                if (find(currpth.begin(), currpth.end(), *j) != currpth.end()) {</span>
<a name="l01271"></a>01271 <span class="comment">                    disj = false;</span>
<a name="l01272"></a>01272 <span class="comment">                    //j = pthloops[i].size();</span>
<a name="l01273"></a>01273 <span class="comment">                }</span>
<a name="l01274"></a>01274 <span class="comment">            }</span>
<a name="l01275"></a>01275 <span class="comment">            }</span>
<a name="l01276"></a>01276 <span class="comment">            </span>
<a name="l01277"></a>01277 <span class="comment">        }</span>
<a name="l01278"></a>01278 <span class="comment">*/</span>
<a name="l01279"></a>01279         tdise = <a class="code" href="graphProcessingSgIncGraph_8h.html#ab6d29d20cfc76e01eb759ce6d926c93b">getCPUTime</a>();
<a name="l01280"></a>01280         distime += <a class="code" href="graphProcessing_8h.html#ae0e3d51bc94bbc9201f1125a8407492f">timeDifference</a>(tdise, tdisb);
<a name="l01281"></a>01281         <span class="keywordflow">if</span> (disj) {
<a name="l01282"></a>01282             
<a name="l01283"></a>01283             disjointtrues++;
<a name="l01284"></a>01284             <span class="comment">//std::cout &lt;&lt; &quot;disjoints: &quot; &lt;&lt; disjointtrues &lt;&lt; std::endl;</span>
<a name="l01285"></a>01285             midstep = <span class="keyword">false</span>;
<a name="l01286"></a>01286             std::set&lt;SgGraphNode*&gt; pthloopstmp;
<a name="l01287"></a>01287             pthloopstmp.clear();
<a name="l01288"></a>01288                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; currpth.size(); i++) {
<a name="l01289"></a>01289                     <span class="comment">//currflat.push_back(currpth[i]);</span>
<a name="l01290"></a>01290                     <span class="keywordflow">if</span> (mkloops.find(currpth[i]) != mkloops.end()) {
<a name="l01291"></a>01291                        pthloopstmp.insert(currpth[i]);
<a name="l01292"></a>01292                     }
<a name="l01293"></a>01293                 }
<a name="l01294"></a>01294                 pthloops.push_back(pthloopstmp);
<a name="l01295"></a>01295                 path.push_back(currpth);
<a name="l01296"></a>01296                 pthloopstmp.clear();
<a name="l01297"></a>01297                 
<a name="l01298"></a>01298                 <span class="comment">//std::set&lt;std::vector&lt;SgGraphNode*&gt; &gt; lpth;</span>
<a name="l01299"></a>01299                 std::vector&lt;SgGraphNode*&gt; oldcurrpth = currpth;
<a name="l01300"></a>01300                 currpth.clear();
<a name="l01301"></a>01301                 <span class="keywordflow">if</span> (currents.find((path.back()).back()) == currents.end()) {
<a name="l01302"></a>01302                     currents[(path.back()).back()] = 0;
<a name="l01303"></a>01303                 }
<a name="l01304"></a>01304                         <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* frontnode = (path.back()).front();
<a name="l01305"></a>01305                         <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* backnode = (path.back()).back();
<a name="l01306"></a>01306      
<a name="l01307"></a>01307                         ROSE_ASSERT(pathsAtMk.find(backnode) != pathsAtMk.end() || backnode == endnode);
<a name="l01308"></a>01308                         ROSE_ASSERT(pathsAtMk.find(frontnode) != pathsAtMk.end());
<a name="l01309"></a>01309                         <span class="keywordflow">if</span> (currents.find(backnode) == currents.end()) {
<a name="l01310"></a>01310                             currents[backnode] = 0;
<a name="l01311"></a>01311                         }
<a name="l01312"></a>01312                         <span class="keywordflow">else</span> {
<a name="l01313"></a>01313                             ROSE_ASSERT(currents[backnode] == 0);
<a name="l01314"></a>01314                         }
<a name="l01315"></a>01315                         std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; tmppths = pathsAtMk[backnode];
<a name="l01316"></a>01316                        
<a name="l01317"></a>01317                         currpth = tmppths[currents[backnode]];
<a name="l01318"></a>01318                         ROSE_ASSERT(currpth != oldcurrpth);
<a name="l01319"></a>01319                         currents[backnode]++;
<a name="l01320"></a>01320                     }        
<a name="l01321"></a>01321      <span class="keywordflow">else</span> {
<a name="l01322"></a>01322         disjoints++;
<a name="l01323"></a>01323         <span class="comment">//std::cout &lt;&lt; &quot;disjoint false: &quot; &lt;&lt; s &lt;&lt; std::endl;</span>
<a name="l01324"></a>01324         
<a name="l01325"></a>01325         <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l01326"></a>01326             <span class="keywordflow">if</span> (currents[(path.back()).back()] &lt; pathsAtMk[(path.back()).back()].size() || path.back().back() == realstartnode) {
<a name="l01327"></a>01327                 <span class="keywordflow">break</span>;
<a name="l01328"></a>01328             }
<a name="l01329"></a>01329             currents[(path.back()).back()] = 0;
<a name="l01330"></a>01330             path.pop_back();
<a name="l01331"></a>01331             pthloops.pop_back();
<a name="l01332"></a>01332         }
<a name="l01333"></a>01333         <span class="keywordflow">if</span> ((path.back()).back() != realstartnode) {
<a name="l01334"></a>01334         currpth = (pathsAtMk[(path.back()).back()])[currents[(path.back()).back()]];
<a name="l01335"></a>01335         currents[(path.back()).back()]++;
<a name="l01336"></a>01336         }
<a name="l01337"></a>01337         <span class="keywordflow">else</span> {
<a name="l01338"></a>01338         step = <span class="keyword">true</span>;
<a name="l01339"></a>01339         }
<a name="l01340"></a>01340     }
<a name="l01341"></a>01341  }
<a name="l01342"></a>01342  }
<a name="l01343"></a>01343 std::cout &lt;&lt; <span class="stringliteral">&quot;successes: &quot;</span> &lt;&lt; successes &lt;&lt; std::endl;
<a name="l01344"></a>01344 std::cout &lt;&lt; <span class="stringliteral">&quot;failures: &quot;</span> &lt;&lt; failures &lt;&lt; std::endl;
<a name="l01345"></a>01345 
<a name="l01346"></a>01346 <span class="keywordflow">return</span>;
<a name="l01347"></a>01347 }
<a name="l01348"></a>01348     
<a name="l01349"></a>01349         
<a name="l01350"></a>01350 <span class="comment">//these are debugging functions, used to visually ascertain where the paths are going to check to make sure everything is evaluated</span>
<a name="l01351"></a>01351 
<a name="l01352"></a>01352 
<a name="l01353"></a>01353 <span class="comment">/* DEBUGGING */</span>
<a name="l01354"></a>01354 
<a name="l01355"></a>01355 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType&gt;
<a name="l01356"></a>01356 <span class="keywordtype">void</span>
<a name="l01357"></a>01357 <a class="code" href="classSgGraphTraversal.html#affa8a10ae10b229fa790a11bf7d0d0f6">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</a>
<a name="l01358"></a><a class="code" href="classSgGraphTraversal.html#affa8a10ae10b229fa790a11bf7d0d0f6">01358</a> <a class="code" href="classSgGraphTraversal.html#affa8a10ae10b229fa790a11bf7d0d0f6">printNodePlusEdgesForAnalysis</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n, <span class="keywordtype">int</span> loopNum, <span class="keywordtype">int</span> pathVal, std::ofstream&amp; ss) {
<a name="l01359"></a>01359   printNodeForAnalysis(n, loopNum, pathVal, ss);
<a name="l01360"></a>01360   std::set&lt;SgDirectedGraphEdge*&gt; <a class="code" href="namespaceStaticCFG.html#ab6db4c881b581bbf831656db30daf0ce">outEdges</a> = g-&gt;<a class="code" href="classSgIncidenceDirectedGraph.html#af313470c8b7ba952134a8420ef425726">computeEdgeSetOut</a>(n);
<a name="l01361"></a>01361   <span class="keywordflow">for</span> (std::set&lt;SgDirectedGraphEdge*&gt;::iterator i = outEdges.begin(); i != outEdges.end(); i++) {
<a name="l01362"></a>01362     <span class="keywordflow">if</span> (nullEdgesOrdered.find(*i) == nullEdgesOrdered.end()) {
<a name="l01363"></a>01363         printEdgeForAnalysis(*i, <span class="keyword">false</span>, ss);
<a name="l01364"></a>01364     }
<a name="l01365"></a>01365     <span class="keywordflow">else</span> {
<a name="l01366"></a>01366         printEdgeForAnalysis(*i, <span class="keyword">true</span>, ss);
<a name="l01367"></a>01367     }   
<a name="l01368"></a>01368   }
<a name="l01369"></a>01369 }
<a name="l01370"></a>01370 
<a name="l01371"></a>01371 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType&gt;
<a name="l01372"></a>01372 <span class="keywordtype">void</span>
<a name="l01373"></a>01373 <a class="code" href="classSgGraphTraversal.html#ab897274ca07ab604307e624b39d63563">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</a>
<a name="l01374"></a><a class="code" href="classSgGraphTraversal.html#ab897274ca07ab604307e624b39d63563">01374</a> <a class="code" href="classSgGraphTraversal.html#ab897274ca07ab604307e624b39d63563">printNodePlusEdgesForAnalysisPath</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, std::vector&lt;SgGraphNode*&gt; n, <span class="keywordtype">int</span> loopNum, <span class="keywordtype">int</span> pathVal, std::ofstream&amp; ss) {
<a name="l01375"></a>01375   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n.size()-1; i++) {
<a name="l01376"></a>01376      <span class="keywordflow">if</span> (completedNodesPath.find(n[i]) == completedNodesPath.end()) {
<a name="l01377"></a>01377          printNodeForAnalysis(n[i], loopNum, pathVal, ss);
<a name="l01378"></a>01378          completedNodesPath.insert(n[i]);
<a name="l01379"></a>01379      }
<a name="l01380"></a>01380      std::pair&lt;SgGraphNode*, SgGraphNode*&gt; prnod;
<a name="l01381"></a>01381      prnod.first = n[i+1];
<a name="l01382"></a>01382      prnod.second = n[i];
<a name="l01383"></a>01383      <span class="keywordflow">if</span> (completedEdgesPath.find(prnod) == completedEdgesPath.end()) {
<a name="l01384"></a>01384          printEdgeForAnalysisPath(n[i+1], n[i], ss);
<a name="l01385"></a>01385          completedEdgesPath.insert(prnod);
<a name="l01386"></a>01386      }
<a name="l01387"></a>01387   }
<a name="l01388"></a>01388   <span class="keywordflow">if</span> (completedNodesPath.find(n[n.size() - 1]) == completedNodesPath.end()) {
<a name="l01389"></a>01389      printNodeForAnalysis(n[n.size()-1], loopNum, pathVal, ss);
<a name="l01390"></a>01390      completedNodesPath.insert(n[n.size() - 1]);
<a name="l01391"></a>01391   }
<a name="l01392"></a>01392 
<a name="l01393"></a>01393 }
<a name="l01394"></a>01394 
<a name="l01395"></a>01395 
<a name="l01396"></a>01396 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType&gt;
<a name="l01397"></a>01397 <span class="keywordtype">void</span>
<a name="l01398"></a>01398 <a class="code" href="classSgGraphTraversal.html#aaa17519821f913b3271d741d6058a8eb">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</a>
<a name="l01399"></a><a class="code" href="classSgGraphTraversal.html#aaa17519821f913b3271d741d6058a8eb">01399</a> <a class="code" href="classSgGraphTraversal.html#aaa17519821f913b3271d741d6058a8eb">printNodeForAnalysis</a>(<a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n, <span class="keywordtype">int</span> loopNum, <span class="keywordtype">int</span> pathNum, std::ofstream &amp;ss) {
<a name="l01400"></a>01400   <span class="keywordtype">int</span> <span class="keywordtype">id</span> = n-&gt;<a class="code" href="classSgGraphNode.html#a5d9c20d84e5cda80e95287a384c9a27e">get_index</a>();
<a name="l01401"></a>01401   std::string nodeColor = <span class="stringliteral">&quot;black&quot;</span>;
<a name="l01402"></a>01402   <span class="keywordflow">if</span> (loopNum != 0) {
<a name="l01403"></a>01403   ss &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot; [label=\&quot;&quot;</span> &lt;&lt; <span class="stringliteral">&quot;LoopNumS&quot;</span> &lt;&lt; loopNum &lt;&lt; <span class="stringliteral">&quot;\&quot;, color=\&quot;&quot;</span> &lt;&lt; <span class="stringliteral">&quot;green&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\&quot;, style=\&quot;&quot;</span> &lt;&lt; <span class="stringliteral">&quot;solid&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\&quot;];\n&quot;</span>;
<a name="l01404"></a>01404   }
<a name="l01405"></a>01405   <span class="keywordflow">else</span> {
<a name="l01406"></a>01406   ss &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot; [label=\&quot;&quot;</span> &lt;&lt; <span class="stringliteral">&quot;pathNumS&quot;</span> &lt;&lt; pathNum &lt;&lt; <span class="stringliteral">&quot;\&quot;, color=\&quot;&quot;</span> &lt;&lt; <span class="stringliteral">&quot;black&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\&quot;, style=\&quot;&quot;</span> &lt;&lt; <span class="stringliteral">&quot;dotted&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\&quot;];\n&quot;</span>;
<a name="l01407"></a>01407   }
<a name="l01408"></a>01408   
<a name="l01409"></a>01409 }
<a name="l01410"></a>01410 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType&gt;
<a name="l01411"></a>01411 <span class="keywordtype">void</span>
<a name="l01412"></a>01412 <a class="code" href="classSgGraphTraversal.html#a089d55063e076d774796bb9f406dc43e">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</a>
<a name="l01413"></a><a class="code" href="classSgGraphTraversal.html#a089d55063e076d774796bb9f406dc43e">01413</a> <a class="code" href="classSgGraphTraversal.html#a089d55063e076d774796bb9f406dc43e">printEdgeForAnalysis</a>(<a class="code" href="classSgDirectedGraphEdge.html">SgDirectedGraphEdge</a>* e, <span class="keywordtype">bool</span> isNullEdge, std::ofstream &amp;ss) {
<a name="l01414"></a>01414   <span class="keywordflow">if</span> (isNullEdge) {
<a name="l01415"></a>01415       ss &lt;&lt; e-&gt;<a class="code" href="classSgDirectedGraphEdge.html#a83af6bd7480bf38509cb2add21a7549b">get_from</a>()-&gt;<a class="code" href="classSgGraphNode.html#a5d9c20d84e5cda80e95287a384c9a27e">get_index</a>() &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span> &lt;&lt; e-&gt;<a class="code" href="classSgDirectedGraphEdge.html#ae209679ec181224ad857bc0a5f5c97f9">get_to</a>()-&gt;<a class="code" href="classSgGraphNode.html#a5d9c20d84e5cda80e95287a384c9a27e">get_index</a>() &lt;&lt; <span class="stringliteral">&quot; [label=\&quot;&quot;</span> &lt;&lt; <span class="stringliteral">&quot;NullEdge&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\&quot;, style=\&quot;&quot;</span> &lt;&lt; <span class="stringliteral">&quot;dotted&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\&quot;];\n&quot;</span>;
<a name="l01416"></a>01416   }
<a name="l01417"></a>01417   <span class="keywordflow">else</span> {
<a name="l01418"></a>01418       ss &lt;&lt; e-&gt;<a class="code" href="classSgDirectedGraphEdge.html#a83af6bd7480bf38509cb2add21a7549b">get_from</a>()-&gt;<a class="code" href="classSgGraphNode.html#a5d9c20d84e5cda80e95287a384c9a27e">get_index</a>() &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span> &lt;&lt; e-&gt;<a class="code" href="classSgDirectedGraphEdge.html#ae209679ec181224ad857bc0a5f5c97f9">get_to</a>()-&gt;<a class="code" href="classSgGraphNode.html#a5d9c20d84e5cda80e95287a384c9a27e">get_index</a>() &lt;&lt; <span class="stringliteral">&quot; [label=\&quot;&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\&quot;, style=\&quot;&quot;</span> &lt;&lt; <span class="stringliteral">&quot;solid&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\&quot;];\n&quot;</span>;
<a name="l01419"></a>01419   }
<a name="l01420"></a>01420 }
<a name="l01421"></a>01421 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType&gt;
<a name="l01422"></a>01422 <span class="keywordtype">void</span>
<a name="l01423"></a>01423 <a class="code" href="classSgGraphTraversal.html#a7d22a63580636774eca3e252b50a9d7a">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</a>
<a name="l01424"></a><a class="code" href="classSgGraphTraversal.html#a7d22a63580636774eca3e252b50a9d7a">01424</a> <a class="code" href="classSgGraphTraversal.html#a7d22a63580636774eca3e252b50a9d7a">printEdgeForAnalysisPath</a>(<a class="code" href="classSgGraphNode.html">SgGraphNode</a>* g1, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* g2, std::ofstream &amp;ss) {
<a name="l01425"></a>01425       ss &lt;&lt; g2-&gt;<a class="code" href="classSgGraphNode.html#a5d9c20d84e5cda80e95287a384c9a27e">get_index</a>() &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span> &lt;&lt; g1-&gt;<a class="code" href="classSgGraphNode.html#a5d9c20d84e5cda80e95287a384c9a27e">get_index</a>() &lt;&lt; <span class="stringliteral">&quot; [label=\&quot;&quot;</span> &lt;&lt; <span class="stringliteral">&quot;Edge&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\&quot;, style=\&quot;&quot;</span> &lt;&lt; <span class="stringliteral">&quot;solid&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\&quot;];\n&quot;</span>;
<a name="l01426"></a>01426 }
<a name="l01427"></a>01427 
<a name="l01428"></a>01428 <span class="comment">/* END DEBUGGING */</span>
<a name="l01429"></a>01429 
<a name="l01430"></a>01430 <span class="comment">//This function sets up the graph so that the evaluatePath function can easily traverse the paths</span>
<a name="l01431"></a>01431 
<a name="l01432"></a>01432 <span class="keyword">template</span>&lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType&gt;
<a name="l01433"></a>01433 <span class="keywordtype">void</span>
<a name="l01434"></a>01434 <a class="code" href="classSgGraphTraversal.html#a1a9736b9bd3eeef8ee9b75b6cdfbdfc5">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</a>
<a name="l01435"></a><a class="code" href="classSgGraphTraversal.html#af562e2f2aab02e58a3250ceea73d1aad">01435</a> <a class="code" href="classSgGraphTraversal.html#a1a9736b9bd3eeef8ee9b75b6cdfbdfc5">solvePaths</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* endnode) {
<a name="l01436"></a>01436     <span class="keywordtype">bool</span> done = <span class="keyword">false</span>;
<a name="l01437"></a>01437     <span class="keywordtype">bool</span> edges = <span class="keyword">true</span>;
<a name="l01438"></a>01438     <span class="keywordtype">bool</span> tookone = <span class="keyword">false</span>;
<a name="l01439"></a>01439     std::vector&lt;SgGraphNode*&gt; mkpath;
<a name="l01440"></a>01440     std::vector&lt;SgGraphNode*&gt; marks;
<a name="l01441"></a>01441     marks.push_back(n);
<a name="l01442"></a>01442     mkglobal.push_back(n);
<a name="l01443"></a>01443     <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* currn = n;
<a name="l01444"></a>01444     <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* took;
<a name="l01445"></a>01445     std::set&lt;SgDirectedGraphEdge*&gt; taken;
<a name="l01446"></a>01446     std::vector&lt;SgGraphNode*&gt; toTake;
<a name="l01447"></a>01447     std::vector&lt;SgGraphNode*&gt; path;
<a name="l01448"></a>01448     path.push_back(n);
<a name="l01449"></a>01449     mkpath.push_back(n);
<a name="l01450"></a>01450     <span class="keywordtype">int</span> itr = 0;
<a name="l01451"></a>01451     <span class="keywordtype">int</span> bifurcations = 0;
<a name="l01452"></a>01452     std::map&lt;SgGraphNode*, bool&gt; completed;
<a name="l01453"></a>01453     <span class="keywordflow">while</span> (done == <span class="keyword">false</span>) {
<a name="l01454"></a>01454              ROSE_ASSERT(currn != NULL);
<a name="l01455"></a>01455 <span class="comment">//check to see if we&#39;ve hit the endnode or if we&#39;re done, if not continue, if so push the subpath into the &quot;pathsAtMk&quot; repository            </span>
<a name="l01456"></a>01456                <span class="keywordflow">if</span> (currn == endnode || completed.find(currn) != completed.end()) {
<a name="l01457"></a>01457                 <span class="keywordflow">if</span> (pathsAtMk.find(marks.back()) == pathsAtMk.end()) {
<a name="l01458"></a>01458                     std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; emptypath;
<a name="l01459"></a>01459                     pathsAtMk[marks.back()] = emptypath;
<a name="l01460"></a>01460                 }
<a name="l01461"></a>01461                 edges = <span class="keyword">false</span>;
<a name="l01462"></a>01462                 pathsAtMk[marks.back()].push_back(mkpath);
<a name="l01463"></a>01463                 <span class="comment">//for (int mk = 0; mk &lt; mkpath.size(); mk++) {</span>
<a name="l01464"></a>01464                  <span class="comment">//   std::set&lt;SgDirectedGraphEdge*&gt; iedg = g-&gt;computeEdgeSetIn(mkpath[mk]);</span>
<a name="l01465"></a>01465                     <span class="comment">//if (iedg.size() &gt; 1) {</span>
<a name="l01466"></a>01466                     <span class="comment">//    ploops.insert(mkpath[mk]);</span>
<a name="l01467"></a>01467                    <span class="comment">// }</span>
<a name="l01468"></a>01468                 <span class="comment">//}</span>
<a name="l01469"></a>01469                 ROSE_ASSERT(mkpath.front() == marks.back());
<a name="l01470"></a>01470                 <span class="keywordflow">if</span> (marks.size() == 0) {
<a name="l01471"></a>01471                     <span class="keywordflow">return</span>;
<a name="l01472"></a>01472                 }
<a name="l01473"></a>01473                 mkpath.clear();
<a name="l01474"></a>01474                 <span class="keywordtype">bool</span> y = <span class="keyword">true</span>;
<a name="l01475"></a>01475                 <span class="keywordtype">bool</span> haventtaken = <span class="keyword">false</span>;
<a name="l01476"></a>01476                 <span class="keywordtype">bool</span> p = <span class="keyword">true</span>;
<a name="l01477"></a>01477                 <span class="keywordtype">int</span> place;
<a name="l01478"></a>01478                 <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;
<a name="l01479"></a>01479                 <span class="keywordflow">while</span> (found == <span class="keyword">false</span>) {
<a name="l01480"></a>01480                     <span class="keywordflow">if</span> (marks.size() == 0) {
<a name="l01481"></a>01481                         <span class="keywordflow">return</span>;
<a name="l01482"></a>01482                     }
<a name="l01483"></a>01483                     <a class="code" href="classSgDirectedGraphEdge.html">SgDirectedGraphEdge</a>* tooked;
<a name="l01484"></a>01484                     <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* mark1 = marks.back();
<a name="l01485"></a>01485                     std::set&lt;SgDirectedGraphEdge*&gt; oedg = g-&gt;<a class="code" href="classSgIncidenceDirectedGraph.html#af313470c8b7ba952134a8420ef425726">computeEdgeSetOut</a>(mark1);
<a name="l01486"></a>01486                     ROSE_ASSERT(oedg.size() &gt; 1 || mark1 == n);
<a name="l01487"></a>01487                         <span class="keywordflow">for</span> (std::set&lt;SgDirectedGraphEdge*&gt;::iterator j = oedg.begin(); j != oedg.end(); j++) {
<a name="l01488"></a>01488                             <span class="keywordflow">if</span> (taken.find(*j) == taken.end() &amp;&amp; haventtaken == <span class="keyword">false</span>) {
<a name="l01489"></a>01489                                 tooked = *j;
<a name="l01490"></a>01490                                 haventtaken = <span class="keyword">true</span>;
<a name="l01491"></a>01491                             }
<a name="l01492"></a>01492                         }
<a name="l01493"></a>01493                         <span class="keywordflow">if</span> (haventtaken == <span class="keyword">true</span>) {
<a name="l01494"></a>01494                             <span class="keywordflow">if</span> (marks.back() == n) {
<a name="l01495"></a>01495                                 path.clear();
<a name="l01496"></a>01496                             }
<a name="l01497"></a>01497                             path.push_back(marks.back());
<a name="l01498"></a>01498                             <span class="keywordflow">if</span> ( mkpath.empty() || (mkpath.back() != marks.back()) ) {
<a name="l01499"></a>01499                                 ROSE_ASSERT(!marks.empty());
<a name="l01500"></a>01500                                 mkpath.push_back(marks.back());
<a name="l01501"></a>01501                             }
<a name="l01502"></a>01502                             taken.insert(tooked);
<a name="l01503"></a>01503                             took = tooked-&gt;<a class="code" href="classSgDirectedGraphEdge.html#ae209679ec181224ad857bc0a5f5c97f9">get_to</a>();
<a name="l01504"></a>01504                             found = <span class="keyword">true</span>;
<a name="l01505"></a>01505                         }
<a name="l01506"></a>01506                         <span class="keywordflow">else</span> {
<a name="l01507"></a>01507                             completed[marks.back()] = <span class="keyword">true</span>;
<a name="l01508"></a>01508                             bifurcations++;
<a name="l01509"></a>01509                             marks.pop_back();
<a name="l01510"></a>01510                         }
<a name="l01511"></a>01511                     }
<a name="l01512"></a>01512                     <span class="keywordflow">if</span> (marks.size() == 0) {
<a name="l01513"></a>01513                         <span class="keywordflow">return</span>;
<a name="l01514"></a>01514                     } 
<a name="l01515"></a>01515                     haventtaken = <span class="keyword">false</span>;
<a name="l01516"></a>01516                     found = <span class="keyword">false</span>; 
<a name="l01517"></a>01517                                 
<a name="l01518"></a>01518              }
<a name="l01519"></a>01519 <span class="comment">//if we haven&#39;t reached the endnode or completed, continue down the graph</span>
<a name="l01520"></a>01520              <span class="keywordflow">else</span> {
<a name="l01521"></a>01521             std::set&lt;SgDirectedGraphEdge*&gt; oedg = g-&gt;<a class="code" href="classSgIncidenceDirectedGraph.html#af313470c8b7ba952134a8420ef425726">computeEdgeSetOut</a>(currn);
<a name="l01522"></a>01522             std::set&lt;SgDirectedGraphEdge*&gt; iedg = g-&gt;<a class="code" href="classSgIncidenceDirectedGraph.html#a109c80348472be5c09a0d9b9bcc2d9a1">computeEdgeSetIn</a>(currn);
<a name="l01523"></a>01523             <span class="keywordflow">if</span> (oedg.size() &gt; 1) {
<a name="l01524"></a>01524                      <span class="keywordflow">if</span> (mkpath.back() != currn) {
<a name="l01525"></a>01525                      mkpath.push_back(currn);
<a name="l01526"></a>01526                      }
<a name="l01527"></a>01527                      pathsAtMk[marks.back()].push_back(mkpath);
<a name="l01528"></a>01528                      mkpath.clear();
<a name="l01529"></a>01529                      mkpath.push_back(currn);
<a name="l01530"></a>01530                      marks.push_back(currn);
<a name="l01531"></a>01531                      <span class="keywordflow">if</span> (<a class="code" href="namespaceSageInterface.html#aff5394b21cf11cd338671af3a11a7f92">find</a>(mkglobal.begin(), mkglobal.end(), currn) == mkglobal.end()) {
<a name="l01532"></a>01532                          mkglobal.push_back(currn);
<a name="l01533"></a>01533                      }
<a name="l01534"></a>01534                      <span class="keywordflow">for</span> (std::set&lt;SgDirectedGraphEdge*&gt;::iterator i = oedg.begin(); i != oedg.end(); i++) {
<a name="l01535"></a>01535                           <span class="keywordflow">if</span> (taken.find(*i) == taken.end() &amp;&amp; tookone == <span class="keyword">false</span>) {
<a name="l01536"></a>01536                                taken.insert(*i);
<a name="l01537"></a>01537                                tookone = <span class="keyword">true</span>;
<a name="l01538"></a>01538                                took = (*i)-&gt;get_to();
<a name="l01539"></a>01539                           }
<a name="l01540"></a>01540                           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (taken.find(*i) == taken.end() &amp;&amp; tookone == <span class="keyword">true</span>) {
<a name="l01541"></a>01541                                <span class="comment">//toTake.push_back((*i)-&gt;get_to());</span>
<a name="l01542"></a>01542                           }
<a name="l01543"></a>01543                    }
<a name="l01544"></a>01544                    tookone = <span class="keyword">false</span>;
<a name="l01545"></a>01545            }
<a name="l01546"></a>01546            <span class="keywordflow">else</span> {
<a name="l01547"></a>01547                 took = (*(oedg.begin()))-&gt;get_to();
<a name="l01548"></a>01548            }
<a name="l01549"></a>01549            }
<a name="l01550"></a>01550            itr++;
<a name="l01551"></a>01551            
<a name="l01552"></a>01552            <span class="keywordflow">if</span> (<a class="code" href="namespaceSageInterface.html#aff5394b21cf11cd338671af3a11a7f92">find</a>(path.begin(), path.end(), took) == path.end()) {
<a name="l01553"></a>01553                mkpath.push_back(took);
<a name="l01554"></a>01554                path.push_back(took);
<a name="l01555"></a>01555                currn = took;
<a name="l01556"></a>01556            }
<a name="l01557"></a>01557            <span class="keywordflow">else</span> {
<a name="l01558"></a>01558                mkloops.insert(took);
<a name="l01559"></a>01559                std::vector&lt;SgGraphNode*&gt; lptemp;
<a name="l01560"></a>01560                lptemp.clear();
<a name="l01561"></a>01561                lptemp.push_back(took);
<a name="l01562"></a>01562                <span class="keywordflow">while</span> (path.back() != took) {
<a name="l01563"></a>01563                    
<a name="l01564"></a>01564                    path.pop_back();
<a name="l01565"></a>01565                   
<a name="l01566"></a>01566                    lptemp.push_back(path.back());
<a name="l01567"></a>01567                    
<a name="l01568"></a>01568                }
<a name="l01569"></a>01569                (mkloopmap[took]).insert(lptemp);
<a name="l01570"></a>01570 <span class="comment">/*</span>
<a name="l01571"></a>01571 <span class="comment">               if (lptemp.size() &gt; 1) {</span>
<a name="l01572"></a>01572 <span class="comment">               if (find(looppaths.begin(), looppaths.end(), lptemp) == looppaths.end() &amp;&amp; find(lptemp.begin(), lptemp.end(), st) == lptemp.end() &amp;&amp; find(lptemp.begin(), lptemp.end(), endnode) == lptemp.end()) {</span>
<a name="l01573"></a>01573 <span class="comment">                   looppaths.push_back(lptemp);</span>
<a name="l01574"></a>01574 <span class="comment">                   loopnum++;</span>
<a name="l01575"></a>01575 <span class="comment">                   for (unsigned int i = 0; i &lt; lptemp.size(); i++) {</span>
<a name="l01576"></a>01576 <span class="comment">                       loopNumMap[lptemp[i]] = loopnum;</span>
<a name="l01577"></a>01577 <span class="comment">                   }</span>
<a name="l01578"></a>01578 <span class="comment">               }</span>
<a name="l01579"></a>01579 <span class="comment">               }</span>
<a name="l01580"></a>01580 <span class="comment">*/</span>
<a name="l01581"></a>01581                path.push_back(took);
<a name="l01582"></a>01582                currn = path.back();
<a name="l01583"></a>01583                mkpath.push_back(took);
<a name="l01584"></a>01584            }
<a name="l01585"></a>01585            
<a name="l01586"></a>01586                
<a name="l01587"></a>01587 }
<a name="l01588"></a>01588            <span class="keywordflow">return</span>;
<a name="l01589"></a>01589 }
<a name="l01590"></a>01590 
<a name="l01591"></a>01591 <span class="comment">//not currently useful</span>
<a name="l01592"></a>01592 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType&gt;
<a name="l01593"></a>01593 SynthesizedAttributeType
<a name="l01594"></a>01594 <a class="code" href="classSgGraphTraversal.html#a518fd34370e6be9c357524280421d7e9">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</a>
<a name="l01595"></a>01595 <a class="code" href="classSgGraphTraversal.html#a518fd34370e6be9c357524280421d7e9">defaultSynthesizedAttribute</a>(InheritedAttributeType inh)
<a name="l01596"></a>01596 {
<a name="l01597"></a>01597     SynthesizedAttributeType s = SynthesizedAttributeType();
<a name="l01598"></a>01598     <span class="keywordflow">return</span> s;
<a name="l01599"></a>01599 }
<a name="l01600"></a>01600 
<a name="l01601"></a>01601 
<a name="l01602"></a>01602 <span class="comment">//computes the order in which to evaluate the nodes in nodal analysis so that you don&#39;t evaluate a node before you evaluate its parents</span>
<a name="l01603"></a>01603 
<a name="l01604"></a>01604 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType&gt;
<a name="l01605"></a>01605 <span class="keywordtype">void</span>
<a name="l01606"></a>01606 <a class="code" href="classSgGraphTraversal.html#ae984130d098c298843f480cd7a818542" title="This is the function that is used by the user directly to start the algorithm.">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</a>
<a name="l01607"></a><a class="code" href="classSgGraphTraversal.html#a94e0f96cac1bcaa3015e092a96130c5b">01607</a> <a class="code" href="classSgGraphTraversal.html#ae984130d098c298843f480cd7a818542" title="This is the function that is used by the user directly to start the algorithm.">computeOrder</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* endnode) {
<a name="l01608"></a>01608     std::map&lt;SgGraphNode*, int&gt; incomputables;
<a name="l01609"></a>01609     std::set&lt;SgGraphNode*&gt; lpposs;
<a name="l01610"></a>01610     <span class="comment">//std::set&lt;SgGraphNode*&gt; lps;</span>
<a name="l01611"></a>01611     <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* currn;
<a name="l01612"></a>01612     currn = n;
<a name="l01613"></a>01613     <span class="keywordtype">int</span> orders = 0; 
<a name="l01614"></a>01614     <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l01615"></a>01615         <span class="keywordflow">if</span> (orders % 10000 == 0) {
<a name="l01616"></a>01616             std::cout &lt;&lt; <span class="stringliteral">&quot;orders: &quot;</span> &lt;&lt; orders &lt;&lt; std::endl;
<a name="l01617"></a>01617         }
<a name="l01618"></a>01618         orders++;
<a name="l01619"></a>01619         <span class="keywordflow">if</span> (currn == endnode) {
<a name="l01620"></a>01620         }
<a name="l01621"></a>01621         <span class="keywordflow">if</span> (computable(g, currn) || currn == n) {
<a name="l01622"></a>01622             <span class="keywordtype">int</span> mp;
<a name="l01623"></a>01623             <span class="keywordflow">if</span> (oVals.find(currn) == oVals.end()) {
<a name="l01624"></a>01624                  oVals[currn] = currm++;
<a name="l01625"></a>01625                  iVals[currm++] = currn;
<a name="l01626"></a>01626                  currm += 1;
<a name="l01627"></a>01627             }
<a name="l01628"></a>01628             <span class="keywordflow">if</span> (currn == endnode) {
<a name="l01629"></a>01629                 
<a name="l01630"></a>01630                 <span class="keywordflow">break</span>;
<a name="l01631"></a>01631             }
<a name="l01632"></a>01632             std::pair&lt;bool, SgGraphNode*&gt; pbs = getNextChild(g, currn);
<a name="l01633"></a>01633             computedNodes.insert(currn);
<a name="l01634"></a>01634             ROSE_ASSERT(pbs.first == <span class="keyword">true</span>);
<a name="l01635"></a>01635             currn = pbs.second;
<a name="l01636"></a>01636         }
<a name="l01637"></a>01637         <span class="keywordflow">else</span> {
<a name="l01638"></a>01638             std::pair&lt;bool, SgGraphNode*&gt; pbp = getNextPar(g, currn);
<a name="l01639"></a>01639             ROSE_ASSERT(pbp.first == <span class="keyword">true</span>);
<a name="l01640"></a>01640             currn = pbp.second;
<a name="l01641"></a>01641             
<a name="l01642"></a>01642         }
<a name="l01643"></a>01643         
<a name="l01644"></a>01644     }
<a name="l01645"></a>01645     std::cout &lt;&lt; <span class="stringliteral">&quot;required orders&quot;</span> &lt;&lt; orders &lt;&lt; std::endl;
<a name="l01646"></a>01646     std::cout &lt;&lt; <span class="stringliteral">&quot;incomputables.size() &quot;</span> &lt;&lt; incomputables.size() &lt;&lt; std::endl;
<a name="l01647"></a>01647 }
<a name="l01648"></a>01648 
<a name="l01649"></a>01649 <span class="comment">//simple fucntion to check the computability under nodal analysis</span>
<a name="l01650"></a>01650 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType&gt;
<a name="l01651"></a>01651 <span class="keywordtype">bool</span>
<a name="l01652"></a>01652 <a class="code" href="classSgGraphTraversal.html#aea7df8b5b0fbc8f50e5e328634b24137" title="Checks whether or not the node can be computed for InheritedAttribute evaluation.">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</a>
<a name="l01653"></a><a class="code" href="classSgGraphTraversal.html#a946ed53b9c73ba7e4478f5103159b4a4">01653</a> <a class="code" href="classSgGraphTraversal.html#aea7df8b5b0fbc8f50e5e328634b24137" title="Checks whether or not the node can be computed for InheritedAttribute evaluation.">computable</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n) {
<a name="l01654"></a>01654     <span class="keywordflow">if</span> (computedNodes.find(n) != computedNodes.end()) {
<a name="l01655"></a>01655         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01656"></a>01656     }
<a name="l01657"></a>01657     std::set&lt;SgDirectedGraphEdge*&gt; ed = g-&gt;<a class="code" href="classSgIncidenceDirectedGraph.html#a109c80348472be5c09a0d9b9bcc2d9a1">computeEdgeSetIn</a>(n);
<a name="l01658"></a>01658     <span class="keywordtype">bool</span> comp = <span class="keyword">true</span>;
<a name="l01659"></a>01659     <span class="keywordflow">for</span> (std::set&lt;SgDirectedGraphEdge*&gt;::iterator i = ed.begin(); i != ed.end(); i++) {
<a name="l01660"></a>01660         <span class="keywordflow">if</span> (oVals.find((*i)-&gt;get_from()) == oVals.end() &amp;&amp; nullEdgesOrdered.find(*i) == nullEdgesOrdered.end()) {
<a name="l01661"></a>01661             comp = <span class="keyword">false</span>;
<a name="l01662"></a>01662         }
<a name="l01663"></a>01663     }
<a name="l01664"></a>01664     <span class="keywordflow">return</span> comp;
<a name="l01665"></a>01665 }
<a name="l01666"></a>01666 
<a name="l01667"></a>01667 
<a name="l01668"></a>01668 <span class="comment">//computes the inherited attribute values in nodal analysis</span>
<a name="l01669"></a>01669 
<a name="l01670"></a>01670 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType&gt;
<a name="l01671"></a>01671 <span class="keywordtype">void</span>
<a name="l01672"></a>01672 <a class="code" href="classSgGraphTraversal.html#ac025d6d43427e39209560ec3ac1e8833" title="computes the InheritedAttribute values on each of the nodes">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</a>
<a name="l01673"></a><a class="code" href="classSgGraphTraversal.html#a0e548c69116738a72c2879352a47bed1">01673</a> <a class="code" href="classSgGraphTraversal.html#ac025d6d43427e39209560ec3ac1e8833" title="computes the InheritedAttribute values on each of the nodes">computeInheritedOrdered</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n) {
<a name="l01674"></a>01674     <span class="keywordtype">int</span> runs = 0;
<a name="l01675"></a>01675 <span class="comment">//    std::ofstream mf;</span>
<a name="l01676"></a>01676 <span class="comment">//    mf.open(&quot;analysis.dot&quot;);</span>
<a name="l01677"></a>01677 <span class="comment">//    mf &lt;&lt; &quot;digraph defaultName { \n&quot;;</span>
<a name="l01678"></a>01678     <span class="keywordflow">for</span> (std::map&lt;int, SgGraphNode*&gt;::iterator i = iVals.begin(); i != iVals.end(); i++) {
<a name="l01679"></a>01679         runs++;
<a name="l01680"></a>01680         ROSE_ASSERT(canEval(g, (*i).second));
<a name="l01681"></a>01681         setPathVal(g, n);
<a name="l01682"></a>01682         <span class="comment">//printNodePlusEdgesForAnalysis(g, (*i).second, loopNumMap[(*i).second], pathValMap[(*i).second], mf);</span>
<a name="l01683"></a>01683         evalNodeOrdered(g, (*i).second);
<a name="l01684"></a>01684     }
<a name="l01685"></a>01685 }
<a name="l01686"></a>01686 
<a name="l01687"></a>01687 <span class="comment">//checks to see if evaluation is possible under nodal analysis</span>
<a name="l01688"></a>01688 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType&gt;
<a name="l01689"></a>01689 <span class="keywordtype">bool</span>
<a name="l01690"></a>01690 <a class="code" href="classSgGraphTraversal.html#abb4e5a24cad4e13c6e040df8ae60ba9b" title="Checks whether or not the node can be evaluated (deprecated)">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</a>
<a name="l01691"></a><a class="code" href="classSgGraphTraversal.html#ad3c59f14518d908cdac2e1ada7ae74e2">01691</a> <a class="code" href="classSgGraphTraversal.html#abb4e5a24cad4e13c6e040df8ae60ba9b" title="Checks whether or not the node can be evaluated (deprecated)">canEval</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n) {
<a name="l01692"></a>01692     <span class="keywordtype">bool</span> evaled = <span class="keyword">true</span>;
<a name="l01693"></a>01693     <span class="keywordflow">if</span> (inhVals.find(n) == inhVals.end()) {
<a name="l01694"></a>01694     std::set&lt;SgDirectedGraphEdge*&gt; ins = g-&gt;<a class="code" href="classSgIncidenceDirectedGraph.html#a109c80348472be5c09a0d9b9bcc2d9a1">computeEdgeSetIn</a>(n);
<a name="l01695"></a>01695     <span class="keywordflow">for</span> (std::set&lt;SgDirectedGraphEdge*&gt;::iterator i = ins.begin(); i != ins.end(); i++) {
<a name="l01696"></a>01696         <span class="keywordflow">if</span> (inhVals.find((*i)-&gt;get_from()) == inhVals.end() &amp;&amp; nullEdgesOrdered.find(*i) == nullEdgesOrdered.end()) {
<a name="l01697"></a>01697             evaled = <span class="keyword">false</span>;
<a name="l01698"></a>01698         }
<a name="l01699"></a>01699     }
<a name="l01700"></a>01700     }
<a name="l01701"></a>01701     <span class="keywordflow">return</span> evaled;
<a name="l01702"></a>01702 }
<a name="l01703"></a>01703 
<a name="l01704"></a>01704 
<a name="l01705"></a>01705 <span class="comment">//actually does the evaluation</span>
<a name="l01706"></a>01706 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType&gt;
<a name="l01707"></a>01707 <span class="keywordtype">void</span>
<a name="l01708"></a>01708 <a class="code" href="classSgGraphTraversal.html#adb0bdc7cf8fe6c427f1aeb748a20ba33" title="evaluates the node directly, used within computeInheritedOrdered SgGraphTraversal::evalNodeOrdered In...">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</a>
<a name="l01709"></a><a class="code" href="classSgGraphTraversal.html#a20868f8ed7326c1fa9c2d3afdd87b4c7">01709</a> <a class="code" href="classSgGraphTraversal.html#adb0bdc7cf8fe6c427f1aeb748a20ba33" title="evaluates the node directly, used within computeInheritedOrdered SgGraphTraversal::evalNodeOrdered In...">evalNodeOrdered</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n) {
<a name="l01710"></a>01710     <span class="keywordflow">if</span> (inhVals.find(n) != inhVals.end()) {
<a name="l01711"></a>01711         <span class="keywordflow">return</span>;
<a name="l01712"></a>01712     }
<a name="l01713"></a>01713     std::set&lt;SgDirectedGraphEdge*&gt; par = g-&gt;<a class="code" href="classSgIncidenceDirectedGraph.html#a109c80348472be5c09a0d9b9bcc2d9a1">computeEdgeSetIn</a>(n);
<a name="l01714"></a>01714     std::vector&lt;InheritedAttributeType&gt; inh;
<a name="l01715"></a>01715     <span class="keywordflow">for</span> (std::set&lt;SgDirectedGraphEdge*&gt;::iterator i = par.begin(); i != par.end(); i++) {
<a name="l01716"></a>01716         <span class="keywordflow">if</span> (inhVals.find((*i)-&gt;get_from()) != inhVals.end()) {
<a name="l01717"></a>01717             inh.push_back(inhVals[(*i)-&gt;get_from()]);
<a name="l01718"></a>01718         }
<a name="l01719"></a>01719     }
<a name="l01720"></a>01720     
<a name="l01721"></a>01721     <span class="keywordflow">if</span> (n != st || inh.size() &gt; 0) {
<a name="l01722"></a>01722         InheritedAttributeType inhX;
<a name="l01723"></a>01723         inhX = evaluateInheritedAttribute(n, inh);
<a name="l01724"></a>01724         inhVals[n] = inhX;
<a name="l01725"></a>01725     }
<a name="l01726"></a>01726     <span class="comment">//std::cout &lt;&lt; &quot;num of inhVals: &quot; &lt;&lt; inh.size() &lt;&lt; std::endl;</span>
<a name="l01727"></a>01727     
<a name="l01728"></a>01728 }
<a name="l01729"></a>01729 
<a name="l01730"></a>01730 
<a name="l01731"></a>01731 <span class="comment">//debugging function, currently not useful for the end user</span>
<a name="l01732"></a>01732 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType&gt;
<a name="l01733"></a>01733 <span class="keywordtype">void</span>
<a name="l01734"></a>01734 <a class="code" href="classSgGraphTraversal.html#a446d0ed49b6ba81dbc0b1626aac5d6bd">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</a>
<a name="l01735"></a><a class="code" href="classSgGraphTraversal.html#a446d0ed49b6ba81dbc0b1626aac5d6bd">01735</a> <a class="code" href="classSgGraphTraversal.html#a446d0ed49b6ba81dbc0b1626aac5d6bd">setPathVal</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* currn) {
<a name="l01736"></a>01736        <span class="keywordflow">if</span> (pathValMap.find(currn) != pathValMap.end()) {
<a name="l01737"></a>01737            <span class="keywordflow">return</span>;
<a name="l01738"></a>01738        }
<a name="l01739"></a>01739        std::set&lt;SgDirectedGraphEdge*&gt; ined = g-&gt;<a class="code" href="classSgIncidenceDirectedGraph.html#a109c80348472be5c09a0d9b9bcc2d9a1">computeEdgeSetIn</a>(currn);
<a name="l01740"></a>01740        <span class="keywordtype">int</span> tmppathcount = 0;
<a name="l01741"></a>01741        <span class="keywordflow">for</span> (std::set&lt;SgDirectedGraphEdge*&gt;::iterator i = ined.begin(); i != ined.end(); i++) {
<a name="l01742"></a>01742             ROSE_ASSERT(pathValMap.find((*i)-&gt;get_from()) != pathValMap.end() <span class="comment">/*|| nullEdgesOrdered.find(*i) != nullEdgesOrdered.end()*/</span>);
<a name="l01743"></a>01743             <span class="comment">//if (nullEdgesOrdered.find(*i) != nullEdgesOrdered.end()) {</span>
<a name="l01744"></a>01744             <span class="comment">//    pathValMap[(*i)-&gt;get_from()] = 0;</span>
<a name="l01745"></a>01745            <span class="comment">// }</span>
<a name="l01746"></a>01746             <span class="keywordtype">int</span> pv = pathValMap[(*i)-&gt;get_from()];
<a name="l01747"></a>01747             <span class="keywordflow">if</span> (pv != 0) {
<a name="l01748"></a>01748             tmppathcount += pv;
<a name="l01749"></a>01749             }
<a name="l01750"></a>01750         }
<a name="l01751"></a>01751         pathValMap[currn] = tmppathcount;
<a name="l01752"></a>01752         <span class="keywordflow">return</span>;
<a name="l01753"></a>01753     }
<a name="l01754"></a>01754 
<a name="l01755"></a>01755 <span class="comment">//computes the next child to be analyzed in nodal analysis</span>
<a name="l01756"></a>01756 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType&gt;
<a name="l01757"></a>01757 std::pair&lt;bool, SgGraphNode*&gt;
<a name="l01758"></a>01758 <a class="code" href="classSgGraphTraversal.html#a202ad77e0c9f4edfe12b1e348d811c88" title="computes the next child node to evaluate, used in computing inheritedAttributes, picks the child that...">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</a>
<a name="l01759"></a><a class="code" href="classSgGraphTraversal.html#afb0411af34796f1a97854134fe0a22f7">01759</a> <a class="code" href="classSgGraphTraversal.html#a202ad77e0c9f4edfe12b1e348d811c88" title="computes the next child node to evaluate, used in computing inheritedAttributes, picks the child that...">getNextChild</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n) {
<a name="l01760"></a>01760     <span class="keywordtype">bool</span> nullPoss = <span class="keyword">false</span>;
<a name="l01761"></a>01761     <span class="comment">//std::cout &lt;&lt; &quot;nextChild&quot; &lt;&lt; std::endl;</span>
<a name="l01762"></a>01762     std::set&lt;SgDirectedGraphEdge*&gt; outs = g-&gt;<a class="code" href="classSgIncidenceDirectedGraph.html#af313470c8b7ba952134a8420ef425726">computeEdgeSetOut</a>(n);
<a name="l01763"></a>01763     <span class="comment">//std::cout &lt;&lt; &quot;outs.size(): &quot; &lt;&lt; outs.size() &lt;&lt; std::endl;</span>
<a name="l01764"></a>01764     <span class="comment">//std::cout &lt;&lt; &quot;outs: &quot; &lt;&lt; outs.size() &lt;&lt; std::endl;</span>
<a name="l01765"></a>01765     <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* nextNode;
<a name="l01766"></a>01766     <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* nullNode;
<a name="l01767"></a>01767     <span class="keywordtype">bool</span> completed = <span class="keyword">false</span>;
<a name="l01768"></a>01768     <span class="keywordtype">bool</span> completeNull = <span class="keyword">false</span>;
<a name="l01769"></a>01769     
<a name="l01770"></a>01770     <span class="keywordflow">for</span> (std::set&lt;SgDirectedGraphEdge*&gt;::iterator i = outs.begin(); i != outs.end(); i++) {
<a name="l01771"></a>01771 
<a name="l01772"></a>01772         <span class="keywordflow">if</span> (outs.size() == 1) {
<a name="l01773"></a>01773             nextNode = (*i)-&gt;get_to();
<a name="l01774"></a>01774             <span class="keywordflow">if</span> (nullEdgesOrdered.find(*i) != nullEdgesOrdered.end()) {
<a name="l01775"></a>01775                 nullNum++;
<a name="l01776"></a>01776             }
<a name="l01777"></a>01777             <span class="comment">//completedEdges.insert(*i);</span>
<a name="l01778"></a>01778             completed = <span class="keyword">true</span>;
<a name="l01779"></a>01779         }
<a name="l01780"></a>01780         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (completed == <span class="keyword">false</span> &amp;&amp; computedNodes.find((*i)-&gt;get_to()) == computedNodes.end()) {
<a name="l01781"></a>01781             completed = <span class="keyword">true</span>;
<a name="l01782"></a>01782             nextNode = (*i)-&gt;get_to();
<a name="l01783"></a>01783             <span class="keywordflow">if</span> (nullEdgesOrdered.find(*i) != nullEdgesOrdered.end()) {
<a name="l01784"></a>01784                 nullNum++;
<a name="l01785"></a>01785             }
<a name="l01786"></a>01786             completedEdgesOut.insert(*i);
<a name="l01787"></a>01787         }
<a name="l01788"></a>01788         
<a name="l01789"></a>01789             
<a name="l01790"></a>01790     }
<a name="l01791"></a>01791     std::pair&lt;bool, SgGraphNode*&gt; pr;
<a name="l01792"></a>01792     ROSE_ASSERT (completed == <span class="keyword">true</span> || completeNull == <span class="keyword">true</span>);
<a name="l01793"></a>01793     <span class="keywordflow">if</span> (completed == <span class="keyword">true</span>) {
<a name="l01794"></a>01794         pr.first = completed;
<a name="l01795"></a>01795         pr.second = nextNode;
<a name="l01796"></a>01796         <span class="keywordflow">return</span> pr;
<a name="l01797"></a>01797     }
<a name="l01798"></a>01798     <span class="keywordflow">else</span> {
<a name="l01799"></a>01799         pr.first = <span class="keyword">true</span>;
<a name="l01800"></a>01800         pr.second = nullNode;
<a name="l01801"></a>01801         <span class="keywordflow">return</span> pr;
<a name="l01802"></a>01802     } 
<a name="l01803"></a>01803     
<a name="l01804"></a>01804 }
<a name="l01805"></a>01805 
<a name="l01806"></a>01806 <span class="comment">//computes the next parent to be analyzed in nodal analysis</span>
<a name="l01807"></a>01807 <span class="keyword">template</span> &lt;<span class="keyword">class</span> InheritedAttributeType, <span class="keyword">class</span> SynthesizedAttributeType&gt;
<a name="l01808"></a>01808 std::pair&lt;bool, SgGraphNode*&gt;
<a name="l01809"></a>01809 <a class="code" href="classSgGraphTraversal.html#a1dc4b927b3eb7781dc6a1adb9c5e884b" title="computes the next parent node to calculate similar to getNextChild">SgGraphTraversal&lt;InheritedAttributeType, SynthesizedAttributeType&gt;::</a>
<a name="l01810"></a><a class="code" href="classSgGraphTraversal.html#a59dcee0b21f300e4ed2df0876741271c">01810</a> <a class="code" href="classSgGraphTraversal.html#a1dc4b927b3eb7781dc6a1adb9c5e884b" title="computes the next parent node to calculate similar to getNextChild">getNextPar</a>(<a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g, <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n) {
<a name="l01811"></a>01811     std::set&lt;SgDirectedGraphEdge*&gt; ins = g-&gt;<a class="code" href="classSgIncidenceDirectedGraph.html#a109c80348472be5c09a0d9b9bcc2d9a1">computeEdgeSetIn</a>(n);
<a name="l01812"></a>01812     <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* nextPar;
<a name="l01813"></a>01813     <a class="code" href="classSgDirectedGraphEdge.html">SgDirectedGraphEdge</a>* nullEdgeO;
<a name="l01814"></a>01814     <span class="keywordtype">bool</span> completed = <span class="keyword">false</span>;
<a name="l01815"></a>01815     <span class="keywordtype">bool</span> completeNull = <span class="keyword">false</span>;
<a name="l01816"></a>01816     <span class="keywordflow">for</span> (std::set&lt;SgDirectedGraphEdge*&gt;::iterator i = ins.begin(); i != ins.end(); i++) {
<a name="l01817"></a>01817 
<a name="l01818"></a>01818         <span class="keywordflow">if</span> (ins.size() == 1 <span class="comment">/*&amp;&amp; completedEdges.find(*i) == completedEdges.end()*/</span>) {
<a name="l01819"></a>01819             completed = <span class="keyword">true</span>;
<a name="l01820"></a>01820             completedEdges.insert(*i);
<a name="l01821"></a>01821             nextPar = (*i)-&gt;get_from();
<a name="l01822"></a>01822         }
<a name="l01823"></a>01823 
<a name="l01824"></a>01824         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (completedEdges.find(*i) == completedEdges.end() &amp;&amp; completed == <span class="keyword">false</span>) {
<a name="l01825"></a>01825             completed = <span class="keyword">true</span>;
<a name="l01826"></a>01826             nextPar = (*i)-&gt;get_from();
<a name="l01827"></a>01827             completedEdges.insert(*i);
<a name="l01828"></a>01828         }
<a name="l01829"></a>01829 
<a name="l01830"></a>01830         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (completedEdges.find(*i) != completedEdges.end() &amp;&amp; computedNodes.find((*i)-&gt;get_from()) == computedNodes.end() &amp;&amp; completed == <span class="keyword">false</span> <span class="comment">/*&amp;&amp; nullEdgesOrdered.find(*i) == nullEdgesOrdered.end()*/</span>) {
<a name="l01831"></a>01831             completeNull = <span class="keyword">true</span>;
<a name="l01832"></a>01832             std::pair&lt;SgGraphNode*, SgGraphNode*&gt; lpp;
<a name="l01833"></a>01833             nextPar = n;
<a name="l01834"></a>01834             nullEdgesOrdered.insert(*i);
<a name="l01835"></a>01835             nullEdgesPaths++;
<a name="l01836"></a>01836             
<a name="l01837"></a>01837         }
<a name="l01838"></a>01838     }
<a name="l01839"></a>01839     ROSE_ASSERT(completed == <span class="keyword">true</span> || completeNull == <span class="keyword">true</span>);
<a name="l01840"></a>01840     std::pair&lt;bool, SgGraphNode*&gt; pr;
<a name="l01841"></a>01841     pr.first = completed;
<a name="l01842"></a>01842     pr.second = nextPar;
<a name="l01843"></a>01843 
<a name="l01844"></a>01844     <span class="keywordflow">if</span> (completeNull == <span class="keyword">true</span> &amp;&amp; completed == <span class="keyword">false</span>) {
<a name="l01845"></a>01845         pr.first = completeNull;
<a name="l01846"></a>01846         pr.second = nextPar;
<a name="l01847"></a>01847     }
<a name="l01848"></a>01848    
<a name="l01849"></a>01849     <span class="keywordflow">return</span> pr;
<a name="l01850"></a>01850 }
<a name="l01851"></a>01851  
<a name="l01852"></a>01852     
<a name="l01853"></a>01853 
<a name="l01854"></a>01854 
<a name="l01855"></a>01855 
<a name="l01856"></a>01856 
<a name="l01857"></a>01857 
<a name="l01858"></a>01858 
<a name="l01859"></a>01859  
<a name="l01860"></a>01860     
<a name="l01861"></a>01861 
<a name="l01862"></a>01862   
<a name="l01863"></a>01863         
<a name="l01864"></a>01864     
<a name="l01865"></a>01865             
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="graphProcessingSgIncGraph_8h.html">graphProcessingSgIncGraph.h</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Thu Dec 1 2011 16:31:43 for ROSE by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
