<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: Partitioner Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>Partitioner Class Reference</h1><!-- doxytag: class="Partitioner" --><code>#include &lt;<a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>&gt;</code>
<p>
Collaboration diagram for Partitioner:<p><center><img src="classPartitioner__coll__graph.png" border="0" usemap="#Partitioner__coll__map" alt="Collaboration graph"></center>
<map name="Partitioner__coll__map">
<area href="classDisassembler.html" shape="rect" coords="220,311,327,337" alt="">
<area href="classRegisterDictionary.html" shape="rect" coords="5,215,141,241" alt="">
<area href="structRTS__mutex__t.html" shape="rect" coords="165,215,269,241" alt="">
<area href="classPartitioner_1_1CodeCriteria.html" shape="rect" coords="141,103,315,129" alt="">
<area href="classPartitioner_1_1RegionStats.html" shape="rect" coords="339,103,507,129" alt="">
<area href="classMemoryMap.html" shape="rect" coords="532,103,631,129" alt="">
<area href="classRangeMap.html" shape="rect" coords="511,7,652,33" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classPartitioner-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Partitions instructions into basic blocks and functions. 
<p>
The <a class="el" href="classPartitioner.html">Partitioner</a> classes are responsible for assigning instructions to basic blocks, and basic blocks to functions. A "basic block" is a sequence of instructions where control flow enters at only the first instruction and exits at only the last instruction. The definition can be further restricted to include only those instructions that are contiguous and non-overlapping in virtual memory by setting the <a class="el" href="classPartitioner.html#07ab675418fbe36332333be50b0b78b8">set_allow_discontiguous_blocks()</a> property to false. Every instruction belongs to exactly one basic block. A "function" is a collection of basic blocks having a single entry point. Every basic block belongs to exactly one function. If <a class="el" href="namespaceROSE.html">ROSE</a> cannot determine what function a block belongs to, it will be placed in a special function created for the purpose of holding such blocks.<p>
A partitioner can operate in one of two modes: it can use a list of instructions that has been previously disassembled (a.k.a. "passive mode"), or it can drive a <a class="el" href="classDisassembler.html">Disassembler</a> to obtain instructions as necessary (a.k.a. "active mode"). Each mode has its benefits:<p>
<ul>
<li>
Active mode disassembles only what is actually necessary. Although the disassembler is recursive and can follow the flow of control, its analyses are not as thorough or robust as the partitioner. Therfore, in order to be sure that the partitioner has all the instructions it needs in this mode, the disassembler is usually run in a very aggressive mode. In the end, much of what was disassembled is then thrown away. </li>
<li>
Passive mode allows the partitioner to search for instruction sequences in parts of the specimen address space that the partitioner otherwise would not have disassembled in active mode. Thus, passive mode can detect function entry addresses by searching for function prologues such as the common x86 pair "push ebp; mov ebp, esp". </li>
<li>
Passive mode delegates all disassembling to some other software layer. This gives the user full control over the disassembly process before partitioning even starts. </li>
<li>
Passive mode can be used to force the partitioner to omit certain address ranges or instruction sequences from consideration. For example, one could disassemble certain parts of program while skipping over instructions that were inserted maliciously in order to thwart disassembly. On the other hand a similar effect can be had by manipulating the <a class="el" href="classMemoryMap.html">MemoryMap</a> used by an active partitioner. The case where this doesn't work is when two instruction streams overlap and we want to exclude one of them from consideration. </li>
</ul>
<p>
The partitioner organizes instructions into basic blocks by starting at a particular instruction and then looking at its set of successor addresses. Successor addresses are edges of the eventual control-flow graph (CFG) that are calculated using instruction semantics, and are available to the end user via SgAsmBlock::get_cached_successors(). It's not always possible to statically determine the complete set of successors; in this case, get_cached_successors() will return at least one successor whose isAmbiguous() property is true. Because <a class="el" href="namespaceROSE.html">ROSE</a> performs semantic analysis over all instructions of the basic block (and occassionally related blocks), it can sometimes determine that instructions that are usually considered to be conditional branches are, in fact, unconditional (e.g., a PUSH followed by a RET; or a CALL to a block that discards the return address). <a class="el" href="namespaceROSE.html">ROSE</a> includes unconditional branch instructions and their targets within the same basic block (provided no other CFG edge comes into the middle of the block).<p>
The partitioner organizes basic blocks into functions in three phases, all three of which can be run by a single call to the partitioner() method. The first phase considers all disassembled instructions and other available information such as symbol tables and tries to determine which addresses are entry points for functions. For instance, if the symbol table contains function symbols, then the address stored in the symbol table is assumed to be the entry point of a function. <a class="el" href="namespaceROSE.html">ROSE</a> has a variety of these "pre-cfg" detection methods which can be enabled/disabled at runtime with the <a class="el" href="classPartitioner.html#e52ab7e0fa20592ae95f858404b3234b">set_search()</a> method. <a class="el" href="namespaceROSE.html">ROSE</a> also supports user-defined search methods that can be registered with <a class="el" href="classPartitioner.html#fc4d3b064e80e0124eda08827c9cfa07">add_function_detector()</a>. The three phases are initialized and influenced by the contents of an optional configuration file specified with the <a class="el" href="classPartitioner.html#7adb0e1cb0359b14d928ad1d7ffd0a03">load_config()</a> method.<p>
The second phase for assigning blocks to functions is via analysis of the control-flow graph. In a nutshell, <a class="el" href="namespaceROSE.html">ROSE</a> traverses the CFG starting with the entry address of each function, adding blocks to the function as it goes. When it detects that a block has edges coming in from two different functions, it creates a new function whose entry point is that block (see definition of "function" above; a function can only have one entry point).<p>
The third and final phase, called "post-cfg", makes final adjustments, such as adding <a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> objects for no-op or zero padding occuring between the previously detected functions. This could also be user-extended to add blocks to functions that <a class="el" href="namespaceROSE.html">ROSE</a> detected during CFG analysis (such as unreferenced basic blocks, no-ops, etc. that occur within the extent of a function.)<p>
By default, <a class="el" href="namespaceROSE.html">ROSE</a> constructs a <a class="el" href="classPartitioner.html">Partitioner</a> to use for partitioning instructions of binary files during <a class="el" href="utility__functions_8h.html#48fd701ae63655987f71cf749dd996ed">frontend()</a> parsing (this happens in <a class="el" href="classDisassembler.html#fd020ba343b083b9eccd75562a43d2be">Disassembler::disassembleInterpretation()</a>). This Partitioner's settings are controlled by two command-line switches whose documentation can be seen by running any <a class="el" href="namespaceROSE.html">ROSE</a> program with the --help switch. These command-line switches operate by setting property values in the <a class="el" href="classSgFile.html">SgFile</a> node and then transferring them to the <a class="el" href="classPartitioner.html">Partitioner</a> when the <a class="el" href="classPartitioner.html">Partitioner</a> is constructed. <ul>
<li>
-rose:partitioner_search initializes the detection methods by calling <a class="el" href="classPartitioner.html#e52ab7e0fa20592ae95f858404b3234b">set_search()</a>, and <a class="el" href="classPartitioner.html#63758ffe8d586886ebfcdb2f69c7d107">parse_switches()</a> </li>
<li>
-rose:partitioner_config specifies an IPD file by calling <a class="el" href="classPartitioner.html#7adb0e1cb0359b14d928ad1d7ffd0a03">load_config()</a>. </li>
</ul>
<p>
The results of block and function detection are stored in the <a class="el" href="classPartitioner.html">Partitioner</a> object itself. One usually retrieves this information via a call to the <a class="el" href="classPartitioner.html#d94b1f74e750728b71d1726330786506">build_ast()</a> method, which constructs a <a class="el" href="namespaceROSE.html">ROSE</a> AST. Any instructions that were not assigned to blocks of a function can be optionally discarded (see the <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c617301fe6a598b9c4afbde0aebcc8ad5">SgAsmFunction::FUNC_LEFTOVERS</a> bit of <a class="el" href="classPartitioner.html#e52ab7e0fa20592ae95f858404b3234b">set_search()</a>, or the "leftovers" parameter of the "-rose:partitioner_search" command-line switch).<p>
The <a class="el" href="classPartitioner.html">Partitioner</a> class can easily be subclassed by the user. Some of the <a class="el" href="classDisassembler.html">Disassembler</a> methods automatically call <a class="el" href="classPartitioner.html#d8d4292001cbf0490676f8bc148c1a24">Partitioner::partition()</a>, using either a temporarily instantiated <a class="el" href="classPartitioner.html">Partitioner</a>, or a partitioner provided by the user.<p>
NOTE: Some of the methods used by the partitioner are more complex than one might originally imagine. The CFG analysis, for instance, must contend with the fact that the graph nodes (basic blocks) are changing as new edges are discovered (e.g., splitting a large block when we discover an edge coming into the middle). Changes to the nodes result in changes to the edges (e.g., a PUSH/RET pair is an unconditional branch to a known target, but if the block were to be divided then the RET becomes a branch to an unknown address (i.e., the edge disappears).<p>
Another complexity is that the CFG analysis must avoid circular logic. Consider the following instructions: <div class="fragment"><pre class="fragment">     1: PUSH 2
     2: NOP
     3: RET
</pre></div><p>
When all three instructions are in the same basic block, as they are initially, the RET is an unconditional branch to the NOP. This splits the block and the RET no longer has known successors (according to block semantic analysis). So the edge from the RET to the NOP disappears and the three instructions would coalesce back into a single basic block. In this situation, <a class="el" href="namespaceROSE.html">ROSE</a> keeps these three instructions as two basic blocks with no CFG edges to the second block.<p>
A third complexity is that the <a class="el" href="classPartitioner.html">Partitioner</a> cannot rely on the usual <a class="el" href="namespaceROSE.html">ROSE</a> AST traversal mechanisms because it must perform its work before the AST is created. However, the <a class="el" href="classPartitioner.html">Partitioner</a> benefits from this situation by being able to use data structures and methods that are optimized for performance.<p>
A final complexity, is that the <a class="el" href="classDisassembler.html">Disassembler</a> and <a class="el" href="classPartitioner.html">Partitioner</a> classes are both designed to be useful in a general way, and independent of each other. These two classes can be called even when the user doesn't have an AST. For instance, the tests/roseTests/binaryTests/disassembleBuffer.C is an example of how the <a class="el" href="classDisassembler.html">Disassembler</a> and <a class="el" href="classPartitioner.html">Partitioner</a> classes can be used to disassemble and partition a buffer of instructions obtained outside of ROSE's binary file parsing mechanisms. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00111">111</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map&lt; <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>,<br>
 <a class="el" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#9a75d765cbfecc297f7d47063095a3c5">BasicBlockStarts</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Map of basic block starting addresses.  <a href="#9a75d765cbfecc297f7d47063095a3c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map&lt; <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>,<br>
 <a class="el" href="structPartitioner_1_1FunctionStart.html">FunctionStart</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#b8bf5254df78bd41a374776dc956c0b0">FunctionStarts</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Map describing the starting address of each known function.  <a href="#b8bf5254df78bd41a374776dc956c0b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classRangeMap.html">RangeMap</a>&lt; <a class="el" href="classRange.html">Extent</a>,<br>
 <a class="el" href="classPartitioner_1_1FunctionRangeMapValue.html">FunctionRangeMapValue</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#fa61b430928023cd27ec0227c5a45f4f">FunctionRangeMap</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classRange.html">Range</a> map associating addresses with functions.  <a href="#fa61b430928023cd27ec0227c5a45f4f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classRangeMap.html">RangeMap</a>&lt; <a class="el" href="classRange.html">Extent</a>,<br>
 <a class="el" href="classPartitioner_1_1DataRangeMapValue.html">DataRangeMapValue</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#908ae714b9d63d22397ba1d44c0a131e">DataRangeMap</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classRange.html">Range</a> map associating addresses with functions.  <a href="#908ae714b9d63d22397ba1d44c0a131e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classROSE__Callbacks_1_1List.html">ROSE_Callbacks::List</a>&lt;<br>
 <a class="el" href="classPartitioner_1_1InsnRangeCallback.html">InsnRangeCallback</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#d3746ef9608772aa918629792f10b2b9">InsnRangeCallbacks</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classROSE__Callbacks_1_1List.html">ROSE_Callbacks::List</a>&lt;<br>
 <a class="el" href="classPartitioner_1_1ByteRangeCallback.html">ByteRangeCallback</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#28a95ae28faba1e516a9e230258ee7ee">ByteRangeCallbacks</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPartitioner.html#9a75d765cbfecc297f7d47063095a3c5">BasicBlockStarts</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#4812db8f83f8858ae85b382cc3a6acdc">detectBasicBlocks</a> (const <a class="el" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">Disassembler::InstructionMap</a> &amp;) const __attribute__((deprecated))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the beginnings of basic blocks based on instruction type and call targets.  <a href="#4812db8f83f8858ae85b382cc3a6acdc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPartitioner.html#b8bf5254df78bd41a374776dc956c0b0">FunctionStarts</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#2661469599426a48867a62e649c3585b">detectFunctions</a> (<a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *, const <a class="el" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">Disassembler::InstructionMap</a> &amp;<a class="el" href="classPartitioner.html#f9d5d92a9d9ca6a35ade7c5b3906ab97">insns</a>, <a class="el" href="classPartitioner.html#9a75d765cbfecc297f7d47063095a3c5">BasicBlockStarts</a> &amp;bb_starts) const __attribute__((deprecated))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a list of the currently defined functions.  <a href="#2661469599426a48867a62e649c3585b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#b3788db43d9594c28b201255991e85c2">Partitioner</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#8adefe825a9988129017f650bac676d4">~Partitioner</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#e52ab7e0fa20592ae95f858404b3234b">set_search</a> (unsigned heuristics)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the set of heuristics used by the partitioner.  <a href="#e52ab7e0fa20592ae95f858404b3234b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#27dadf58c669d89a6ddb3993075ade12">get_search</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a bit mask of <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c">SgAsmFunction::FunctionReason</a> bits indicating which heuristics would be used by the partitioner.  <a href="#27dadf58c669d89a6ddb3993075ade12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#07ab675418fbe36332333be50b0b78b8">set_allow_discontiguous_blocks</a> (bool b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turns on/off the allowing of discontiguous basic blocks.  <a href="#07ab675418fbe36332333be50b0b78b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#7b2621f78594a4269ddf84ac5b038705">get_allow_discontiguous_blocks</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an indication of whether discontiguous blocks are allowed.  <a href="#7b2621f78594a4269ddf84ac5b038705"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#3779f2493e75745eb5a0d8abf8317316">set_debug</a> (FILE *f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends diagnostics to the specified output stream.  <a href="#3779f2493e75745eb5a0d8abf8317316"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">FILE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#878a062caa7908af34df84d4bedae71e">get_debug</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the file currently used for debugging; null implies no debugging.  <a href="#878a062caa7908af34df84d4bedae71e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#072171925925389189b7206fd5897f3d">set_progress_reporting</a> (FILE *, unsigned min_interval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set progress reporting properties.  <a href="#072171925925389189b7206fd5897f3d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#fc4d3b064e80e0124eda08827c9cfa07">add_function_detector</a> (<a class="el" href="classPartitioner.html#da9ff0ad1ed799e3d44df2c1958e9303">FunctionDetector</a> f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a user-defined function detector to this partitioner.  <a href="#fc4d3b064e80e0124eda08827c9cfa07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#d8d4292001cbf0490676f8bc148c1a24">partition</a> (<a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *, const <a class="el" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">Disassembler::InstructionMap</a> &amp;, <a class="el" href="classMemoryMap.html">MemoryMap</a> *mmap=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Top-level function to run the partitioner on some instructions and build an AST.  <a href="#d8d4292001cbf0490676f8bc148c1a24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#ec5dbc10e96f8e3d26f58294945c2f9d">partition</a> (<a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *, <a class="el" href="classDisassembler.html">Disassembler</a> *, <a class="el" href="classMemoryMap.html">MemoryMap</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Top-level function to run the partitioner, calling the specified disassembler as necessary to generate instructions.  <a href="#ec5dbc10e96f8e3d26f58294945c2f9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#d64a57bb09ffe9557d1ad51f2ca30bf8">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset partitioner to initial conditions by discarding all instructions, basic blocks, functions, and configuration file settings and definitions.  <a href="#d64a57bb09ffe9557d1ad51f2ca30bf8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#7adb0e1cb0359b14d928ad1d7ffd0a03">load_config</a> (const std::string &amp;filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads the specified configuration file.  <a href="#7adb0e1cb0359b14d928ad1d7ffd0a03"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#33a895f0f8724262d24404a67be98a2f">add_instructions</a> (const <a class="el" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">Disassembler::InstructionMap</a> &amp;<a class="el" href="classPartitioner.html#f9d5d92a9d9ca6a35ade7c5b3906ab97">insns</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds additional instructions to be processed.  <a href="#33a895f0f8724262d24404a67be98a2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">Disassembler::InstructionMap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#45a9d059b28d95033aa343fd4689ac0e">get_instructions</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the list of all instructions.  <a href="#45a9d059b28d95033aa343fd4689ac0e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classDisassembler.html#30c51578d70dfc05fb46047867ceadcd">Disassembler::BadMap</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#72f6b3bb0baf5d2978b27174626ad1b4">get_disassembler_errors</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the list of disassembler errors.  <a href="#72f6b3bb0baf5d2978b27174626ad1b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#f993c26936e910eedaa5b433a74e70b3">clear_disassembler_errors</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears errors from the disassembler.  <a href="#f993c26936e910eedaa5b433a74e70b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#1dcdd3e0993256cd5ed93fd4d178679f">find_instruction</a> (<a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>, bool create=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds an instruction at the specified address.  <a href="#1dcdd3e0993256cd5ed93fd4d178679f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#8b679c9a4b6fb7a7f4f45900d10819c0">discard</a> (<a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a> *, bool discard_entire_block=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drop an instruction from consideration.  <a href="#8b679c9a4b6fb7a7f4f45900d10819c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#1ea949dc4beeb1444894ed978931e7b2">discard</a> (<a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drop a basic block from the partitioner.  <a href="#1ea949dc4beeb1444894ed978931e7b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPartitioner_1_1Function.html">Function</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#91e9b8ad59e4657d6f3dbece95752a4e">add_function</a> (<a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> entry_va, unsigned reasons, std::string name=&quot;&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a new function definition to the partitioner.  <a href="#91e9b8ad59e4657d6f3dbece95752a4e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPartitioner_1_1Function.html">Function</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#e9238319a8257ac90435cce78d96dc9d">find_function</a> (<a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> entry_va)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks up a function by address.  <a href="#e9238319a8257ac90435cce78d96dc9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#d94b1f74e750728b71d1726330786506">build_ast</a> (<a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *interp=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds the AST describing all the functions.  <a href="#d94b1f74e750728b71d1726330786506"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#416452ab2d4ffc7df788c078421c4848">fixup_cfg_edges</a> (<a class="el" href="classSgNode.html">SgNode</a> *ast)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update control flow graph edge nodes.  <a href="#416452ab2d4ffc7df788c078421c4848"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#ea4ea9a5b5238c91b86b226fb04708c1">fixup_pointers</a> (<a class="el" href="classSgNode.html">SgNode</a> *ast, <a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *interp=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Updates pointers inside instructions.  <a href="#ea4ea9a5b5238c91b86b226fb04708c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPartitioner_1_1RegionStats.html">RegionStats</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#e28a2d008b984feffc35c4945b0cf496">new_region_stats</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new region statistics object.  <a href="#e28a2d008b984feffc35c4945b0cf496"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPartitioner_1_1RegionStats.html">RegionStats</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#b611787b2c6ef70f765031acde40fdd2">aggregate_statistics</a> (bool do_variance=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes aggregate statistics over all known functions.  <a href="#b611787b2c6ef70f765031acde40fdd2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#adaa21925ebc452fcac317509cfe84d9">clear_aggregate_statistics</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Causes the partitioner to forget statistics.  <a href="#adaa21925ebc452fcac317509cfe84d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#80a5af9330b230ed4d3819aa1e69b18d">is_code</a> (const <a class="el" href="classExtentMap.html">ExtentMap</a> &amp;region, double *raw_vote_ptr=NULL, std::ostream *<a class="el" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a>=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if a region contains code.  <a href="#80a5af9330b230ed4d3819aa1e69b18d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#3d11541835dec7b94d67c6a23db908cd">append</a> (<a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *, <a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an instruction to a basic block.  <a href="#3d11541835dec7b94d67c6a23db908cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#ba38c7356f1455b1eafdfdfdfba7ec80">append</a> (<a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *, <a class="el" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *, unsigned reasons)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Associate a data block with a basic block.  <a href="#ba38c7356f1455b1eafdfdfdfba7ec80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#30f511a1deeb308d57ec9bcec8d16f0f">append</a> (<a class="el" href="classPartitioner_1_1Function.html">Function</a> *, <a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *, unsigned reasons, bool keep=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append basic block to function.  <a href="#30f511a1deeb308d57ec9bcec8d16f0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#7d6d934c7fe0e273e8edd1b4ecc5e36e">append</a> (<a class="el" href="classPartitioner_1_1Function.html">Function</a> *, <a class="el" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *, unsigned reasons, bool force=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append data region to function.  <a href="#7d6d934c7fe0e273e8edd1b4ecc5e36e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#7a886afe82a7fc7171bdc64ecfd379fb">remove</a> (<a class="el" href="classPartitioner_1_1Function.html">Function</a> *, <a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a basic block from a function.  <a href="#7a886afe82a7fc7171bdc64ecfd379fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#780baf904faf5b5eb57eec90b1b6c16b">remove</a> (<a class="el" href="classPartitioner_1_1Function.html">Function</a> *, <a class="el" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a data block from a function.  <a href="#780baf904faf5b5eb57eec90b1b6c16b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#7578d7e4a6ba2612a608fd19a550178e">remove</a> (<a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *, <a class="el" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a data block from a basic block.  <a href="#7578d7e4a6ba2612a608fd19a550178e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">find_bb_containing</a> (<a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>, bool create=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds a basic block containing the specified instruction address.  <a href="#67b4f858bb93fcef7d4c24be86cd10f3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#67702e97dcbfb27fa18f6186fe30538a">find_bb_starting</a> (<a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>, bool create=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes sure the block at the specified address exists.  <a href="#67702e97dcbfb27fa18f6186fe30538a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#72fe4f436de7235fa06629810a5f1494">find_db_starting</a> (<a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>, size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds (or creates) a data block.  <a href="#72fe4f436de7235fa06629810a5f1494"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#e2e3e09e5194ba8c87bc968b65b63e3c">successors</a> (<a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *, bool *complete=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns known successors of a basic block.  <a href="#e2e3e09e5194ba8c87bc968b65b63e3c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#5665dc5ef1c3aef6670dc6ab5d66815f">call_target</a> (<a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns call target if block could be a function call.  <a href="#5665dc5ef1c3aef6670dc6ab5d66815f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#a1fd20a852585175fc0be71ef5bd97bd">truncate</a> (<a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *, <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reduces the size of a basic block by truncating its list of instructions.  <a href="#a1fd20a852585175fc0be71ef5bd97bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#810bddfe83b19037ed710bdb98a34f50">discover_first_block</a> (<a class="el" href="classPartitioner_1_1Function.html">Function</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds first basic block to empty function before we start discovering blocks of any other functions.  <a href="#810bddfe83b19037ed710bdb98a34f50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#354aa1fce4dcbc80c99038829a3ddb76">discover_blocks</a> (<a class="el" href="classPartitioner_1_1Function.html">Function</a> *, unsigned reason)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#9bc4921fd2eefd0a2eb4f8eeaa2b2f2f">discover_blocks</a> (<a class="el" href="classPartitioner_1_1Function.html">Function</a> *, <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>, unsigned reason)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Discover the basic blocks that belong to the current function.  <a href="#9bc4921fd2eefd0a2eb4f8eeaa2b2f2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#815304b7ef093a74bc419662d54df49b">pre_cfg</a> (<a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *interp=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detects functions before analyzing the CFG.  <a href="#815304b7ef093a74bc419662d54df49b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#19725656eaa83118d75bdd77c617cef4">analyze_cfg</a> (<a class="el" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48c">SgAsmBlock::Reason</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detect functions by analyzing the CFG.  <a href="#19725656eaa83118d75bdd77c617cef4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#48a2e4d8bd6d15fb31a0ae8e41a747a3">post_cfg</a> (<a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *interp=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detects functions after analyzing the CFG.  <a href="#48a2e4d8bd6d15fb31a0ae8e41a747a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#2f7da41ef6f3e3d1e11146ecc4c75a61">build_ast</a> (<a class="el" href="classPartitioner_1_1Function.html">Function</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build an AST for a single function.  <a href="#2f7da41ef6f3e3d1e11146ecc4c75a61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#ed7ad33de4977b27a12453e6c37b8288">build_ast</a> (<a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build an AST for a single basic block.  <a href="#ed7ad33de4977b27a12453e6c37b8288"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#ca294bc7e7ed85d40465d7d7c346bd49">build_ast</a> (<a class="el" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build an AST for a single data block.  <a href="#ca294bc7e7ed85d40465d7d7c346bd49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#6da761bf550bd07c05fa615f4091adba">pops_return_address</a> (<a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if a block pops the stack w/o returning.  <a href="#6da761bf550bd07c05fa615f4091adba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#8652c15bcdd9d9dca2efb2d9f865f519">update_analyses</a> (<a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Runs local block analyses if their cached results are invalid and caches the results.  <a href="#8652c15bcdd9d9dca2efb2d9f865f519"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#bd63242c67a32e6de5434d21956a01bf">canonic_block</a> (<a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Follow alias links in basic blocks.  <a href="#bd63242c67a32e6de5434d21956a01bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#9c333715d5d353bab9fd4f46ce2c2d8d">is_function_call</a> (<a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *, <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if basic block appears to end with a function call.  <a href="#9c333715d5d353bab9fd4f46ce2c2d8d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#64d3ebb83d085cd1709305c13a2bbd7d">is_thunk</a> (<a class="el" href="classPartitioner_1_1Function.html">Function</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if function is a thunk.  <a href="#64d3ebb83d085cd1709305c13a2bbd7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPartitioner_1_1Function.html">Function</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#cd1de02179852d54139e2f4eb366ebdc">effective_function</a> (<a class="el" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the function to which this data block is effectively assigned.  <a href="#cd1de02179852d54139e2f4eb366ebdc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#e9e536212c2e5efdf21ad22993d5c888">mark_call_insns</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Naive marking of CALL instruction targets as functions.  <a href="#e9e536212c2e5efdf21ad22993d5c888"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#fd2b60293bc45d47e74befebde631533">mark_ipd_configuration</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Seeds partitioner with IPD configuration information.  <a href="#fd2b60293bc45d47e74befebde631533"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#1f7de70089099ce3d31af5ed455fc9b7">mark_entry_targets</a> (<a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Seeds functions for program entry points.  <a href="#1f7de70089099ce3d31af5ed455fc9b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#167cda7ee682478117f8480d86815efc">mark_eh_frames</a> (<a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Seeds functions for error handling frames.  <a href="#167cda7ee682478117f8480d86815efc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#20bab02d75f2c49035e63dc029635698">mark_elf_plt_entries</a> (<a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Seeds functions that are dynamically linked via .plt.  <a href="#20bab02d75f2c49035e63dc029635698"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#5856443d8da3aeb540e193491619dab8">mark_func_symbols</a> (<a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Seeds functions that correspond to function symbols.  <a href="#5856443d8da3aeb540e193491619dab8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#608c32001c0e56d18e41ce2d77976f9d">mark_func_patterns</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Seeds functions according to instruction patterns.  <a href="#608c32001c0e56d18e41ce2d77976f9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#17cac3fb6a8a12bf633c70e4640728ff">name_plt_entries</a> (<a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gives names to dynmaic linking trampolines for ELF.  <a href="#17cac3fb6a8a12bf633c70e4640728ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#dc7b9b7851ee14847eed8454619cb505">name_import_entries</a> (<a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gives names to dynamic linking thunks for PE.  <a href="#dc7b9b7851ee14847eed8454619cb505"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#3a1386d81012e94a46184c4703fd9e40">function_extent</a> (<a class="el" href="classRangeMap.html">FunctionRangeMap</a> *extents)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds extents for all defined functions.  <a href="#3a1386d81012e94a46184c4703fd9e40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#4e30200e210edc6193cc8d4edd873607">function_extent</a> (<a class="el" href="classPartitioner_1_1Function.html">Function</a> *, <a class="el" href="classRangeMap.html">FunctionRangeMap</a> *extents=NULL, <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> *lo_addr=NULL, <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> *hi_addr=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns information about the function addresses.  <a href="#4e30200e210edc6193cc8d4edd873607"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#b887328bc3f2afab215f8c0e7e5603c9">datablock_extent</a> (<a class="el" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *, <a class="el" href="classRangeMap.html">DataRangeMap</a> *extents=NULL, <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> *lo_addr=NULL, <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> *hi_addr=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns information about the datablock addresses.  <a href="#b887328bc3f2afab215f8c0e7e5603c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#481f8f89f2c2427ef13f3a737448c927">datablock_extent</a> (<a class="el" href="classRangeMap.html">DataRangeMap</a> *extent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds assigned datablocks to extent.  <a href="#481f8f89f2c2427ef13f3a737448c927"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#af310f1d4a77ace2f3b3ecc05e376c20">padding_extent</a> (<a class="el" href="classRangeMap.html">DataRangeMap</a> *extent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds padding datablocks to extent.  <a href="#af310f1d4a77ace2f3b3ecc05e376c20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#8e3fb4de9cbbd0a0bba2c3392f3361f9">is_contiguous</a> (<a class="el" href="classPartitioner_1_1Function.html">Function</a> *, bool strict=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an indication of whether a function is contiguous.  <a href="#8e3fb4de9cbbd0a0bba2c3392f3361f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#044f608ba9d2cf1d4b9d22b2c53ccea9">progress</a> (FILE *, const char *fmt,...) const __attribute__((format(printf</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Conditionally prints a progress report.  <a href="#044f608ba9d2cf1d4b9d22b2c53ccea9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#50ae683bbc187c44dc13dcac778fd502">detach_thunks</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Splits thunks off of the start of functions.  <a href="#50ae683bbc187c44dc13dcac778fd502"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#b6d3411d68e7aa9a994850b672f01af0">detach_thunk</a> (<a class="el" href="classPartitioner_1_1Function.html">Function</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Splits one thunk off the start of a function if possible.  <a href="#b6d3411d68e7aa9a994850b672f01af0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#6280eae4362e64e6b5df4ed55fc17c91">adjust_padding</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adjusts ownership of padding data blocks.  <a href="#6280eae4362e64e6b5df4ed55fc17c91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#c0755f9cbb352919fe0d275cb8f4bd9a">merge_function_fragments</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merge function fragments.  <a href="#c0755f9cbb352919fe0d275cb8f4bd9a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#ffa6af5890f1034b4b6cd59779492e23">merge_functions</a> (<a class="el" href="classPartitioner_1_1Function.html">Function</a> *parent, <a class="el" href="classPartitioner_1_1Function.html">Function</a> *other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merge two functions.  <a href="#ffa6af5890f1034b4b6cd59779492e23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#2a72cba4305db33a1086da011dab641b">discover_jump_table</a> (<a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *bb, bool do_create=true, <a class="el" href="classExtentMap.html">ExtentMap</a> *table_addresses=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks for a jump table.  <a href="#2a72cba4305db33a1086da011dab641b"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#3c46fdd567c72ad245ab7e2e6351a9d8">set_map</a> (<a class="el" href="classMemoryMap.html">MemoryMap</a> *mmap, <a class="el" href="classMemoryMap.html">MemoryMap</a> *ro_mmap=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accessors for the memory maps.  <a href="#3c46fdd567c72ad245ab7e2e6351a9d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classMemoryMap.html">MemoryMap</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#697de2be7e07894883304357a546438b">get_map</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accessors for the memory maps.  <a href="#697de2be7e07894883304357a546438b"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPartitioner_1_1CodeCriteria.html">CodeCriteria</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#54cffacaad0e5f8d0eb9195a9f9ba7bb">new_code_criteria</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new criteria object.  <a href="#54cffacaad0e5f8d0eb9195a9f9ba7bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPartitioner_1_1CodeCriteria.html">CodeCriteria</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#b890b3323cad88efe757daae581beb7c">new_code_criteria</a> (const <a class="el" href="classPartitioner_1_1RegionStats.html">RegionStats</a> *mean, const <a class="el" href="classPartitioner_1_1RegionStats.html">RegionStats</a> *variance, double threshold)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new criteria object.  <a href="#b890b3323cad88efe757daae581beb7c"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPartitioner_1_1RegionStats.html">RegionStats</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#a268f3ccba22f976fa0439a88e77594d">region_statistics</a> (const <a class="el" href="classExtentMap.html">ExtentMap</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes various statistics over part of an address space.  <a href="#a268f3ccba22f976fa0439a88e77594d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPartitioner_1_1RegionStats.html">RegionStats</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#d743f90216a471e9a699f9beb4bfe44a">region_statistics</a> (<a class="el" href="classPartitioner_1_1Function.html">Function</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes various statistics over part of an address space.  <a href="#d743f90216a471e9a699f9beb4bfe44a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPartitioner_1_1RegionStats.html">RegionStats</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#07952b3805872c9992ce72c39083c9f9">region_statistics</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes various statistics over part of an address space.  <a href="#07952b3805872c9992ce72c39083c9f9"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPartitioner_1_1RegionStats.html">RegionStats</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#819257a6ef08bdc22af30adf6147825c">get_aggregate_mean</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accessors for cached aggregate statistics.  <a href="#819257a6ef08bdc22af30adf6147825c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPartitioner_1_1RegionStats.html">RegionStats</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#6618693bfecf89c45fdf92a3b4b72cf3">get_aggregate_variance</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accessors for cached aggregate statistics.  <a href="#6618693bfecf89c45fdf92a3b4b72cf3"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#6d1d5da1e3c1b3d4f9fb9e63be723c91">count_kinds</a> (const <a class="el" href="classPartitioner.html#cff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Counts the number of distinct kinds of instructions.  <a href="#6d1d5da1e3c1b3d4f9fb9e63be723c91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#2678589961c331f098f409fb8a9432cd">count_kinds</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Counts the number of distinct kinds of instructions.  <a href="#2678589961c331f098f409fb8a9432cd"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#38c4d8fa97d420b1d5ee00569471136d">count_privileged</a> (const <a class="el" href="classPartitioner.html#cff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Counts the number of privileged instructions.  <a href="#38c4d8fa97d420b1d5ee00569471136d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#54f485a94d56cc3444d5b83a92c8809e">count_privileged</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Counts the number of privileged instructions.  <a href="#54f485a94d56cc3444d5b83a92c8809e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#a634ae377c966bab8ba4c093636955b2">ratio_privileged</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Counts the number of privileged instructions.  <a href="#a634ae377c966bab8ba4c093636955b2"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#250d10977fc2134480c49b88e08ffd46">count_floating_point</a> (const <a class="el" href="classPartitioner.html#cff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Counts the number of floating point instructions.  <a href="#250d10977fc2134480c49b88e08ffd46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#1b01910a0c4aa0a888585d02913259fc">count_floating_point</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Counts the number of floating point instructions.  <a href="#1b01910a0c4aa0a888585d02913259fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#ebcf2106ed8fed4d0e0c4c8b5d9737a5">ratio_floating_point</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Counts the number of floating point instructions.  <a href="#ebcf2106ed8fed4d0e0c4c8b5d9737a5"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#723e4425779fdc6bec6dc132b70aae4e">count_registers</a> (const <a class="el" href="classPartitioner.html#cff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a> &amp;, double *mean=NULL, double *variance=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Counts the number of register references.  <a href="#723e4425779fdc6bec6dc132b70aae4e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#c18f17d2cd089802b9b44e10930b136e">count_registers</a> (double *mean=NULL, double *variance=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Counts the number of register references.  <a href="#c18f17d2cd089802b9b44e10930b136e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#c9fa9c57392d17fd4037b19257b6041e">ratio_registers</a> (double *mean=NULL, double *variance=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Counts the number of register references.  <a href="#c9fa9c57392d17fd4037b19257b6041e"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#b308df2f53d07d9213961c358110282b">count_size_variance</a> (const <a class="el" href="classPartitioner.html#cff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a> &amp;<a class="el" href="classPartitioner.html#f9d5d92a9d9ca6a35ade7c5b3906ab97">insns</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the variance of instruction bit widths.  <a href="#b308df2f53d07d9213961c358110282b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#0ced79f385b55276035b5712d2620a76">count_size_variance</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the variance of instruction bit widths.  <a href="#0ced79f385b55276035b5712d2620a76"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPartitioner_1_1CodeCriteria.html">CodeCriteria</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#56c16ee96129976b670fb0a49a1ce91f">get_code_criteria</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accessors for code criteria.  <a href="#56c16ee96129976b670fb0a49a1ce91f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#b83a528886f91bd791e89b4fa8fee83f">set_code_criteria</a> (<a class="el" href="classPartitioner_1_1CodeCriteria.html">CodeCriteria</a> *cc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accessors for code criteria.  <a href="#b83a528886f91bd791e89b4fa8fee83f"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#128338b3c819f629c68058ca40545c18">scan_contiguous_insns</a> (<a class="el" href="classPartitioner.html#cff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a> <a class="el" href="classPartitioner.html#f9d5d92a9d9ca6a35ade7c5b3906ab97">insns</a>, <a class="el" href="classROSE__Callbacks_1_1List.html">InsnRangeCallbacks</a> &amp;cblist, <a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a> *insn_prev, <a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a> *insn_end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scans contiguous sequences of instructions.  <a href="#128338b3c819f629c68058ca40545c18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#d76daaae13e84b22b42098fc1a58641f">scan_contiguous_insns</a> (const <a class="el" href="classPartitioner.html#cff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a> &amp;<a class="el" href="classPartitioner.html#f9d5d92a9d9ca6a35ade7c5b3906ab97">insns</a>, <a class="el" href="classPartitioner_1_1InsnRangeCallback.html">InsnRangeCallback</a> *callback, <a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a> *insn_prev, <a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a> *insn_end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scans contiguous sequences of instructions.  <a href="#d76daaae13e84b22b42098fc1a58641f"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#296180568b4a21d4435f264a05f1837f">scan_unassigned_insns</a> (<a class="el" href="classROSE__Callbacks_1_1List.html">InsnRangeCallbacks</a> &amp;callbacks)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scans ranges of unassigned instructions.  <a href="#296180568b4a21d4435f264a05f1837f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#36686cdb1a5fee0a8033ef7708f70b6f">scan_unassigned_insns</a> (<a class="el" href="classPartitioner_1_1InsnRangeCallback.html">InsnRangeCallback</a> *callback)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scans ranges of unassigned instructions.  <a href="#36686cdb1a5fee0a8033ef7708f70b6f"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#6d6f280eb993c9ec09c0b79d1ae790f7">scan_intrafunc_insns</a> (<a class="el" href="classROSE__Callbacks_1_1List.html">InsnRangeCallbacks</a> &amp;callbacks)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scans the unassigned instructions within a function.  <a href="#6d6f280eb993c9ec09c0b79d1ae790f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#155f8d6d64429bab633e256b48cd32d0">scan_intrafunc_insns</a> (<a class="el" href="classPartitioner_1_1InsnRangeCallback.html">InsnRangeCallback</a> *callback)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scans the unassigned instructions within a function.  <a href="#155f8d6d64429bab633e256b48cd32d0"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#ff3f578d277b534b4e2e703a39414e73">scan_interfunc_insns</a> (<a class="el" href="classROSE__Callbacks_1_1List.html">InsnRangeCallbacks</a> &amp;callbacks)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scans the instructions between functions.  <a href="#ff3f578d277b534b4e2e703a39414e73"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#1e3a66407625c4723589f867064709ac">scan_interfunc_insns</a> (<a class="el" href="classPartitioner_1_1InsnRangeCallback.html">InsnRangeCallback</a> *callback)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scans the instructions between functions.  <a href="#1e3a66407625c4723589f867064709ac"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#9fa138686f888f9a51e6e798a550a285">scan_unassigned_bytes</a> (<a class="el" href="classROSE__Callbacks_1_1List.html">ByteRangeCallbacks</a> &amp;callbacks, <a class="el" href="classMemoryMap.html">MemoryMap</a> *restrict_map=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scans ranges of the address space that have not been assigned to any function.  <a href="#9fa138686f888f9a51e6e798a550a285"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#7e81dfb79439e41d3013fbd032edb0bf">scan_unassigned_bytes</a> (<a class="el" href="classPartitioner_1_1ByteRangeCallback.html">ByteRangeCallback</a> *callback, <a class="el" href="classMemoryMap.html">MemoryMap</a> *restrict_map=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scans ranges of the address space that have not been assigned to any function.  <a href="#7e81dfb79439e41d3013fbd032edb0bf"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#a262ad7bb16670512ea037eb06b0ed15">scan_intrafunc_bytes</a> (<a class="el" href="classROSE__Callbacks_1_1List.html">ByteRangeCallbacks</a> &amp;callbacks, <a class="el" href="classMemoryMap.html">MemoryMap</a> *restrict_map=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scans unassigned ranges of the address space within a function.  <a href="#a262ad7bb16670512ea037eb06b0ed15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#e7f2a87f90ac844277ab59b19ea0f863">scan_intrafunc_bytes</a> (<a class="el" href="classPartitioner_1_1ByteRangeCallback.html">ByteRangeCallback</a> *callback, <a class="el" href="classMemoryMap.html">MemoryMap</a> *restrict_map=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scans unassigned ranges of the address space within a function.  <a href="#e7f2a87f90ac844277ab59b19ea0f863"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#7f593939f5d8fa66b5e38a25183b4b8f">scan_interfunc_bytes</a> (<a class="el" href="classROSE__Callbacks_1_1List.html">ByteRangeCallbacks</a> &amp;callbacks, <a class="el" href="classMemoryMap.html">MemoryMap</a> *restrict_map=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scans unassigned ranges of the address space between functions.  <a href="#7f593939f5d8fa66b5e38a25183b4b8f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#5f29cd4e14c75ec863a017c12bae0c47">scan_interfunc_bytes</a> (<a class="el" href="classPartitioner_1_1ByteRangeCallback.html">ByteRangeCallback</a> *callback, <a class="el" href="classMemoryMap.html">MemoryMap</a> *restrict_map=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scans unassigned ranges of the address space between functions.  <a href="#5f29cd4e14c75ec863a017c12bae0c47"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#63758ffe8d586886ebfcdb2f69c7d107">parse_switches</a> (const std::string &amp;, unsigned initial_flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parses a string describing the heuristics and returns the bit vector that can be passed to <a class="el" href="classPartitioner.html#e52ab7e0fa20592ae95f858404b3234b">set_search()</a>.  <a href="#63758ffe8d586886ebfcdb2f69c7d107"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#a4ec978230e19cc6bd34d60be7801452">get_indirection_addr</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the virtual address that holds the branch target for an indirect branch.  <a href="#a4ec978230e19cc6bd34d60be7801452"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#36e3aa4734377dacea3614c7dd5fd5e6">value_of</a> (<a class="el" href="classSgAsmValueExpression.html">SgAsmValueExpression</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the integer value of a value expression since there's no virtual method for doing this.  <a href="#36e3aa4734377dacea3614c7dd5fd5e6"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classDisassembler.html">Disassembler</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#320e02804f0d9ae5bc55e1ba26791a72">disassembler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optional disassembler to call when an instruction is needed.  <a href="#320e02804f0d9ae5bc55e1ba26791a72"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPartitioner.html#cff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#f9d5d92a9d9ca6a35ade7c5b3906ab97">insns</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a> cache, filled in by user or populated by disassembler.  <a href="#f9d5d92a9d9ca6a35ade7c5b3906ab97"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classMemoryMap.html">MemoryMap</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">map</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Memory map used for disassembly if disassembler is present.  <a href="#a8aa1ec02714f0608e72147f2dee7ffc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classMemoryMap.html">MemoryMap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#0b160d2ed1a5b32606e0deaf4c8cbb43">ro_map</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The read-only parts of 'map', used for insn semantics mem reads.  <a href="#0b160d2ed1a5b32606e0deaf4c8cbb43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classDisassembler.html#30c51578d70dfc05fb46047867ceadcd">Disassembler::BadMap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#44a78932a6c3307dbdd9d9327bbb3eba">bad_insns</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Captured disassembler exceptions.  <a href="#44a78932a6c3307dbdd9d9327bbb3eba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPartitioner.html#a3a62d239fd07ca47ffc37dd21b74006">BasicBlocks</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#1f1a02cff90220dd026d8a344404fbea">basic_blocks</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All known basic blocks.  <a href="#1f1a02cff90220dd026d8a344404fbea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPartitioner.html#d68aee879b03b498c5d988d7fdfd6ae8">Functions</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">functions</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All known functions, pending and complete.  <a href="#85fdfbc700ab9b3eaf1a1fa77c53c216"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPartitioner.html#c9034b33e56a9e1d2e95dcd9c97cf431">DataBlocks</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#b8b08dc01aab15b7ae2dff4af899046f">data_blocks</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Blocks that point to static data.  <a href="#b8b08dc01aab15b7ae2dff4af899046f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#61a820e23e3d57c012d0928aa9c4d1a2">func_heuristics</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit mask of <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c">SgAsmFunction::FunctionReason</a> bits.  <a href="#61a820e23e3d57c012d0928aa9c4d1a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classPartitioner.html#da9ff0ad1ed799e3d44df2c1958e9303">FunctionDetector</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#e8ccefb002c5a4bea6abc98c226d19d6">user_detectors</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of user-defined function detection methods.  <a href="#e8ccefb002c5a4bea6abc98c226d19d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">FILE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">debug</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stream where diagnistics are sent (or null).  <a href="#7ea39de5e72216dbece1d9f3b9c79f8f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#a89d8e06b1a855108422287a46b63b04">allow_discont_blocks</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allow basic blocks to be discontiguous in virtual memory.  <a href="#a89d8e06b1a855108422287a46b63b04"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPartitioner.html#f15dc59805f5188b3a9a91f2a9906ca3">BlockConfigMap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#e4d5b142571b09b4cb8e77016991d3d0">block_config</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IPD configuration info for basic blocks.  <a href="#e4d5b142571b09b4cb8e77016991d3d0"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static time_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#2663919047a75925b65a999ab6ea2f40">progress_interval</a> = 10</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Minimum interval between progress reports.  <a href="#2663919047a75925b65a999ab6ea2f40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static time_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#868d4534cf2da160c4ed12cb304323c9">progress_time</a> = 0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Time of last report, or zero if no report has been generated.  <a href="#868d4534cf2da160c4ed12cb304323c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static FILE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#2b8e2de19780bf27ea1ab31b1b20f51a">progress_file</a> = stderr</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">File to which reports are made.  <a href="#2b8e2de19780bf27ea1ab31b1b20f51a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#7e4a76ae7ab4113b2ec7acf9093c3810">NO_TARGET</a> = (<a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>)-1</td></tr>

<tr><td colspan="2"><br><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map&lt; <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>,<br>
 <a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#cff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::vector&lt; <a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#8a540a6d610b0b6746bdb3900842fec7">InstructionVector</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map&lt; <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>,<br>
 <a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#a3a62d239fd07ca47ffc37dd21b74006">BasicBlocks</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map&lt; <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>,<br>
 <a class="el" href="structPartitioner_1_1DataBlock.html">DataBlock</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#c9034b33e56a9e1d2e95dcd9c97cf431">DataBlocks</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map&lt; <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>,<br>
 <a class="el" href="classPartitioner_1_1Function.html">Function</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#d68aee879b03b498c5d988d7fdfd6ae8">Functions</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#da9ff0ad1ed799e3d44df2c1958e9303">FunctionDetector</a> (<a class="el" href="classPartitioner.html">Partitioner</a> *, <a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for user-defined function detectors.  <a href="#da9ff0ad1ed799e3d44df2c1958e9303"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map&lt; <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>,<br>
 <a class="el" href="structPartitioner_1_1BlockConfig.html">BlockConfig</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#f15dc59805f5188b3a9a91f2a9906ca3">BlockConfigMap</a></td></tr>

<tr><td colspan="2"><br><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static InstructionMap::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#211865359a987a4e353615bb427bda34">pattern1</a> (const <a class="el" href="classPartitioner.html#cff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a> &amp;<a class="el" href="classPartitioner.html#f9d5d92a9d9ca6a35ade7c5b3906ab97">insns</a>, InstructionMap::const_iterator first, <a class="el" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> &amp;exclude)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks for stack frame setup.  <a href="#211865359a987a4e353615bb427bda34"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#9c2b4ede732f01bb1ce72270e0ee68da">isSgAsmInstruction</a> (const <a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Augments dynamic casts defined from ROSETTA.  <a href="#9c2b4ede732f01bb1ce72270e0ee68da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#180324119e83339c19e88b0790dc0a5d">isSgAsmInstruction</a> (<a class="el" href="classSgNode.html">SgNode</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Augments dynamic casts defined from ROSETTA.  <a href="#180324119e83339c19e88b0790dc0a5d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#8ca4106dccc0db0f0a69bc84efd48474">isSgAsmx86Instruction</a> (const <a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Augments dynamic casts defined from ROSETTA.  <a href="#8ca4106dccc0db0f0a69bc84efd48474"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#cd7ab5192dc3577d88a0f7d63ed548a7">isSgAsmx86Instruction</a> (<a class="el" href="classSgNode.html">SgNode</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Augments dynamic casts defined from ROSETTA.  <a href="#cd7ab5192dc3577d88a0f7d63ed548a7"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPartitioner_1_1RegionStats.html">RegionStats</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#4862f9ab22b50ad90a880ff7d16031ab">aggregate_mean</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Aggregate statistics returned by get_region_stats_mean().  <a href="#4862f9ab22b50ad90a880ff7d16031ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPartitioner_1_1RegionStats.html">RegionStats</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#a129e066f5e94444fb2a29b3d18bdf04">aggregate_variance</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Aggregate statistics returned by get_region_stats_variance().  <a href="#a129e066f5e94444fb2a29b3d18bdf04"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPartitioner_1_1CodeCriteria.html">CodeCriteria</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner.html#068adcb53c802118a44b8d8fb0ee653c">code_criteria</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Criteria used to determine if a region contains code or data.  <a href="#068adcb53c802118a44b8d8fb0ee653c"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPartitioner_1_1AbandonFunctionDiscovery.html">AbandonFunctionDiscovery</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a basic block within the <a class="el" href="classPartitioner.html">Partitioner</a>.  <a href="structPartitioner_1_1BasicBlock.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1BlockAnalysisCache.html">BlockAnalysisCache</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classAnalysis.html">Analysis</a> that can be cached in a block.  <a href="classPartitioner_1_1BlockAnalysisCache.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPartitioner_1_1BlockConfig.html">BlockConfig</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic block configuration information.  <a href="structPartitioner_1_1BlockConfig.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1ByteRangeCallback.html">ByteRangeCallback</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for byte scanning callbacks.  <a href="classPartitioner_1_1ByteRangeCallback.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1CodeCriteria.html">CodeCriteria</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Criteria to decide whether a region of memory contains code.  <a href="classPartitioner_1_1CodeCriteria.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPartitioner_1_1DataBlock.html">DataBlock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a region of static data within the address space being disassembled.  <a href="structPartitioner_1_1DataBlock.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1DataRangeMapValue.html">DataRangeMapValue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Value type for DataRangeMap.  <a href="classPartitioner_1_1DataRangeMapValue.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPartitioner_1_1Exception.html">Exception</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPartitioner_1_1FindData.html">FindData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback to add unassigned addresses to a function.  <a href="structPartitioner_1_1FindData.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPartitioner_1_1FindDataPadding.html">FindDataPadding</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback to detect padding.  <a href="structPartitioner_1_1FindDataPadding.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPartitioner_1_1FindFunctionFragments.html">FindFunctionFragments</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback to insert unreachable code fragments.  <a href="structPartitioner_1_1FindFunctionFragments.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPartitioner_1_1FindInsnPadding.html">FindInsnPadding</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback to create inter-function instruction padding.  <a href="structPartitioner_1_1FindInsnPadding.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPartitioner_1_1FindInterPadFunctions.html">FindInterPadFunctions</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback to find functions that are between padding.  <a href="structPartitioner_1_1FindInterPadFunctions.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPartitioner_1_1FindPostFunctionInsns.html">FindPostFunctionInsns</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback to add post-function instructions to the preceding function.  <a href="structPartitioner_1_1FindPostFunctionInsns.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPartitioner_1_1FindThunks.html">FindThunks</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback to find thunks.  <a href="structPartitioner_1_1FindThunks.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPartitioner_1_1FindThunkTables.html">FindThunkTables</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback to find thunk tables.  <a href="structPartitioner_1_1FindThunkTables.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1Function.html">Function</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a function within the <a class="el" href="classPartitioner.html">Partitioner</a>.  <a href="classPartitioner_1_1Function.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1FunctionRangeMapValue.html">FunctionRangeMapValue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Value type for FunctionRangeMap.  <a href="classPartitioner_1_1FunctionRangeMapValue.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPartitioner_1_1FunctionStart.html">FunctionStart</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Information about each function starting address.  <a href="structPartitioner_1_1FunctionStart.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1InsnRangeCallback.html">InsnRangeCallback</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for instruction scanning callbacks.  <a href="classPartitioner_1_1InsnRangeCallback.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Holds an instruction along with some other information about the instruction.  <a href="classPartitioner_1_1Instruction.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1IPDParser.html">IPDParser</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the parser for the instruction partitioning data (IPD) files.  <a href="classPartitioner_1_1IPDParser.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPartitioner_1_1RegionStats.html">RegionStats</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Statistics computed over a region of an address space.  <a href="classPartitioner_1_1RegionStats.html#_details">More...</a><br></td></tr>
</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="cff82cb76be01d1207e5653e6ef2c5c0"></a><!-- doxytag: member="Partitioner::InstructionMap" ref="cff82cb76be01d1207e5653e6ef2c5c0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>, <a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a>*&gt; <a class="el" href="classPartitioner.html#cff82cb76be01d1207e5653e6ef2c5c0">Partitioner::InstructionMap</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00149">149</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
</div>
</div><p>
<a class="anchor" name="8a540a6d610b0b6746bdb3900842fec7"></a><!-- doxytag: member="Partitioner::InstructionVector" ref="8a540a6d610b0b6746bdb3900842fec7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a>*&gt; <a class="el" href="classPartitioner.html#8a540a6d610b0b6746bdb3900842fec7">Partitioner::InstructionVector</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00150">150</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
</div>
</div><p>
<a class="anchor" name="a3a62d239fd07ca47ffc37dd21b74006"></a><!-- doxytag: member="Partitioner::BasicBlocks" ref="a3a62d239fd07ca47ffc37dd21b74006" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>, <a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a>*&gt; <a class="el" href="classPartitioner.html#a3a62d239fd07ca47ffc37dd21b74006">Partitioner::BasicBlocks</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00241">241</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
</div>
</div><p>
<a class="anchor" name="c9034b33e56a9e1d2e95dcd9c97cf431"></a><!-- doxytag: member="Partitioner::DataBlocks" ref="c9034b33e56a9e1d2e95dcd9c97cf431" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>, <a class="el" href="structPartitioner_1_1DataBlock.html">DataBlock</a>*&gt; <a class="el" href="classPartitioner.html#c9034b33e56a9e1d2e95dcd9c97cf431">Partitioner::DataBlocks</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00271">271</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
</div>
</div><p>
<a class="anchor" name="d68aee879b03b498c5d988d7fdfd6ae8"></a><!-- doxytag: member="Partitioner::Functions" ref="d68aee879b03b498c5d988d7fdfd6ae8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>, <a class="el" href="classPartitioner_1_1Function.html">Function</a>*&gt; <a class="el" href="classPartitioner.html#d68aee879b03b498c5d988d7fdfd6ae8">Partitioner::Functions</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00343">343</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
</div>
</div><p>
<a class="anchor" name="da9ff0ad1ed799e3d44df2c1958e9303"></a><!-- doxytag: member="Partitioner::FunctionDetector" ref="da9ff0ad1ed799e3d44df2c1958e9303" args="(Partitioner *, SgAsmGenericHeader *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*) <a class="el" href="classPartitioner.html#da9ff0ad1ed799e3d44df2c1958e9303">Partitioner::FunctionDetector</a>(<a class="el" href="classPartitioner.html">Partitioner</a> *, <a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *)<code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Data type for user-defined function detectors. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00346">346</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
</div>
</div><p>
<a class="anchor" name="f15dc59805f5188b3a9a91f2a9906ca3"></a><!-- doxytag: member="Partitioner::BlockConfigMap" ref="f15dc59805f5188b3a9a91f2a9906ca3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>, <a class="el" href="structPartitioner_1_1BlockConfig.html">BlockConfig</a>*&gt; <a class="el" href="classPartitioner.html#f15dc59805f5188b3a9a91f2a9906ca3">Partitioner::BlockConfigMap</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00358">358</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
</div>
</div><p>
<a class="anchor" name="9a75d765cbfecc297f7d47063095a3c5"></a><!-- doxytag: member="Partitioner::BasicBlockStarts" ref="9a75d765cbfecc297f7d47063095a3c5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>, <a class="el" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a>&gt; <a class="el" href="classPartitioner.html#9a75d765cbfecc297f7d47063095a3c5">Partitioner::BasicBlockStarts</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Map of basic block starting addresses. 
<p>
The key is the virtual address of the first instruction in the basic block; the value is the set of all virtual addresses of instructions known to branch to this basic block (i.e., set of all known callers).<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000094">Deprecated:</a></b></dt><dd>This data type is used only for backward compatibility by <a class="el" href="classPartitioner.html#4812db8f83f8858ae85b382cc3a6acdc">detectBasicBlocks()</a> and <a class="el" href="classPartitioner.html#2661469599426a48867a62e649c3585b">detectFunctions()</a>. It has been replaced by <a class="el" href="classPartitioner.html#a3a62d239fd07ca47ffc37dd21b74006">Partitioner::BasicBlocks</a>. </dd></dl>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00374">374</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
</div>
</div><p>
<a class="anchor" name="b8bf5254df78bd41a374776dc956c0b0"></a><!-- doxytag: member="Partitioner::FunctionStarts" ref="b8bf5254df78bd41a374776dc956c0b0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>, <a class="el" href="structPartitioner_1_1FunctionStart.html">FunctionStart</a>&gt; <a class="el" href="classPartitioner.html#b8bf5254df78bd41a374776dc956c0b0">Partitioner::FunctionStarts</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Map describing the starting address of each known function. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000097">Deprecated:</a></b></dt><dd>This type has been replaced with <a class="el" href="classPartitioner.html#d68aee879b03b498c5d988d7fdfd6ae8">Partitioner::Functions</a>, which is capable of describing noncontiguous functions. </dd></dl>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00395">395</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
</div>
</div><p>
<a class="anchor" name="fa61b430928023cd27ec0227c5a45f4f"></a><!-- doxytag: member="Partitioner::FunctionRangeMap" ref="fa61b430928023cd27ec0227c5a45f4f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classRangeMap.html">RangeMap</a>&lt;<a class="el" href="classRange.html">Extent</a>, <a class="el" href="classPartitioner_1_1FunctionRangeMapValue.html">FunctionRangeMapValue</a>&gt; <a class="el" href="classRangeMap.html">Partitioner::FunctionRangeMap</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classRange.html">Range</a> map associating addresses with functions. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00657">657</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
</div>
</div><p>
<a class="anchor" name="908ae714b9d63d22397ba1d44c0a131e"></a><!-- doxytag: member="Partitioner::DataRangeMap" ref="908ae714b9d63d22397ba1d44c0a131e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classRangeMap.html">RangeMap</a>&lt;<a class="el" href="classRange.html">Extent</a>, <a class="el" href="classPartitioner_1_1DataRangeMapValue.html">DataRangeMapValue</a>&gt; <a class="el" href="classRangeMap.html">Partitioner::DataRangeMap</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classRange.html">Range</a> map associating addresses with functions. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00680">680</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
</div>
</div><p>
<a class="anchor" name="d3746ef9608772aa918629792f10b2b9"></a><!-- doxytag: member="Partitioner::InsnRangeCallbacks" ref="d3746ef9608772aa918629792f10b2b9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classROSE__Callbacks_1_1List.html">ROSE_Callbacks::List</a>&lt;<a class="el" href="classPartitioner_1_1InsnRangeCallback.html">InsnRangeCallback</a>&gt; <a class="el" href="classROSE__Callbacks_1_1List.html">Partitioner::InsnRangeCallbacks</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01037">1037</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
</div>
</div><p>
<a class="anchor" name="28a95ae28faba1e516a9e230258ee7ee"></a><!-- doxytag: member="Partitioner::ByteRangeCallbacks" ref="28a95ae28faba1e516a9e230258ee7ee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classROSE__Callbacks_1_1List.html">ROSE_Callbacks::List</a>&lt;<a class="el" href="classPartitioner_1_1ByteRangeCallback.html">ByteRangeCallback</a>&gt; <a class="el" href="classROSE__Callbacks_1_1List.html">Partitioner::ByteRangeCallbacks</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01057">1057</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="b3788db43d9594c28b201255991e85c2"></a><!-- doxytag: member="Partitioner::Partitioner" ref="b3788db43d9594c28b201255991e85c2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Partitioner::Partitioner           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00409">409</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
</div>
</div><p>
<a class="anchor" name="8adefe825a9988129017f650bac676d4"></a><!-- doxytag: member="Partitioner::~Partitioner" ref="8adefe825a9988129017f650bac676d4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Partitioner::~Partitioner           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00413">413</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00584">clear()</a>.
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="9c2b4ede732f01bb1ce72270e0ee68da"></a><!-- doxytag: member="Partitioner::isSgAsmInstruction" ref="9c2b4ede732f01bb1ce72270e0ee68da" args="(const Instruction *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * Partitioner::isSgAsmInstruction           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Augments dynamic casts defined from ROSETTA. 
<p>
A <a class="el" href="classPartitioner_1_1Instruction.html">Partitioner::Instruction</a> used to be just a <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> before we needed to combine it with some additional info for the partitioner. Therefore, there's quite a bit of code (within the partitioner) that treats them as AST nodes. Rather than replace every occurrance of isSgAsmInstruction(N) with something like (N?isSgAsmInstruction(N-&gt;node):NULL), we add additional versions of the necessary global functions, but define them only within the partitioner. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00027">27</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l00138">Partitioner::Instruction::node</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03564">fixup_cfg_edges()</a>, <a class="el" href="Partitioner_8C-source.html#l03613">fixup_pointers()</a>, and <a class="el" href="Partitioner_8C-source.html#l00270">update_analyses()</a>.
</div>
</div><p>
<a class="anchor" name="180324119e83339c19e88b0790dc0a5d"></a><!-- doxytag: member="Partitioner::isSgAsmInstruction" ref="180324119e83339c19e88b0790dc0a5d" args="(SgNode *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * Partitioner::isSgAsmInstruction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Augments dynamic casts defined from ROSETTA. 
<p>
A <a class="el" href="classPartitioner_1_1Instruction.html">Partitioner::Instruction</a> used to be just a <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> before we needed to combine it with some additional info for the partitioner. Therefore, there's quite a bit of code (within the partitioner) that treats them as AST nodes. Rather than replace every occurrance of isSgAsmInstruction(N) with something like (N?isSgAsmInstruction(N-&gt;node):NULL), we add additional versions of the necessary global functions, but define them only within the partitioner. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00034">34</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Cxx__Grammar_8h.html#8ea3968ea14e6511567d5e5b654315f1">isSgAsmInstruction()</a>.
</div>
</div><p>
<a class="anchor" name="8ca4106dccc0db0f0a69bc84efd48474"></a><!-- doxytag: member="Partitioner::isSgAsmx86Instruction" ref="8ca4106dccc0db0f0a69bc84efd48474" args="(const Instruction *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> * Partitioner::isSgAsmx86Instruction           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Augments dynamic casts defined from ROSETTA. 
<p>
A <a class="el" href="classPartitioner_1_1Instruction.html">Partitioner::Instruction</a> used to be just a <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> before we needed to combine it with some additional info for the partitioner. Therefore, there's quite a bit of code (within the partitioner) that treats them as AST nodes. Rather than replace every occurrance of isSgAsmInstruction(N) with something like (N?isSgAsmInstruction(N-&gt;node):NULL), we add additional versions of the necessary global functions, but define them only within the partitioner. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00041">41</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l00138">Partitioner::Instruction::node</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02990">detach_thunk()</a>, <a class="el" href="Partitioner_8C-source.html#l03954">detectBasicBlocks()</a>, <a class="el" href="Partitioner_8C-source.html#l00191">discover_jump_table()</a>, <a class="el" href="Partitioner_8C-source.html#l02397">get_indirection_addr()</a>, <a class="el" href="Partitioner_8C-source.html#l02300">is_thunk()</a>, <a class="el" href="Partitioner_8C-source.html#l01227">mark_elf_plt_entries()</a>, <a class="el" href="Partitioner_8C-source.html#l01019">mark_ipd_configuration()</a>, <a class="el" href="Partitioner_8C-source.html#l02510">name_import_entries()</a>, <a class="el" href="Partitioner_8C-source.html#l02431">name_plt_entries()</a>, <a class="el" href="Partitioner_8C-source.html#l02213">Partitioner::FindThunkTables::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l02121">Partitioner::FindThunks::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l01863">Partitioner::FindInsnPadding::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l01349">pattern1()</a>, and <a class="el" href="Partitioner_8C-source.html#l00400">pops_return_address()</a>.
</div>
</div><p>
<a class="anchor" name="cd7ab5192dc3577d88a0f7d63ed548a7"></a><!-- doxytag: member="Partitioner::isSgAsmx86Instruction" ref="cd7ab5192dc3577d88a0f7d63ed548a7" args="(SgNode *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> * Partitioner::isSgAsmx86Instruction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Augments dynamic casts defined from ROSETTA. 
<p>
A <a class="el" href="classPartitioner_1_1Instruction.html">Partitioner::Instruction</a> used to be just a <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> before we needed to combine it with some additional info for the partitioner. Therefore, there's quite a bit of code (within the partitioner) that treats them as AST nodes. Rather than replace every occurrance of isSgAsmInstruction(N) with something like (N?isSgAsmInstruction(N-&gt;node):NULL), we add additional versions of the necessary global functions, but define them only within the partitioner. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00048">48</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Cxx__Grammar_8h.html#a821b70974acc822c032fddf101296e9">isSgAsmx86Instruction()</a>.
</div>
</div><p>
<a class="anchor" name="4812db8f83f8858ae85b382cc3a6acdc"></a><!-- doxytag: member="Partitioner::detectBasicBlocks" ref="4812db8f83f8858ae85b382cc3a6acdc" args="(const Disassembler::InstructionMap &amp;) const __attribute__((deprecated))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPartitioner.html#9a75d765cbfecc297f7d47063095a3c5">Partitioner::BasicBlockStarts</a> Partitioner::detectBasicBlocks           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">Disassembler::InstructionMap</a> &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the beginnings of basic blocks based on instruction type and call targets. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000095">Deprecated:</a></b></dt><dd>This function is deprecated. Basic blocks are now represented by <a class="el" href="structPartitioner_1_1BasicBlock.html">Partitioner::BasicBlock</a>. </dd></dl>

<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l03954">3954</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">SgAsmStatement::get_address()</a>, <a class="el" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">SgAsmx86Instruction::get_kind()</a>, <a class="el" href="Cxx__Grammar_8h-source.html#l217707">SgAsmInstruction::get_size()</a>, <a class="el" href="SgAsmX86Instruction_8C-source.html#l00058">SgAsmx86Instruction::get_successors()</a>, <a class="el" href="Partitioner_8C-source.html#l00041">isSgAsmx86Instruction()</a>, <a class="el" href="Partitioner_8C-source.html#l00345">successors()</a>, <a class="el" href="SgAsmX86Instruction_8C-source.html#l00012">SgAsmx86Instruction::terminatesBasicBlock()</a>, <a class="el" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571221e4d163bb7557e57e351140aa7855e">x86_call</a>, <a class="el" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca55714edb34feaf8cb03afb49361a9a0b26c4">x86_farcall</a>, and <a class="el" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571c3721979ec7e0215f81e281e07f66229">x86_pop</a>.
</div>
</div><p>
<a class="anchor" name="2661469599426a48867a62e649c3585b"></a><!-- doxytag: member="Partitioner::detectFunctions" ref="2661469599426a48867a62e649c3585b" args="(SgAsmInterpretation *, const Disassembler::InstructionMap &amp;insns, BasicBlockStarts &amp;bb_starts) const __attribute__((deprecated))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPartitioner.html#b8bf5254df78bd41a374776dc956c0b0">Partitioner::FunctionStarts</a> Partitioner::detectFunctions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">Disassembler::InstructionMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>insns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPartitioner.html#9a75d765cbfecc297f7d47063095a3c5">BasicBlockStarts</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bb_starts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a list of the currently defined functions. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000098">Deprecated:</a></b></dt><dd>This function has been replaced by <a class="el" href="classPartitioner.html#815304b7ef093a74bc419662d54df49b">pre_cfg()</a>, <a class="el" href="classPartitioner.html#19725656eaa83118d75bdd77c617cef4">analyze_cfg()</a>, and <a class="el" href="classPartitioner.html#48a2e4d8bd6d15fb31a0ae8e41a747a3">post_cfg()</a> </dd></dl>

<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l04007">4007</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01805">functions</a>.
</div>
</div><p>
<a class="anchor" name="e52ab7e0fa20592ae95f858404b3234b"></a><!-- doxytag: member="Partitioner::set_search" ref="e52ab7e0fa20592ae95f858404b3234b" args="(unsigned heuristics)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Partitioner::set_search           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>heuristics</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the set of heuristics used by the partitioner. 
<p>
The <code>heuristics</code> should be a bit mask containing the <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c">SgAsmFunction::FunctionReason</a> bits. These same bits are assigned to the "reason" property of the resulting function nodes in the AST, depending on which heuristic detected the function. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00423">423</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01809">func_heuristics</a>.
<p>
Referenced by <a class="el" href="Disassembler_8C-source.html#l00207">Disassembler::disassembleInterpretation()</a>.
</div>
</div><p>
<a class="anchor" name="27dadf58c669d89a6ddb3993075ade12"></a><!-- doxytag: member="Partitioner::get_search" ref="27dadf58c669d89a6ddb3993075ade12" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned Partitioner::get_search           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a bit mask of <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c">SgAsmFunction::FunctionReason</a> bits indicating which heuristics would be used by the partitioner. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00429">429</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01809">func_heuristics</a>.
</div>
</div><p>
<a class="anchor" name="07ab675418fbe36332333be50b0b78b8"></a><!-- doxytag: member="Partitioner::set_allow_discontiguous_blocks" ref="07ab675418fbe36332333be50b0b78b8" args="(bool b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::set_allow_discontiguous_blocks           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>b</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Turns on/off the allowing of discontiguous basic blocks. 
<p>
When set, a basic block may contain instructions that are discontiguous in memory. Such blocks are created when <a class="el" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">find_bb_containing()</a> encounters an unconditional jump whose only successor is known and the successor would not be part of any other block.<p>
Here's an example of a discontiguous basic block.<p>
<div class="fragment"><pre class="fragment">    0x00473bf0: 83 c0 18          |...   |   <a class="code" href="namespacecfgUtils.html#495bbf2d6fb84a47ca0cc937068ab793">add</a>    eax, 0x18
    0x00473bf3: 68 e0 84 44 00    |h..D. |   push   0x004484e0
    0x00473bf8: e9 db 72 fc ff    |..r.. |   jmp    0x0043aed8
    0x0043aed8: c3                |.     |   ret
    0x004484e0: 89 45 f0          |.E.   |   mov    DWORD PTR ss:[ebp + 0xf0(-0x10)], eax
    0x004484e3: 8b 45 f0          |.E.   |   mov    eax, DWORD PTR ss:[ebp + 0xf0(-0x10)]
    0x004484e6: 8b 40 60          |.@`   |   mov    eax, DWORD PTR ds:[eax + 0x60]
    0x004484e9: 03 45 fc          |.E.   |   <a class="code" href="namespacecfgUtils.html#495bbf2d6fb84a47ca0cc937068ab793">add</a>    eax, DWORD PTR ss:[ebp + 0xfc(-0x04)]
    0x004484ec: 89 45 ec          |.E.   |   mov    DWORD PTR ss:[ebp + 0xec(-0x14)], eax
    0x004484ef: e9 0c 83 02 00    |..... |   jmp    0x00470800
    0x00470800: 8b 45 ec          |.E.   |   mov    eax, DWORD PTR ss:[ebp + 0xec(-0x14)]
    0x00470803: 8b 40 18          |.@.   |   mov    eax, DWORD PTR ds:[eax + 0x18]
    0x00470806: 48                |H     |   dec    eax
    0x00470807: 85 c0             |..    |   test   eax, eax
    0x00470809: 0f 8c 4f 3d 00 00 |..O=..|   jl     0x0047455e
                (<a class="code" href="classPartitioner.html#e2e3e09e5194ba8c87bc968b65b63e3c">successors</a>: 0x0047080f 0x0047455e)
</pre></div><p>
When this property is disabled, the above single basic block would have been four blocks, ending at the JMP at 0x473bf8, the RET at 0x43aed8, the JMP at 0x4484ef, and the JL at 0x470809.<p>
The default is that blocks are allowed to be discontiguous. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00462">462</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01813">allow_discont_blocks</a>.
</div>
</div><p>
<a class="anchor" name="7b2621f78594a4269ddf84ac5b038705"></a><!-- doxytag: member="Partitioner::get_allow_discontiguous_blocks" ref="7b2621f78594a4269ddf84ac5b038705" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Partitioner::get_allow_discontiguous_blocks           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an indication of whether discontiguous blocks are allowed. 
<p>
See <a class="el" href="classPartitioner.html#07ab675418fbe36332333be50b0b78b8">set_allow_discontiguous_blocks()</a> for details. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00467">467</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01813">allow_discont_blocks</a>.
</div>
</div><p>
<a class="anchor" name="3779f2493e75745eb5a0d8abf8317316"></a><!-- doxytag: member="Partitioner::set_debug" ref="3779f2493e75745eb5a0d8abf8317316" args="(FILE *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::set_debug           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>f</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends diagnostics to the specified output stream. 
<p>
Null (the default) turns off debugging. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00472">472</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01812">debug</a>.
<p>
Referenced by <a class="el" href="Disassembler_8C-source.html#l00191">Disassembler::disassemble()</a>.
</div>
</div><p>
<a class="anchor" name="878a062caa7908af34df84d4bedae71e"></a><!-- doxytag: member="Partitioner::get_debug" ref="878a062caa7908af34df84d4bedae71e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* Partitioner::get_debug           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the file currently used for debugging; null implies no debugging. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00477">477</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01812">debug</a>.
</div>
</div><p>
<a class="anchor" name="3c46fdd567c72ad245ab7e2e6351a9d8"></a><!-- doxytag: member="Partitioner::set_map" ref="3c46fdd567c72ad245ab7e2e6351a9d8" args="(MemoryMap *mmap, MemoryMap *ro_mmap=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::set_map           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMemoryMap.html">MemoryMap</a> *&nbsp;</td>
          <td class="paramname"> <em>mmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMemoryMap.html">MemoryMap</a> *&nbsp;</td>
          <td class="paramname"> <em>ro_mmap</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accessors for the memory maps. 
<p>
The first argument is usually the complete memory map. It should define all memory that holds instructions, either instructions that have already been disassembled and provided to the <a class="el" href="classPartitioner.html">Partitioner</a>, or instructions that might be disassembled in the course of partitioning. Depending on disassembler flags, the disassembler will probably only look at portions of the map that are marked executable.<p>
The second (optional) map is used to initialize memory in the virtual machine semantics layer and should contain all read-only memory addresses for the specimen. This map normally also includes the parts of the first argument that hold instructions. Things such as dynamic library addresses (i.e., import sections) can also be supplied if they are initialized and not expected to change during the life of the specimen. If a null pointer is specified (the default) then this map is created from all read-only segments of the first argument.<p>
The first map will be stored by the partitioner as a pointer; the other supplied maps are copied. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00174">174</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="MemoryMap_8C-source.html#l00556">MemoryMap::clear()</a>, <a class="el" href="Partitioner_8h-source.html#l01800">map</a>, <a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575721c493a6d527e717ffd911d2f18060f">MemoryMap::MM_PROT_READ</a>, <a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575ba37f8b609f7bd6bc6a454be584726df">MemoryMap::MM_PROT_WRITE</a>, <a class="el" href="MemoryMap_8C-source.html#l00681">MemoryMap::prune()</a>, and <a class="el" href="Partitioner_8h-source.html#l01801">ro_map</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03891">partition()</a>.
</div>
</div><p>
<a class="anchor" name="697de2be7e07894883304357a546438b"></a><!-- doxytag: member="Partitioner::get_map" ref="697de2be7e07894883304357a546438b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMemoryMap.html">MemoryMap</a>* Partitioner::get_map           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accessors for the memory maps. 
<p>
The first argument is usually the complete memory map. It should define all memory that holds instructions, either instructions that have already been disassembled and provided to the <a class="el" href="classPartitioner.html">Partitioner</a>, or instructions that might be disassembled in the course of partitioning. Depending on disassembler flags, the disassembler will probably only look at portions of the map that are marked executable.<p>
The second (optional) map is used to initialize memory in the virtual machine semantics layer and should contain all read-only memory addresses for the specimen. This map normally also includes the parts of the first argument that hold instructions. Things such as dynamic library addresses (i.e., import sections) can also be supplied if they are initialized and not expected to change during the life of the specimen. If a null pointer is specified (the default) then this map is created from all read-only segments of the first argument.<p>
The first map will be stored by the partitioner as a pointer; the other supplied maps are copied. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00498">498</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01800">map</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l01019">mark_ipd_configuration()</a>, <a class="el" href="Partitioner_8C-source.html#l03891">partition()</a>, and <a class="el" href="Partitioner_8C-source.html#l00400">pops_return_address()</a>.
</div>
</div><p>
<a class="anchor" name="072171925925389189b7206fd5897f3d"></a><!-- doxytag: member="Partitioner::set_progress_reporting" ref="072171925925389189b7206fd5897f3d" args="(FILE *, unsigned min_interval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::set_progress_reporting           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>min_interval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set progress reporting properties. 
<p>
A progress report is produced not more than once every <code>min_interval</code> seconds (default is 10) by sending a single line of ouput to the specified file. Progress reporting can be disabled by supplying a null pointer for the file. Progress report properties are class variables. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00060">60</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01818">progress_file</a>, and <a class="el" href="Partitioner_8h-source.html#l01816">progress_interval</a>.
</div>
</div><p>
<a class="anchor" name="fc4d3b064e80e0124eda08827c9cfa07"></a><!-- doxytag: member="Partitioner::add_function_detector" ref="fc4d3b064e80e0124eda08827c9cfa07" args="(FunctionDetector f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::add_function_detector           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner.html#da9ff0ad1ed799e3d44df2c1958e9303">FunctionDetector</a>&nbsp;</td>
          <td class="paramname"> <em>f</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a user-defined function detector to this partitioner. 
<p>
Any number of detectors can be added and they will be run by <a class="el" href="classPartitioner.html#815304b7ef093a74bc419662d54df49b">pre_cfg()</a> in the order they were added, after the built-in methods run. Each user-defined detector will be called first with the SgAmGenericHeader pointing to null, then once for each file header. The user-defined methods are run only if the <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c5f338fbf75bfacef4196e65ba5441767">SgAsmFunction::FUNC_USERDEF</a> is set (see <a class="el" href="classPartitioner.html#e52ab7e0fa20592ae95f858404b3234b">set_search()</a>), which is the default. The reason for having user-defined function detectors is that the detection of functions influences the shape of the AST and so it is easier to apply those analyses here, before the AST is built, rather than in the mid-end after the AST is built. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00519">519</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01810">user_detectors</a>.
</div>
</div><p>
<a class="anchor" name="63758ffe8d586886ebfcdb2f69c7d107"></a><!-- doxytag: member="Partitioner::parse_switches" ref="63758ffe8d586886ebfcdb2f69c7d107" args="(const std::string &amp;, unsigned initial_flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Partitioner::parse_switches           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>initial_flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parses a string describing the heuristics and returns the bit vector that can be passed to <a class="el" href="classPartitioner.html#e52ab7e0fa20592ae95f858404b3234b">set_search()</a>. 
<p>
The input string should be a comma-separated list (without white space) of search specifications. Each specification should be an optional qualifier character followed by either an integer or a word. The accepted words are the lower-case versions of the constants enumerated by <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c">SgAsmFunction::FunctionReason</a>, but without the leading "FUNC_". The qualifier determines whether the bits specified by the integer or word are added to the return value ("+") or removed from the return value ("-"). The "=" qualifier acts like "+" but first zeros the return value. The default qualifier is "+" except when the word is "default", in which case the specifier is "=". An optional initial bit mask can be specified (defaults to <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c385e7a83cce8b1ff004ec203c157785a">SgAsmFunction::FUNC_DEFAULT</a>). 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00093">93</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cbb9273d4d879614c52016694798c3143">SgAsmFunction::FUNC_CALL_INSN</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852ceea34044afa2b5415dad4b39cf2aa51d">SgAsmFunction::FUNC_CALL_TARGET</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c385e7a83cce8b1ff004ec203c157785a">SgAsmFunction::FUNC_DEFAULT</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cd7e1055f3974be70f4e4d88e758ed666">SgAsmFunction::FUNC_EH_FRAME</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c2c1716e490136fddc09c145d8809ed64">SgAsmFunction::FUNC_ENTRY_POINT</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c40c0ce88c447524963f4e8d7ef193cc7">SgAsmFunction::FUNC_IMPORT</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c78785310b2939c8834f597ef91fc17f4">SgAsmFunction::FUNC_INTRABLOCK</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c617301fe6a598b9c4afbde0aebcc8ad5">SgAsmFunction::FUNC_LEFTOVERS</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852ccb6d9cc5789fcc0c98bb6e6894831228">SgAsmFunction::FUNC_MISCMASK</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cdac33191eb0a658ed5382f9076595a28">SgAsmFunction::FUNC_PADDING</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cd01f7a2ed6ff7e8a3e6c4550d0ccaa63">SgAsmFunction::FUNC_PATTERN</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c10eee68a3ad870f7e48faef2639a853a">SgAsmFunction::FUNC_SYMBOL</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c331ffe7c063699b34757276068c08d79">SgAsmFunction::FUNC_THUNK</a>, and <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c5f338fbf75bfacef4196e65ba5441767">SgAsmFunction::FUNC_USERDEF</a>.
</div>
</div><p>
<a class="anchor" name="d8d4292001cbf0490676f8bc148c1a24"></a><!-- doxytag: member="Partitioner::partition" ref="d8d4292001cbf0490676f8bc148c1a24" args="(SgAsmInterpretation *, const Disassembler::InstructionMap &amp;, MemoryMap *mmap=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> * Partitioner::partition           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">Disassembler::InstructionMap</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMemoryMap.html">MemoryMap</a> *&nbsp;</td>
          <td class="paramname"> <em>mmap</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Top-level function to run the partitioner on some instructions and build an AST. 
<p>
The <a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> is optional. If it is null then those function seeding operations that depend on having file headers are not run. The memory map argument is optional only if a memory map has already been attached to this partitioner object with the <a class="el" href="classPartitioner.html#3c46fdd567c72ad245ab7e2e6351a9d8">set_map()</a> method. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l03891">3891</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l03933">add_instructions()</a>, <a class="el" href="Partitioner_8C-source.html#l02808">analyze_cfg()</a>, <a class="el" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48ce4246f5b8a05009b72d727573c3f9a28">SgAsmBlock::BLK_GRAPH1</a>, <a class="el" href="Partitioner_8C-source.html#l03705">build_ast()</a>, <a class="el" href="Partitioner_8h-source.html#l01798">disassembler</a>, <a class="el" href="Partitioner_8h-source.html#l00498">get_map()</a>, <a class="el" href="Partitioner_8h-source.html#l01800">map</a>, <a class="el" href="Partitioner_8C-source.html#l03245">post_cfg()</a>, <a class="el" href="Partitioner_8C-source.html#l02569">pre_cfg()</a>, <a class="el" href="Partitioner_8h-source.html#l01801">ro_map</a>, and <a class="el" href="Partitioner_8C-source.html#l00174">set_map()</a>.
<p>
Referenced by <a class="el" href="Disassembler_8C-source.html#l00191">Disassembler::disassemble()</a>.
</div>
</div><p>
<a class="anchor" name="ec5dbc10e96f8e3d26f58294945c2f9d"></a><!-- doxytag: member="Partitioner::partition" ref="ec5dbc10e96f8e3d26f58294945c2f9d" args="(SgAsmInterpretation *, Disassembler *, MemoryMap *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> * Partitioner::partition           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDisassembler.html">Disassembler</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMemoryMap.html">MemoryMap</a> *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Top-level function to run the partitioner, calling the specified disassembler as necessary to generate instructions. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l03920">3920</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l02808">analyze_cfg()</a>, <a class="el" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48ce4246f5b8a05009b72d727573c3f9a28">SgAsmBlock::BLK_GRAPH1</a>, <a class="el" href="Partitioner_8C-source.html#l03705">build_ast()</a>, <a class="el" href="Partitioner_8h-source.html#l01798">disassembler</a>, <a class="el" href="Partitioner_8C-source.html#l03245">post_cfg()</a>, <a class="el" href="Partitioner_8C-source.html#l02569">pre_cfg()</a>, and <a class="el" href="Partitioner_8C-source.html#l00174">set_map()</a>.
</div>
</div><p>
<a class="anchor" name="d64a57bb09ffe9557d1ad51f2ca30bf8"></a><!-- doxytag: member="Partitioner::clear" ref="d64a57bb09ffe9557d1ad51f2ca30bf8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset partitioner to initial conditions by discarding all instructions, basic blocks, functions, and configuration file settings and definitions. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00584">584</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01007">aggregate_mean</a>, <a class="el" href="Partitioner_8h-source.html#l01008">aggregate_variance</a>, <a class="el" href="Partitioner_8h-source.html#l01804">basic_blocks</a>, <a class="el" href="Partitioner_8h-source.html#l01814">block_config</a>, <a class="el" href="Partitioner_8h-source.html#l00568">clear_disassembler_errors()</a>, <a class="el" href="Partitioner_8h-source.html#l01009">code_criteria</a>, <a class="el" href="Partitioner_8h-source.html#l01807">data_blocks</a>, <a class="el" href="Partitioner_8h-source.html#l01805">functions</a>, and <a class="el" href="Partitioner_8h-source.html#l01799">insns</a>.
<p>
Referenced by <a class="el" href="Partitioner_8h-source.html#l00413">~Partitioner()</a>.
</div>
</div><p>
<a class="anchor" name="7adb0e1cb0359b14d928ad1d7ffd0a03"></a><!-- doxytag: member="Partitioner::load_config" ref="7adb0e1cb0359b14d928ad1d7ffd0a03" args="(const std::string &amp;filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::load_config           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>filename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Loads the specified configuration file. 
<p>
This should be called before any of the partitioning functions (such as <a class="el" href="classPartitioner.html#d8d4292001cbf0490676f8bc148c1a24">partition()</a>). If an error occurs then <a class="el" href="classPartitioner_1_1IPDParser_1_1Exception.html">Partitioner::IPDParser::Exception</a> error is thrown. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00627">627</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
Referenced by <a class="el" href="Disassembler_8C-source.html#l00207">Disassembler::disassembleInterpretation()</a>.
</div>
</div><p>
<a class="anchor" name="33a895f0f8724262d24404a67be98a2f"></a><!-- doxytag: member="Partitioner::add_instructions" ref="33a895f0f8724262d24404a67be98a2f" args="(const Disassembler::InstructionMap &amp;insns)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::add_instructions           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">Disassembler::InstructionMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>insns</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds additional instructions to be processed. 
<p>
New instructions are only added at addresses that don't already have an instruction. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l03933">3933</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03891">partition()</a>.
</div>
</div><p>
<a class="anchor" name="45a9d059b28d95033aa343fd4689ac0e"></a><!-- doxytag: member="Partitioner::get_instructions" ref="45a9d059b28d95033aa343fd4689ac0e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">Disassembler::InstructionMap</a> Partitioner::get_instructions           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the list of all instructions. 
<p>
This includes instructions that were added with <a class="el" href="classPartitioner.html#33a895f0f8724262d24404a67be98a2f">add_instructions()</a>, instructions added by a passive <a class="el" href="classPartitioner.html#d8d4292001cbf0490676f8bc148c1a24">partition()</a> call, and instructions added by an active partitioner. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l03942">3942</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
</div>
</div><p>
<a class="anchor" name="72f6b3bb0baf5d2978b27174626ad1b4"></a><!-- doxytag: member="Partitioner::get_disassembler_errors" ref="72f6b3bb0baf5d2978b27174626ad1b4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDisassembler.html#30c51578d70dfc05fb46047867ceadcd">Disassembler::BadMap</a>&amp; Partitioner::get_disassembler_errors           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the list of disassembler errors. 
<p>
Only active partitioners accumulate this information since only active partitioners call the disassembler to obtain instructions. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00560">560</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01802">bad_insns</a>.
</div>
</div><p>
<a class="anchor" name="f993c26936e910eedaa5b433a74e70b3"></a><!-- doxytag: member="Partitioner::clear_disassembler_errors" ref="f993c26936e910eedaa5b433a74e70b3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::clear_disassembler_errors           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears errors from the disassembler. 
<p>
This might be useful in order to cause the partitioner to call the disassembler again for certain addresses. Normally, if the partitioner fails to obtain an instruction at a particular address it remembers the failure and does not try again. The bad map is also cleared by the <a class="el" href="classPartitioner.html#d64a57bb09ffe9557d1ad51f2ca30bf8">Partitioner::clear()</a> method, which clears various other things in addition. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00568">568</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01802">bad_insns</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l00584">clear()</a>.
</div>
</div><p>
<a class="anchor" name="1dcdd3e0993256cd5ed93fd4d178679f"></a><!-- doxytag: member="Partitioner::find_instruction" ref="1dcdd3e0993256cd5ed93fd4d178679f" args="(rose_addr_t, bool create=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPartitioner_1_1Instruction.html">Partitioner::Instruction</a> * Partitioner::find_instruction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>create</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds an instruction at the specified address. 
<p>
If the partitioner is operating in active mode and <code>create</code> is true, then the disassembler will be invoked if necessary to obtain the instruction. This function returns the null pointer if no instruction is available. If the disassembler was called and threw an exception, then we catch the exception and add it to the bad instruction list. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00869">869</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01802">bad_insns</a>, <a class="el" href="classDisassembler.html#d765ce924af663d75b9ce5915d658d7c">Disassembler::disassembleOne()</a>, <a class="el" href="Partitioner_8h-source.html#l01798">disassembler</a>, <a class="el" href="Partitioner_8h-source.html#l01799">insns</a>, and <a class="el" href="Partitioner_8h-source.html#l01800">map</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02680">discover_blocks()</a>, <a class="el" href="Partitioner_8C-source.html#l00904">find_bb_containing()</a>, <a class="el" href="Partitioner_8C-source.html#l03613">fixup_pointers()</a>, <a class="el" href="Partitioner_8C-source.html#l01204">mark_eh_frames()</a>, <a class="el" href="Partitioner_8C-source.html#l01227">mark_elf_plt_entries()</a>, <a class="el" href="Partitioner_8C-source.html#l01192">mark_entry_targets()</a>, <a class="el" href="Partitioner_8C-source.html#l01307">mark_func_symbols()</a>, <a class="el" href="Partitioner_8C-source.html#l02510">name_import_entries()</a>, <a class="el" href="Partitioner_8C-source.html#l02431">name_plt_entries()</a>, <a class="el" href="Partitioner_8C-source.html#l02334">Partitioner::FindPostFunctionInsns::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l02213">Partitioner::FindThunkTables::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l02121">Partitioner::FindThunks::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l01863">Partitioner::FindInsnPadding::operator()()</a>, and <a class="el" href="Partitioner_8C-source.html#l00345">successors()</a>.
</div>
</div><p>
<a class="anchor" name="8b679c9a4b6fb7a7f4f45900d10819c0"></a><!-- doxytag: member="Partitioner::discard" ref="8b679c9a4b6fb7a7f4f45900d10819c0" args="(Instruction *, bool discard_entire_block=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPartitioner_1_1Instruction.html">Partitioner::Instruction</a> * Partitioner::discard           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>discard_entire_block</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Drop an instruction from consideration. 
<p>
If the instruction is the beginning of a basic block then drop the entire basic block, returning its subsequent instructions back to the (implied) list of free instructions. If the instruction is in the middle of a basic block, then either drop the entire basic block, or truncate it at the specified instruction depending on whether discard_entire_block is true or false.<p>
This method always returns the null pointer. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00824">824</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00904">find_bb_containing()</a>, <a class="el" href="Partitioner_8h-source.html#l00143">Partitioner::Instruction::get_address()</a>, <a class="el" href="Partitioner_8h-source.html#l01799">insns</a>, <a class="el" href="Partitioner_8h-source.html#l00235">Partitioner::BasicBlock::insns</a>, and <a class="el" href="Partitioner_8C-source.html#l00659">truncate()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l01863">Partitioner::FindInsnPadding::operator()()</a>, and <a class="el" href="Partitioner_8C-source.html#l00400">pops_return_address()</a>.
</div>
</div><p>
<a class="anchor" name="1ea949dc4beeb1444894ed978931e7b2"></a><!-- doxytag: member="Partitioner::discard" ref="1ea949dc4beeb1444894ed978931e7b2" args="(BasicBlock *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPartitioner_1_1BasicBlock.html">Partitioner::BasicBlock</a> * Partitioner::discard           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Drop a basic block from the partitioner. 
<p>
The specified basic block, which must not belong to any function, is removed from the <a class="el" href="classPartitioner.html">Partitioner</a>, deleted, and its instructions all returned to the (implied) list of free instructions. This function always returns the null pointer. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00845">845</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00465">Partitioner::BasicBlock::address()</a>, <a class="el" href="Partitioner_8h-source.html#l01804">basic_blocks</a>, <a class="el" href="Partitioner_8C-source.html#l00503">Partitioner::BasicBlock::clear_data_blocks()</a>, <a class="el" href="Partitioner_8h-source.html#l00238">Partitioner::BasicBlock::function</a>, and <a class="el" href="Partitioner_8h-source.html#l00235">Partitioner::BasicBlock::insns</a>.
</div>
</div><p>
<a class="anchor" name="91e9b8ad59e4657d6f3dbece95752a4e"></a><!-- doxytag: member="Partitioner::add_function" ref="91e9b8ad59e4657d6f3dbece95752a4e" args="(rose_addr_t entry_va, unsigned reasons, std::string name=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPartitioner_1_1Function.html">Partitioner::Function</a> * Partitioner::add_function           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td>
          <td class="paramname"> <em>entry_va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>reasons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>name</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a new function definition to the partitioner. 
<p>
New functions can be added at any time, including during the <a class="el" href="classPartitioner.html#19725656eaa83118d75bdd77c617cef4">analyze_cfg()</a> call. When this method is called with an entry_va for an existing function, the specified <code>reasons</code> will be merged with the existing function, and the existing function will be given the specified name if it has none. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00999">999</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l00335">Partitioner::Function::entry_va</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852ccb6d9cc5789fcc0c98bb6e6894831228">SgAsmFunction::FUNC_MISCMASK</a>, <a class="el" href="Partitioner_8h-source.html#l01805">functions</a>, <a class="el" href="Partitioner_8h-source.html#l00331">Partitioner::Function::name</a>, and <a class="el" href="Partitioner_8h-source.html#l00330">Partitioner::Function::reason</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03705">build_ast()</a>, <a class="el" href="Partitioner_8C-source.html#l02990">detach_thunk()</a>, <a class="el" href="Partitioner_8C-source.html#l02680">discover_blocks()</a>, <a class="el" href="Partitioner_8C-source.html#l01524">mark_call_insns()</a>, <a class="el" href="Partitioner_8C-source.html#l01204">mark_eh_frames()</a>, <a class="el" href="Partitioner_8C-source.html#l01227">mark_elf_plt_entries()</a>, <a class="el" href="Partitioner_8C-source.html#l01192">mark_entry_targets()</a>, <a class="el" href="Partitioner_8C-source.html#l01497">mark_func_patterns()</a>, <a class="el" href="Partitioner_8C-source.html#l01307">mark_func_symbols()</a>, <a class="el" href="Partitioner_8C-source.html#l02213">Partitioner::FindThunkTables::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l02176">Partitioner::FindInterPadFunctions::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l02121">Partitioner::FindThunks::operator()()</a>, and <a class="el" href="Partitioner_8C-source.html#l01863">Partitioner::FindInsnPadding::operator()()</a>.
</div>
</div><p>
<a class="anchor" name="e9238319a8257ac90435cce78d96dc9d"></a><!-- doxytag: member="Partitioner::find_function" ref="e9238319a8257ac90435cce78d96dc9d" args="(rose_addr_t entry_va)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPartitioner_1_1Function.html">Partitioner::Function</a> * Partitioner::find_function           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td>
          <td class="paramname"> <em>entry_va</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up a function by address. 
<p>
Returns the function pointer if found, the null pointer if not found. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00990">990</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01805">functions</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02808">analyze_cfg()</a>, and <a class="el" href="Partitioner_8C-source.html#l02680">discover_blocks()</a>.
</div>
</div><p>
<a class="anchor" name="d94b1f74e750728b71d1726330786506"></a><!-- doxytag: member="Partitioner::build_ast" ref="d94b1f74e750728b71d1726330786506" args="(SgAsmInterpretation *interp=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> * Partitioner::build_ast           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&nbsp;</td>
          <td class="paramname"> <em>interp</em> = <code>NULL</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds the AST describing all the functions. 
<p>
The return value is an <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> node that points to a list of <a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> nodes (the functions), each of which points to a list of <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> nodes (the basic blocks). Any basic blocks that were not assigned to a function by the <a class="el" href="classPartitioner.html">Partitioner</a> will be added to a function named "***uncategorized blocks***" whose entry address will be the address of the lowest instruction, and whose reasons for existence will include the <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c617301fe6a598b9c4afbde0aebcc8ad5">SgAsmFunction::FUNC_LEFTOVERS</a> bit. However, if the FUNC_LEFTOVERS bit is not turned on (see <a class="el" href="classPartitioner.html#e52ab7e0fa20592ae95f858404b3234b">set_search()</a>) then uncategorized blocks will not appear in the AST.<p>
If an interpretation is supplied, then it will be used to obtain information about where various file sections are mapped into memory. This mapping is used to fix-up various kinds of pointers in the instructions to make them relative to a file section. For instance, a pointer into the ".bss" section will be made relative to the beginning of that section. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l03705">3705</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00999">add_function()</a>, <a class="el" href="Partitioner_8C-source.html#l00683">append()</a>, <a class="el" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48c7545b24fc1b6a1b274ed67a17e074707">SgAsmBlock::BLK_LEFTOVERS</a>, <a class="el" href="Partitioner_8C-source.html#l00512">Partitioner::Function::clear_basic_blocks()</a>, <a class="el" href="Partitioner_8C-source.html#l00521">Partitioner::Function::clear_data_blocks()</a>, <a class="el" href="rangemap_8h-source.html#l01133">RangeMap&lt; R, T &gt;::contains()</a>, <a class="el" href="Partitioner_8h-source.html#l00335">Partitioner::Function::entry_va</a>, <a class="el" href="Partitioner_8C-source.html#l00904">find_bb_containing()</a>, <a class="el" href="Partitioner_8C-source.html#l03564">fixup_cfg_edges()</a>, <a class="el" href="Partitioner_8C-source.html#l03613">fixup_pointers()</a>, <a class="el" href="Partitioner_8h-source.html#l01809">func_heuristics</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c617301fe6a598b9c4afbde0aebcc8ad5">SgAsmFunction::FUNC_LEFTOVERS</a>, <a class="el" href="Partitioner_8C-source.html#l03383">function_extent()</a>, <a class="el" href="Partitioner_8h-source.html#l01805">functions</a>, and <a class="el" href="classSgAsmBlock.html#c19627b98d9cee481b9c533ad21ac755">SgAsmBlock::get_statementList()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03768">build_ast()</a>, and <a class="el" href="Partitioner_8C-source.html#l03891">partition()</a>.
</div>
</div><p>
<a class="anchor" name="416452ab2d4ffc7df788c078421c4848"></a><!-- doxytag: member="Partitioner::fixup_cfg_edges" ref="416452ab2d4ffc7df788c078421c4848" args="(SgNode *ast)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::fixup_cfg_edges           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>ast</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update control flow graph edge nodes. 
<p>
This method traverses the specified AST and updates any edge nodes so their block pointers point to actual blocks rather than just containing virtual addresses. The update only happens for edges that don't already have a node pointer. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l03564">3564</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">SgAsmStatement::get_address()</a>, <a class="el" href="classSgAsmBlock.html#c19627b98d9cee481b9c533ad21ac755">SgAsmBlock::get_statementList()</a>, <a class="el" href="classSgAsmBlock.html#0e798d793c22e6d6a63a526b6a18e7ce">SgAsmBlock::get_successors()</a>, <a class="el" href="Cxx__Grammar_8h.html#0f21c6b7a4aede1900e16a5122233a83">isSgAsmBlock()</a>, <a class="el" href="Partitioner_8C-source.html#l00027">isSgAsmInstruction()</a>, and <a class="el" href="Cxx__Grammar_8h.html#59f7fee88581c4dd75f5fb25dbefa29edefb5d09673c144dc5b4dc177e278696">preorder</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03705">build_ast()</a>.
</div>
</div><p>
<a class="anchor" name="ea4ea9a5b5238c91b86b226fb04708c1"></a><!-- doxytag: member="Partitioner::fixup_pointers" ref="ea4ea9a5b5238c91b86b226fb04708c1" args="(SgNode *ast, SgAsmInterpretation *interp=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::fixup_pointers           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>ast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&nbsp;</td>
          <td class="paramname"> <em>interp</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Updates pointers inside instructions. 
<p>
This method traverses each instruction in the specified AST and looks for integer value expressions that that have no base node (i.e., those that have only an absolute value). For each such value it finds, it tries to determine if that value points to code or data. Code pointers are made relative to the instruction or function (for function calls) to which they point; data pointers are made relative to the data to which they point.<p>
The specified interpretation is only used to obtain a list of all mapped sections. The sections are used to determine whether a value is a data pointer even if it doesn't point to any specific data that was discovered during disassembly.<p>
This method is called by <a class="el" href="classPartitioner.html#d94b1f74e750728b71d1726330786506">build_ast()</a>, but can also be called explicitly. Only pointers that are not already relative to some object are affected. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l03613">3613</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l00139">Partitioner::Instruction::bblock</a>, <a class="el" href="GenericFile_8C-source.html#l00583">SgAsmGenericFile::best_section_by_va()</a>, <a class="el" href="Partitioner_8C-source.html#l03488">datablock_extent()</a>, <a class="el" href="Partitioner_8C-source.html#l00869">find_instruction()</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c617301fe6a598b9c4afbde0aebcc8ad5">SgAsmFunction::FUNC_LEFTOVERS</a>, <a class="el" href="Partitioner_8h-source.html#l00238">Partitioner::BasicBlock::function</a>, <a class="el" href="Expressions_8C-source.html#l00287">SgAsmIntegerValueExpression::get_absolute_value()</a>, <a class="el" href="Partitioner_8h-source.html#l00143">Partitioner::Instruction::get_address()</a>, <a class="el" href="classSgAsmIntegerValueExpression.html#03a85d1a7c86cb075adaef1aaf77d4aa">SgAsmIntegerValueExpression::get_base_node()</a>, <a class="el" href="classSgAsmFunction.html#6edeeb78e01e2af6e59a5c6f7b0088af">SgAsmFunction::get_entry_va()</a>, <a class="el" href="classSgAsmGenericHeaderList.html#c3d9878c64af6c90e2d52988f8578b36">SgAsmGenericHeaderList::get_headers()</a>, <a class="el" href="classSgAsmInterpretation.html#5d116938aaa9da9f3e27ca598965c77b">SgAsmInterpretation::get_headers()</a>, <a class="el" href="classSgAsmGenericSection.html#a7213f04087f77affd6b85ef55dfc864">SgAsmGenericSection::get_mapped_xperm()</a>, <a class="el" href="Partitioner_8C-source.html#l00027">isSgAsmInstruction()</a>, <a class="el" href="Cxx__Grammar_8h.html#1f84547c1be282455b89ec1ef75f834d">isSgAsmIntegerValueExpression()</a>, <a class="el" href="Expressions_8C-source.html#l00266">SgAsmIntegerValueExpression::make_relative_to()</a>, <a class="el" href="Partitioner_8h-source.html#l00138">Partitioner::Instruction::node</a>, and <a class="el" href="Partitioner_8h-source.html#l00330">Partitioner::Function::reason</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03705">build_ast()</a>.
</div>
</div><p>
<a class="anchor" name="e28a2d008b984feffc35c4945b0cf496"></a><!-- doxytag: member="Partitioner::new_region_stats" ref="e28a2d008b984feffc35c4945b0cf496" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPartitioner_1_1RegionStats.html">RegionStats</a>* Partitioner::new_region_stats           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new region statistics object. 
<p>
We do it this way because the statistics class is closely tied to the partitioner class, but users might want to augment the statistics. The <a class="el" href="classPartitioner_1_1RegionStats.html">RegionStats</a> is a virtual class as is this creator. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00890">890</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
</div>
</div><p>
<a class="anchor" name="54cffacaad0e5f8d0eb9195a9f9ba7bb"></a><!-- doxytag: member="Partitioner::new_code_criteria" ref="54cffacaad0e5f8d0eb9195a9f9ba7bb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPartitioner_1_1CodeCriteria.html">CodeCriteria</a>* Partitioner::new_code_criteria           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new criteria object. 
<p>
This allows a user to derive a new class from <a class="el" href="classPartitioner_1_1CodeCriteria.html">CodeCriteria</a> and have that class be used by the partitioner. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00897">897</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02036">Partitioner::FindFunctionFragments::operator()()</a>.
</div>
</div><p>
<a class="anchor" name="b890b3323cad88efe757daae581beb7c"></a><!-- doxytag: member="Partitioner::new_code_criteria" ref="b890b3323cad88efe757daae581beb7c" args="(const RegionStats *mean, const RegionStats *variance, double threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPartitioner_1_1CodeCriteria.html">CodeCriteria</a>* Partitioner::new_code_criteria           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPartitioner_1_1RegionStats.html">RegionStats</a> *&nbsp;</td>
          <td class="paramname"> <em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPartitioner_1_1RegionStats.html">RegionStats</a> *&nbsp;</td>
          <td class="paramname"> <em>variance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>threshold</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new criteria object. 
<p>
This allows a user to derive a new class from <a class="el" href="classPartitioner_1_1CodeCriteria.html">CodeCriteria</a> and have that class be used by the partitioner. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00900">900</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
</div>
</div><p>
<a class="anchor" name="a268f3ccba22f976fa0439a88e77594d"></a><!-- doxytag: member="Partitioner::region_statistics" ref="a268f3ccba22f976fa0439a88e77594d" args="(const ExtentMap &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPartitioner_1_1RegionStats.html">RegionStats</a>* Partitioner::region_statistics           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classExtentMap.html">ExtentMap</a> &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes various statistics over part of an address space. 
<p>
If no region is supplied then the statistics are calculated over the part of the <a class="el" href="classPartitioner.html">Partitioner</a> memory map that contains execute permission. The statistics are returned by argument so that subclasses have an easy way to augment them. 
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02036">Partitioner::FindFunctionFragments::operator()()</a>.
</div>
</div><p>
<a class="anchor" name="d743f90216a471e9a699f9beb4bfe44a"></a><!-- doxytag: member="Partitioner::region_statistics" ref="d743f90216a471e9a699f9beb4bfe44a" args="(Function *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPartitioner_1_1RegionStats.html">RegionStats</a>* Partitioner::region_statistics           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1Function.html">Function</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes various statistics over part of an address space. 
<p>
If no region is supplied then the statistics are calculated over the part of the <a class="el" href="classPartitioner.html">Partitioner</a> memory map that contains execute permission. The statistics are returned by argument so that subclasses have an easy way to augment them. 
</div>
</div><p>
<a class="anchor" name="07952b3805872c9992ce72c39083c9f9"></a><!-- doxytag: member="Partitioner::region_statistics" ref="07952b3805872c9992ce72c39083c9f9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPartitioner_1_1RegionStats.html">RegionStats</a>* Partitioner::region_statistics           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes various statistics over part of an address space. 
<p>
If no region is supplied then the statistics are calculated over the part of the <a class="el" href="classPartitioner.html">Partitioner</a> memory map that contains execute permission. The statistics are returned by argument so that subclasses have an easy way to augment them. 
</div>
</div><p>
<a class="anchor" name="b611787b2c6ef70f765031acde40fdd2"></a><!-- doxytag: member="Partitioner::aggregate_statistics" ref="b611787b2c6ef70f765031acde40fdd2" args="(bool do_variance=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPartitioner_1_1RegionStats.html">RegionStats</a>* Partitioner::aggregate_statistics           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>do_variance</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes aggregate statistics over all known functions. 
<p>
This method computes region statistics for each individual function (except padding and leftovers) and obtains an average and, optionally, the variance. The average and variance are cached in the partitioner and can be retrieved by <a class="el" href="classPartitioner.html#819257a6ef08bdc22af30adf6147825c">get_aggregate_mean()</a> and <a class="el" href="classPartitioner.html#6618693bfecf89c45fdf92a3b4b72cf3">get_aggregate_variance()</a>. This method also returns the mean regardless of whether its cached. The values are not recomputed if they are already cached; the cache can be cleared with clear_aggregate_cache(). 
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02036">Partitioner::FindFunctionFragments::operator()()</a>, and <a class="el" href="Partitioner_8C-source.html#l03245">post_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="819257a6ef08bdc22af30adf6147825c"></a><!-- doxytag: member="Partitioner::get_aggregate_mean" ref="819257a6ef08bdc22af30adf6147825c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPartitioner_1_1RegionStats.html">RegionStats</a>* Partitioner::get_aggregate_mean           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accessors for cached aggregate statistics. 
<p>
If the partitioner has aggregated statistics over known functions, then that information is available by this method: <a class="el" href="classPartitioner.html#819257a6ef08bdc22af30adf6147825c">get_aggregate_mean()</a> returns the average values over all functions, and <a class="el" href="classPartitioner.html#6618693bfecf89c45fdf92a3b4b72cf3">get_aggregate_variance()</a> returns the variance. The partitioner normally calculates this information immediately after performing the first CFG analysis, after most instructions are added to most functions, but before data blocks are added. A null pointer is returned if the information is not available. The user is allowed to modify the values, but should not free the objects. New values can be computed by clearing the cache (<a class="el" href="classPartitioner.html#adaa21925ebc452fcac317509cfe84d9">clear_aggregate_statistics()</a>) and then calling a function that computes them again, such as <a class="el" href="classPartitioner.html#b611787b2c6ef70f765031acde40fdd2">aggregate_statistics()</a> or <a class="el" href="classPartitioner.html#80a5af9330b230ed4d3819aa1e69b18d">is_code()</a>. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00929">929</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01007">aggregate_mean</a>.
</div>
</div><p>
<a class="anchor" name="6618693bfecf89c45fdf92a3b4b72cf3"></a><!-- doxytag: member="Partitioner::get_aggregate_variance" ref="6618693bfecf89c45fdf92a3b4b72cf3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPartitioner_1_1RegionStats.html">RegionStats</a>* Partitioner::get_aggregate_variance           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accessors for cached aggregate statistics. 
<p>
If the partitioner has aggregated statistics over known functions, then that information is available by this method: <a class="el" href="classPartitioner.html#819257a6ef08bdc22af30adf6147825c">get_aggregate_mean()</a> returns the average values over all functions, and <a class="el" href="classPartitioner.html#6618693bfecf89c45fdf92a3b4b72cf3">get_aggregate_variance()</a> returns the variance. The partitioner normally calculates this information immediately after performing the first CFG analysis, after most instructions are added to most functions, but before data blocks are added. A null pointer is returned if the information is not available. The user is allowed to modify the values, but should not free the objects. New values can be computed by clearing the cache (<a class="el" href="classPartitioner.html#adaa21925ebc452fcac317509cfe84d9">clear_aggregate_statistics()</a>) and then calling a function that computes them again, such as <a class="el" href="classPartitioner.html#b611787b2c6ef70f765031acde40fdd2">aggregate_statistics()</a> or <a class="el" href="classPartitioner.html#80a5af9330b230ed4d3819aa1e69b18d">is_code()</a>. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00930">930</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01008">aggregate_variance</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02036">Partitioner::FindFunctionFragments::operator()()</a>, and <a class="el" href="Partitioner_8C-source.html#l03245">post_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="adaa21925ebc452fcac317509cfe84d9"></a><!-- doxytag: member="Partitioner::clear_aggregate_statistics" ref="adaa21925ebc452fcac317509cfe84d9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Partitioner::clear_aggregate_statistics           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Causes the partitioner to forget statistics. 
<p>
The statistics aggregated over known functions are discarded, and subsequent calls to <a class="el" href="classPartitioner.html#819257a6ef08bdc22af30adf6147825c">get_aggregate_mean()</a> and <a class="el" href="classPartitioner.html#6618693bfecf89c45fdf92a3b4b72cf3">get_aggregate_variance()</a> will return null pointers until the data is recalculated (if ever). 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00936">936</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01007">aggregate_mean</a>, and <a class="el" href="Partitioner_8h-source.html#l01008">aggregate_variance</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03245">post_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="6d1d5da1e3c1b3d4f9fb9e63be723c91"></a><!-- doxytag: member="Partitioner::count_kinds" ref="6d1d5da1e3c1b3d4f9fb9e63be723c91" args="(const InstructionMap &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Partitioner::count_kinds           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPartitioner.html#cff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a> &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Counts the number of distinct kinds of instructions. 
<p>
The counting is based on the instructions' get_kind() method. 
</div>
</div><p>
<a class="anchor" name="2678589961c331f098f409fb8a9432cd"></a><!-- doxytag: member="Partitioner::count_kinds" ref="2678589961c331f098f409fb8a9432cd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Partitioner::count_kinds           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Counts the number of distinct kinds of instructions. 
<p>
The counting is based on the instructions' get_kind() method. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00944">944</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l00950">count_privileged()</a>, and <a class="el" href="Partitioner_8h-source.html#l01799">insns</a>.
</div>
</div><p>
<a class="anchor" name="38c4d8fa97d420b1d5ee00569471136d"></a><!-- doxytag: member="Partitioner::count_privileged" ref="38c4d8fa97d420b1d5ee00569471136d" args="(const InstructionMap &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Partitioner::count_privileged           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPartitioner.html#cff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a> &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Counts the number of privileged instructions. 
<p>
Such instructions are generally don't appear in normal code. 
</div>
</div><p>
<a class="anchor" name="54f485a94d56cc3444d5b83a92c8809e"></a><!-- doxytag: member="Partitioner::count_privileged" ref="54f485a94d56cc3444d5b83a92c8809e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Partitioner::count_privileged           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Counts the number of privileged instructions. 
<p>
Such instructions are generally don't appear in normal code. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00950">950</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01799">insns</a>.
<p>
Referenced by <a class="el" href="Partitioner_8h-source.html#l00944">count_kinds()</a>, and <a class="el" href="Partitioner_8h-source.html#l00951">ratio_privileged()</a>.
</div>
</div><p>
<a class="anchor" name="a634ae377c966bab8ba4c093636955b2"></a><!-- doxytag: member="Partitioner::ratio_privileged" ref="a634ae377c966bab8ba4c093636955b2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double Partitioner::ratio_privileged           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Counts the number of privileged instructions. 
<p>
Such instructions are generally don't appear in normal code. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00951">951</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l00950">count_privileged()</a>, and <a class="el" href="Partitioner_8h-source.html#l01799">insns</a>.
</div>
</div><p>
<a class="anchor" name="250d10977fc2134480c49b88e08ffd46"></a><!-- doxytag: member="Partitioner::count_floating_point" ref="250d10977fc2134480c49b88e08ffd46" args="(const InstructionMap &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Partitioner::count_floating_point           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPartitioner.html#cff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a> &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Counts the number of floating point instructions. 
<p>

</div>
</div><p>
<a class="anchor" name="1b01910a0c4aa0a888585d02913259fc"></a><!-- doxytag: member="Partitioner::count_floating_point" ref="1b01910a0c4aa0a888585d02913259fc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Partitioner::count_floating_point           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Counts the number of floating point instructions. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00957">957</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01799">insns</a>.
<p>
Referenced by <a class="el" href="Partitioner_8h-source.html#l00958">ratio_floating_point()</a>.
</div>
</div><p>
<a class="anchor" name="ebcf2106ed8fed4d0e0c4c8b5d9737a5"></a><!-- doxytag: member="Partitioner::ratio_floating_point" ref="ebcf2106ed8fed4d0e0c4c8b5d9737a5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double Partitioner::ratio_floating_point           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Counts the number of floating point instructions. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00958">958</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l00957">count_floating_point()</a>, and <a class="el" href="Partitioner_8h-source.html#l01799">insns</a>.
</div>
</div><p>
<a class="anchor" name="723e4425779fdc6bec6dc132b70aae4e"></a><!-- doxytag: member="Partitioner::count_registers" ref="723e4425779fdc6bec6dc132b70aae4e" args="(const InstructionMap &amp;, double *mean=NULL, double *variance=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Partitioner::count_registers           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPartitioner.html#cff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>mean</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>variance</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Counts the number of register references. 
<p>
Returns the total number of register reference expressions, but the real value of this method is that it also computes the an average register reference size and variance. Register sizes are represented as a power of two in an attempt to weight common register sizes equally. In other words, a 16 bit program with a couple of 8 bit values should have a variance that's close to a similar sized 32-bit program with a couple of 16-bit values. 
<p>
Referenced by <a class="el" href="Partitioner_8h-source.html#l00968">count_registers()</a>, and <a class="el" href="Partitioner_8h-source.html#l00969">ratio_registers()</a>.
</div>
</div><p>
<a class="anchor" name="c18f17d2cd089802b9b44e10930b136e"></a><!-- doxytag: member="Partitioner::count_registers" ref="c18f17d2cd089802b9b44e10930b136e" args="(double *mean=NULL, double *variance=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Partitioner::count_registers           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>mean</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>variance</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Counts the number of register references. 
<p>
Returns the total number of register reference expressions, but the real value of this method is that it also computes the an average register reference size and variance. Register sizes are represented as a power of two in an attempt to weight common register sizes equally. In other words, a 16 bit program with a couple of 8 bit values should have a variance that's close to a similar sized 32-bit program with a couple of 16-bit values. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00968">968</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="classPartitioner.html#723e4425779fdc6bec6dc132b70aae4e">count_registers()</a>, and <a class="el" href="Partitioner_8h-source.html#l01799">insns</a>.
</div>
</div><p>
<a class="anchor" name="c9fa9c57392d17fd4037b19257b6041e"></a><!-- doxytag: member="Partitioner::ratio_registers" ref="c9fa9c57392d17fd4037b19257b6041e" args="(double *mean=NULL, double *variance=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double Partitioner::ratio_registers           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>mean</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>variance</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Counts the number of register references. 
<p>
Returns the total number of register reference expressions, but the real value of this method is that it also computes the an average register reference size and variance. Register sizes are represented as a power of two in an attempt to weight common register sizes equally. In other words, a 16 bit program with a couple of 8 bit values should have a variance that's close to a similar sized 32-bit program with a couple of 16-bit values. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00969">969</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="classPartitioner.html#723e4425779fdc6bec6dc132b70aae4e">count_registers()</a>, and <a class="el" href="Partitioner_8h-source.html#l01799">insns</a>.
</div>
</div><p>
<a class="anchor" name="b308df2f53d07d9213961c358110282b"></a><!-- doxytag: member="Partitioner::count_size_variance" ref="b308df2f53d07d9213961c358110282b" args="(const InstructionMap &amp;insns)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double Partitioner::count_size_variance           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPartitioner.html#cff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>insns</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the variance of instruction bit widths. 
<p>
The variance is computed over the instruction size, the address size, and the operand size. The sizes 16-, 32-, and 64-bit are mapped to the integers 0, 1, and 2 respectively and the mean is computed. The variance is the sum of squares of the difference between each data point and the mean. Returns NAN if the instruction map is empty. Most valid code has a variance of less than 0.05. 
</div>
</div><p>
<a class="anchor" name="0ced79f385b55276035b5712d2620a76"></a><!-- doxytag: member="Partitioner::count_size_variance" ref="0ced79f385b55276035b5712d2620a76" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double Partitioner::count_size_variance           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the variance of instruction bit widths. 
<p>
The variance is computed over the instruction size, the address size, and the operand size. The sizes 16-, 32-, and 64-bit are mapped to the integers 0, 1, and 2 respectively and the mean is computed. The variance is the sum of squares of the difference between each data point and the mean. Returns NAN if the instruction map is empty. Most valid code has a variance of less than 0.05. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l00980">980</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01799">insns</a>.
</div>
</div><p>
<a class="anchor" name="80a5af9330b230ed4d3819aa1e69b18d"></a><!-- doxytag: member="Partitioner::is_code" ref="80a5af9330b230ed4d3819aa1e69b18d" args="(const ExtentMap &amp;region, double *raw_vote_ptr=NULL, std::ostream *debug=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Partitioner::is_code           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classExtentMap.html">ExtentMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>raw_vote_ptr</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&nbsp;</td>
          <td class="paramname"> <em>debug</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if a region contains code. 
<p>
The determination is made by computing aggregate statistics over each of the functions that are already known, then building a <a class="el" href="classPartitioner_1_1CodeCriteria.html">CodeCriteria</a> object. The same analysis is run over the region in question and the compared with the <a class="el" href="classPartitioner_1_1CodeCriteria.html">CodeCriteria</a> object. The criteria is then discarded.<p>
If the partitioner's <a class="el" href="classPartitioner.html#819257a6ef08bdc22af30adf6147825c">get_aggregate_mean()</a> and <a class="el" href="classPartitioner.html#6618693bfecf89c45fdf92a3b4b72cf3">get_aggregate_variance()</a> return non-null values, then those statistics are used in favor of computing new ones. If new statistics are computed, they will be cached for those methods to return later.<p>
If a raw_vote_ptr is supplied, then upon return it will hold a value between zero and one, inclusive, which is the weighted average of the votes from the individual analyses. The raw vote is the value compared against the code criteria threshold to obtain a Boolean result. 
</div>
</div><p>
<a class="anchor" name="56c16ee96129976b670fb0a49a1ce91f"></a><!-- doxytag: member="Partitioner::get_code_criteria" ref="56c16ee96129976b670fb0a49a1ce91f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPartitioner_1_1CodeCriteria.html">CodeCriteria</a>* Partitioner::get_code_criteria           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accessors for code criteria. 
<p>
A <a class="el" href="classPartitioner_1_1CodeCriteria.html">CodeCriteria</a> object can be associated with the <a class="el" href="classPartitioner.html">Partitioner</a>, in which case the partitioner does not compute statistics over the known functions, but rather uses the code criteria directly. The caller is reponsible for allocating and freeing the criteria. If no criteria is supplied, then one is created as necessary by calling <a class="el" href="classPartitioner.html#54cffacaad0e5f8d0eb9195a9f9ba7bb">new_code_criteria()</a> and passing it the average and variance computed over all the functions (excluding leftovers and padding) or use the values cached in the partitioner. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01002">1002</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01009">code_criteria</a>.
</div>
</div><p>
<a class="anchor" name="b83a528886f91bd791e89b4fa8fee83f"></a><!-- doxytag: member="Partitioner::set_code_criteria" ref="b83a528886f91bd791e89b4fa8fee83f" args="(CodeCriteria *cc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Partitioner::set_code_criteria           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1CodeCriteria.html">CodeCriteria</a> *&nbsp;</td>
          <td class="paramname"> <em>cc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accessors for code criteria. 
<p>
A <a class="el" href="classPartitioner_1_1CodeCriteria.html">CodeCriteria</a> object can be associated with the <a class="el" href="classPartitioner.html">Partitioner</a>, in which case the partitioner does not compute statistics over the known functions, but rather uses the code criteria directly. The caller is reponsible for allocating and freeing the criteria. If no criteria is supplied, then one is created as necessary by calling <a class="el" href="classPartitioner.html#54cffacaad0e5f8d0eb9195a9f9ba7bb">new_code_criteria()</a> and passing it the average and variance computed over all the functions (excluding leftovers and padding) or use the values cached in the partitioner. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01003">1003</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01009">code_criteria</a>.
</div>
</div><p>
<a class="anchor" name="128338b3c819f629c68058ca40545c18"></a><!-- doxytag: member="Partitioner::scan_contiguous_insns" ref="128338b3c819f629c68058ca40545c18" args="(InstructionMap insns, InsnRangeCallbacks &amp;cblist, Instruction *insn_prev, Instruction *insn_end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::scan_contiguous_insns           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner.html#cff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a>&nbsp;</td>
          <td class="paramname"> <em>insns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classROSE__Callbacks_1_1List.html">InsnRangeCallbacks</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cblist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a> *&nbsp;</td>
          <td class="paramname"> <em>insn_prev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a> *&nbsp;</td>
          <td class="paramname"> <em>insn_end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scans contiguous sequences of instructions. 
<p>
The specified callbacks are invoked for each contiguous sequence of instructions in the specified instruction map. At each iteration of the loop, we choose the instruction with the lowest address and the subsequent instructions that are contiguous in memory, build up the callback argument list, invoke the callbacks on the list, and remove those instructions from consideration by subsequent iterations of the loop.<p>
The callback arguments are built from the supplied values of <code>insn_prev</code> and <code>insn_end</code>. The <code>insn_begin</code> member is the instruction with the lowest address in this iteration and <code>ninsns</code> is the number of contiguous instructions. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l01539">1539</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="callbacks_8h-source.html#l00269">ROSE_Callbacks::List&lt; T &gt;::apply()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8h-source.html#l01071">scan_contiguous_insns()</a>, and <a class="el" href="Partitioner_8C-source.html#l01560">scan_unassigned_insns()</a>.
</div>
</div><p>
<a class="anchor" name="d76daaae13e84b22b42098fc1a58641f"></a><!-- doxytag: member="Partitioner::scan_contiguous_insns" ref="d76daaae13e84b22b42098fc1a58641f" args="(const InstructionMap &amp;insns, InsnRangeCallback *callback, Instruction *insn_prev, Instruction *insn_end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::scan_contiguous_insns           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPartitioner.html#cff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>insns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1InsnRangeCallback.html">InsnRangeCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a> *&nbsp;</td>
          <td class="paramname"> <em>insn_prev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a> *&nbsp;</td>
          <td class="paramname"> <em>insn_end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scans contiguous sequences of instructions. 
<p>
The specified callbacks are invoked for each contiguous sequence of instructions in the specified instruction map. At each iteration of the loop, we choose the instruction with the lowest address and the subsequent instructions that are contiguous in memory, build up the callback argument list, invoke the callbacks on the list, and remove those instructions from consideration by subsequent iterations of the loop.<p>
The callback arguments are built from the supplied values of <code>insn_prev</code> and <code>insn_end</code>. The <code>insn_begin</code> member is the instruction with the lowest address in this iteration and <code>ninsns</code> is the number of contiguous instructions. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01071">1071</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l01539">scan_contiguous_insns()</a>.
</div>
</div><p>
<a class="anchor" name="296180568b4a21d4435f264a05f1837f"></a><!-- doxytag: member="Partitioner::scan_unassigned_insns" ref="296180568b4a21d4435f264a05f1837f" args="(InsnRangeCallbacks &amp;callbacks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::scan_unassigned_insns           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classROSE__Callbacks_1_1List.html">InsnRangeCallbacks</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callbacks</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scans ranges of unassigned instructions. 
<p>
Scans through the list of existing instructions that are not assigned to any function and invokes all of the specified callbacks on each range of such instructions. The ranges of unassigned instructions are not necessarily contiguous or non-overlapping but are bounded by the <code>insn_begin</code> (inclusive) and <code>insn_end</code> (exclusive, or null) callback arguments. The callbacks are invoked via the <a class="el" href="classPartitioner.html#128338b3c819f629c68058ca40545c18">scan_contiguous_insns()</a> method with a different <code>insn_begin</code> for each call.<p>
Callbacks are allowed to disassemble additional instructions and/or assign/break associations between instructions and functions. Only the instructions that are already disassembled at the beginning of this call are considered by the iterators, but the instruction/function associations may change during the iteration.<p>
All callbacks should honor their "enabled" argument and do nothing if it is clear. This feature is used by some of the other instruction scanning methods to filter out certain ranges of instructions. For instance, the <a class="el" href="classPartitioner.html#6d6f280eb993c9ec09c0b79d1ae790f7">scan_intrafunc_insns()</a> will set "enabled" to true only for ranges of unassigned instructions whose closest surrounding assigned instructions both belong to the same function. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l01560">1560</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="callbacks_8h-source.html#l00107">ROSE_Callbacks::List&lt; T &gt;::empty()</a>, <a class="el" href="Partitioner_8C-source.html#l00904">find_bb_containing()</a>, <a class="el" href="Partitioner_8h-source.html#l00238">Partitioner::BasicBlock::function</a>, and <a class="el" href="Partitioner_8C-source.html#l01539">scan_contiguous_insns()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03245">post_cfg()</a>, <a class="el" href="Partitioner_8C-source.html#l01591">scan_interfunc_insns()</a>, <a class="el" href="Partitioner_8C-source.html#l01618">scan_intrafunc_insns()</a>, and <a class="el" href="Partitioner_8h-source.html#l01095">scan_unassigned_insns()</a>.
</div>
</div><p>
<a class="anchor" name="36686cdb1a5fee0a8033ef7708f70b6f"></a><!-- doxytag: member="Partitioner::scan_unassigned_insns" ref="36686cdb1a5fee0a8033ef7708f70b6f" args="(InsnRangeCallback *callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::scan_unassigned_insns           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1InsnRangeCallback.html">InsnRangeCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scans ranges of unassigned instructions. 
<p>
Scans through the list of existing instructions that are not assigned to any function and invokes all of the specified callbacks on each range of such instructions. The ranges of unassigned instructions are not necessarily contiguous or non-overlapping but are bounded by the <code>insn_begin</code> (inclusive) and <code>insn_end</code> (exclusive, or null) callback arguments. The callbacks are invoked via the <a class="el" href="classPartitioner.html#128338b3c819f629c68058ca40545c18">scan_contiguous_insns()</a> method with a different <code>insn_begin</code> for each call.<p>
Callbacks are allowed to disassemble additional instructions and/or assign/break associations between instructions and functions. Only the instructions that are already disassembled at the beginning of this call are considered by the iterators, but the instruction/function associations may change during the iteration.<p>
All callbacks should honor their "enabled" argument and do nothing if it is clear. This feature is used by some of the other instruction scanning methods to filter out certain ranges of instructions. For instance, the <a class="el" href="classPartitioner.html#6d6f280eb993c9ec09c0b79d1ae790f7">scan_intrafunc_insns()</a> will set "enabled" to true only for ranges of unassigned instructions whose closest surrounding assigned instructions both belong to the same function. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01095">1095</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l01560">scan_unassigned_insns()</a>.
</div>
</div><p>
<a class="anchor" name="6d6f280eb993c9ec09c0b79d1ae790f7"></a><!-- doxytag: member="Partitioner::scan_intrafunc_insns" ref="6d6f280eb993c9ec09c0b79d1ae790f7" args="(InsnRangeCallbacks &amp;callbacks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::scan_intrafunc_insns           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classROSE__Callbacks_1_1List.html">InsnRangeCallbacks</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callbacks</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scans the unassigned instructions within a function. 
<p>
The specified callbacks are invoked for each range of unassigned instructions whose closest surrounding assigned instructions both belong to the same function. This can be used, for example, to discover instructions that should probably be considered part of the same function as the surrounding instructions.<p>
This method operates by making a temporary copy of <code>callbacks</code>, prepending a filtering callback, and then invoking <a class="el" href="classPartitioner.html#296180568b4a21d4435f264a05f1837f">scan_unassigned_insns()</a>. Therefore, the callbacks supplied by the user should all honor their "enabled" argument. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l01618">1618</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="callbacks_8h-source.html#l00107">ROSE_Callbacks::List&lt; T &gt;::empty()</a>, <a class="el" href="Partitioner_8h-source.html#l00238">Partitioner::BasicBlock::function</a>, <a class="el" href="callbacks_8h-source.html#l00133">ROSE_Callbacks::List&lt; T &gt;::prepend()</a>, and <a class="el" href="Partitioner_8C-source.html#l01560">scan_unassigned_insns()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8h-source.html#l01111">scan_intrafunc_insns()</a>.
</div>
</div><p>
<a class="anchor" name="155f8d6d64429bab633e256b48cd32d0"></a><!-- doxytag: member="Partitioner::scan_intrafunc_insns" ref="155f8d6d64429bab633e256b48cd32d0" args="(InsnRangeCallback *callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::scan_intrafunc_insns           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1InsnRangeCallback.html">InsnRangeCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scans the unassigned instructions within a function. 
<p>
The specified callbacks are invoked for each range of unassigned instructions whose closest surrounding assigned instructions both belong to the same function. This can be used, for example, to discover instructions that should probably be considered part of the same function as the surrounding instructions.<p>
This method operates by making a temporary copy of <code>callbacks</code>, prepending a filtering callback, and then invoking <a class="el" href="classPartitioner.html#296180568b4a21d4435f264a05f1837f">scan_unassigned_insns()</a>. Therefore, the callbacks supplied by the user should all honor their "enabled" argument. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01111">1111</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l01618">scan_intrafunc_insns()</a>.
</div>
</div><p>
<a class="anchor" name="ff3f578d277b534b4e2e703a39414e73"></a><!-- doxytag: member="Partitioner::scan_interfunc_insns" ref="ff3f578d277b534b4e2e703a39414e73" args="(InsnRangeCallbacks &amp;callbacks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::scan_interfunc_insns           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classROSE__Callbacks_1_1List.html">InsnRangeCallbacks</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callbacks</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scans the instructions between functions. 
<p>
The specified callbacks are invoked for each set of instructions (not necessarily contiguous in memory) that fall "between" two functions. <a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a> I(x) at address x is between two functions, Fa and Fb, if there exists a lower address a&lt;x such that I(a) belongs to Fa and there exists a higher address b&gt;x such that I(b) belongs to Fb; and for all instructions I(y) for a&lt;y&lt;b, I(y) does not belong to any function.<p>
Additionally, if no I(a) exists that belongs to a function, and/or no I(b) exists that belongs to a function, then I(x) is also considered part of an inter-function region and the lower and/or upper functions are undefined. In other words, instructions appearing before all functions or after all functions are also considered to be between functions, and all instructions are considered to be between functions if there are no functions.<p>
Only instructions that have already been disassembled are considered. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l01591">1591</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="callbacks_8h-source.html#l00107">ROSE_Callbacks::List&lt; T &gt;::empty()</a>, <a class="el" href="Partitioner_8h-source.html#l00238">Partitioner::BasicBlock::function</a>, <a class="el" href="callbacks_8h-source.html#l00133">ROSE_Callbacks::List&lt; T &gt;::prepend()</a>, and <a class="el" href="Partitioner_8C-source.html#l01560">scan_unassigned_insns()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8h-source.html#l01132">scan_interfunc_insns()</a>.
</div>
</div><p>
<a class="anchor" name="1e3a66407625c4723589f867064709ac"></a><!-- doxytag: member="Partitioner::scan_interfunc_insns" ref="1e3a66407625c4723589f867064709ac" args="(InsnRangeCallback *callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::scan_interfunc_insns           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1InsnRangeCallback.html">InsnRangeCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scans the instructions between functions. 
<p>
The specified callbacks are invoked for each set of instructions (not necessarily contiguous in memory) that fall "between" two functions. <a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a> I(x) at address x is between two functions, Fa and Fb, if there exists a lower address a&lt;x such that I(a) belongs to Fa and there exists a higher address b&gt;x such that I(b) belongs to Fb; and for all instructions I(y) for a&lt;y&lt;b, I(y) does not belong to any function.<p>
Additionally, if no I(a) exists that belongs to a function, and/or no I(b) exists that belongs to a function, then I(x) is also considered part of an inter-function region and the lower and/or upper functions are undefined. In other words, instructions appearing before all functions or after all functions are also considered to be between functions, and all instructions are considered to be between functions if there are no functions.<p>
Only instructions that have already been disassembled are considered. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01132">1132</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l01591">scan_interfunc_insns()</a>.
</div>
</div><p>
<a class="anchor" name="9fa138686f888f9a51e6e798a550a285"></a><!-- doxytag: member="Partitioner::scan_unassigned_bytes" ref="9fa138686f888f9a51e6e798a550a285" args="(ByteRangeCallbacks &amp;callbacks, MemoryMap *restrict_map=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::scan_unassigned_bytes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classROSE__Callbacks_1_1List.html">ByteRangeCallbacks</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callbacks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMemoryMap.html">MemoryMap</a> *&nbsp;</td>
          <td class="paramname"> <em>restrict_map</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scans ranges of the address space that have not been assigned to any function. 
<p>
For each contiguous range of address space that is not associated with any function, each of the specified callbacks is invoked in turn until one of them returns false. The determination of what parts of the address space belong to functions is made before any of the callbacks are invoked and not updated for the duration of this function. The determination is made by calling <a class="el" href="classPartitioner.html#3a1386d81012e94a46184c4703fd9e40">Partitioner::function_extent()</a> across all known functions, and then passing that mapping to each of the callbacks.<p>
If a <code>restrict_map</code> <a class="el" href="classMemoryMap.html">MemoryMap</a> is specified then only addresses that are also defined in the map are considered. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l01643">1643</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="callbacks_8h-source.html#l00269">ROSE_Callbacks::List&lt; T &gt;::apply()</a>, <a class="el" href="rangemap_8h-source.html#l00775">RangeMap&lt; R, T &gt;::begin()</a>, <a class="el" href="callbacks_8h-source.html#l00107">ROSE_Callbacks::List&lt; T &gt;::empty()</a>, <a class="el" href="rangemap_8h-source.html#l00787">RangeMap&lt; R, T &gt;::end()</a>, <a class="el" href="rangemap_8h-source.html#l01051">RangeMap&lt; R, T &gt;::erase_ranges()</a>, <a class="el" href="Partitioner_8C-source.html#l03383">function_extent()</a>, <a class="el" href="rangemap_8h-source.html#l01226">RangeMap&lt; R, T &gt;::invert()</a>, and <a class="el" href="MemoryMap_8C-source.html#l00805">MemoryMap::va_extents()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03245">post_cfg()</a>, <a class="el" href="Partitioner_8C-source.html#l01697">scan_interfunc_bytes()</a>, <a class="el" href="Partitioner_8C-source.html#l01664">scan_intrafunc_bytes()</a>, and <a class="el" href="Partitioner_8h-source.html#l01148">scan_unassigned_bytes()</a>.
</div>
</div><p>
<a class="anchor" name="7e81dfb79439e41d3013fbd032edb0bf"></a><!-- doxytag: member="Partitioner::scan_unassigned_bytes" ref="7e81dfb79439e41d3013fbd032edb0bf" args="(ByteRangeCallback *callback, MemoryMap *restrict_map=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::scan_unassigned_bytes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1ByteRangeCallback.html">ByteRangeCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMemoryMap.html">MemoryMap</a> *&nbsp;</td>
          <td class="paramname"> <em>restrict_map</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scans ranges of the address space that have not been assigned to any function. 
<p>
For each contiguous range of address space that is not associated with any function, each of the specified callbacks is invoked in turn until one of them returns false. The determination of what parts of the address space belong to functions is made before any of the callbacks are invoked and not updated for the duration of this function. The determination is made by calling <a class="el" href="classPartitioner.html#3a1386d81012e94a46184c4703fd9e40">Partitioner::function_extent()</a> across all known functions, and then passing that mapping to each of the callbacks.<p>
If a <code>restrict_map</code> <a class="el" href="classMemoryMap.html">MemoryMap</a> is specified then only addresses that are also defined in the map are considered. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01148">1148</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l01643">scan_unassigned_bytes()</a>.
</div>
</div><p>
<a class="anchor" name="a262ad7bb16670512ea037eb06b0ed15"></a><!-- doxytag: member="Partitioner::scan_intrafunc_bytes" ref="a262ad7bb16670512ea037eb06b0ed15" args="(ByteRangeCallbacks &amp;callbacks, MemoryMap *restrict_map=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::scan_intrafunc_bytes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classROSE__Callbacks_1_1List.html">ByteRangeCallbacks</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callbacks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMemoryMap.html">MemoryMap</a> *&nbsp;</td>
          <td class="paramname"> <em>restrict_map</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scans unassigned ranges of the address space within a function. 
<p>
The specified callbacks are invoked for each range of the address space whose closest surrounding assigned addresses both belong to the same function. This can be used, for example, to discover static data or unreachable instructions (by static analysis) that should probably belong to the surrounding function.<p>
If a <code>restrict_map</code> <a class="el" href="classMemoryMap.html">MemoryMap</a> is specified then only addresses that are also defined in the map are considered. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l01664">1664</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="callbacks_8h-source.html#l00107">ROSE_Callbacks::List&lt; T &gt;::empty()</a>, <a class="el" href="rangemap_8h-source.html#l00365">Range&lt; T &gt;::maximum()</a>, <a class="el" href="rangemap_8h-source.html#l00360">Range&lt; T &gt;::minimum()</a>, <a class="el" href="callbacks_8h-source.html#l00133">ROSE_Callbacks::List&lt; T &gt;::prepend()</a>, and <a class="el" href="Partitioner_8C-source.html#l01643">scan_unassigned_bytes()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8h-source.html#l01163">scan_intrafunc_bytes()</a>.
</div>
</div><p>
<a class="anchor" name="e7f2a87f90ac844277ab59b19ea0f863"></a><!-- doxytag: member="Partitioner::scan_intrafunc_bytes" ref="e7f2a87f90ac844277ab59b19ea0f863" args="(ByteRangeCallback *callback, MemoryMap *restrict_map=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::scan_intrafunc_bytes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1ByteRangeCallback.html">ByteRangeCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMemoryMap.html">MemoryMap</a> *&nbsp;</td>
          <td class="paramname"> <em>restrict_map</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scans unassigned ranges of the address space within a function. 
<p>
The specified callbacks are invoked for each range of the address space whose closest surrounding assigned addresses both belong to the same function. This can be used, for example, to discover static data or unreachable instructions (by static analysis) that should probably belong to the surrounding function.<p>
If a <code>restrict_map</code> <a class="el" href="classMemoryMap.html">MemoryMap</a> is specified then only addresses that are also defined in the map are considered. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01163">1163</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l01664">scan_intrafunc_bytes()</a>.
</div>
</div><p>
<a class="anchor" name="7f593939f5d8fa66b5e38a25183b4b8f"></a><!-- doxytag: member="Partitioner::scan_interfunc_bytes" ref="7f593939f5d8fa66b5e38a25183b4b8f" args="(ByteRangeCallbacks &amp;callbacks, MemoryMap *restrict_map=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::scan_interfunc_bytes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classROSE__Callbacks_1_1List.html">ByteRangeCallbacks</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callbacks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMemoryMap.html">MemoryMap</a> *&nbsp;</td>
          <td class="paramname"> <em>restrict_map</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scans unassigned ranges of the address space between functions. 
<p>
The specified callbacks are invoked for each range of addresses that fall "between" two functions. An address is between two functions if the next lower assigned address belongs to one function and the next higher assigned address belongs to some other function, or if there is no assigned lower address and/or no assigned higher address.<p>
If a <code>restrict_map</code> <a class="el" href="classMemoryMap.html">MemoryMap</a> is specified then only addresses that are also defined in the map are considered. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l01697">1697</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="callbacks_8h-source.html#l00107">ROSE_Callbacks::List&lt; T &gt;::empty()</a>, <a class="el" href="rangemap_8h-source.html#l00365">Range&lt; T &gt;::maximum()</a>, <a class="el" href="rangemap_8h-source.html#l00360">Range&lt; T &gt;::minimum()</a>, <a class="el" href="callbacks_8h-source.html#l00133">ROSE_Callbacks::List&lt; T &gt;::prepend()</a>, and <a class="el" href="Partitioner_8C-source.html#l01643">scan_unassigned_bytes()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03245">post_cfg()</a>, and <a class="el" href="Partitioner_8h-source.html#l01178">scan_interfunc_bytes()</a>.
</div>
</div><p>
<a class="anchor" name="5f29cd4e14c75ec863a017c12bae0c47"></a><!-- doxytag: member="Partitioner::scan_interfunc_bytes" ref="5f29cd4e14c75ec863a017c12bae0c47" args="(ByteRangeCallback *callback, MemoryMap *restrict_map=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::scan_interfunc_bytes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1ByteRangeCallback.html">ByteRangeCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMemoryMap.html">MemoryMap</a> *&nbsp;</td>
          <td class="paramname"> <em>restrict_map</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scans unassigned ranges of the address space between functions. 
<p>
The specified callbacks are invoked for each range of addresses that fall "between" two functions. An address is between two functions if the next lower assigned address belongs to one function and the next higher assigned address belongs to some other function, or if there is no assigned lower address and/or no assigned higher address.<p>
If a <code>restrict_map</code> <a class="el" href="classMemoryMap.html">MemoryMap</a> is specified then only addresses that are also defined in the map are considered. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01178">1178</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l01697">scan_interfunc_bytes()</a>.
</div>
</div><p>
<a class="anchor" name="211865359a987a4e353615bb427bda34"></a><!-- doxytag: member="Partitioner::pattern1" ref="211865359a987a4e353615bb427bda34" args="(const InstructionMap &amp;insns, InstructionMap::const_iterator first, Disassembler::AddressSet &amp;exclude)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Partitioner::InstructionMap::const_iterator Partitioner::pattern1           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPartitioner.html#cff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>insns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InstructionMap::const_iterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>exclude</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks for stack frame setup. 
<p>
Tries to match "(mov rdi,rdi)?; push rbp; mov rbp,rsp" (or the 32-bit equivalent). The first MOV instruction is a two-byte no-op used for hot patching of executables (single instruction rather than two NOP instructions so that no thread is executing at the second byte when the MOV is replaced by a JMP). The PUSH and second MOV are the standard way to set up the stack frame. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l01349">1349</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="classSgAsmRegisterReferenceExpression.html#e4a2ae3037e897d983674a61bbf16ec0">SgAsmRegisterReferenceExpression::get_descriptor()</a>, <a class="el" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">SgAsmx86Instruction::get_kind()</a>, <a class="el" href="Cxx__Grammar_8h-source.html#l05133">RegisterDescriptor::get_major()</a>, <a class="el" href="Cxx__Grammar_8h-source.html#l05140">RegisterDescriptor::get_minor()</a>, <a class="el" href="classSgAsmInstruction.html#264e86d032b0a589d9dc520e79d09eb8">SgAsmInstruction::get_operandList()</a>, <a class="el" href="classSgAsmOperandList.html#bb5638c0533863030ad7acee019f1f17">SgAsmOperandList::get_operands()</a>, <a class="el" href="Cxx__Grammar_8h-source.html#l217707">SgAsmInstruction::get_size()</a>, <a class="el" href="Partitioner_8C-source.html#l00041">isSgAsmx86Instruction()</a>, <a class="el" href="Cxx__Grammar_8h.html#5e5ead71a8653e1d062d92582359e574">isSgAsmx86RegisterReferenceExpression()</a>, <a class="el" href="InstructionEnumsX86_8h.html#5069ca462f85d162797843f48bc6bceda9ec94ced24945de2d3e64be23e8a19b">x86_gpr_bp</a>, <a class="el" href="InstructionEnumsX86_8h.html#5069ca462f85d162797843f48bc6bced4e00b4b002bfe801084a2c7648bf884e">x86_gpr_di</a>, <a class="el" href="InstructionEnumsX86_8h.html#5069ca462f85d162797843f48bc6bced1f5849637e513ff627dc7360562d1ca0">x86_gpr_sp</a>, <a class="el" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca55716425893a9bd36fb1384ff05ba92096b7">x86_mov</a>, <a class="el" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571618cb96107e08a8518c194668a9bb9c2">x86_push</a>, and <a class="el" href="InstructionEnumsX86_8h.html#12229bfc0029dbc592944d1d6514e30fbcab68a004f857b0eb9dc6a5b736b1ec">x86_regclass_gpr</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l01497">mark_func_patterns()</a>.
</div>
</div><p>
<a class="anchor" name="3d11541835dec7b94d67c6a23db908cd"></a><!-- doxytag: member="Partitioner::append" ref="3d11541835dec7b94d67c6a23db908cd" args="(BasicBlock *, Instruction *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::append           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a> *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add an instruction to a basic block. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00683">683</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l00139">Partitioner::Instruction::bblock</a>, and <a class="el" href="Partitioner_8h-source.html#l00235">Partitioner::BasicBlock::insns</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03080">adjust_padding()</a>, <a class="el" href="Partitioner_8C-source.html#l03705">build_ast()</a>, <a class="el" href="Partitioner_8C-source.html#l02990">detach_thunk()</a>, <a class="el" href="Partitioner_8C-source.html#l02680">discover_blocks()</a>, <a class="el" href="Partitioner_8C-source.html#l02632">discover_first_block()</a>, <a class="el" href="Partitioner_8C-source.html#l00191">discover_jump_table()</a>, <a class="el" href="Partitioner_8C-source.html#l00904">find_bb_containing()</a>, <a class="el" href="Partitioner_8C-source.html#l02334">Partitioner::FindPostFunctionInsns::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l02213">Partitioner::FindThunkTables::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l02176">Partitioner::FindInterPadFunctions::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l02121">Partitioner::FindThunks::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l02036">Partitioner::FindFunctionFragments::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l01863">Partitioner::FindInsnPadding::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l01820">Partitioner::FindData::operator()()</a>, and <a class="el" href="Partitioner_8C-source.html#l01730">Partitioner::FindDataPadding::operator()()</a>.
</div>
</div><p>
<a class="anchor" name="ba38c7356f1455b1eafdfdfdfba7ec80"></a><!-- doxytag: member="Partitioner::append" ref="ba38c7356f1455b1eafdfdfdfba7ec80" args="(BasicBlock *, DataBlock *, unsigned reasons)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::append           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>reason</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Associate a data block with a basic block. 
<p>
Any basic block can point to zero or more data blocks. The data block will then be kept with the same function as the basic block. This is typically used for things like jump tables, where the last instruction of the basic block is an indirect jump, and the data block contains the jump table. When a blasic block is truncated, it looses its data blocks.<p>
A data block's explicit function assignment (i.e., its "function" member) overrides its assignment via a basic block. A data block can be assigned to at most one basic block.<p>
The <code>reason</code> argument is a bit vector of <a class="el" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48c">SgAsmBlock::Reason</a> bits that are added to the data block's reasons for existing. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00702">702</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l00269">Partitioner::DataBlock::basic_block</a>, <a class="el" href="Partitioner_8h-source.html#l00236">Partitioner::BasicBlock::data_blocks</a>, and <a class="el" href="Partitioner_8h-source.html#l00267">Partitioner::DataBlock::reason</a>.
</div>
</div><p>
<a class="anchor" name="30f511a1deeb308d57ec9bcec8d16f0f"></a><!-- doxytag: member="Partitioner::append" ref="30f511a1deeb308d57ec9bcec8d16f0f" args="(Function *, BasicBlock *, unsigned reasons, bool keep=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::append           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1Function.html">Function</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>keep</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append basic block to function. 
<p>
This method is a bit of a misnomer because the order that blocks are appended to a function is irrelevant -- the blocks are stored in a map by order of block entry address. The block being appended must not already belong to some other function, but it's fine if the block already belongs to the function to which it is being appended (it is not added a second time).<p>
Whenever a block is added to a function, we should supply a reason for adding it. The <code>reasons</code> bit vector are those reasons. The bits are from the <a class="el" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48c">SgAsmBlock::Reason</a> enum.<p>
If the <code>keep</code> argument is true, then the block's entry address is also added to the function's list of control flow graph (CFG) heads. These are the addresses of blocks which are used to start the recursive CFG analysis phase of function block discovery. The function's entry address is always considered a CFG head even if it doesn't appear in the set of heads. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00727">727</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00465">Partitioner::BasicBlock::address()</a>, <a class="el" href="Partitioner_8h-source.html#l00332">Partitioner::Function::basic_blocks</a>, <a class="el" href="Partitioner_8h-source.html#l00237">Partitioner::BasicBlock::cache</a>, <a class="el" href="Partitioner_8h-source.html#l00238">Partitioner::BasicBlock::function</a>, <a class="el" href="Partitioner_8h-source.html#l00196">Partitioner::BlockAnalysisCache::function_return</a>, <a class="el" href="Partitioner_8h-source.html#l00336">Partitioner::Function::heads</a>, <a class="el" href="Partitioner_8C-source.html#l00555">Partitioner::Function::promote_may_return()</a>, <a class="el" href="Partitioner_8h-source.html#l00234">Partitioner::BasicBlock::reason</a>, <a class="el" href="classSgAsmFunction.html#d1e0c37f9e507fc6acaf01dd0794a752921b64c76e93f8581fd16c205aac1516">SgAsmFunction::RET_SOMETIMES</a>, and <a class="el" href="Partitioner_8C-source.html#l00270">update_analyses()</a>.
</div>
</div><p>
<a class="anchor" name="7d6d934c7fe0e273e8edd1b4ecc5e36e"></a><!-- doxytag: member="Partitioner::append" ref="7d6d934c7fe0e273e8edd1b4ecc5e36e" args="(Function *, DataBlock *, unsigned reasons, bool force=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::append           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1Function.html">Function</a> *&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>force</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append data region to function. 
<p>
This method is a bit of a misnomer because the order that the data blocks are appended to the function is irrelevant -- the blocks are stored in a map by order of block address. The data block being appended must not already belong to some other function, but it's fine if the block already belongs to the function to which it is being appended (it is not added a second time).<p>
Whenever a block is added to a function, we should supply a reason for adding it. The <code>reason</code> bit vector are those reasons. The bits are from the <a class="el" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48c">SgAsmBlock::Reason</a> enum.<p>
If <code>force</code> is true then the data block is first removed from any basic block or function to which it already belongs. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00764">764</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00474">Partitioner::DataBlock::address()</a>, <a class="el" href="Partitioner_8h-source.html#l00269">Partitioner::DataBlock::basic_block</a>, <a class="el" href="Partitioner_8h-source.html#l00333">Partitioner::Function::data_blocks</a>, <a class="el" href="Partitioner_8h-source.html#l00268">Partitioner::DataBlock::function</a>, <a class="el" href="Partitioner_8h-source.html#l00267">Partitioner::DataBlock::reason</a>, and <a class="el" href="Partitioner_8C-source.html#l00788">remove()</a>.
</div>
</div><p>
<a class="anchor" name="7a886afe82a7fc7171bdc64ecfd379fb"></a><!-- doxytag: member="Partitioner::remove" ref="7a886afe82a7fc7171bdc64ecfd379fb" args="(Function *, BasicBlock *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::remove           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1Function.html">Function</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>bb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove a basic block from a function. 
<p>
The block and function continue to exist--only the association between them is broken. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00788">788</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00465">Partitioner::BasicBlock::address()</a>, <a class="el" href="Partitioner_8h-source.html#l00332">Partitioner::Function::basic_blocks</a>, and <a class="el" href="Partitioner_8h-source.html#l00238">Partitioner::BasicBlock::function</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l00764">append()</a>, <a class="el" href="Partitioner_8C-source.html#l02990">detach_thunk()</a>, and <a class="el" href="Partitioner_8C-source.html#l02632">discover_first_block()</a>.
</div>
</div><p>
<a class="anchor" name="780baf904faf5b5eb57eec90b1b6c16b"></a><!-- doxytag: member="Partitioner::remove" ref="780baf904faf5b5eb57eec90b1b6c16b" args="(Function *, DataBlock *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::remove           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1Function.html">Function</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>db</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove a data block from a function. 
<p>
The block and function continue to exist--only the association between them is broken. The data block might also be associated with a basic block, in which case the data block will ultimately belong to the same function as the basic block. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00801">801</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00474">Partitioner::DataBlock::address()</a>, <a class="el" href="Partitioner_8h-source.html#l00333">Partitioner::Function::data_blocks</a>, and <a class="el" href="Partitioner_8h-source.html#l00268">Partitioner::DataBlock::function</a>.
</div>
</div><p>
<a class="anchor" name="7578d7e4a6ba2612a608fd19a550178e"></a><!-- doxytag: member="Partitioner::remove" ref="7578d7e4a6ba2612a608fd19a550178e" args="(BasicBlock *, DataBlock *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::remove           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>db</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove a data block from a basic block. 
<p>
The blocks continue to exist--only the association between them is broken. The data block might still be associated with a function, in which case it will ultimately end up in that function. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00813">813</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l00269">Partitioner::DataBlock::basic_block</a>, and <a class="el" href="Partitioner_8h-source.html#l00236">Partitioner::BasicBlock::data_blocks</a>.
</div>
</div><p>
<a class="anchor" name="67b4f858bb93fcef7d4c24be86cd10f3"></a><!-- doxytag: member="Partitioner::find_bb_containing" ref="67b4f858bb93fcef7d4c24be86cd10f3" args="(rose_addr_t, bool create=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPartitioner_1_1BasicBlock.html">Partitioner::BasicBlock</a> * Partitioner::find_bb_containing           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td>
          <td class="paramname"> <em>va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>create</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds a basic block containing the specified instruction address. 
<p>
If no basic block exists and <code>create</code> is set, then a new block is created which starts at the specified address. The return value, in the case when a block already exists, may be a block where the specified virtual address is either the beginning of the block or somewhere inside the block. In any case, the virtual address will always represent a function.<p>
If no instruction can be found at the specified address then no block is created and a null pointer is returned.<p>
Blocks are created by adding the initial instruction to the block, then repeatedly attempting to add more instructions as follows: if the block successors can all be statically determined, and there is exactly one successor, and that successor is not already part of a block, then the successor is appended to the block.<p>
Block creation is recursive in nature since the computation of a (partial) block's successors might require creation of other blocks. Consider the case of an x86 CALL instruction: after a CALL is appended to a block, the successors are calculated by looking at the target of the CALL. If the target is known and it can be proved that the target block (recursively constructed) discards the return address, then the fall-through address of the CALL is not a direct successor.<p>
See also, <a class="el" href="classPartitioner.html#07ab675418fbe36332333be50b0b78b8">set_allow_discontiguous_blocks()</a>. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00904">904</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01813">allow_discont_blocks</a>, <a class="el" href="Partitioner_8C-source.html#l00683">append()</a>, <a class="el" href="Partitioner_8h-source.html#l01804">basic_blocks</a>, <a class="el" href="Partitioner_8h-source.html#l00139">Partitioner::Instruction::bblock</a>, <a class="el" href="Partitioner_8C-source.html#l00869">find_instruction()</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852ceea34044afa2b5415dad4b39cf2aa51d">SgAsmFunction::FUNC_CALL_TARGET</a>, <a class="el" href="Partitioner_8h-source.html#l01809">func_heuristics</a>, <a class="el" href="Partitioner_8h-source.html#l00144">Partitioner::Instruction::get_size()</a>, <a class="el" href="Partitioner_8C-source.html#l00325">is_function_call()</a>, <a class="el" href="Partitioner_8C-source.html#l00345">successors()</a>, and <a class="el" href="Partitioner_8h-source.html#l00145">Partitioner::Instruction::terminatesBasicBlock()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03705">build_ast()</a>, <a class="el" href="Partitioner_8C-source.html#l00824">discard()</a>, <a class="el" href="Partitioner_8C-source.html#l02680">discover_blocks()</a>, <a class="el" href="Partitioner_8C-source.html#l02632">discover_first_block()</a>, <a class="el" href="Partitioner_8C-source.html#l00952">find_bb_starting()</a>, <a class="el" href="Partitioner_8C-source.html#l03525">is_contiguous()</a>, <a class="el" href="Partitioner_8C-source.html#l02334">Partitioner::FindPostFunctionInsns::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l02213">Partitioner::FindThunkTables::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l02121">Partitioner::FindThunks::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l02036">Partitioner::FindFunctionFragments::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l01863">Partitioner::FindInsnPadding::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l00400">pops_return_address()</a>, <a class="el" href="Partitioner_8C-source.html#l01560">scan_unassigned_insns()</a>, and <a class="el" href="Partitioner_8C-source.html#l00659">truncate()</a>.
</div>
</div><p>
<a class="anchor" name="67702e97dcbfb27fa18f6186fe30538a"></a><!-- doxytag: member="Partitioner::find_bb_starting" ref="67702e97dcbfb27fa18f6186fe30538a" args="(rose_addr_t, bool create=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPartitioner_1_1BasicBlock.html">Partitioner::BasicBlock</a> * Partitioner::find_bb_starting           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td>
          <td class="paramname"> <em>va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>create</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Makes sure the block at the specified address exists. 
<p>
This is similar to <a class="el" href="classPartitioner.html#67b4f858bb93fcef7d4c24be86cd10f3">find_bb_containing()</a> except it makes sure that <code>va</code> starts a new basic block if it was previously in the middle of a block. If an existing block had to be truncated to start this new block then the original block's function is marked as pending rediscovery. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00952">952</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00465">Partitioner::BasicBlock::address()</a>, <a class="el" href="Partitioner_8h-source.html#l01812">debug</a>, <a class="el" href="Partitioner_8C-source.html#l00904">find_bb_containing()</a>, <a class="el" href="Partitioner_8h-source.html#l00238">Partitioner::BasicBlock::function</a>, <a class="el" href="Partitioner_8h-source.html#l00235">Partitioner::BasicBlock::insns</a>, <a class="el" href="Partitioner_8h-source.html#l00334">Partitioner::Function::pending</a>, and <a class="el" href="Partitioner_8C-source.html#l00659">truncate()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02808">analyze_cfg()</a>, <a class="el" href="Partitioner_8C-source.html#l00976">canonic_block()</a>, <a class="el" href="Partitioner_8C-source.html#l02990">detach_thunk()</a>, <a class="el" href="Partitioner_8C-source.html#l02680">discover_blocks()</a>, <a class="el" href="Partitioner_8C-source.html#l01019">mark_ipd_configuration()</a>, <a class="el" href="Partitioner_8C-source.html#l03104">merge_function_fragments()</a>, <a class="el" href="Partitioner_8C-source.html#l02213">Partitioner::FindThunkTables::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l02121">Partitioner::FindThunks::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l02036">Partitioner::FindFunctionFragments::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l01863">Partitioner::FindInsnPadding::operator()()</a>, and <a class="el" href="Partitioner_8C-source.html#l00345">successors()</a>.
</div>
</div><p>
<a class="anchor" name="72fe4f436de7235fa06629810a5f1494"></a><!-- doxytag: member="Partitioner::find_db_starting" ref="72fe4f436de7235fa06629810a5f1494" args="(rose_addr_t, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPartitioner_1_1DataBlock.html">Partitioner::DataBlock</a> * Partitioner::find_db_starting           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td>
          <td class="paramname"> <em>start_va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds (or creates) a data block. 
<p>
Finds a data block starting at the specified address. If <code>size</code> is non-zero then the existing data block must contain all bytes in the range <code>start_va</code> (inclusive) to <code>start_va</code> + <code>size</code> (exclusive), and if it doesn't then a new <a class="el" href="classSgAsmStaticData.html">SgAsmStaticData</a> node is created and appended to either a new data block or a data block that already begins at the specified address. If size is zero an no block exists, then the null pointer is returned. The size of the existing block does not matter if size is zero. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l01998">1998</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01807">data_blocks</a>, <a class="el" href="Partitioner_8C-source.html#l03488">datablock_extent()</a>, <a class="el" href="rangemap_8h-source.html#l00928">RangeMap&lt; R, T &gt;::empty()</a>, <a class="el" href="rangemap_8h-source.html#l01051">RangeMap&lt; R, T &gt;::erase_ranges()</a>, <a class="el" href="rangemap_8h-source.html#l01062">RangeMap&lt; R, T &gt;::insert()</a>, <a class="el" href="Partitioner_8h-source.html#l01800">map</a>, <a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd57544ce6196a00fe1b9a997bbd34b607f12">MemoryMap::MM_PROT_NONE</a>, <a class="el" href="Partitioner_8h-source.html#l00266">Partitioner::DataBlock::nodes</a>, and <a class="el" href="MemoryMap_8C-source.html#l00728">MemoryMap::read()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l00191">discover_jump_table()</a>, <a class="el" href="Partitioner_8C-source.html#l01863">Partitioner::FindInsnPadding::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l01820">Partitioner::FindData::operator()()</a>, and <a class="el" href="Partitioner_8C-source.html#l01730">Partitioner::FindDataPadding::operator()()</a>.
</div>
</div><p>
<a class="anchor" name="e2e3e09e5194ba8c87bc968b65b63e3c"></a><!-- doxytag: member="Partitioner::successors" ref="e2e3e09e5194ba8c87bc968b65b63e3c" args="(BasicBlock *, bool *complete=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> Partitioner::successors           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>complete</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns known successors of a basic block. 
<p>
There are two types of successor analyses: one is an analysis that depends only on the instructions of the basic block for which successors are being calculated. It is safe to cache these based on properties of the block itself (e.g., the number of instructions in the block).<p>
The other category is analyses that depend on other blocks, such as determining whether the target of an x86 CALL instruction returns to the instruction after the CALL site. The results of these analyses cannot be cached at the block that needs them and must be recomputed for each call. However, they can be cached at either the block or function that's analyzed, so recomputing them here in this block is probably not too expensive.<p>
All successor addresses are translated according to the alias_for links in existing blocks via calls to <a class="el" href="classPartitioner.html#bd63242c67a32e6de5434d21956a01bf">canonic_block()</a>. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00345">345</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l00237">Partitioner::BasicBlock::cache</a>, <a class="el" href="Partitioner_8C-source.html#l00385">call_target()</a>, <a class="el" href="Partitioner_8C-source.html#l00976">canonic_block()</a>, <a class="el" href="Partitioner_8C-source.html#l00952">find_bb_starting()</a>, <a class="el" href="Partitioner_8C-source.html#l00869">find_instruction()</a>, <a class="el" href="Partitioner_8h-source.html#l00238">Partitioner::BasicBlock::function</a>, <a class="el" href="Partitioner_8h-source.html#l00143">Partitioner::Instruction::get_address()</a>, <a class="el" href="Partitioner_8h-source.html#l00144">Partitioner::Instruction::get_size()</a>, <a class="el" href="Partitioner_8h-source.html#l00190">Partitioner::BlockAnalysisCache::is_function_call</a>, <a class="el" href="Partitioner_8C-source.html#l00495">Partitioner::BasicBlock::last_insn()</a>, <a class="el" href="Partitioner_8h-source.html#l01821">NO_TARGET</a>, <a class="el" href="Partitioner_8h-source.html#l00311">Partitioner::Function::possible_may_return()</a>, <a class="el" href="Partitioner_8h-source.html#l00188">Partitioner::BlockAnalysisCache::sucs</a>, <a class="el" href="Partitioner_8h-source.html#l00189">Partitioner::BlockAnalysisCache::sucs_complete</a>, and <a class="el" href="Partitioner_8C-source.html#l00270">update_analyses()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02808">analyze_cfg()</a>, <a class="el" href="Partitioner_8C-source.html#l03844">build_ast()</a>, <a class="el" href="Partitioner_8C-source.html#l02990">detach_thunk()</a>, <a class="el" href="Partitioner_8C-source.html#l03954">detectBasicBlocks()</a>, <a class="el" href="Partitioner_8C-source.html#l02680">discover_blocks()</a>, <a class="el" href="Partitioner_8C-source.html#l00191">discover_jump_table()</a>, <a class="el" href="Partitioner_8C-source.html#l00904">find_bb_containing()</a>, <a class="el" href="Partitioner_8C-source.html#l02300">is_thunk()</a>, <a class="el" href="Partitioner_8C-source.html#l03104">merge_function_fragments()</a>, and <a class="el" href="Partitioner_8C-source.html#l02213">Partitioner::FindThunkTables::operator()()</a>.
</div>
</div><p>
<a class="anchor" name="5665dc5ef1c3aef6670dc6ab5d66815f"></a><!-- doxytag: member="Partitioner::call_target" ref="5665dc5ef1c3aef6670dc6ab5d66815f" args="(BasicBlock *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> Partitioner::call_target           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>bb</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns call target if block could be a function call. 
<p>
If the specified block looks like it could be a function call (using only local analysis) then return the call target address. If the block does not look like a function call or the target address cannot be statically computed, then return <a class="el" href="classPartitioner.html#7e4a76ae7ab4113b2ec7acf9093c3810">Partitioner::NO_TARGET</a>. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00385">385</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l00237">Partitioner::BasicBlock::cache</a>, <a class="el" href="Partitioner_8h-source.html#l00191">Partitioner::BlockAnalysisCache::call_target</a>, <a class="el" href="Partitioner_8C-source.html#l00976">canonic_block()</a>, <a class="el" href="Partitioner_8h-source.html#l01821">NO_TARGET</a>, and <a class="el" href="Partitioner_8C-source.html#l00270">update_analyses()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02680">discover_blocks()</a>, and <a class="el" href="Partitioner_8C-source.html#l00345">successors()</a>.
</div>
</div><p>
<a class="anchor" name="a1fd20a852585175fc0be71ef5bd97bd"></a><!-- doxytag: member="Partitioner::truncate" ref="a1fd20a852585175fc0be71ef5bd97bd" args="(BasicBlock *, rose_addr_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::truncate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td>
          <td class="paramname"> <em>va</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reduces the size of a basic block by truncating its list of instructions. 
<p>
The new block contains initial instructions up to but not including the instruction at the specified virtual address. The addresses of the instructions (aside from the instruction with the specified split point), are irrelevant since the choice of where to split is based on the relative positions in the basic block's instruction vector rather than instruction address.<p>
If this basic block's size decreased, then any data blocks associated with this basic block are no longer associated with this basic block. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00659">659</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00503">Partitioner::BasicBlock::clear_data_blocks()</a>, <a class="el" href="Partitioner_8C-source.html#l00904">find_bb_containing()</a>, and <a class="el" href="Partitioner_8h-source.html#l00235">Partitioner::BasicBlock::insns</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l00824">discard()</a>, <a class="el" href="Partitioner_8C-source.html#l02632">discover_first_block()</a>, <a class="el" href="Partitioner_8C-source.html#l00952">find_bb_starting()</a>, and <a class="el" href="Partitioner_8C-source.html#l01019">mark_ipd_configuration()</a>.
</div>
</div><p>
<a class="anchor" name="810bddfe83b19037ed710bdb98a34f50"></a><!-- doxytag: member="Partitioner::discover_first_block" ref="810bddfe83b19037ed710bdb98a34f50" args="(Function *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::discover_first_block           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1Function.html">Function</a> *&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds first basic block to empty function before we start discovering blocks of any other functions. 
<p>
This protects against cases where one function simply falls through to another within a basic block, such as: 08048460 &lt;foo&gt;: 8048460: 55 push ebp 8048461: 89 e5 mov ebp,esp 8048463: 83 ec 08 sub esp,0x8 8048466: c7 04 24 d4 85 04 08 mov DWORD PTR [esp],0x80485d4 804846d: e8 8e fe ff ff call 8048300 &lt;puts&gt; 8048472: c7 04 24 00 00 00 00 mov DWORD PTR [esp],0x0 8048479: e8 a2 fe ff ff call 8048320 &lt;_exit&gt; 804847e: 89 f6 mov esi,esi<p>
08048480 &lt;handler&gt;: 8048480: 55 push ebp 8048481: 89 e5 mov ebp,esp 8048483: 83 ec 08 sub esp,0x8 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l02632">2632</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00683">append()</a>, <a class="el" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48ccb1cb50df0cb421e21b3ca064d1122e0">SgAsmBlock::BLK_ENTRY_POINT</a>, <a class="el" href="Partitioner_8h-source.html#l01812">debug</a>, <a class="el" href="Partitioner_8h-source.html#l00335">Partitioner::Function::entry_va</a>, <a class="el" href="Partitioner_8C-source.html#l00904">find_bb_containing()</a>, <a class="el" href="Partitioner_8h-source.html#l00331">Partitioner::Function::name</a>, <a class="el" href="Partitioner_8h-source.html#l00330">Partitioner::Function::reason</a>, <a class="el" href="SgAsmFunction_8C-source.html#l00026">SgAsmFunction::reason_str()</a>, <a class="el" href="Partitioner_8C-source.html#l00788">remove()</a>, <a class="el" href="Partitioner_8C-source.html#l00571">Partitioner::Function::show_properties()</a>, and <a class="el" href="Partitioner_8C-source.html#l00659">truncate()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02808">analyze_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="354aa1fce4dcbc80c99038829a3ddb76"></a><!-- doxytag: member="Partitioner::discover_blocks" ref="354aa1fce4dcbc80c99038829a3ddb76" args="(Function *, unsigned reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::discover_blocks           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1Function.html">Function</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>reason</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l02799">2799</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l00335">Partitioner::Function::entry_va</a>, and <a class="el" href="Partitioner_8h-source.html#l00336">Partitioner::Function::heads</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02808">analyze_cfg()</a>, and <a class="el" href="Partitioner_8C-source.html#l02680">discover_blocks()</a>.
</div>
</div><p>
<a class="anchor" name="9bc4921fd2eefd0a2eb4f8eeaa2b2f2f"></a><!-- doxytag: member="Partitioner::discover_blocks" ref="9bc4921fd2eefd0a2eb4f8eeaa2b2f2f" args="(Function *, rose_addr_t, unsigned reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::discover_blocks           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1Function.html">Function</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td>
          <td class="paramname"> <em>va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>reason</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Discover the basic blocks that belong to the current function. 
<p>
This function recursively adds basic blocks to function <code>f</code> by following the successors of each block. If a successor is an instruction belonging to some other function then it's either a function call (if it branches to the entry point of that function) or it's a collision. Collisions are resolved by discarding and rediscovering the blocks of the other function. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l02680">2680</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00999">add_function()</a>, <a class="el" href="Partitioner_8C-source.html#l00465">Partitioner::BasicBlock::address()</a>, <a class="el" href="Partitioner_8C-source.html#l00683">append()</a>, <a class="el" href="Partitioner_8C-source.html#l00385">call_target()</a>, <a class="el" href="Partitioner_8h-source.html#l01812">debug</a>, <a class="el" href="Partitioner_8C-source.html#l02799">discover_blocks()</a>, <a class="el" href="Partitioner_8h-source.html#l00335">Partitioner::Function::entry_va</a>, <a class="el" href="Partitioner_8C-source.html#l00904">find_bb_containing()</a>, <a class="el" href="Partitioner_8C-source.html#l00952">find_bb_starting()</a>, <a class="el" href="Partitioner_8C-source.html#l00990">find_function()</a>, <a class="el" href="Partitioner_8C-source.html#l00869">find_instruction()</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852ceea34044afa2b5415dad4b39cf2aa51d">SgAsmFunction::FUNC_CALL_TARGET</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c9c6f61a9e05594d28378f6130c1d59cf">SgAsmFunction::FUNC_GRAPH</a>, <a class="el" href="Partitioner_8h-source.html#l01809">func_heuristics</a>, <a class="el" href="Partitioner_8h-source.html#l00238">Partitioner::BasicBlock::function</a>, <a class="el" href="Partitioner_8h-source.html#l01805">functions</a>, <a class="el" href="Partitioner_8h-source.html#l00235">Partitioner::BasicBlock::insns</a>, <a class="el" href="Partitioner_8h-source.html#l00331">Partitioner::Function::name</a>, <a class="el" href="Partitioner_8h-source.html#l01821">NO_TARGET</a>, <a class="el" href="Partitioner_8h-source.html#l00334">Partitioner::Function::pending</a>, <a class="el" href="Partitioner_8h-source.html#l00330">Partitioner::Function::reason</a>, and <a class="el" href="Partitioner_8C-source.html#l00345">successors()</a>.
</div>
</div><p>
<a class="anchor" name="815304b7ef093a74bc419662d54df49b"></a><!-- doxytag: member="Partitioner::pre_cfg" ref="815304b7ef093a74bc419662d54df49b" args="(SgAsmInterpretation *interp=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::pre_cfg           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&nbsp;</td>
          <td class="paramname"> <em>interp</em> = <code>NULL</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Detects functions before analyzing the CFG. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l02569">2569</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01812">debug</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cbb9273d4d879614c52016694798c3143">SgAsmFunction::FUNC_CALL_INSN</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cd7e1055f3974be70f4e4d88e758ed666">SgAsmFunction::FUNC_EH_FRAME</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c2c1716e490136fddc09c145d8809ed64">SgAsmFunction::FUNC_ENTRY_POINT</a>, <a class="el" href="Partitioner_8h-source.html#l01809">func_heuristics</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c40c0ce88c447524963f4e8d7ef193cc7">SgAsmFunction::FUNC_IMPORT</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cd01f7a2ed6ff7e8a3e6c4550d0ccaa63">SgAsmFunction::FUNC_PATTERN</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c10eee68a3ad870f7e48faef2639a853a">SgAsmFunction::FUNC_SYMBOL</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c5f338fbf75bfacef4196e65ba5441767">SgAsmFunction::FUNC_USERDEF</a>, <a class="el" href="classSgAsmGenericHeaderList.html#c3d9878c64af6c90e2d52988f8578b36">SgAsmGenericHeaderList::get_headers()</a>, <a class="el" href="classSgAsmInterpretation.html#5d116938aaa9da9f3e27ca598965c77b">SgAsmInterpretation::get_headers()</a>, <a class="el" href="Partitioner_8C-source.html#l01524">mark_call_insns()</a>, <a class="el" href="Partitioner_8C-source.html#l01204">mark_eh_frames()</a>, <a class="el" href="Partitioner_8C-source.html#l01227">mark_elf_plt_entries()</a>, <a class="el" href="Partitioner_8C-source.html#l01192">mark_entry_targets()</a>, <a class="el" href="Partitioner_8C-source.html#l01497">mark_func_patterns()</a>, <a class="el" href="Partitioner_8C-source.html#l01307">mark_func_symbols()</a>, <a class="el" href="Partitioner_8C-source.html#l01019">mark_ipd_configuration()</a>, <a class="el" href="SgAsmFunction_8C-source.html#l00010">SgAsmFunction::reason_key()</a>, and <a class="el" href="Partitioner_8h-source.html#l01810">user_detectors</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03891">partition()</a>.
</div>
</div><p>
<a class="anchor" name="19725656eaa83118d75bdd77c617cef4"></a><!-- doxytag: member="Partitioner::analyze_cfg" ref="19725656eaa83118d75bdd77c617cef4" args="(SgAsmBlock::Reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::analyze_cfg           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48c">SgAsmBlock::Reason</a>&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Detect functions by analyzing the CFG. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l02808">2808</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00465">Partitioner::BasicBlock::address()</a>, <a class="el" href="Partitioner_8h-source.html#l01804">basic_blocks</a>, <a class="el" href="Partitioner_8C-source.html#l00976">canonic_block()</a>, <a class="el" href="Partitioner_8h-source.html#l01812">debug</a>, <a class="el" href="Partitioner_8C-source.html#l02799">discover_blocks()</a>, <a class="el" href="Partitioner_8C-source.html#l02632">discover_first_block()</a>, <a class="el" href="Partitioner_8h-source.html#l00335">Partitioner::Function::entry_va</a>, <a class="el" href="Partitioner_8C-source.html#l00952">find_bb_starting()</a>, <a class="el" href="Partitioner_8C-source.html#l00990">find_function()</a>, <a class="el" href="Partitioner_8h-source.html#l00238">Partitioner::BasicBlock::function</a>, <a class="el" href="Partitioner_8h-source.html#l01805">functions</a>, <a class="el" href="Partitioner_8C-source.html#l00325">is_function_call()</a>, <a class="el" href="Partitioner_8h-source.html#l00331">Partitioner::Function::name</a>, <a class="el" href="Partitioner_8h-source.html#l01821">NO_TARGET</a>, <a class="el" href="Partitioner_8C-source.html#l00068">progress()</a>, <a class="el" href="Partitioner_8h-source.html#l00330">Partitioner::Function::reason</a>, <a class="el" href="SgAsmFunction_8C-source.html#l00026">SgAsmFunction::reason_str()</a>, <a class="el" href="classSgAsmFunction.html#d1e0c37f9e507fc6acaf01dd0794a752921b64c76e93f8581fd16c205aac1516">SgAsmFunction::RET_SOMETIMES</a>, <a class="el" href="stringify_8C-source.html#l22101">stringifySgAsmBlockReason()</a>, and <a class="el" href="Partitioner_8C-source.html#l00345">successors()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03891">partition()</a>, and <a class="el" href="Partitioner_8C-source.html#l03245">post_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="48a2e4d8bd6d15fb31a0ae8e41a747a3"></a><!-- doxytag: member="Partitioner::post_cfg" ref="48a2e4d8bd6d15fb31a0ae8e41a747a3" args="(SgAsmInterpretation *interp=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::post_cfg           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&nbsp;</td>
          <td class="paramname"> <em>interp</em> = <code>NULL</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Detects functions after analyzing the CFG. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l03245">3245</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l03080">adjust_padding()</a>, <a class="el" href="classPartitioner.html#b611787b2c6ef70f765031acde40fdd2">aggregate_statistics()</a>, <a class="el" href="Partitioner_8C-source.html#l02808">analyze_cfg()</a>, <a class="el" href="Partitioner_8h-source.html#l01804">basic_blocks</a>, <a class="el" href="Partitioner_8h-source.html#l01197">Partitioner::FindDataPadding::begins_contiguously</a>, <a class="el" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48cf717779cc969a0f357ac6dae8fa2ddfa">SgAsmBlock::BLK_CFGHEAD</a>, <a class="el" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48c98cf079ce3d66b38c6d7f9f25eea9f73">SgAsmBlock::BLK_GRAPH2</a>, <a class="el" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48c6dc92f7eb3987dc543ca9e14b415b141">SgAsmBlock::BLK_GRAPH3</a>, <a class="el" href="Partitioner_8h-source.html#l00936">clear_aggregate_statistics()</a>, <a class="el" href="Partitioner_8h-source.html#l01812">debug</a>, <a class="el" href="Partitioner_8C-source.html#l02978">detach_thunks()</a>, <a class="el" href="Partitioner_8h-source.html#l01198">Partitioner::FindDataPadding::ends_contiguously</a>, <a class="el" href="Partitioner_8h-source.html#l01809">func_heuristics</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c40c0ce88c447524963f4e8d7ef193cc7">SgAsmFunction::FUNC_IMPORT</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c78785310b2939c8834f597ef91fc17f4">SgAsmFunction::FUNC_INTRABLOCK</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c617301fe6a598b9c4afbde0aebcc8ad5">SgAsmFunction::FUNC_LEFTOVERS</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852ccb6d9cc5789fcc0c98bb6e6894831228">SgAsmFunction::FUNC_MISCMASK</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cdac33191eb0a658ed5382f9076595a28">SgAsmFunction::FUNC_PADDING</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c331ffe7c063699b34757276068c08d79">SgAsmFunction::FUNC_THUNK</a>, <a class="el" href="Partitioner_8h-source.html#l01805">functions</a>, <a class="el" href="Partitioner_8h-source.html#l00930">get_aggregate_variance()</a>, <a class="el" href="classSgAsmGenericHeaderList.html#c3d9878c64af6c90e2d52988f8578b36">SgAsmGenericHeaderList::get_headers()</a>, <a class="el" href="classSgAsmInterpretation.html#5d116938aaa9da9f3e27ca598965c77b">SgAsmInterpretation::get_headers()</a>, <a class="el" href="Partitioner_8h-source.html#l01800">map</a>, <a class="el" href="Partitioner_8h-source.html#l01196">Partitioner::FindDataPadding::maximum_nrep</a>, <a class="el" href="Partitioner_8C-source.html#l03104">merge_function_fragments()</a>, <a class="el" href="Partitioner_8h-source.html#l01195">Partitioner::FindDataPadding::minimum_nrep</a>, <a class="el" href="Partitioner_8h-source.html#l01347">Partitioner::FindThunkTables::minimum_nthunks</a>, <a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575a061dc1ffe578fdaea067d730efb00ac">MemoryMap::MM_PROT_EXEC</a>, <a class="el" href="Partitioner_8C-source.html#l02510">name_import_entries()</a>, <a class="el" href="Partitioner_8C-source.html#l02431">name_plt_entries()</a>, <a class="el" href="Partitioner_8h-source.html#l01194">Partitioner::FindDataPadding::patterns</a>, <a class="el" href="Partitioner_8C-source.html#l00068">progress()</a>, <a class="el" href="MemoryMap_8C-source.html#l00681">MemoryMap::prune()</a>, <a class="el" href="Partitioner_8h-source.html#l01301">Partitioner::FindFunctionFragments::require_intrafunction</a>, <a class="el" href="Partitioner_8h-source.html#l01300">Partitioner::FindFunctionFragments::require_noninterleaved</a>, <a class="el" href="Partitioner_8h-source.html#l01801">ro_map</a>, <a class="el" href="Partitioner_8C-source.html#l01697">scan_interfunc_bytes()</a>, <a class="el" href="Partitioner_8C-source.html#l01643">scan_unassigned_bytes()</a>, <a class="el" href="Partitioner_8C-source.html#l01560">scan_unassigned_insns()</a>, <a class="el" href="Partitioner_8h-source.html#l01302">Partitioner::FindFunctionFragments::threshold</a>, and <a class="el" href="Partitioner_8h-source.html#l01348">Partitioner::FindThunkTables::validate_targets</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03891">partition()</a>.
</div>
</div><p>
<a class="anchor" name="2f7da41ef6f3e3d1e11146ecc4c75a61"></a><!-- doxytag: member="Partitioner::build_ast" ref="2f7da41ef6f3e3d1e11146ecc4c75a61" args="(Function *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> * Partitioner::build_ast           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1Function.html">Function</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Build an AST for a single function. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l03768">3768</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00465">Partitioner::BasicBlock::address()</a>, <a class="el" href="Partitioner_8h-source.html#l00332">Partitioner::Function::basic_blocks</a>, <a class="el" href="Partitioner_8C-source.html#l03705">build_ast()</a>, <a class="el" href="Partitioner_8h-source.html#l00333">Partitioner::Function::data_blocks</a>, <a class="el" href="Partitioner_8h-source.html#l01812">debug</a>, <a class="el" href="Partitioner_8C-source.html#l00484">effective_function()</a>, <a class="el" href="Partitioner_8h-source.html#l00335">Partitioner::Function::entry_va</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cb8251be92d0c4b04f5da036ebeef5bc5">SgAsmFunction::FUNC_DISCONT</a>, <a class="el" href="Partitioner_8C-source.html#l03383">function_extent()</a>, <a class="el" href="Partitioner_8h-source.html#l00304">Partitioner::Function::get_may_return()</a>, <a class="el" href="classSgAsmFunction.html#08fe036249766f5c7bca4403851f9cab">SgAsmFunction::get_statementList()</a>, <a class="el" href="Partitioner_8h-source.html#l00331">Partitioner::Function::name</a>, <a class="el" href="rangemap_8h-source.html#l00934">RangeMap&lt; R, T &gt;::nranges()</a>, <a class="el" href="Partitioner_8h-source.html#l00330">Partitioner::Function::reason</a>, <a class="el" href="classSgAsmFunction.html#d1e0c37f9e507fc6acaf01dd0794a752df440ebe371c3f4fdc1612448157f6bc">SgAsmFunction::RET_NEVER</a>, <a class="el" href="classSgAsmFunction.html#d1e0c37f9e507fc6acaf01dd0794a7520d3fbe8fb9b711a6ca66ef2f09824496">SgAsmFunction::RET_UNKNOWN</a>, <a class="el" href="classSgAsmStatement.html#628c9fd41d1b6d1cfcd94cddc0b117bb">SgAsmStatement::set_address()</a>, <a class="el" href="classSgAsmFunction.html#22eb36588afcbeff004768b4598f8aed">SgAsmFunction::set_entry_va()</a>, <a class="el" href="classSgAsmFunction.html#e30a4cf2e729eaf2f5e1599e85e5b722">SgAsmFunction::set_may_return()</a>, <a class="el" href="classSgAsmFunction.html#91f84d1eb4822282467425d403c6e99c">SgAsmFunction::set_name()</a>, and <a class="el" href="classSgAsmFunction.html#90c5ce34a89fd36621a3b80ffacfb3fc">SgAsmFunction::set_reason()</a>.
</div>
</div><p>
<a class="anchor" name="ed7ad33de4977b27a12453e6c37b8288"></a><!-- doxytag: member="Partitioner::build_ast" ref="ed7ad33de4977b27a12453e6c37b8288" args="(BasicBlock *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> * Partitioner::build_ast           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Build an AST for a single basic block. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l03844">3844</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00465">Partitioner::BasicBlock::address()</a>, <a class="el" href="Partitioner_8h-source.html#l00239">Partitioner::BasicBlock::code_likelihood</a>, <a class="el" href="classSgAsmBlock.html#c19627b98d9cee481b9c533ad21ac755">SgAsmBlock::get_statementList()</a>, <a class="el" href="classSgAsmBlock.html#0e798d793c22e6d6a63a526b6a18e7ce">SgAsmBlock::get_successors()</a>, <a class="el" href="Partitioner_8h-source.html#l00235">Partitioner::BasicBlock::insns</a>, <a class="el" href="Partitioner_8h-source.html#l00234">Partitioner::BasicBlock::reason</a>, <a class="el" href="classSgAsmStatement.html#628c9fd41d1b6d1cfcd94cddc0b117bb">SgAsmStatement::set_address()</a>, <a class="el" href="classSgAsmBlock.html#fa70ebec2668c1614e76b742587f1e22">SgAsmBlock::set_code_likelihood()</a>, <a class="el" href="classSgAsmBlock.html#49da239fdc05d676519696e3e94370a5">SgAsmBlock::set_id()</a>, <a class="el" href="classSgNode.html#83017efa378d75b031330739c963749d">SgNode::set_parent()</a>, <a class="el" href="classSgAsmBlock.html#b18c973e10efc4c6dd6d47990edb779a">SgAsmBlock::set_reason()</a>, <a class="el" href="classSgAsmBlock.html#5bc8828b73e2e1695e336a618ca3213b">SgAsmBlock::set_successors_complete()</a>, and <a class="el" href="Partitioner_8C-source.html#l00345">successors()</a>.
</div>
</div><p>
<a class="anchor" name="ca294bc7e7ed85d40465d7d7c346bd49"></a><!-- doxytag: member="Partitioner::build_ast" ref="ca294bc7e7ed85d40465d7d7c346bd49" args="(DataBlock *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> * Partitioner::build_ast           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Build an AST for a single data block. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l03874">3874</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00474">Partitioner::DataBlock::address()</a>, <a class="el" href="classSgAsmBlock.html#c19627b98d9cee481b9c533ad21ac755">SgAsmBlock::get_statementList()</a>, <a class="el" href="Partitioner_8h-source.html#l00266">Partitioner::DataBlock::nodes</a>, <a class="el" href="Partitioner_8h-source.html#l00267">Partitioner::DataBlock::reason</a>, <a class="el" href="classSgAsmStatement.html#628c9fd41d1b6d1cfcd94cddc0b117bb">SgAsmStatement::set_address()</a>, <a class="el" href="classSgAsmBlock.html#49da239fdc05d676519696e3e94370a5">SgAsmBlock::set_id()</a>, and <a class="el" href="classSgAsmBlock.html#b18c973e10efc4c6dd6d47990edb779a">SgAsmBlock::set_reason()</a>.
</div>
</div><p>
<a class="anchor" name="6da761bf550bd07c05fa615f4091adba"></a><!-- doxytag: member="Partitioner::pops_return_address" ref="6da761bf550bd07c05fa615f4091adba" args="(rose_addr_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Partitioner::pops_return_address           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if a block pops the stack w/o returning. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00400">400</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01812">debug</a>, <a class="el" href="Partitioner_8C-source.html#l00824">discard()</a>, <a class="el" href="Partitioner_8C-source.html#l00904">find_bb_containing()</a>, <a class="el" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">SgAsmx86Instruction::get_kind()</a>, <a class="el" href="Partitioner_8h-source.html#l00498">get_map()</a>, <a class="el" href="Partitioner_8h-source.html#l00235">Partitioner::BasicBlock::insns</a>, <a class="el" href="Partitioner_8C-source.html#l00041">isSgAsmx86Instruction()</a>, <a class="el" href="Partitioner_8C-source.html#l00495">Partitioner::BasicBlock::last_insn()</a>, <a class="el" href="AsmUnparser__compat_8h.html#3b979292833b85f5b059b2893250453c">unparseInstructionWithAddress()</a>, <a class="el" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca557193febfccef733b633e7c6374ea207532">x86_ret</a>, and <a class="el" href="InstructionEnumsX86_8h.html#0b09709b1ff4de1bbe47357b6d7b0e64ac8d2c21aff809a6d4a6303b051c88f7">x86_segreg_ss</a>.
</div>
</div><p>
<a class="anchor" name="8652c15bcdd9d9dca2efb2d9f865f519"></a><!-- doxytag: member="Partitioner::update_analyses" ref="8652c15bcdd9d9dca2efb2d9f865f519" args="(BasicBlock *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::update_analyses           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>bb</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Runs local block analyses if their cached results are invalid and caches the results. 
<p>
A local analysis is one whose results only depend on the specified block and which are valid into the future as long as the instructions in the block do not change. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00270">270</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l00237">Partitioner::BasicBlock::cache</a>, <a class="el" href="Partitioner_8h-source.html#l00191">Partitioner::BlockAnalysisCache::call_target</a>, <a class="el" href="Partitioner_8h-source.html#l01812">debug</a>, <a class="el" href="Partitioner_8C-source.html#l00191">discover_jump_table()</a>, <a class="el" href="Partitioner_8h-source.html#l00196">Partitioner::BlockAnalysisCache::function_return</a>, <a class="el" href="Partitioner_8h-source.html#l00143">Partitioner::Instruction::get_address()</a>, <a class="el" href="Partitioner_8h-source.html#l00144">Partitioner::Instruction::get_size()</a>, <a class="el" href="Partitioner_8h-source.html#l00235">Partitioner::BasicBlock::insns</a>, <a class="el" href="Partitioner_8h-source.html#l00190">Partitioner::BlockAnalysisCache::is_function_call</a>, <a class="el" href="Partitioner_8C-source.html#l00027">isSgAsmInstruction()</a>, <a class="el" href="Partitioner_8C-source.html#l00495">Partitioner::BasicBlock::last_insn()</a>, <a class="el" href="Partitioner_8h-source.html#l01821">NO_TARGET</a>, <a class="el" href="Partitioner_8h-source.html#l01801">ro_map</a>, <a class="el" href="Partitioner_8h-source.html#l00188">Partitioner::BlockAnalysisCache::sucs</a>, <a class="el" href="Partitioner_8h-source.html#l00189">Partitioner::BlockAnalysisCache::sucs_complete</a>, <a class="el" href="Partitioner_8h-source.html#l00220">Partitioner::BasicBlock::valid_cache()</a>, and <a class="el" href="Partitioner_8h-source.html#l00226">Partitioner::BasicBlock::validate_cache()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l00727">append()</a>, <a class="el" href="Partitioner_8C-source.html#l00385">call_target()</a>, <a class="el" href="Partitioner_8C-source.html#l00325">is_function_call()</a>, <a class="el" href="Partitioner_8C-source.html#l01019">mark_ipd_configuration()</a>, and <a class="el" href="Partitioner_8C-source.html#l00345">successors()</a>.
</div>
</div><p>
<a class="anchor" name="bd63242c67a32e6de5434d21956a01bf"></a><!-- doxytag: member="Partitioner::canonic_block" ref="bd63242c67a32e6de5434d21956a01bf" args="(rose_addr_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> Partitioner::canonic_block           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>&nbsp;</td>
          <td class="paramname"> <em>va</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Follow alias links in basic blocks. 
<p>
The input value is the virtual address of a basic block (which need not exist). We recursively look up the specified block and follow its alias_for link until either the block does not exist or it has no alias_for. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00976">976</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l00199">Partitioner::BlockAnalysisCache::alias_for</a>, <a class="el" href="Partitioner_8h-source.html#l00237">Partitioner::BasicBlock::cache</a>, <a class="el" href="Partitioner_8h-source.html#l01812">debug</a>, and <a class="el" href="Partitioner_8C-source.html#l00952">find_bb_starting()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02808">analyze_cfg()</a>, <a class="el" href="Partitioner_8C-source.html#l00385">call_target()</a>, and <a class="el" href="Partitioner_8C-source.html#l00345">successors()</a>.
</div>
</div><p>
<a class="anchor" name="9c333715d5d353bab9fd4f46ce2c2d8d"></a><!-- doxytag: member="Partitioner::is_function_call" ref="9c333715d5d353bab9fd4f46ce2c2d8d" args="(BasicBlock *, rose_addr_t *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Partitioner::is_function_call           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>target_va</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if basic block appears to end with a function call. 
<p>
If the call target can be determined and <code>target_va</code> is non-null, then <code>target_va</code> will be initialized to contain the virtual address of the call target; otherwise it will contain the constant NO_TARGET. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00325">325</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l00237">Partitioner::BasicBlock::cache</a>, <a class="el" href="Partitioner_8h-source.html#l00191">Partitioner::BlockAnalysisCache::call_target</a>, <a class="el" href="Partitioner_8h-source.html#l00190">Partitioner::BlockAnalysisCache::is_function_call</a>, and <a class="el" href="Partitioner_8C-source.html#l00270">update_analyses()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02808">analyze_cfg()</a>, and <a class="el" href="Partitioner_8C-source.html#l00904">find_bb_containing()</a>.
</div>
</div><p>
<a class="anchor" name="64d3ebb83d085cd1709305c13a2bbd7d"></a><!-- doxytag: member="Partitioner::is_thunk" ref="64d3ebb83d085cd1709305c13a2bbd7d" args="(Function *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Partitioner::is_thunk           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1Function.html">Function</a> *&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if function is a thunk. 
<p>
A thunk is a small piece of code (a function) whose only purpose is to branch to another function. This predicate should not be confused with the <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c331ffe7c063699b34757276068c08d79">SgAsmFunction::FUNC_THUNK</a> reason bit; the latter is only an indication of why the function was originally created. A thunk (as defined by this predicate) might not have the FUNC_THUNK reason bit set if this function was detected by other means (such as being a target of a function call). Conversely, a function that has the FUNC_THUNK reason bit set might not qualify as being a thunk by the definition implemented in this predicate (additional blocks or instructions might have been discovered that disqualify this function even though it was originally thought to be a thunk). 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l02300">2300</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l00332">Partitioner::Function::basic_blocks</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c617301fe6a598b9c4afbde0aebcc8ad5">SgAsmFunction::FUNC_LEFTOVERS</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cdac33191eb0a658ed5382f9076595a28">SgAsmFunction::FUNC_PADDING</a>, <a class="el" href="Partitioner_8h-source.html#l01805">functions</a>, <a class="el" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">SgAsmx86Instruction::get_kind()</a>, <a class="el" href="Partitioner_8h-source.html#l00235">Partitioner::BasicBlock::insns</a>, <a class="el" href="Partitioner_8C-source.html#l00041">isSgAsmx86Instruction()</a>, <a class="el" href="Partitioner_8h-source.html#l00330">Partitioner::Function::reason</a>, <a class="el" href="Partitioner_8C-source.html#l00345">successors()</a>, <a class="el" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca557198fb4c6bacf21d45da2c1eb7380caccc">x86_farjmp</a>, and <a class="el" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571ad03bc3cf5ca0f4918d34b66a2ae0b24">x86_jmp</a>.
</div>
</div><p>
<a class="anchor" name="cd1de02179852d54139e2f4eb366ebdc"></a><!-- doxytag: member="Partitioner::effective_function" ref="cd1de02179852d54139e2f4eb366ebdc" args="(DataBlock *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPartitioner_1_1Function.html">Partitioner::Function</a> * Partitioner::effective_function           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>dblock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the function to which this data block is effectively assigned. 
<p>
This returns, in this order, the function to which this data block is explicitly assigned, the function to which this block is implicitly assigned via an association with a basic block, or a null pointer. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00484">484</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l00269">Partitioner::DataBlock::basic_block</a>, <a class="el" href="Partitioner_8h-source.html#l00238">Partitioner::BasicBlock::function</a>, and <a class="el" href="Partitioner_8h-source.html#l00268">Partitioner::DataBlock::function</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03080">adjust_padding()</a>, <a class="el" href="Partitioner_8C-source.html#l03768">build_ast()</a>, <a class="el" href="Partitioner_8C-source.html#l03474">datablock_extent()</a>, <a class="el" href="Partitioner_8C-source.html#l03525">is_contiguous()</a>, and <a class="el" href="Partitioner_8C-source.html#l03460">padding_extent()</a>.
</div>
</div><p>
<a class="anchor" name="e9e536212c2e5efdf21ad22993d5c888"></a><!-- doxytag: member="Partitioner::mark_call_insns" ref="e9e536212c2e5efdf21ad22993d5c888" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::mark_call_insns           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Naive marking of CALL instruction targets as functions. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l01524">1524</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00999">add_function()</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852ceea34044afa2b5415dad4b39cf2aa51d">SgAsmFunction::FUNC_CALL_TARGET</a>, and <a class="el" href="Partitioner_8h-source.html#l01821">NO_TARGET</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02569">pre_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="fd2b60293bc45d47e74befebde631533"></a><!-- doxytag: member="Partitioner::mark_ipd_configuration" ref="fd2b60293bc45d47e74befebde631533" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::mark_ipd_configuration           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Seeds partitioner with IPD configuration information. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l01019">1019</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="namespaceStringUtility.html#b07dfdb6df484680f9a29ad4fcf79f80">StringUtility::addrToString()</a>, <a class="el" href="Partitioner_8h-source.html#l01814">block_config</a>, <a class="el" href="MemoryMap_8C-source.html#l00231">MemoryMap::AnonymousBuffer::create()</a>, <a class="el" href="MemoryMap_8C-source.html#l00137">MemoryMap::ExternBuffer::create()</a>, <a class="el" href="Partitioner_8h-source.html#l01812">debug</a>, <a class="el" href="namespaceSageInterface.html#57437bbbb806858dda0cea7444fbafef">SageInterface::deleteAST()</a>, <a class="el" href="classDisassembler.html#d765ce924af663d75b9ce5915d658d7c">Disassembler::disassembleOne()</a>, <a class="el" href="Partitioner_8h-source.html#l01798">disassembler</a>, <a class="el" href="MemoryMap_8C-source.html#l00854">MemoryMap::dump()</a>, <a class="el" href="MemoryMap_8C-source.html#l00622">MemoryMap::erase()</a>, <a class="el" href="Partitioner_8C-source.html#l00952">find_bb_starting()</a>, <a class="el" href="MemoryMap_8C-source.html#l00648">MemoryMap::find_free()</a>, <a class="el" href="Partitioner_8h-source.html#l00498">get_map()</a>, <a class="el" href="MemoryMap_8C-source.html#l00585">MemoryMap::insert()</a>, <a class="el" href="Partitioner_8C-source.html#l00041">isSgAsmx86Instruction()</a>, <a class="el" href="Disassembler_8C-source.html#l00172">Disassembler::lookup()</a>, <a class="el" href="Partitioner_8h-source.html#l01800">map</a>, <a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd5757928ac57b8a90b020a73405a03fdfe3d">MemoryMap::MM_PROT_RW</a>, <a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd57589290f94ccb75d2e8b659c4ef50bb700">MemoryMap::MM_PROT_RX</a>, <a class="el" href="namespaceStringUtility.html#e60d57efaa1e2a94776bd42908d62de5">StringUtility::numberToString()</a>, <a class="el" href="Partitioner_8C-source.html#l00659">truncate()</a>, <a class="el" href="AsmUnparser__compat_8h.html#30492a6c8df6a943ca55224e62c322c8">unparseInstruction()</a>, <a class="el" href="Partitioner_8C-source.html#l00270">update_analyses()</a>, and <a class="el" href="InstructionEnumsX86_8h.html#0b09709b1ff4de1bbe47357b6d7b0e64ac8d2c21aff809a6d4a6303b051c88f7">x86_segreg_ss</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02569">pre_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="1f7de70089099ce3d31af5ed455fc9b7"></a><!-- doxytag: member="Partitioner::mark_entry_targets" ref="1f7de70089099ce3d31af5ed455fc9b7" args="(SgAsmGenericHeader *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::mark_entry_targets           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Seeds functions for program entry points. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l01192">1192</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00999">add_function()</a>, <a class="el" href="Partitioner_8C-source.html#l00869">find_instruction()</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c2c1716e490136fddc09c145d8809ed64">SgAsmFunction::FUNC_ENTRY_POINT</a>, <a class="el" href="classSgAsmGenericHeader.html#fb6c62c0fdc956105bfae2263617446e">SgAsmGenericHeader::get_base_va()</a>, and <a class="el" href="classSgAsmGenericHeader.html#a6d2b0b9c6469a2ff98bb9021a41cc9e">SgAsmGenericHeader::get_entry_rvas()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02569">pre_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="167cda7ee682478117f8480d86815efc"></a><!-- doxytag: member="Partitioner::mark_eh_frames" ref="167cda7ee682478117f8480d86815efc" args="(SgAsmGenericHeader *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::mark_eh_frames           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Seeds functions for error handling frames. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l01204">1204</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00999">add_function()</a>, <a class="el" href="Partitioner_8C-source.html#l00869">find_instruction()</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cd7e1055f3974be70f4e4d88e758ed666">SgAsmFunction::FUNC_EH_FRAME</a>, <a class="el" href="classSgAsmElfEHFrameSection.html#d7939c95532f3e26e6693ffead3293f6">SgAsmElfEHFrameSection::get_ci_entries()</a>, <a class="el" href="classSgAsmElfEHFrameEntryFDList.html#857b7f91ee69de6582eee3bc38336368">SgAsmElfEHFrameEntryFDList::get_entries()</a>, <a class="el" href="classSgAsmElfEHFrameEntryCIList.html#2f2fc1a72617b1a793d4c0107f06d82c">SgAsmElfEHFrameEntryCIList::get_entries()</a>, <a class="el" href="classSgAsmGenericSectionList.html#239d407e4df928777b992e8fdfc6e685">SgAsmGenericSectionList::get_sections()</a>, <a class="el" href="classSgAsmGenericHeader.html#5cefae0c9db1832cd75642799bc33762">SgAsmGenericHeader::get_sections()</a>, and <a class="el" href="Cxx__Grammar_8h.html#d08e263414ec2d08e4a09aa531be9b91">isSgAsmElfEHFrameSection()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02569">pre_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="20bab02d75f2c49035e63dc029635698"></a><!-- doxytag: member="Partitioner::mark_elf_plt_entries" ref="20bab02d75f2c49035e63dc029635698" args="(SgAsmGenericHeader *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::mark_elf_plt_entries           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Seeds functions that are dynamically linked via .plt. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l01227">1227</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00999">add_function()</a>, <a class="el" href="Partitioner_8C-source.html#l00869">find_instruction()</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c40c0ce88c447524963f4e8d7ef193cc7">SgAsmFunction::FUNC_IMPORT</a>, <a class="el" href="Partitioner_8h-source.html#l00143">Partitioner::Instruction::get_address()</a>, <a class="el" href="classSgAsmGenericHeader.html#fb6c62c0fdc956105bfae2263617446e">SgAsmGenericHeader::get_base_va()</a>, <a class="el" href="Partitioner_8C-source.html#l02397">get_indirection_addr()</a>, <a class="el" href="classSgAsmGenericSection.html#ea9f50c4b61b494c81f6f2d1382f3de5">SgAsmGenericSection::get_mapped_actual_va()</a>, <a class="el" href="GenericSection_8C-source.html#l00257">SgAsmGenericSection::get_mapped_preferred_rva()</a>, <a class="el" href="GenericSection_8C-source.html#l00238">SgAsmGenericSection::get_mapped_size()</a>, <a class="el" href="GenericDynamicLinking_8C-source.html#l00056">SgAsmGenericSymbol::get_name()</a>, <a class="el" href="GenericHeader_8C-source.html#l00195">SgAsmGenericHeader::get_section_by_name()</a>, <a class="el" href="classSgAsmGenericSectionList.html#239d407e4df928777b992e8fdfc6e685">SgAsmGenericSectionList::get_sections()</a>, <a class="el" href="classSgAsmGenericHeader.html#5cefae0c9db1832cd75642799bc33762">SgAsmGenericHeader::get_sections()</a>, <a class="el" href="Partitioner_8h-source.html#l00144">Partitioner::Instruction::get_size()</a>, <a class="el" href="GenericString_8C-source.html#l00006">SgAsmGenericString::get_string()</a>, <a class="el" href="classSgAsmElfSymbolList.html#f0bad6ae664035299ed6102dce7cd4e3">SgAsmElfSymbolList::get_symbols()</a>, <a class="el" href="classSgAsmElfSymbolSection.html#68c30567293ca0163f091dd2c8c19e8c">SgAsmElfSymbolSection::get_symbols()</a>, <a class="el" href="GenericSection_8C-source.html#l00218">SgAsmGenericSection::is_mapped()</a>, <a class="el" href="Cxx__Grammar_8h.html#634969907f40ab0a68fa945423fc355a">isSgAsmElfFileHeader()</a>, <a class="el" href="Cxx__Grammar_8h.html#659c355083a0fd75c56da2364ae4f08b">isSgAsmElfRelocSection()</a>, <a class="el" href="Cxx__Grammar_8h.html#faaae5166c764907865b84e4aca5f2be">isSgAsmElfSymbolSection()</a>, <a class="el" href="Partitioner_8C-source.html#l00041">isSgAsmx86Instruction()</a>, <a class="el" href="classSgAsmFunction.html#d1e0c37f9e507fc6acaf01dd0794a7528cf02b4f0b67544a9fafcf0fbc28ee19">SgAsmFunction::RET_ALWAYS</a>, <a class="el" href="classSgAsmFunction.html#d1e0c37f9e507fc6acaf01dd0794a752df440ebe371c3f4fdc1612448157f6bc">SgAsmFunction::RET_NEVER</a>, and <a class="el" href="Partitioner_8h-source.html#l00305">Partitioner::Function::set_may_return()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02569">pre_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="5856443d8da3aeb540e193491619dab8"></a><!-- doxytag: member="Partitioner::mark_func_symbols" ref="5856443d8da3aeb540e193491619dab8" args="(SgAsmGenericHeader *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::mark_func_symbols           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Seeds functions that correspond to function symbols. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l01307">1307</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00999">add_function()</a>, <a class="el" href="Partitioner_8C-source.html#l00869">find_instruction()</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c10eee68a3ad870f7e48faef2639a853a">SgAsmFunction::FUNC_SYMBOL</a>, <a class="el" href="classSgAsmGenericSectionList.html#239d407e4df928777b992e8fdfc6e685">SgAsmGenericSectionList::get_sections()</a>, <a class="el" href="classSgAsmGenericHeader.html#5cefae0c9db1832cd75642799bc33762">SgAsmGenericHeader::get_sections()</a>, <a class="el" href="classSgAsmCoffSymbolList.html#99bdd0304e1061727edc840ca884aeed">SgAsmCoffSymbolList::get_symbols()</a>, <a class="el" href="classSgAsmElfSymbolList.html#f0bad6ae664035299ed6102dce7cd4e3">SgAsmElfSymbolList::get_symbols()</a>, <a class="el" href="Cxx__Grammar_8h.html#3784b7e019b3c0e729e465249b471c4f">isSgAsmCoffSymbolTable()</a>, <a class="el" href="Cxx__Grammar_8h.html#faaae5166c764907865b84e4aca5f2be">isSgAsmElfSymbolSection()</a>, <a class="el" href="classSgAsmGenericSymbol.html#e64e9dd59a83e83566671d7cad4432ef16df55db1f93a2213909c5106c310824">SgAsmGenericSymbol::SYM_DEFINED</a>, <a class="el" href="classSgAsmGenericSymbol.html#25348ff5aed9d9e7c581db9d610f955cf63811b9d936e39b907895e2565b553f">SgAsmGenericSymbol::SYM_FUNC</a>, and <a class="el" href="classSgAsmGenericSymbol.html#4957aa9672fd1498b565c12b6691d5c00d7c5f0c368b014a3c762f7ad408eabd">SgAsmGenericSymbol::SYM_WEAK</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02569">pre_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="608c32001c0e56d18e41ce2d77976f9d"></a><!-- doxytag: member="Partitioner::mark_func_patterns" ref="608c32001c0e56d18e41ce2d77976f9d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::mark_func_patterns           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Seeds functions according to instruction patterns. 
<p>
Note that this pattern matcher only looks at existing instructions--it does not actively disassemble new instructions. In other words, this matcher is intended mostly for passive-mode partitioners where the disassembler has already disassembled everything it can. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l01497">1497</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00999">add_function()</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852cd01f7a2ed6ff7e8a3e6c4550d0ccaa63">SgAsmFunction::FUNC_PATTERN</a>, and <a class="el" href="Partitioner_8C-source.html#l01349">pattern1()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02569">pre_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="17cac3fb6a8a12bf633c70e4640728ff"></a><!-- doxytag: member="Partitioner::name_plt_entries" ref="17cac3fb6a8a12bf633c70e4640728ff" args="(SgAsmGenericHeader *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::name_plt_entries           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *&nbsp;</td>
          <td class="paramname"> <em>fhdr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gives names to dynmaic linking trampolines for ELF. 
<p>
This method gives names to the dynamic linking trampolines in the .plt section if the <a class="el" href="classPartitioner.html">Partitioner</a> detected them as functions. If <a class="el" href="classPartitioner.html#20bab02d75f2c49035e63dc029635698">mark_elf_plt_entries()</a> was called then they all would have been marked as functions and given names. Otherwise, <a class="el" href="namespaceROSE.html">ROSE</a> might have detected some of them in other ways (like CFG analysis) and this function will give them names. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l02431">2431</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00869">find_instruction()</a>, <a class="el" href="Partitioner_8h-source.html#l01805">functions</a>, <a class="el" href="classSgAsmGenericHeader.html#fb6c62c0fdc956105bfae2263617446e">SgAsmGenericHeader::get_base_va()</a>, <a class="el" href="Partitioner_8C-source.html#l02397">get_indirection_addr()</a>, <a class="el" href="GenericSection_8C-source.html#l00257">SgAsmGenericSection::get_mapped_preferred_rva()</a>, <a class="el" href="GenericSection_8C-source.html#l00238">SgAsmGenericSection::get_mapped_size()</a>, <a class="el" href="GenericDynamicLinking_8C-source.html#l00056">SgAsmGenericSymbol::get_name()</a>, <a class="el" href="GenericHeader_8C-source.html#l00195">SgAsmGenericHeader::get_section_by_name()</a>, <a class="el" href="classSgAsmGenericSectionList.html#239d407e4df928777b992e8fdfc6e685">SgAsmGenericSectionList::get_sections()</a>, <a class="el" href="classSgAsmGenericHeader.html#5cefae0c9db1832cd75642799bc33762">SgAsmGenericHeader::get_sections()</a>, <a class="el" href="GenericString_8C-source.html#l00006">SgAsmGenericString::get_string()</a>, <a class="el" href="classSgAsmElfSymbolList.html#f0bad6ae664035299ed6102dce7cd4e3">SgAsmElfSymbolList::get_symbols()</a>, <a class="el" href="classSgAsmElfSymbolSection.html#68c30567293ca0163f091dd2c8c19e8c">SgAsmElfSymbolSection::get_symbols()</a>, <a class="el" href="GenericSection_8C-source.html#l00218">SgAsmGenericSection::is_mapped()</a>, <a class="el" href="Cxx__Grammar_8h.html#634969907f40ab0a68fa945423fc355a">isSgAsmElfFileHeader()</a>, <a class="el" href="Cxx__Grammar_8h.html#659c355083a0fd75c56da2364ae4f08b">isSgAsmElfRelocSection()</a>, <a class="el" href="Cxx__Grammar_8h.html#faaae5166c764907865b84e4aca5f2be">isSgAsmElfSymbolSection()</a>, and <a class="el" href="Partitioner_8C-source.html#l00041">isSgAsmx86Instruction()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03245">post_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="dc7b9b7851ee14847eed8454619cb505"></a><!-- doxytag: member="Partitioner::name_import_entries" ref="dc7b9b7851ee14847eed8454619cb505" args="(SgAsmGenericHeader *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::name_import_entries           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *&nbsp;</td>
          <td class="paramname"> <em>fhdr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gives names to dynamic linking thunks for PE. 
<p>
This method gives names to thunks for imported functions. The thunks must have already been detected by the partitioner--this method does not create new functions. The algorithm scans the list of unnamed functions looking for functions whose entry instruction is an indirect jump. When found, check whether the jump is through a memory address that part of an import address table. If so, use the corresponding import name as the name of this function and append "@import". The "@import" is to distinguish between the actual function whose name is given in the PE Import Section, and the thunk that jumps to that function. It's possible to have multiple thunks that all jump to the same imported function and thus all have the same name. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l02510">2510</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01812">debug</a>, <a class="el" href="Partitioner_8C-source.html#l00869">find_instruction()</a>, <a class="el" href="Partitioner_8h-source.html#l01805">functions</a>, <a class="el" href="classSgAsmMemoryReferenceExpression.html#b5e0f8d74e3aa16aeef0ac063d6a112c">SgAsmMemoryReferenceExpression::get_address()</a>, <a class="el" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">SgAsmx86Instruction::get_kind()</a>, <a class="el" href="classSgAsmInstruction.html#264e86d032b0a589d9dc520e79d09eb8">SgAsmInstruction::get_operandList()</a>, <a class="el" href="classSgAsmOperandList.html#bb5638c0533863030ad7acee019f1f17">SgAsmOperandList::get_operands()</a>, <a class="el" href="Cxx__Grammar_8h.html#de53c81adf2fb05def17e8e660ff4e18">isSgAsmMemoryReferenceExpression()</a>, <a class="el" href="Cxx__Grammar_8h.html#f17b1e963bc0432adc451e9785358e37">isSgAsmPEFileHeader()</a>, <a class="el" href="Cxx__Grammar_8h.html#e223cffb51a81e8cd4506c2dffc3382f">isSgAsmPEImportItem()</a>, <a class="el" href="Cxx__Grammar_8h.html#4f477d8260444d2a9e08132c691d25a8">isSgAsmValueExpression()</a>, <a class="el" href="Partitioner_8C-source.html#l00041">isSgAsmx86Instruction()</a>, <a class="el" href="Cxx__Grammar_8h.html#59f7fee88581c4dd75f5fb25dbefa29edefb5d09673c144dc5b4dc177e278696">preorder</a>, <a class="el" href="Partitioner_8C-source.html#l02378">value_of()</a>, <a class="el" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca557198fb4c6bacf21d45da2c1eb7380caccc">x86_farjmp</a>, and <a class="el" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571ad03bc3cf5ca0f4918d34b66a2ae0b24">x86_jmp</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03245">post_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="3a1386d81012e94a46184c4703fd9e40"></a><!-- doxytag: member="Partitioner::function_extent" ref="3a1386d81012e94a46184c4703fd9e40" args="(FunctionRangeMap *extents)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Partitioner::function_extent           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRangeMap.html">FunctionRangeMap</a> *&nbsp;</td>
          <td class="paramname"> <em>extents</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds extents for all defined functions. 
<p>
Scans across all known functions and adds their extents to the specified <a class="el" href="classRangeMap.html">RangeMap</a> argument. Returns the sum of the return values from the single-function <a class="el" href="classPartitioner.html#3a1386d81012e94a46184c4703fd9e40">function_extent()</a> method. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l03383">3383</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01805">functions</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03080">adjust_padding()</a>, <a class="el" href="Partitioner_8C-source.html#l03705">build_ast()</a>, <a class="el" href="Partitioner_8C-source.html#l03525">is_contiguous()</a>, <a class="el" href="Partitioner_8C-source.html#l02036">Partitioner::FindFunctionFragments::operator()()</a>, and <a class="el" href="Partitioner_8C-source.html#l01643">scan_unassigned_bytes()</a>.
</div>
</div><p>
<a class="anchor" name="4e30200e210edc6193cc8d4edd873607"></a><!-- doxytag: member="Partitioner::function_extent" ref="4e30200e210edc6193cc8d4edd873607" args="(Function *, FunctionRangeMap *extents=NULL, rose_addr_t *lo_addr=NULL, rose_addr_t *hi_addr=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Partitioner::function_extent           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1Function.html">Function</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRangeMap.html">FunctionRangeMap</a> *&nbsp;</td>
          <td class="paramname"> <em>extents</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>lo_addr</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>hi_addr</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns information about the function addresses. 
<p>
Every non-empty function has a minimum (inclusive) and maximum (exclusive) address which are returned by reference, but not all functions own all the bytes within that range of addresses. Therefore, the exact bytes are returned by adding them to the optional <a class="el" href="classExtentMap.html">ExtentMap</a> argument. This function returns the number of nodes (instructions and static data items) in the function. If the function contains no nodes then the extent map is not modified and the low and high addresses are both set to zero.<p>
See also: <a class="el" href="classSgAsmFunction.html#a8c95eb809c88fd98faac698d96bf7f3">SgAsmFunction::get_extent()</a>, which calculates the same information but can be used only after we've constructed the AST for the function. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l03392">3392</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l00332">Partitioner::Function::basic_blocks</a>, <a class="el" href="rangemap_8h-source.html#l00775">RangeMap&lt; R, T &gt;::begin()</a>, <a class="el" href="Partitioner_8h-source.html#l00333">Partitioner::Function::data_blocks</a>, <a class="el" href="Partitioner_8C-source.html#l03488">datablock_extent()</a>, <a class="el" href="rangemap_8h-source.html#l00787">RangeMap&lt; R, T &gt;::end()</a>, and <a class="el" href="rangemap_8h-source.html#l01062">RangeMap&lt; R, T &gt;::insert()</a>.
</div>
</div><p>
<a class="anchor" name="b887328bc3f2afab215f8c0e7e5603c9"></a><!-- doxytag: member="Partitioner::datablock_extent" ref="b887328bc3f2afab215f8c0e7e5603c9" args="(DataBlock *, DataRangeMap *extents=NULL, rose_addr_t *lo_addr=NULL, rose_addr_t *hi_addr=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Partitioner::datablock_extent           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPartitioner_1_1DataBlock.html">DataBlock</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRangeMap.html">DataRangeMap</a> *&nbsp;</td>
          <td class="paramname"> <em>extents</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>lo_addr</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>hi_addr</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns information about the datablock addresses. 
<p>
Every data block has a minimum (inclusive) and maximum (exclusive) address which are returned by reference, but some of the addresses in that range might not be owned by the specified data block. Therefore, the exact bytes are returned by adding them to the optional <a class="el" href="classExtentMap.html">ExtentMap</a> argument. This function returns the number of nodes (static data items) in the data block. If the data block contains no nodes then the extent map is not modified, the low and high addresses are both set to zero, and the return value is zero. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l03488">3488</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="rangemap_8h-source.html#l01062">RangeMap&lt; R, T &gt;::insert()</a>, and <a class="el" href="Partitioner_8h-source.html#l00266">Partitioner::DataBlock::nodes</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03474">datablock_extent()</a>, <a class="el" href="Partitioner_8C-source.html#l01998">find_db_starting()</a>, <a class="el" href="Partitioner_8C-source.html#l03613">fixup_pointers()</a>, <a class="el" href="Partitioner_8C-source.html#l03392">function_extent()</a>, and <a class="el" href="Partitioner_8C-source.html#l03460">padding_extent()</a>.
</div>
</div><p>
<a class="anchor" name="481f8f89f2c2427ef13f3a737448c927"></a><!-- doxytag: member="Partitioner::datablock_extent" ref="481f8f89f2c2427ef13f3a737448c927" args="(DataRangeMap *extent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Partitioner::datablock_extent           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRangeMap.html">DataRangeMap</a> *&nbsp;</td>
          <td class="paramname"> <em>extent</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds assigned datablocks to extent. 
<p>
Scans across all known data blocks and for any block that's assigned to a function, adds that block's extents to the supplied <a class="el" href="classRangeMap.html">RangeMap</a>. Return value is the number of data blocks added. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l03474">3474</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01807">data_blocks</a>, <a class="el" href="Partitioner_8C-source.html#l03488">datablock_extent()</a>, and <a class="el" href="Partitioner_8C-source.html#l00484">effective_function()</a>.
</div>
</div><p>
<a class="anchor" name="af310f1d4a77ace2f3b3ecc05e376c20"></a><!-- doxytag: member="Partitioner::padding_extent" ref="af310f1d4a77ace2f3b3ecc05e376c20" args="(DataRangeMap *extent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Partitioner::padding_extent           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRangeMap.html">DataRangeMap</a> *&nbsp;</td>
          <td class="paramname"> <em>extent</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds padding datablocks to extent. 
<p>
Scans across all known data blocks, and for any padding block that's assigned to a function, adds that block's extents to the supplied <a class="el" href="classRangeMap.html">RangeMap</a>. Return value is the number of padding blocks added. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l03460">3460</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48c155cde4b70560fc1bf7c615263adf0b0">SgAsmBlock::BLK_PADDING</a>, <a class="el" href="Partitioner_8h-source.html#l01807">data_blocks</a>, <a class="el" href="Partitioner_8C-source.html#l03488">datablock_extent()</a>, and <a class="el" href="Partitioner_8C-source.html#l00484">effective_function()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03080">adjust_padding()</a>, <a class="el" href="Partitioner_8C-source.html#l02176">Partitioner::FindInterPadFunctions::operator()()</a>, and <a class="el" href="Partitioner_8C-source.html#l01820">Partitioner::FindData::operator()()</a>.
</div>
</div><p>
<a class="anchor" name="8e3fb4de9cbbd0a0bba2c3392f3361f9"></a><!-- doxytag: member="Partitioner::is_contiguous" ref="8e3fb4de9cbbd0a0bba2c3392f3361f9" args="(Function *, bool strict=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Partitioner::is_contiguous           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1Function.html">Function</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>strict</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an indication of whether a function is contiguous. 
<p>
All empty functions are contiguous. If <code>strict</code> is true, then a function is contiguous if it owns all bytes in a contiguous range of the address space. If <code>strict</code> is false then the definition is relaxed so that the instructions need not be contiguous in memory as long as no other function owns any of the bytes between this function's low and high address range. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l03525">3525</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01807">data_blocks</a>, <a class="el" href="Partitioner_8C-source.html#l00484">effective_function()</a>, <a class="el" href="Partitioner_8C-source.html#l00904">find_bb_containing()</a>, <a class="el" href="Partitioner_8h-source.html#l00238">Partitioner::BasicBlock::function</a>, <a class="el" href="Partitioner_8C-source.html#l03383">function_extent()</a>, and <a class="el" href="rangemap_8h-source.html#l00942">RangeMap&lt; R, T &gt;::size()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02036">Partitioner::FindFunctionFragments::operator()()</a>.
</div>
</div><p>
<a class="anchor" name="a4ec978230e19cc6bd34d60be7801452"></a><!-- doxytag: member="Partitioner::get_indirection_addr" ref="a4ec978230e19cc6bd34d60be7801452" args="(SgAsmInstruction *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> Partitioner::get_indirection_addr           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the virtual address that holds the branch target for an indirect branch. 
<p>
For example, when called with these instructions:<p>
<div class="fragment"><pre class="fragment">     jmp DWORD PTR ds:[0x80496b0]        -&gt; (x86)   returns 80496b0
     jmp QWORD PTR ds:[rip+0x200b52]     -&gt; (amd64) returns 200b52 + address following instruction
</pre></div><p>
We only handle instructions that appear as the first instruction in an ELF .plt entry. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l02397">2397</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">SgAsmStatement::get_address()</a>, <a class="el" href="classSgAsmMemoryReferenceExpression.html#b5e0f8d74e3aa16aeef0ac063d6a112c">SgAsmMemoryReferenceExpression::get_address()</a>, <a class="el" href="classSgAsmRegisterReferenceExpression.html#e4a2ae3037e897d983674a61bbf16ec0">SgAsmRegisterReferenceExpression::get_descriptor()</a>, <a class="el" href="classSgAsmBinaryExpression.html#14af858f7b9e4bd5de65982c9080688f">SgAsmBinaryExpression::get_lhs()</a>, <a class="el" href="Cxx__Grammar_8h-source.html#l05133">RegisterDescriptor::get_major()</a>, <a class="el" href="classSgAsmInstruction.html#264e86d032b0a589d9dc520e79d09eb8">SgAsmInstruction::get_operandList()</a>, <a class="el" href="classSgAsmOperandList.html#bb5638c0533863030ad7acee019f1f17">SgAsmOperandList::get_operands()</a>, <a class="el" href="classSgAsmBinaryExpression.html#39bf53f0b93068e84075ce17526e845b">SgAsmBinaryExpression::get_rhs()</a>, <a class="el" href="Cxx__Grammar_8h-source.html#l217707">SgAsmInstruction::get_size()</a>, <a class="el" href="Cxx__Grammar_8h.html#b168edf9057af44e40677187242cfca5">isSgAsmBinaryExpression()</a>, <a class="el" href="Cxx__Grammar_8h.html#de53c81adf2fb05def17e8e660ff4e18">isSgAsmMemoryReferenceExpression()</a>, <a class="el" href="Cxx__Grammar_8h.html#4f477d8260444d2a9e08132c691d25a8">isSgAsmValueExpression()</a>, <a class="el" href="Partitioner_8C-source.html#l00041">isSgAsmx86Instruction()</a>, <a class="el" href="Cxx__Grammar_8h.html#5e5ead71a8653e1d062d92582359e574">isSgAsmx86RegisterReferenceExpression()</a>, <a class="el" href="Partitioner_8C-source.html#l02378">value_of()</a>, and <a class="el" href="InstructionEnumsX86_8h.html#12229bfc0029dbc592944d1d6514e30f7d690d572a18c19f87bfb2cb0d2b490c">x86_regclass_ip</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l01227">mark_elf_plt_entries()</a>, and <a class="el" href="Partitioner_8C-source.html#l02431">name_plt_entries()</a>.
</div>
</div><p>
<a class="anchor" name="36e3aa4734377dacea3614c7dd5fd5e6"></a><!-- doxytag: member="Partitioner::value_of" ref="36e3aa4734377dacea3614c7dd5fd5e6" args="(SgAsmValueExpression *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> Partitioner::value_of           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmValueExpression.html">SgAsmValueExpression</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the integer value of a value expression since there's no virtual method for doing this. 
<p>
(FIXME) 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l02378">2378</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Expressions_8C-source.html#l00382">SgAsmQuadWordValueExpression::get_value()</a>, <a class="el" href="Expressions_8C-source.html#l00366">SgAsmDoubleWordValueExpression::get_value()</a>, <a class="el" href="Expressions_8C-source.html#l00350">SgAsmWordValueExpression::get_value()</a>, <a class="el" href="Expressions_8C-source.html#l00334">SgAsmByteValueExpression::get_value()</a>, <a class="el" href="Cxx__Grammar_8h.html#69220e527d62b6b2df9e5a6321ac0f7d">isSgAsmByteValueExpression()</a>, <a class="el" href="Cxx__Grammar_8h.html#da4951b2a5743765b3427d5ea4057e48">isSgAsmDoubleWordValueExpression()</a>, <a class="el" href="Cxx__Grammar_8h.html#86d1906725133b85b9114c14572db22b">isSgAsmQuadWordValueExpression()</a>, and <a class="el" href="Cxx__Grammar_8h.html#26f8959436fc609bf33bb645b4e41bed">isSgAsmWordValueExpression()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02397">get_indirection_addr()</a>, and <a class="el" href="Partitioner_8C-source.html#l02510">name_import_entries()</a>.
</div>
</div><p>
<a class="anchor" name="044f608ba9d2cf1d4b9d22b2c53ccea9"></a><!-- doxytag: member="Partitioner::progress" ref="044f608ba9d2cf1d4b9d22b2c53ccea9" args="(FILE *, const char *fmt,...) const __attribute__((format(printf" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::progress           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>debug</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Conditionally prints a progress report. 
<p>
If progress reporting is enabled and the required amount of time has elapsed since the previous report, then the supplied report is emited. Also, if debugging is enabled the report is emitted to the debugging file regardless of the elapsed time. The arguments are the same as fprintf(). 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00068">68</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01818">progress_file</a>, <a class="el" href="Partitioner_8h-source.html#l01816">progress_interval</a>, and <a class="el" href="Partitioner_8h-source.html#l01817">progress_time</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02808">analyze_cfg()</a>, and <a class="el" href="Partitioner_8C-source.html#l03245">post_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="50ae683bbc187c44dc13dcac778fd502"></a><!-- doxytag: member="Partitioner::detach_thunks" ref="50ae683bbc187c44dc13dcac778fd502" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Partitioner::detach_thunks           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Splits thunks off of the start of functions. 
<p>
Splits as many thunks as possible from the front of all known functions. Returns the number of thunks split off from functions. It's not important that this be done, but doing so results in functions that more closely match what some other disassemblers do when provided with debug info. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l02978">2978</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l02990">detach_thunk()</a>, and <a class="el" href="Partitioner_8h-source.html#l01805">functions</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03245">post_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="b6d3411d68e7aa9a994850b672f01af0"></a><!-- doxytag: member="Partitioner::detach_thunk" ref="b6d3411d68e7aa9a994850b672f01af0" args="(Function *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Partitioner::detach_thunk           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1Function.html">Function</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Splits one thunk off the start of a function if possible. 
<p>
Since the partitioner constructs functions according to the control flow graph, thunks (JMP to start of function) often become part of the function to which they jump. This can happen if the real function has no direct callers and was not detected as a function entry point due to any pattern or symbol. The <a class="el" href="classPartitioner.html#50ae683bbc187c44dc13dcac778fd502">detach_thunks()</a> function traverses all defined functions and looks for cases where the thunk is attached to the jumped-to function, and splits them into two functions. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l02990">2990</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00999">add_function()</a>, <a class="el" href="Partitioner_8C-source.html#l00683">append()</a>, <a class="el" href="Partitioner_8h-source.html#l00332">Partitioner::Function::basic_blocks</a>, <a class="el" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48ccb1cb50df0cb421e21b3ca064d1122e0">SgAsmBlock::BLK_ENTRY_POINT</a>, <a class="el" href="Partitioner_8h-source.html#l00333">Partitioner::Function::data_blocks</a>, <a class="el" href="Partitioner_8h-source.html#l01812">debug</a>, <a class="el" href="Partitioner_8h-source.html#l00335">Partitioner::Function::entry_va</a>, <a class="el" href="namespaceSageInterface.html#ff5394b21cf11cd338671af3a11a7f92">SageInterface::find()</a>, <a class="el" href="Partitioner_8C-source.html#l00952">find_bb_starting()</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c331ffe7c063699b34757276068c08d79">SgAsmFunction::FUNC_THUNK</a>, <a class="el" href="Partitioner_8h-source.html#l00238">Partitioner::BasicBlock::function</a>, <a class="el" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">SgAsmx86Instruction::get_kind()</a>, <a class="el" href="Partitioner_8h-source.html#l00304">Partitioner::Function::get_may_return()</a>, <a class="el" href="Partitioner_8h-source.html#l00336">Partitioner::Function::heads</a>, <a class="el" href="Partitioner_8h-source.html#l00235">Partitioner::BasicBlock::insns</a>, <a class="el" href="Partitioner_8C-source.html#l00041">isSgAsmx86Instruction()</a>, <a class="el" href="Partitioner_8h-source.html#l00331">Partitioner::Function::name</a>, <a class="el" href="Partitioner_8h-source.html#l00334">Partitioner::Function::pending</a>, <a class="el" href="Partitioner_8h-source.html#l00234">Partitioner::BasicBlock::reason</a>, <a class="el" href="Partitioner_8h-source.html#l00330">Partitioner::Function::reason</a>, <a class="el" href="Partitioner_8C-source.html#l00788">remove()</a>, <a class="el" href="Partitioner_8h-source.html#l00305">Partitioner::Function::set_may_return()</a>, <a class="el" href="Partitioner_8C-source.html#l00345">successors()</a>, <a class="el" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca557198fb4c6bacf21d45da2c1eb7380caccc">x86_farjmp</a>, and <a class="el" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571ad03bc3cf5ca0f4918d34b66a2ae0b24">x86_jmp</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02978">detach_thunks()</a>.
</div>
</div><p>
<a class="anchor" name="6280eae4362e64e6b5df4ed55fc17c91"></a><!-- doxytag: member="Partitioner::adjust_padding" ref="6280eae4362e64e6b5df4ed55fc17c91" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::adjust_padding           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adjusts ownership of padding data blocks. 
<p>
Each padding data block should be owned by the prior function in the address space. This is normally the case, but when functions are moved around, split, etc., the padding data blocks can get mixed up. This method puts them all back where they belong. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l03080">3080</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00683">append()</a>, <a class="el" href="rangemap_8h-source.html#l00775">RangeMap&lt; R, T &gt;::begin()</a>, <a class="el" href="Partitioner_8C-source.html#l00484">effective_function()</a>, <a class="el" href="rangemap_8h-source.html#l00787">RangeMap&lt; R, T &gt;::end()</a>, <a class="el" href="rangemap_8h-source.html#l00991">RangeMap&lt; R, T &gt;::erase()</a>, <a class="el" href="rangemap_8h-source.html#l00853">RangeMap&lt; R, T &gt;::find_prior()</a>, <a class="el" href="Partitioner_8C-source.html#l03383">function_extent()</a>, <a class="el" href="Partitioner_8C-source.html#l03460">padding_extent()</a>, and <a class="el" href="Partitioner_8h-source.html#l00330">Partitioner::Function::reason</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03245">post_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="c0755f9cbb352919fe0d275cb8f4bd9a"></a><!-- doxytag: member="Partitioner::merge_function_fragments" ref="c0755f9cbb352919fe0d275cb8f4bd9a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::merge_function_fragments           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Merge function fragments. 
<p>
The partitioner sometimes goes crazy breaking functions into smaller and smaller parts. This method attempts to merge all those parts after the partitioner's function detection has completed. A function fragment is any function whose only reason code is one of the GRAPH codes (function detected by graph analysis and the rule that every function has only one entry point). 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l03104">3104</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l01812">debug</a>, <a class="el" href="Partitioner_8C-source.html#l00952">find_bb_starting()</a>, <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c9c6f61a9e05594d28378f6130c1d59cf">SgAsmFunction::FUNC_GRAPH</a>, <a class="el" href="Partitioner_8h-source.html#l00238">Partitioner::BasicBlock::function</a>, <a class="el" href="Partitioner_8h-source.html#l01805">functions</a>, <a class="el" href="Partitioner_8C-source.html#l03222">merge_functions()</a>, <a class="el" href="Partitioner_8h-source.html#l00330">Partitioner::Function::reason</a>, <a class="el" href="SgAsmFunction_8C-source.html#l00026">SgAsmFunction::reason_str()</a>, and <a class="el" href="Partitioner_8C-source.html#l00345">successors()</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03245">post_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="ffa6af5890f1034b4b6cd59779492e23"></a><!-- doxytag: member="Partitioner::merge_functions" ref="ffa6af5890f1034b4b6cd59779492e23" args="(Function *parent, Function *other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Partitioner::merge_functions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1Function.html">Function</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPartitioner_1_1Function.html">Function</a> *&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Merge two functions. 
<p>
The <code>other</code> function is merged into <code>parent</code> and then <code>other</code> is deleted. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l03222">3222</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8h-source.html#l00335">Partitioner::Function::entry_va</a>, <a class="el" href="Partitioner_8h-source.html#l01805">functions</a>, <a class="el" href="Partitioner_8h-source.html#l00304">Partitioner::Function::get_may_return()</a>, <a class="el" href="Partitioner_8C-source.html#l00530">Partitioner::Function::move_basic_blocks_from()</a>, <a class="el" href="Partitioner_8C-source.html#l00544">Partitioner::Function::move_data_blocks_from()</a>, <a class="el" href="Partitioner_8h-source.html#l00331">Partitioner::Function::name</a>, <a class="el" href="Partitioner_8h-source.html#l00334">Partitioner::Function::pending</a>, <a class="el" href="Partitioner_8C-source.html#l00555">Partitioner::Function::promote_may_return()</a>, and <a class="el" href="Partitioner_8h-source.html#l00330">Partitioner::Function::reason</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03104">merge_function_fragments()</a>.
</div>
</div><p>
<a class="anchor" name="2a72cba4305db33a1086da011dab641b"></a><!-- doxytag: member="Partitioner::discover_jump_table" ref="2a72cba4305db33a1086da011dab641b" args="(BasicBlock *bb, bool do_create=true, ExtentMap *table_addresses=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> Partitioner::discover_jump_table           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPartitioner_1_1BasicBlock.html">BasicBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>do_create</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classExtentMap.html">ExtentMap</a> *&nbsp;</td>
          <td class="paramname"> <em>table_addresses</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks for a jump table. 
<p>
This method looks at the specified basic block and tries to discover if the last instruction is an indirect jump through memory. If it is, then the entries of the jump table are returned by value (i.e., the control flow successors of the given basic block), and the addresses of the table are added to the optional extent map. It is possible for the jump table to be discontiguous, but this is not usually the case. If <code>do_create</code> is true then data blocks are created for the jump table and added to the basic block. 
<p>
Definition at line <a class="el" href="Partitioner_8C-source.html#l00191">191</a> of file <a class="el" href="Partitioner_8C-source.html">Partitioner.C</a>.
<p>
References <a class="el" href="Partitioner_8C-source.html#l00683">append()</a>, <a class="el" href="classSgAsmBlock.html#94a08ed03be6bcd089f1106a0aa7e48c1b1c894179759ed0bb4d6a76d54d90e3">SgAsmBlock::BLK_JUMPTABLE</a>, <a class="el" href="Partitioner_8h-source.html#l01812">debug</a>, <a class="el" href="MemoryMap_8h-source.html#l00517">MemoryMap::exists()</a>, <a class="el" href="Partitioner_8C-source.html#l01998">find_db_starting()</a>, <a class="el" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">SgAsmStatement::get_address()</a>, <a class="el" href="classSgAsmx86Instruction.html#fb866bc83e59e6bafb4620bc39c7f87e">SgAsmx86Instruction::get_kind()</a>, <a class="el" href="classSgAsmInstruction.html#264e86d032b0a589d9dc520e79d09eb8">SgAsmInstruction::get_operandList()</a>, <a class="el" href="classSgAsmOperandList.html#bb5638c0533863030ad7acee019f1f17">SgAsmOperandList::get_operands()</a>, <a class="el" href="rangemap_8h-source.html#l01062">RangeMap&lt; R, T &gt;::insert()</a>, <a class="el" href="Partitioner_8h-source.html#l00235">Partitioner::BasicBlock::insns</a>, <a class="el" href="Cxx__Grammar_8h.html#de53c81adf2fb05def17e8e660ff4e18">isSgAsmMemoryReferenceExpression()</a>, <a class="el" href="Cxx__Grammar_8h.html#57c63c97527f4a655f21a06f0287b1fe">isSgAsmRegisterReferenceExpression()</a>, <a class="el" href="Partitioner_8C-source.html#l00041">isSgAsmx86Instruction()</a>, <a class="el" href="Partitioner_8C-source.html#l00495">Partitioner::BasicBlock::last_insn()</a>, <a class="el" href="Partitioner_8h-source.html#l01800">map</a>, <a class="el" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575a061dc1ffe578fdaea067d730efb00ac">MemoryMap::MM_PROT_EXEC</a>, <a class="el" href="MemoryMap_8C-source.html#l00728">MemoryMap::read()</a>, <a class="el" href="Partitioner_8h-source.html#l01801">ro_map</a>, <a class="el" href="Partitioner_8C-source.html#l00345">successors()</a>, <a class="el" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca557198fb4c6bacf21d45da2c1eb7380caccc">x86_farjmp</a>, and <a class="el" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571ad03bc3cf5ca0f4918d34b66a2ae0b24">x86_jmp</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l00270">update_analyses()</a>.
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="4862f9ab22b50ad90a880ff7d16031ab"></a><!-- doxytag: member="Partitioner::aggregate_mean" ref="4862f9ab22b50ad90a880ff7d16031ab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPartitioner_1_1RegionStats.html">RegionStats</a>* <a class="el" href="classPartitioner.html#4862f9ab22b50ad90a880ff7d16031ab">Partitioner::aggregate_mean</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Aggregate statistics returned by get_region_stats_mean(). 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01007">1007</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l00584">clear()</a>, <a class="el" href="Partitioner_8h-source.html#l00936">clear_aggregate_statistics()</a>, and <a class="el" href="Partitioner_8h-source.html#l00929">get_aggregate_mean()</a>.
</div>
</div><p>
<a class="anchor" name="a129e066f5e94444fb2a29b3d18bdf04"></a><!-- doxytag: member="Partitioner::aggregate_variance" ref="a129e066f5e94444fb2a29b3d18bdf04" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPartitioner_1_1RegionStats.html">RegionStats</a>* <a class="el" href="classPartitioner.html#a129e066f5e94444fb2a29b3d18bdf04">Partitioner::aggregate_variance</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Aggregate statistics returned by get_region_stats_variance(). 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01008">1008</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l00584">clear()</a>, <a class="el" href="Partitioner_8h-source.html#l00936">clear_aggregate_statistics()</a>, and <a class="el" href="Partitioner_8h-source.html#l00930">get_aggregate_variance()</a>.
</div>
</div><p>
<a class="anchor" name="068adcb53c802118a44b8d8fb0ee653c"></a><!-- doxytag: member="Partitioner::code_criteria" ref="068adcb53c802118a44b8d8fb0ee653c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPartitioner_1_1CodeCriteria.html">CodeCriteria</a>* <a class="el" href="classPartitioner.html#068adcb53c802118a44b8d8fb0ee653c">Partitioner::code_criteria</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Criteria used to determine if a region contains code or data. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01009">1009</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l00584">clear()</a>, <a class="el" href="Partitioner_8h-source.html#l01002">get_code_criteria()</a>, and <a class="el" href="Partitioner_8h-source.html#l01003">set_code_criteria()</a>.
</div>
</div><p>
<a class="anchor" name="320e02804f0d9ae5bc55e1ba26791a72"></a><!-- doxytag: member="Partitioner::disassembler" ref="320e02804f0d9ae5bc55e1ba26791a72" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDisassembler.html">Disassembler</a>* <a class="el" href="classPartitioner.html#320e02804f0d9ae5bc55e1ba26791a72">Partitioner::disassembler</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Optional disassembler to call when an instruction is needed. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01798">1798</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l00869">find_instruction()</a>, <a class="el" href="Partitioner_8C-source.html#l01019">mark_ipd_configuration()</a>, and <a class="el" href="Partitioner_8C-source.html#l03891">partition()</a>.
</div>
</div><p>
<a class="anchor" name="f9d5d92a9d9ca6a35ade7c5b3906ab97"></a><!-- doxytag: member="Partitioner::insns" ref="f9d5d92a9d9ca6a35ade7c5b3906ab97" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPartitioner.html#cff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a> <a class="el" href="classPartitioner.html#f9d5d92a9d9ca6a35ade7c5b3906ab97">Partitioner::insns</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classPartitioner_1_1Instruction.html">Instruction</a> cache, filled in by user or populated by disassembler. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01799">1799</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l00584">clear()</a>, <a class="el" href="Partitioner_8h-source.html#l00957">count_floating_point()</a>, <a class="el" href="Partitioner_8h-source.html#l00944">count_kinds()</a>, <a class="el" href="Partitioner_8h-source.html#l00950">count_privileged()</a>, <a class="el" href="Partitioner_8h-source.html#l00968">count_registers()</a>, <a class="el" href="Partitioner_8h-source.html#l00980">count_size_variance()</a>, <a class="el" href="Partitioner_8C-source.html#l00824">discard()</a>, <a class="el" href="Partitioner_8C-source.html#l00869">find_instruction()</a>, <a class="el" href="Partitioner_8h-source.html#l00958">ratio_floating_point()</a>, <a class="el" href="Partitioner_8h-source.html#l00951">ratio_privileged()</a>, and <a class="el" href="Partitioner_8h-source.html#l00969">ratio_registers()</a>.
</div>
</div><p>
<a class="anchor" name="a8aa1ec02714f0608e72147f2dee7ffc"></a><!-- doxytag: member="Partitioner::map" ref="a8aa1ec02714f0608e72147f2dee7ffc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMemoryMap.html">MemoryMap</a>* <a class="el" href="classPartitioner.html#a8aa1ec02714f0608e72147f2dee7ffc">Partitioner::map</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Memory map used for disassembly if disassembler is present. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01800">1800</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
Referenced by <a class="el" href="DisassemblerArm_8C-source.html#l00030">DisassemblerArm::disassembleOne()</a>, <a class="el" href="Partitioner_8C-source.html#l00191">discover_jump_table()</a>, <a class="el" href="Partitioner_8C-source.html#l01998">find_db_starting()</a>, <a class="el" href="Partitioner_8C-source.html#l00869">find_instruction()</a>, <a class="el" href="Partitioner_8h-source.html#l00498">get_map()</a>, <a class="el" href="Partitioner_8C-source.html#l01019">mark_ipd_configuration()</a>, <a class="el" href="Partitioner_8C-source.html#l01730">Partitioner::FindDataPadding::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l03891">partition()</a>, <a class="el" href="Partitioner_8C-source.html#l03245">post_cfg()</a>, and <a class="el" href="Partitioner_8C-source.html#l00174">set_map()</a>.
</div>
</div><p>
<a class="anchor" name="0b160d2ed1a5b32606e0deaf4c8cbb43"></a><!-- doxytag: member="Partitioner::ro_map" ref="0b160d2ed1a5b32606e0deaf4c8cbb43" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMemoryMap.html">MemoryMap</a> <a class="el" href="classPartitioner.html#0b160d2ed1a5b32606e0deaf4c8cbb43">Partitioner::ro_map</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The read-only parts of 'map', used for insn semantics mem reads. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01801">1801</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l00191">discover_jump_table()</a>, <a class="el" href="Partitioner_8C-source.html#l01730">Partitioner::FindDataPadding::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l03891">partition()</a>, <a class="el" href="Partitioner_8C-source.html#l03245">post_cfg()</a>, <a class="el" href="Partitioner_8C-source.html#l00174">set_map()</a>, and <a class="el" href="Partitioner_8C-source.html#l00270">update_analyses()</a>.
</div>
</div><p>
<a class="anchor" name="44a78932a6c3307dbdd9d9327bbb3eba"></a><!-- doxytag: member="Partitioner::bad_insns" ref="44a78932a6c3307dbdd9d9327bbb3eba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDisassembler.html#30c51578d70dfc05fb46047867ceadcd">Disassembler::BadMap</a> <a class="el" href="classPartitioner.html#44a78932a6c3307dbdd9d9327bbb3eba">Partitioner::bad_insns</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Captured disassembler exceptions. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01802">1802</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8h-source.html#l00568">clear_disassembler_errors()</a>, <a class="el" href="Partitioner_8C-source.html#l00869">find_instruction()</a>, and <a class="el" href="Partitioner_8h-source.html#l00560">get_disassembler_errors()</a>.
</div>
</div><p>
<a class="anchor" name="1f1a02cff90220dd026d8a344404fbea"></a><!-- doxytag: member="Partitioner::basic_blocks" ref="1f1a02cff90220dd026d8a344404fbea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPartitioner.html#a3a62d239fd07ca47ffc37dd21b74006">BasicBlocks</a> <a class="el" href="classPartitioner.html#1f1a02cff90220dd026d8a344404fbea">Partitioner::basic_blocks</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
All known basic blocks. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01804">1804</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02808">analyze_cfg()</a>, <a class="el" href="Partitioner_8C-source.html#l00584">clear()</a>, <a class="el" href="Partitioner_8C-source.html#l00845">discard()</a>, <a class="el" href="Partitioner_8C-source.html#l00904">find_bb_containing()</a>, and <a class="el" href="Partitioner_8C-source.html#l03245">post_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="85fdfbc700ab9b3eaf1a1fa77c53c216"></a><!-- doxytag: member="Partitioner::functions" ref="85fdfbc700ab9b3eaf1a1fa77c53c216" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPartitioner.html#d68aee879b03b498c5d988d7fdfd6ae8">Functions</a> <a class="el" href="classPartitioner.html#85fdfbc700ab9b3eaf1a1fa77c53c216">Partitioner::functions</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
All known functions, pending and complete. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01805">1805</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l00999">add_function()</a>, <a class="el" href="Partitioner_8C-source.html#l02808">analyze_cfg()</a>, <a class="el" href="Partitioner_8C-source.html#l03705">build_ast()</a>, <a class="el" href="Partitioner_8C-source.html#l00584">clear()</a>, <a class="el" href="Partitioner_8C-source.html#l02978">detach_thunks()</a>, <a class="el" href="Partitioner_8C-source.html#l04007">detectFunctions()</a>, <a class="el" href="Partitioner_8C-source.html#l02680">discover_blocks()</a>, <a class="el" href="Partitioner_8C-source.html#l00990">find_function()</a>, <a class="el" href="Partitioner_8C-source.html#l03383">function_extent()</a>, <a class="el" href="Partitioner_8C-source.html#l02300">is_thunk()</a>, <a class="el" href="Partitioner_8C-source.html#l03104">merge_function_fragments()</a>, <a class="el" href="Partitioner_8C-source.html#l03222">merge_functions()</a>, <a class="el" href="Partitioner_8C-source.html#l02510">name_import_entries()</a>, <a class="el" href="Partitioner_8C-source.html#l02431">name_plt_entries()</a>, <a class="el" href="Partitioner_8C-source.html#l02121">Partitioner::FindThunks::operator()()</a>, and <a class="el" href="Partitioner_8C-source.html#l03245">post_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="b8b08dc01aab15b7ae2dff4af899046f"></a><!-- doxytag: member="Partitioner::data_blocks" ref="b8b08dc01aab15b7ae2dff4af899046f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPartitioner.html#c9034b33e56a9e1d2e95dcd9c97cf431">DataBlocks</a> <a class="el" href="classPartitioner.html#b8b08dc01aab15b7ae2dff4af899046f">Partitioner::data_blocks</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Blocks that point to static data. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01807">1807</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l00584">clear()</a>, <a class="el" href="Partitioner_8C-source.html#l03474">datablock_extent()</a>, <a class="el" href="Partitioner_8C-source.html#l01998">find_db_starting()</a>, <a class="el" href="Partitioner_8C-source.html#l03525">is_contiguous()</a>, and <a class="el" href="Partitioner_8C-source.html#l03460">padding_extent()</a>.
</div>
</div><p>
<a class="anchor" name="61a820e23e3d57c012d0928aa9c4d1a2"></a><!-- doxytag: member="Partitioner::func_heuristics" ref="61a820e23e3d57c012d0928aa9c4d1a2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classPartitioner.html#61a820e23e3d57c012d0928aa9c4d1a2">Partitioner::func_heuristics</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bit mask of <a class="el" href="classSgAsmFunction.html#dbeeade0378b1c09170ad8d5d808852c">SgAsmFunction::FunctionReason</a> bits. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01809">1809</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l03705">build_ast()</a>, <a class="el" href="Partitioner_8C-source.html#l02680">discover_blocks()</a>, <a class="el" href="Partitioner_8C-source.html#l00904">find_bb_containing()</a>, <a class="el" href="Partitioner_8h-source.html#l00429">get_search()</a>, <a class="el" href="Partitioner_8C-source.html#l03245">post_cfg()</a>, <a class="el" href="Partitioner_8C-source.html#l02569">pre_cfg()</a>, and <a class="el" href="Partitioner_8h-source.html#l00423">set_search()</a>.
</div>
</div><p>
<a class="anchor" name="e8ccefb002c5a4bea6abc98c226d19d6"></a><!-- doxytag: member="Partitioner::user_detectors" ref="e8ccefb002c5a4bea6abc98c226d19d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classPartitioner.html#da9ff0ad1ed799e3d44df2c1958e9303">FunctionDetector</a>&gt; <a class="el" href="classPartitioner.html#e8ccefb002c5a4bea6abc98c226d19d6">Partitioner::user_detectors</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
List of user-defined function detection methods. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01810">1810</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8h-source.html#l00519">add_function_detector()</a>, and <a class="el" href="Partitioner_8C-source.html#l02569">pre_cfg()</a>.
</div>
</div><p>
<a class="anchor" name="7ea39de5e72216dbece1d9f3b9c79f8f"></a><!-- doxytag: member="Partitioner::debug" ref="7ea39de5e72216dbece1d9f3b9c79f8f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* <a class="el" href="classPartitioner.html#7ea39de5e72216dbece1d9f3b9c79f8f">Partitioner::debug</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stream where diagnistics are sent (or null). 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01812">1812</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02808">analyze_cfg()</a>, <a class="el" href="Partitioner_8C-source.html#l03768">build_ast()</a>, <a class="el" href="Partitioner_8C-source.html#l00976">canonic_block()</a>, <a class="el" href="Partitioner_8C-source.html#l02990">detach_thunk()</a>, <a class="el" href="Partitioner_8C-source.html#l02680">discover_blocks()</a>, <a class="el" href="Partitioner_8C-source.html#l02632">discover_first_block()</a>, <a class="el" href="Partitioner_8C-source.html#l00191">discover_jump_table()</a>, <a class="el" href="Partitioner_8C-source.html#l00952">find_bb_starting()</a>, <a class="el" href="Partitioner_8h-source.html#l00477">get_debug()</a>, <a class="el" href="Partitioner_8C-source.html#l01019">mark_ipd_configuration()</a>, <a class="el" href="Partitioner_8C-source.html#l03104">merge_function_fragments()</a>, <a class="el" href="Partitioner_8C-source.html#l02510">name_import_entries()</a>, <a class="el" href="Partitioner_8C-source.html#l02334">Partitioner::FindPostFunctionInsns::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l02213">Partitioner::FindThunkTables::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l02176">Partitioner::FindInterPadFunctions::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l02121">Partitioner::FindThunks::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l01863">Partitioner::FindInsnPadding::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l01820">Partitioner::FindData::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l01730">Partitioner::FindDataPadding::operator()()</a>, <a class="el" href="Partitioner_8C-source.html#l00400">pops_return_address()</a>, <a class="el" href="Partitioner_8C-source.html#l03245">post_cfg()</a>, <a class="el" href="Partitioner_8C-source.html#l02569">pre_cfg()</a>, <a class="el" href="Partitioner_8h-source.html#l00472">set_debug()</a>, and <a class="el" href="Partitioner_8C-source.html#l00270">update_analyses()</a>.
</div>
</div><p>
<a class="anchor" name="a89d8e06b1a855108422287a46b63b04"></a><!-- doxytag: member="Partitioner::allow_discont_blocks" ref="a89d8e06b1a855108422287a46b63b04" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classPartitioner.html#a89d8e06b1a855108422287a46b63b04">Partitioner::allow_discont_blocks</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allow basic blocks to be discontiguous in virtual memory. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01813">1813</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l00904">find_bb_containing()</a>, <a class="el" href="Partitioner_8h-source.html#l00467">get_allow_discontiguous_blocks()</a>, and <a class="el" href="Partitioner_8h-source.html#l00462">set_allow_discontiguous_blocks()</a>.
</div>
</div><p>
<a class="anchor" name="e4d5b142571b09b4cb8e77016991d3d0"></a><!-- doxytag: member="Partitioner::block_config" ref="e4d5b142571b09b4cb8e77016991d3d0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPartitioner.html#f15dc59805f5188b3a9a91f2a9906ca3">BlockConfigMap</a> <a class="el" href="classPartitioner.html#e4d5b142571b09b4cb8e77016991d3d0">Partitioner::block_config</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
IPD configuration info for basic blocks. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01814">1814</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l00584">clear()</a>, and <a class="el" href="Partitioner_8C-source.html#l01019">mark_ipd_configuration()</a>.
</div>
</div><p>
<a class="anchor" name="2663919047a75925b65a999ab6ea2f40"></a><!-- doxytag: member="Partitioner::progress_interval" ref="2663919047a75925b65a999ab6ea2f40" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t <a class="el" href="classPartitioner.html#2663919047a75925b65a999ab6ea2f40">Partitioner::progress_interval</a> = 10<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Minimum interval between progress reports. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01816">1816</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l00068">progress()</a>, and <a class="el" href="Partitioner_8C-source.html#l00060">set_progress_reporting()</a>.
</div>
</div><p>
<a class="anchor" name="868d4534cf2da160c4ed12cb304323c9"></a><!-- doxytag: member="Partitioner::progress_time" ref="868d4534cf2da160c4ed12cb304323c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t <a class="el" href="classPartitioner.html#868d4534cf2da160c4ed12cb304323c9">Partitioner::progress_time</a> = 0<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Time of last report, or zero if no report has been generated. 
<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01817">1817</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l00068">progress()</a>.
</div>
</div><p>
<a class="anchor" name="2b8e2de19780bf27ea1ab31b1b20f51a"></a><!-- doxytag: member="Partitioner::progress_file" ref="2b8e2de19780bf27ea1ab31b1b20f51a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE * <a class="el" href="classPartitioner.html#2b8e2de19780bf27ea1ab31b1b20f51a">Partitioner::progress_file</a> = stderr<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
File to which reports are made. 
<p>
Null disables reporting. 
<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01818">1818</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l00068">progress()</a>, and <a class="el" href="Partitioner_8C-source.html#l00060">set_progress_reporting()</a>.
</div>
</div><p>
<a class="anchor" name="7e4a76ae7ab4113b2ec7acf9093c3810"></a><!-- doxytag: member="Partitioner::NO_TARGET" ref="7e4a76ae7ab4113b2ec7acf9093c3810" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> <a class="el" href="classPartitioner.html#7e4a76ae7ab4113b2ec7acf9093c3810">Partitioner::NO_TARGET</a> = (<a class="el" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>)-1<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="Partitioner_8h-source.html#l01821">1821</a> of file <a class="el" href="Partitioner_8h-source.html">Partitioner.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l02808">analyze_cfg()</a>, <a class="el" href="Partitioner_8C-source.html#l00385">call_target()</a>, <a class="el" href="Partitioner_8h-source.html#l00173">Partitioner::BlockAnalysisCache::clear()</a>, <a class="el" href="Partitioner_8C-source.html#l02680">discover_blocks()</a>, <a class="el" href="Partitioner_8C-source.html#l01524">mark_call_insns()</a>, <a class="el" href="Partitioner_8C-source.html#l00345">successors()</a>, and <a class="el" href="Partitioner_8C-source.html#l00270">update_analyses()</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Partitioner_8h-source.html">Partitioner.h</a><li><a class="el" href="Partitioner_8C-source.html">Partitioner.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
