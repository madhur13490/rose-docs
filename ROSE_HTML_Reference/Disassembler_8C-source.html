<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: Disassembler.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>Disassembler.C</h1><a href="Disassembler_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#include "<a class="code" href="sage3basic_8h.html">sage3basic.h</a>"</span>
<a name="l00002"></a>00002 <span class="preprocessor">#include "<a class="code" href="Assembler_8h.html">Assembler.h</a>"</span>
<a name="l00003"></a>00003 <span class="preprocessor">#include "<a class="code" href="AssemblerX86_8h.html">AssemblerX86.h</a>"</span>
<a name="l00004"></a>00004 <span class="preprocessor">#include "<a class="code" href="AsmUnparser__compat_8h.html">AsmUnparser_compat.h</a>"</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include "<a class="code" href="Disassembler_8h.html">Disassembler.h</a>"</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include "<a class="code" href="DisassemblerPowerpc_8h.html">DisassemblerPowerpc.h</a>"</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include "<a class="code" href="DisassemblerArm_8h.html">DisassemblerArm.h</a>"</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include "<a class="code" href="DisassemblerX86_8h.html">DisassemblerX86.h</a>"</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include "<a class="code" href="BinaryLoader_8h.html">BinaryLoader.h</a>"</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include "<a class="code" href="Partitioner_8h.html">Partitioner.h</a>"</span>
<a name="l00011"></a>00011 
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
<a name="l00013"></a>00013 
<a name="l00014"></a>00014 <span class="comment">/* See header file for full documentation of all methods in this file. */</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 <span class="comment">/* Mutex for class-wide operations (such as adjusting Disassembler::disassemblers) */</span>
<a name="l00018"></a>00018 <a class="code" href="structRTS__mutex__t.html">RTS_mutex_t</a> <a class="code" href="classDisassembler.html#853982f2fc1d85a67ef45d49e2381631">Disassembler::class_mutex</a> = <a class="code" href="threadSupport_8h.html#030bdc54eda342fca5df6aa60412ac55">RTS_MUTEX_INITIALIZER</a>(<a class="code" href="threadSupport_8h.html#cdb719c4a573bf8cb5e26245cb1b2e667b779deca9fcf835fcac214d14630f44">RTS_LAYER_DISASSEMBLER_CLASS</a>);
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="comment">/* List of disassembler subclasses (protect with class_mutex) */</span>
<a name="l00021"></a>00021 std::vector&lt;Disassembler*&gt; <a class="code" href="classDisassembler.html#ca13f9d58790d2ffe3434e8f3a7f3a31">Disassembler::disassemblers</a>;
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="comment">/* Hook for construction */</span>
<a name="l00024"></a><a class="code" href="classDisassembler.html#9b6e3616fc3f8ad7465ccf1454a36cbe">00024</a> <span class="keywordtype">void</span> <a class="code" href="classDisassembler.html#9b6e3616fc3f8ad7465ccf1454a36cbe">Disassembler::ctor</a>() {
<a name="l00025"></a>00025 <span class="preprocessor">#if 0</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span>    <a class="code" href="classDisassembler.html#296d72c41fe8ab803feed162ea7dd6e3">p_debug</a> = stderr;
<a name="l00027"></a>00027 <span class="preprocessor">#endif</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span>}
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="keywordtype">void</span>
<a name="l00031"></a><a class="code" href="classDisassembler_1_1Exception.html#04048fcdb3829da07afe50510103dd90">00031</a> <a class="code" href="classDisassembler_1_1Exception.html#04048fcdb3829da07afe50510103dd90">Disassembler::Exception::print</a>(std::ostream &amp;o)<span class="keyword"> const</span>
<a name="l00032"></a>00032 <span class="keyword"></span>{
<a name="l00033"></a>00033     <span class="keywordflow">if</span> (<a class="code" href="classDisassembler_1_1Exception.html#3967fe0e21b730e8677fb547e4f2c01b">insn</a>) {
<a name="l00034"></a>00034         o &lt;&lt;<span class="stringliteral">"disassembly failed at "</span> &lt;&lt;<a class="code" href="namespaceStringUtility.html#b07dfdb6df484680f9a29ad4fcf79f80">StringUtility::addrToString</a>(<a class="code" href="classDisassembler_1_1Exception.html#740035a2fac94da1d179cac2a3897fa5">ip</a>)
<a name="l00035"></a>00035           &lt;&lt;<span class="stringliteral">" ["</span> &lt;&lt;<a class="code" href="AsmUnparser__compat_8h.html#30492a6c8df6a943ca55224e62c322c8">unparseInstruction</a>(<a class="code" href="classDisassembler_1_1Exception.html#3967fe0e21b730e8677fb547e4f2c01b">insn</a>) &lt;&lt;<span class="stringliteral">"]"</span>
<a name="l00036"></a>00036           &lt;&lt;<span class="stringliteral">": "</span> &lt;&lt;<a class="code" href="classDisassembler_1_1Exception.html#b0fe6869e8b74a4fc2579c44a6ea6a61">mesg</a>;
<a name="l00037"></a>00037     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classDisassembler_1_1Exception.html#740035a2fac94da1d179cac2a3897fa5">ip</a>&gt;0) {
<a name="l00038"></a>00038         o &lt;&lt;<span class="stringliteral">"disassembly failed at "</span> &lt;&lt;<a class="code" href="namespaceStringUtility.html#b07dfdb6df484680f9a29ad4fcf79f80">StringUtility::addrToString</a>(<a class="code" href="classDisassembler_1_1Exception.html#740035a2fac94da1d179cac2a3897fa5">ip</a>);
<a name="l00039"></a>00039         <span class="keywordflow">if</span> (!<a class="code" href="classDisassembler_1_1Exception.html#a55e12d4da36ff0e4e4ed18c0c915ff9">bytes</a>.empty()) {
<a name="l00040"></a>00040             <span class="keywordflow">for</span> (size_t i=0; i&lt;<a class="code" href="classDisassembler_1_1Exception.html#a55e12d4da36ff0e4e4ed18c0c915ff9">bytes</a>.size(); i++) {
<a name="l00041"></a>00041                 o &lt;&lt;(i&gt;0?<span class="stringliteral">", "</span>:<span class="stringliteral">"["</span>)
<a name="l00042"></a>00042                   &lt;&lt;std::hex &lt;&lt;std::setfill(<span class="charliteral">'0'</span>) &lt;&lt;std::setw(2)
<a name="l00043"></a>00043                   &lt;&lt;<span class="stringliteral">"0x"</span> &lt;&lt;<a class="code" href="classDisassembler_1_1Exception.html#a55e12d4da36ff0e4e4ed18c0c915ff9">bytes</a>[i]
<a name="l00044"></a>00044                   &lt;&lt;std::dec &lt;&lt;std::setfill(<span class="charliteral">' '</span>) &lt;&lt;std::setw(1);
<a name="l00045"></a>00045             }
<a name="l00046"></a>00046             o &lt;&lt;<span class="stringliteral">"] at bit "</span> &lt;&lt;<a class="code" href="classDisassembler_1_1Exception.html#92c29a8654ce694db79a904f5c005e1f">bit</a>;
<a name="l00047"></a>00047         }
<a name="l00048"></a>00048     } <span class="keywordflow">else</span> {
<a name="l00049"></a>00049         o &lt;&lt;<a class="code" href="classDisassembler_1_1Exception.html#b0fe6869e8b74a4fc2579c44a6ea6a61">mesg</a>;
<a name="l00050"></a>00050     }
<a name="l00051"></a>00051 }
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 std::ostream &amp;
<a name="l00054"></a><a class="code" href="Disassembler_8C.html#4c12195de35626bc37102c95a43b81f1">00054</a> <a class="code" href="Cxx__Grammar_8h.html#db4215b461ab8236ea979e9ab81c61ff">operator&lt;&lt;</a>(std::ostream &amp;o, <span class="keyword">const</span> <a class="code" href="classDisassembler_1_1Exception.html">Disassembler::Exception</a> &amp;e)
<a name="l00055"></a>00055 {
<a name="l00056"></a>00056     e.<a class="code" href="classDisassembler_1_1Exception.html#04048fcdb3829da07afe50510103dd90">print</a>(o);
<a name="l00057"></a>00057     <span class="keywordflow">return</span> o;
<a name="l00058"></a>00058 }
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 <span class="keywordtype">unsigned</span>
<a name="l00061"></a><a class="code" href="classDisassembler.html#603de94f15b69bea2ee1c526b57e0471">00061</a> <a class="code" href="classDisassembler.html#603de94f15b69bea2ee1c526b57e0471">Disassembler::parse_switches</a>(<span class="keyword">const</span> std::string &amp;s, <span class="keywordtype">unsigned</span> flags)
<a name="l00062"></a>00062 {
<a name="l00063"></a>00063     size_t at=0;
<a name="l00064"></a>00064     <span class="keywordflow">while</span> (at&lt;s.size()) {
<a name="l00065"></a>00065         <span class="keyword">enum</span> { SET_BIT, CLEAR_BIT, SET_VALUE, NOT_SPECIFIED } howset = NOT_SPECIFIED;
<a name="l00066"></a>00066 
<a name="l00067"></a>00067         <span class="keywordflow">if</span> (s[at]==<span class="charliteral">'-'</span>) {
<a name="l00068"></a>00068             howset = CLEAR_BIT;
<a name="l00069"></a>00069             at++;
<a name="l00070"></a>00070         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s[at]==<span class="charliteral">'+'</span>) {
<a name="l00071"></a>00071             howset = SET_BIT;
<a name="l00072"></a>00072             at++;
<a name="l00073"></a>00073         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s[at]==<span class="charliteral">'='</span>) {
<a name="l00074"></a>00074             howset = SET_VALUE;
<a name="l00075"></a>00075             at++;
<a name="l00076"></a>00076         }
<a name="l00077"></a>00077         <span class="keywordflow">if</span> (at&gt;=s.size())
<a name="l00078"></a>00078             <span class="keywordflow">throw</span> <a class="code" href="classDisassembler_1_1Exception.html">Exception</a>(<span class="stringliteral">"heuristic name must follow qualifier"</span>);
<a name="l00079"></a>00079         
<a name="l00080"></a>00080              
<a name="l00081"></a>00081         size_t comma = s.find(<span class="stringliteral">","</span>, at);
<a name="l00082"></a>00082         std::string word = std::string(s, at, comma-at);
<a name="l00083"></a>00083         <span class="keywordflow">if</span> (word.size()==0)
<a name="l00084"></a>00084             <span class="keywordflow">throw</span> <a class="code" href="classDisassembler_1_1Exception.html">Exception</a>(<span class="stringliteral">"heuristic name must follow comma"</span>);
<a name="l00085"></a>00085         
<a name="l00086"></a>00086         <span class="keywordtype">unsigned</span> bits = 0;
<a name="l00087"></a>00087         <span class="keywordflow">if</span> (word == <span class="stringliteral">"following"</span>) {
<a name="l00088"></a>00088             bits = <a class="code" href="classDisassembler.html#bf0472f94be5962208d1944c644337024ea6287ee40f180ae7ca70435a72db12">SEARCH_FOLLOWING</a>;
<a name="l00089"></a>00089         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word == <span class="stringliteral">"immediate"</span>) {
<a name="l00090"></a>00090             bits = <a class="code" href="classDisassembler.html#bf0472f94be5962208d1944c64433702ca5b02f67163cb932a95bd7bead7fd67">SEARCH_IMMEDIATE</a>;
<a name="l00091"></a>00091         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word == <span class="stringliteral">"words"</span>) {
<a name="l00092"></a>00092             bits = <a class="code" href="classDisassembler.html#bf0472f94be5962208d1944c644337023cabd4da3280e245233393925dfae696">SEARCH_WORDS</a>;
<a name="l00093"></a>00093         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word == <span class="stringliteral">"allbytes"</span>) {
<a name="l00094"></a>00094             bits = <a class="code" href="classDisassembler.html#bf0472f94be5962208d1944c6443370292e1794f3dc36276d713f3ce4ab8b32a">SEARCH_ALLBYTES</a>;
<a name="l00095"></a>00095         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word == <span class="stringliteral">"unused"</span>) {
<a name="l00096"></a>00096             bits = <a class="code" href="classDisassembler.html#bf0472f94be5962208d1944c6443370263b4361b25a275377f1b610200feaea0">SEARCH_UNUSED</a>;
<a name="l00097"></a>00097         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word == <span class="stringliteral">"nonexe"</span>) {
<a name="l00098"></a>00098             bits = <a class="code" href="classDisassembler.html#bf0472f94be5962208d1944c644337028d32f00e4d4baef3f0cf3b4e01534f3b">SEARCH_NONEXE</a>;
<a name="l00099"></a>00099         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word == <span class="stringliteral">"deadend"</span>) {
<a name="l00100"></a>00100             bits = <a class="code" href="classDisassembler.html#bf0472f94be5962208d1944c644337021b6f5035e3b9b0c34514d32c0b8ff8e3">SEARCH_DEADEND</a>;
<a name="l00101"></a>00101         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word == <span class="stringliteral">"unknown"</span>) {
<a name="l00102"></a>00102             bits = <a class="code" href="classDisassembler.html#bf0472f94be5962208d1944c644337024e36d238297ad9e93e506a1a34a65451">SEARCH_UNKNOWN</a>;
<a name="l00103"></a>00103         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word == <span class="stringliteral">"funcsyms"</span>) {
<a name="l00104"></a>00104             bits = <a class="code" href="classDisassembler.html#bf0472f94be5962208d1944c644337026c0bec3b2d4180faa1ff82478790f010">SEARCH_FUNCSYMS</a>;
<a name="l00105"></a>00105         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word == <span class="stringliteral">"default"</span>) {
<a name="l00106"></a>00106             bits = <a class="code" href="classDisassembler.html#bf0472f94be5962208d1944c6443370281ac581af8b36425fb6a4fb07b1625bb">SEARCH_DEFAULT</a>;
<a name="l00107"></a>00107             <span class="keywordflow">if</span> (howset==NOT_SPECIFIED) howset = SET_VALUE;
<a name="l00108"></a>00108         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isdigit(word[0])) {
<a name="l00109"></a>00109             bits = strtol(word.c_str(), NULL, 0);
<a name="l00110"></a>00110         } <span class="keywordflow">else</span> {
<a name="l00111"></a>00111             <span class="keywordflow">throw</span> <a class="code" href="classDisassembler_1_1Exception.html">Exception</a>(<span class="stringliteral">"unknown disassembler heuristic: "</span> + word);
<a name="l00112"></a>00112         }
<a name="l00113"></a>00113 
<a name="l00114"></a>00114         <span class="keywordflow">switch</span> (howset) {
<a name="l00115"></a>00115             <span class="keywordflow">case</span> SET_VALUE:
<a name="l00116"></a>00116                 flags = 0;
<a name="l00117"></a>00117             <span class="keywordflow">case</span> NOT_SPECIFIED:
<a name="l00118"></a>00118             <span class="keywordflow">case</span> SET_BIT:
<a name="l00119"></a>00119                 flags |= bits;
<a name="l00120"></a>00120                 <span class="keywordflow">break</span>;
<a name="l00121"></a>00121             <span class="keywordflow">case</span> CLEAR_BIT:
<a name="l00122"></a>00122                 flags &amp;= ~bits;
<a name="l00123"></a>00123                 <span class="keywordflow">break</span>;
<a name="l00124"></a>00124         }
<a name="l00125"></a>00125 
<a name="l00126"></a>00126         at = comma==std::string::npos ? s.size() : comma+1;
<a name="l00127"></a>00127     }
<a name="l00128"></a>00128     <span class="keywordflow">return</span> flags;
<a name="l00129"></a>00129 }
<a name="l00130"></a>00130 
<a name="l00131"></a>00131 <span class="comment">/* Initialize the class. Thread safe. */</span>
<a name="l00132"></a>00132 <span class="keywordtype">void</span>
<a name="l00133"></a><a class="code" href="classDisassembler.html#18b9441ef0521c6b6b6b600fa23af16e">00133</a> <a class="code" href="classDisassembler.html#18b9441ef0521c6b6b6b600fa23af16e">Disassembler::initclass</a>()
<a name="l00134"></a>00134 {
<a name="l00135"></a>00135     <a class="code" href="threadSupport_8h.html#d9802e9ddf3622fe5fc89638403b3aa1">RTS_INIT_RECURSIVE</a>(<a class="code" href="classDisassembler.html#853982f2fc1d85a67ef45d49e2381631">class_mutex</a>) {
<a name="l00136"></a>00136         <a class="code" href="classDisassembler.html#d4a266d168cb2d1d386719a25d47c5c2">register_subclass</a>(<span class="keyword">new</span> <a class="code" href="classDisassemblerArm.html">DisassemblerArm</a>());
<a name="l00137"></a>00137         <a class="code" href="classDisassembler.html#d4a266d168cb2d1d386719a25d47c5c2">register_subclass</a>(<span class="keyword">new</span> <a class="code" href="classDisassemblerPowerpc.html">DisassemblerPowerpc</a>());
<a name="l00138"></a>00138         <a class="code" href="classDisassembler.html#d4a266d168cb2d1d386719a25d47c5c2">register_subclass</a>(<span class="keyword">new</span> <a class="code" href="classDisassemblerX86.html">DisassemblerX86</a>(2)); <span class="comment">/*16-bit*/</span>
<a name="l00139"></a>00139         <a class="code" href="classDisassembler.html#d4a266d168cb2d1d386719a25d47c5c2">register_subclass</a>(<span class="keyword">new</span> <a class="code" href="classDisassemblerX86.html">DisassemblerX86</a>(4)); <span class="comment">/*32-bit*/</span>
<a name="l00140"></a>00140         <a class="code" href="classDisassembler.html#d4a266d168cb2d1d386719a25d47c5c2">register_subclass</a>(<span class="keyword">new</span> <a class="code" href="classDisassemblerX86.html">DisassemblerX86</a>(8)); <span class="comment">/*64-bit*/</span>
<a name="l00141"></a>00141     } <a class="code" href="threadSupport_8h.html#54294de9405d4d40dd7fd9890dd09096">RTS_INIT_END</a>;
<a name="l00142"></a>00142 }
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 <span class="comment">/* Class method to register a new disassembler subclass. Thread safe. */</span>
<a name="l00145"></a>00145 <span class="keywordtype">void</span>
<a name="l00146"></a><a class="code" href="classDisassembler.html#d4a266d168cb2d1d386719a25d47c5c2">00146</a> <a class="code" href="classDisassembler.html#d4a266d168cb2d1d386719a25d47c5c2">Disassembler::register_subclass</a>(<a class="code" href="classDisassembler.html">Disassembler</a> *factory)
<a name="l00147"></a>00147 {
<a name="l00148"></a>00148     <a class="code" href="classDisassembler.html#18b9441ef0521c6b6b6b600fa23af16e">initclass</a>();
<a name="l00149"></a>00149     <a class="code" href="threadSupport_8h.html#e38269e003df2431ff43e7fab618d8cd">RTS_MUTEX</a>(<a class="code" href="classDisassembler.html#853982f2fc1d85a67ef45d49e2381631">class_mutex</a>) {
<a name="l00150"></a>00150         ROSE_ASSERT(factory!=NULL);
<a name="l00151"></a>00151         <a class="code" href="classDisassembler.html#ca13f9d58790d2ffe3434e8f3a7f3a31">disassemblers</a>.push_back(factory);
<a name="l00152"></a>00152     } <a class="code" href="threadSupport_8h.html#aaa39a48f69302ebfea6780090e1e198">RTS_MUTEX_END</a>;
<a name="l00153"></a>00153 }
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 <span class="comment">/* Class method. Thread safe by virtue of lookup(SgAsmGenericHeader*). */</span>
<a name="l00156"></a>00156 <a class="code" href="classDisassembler.html">Disassembler</a> *
<a name="l00157"></a><a class="code" href="classDisassembler.html#3fcecd09b4b103a5e30587387455f49d">00157</a> <a class="code" href="classDisassembler.html#80b0e8a12a159d85c9ad2813ed1559c4">Disassembler::lookup</a>(<a class="code" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *interp)
<a name="l00158"></a>00158 {
<a name="l00159"></a>00159     <a class="code" href="classDisassembler.html">Disassembler</a> *retval=NULL;
<a name="l00160"></a>00160     <span class="keyword">const</span> <a class="code" href="Cxx__Grammar_8h.html#2b92a9464e206badb3c042fe0456d37e">SgAsmGenericHeaderPtrList</a> &amp;headers = interp-&gt;<a class="code" href="classSgAsmInterpretation.html#5d116938aaa9da9f3e27ca598965c77b">get_headers</a>()-&gt;<a class="code" href="classSgAsmGenericHeaderList.html#c3d9878c64af6c90e2d52988f8578b36">get_headers</a>();
<a name="l00161"></a>00161     <span class="keywordflow">for</span> (size_t i=0; i&lt;headers.size(); i++) {
<a name="l00162"></a>00162         <a class="code" href="classDisassembler.html">Disassembler</a> *candidate = <a class="code" href="classDisassembler.html#80b0e8a12a159d85c9ad2813ed1559c4">lookup</a>(headers[i]);
<a name="l00163"></a>00163         <span class="keywordflow">if</span> (retval &amp;&amp; retval!=candidate)
<a name="l00164"></a>00164             <span class="keywordflow">throw</span> <a class="code" href="classDisassembler_1_1Exception.html">Exception</a>(<span class="stringliteral">"interpretation has multiple disassemblers"</span>);
<a name="l00165"></a>00165         retval = candidate;
<a name="l00166"></a>00166     }
<a name="l00167"></a>00167     <span class="keywordflow">return</span> retval;
<a name="l00168"></a>00168 }
<a name="l00169"></a>00169 
<a name="l00170"></a>00170 <span class="comment">/* Class method. Thread safe. */</span>
<a name="l00171"></a>00171 <a class="code" href="classDisassembler.html">Disassembler</a> *
<a name="l00172"></a><a class="code" href="classDisassembler.html#80b0e8a12a159d85c9ad2813ed1559c4">00172</a> <a class="code" href="classDisassembler.html#80b0e8a12a159d85c9ad2813ed1559c4">Disassembler::lookup</a>(<a class="code" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *header)
<a name="l00173"></a>00173 {
<a name="l00174"></a>00174     <a class="code" href="classDisassembler.html#18b9441ef0521c6b6b6b600fa23af16e">initclass</a>();
<a name="l00175"></a>00175     <a class="code" href="classDisassembler.html">Disassembler</a> *retval = NULL;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177     <a class="code" href="threadSupport_8h.html#e38269e003df2431ff43e7fab618d8cd">RTS_MUTEX</a>(<a class="code" href="classDisassembler.html#853982f2fc1d85a67ef45d49e2381631">class_mutex</a>) {
<a name="l00178"></a>00178         <span class="keywordflow">for</span> (size_t i=<a class="code" href="classDisassembler.html#ca13f9d58790d2ffe3434e8f3a7f3a31">disassemblers</a>.size(); i&gt;0 &amp;&amp; !retval; --i) {
<a name="l00179"></a>00179             <span class="keywordflow">if</span> (<a class="code" href="classDisassembler.html#ca13f9d58790d2ffe3434e8f3a7f3a31">disassemblers</a>[i-1]-&gt;<a class="code" href="classDisassembler.html#c9bb3b72fc74a64f9eadf10a7e91de63">can_disassemble</a>(header))
<a name="l00180"></a>00180                 retval = <a class="code" href="classDisassembler.html#ca13f9d58790d2ffe3434e8f3a7f3a31">disassemblers</a>[i-1];
<a name="l00181"></a>00181         }
<a name="l00182"></a>00182     } <a class="code" href="threadSupport_8h.html#aaa39a48f69302ebfea6780090e1e198">RTS_MUTEX_END</a>;
<a name="l00183"></a>00183     
<a name="l00184"></a>00184     <span class="keywordflow">if</span> (retval)
<a name="l00185"></a>00185         <span class="keywordflow">return</span> retval;
<a name="l00186"></a>00186     <span class="keywordflow">throw</span> <a class="code" href="classDisassembler_1_1Exception.html">Exception</a>(<span class="stringliteral">"no disassembler for architecture"</span>);
<a name="l00187"></a>00187 }
<a name="l00188"></a>00188 
<a name="l00189"></a>00189 <span class="comment">/* High-level function for disassembling a whole interpretation. */</span>
<a name="l00190"></a>00190 <span class="keywordtype">void</span>
<a name="l00191"></a><a class="code" href="classDisassembler.html#64aafb327cb2d3eaf1acd0ea0dfe7e97">00191</a> <a class="code" href="classDisassembler.html#64aafb327cb2d3eaf1acd0ea0dfe7e97">Disassembler::disassemble</a>(<a class="code" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *interp, <a class="code" href="namespaceVirtualBinCFG.html#21495b08e1c020b22a49fbf0c569c3ec">AddressSet</a> *successors, BadMap *bad)
<a name="l00192"></a>00192 {
<a name="l00193"></a>00193     <a class="code" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">InstructionMap</a> insns = <a class="code" href="classDisassembler.html#d5dcbb23495e19e34dd84d4b2035b2bb">disassembleInterp</a>(interp, successors, bad);
<a name="l00194"></a>00194     <a class="code" href="classPartitioner.html">Partitioner</a> *p = <a class="code" href="classDisassembler.html#0127a8ef067412e01f34ad506bf74d58">p_partitioner</a> ? <a class="code" href="classDisassembler.html#0127a8ef067412e01f34ad506bf74d58">p_partitioner</a> : <span class="keyword">new</span> <a class="code" href="classPartitioner.html">Partitioner</a>;
<a name="l00195"></a>00195     <span class="keywordflow">if</span> (<a class="code" href="classDisassembler.html#296d72c41fe8ab803feed162ea7dd6e3">p_debug</a> &amp;&amp; !<a class="code" href="classDisassembler.html#0127a8ef067412e01f34ad506bf74d58">p_partitioner</a>)
<a name="l00196"></a>00196         p-&gt;<a class="code" href="classPartitioner.html#3779f2493e75745eb5a0d8abf8317316">set_debug</a>(<a class="code" href="classDisassembler.html#42a48d3ff1218c4e7a01291300246aa0">get_debug</a>());
<a name="l00197"></a>00197     <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a> *top = p-&gt;<a class="code" href="classPartitioner.html#d8d4292001cbf0490676f8bc148c1a24">partition</a>(interp, insns, interp-&gt;<a class="code" href="classSgAsmInterpretation.html#afcc3fea0b7b32d1f46ec2789920caab">get_map</a>());
<a name="l00198"></a>00198     interp-&gt;<a class="code" href="classSgAsmInterpretation.html#5b63595e714c2fc3c9c6c3c563b915cb">set_global_block</a>(top);
<a name="l00199"></a>00199     top-&gt;<a class="code" href="classSgNode.html#83017efa378d75b031330739c963749d">set_parent</a>(interp);
<a name="l00200"></a>00200     <span class="keywordflow">if</span> (!<a class="code" href="classDisassembler.html#0127a8ef067412e01f34ad506bf74d58">p_partitioner</a>)
<a name="l00201"></a>00201         <span class="keyword">delete</span> p;
<a name="l00202"></a>00202 }
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 <span class="comment">/* Class method for backward compatability with the old Disassembler name space.</span>
<a name="l00205"></a>00205 <span class="comment"> * Not thread safe because Partitioner::Partitioner is not. */</span>
<a name="l00206"></a>00206 <span class="keywordtype">void</span>
<a name="l00207"></a><a class="code" href="classDisassembler.html#fd020ba343b083b9eccd75562a43d2be">00207</a> <a class="code" href="classDisassembler.html#fd020ba343b083b9eccd75562a43d2be">Disassembler::disassembleInterpretation</a>(<a class="code" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *interp)
<a name="l00208"></a>00208 {
<a name="l00209"></a>00209     <span class="comment">/* Create a new disassembler so we can modify its behavior locally. */</span>
<a name="l00210"></a>00210     <a class="code" href="classDisassembler.html">Disassembler</a> *disassembler = <a class="code" href="classDisassembler.html#80b0e8a12a159d85c9ad2813ed1559c4">Disassembler::lookup</a>(interp);
<a name="l00211"></a>00211     assert(disassembler);
<a name="l00212"></a>00212     disassembler = disassembler-&gt;<a class="code" href="classDisassembler.html#df49539cafea52de93c906ec17ad9945">clone</a>();
<a name="l00213"></a>00213     assert(disassembler);
<a name="l00214"></a>00214 
<a name="l00215"></a>00215     <span class="comment">/* Search methods specified with "-rose:disassembler_search" are stored in the SgFile object. Use them rather than the</span>
<a name="l00216"></a>00216 <span class="comment">     * defaults built into the Disassembler class. */</span>
<a name="l00217"></a>00217     <a class="code" href="classSgNode.html">SgNode</a> *file = SageInterface::getEnclosingNode&lt;SgFile&gt;(interp);
<a name="l00218"></a>00218     ROSE_ASSERT(file);
<a name="l00219"></a>00219     disassembler-&gt;<a class="code" href="classDisassembler.html#8b72ea8a729a975303364b6015fdf53c">set_search</a>(<a class="code" href="Cxx__Grammar_8h.html#59e774cc7e144f704295b61e60db7319">isSgFile</a>(file)-&gt;get_disassemblerSearchHeuristics());
<a name="l00220"></a>00220 
<a name="l00221"></a>00221     <span class="comment">/* Partitioning methods are specified with "-rose:partitioner_search" and are stored in SgFile also. Use them rather than</span>
<a name="l00222"></a>00222 <span class="comment">     * the default partitioner. */</span>
<a name="l00223"></a>00223     <a class="code" href="classPartitioner.html">Partitioner</a> *partitioner = <span class="keyword">new</span> <a class="code" href="classPartitioner.html">Partitioner</a>;
<a name="l00224"></a>00224     partitioner-&gt;<a class="code" href="classPartitioner.html#e52ab7e0fa20592ae95f858404b3234b">set_search</a>(<a class="code" href="Cxx__Grammar_8h.html#59e774cc7e144f704295b61e60db7319">isSgFile</a>(file)-&gt;get_partitionerSearchHeuristics());
<a name="l00225"></a>00225 
<a name="l00226"></a>00226     <span class="comment">/* Partitioner configuration file specified with "-rose:partitioner_config" is stored in SgFile. Use it rather than</span>
<a name="l00227"></a>00227 <span class="comment">     * the default configuration file. */</span>
<a name="l00228"></a>00228     partitioner-&gt;<a class="code" href="classPartitioner.html#7adb0e1cb0359b14d928ad1d7ffd0a03">load_config</a>(<a class="code" href="Cxx__Grammar_8h.html#59e774cc7e144f704295b61e60db7319">isSgFile</a>(file)-&gt;get_partitionerConfigurationFileName());
<a name="l00229"></a>00229 
<a name="l00230"></a>00230     disassembler-&gt;<a class="code" href="classDisassembler.html#612b5bdb1d86230768ed54c914f44021">set_partitioner</a>(partitioner);
<a name="l00231"></a>00231     disassembler-&gt;<a class="code" href="classDisassembler.html#64aafb327cb2d3eaf1acd0ea0dfe7e97">disassemble</a>(interp, NULL, NULL);
<a name="l00232"></a>00232 
<a name="l00233"></a>00233     <span class="keyword">delete</span> disassembler;
<a name="l00234"></a>00234     <span class="keyword">delete</span> partitioner;
<a name="l00235"></a>00235 }
<a name="l00236"></a>00236 
<a name="l00237"></a>00237 <span class="comment">/* Accessor */</span>
<a name="l00238"></a>00238 <span class="keywordtype">void</span>
<a name="l00239"></a><a class="code" href="classDisassembler.html#db4c06468c622b957cd96bc50f884c0c">00239</a> <a class="code" href="classDisassembler.html#db4c06468c622b957cd96bc50f884c0c">Disassembler::set_wordsize</a>(size_t n)
<a name="l00240"></a>00240 {
<a name="l00241"></a>00241     ROSE_ASSERT(n&gt;0);
<a name="l00242"></a>00242     ROSE_ASSERT(n&lt;=<span class="keyword">sizeof</span>(<a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a>));
<a name="l00243"></a>00243     <a class="code" href="classDisassembler.html#9cb3e37aa8b470f6cc21fdd5eb5bf474">p_wordsize</a> = n;
<a name="l00244"></a>00244 }
<a name="l00245"></a>00245 
<a name="l00246"></a>00246 <span class="comment">/* Accessor */</span>
<a name="l00247"></a>00247 <span class="keywordtype">void</span>
<a name="l00248"></a><a class="code" href="classDisassembler.html#0a1ba689bce0c0a08b275cd7d06af0c7">00248</a> <a class="code" href="classDisassembler.html#0a1ba689bce0c0a08b275cd7d06af0c7">Disassembler::set_alignment</a>(size_t n)
<a name="l00249"></a>00249 {
<a name="l00250"></a>00250 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00251"></a>00251 <span class="preprocessor"></span>    <span class="keywordtype">int</span> nbits=0;
<a name="l00252"></a>00252     <span class="keywordflow">for</span> (size_t i=0; i&lt;8*<span class="keyword">sizeof</span>(n); i++)
<a name="l00253"></a>00253         nbits += (((size_t)1&lt;&lt;i) &amp; n) ? 1 : 0;
<a name="l00254"></a>00254     ROSE_ASSERT(1==nbits);
<a name="l00255"></a>00255 <span class="preprocessor">#endif</span>
<a name="l00256"></a>00256 <span class="preprocessor"></span>    <a class="code" href="classDisassembler.html#3be9f2c9e59b831585a7f6547c2f27a5">p_alignment</a> = n;
<a name="l00257"></a>00257 }
<a name="l00258"></a>00258 
<a name="l00259"></a>00259 <span class="comment">/* Progress report class variables, all protected by class_mutex */</span>
<a name="l00260"></a>00260 time_t <a class="code" href="classDisassembler.html#c40983d6932e8334746d9cf6ff975fd3">Disassembler::progress_interval</a> = 10;
<a name="l00261"></a>00261 time_t <a class="code" href="classDisassembler.html#c2a7d0246adadf512fd910104cfce780">Disassembler::progress_time</a> = 0;
<a name="l00262"></a>00262 FILE *<a class="code" href="classDisassembler.html#6ef901f2c1e42fc1d3ecfd95d35cc0b6">Disassembler::progress_file</a> = stderr;
<a name="l00263"></a>00263 
<a name="l00264"></a>00264 <span class="comment">/* Set progress reporting values. */</span>
<a name="l00265"></a>00265 <span class="keywordtype">void</span>
<a name="l00266"></a><a class="code" href="classDisassembler.html#8722f4993d3e64a6ef9209bf5b3b3248">00266</a> <a class="code" href="classDisassembler.html#8722f4993d3e64a6ef9209bf5b3b3248">Disassembler::set_progress_reporting</a>(FILE *<a class="code" href="IntelPinSupport_8C.html#0c56ec5eb0ac1eec6f0c42a439e9d24d">output</a>, <span class="keywordtype">unsigned</span> min_interval)
<a name="l00267"></a>00267 {
<a name="l00268"></a>00268     <a class="code" href="threadSupport_8h.html#e38269e003df2431ff43e7fab618d8cd">RTS_MUTEX</a>(<a class="code" href="classDisassembler.html#853982f2fc1d85a67ef45d49e2381631">class_mutex</a>) {
<a name="l00269"></a>00269         <a class="code" href="classDisassembler.html#6ef901f2c1e42fc1d3ecfd95d35cc0b6">progress_file</a> = output;
<a name="l00270"></a>00270         <a class="code" href="classDisassembler.html#c40983d6932e8334746d9cf6ff975fd3">progress_interval</a> = min_interval;
<a name="l00271"></a>00271     } <a class="code" href="threadSupport_8h.html#aaa39a48f69302ebfea6780090e1e198">RTS_MUTEX_END</a>;
<a name="l00272"></a>00272 }
<a name="l00273"></a>00273 
<a name="l00274"></a>00274 <span class="comment">/* Produce a progress report if enabled. */</span>
<a name="l00275"></a>00275 <span class="keywordtype">void</span>
<a name="l00276"></a><a class="code" href="classDisassembler.html#e96beff2f2749f2987be67ac38db39b5">00276</a> <a class="code" href="classDisassembler.html#e96beff2f2749f2987be67ac38db39b5">Disassembler::progress</a>(FILE *debug, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...)<span class="keyword"> const</span>
<a name="l00277"></a>00277 <span class="keyword"></span>{
<a name="l00278"></a>00278     va_list ap;
<a name="l00279"></a>00279     va_start(ap, fmt);
<a name="l00280"></a>00280 
<a name="l00281"></a>00281     time_t now = time(NULL);
<a name="l00282"></a>00282 
<a name="l00283"></a>00283     <a class="code" href="threadSupport_8h.html#e38269e003df2431ff43e7fab618d8cd">RTS_MUTEX</a>(<a class="code" href="classDisassembler.html#853982f2fc1d85a67ef45d49e2381631">class_mutex</a>) {
<a name="l00284"></a>00284         <span class="keywordflow">if</span> (0==<a class="code" href="classDisassembler.html#c2a7d0246adadf512fd910104cfce780">progress_time</a>)
<a name="l00285"></a>00285             <a class="code" href="classDisassembler.html#c2a7d0246adadf512fd910104cfce780">progress_time</a> = now;
<a name="l00286"></a>00286     
<a name="l00287"></a>00287         <span class="keywordflow">if</span> (<a class="code" href="classDisassembler.html#6ef901f2c1e42fc1d3ecfd95d35cc0b6">progress_file</a>!=NULL &amp;&amp; now-<a class="code" href="classDisassembler.html#c2a7d0246adadf512fd910104cfce780">progress_time</a> &gt;= <a class="code" href="classDisassembler.html#c40983d6932e8334746d9cf6ff975fd3">progress_interval</a>) {
<a name="l00288"></a>00288             <a class="code" href="classDisassembler.html#c2a7d0246adadf512fd910104cfce780">progress_time</a> = now;
<a name="l00289"></a>00289             vfprintf(<a class="code" href="classDisassembler.html#6ef901f2c1e42fc1d3ecfd95d35cc0b6">progress_file</a>, fmt, ap);
<a name="l00290"></a>00290         }
<a name="l00291"></a>00291 
<a name="l00292"></a>00292         <span class="keywordflow">if</span> (debug!=NULL)
<a name="l00293"></a>00293             vfprintf(debug, fmt, ap);
<a name="l00294"></a>00294     } <a class="code" href="threadSupport_8h.html#aaa39a48f69302ebfea6780090e1e198">RTS_MUTEX_END</a>;
<a name="l00295"></a>00295 
<a name="l00296"></a>00296     va_end(ap);
<a name="l00297"></a>00297 }
<a name="l00298"></a>00298 
<a name="l00299"></a>00299 <span class="comment">/* Update progress, keeping track of the number of instructions disassembled. */</span>
<a name="l00300"></a>00300 <span class="keywordtype">void</span>
<a name="l00301"></a><a class="code" href="classDisassembler.html#7fe7dbd57d1cd4b2e82107c5e38e4805">00301</a> <a class="code" href="classDisassembler.html#7fe7dbd57d1cd4b2e82107c5e38e4805">Disassembler::update_progress</a>(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn)
<a name="l00302"></a>00302 {
<a name="l00303"></a>00303     <span class="keywordflow">if</span> (insn)
<a name="l00304"></a>00304         <a class="code" href="classDisassembler.html#e96e98403346bbbdee1551f9b80445cb">p_ndisassembled</a>++;
<a name="l00305"></a>00305 
<a name="l00306"></a>00306     <a class="code" href="classDisassembler.html#e96beff2f2749f2987be67ac38db39b5">progress</a>(<a class="code" href="classDisassembler.html#296d72c41fe8ab803feed162ea7dd6e3">p_debug</a>, <span class="stringliteral">"Disassembler[va 0x%08"</span>PRIx64<span class="stringliteral">"]: disassembled %zu instructions\n"</span>,
<a name="l00307"></a>00307              insn?insn-&gt;<a class="code" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>():(uint64_t)0, <a class="code" href="classDisassembler.html#e96e98403346bbbdee1551f9b80445cb">p_ndisassembled</a>);
<a name="l00308"></a>00308 }
<a name="l00309"></a>00309 
<a name="l00310"></a>00310 <span class="comment">/* Disassemble one instruction. */</span>
<a name="l00311"></a>00311 <a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *
<a name="l00312"></a><a class="code" href="classDisassembler.html#bd9d54f921efe469daa44611bc83cd95">00312</a> <a class="code" href="classDisassembler.html#d765ce924af663d75b9ce5915d658d7c">Disassembler::disassembleOne</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buf, <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> buf_va, size_t buf_size, <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> start_va,
<a name="l00313"></a>00313                              <a class="code" href="namespaceVirtualBinCFG.html#21495b08e1c020b22a49fbf0c569c3ec">AddressSet</a> *successors)
<a name="l00314"></a>00314 {
<a name="l00315"></a>00315     <a class="code" href="classMemoryMap.html#3fcd4dad3786a2b27069c7891eb7b378">MemoryMap::BufferPtr</a> buffer = <a class="code" href="classMemoryMap_1_1ExternBuffer.html#84cf5d396b6cca4a0f4289b6f80e7982">MemoryMap::ExternBuffer::create</a>(buf, buf_size);
<a name="l00316"></a>00316     <a class="code" href="classMemoryMap_1_1Segment.html">MemoryMap::Segment</a> segment(buffer, 0, <a class="code" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd57589290f94ccb75d2e8b659c4ef50bb700">MemoryMap::MM_PROT_RX</a>, <span class="stringliteral">"disassembleOne temp"</span>);
<a name="l00317"></a>00317     <a class="code" href="classMemoryMap.html">MemoryMap</a> map;
<a name="l00318"></a>00318     map.<a class="code" href="classMemoryMap.html#d8b51b8c73d8bb8d5922cbf1360800ef">insert</a>(<a class="code" href="Cxx__Grammar_8h.html#d8e49820aaa106bb8a2dc17d9ad38d87">Extent</a>(buf_va, buf_size), segment);
<a name="l00319"></a>00319     <span class="keywordflow">return</span> <a class="code" href="classDisassembler.html#d765ce924af663d75b9ce5915d658d7c">disassembleOne</a>(&amp;map, start_va, successors);
<a name="l00320"></a>00320 }
<a name="l00321"></a>00321 
<a name="l00322"></a>00322 <span class="comment">/* Disassemble one basic block. */</span>
<a name="l00323"></a>00323 <a class="code" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">Disassembler::InstructionMap</a>
<a name="l00324"></a><a class="code" href="classDisassembler.html#e6e5cf2f743d1c9815e724cc2cfd55b8">00324</a> <a class="code" href="classDisassembler.html#e6e5cf2f743d1c9815e724cc2cfd55b8">Disassembler::disassembleBlock</a>(<span class="keyword">const</span> <a class="code" href="classMemoryMap.html">MemoryMap</a> *map, <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> start_va, <a class="code" href="namespaceVirtualBinCFG.html#21495b08e1c020b22a49fbf0c569c3ec">AddressSet</a> *successors, InstructionMap *cache)
<a name="l00325"></a>00325 {
<a name="l00326"></a>00326     <a class="code" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">InstructionMap</a> insns;
<a name="l00327"></a>00327     <a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn;
<a name="l00328"></a>00328     <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va=0, next_va=start_va;
<a name="l00329"></a>00329 
<a name="l00330"></a>00330     <span class="keywordflow">if</span> (<a class="code" href="classDisassembler.html#296d72c41fe8ab803feed162ea7dd6e3">p_debug</a>)
<a name="l00331"></a>00331         fprintf(<a class="code" href="classDisassembler.html#296d72c41fe8ab803feed162ea7dd6e3">p_debug</a>, <span class="stringliteral">"Disassembler[va 0x%08"</span>PRIx64<span class="stringliteral">"]: disassembling basic block\n"</span>, start_va);
<a name="l00332"></a>00332 
<a name="l00333"></a>00333     <span class="keywordflow">do</span> { <span class="comment">/*tail recursion*/</span>
<a name="l00334"></a>00334 
<a name="l00335"></a>00335         <span class="comment">/* Disassemble each instruction of what we naively consider to be a basic block (semantic analysis may prove</span>
<a name="l00336"></a>00336 <span class="comment">         * otherwise). This loop exits locally if we reach an address that cannot be disassembled (and we're not calling</span>
<a name="l00337"></a>00337 <span class="comment">         * make_unknown_instruction()) or we reach an instruction that naively terminates a basic block.  In the former case,</span>
<a name="l00338"></a>00338 <span class="comment">         * INSN will be the last instruction, VA is its virtual address, and NEXT_VA is the address of the following</span>
<a name="l00339"></a>00339 <span class="comment">         * instruction; otherwise INSN is null, VA is the address where disassembly failed, and NEXT_VA is meaningless. */</span>
<a name="l00340"></a>00340         <span class="keywordflow">while</span> (1) {
<a name="l00341"></a>00341             va = next_va;
<a name="l00342"></a>00342 
<a name="l00343"></a>00343             insn = NULL;
<a name="l00344"></a>00344             <span class="keywordflow">if</span> (cache) {
<a name="l00345"></a>00345                 InstructionMap::iterator cached = cache-&gt;find(va);
<a name="l00346"></a>00346                 <span class="keywordflow">if</span> (cached!=cache-&gt;end())
<a name="l00347"></a>00347                     insn = cached-&gt;second;
<a name="l00348"></a>00348             }
<a name="l00349"></a>00349             <span class="keywordflow">try</span> {
<a name="l00350"></a>00350                 <span class="keywordflow">if</span> (!insn) {
<a name="l00351"></a>00351                     insn = <a class="code" href="classDisassembler.html#d765ce924af663d75b9ce5915d658d7c">disassembleOne</a>(map, va, NULL);
<a name="l00352"></a>00352                     <span class="keywordflow">if</span> (cache)
<a name="l00353"></a>00353                         cache-&gt;insert(std::make_pair(va, insn));
<a name="l00354"></a>00354                 }
<a name="l00355"></a>00355             } <span class="keywordflow">catch</span>(<span class="keyword">const</span> <a class="code" href="classDisassembler_1_1Exception.html">Exception</a> &amp;e) {
<a name="l00356"></a>00356                 <span class="keywordflow">if</span> ((<a class="code" href="classDisassembler.html#15730211163d1de76e77a8673f54465e">p_search</a> &amp; <a class="code" href="classDisassembler.html#bf0472f94be5962208d1944c644337024e36d238297ad9e93e506a1a34a65451">SEARCH_UNKNOWN</a>) &amp;&amp; e.<a class="code" href="classDisassembler_1_1Exception.html#a55e12d4da36ff0e4e4ed18c0c915ff9">bytes</a>.size()&gt;0) {
<a name="l00357"></a>00357                     insn = <a class="code" href="classDisassembler.html#182a5f0ca954057d37b32cdda9aa4f3c">make_unknown_instruction</a>(e);
<a name="l00358"></a>00358                 } <span class="keywordflow">else</span> {
<a name="l00359"></a>00359                     <span class="keywordflow">if</span> (insns.size()==0 || !(<a class="code" href="classDisassembler.html#15730211163d1de76e77a8673f54465e">p_search</a> &amp; <a class="code" href="classDisassembler.html#bf0472f94be5962208d1944c644337021b6f5035e3b9b0c34514d32c0b8ff8e3">SEARCH_DEADEND</a>)) {
<a name="l00360"></a>00360                         <span class="keywordflow">if</span> (p_debug)
<a name="l00361"></a>00361                             fprintf(p_debug, <span class="stringliteral">"Disassembler[va 0x%08"</span>PRIx64<span class="stringliteral">"]: "</span>
<a name="l00362"></a>00362                                     <span class="stringliteral">"disassembly failed in basic block 0x%08"</span>PRIx64<span class="stringliteral">": %s\n"</span>,
<a name="l00363"></a>00363                                     e.<a class="code" href="classDisassembler_1_1Exception.html#740035a2fac94da1d179cac2a3897fa5">ip</a>, start_va, e.<a class="code" href="classDisassembler_1_1Exception.html#b0fe6869e8b74a4fc2579c44a6ea6a61">mesg</a>.c_str());
<a name="l00364"></a>00364                         <span class="keywordflow">if</span> (!cache) {
<a name="l00365"></a>00365                             <span class="keywordflow">for</span> (InstructionMap::iterator ii=insns.begin(); ii!=insns.end(); ++ii)
<a name="l00366"></a>00366                                 <a class="code" href="namespaceSageInterface.html#57437bbbb806858dda0cea7444fbafef">SageInterface::deleteAST</a>(ii-&gt;second);
<a name="l00367"></a>00367                         }
<a name="l00368"></a>00368                         <span class="keywordflow">throw</span>;
<a name="l00369"></a>00369                     }
<a name="l00370"></a>00370                     <span class="comment">/* Terminate tail recursion. Make sure we don't try to disassemble here again within this call, even if</span>
<a name="l00371"></a>00371 <span class="comment">                     * semantic analysis can prove that the next instruction address is the only possible successor. */</span>
<a name="l00372"></a>00372                     insn = NULL;
<a name="l00373"></a>00373                     <span class="keywordflow">break</span>;
<a name="l00374"></a>00374                 }
<a name="l00375"></a>00375             }
<a name="l00376"></a>00376             assert(insn!=NULL);
<a name="l00377"></a>00377             next_va = va + insn-&gt;<a class="code" href="classSgAsmInstruction.html#6adcc4eb7c725185baa3a2425a57843c">get_size</a>();
<a name="l00378"></a>00378             insns.insert(std::make_pair(va, insn));
<a name="l00379"></a>00379 
<a name="l00380"></a>00380             <span class="comment">/* Is this the end of a basic block? This is naive logic that bases the decision only on the single instruction.</span>
<a name="l00381"></a>00381 <span class="comment">             * A more thorough analysis can be performed below in the get_block_successors() call. */</span>          
<a name="l00382"></a>00382             <span class="keywordflow">if</span> (insn-&gt;<a class="code" href="classSgAsmInstruction.html#f359a9ca1bec7b95cbbf5fa7537136b1">terminatesBasicBlock</a>()) {
<a name="l00383"></a>00383                 <span class="keywordflow">if</span> (p_debug)
<a name="l00384"></a>00384                     fprintf(p_debug, <span class="stringliteral">"Disassembler[va 0x%08"</span>PRIx64<span class="stringliteral">"]: \"%s\" at 0x%08"</span>PRIx64<span class="stringliteral">" naively terminates block\n"</span>,
<a name="l00385"></a>00385                             start_va, <a class="code" href="AsmUnparser__compat_8h.html#9d1a2ee4068a1bb4deb665289aafcaa8">unparseMnemonic</a>(insn).c_str(), va);
<a name="l00386"></a>00386                 <span class="keywordflow">break</span>;
<a name="l00387"></a>00387             }
<a name="l00388"></a>00388         }
<a name="l00389"></a>00389 
<a name="l00390"></a>00390         <span class="comment">/* Try to figure out the successor addresses.  If we can prove that the only successor is the address following the</span>
<a name="l00391"></a>00391 <span class="comment">         * last instruction then we can continue disassembling as if this were a single basic block. */</span>
<a name="l00392"></a>00392         <span class="keywordtype">bool</span> complete=<span class="keyword">false</span>;
<a name="l00393"></a>00393         <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">AddressSet</a> suc = <a class="code" href="classDisassembler.html#6b43093bcbec9db07aa30e34b754051e">get_block_successors</a>(insns, &amp;complete);
<a name="l00394"></a>00394         <span class="keywordflow">if</span> (insn &amp;&amp; complete &amp;&amp; suc.size()==1 &amp;&amp; *(suc.begin())==next_va) {
<a name="l00395"></a>00395             <span class="keywordflow">if</span> (p_debug) {
<a name="l00396"></a>00396                 fprintf(p_debug,
<a name="l00397"></a>00397                         <span class="stringliteral">"Disassembler[va 0x%08"</span>PRIx64<span class="stringliteral">"]: semantic analysis proves basic block continues after 0x%08"</span>PRIx64<span class="stringliteral">"\n"</span>,
<a name="l00398"></a>00398                         start_va, va);
<a name="l00399"></a>00399             }
<a name="l00400"></a>00400         } <span class="keywordflow">else</span> {
<a name="l00401"></a>00401             insn = NULL; <span class="comment">/*terminate recursion*/</span>
<a name="l00402"></a>00402         }
<a name="l00403"></a>00403 
<a name="l00404"></a>00404         <span class="comment">/* Save block successors in return value before we exit scope */</span>
<a name="l00405"></a>00405         <span class="keywordflow">if</span> (!insn &amp;&amp; successors) {
<a name="l00406"></a>00406             successors-&gt;insert(suc.begin(), suc.end());
<a name="l00407"></a>00407             <span class="keywordflow">if</span> (p_debug) {
<a name="l00408"></a>00408                 fprintf(p_debug, <span class="stringliteral">"Disassembler[va 0x%08"</span>PRIx64<span class="stringliteral">"]: basic block successors:"</span>, start_va);
<a name="l00409"></a>00409                 <span class="keywordflow">for</span> (AddressSet::iterator si=suc.begin(); si!=suc.end(); si++)
<a name="l00410"></a>00410                     fprintf(p_debug, <span class="stringliteral">" 0x%08"</span>PRIx64, *si);
<a name="l00411"></a>00411                 fprintf(p_debug, <span class="stringliteral">"\n"</span>);
<a name="l00412"></a>00412             }
<a name="l00413"></a>00413         }
<a name="l00414"></a>00414     } <span class="keywordflow">while</span> (insn);
<a name="l00415"></a>00415     <span class="keywordflow">return</span> insns;
<a name="l00416"></a>00416 }
<a name="l00417"></a>00417 
<a name="l00418"></a>00418 <span class="comment">/* Disassemble one basic block. */</span>
<a name="l00419"></a>00419 <a class="code" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">Disassembler::InstructionMap</a>
<a name="l00420"></a><a class="code" href="classDisassembler.html#98958de60609e6cfea60302309ce609a">00420</a> <a class="code" href="classDisassembler.html#e6e5cf2f743d1c9815e724cc2cfd55b8">Disassembler::disassembleBlock</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buf, <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> buf_va, size_t buf_size, <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> start_va,
<a name="l00421"></a>00421                                <a class="code" href="namespaceVirtualBinCFG.html#21495b08e1c020b22a49fbf0c569c3ec">AddressSet</a> *successors, InstructionMap *cache)
<a name="l00422"></a>00422 {
<a name="l00423"></a>00423     <a class="code" href="classMemoryMap.html#3fcd4dad3786a2b27069c7891eb7b378">MemoryMap::BufferPtr</a> buffer = <a class="code" href="classMemoryMap_1_1ExternBuffer.html#84cf5d396b6cca4a0f4289b6f80e7982">MemoryMap::ExternBuffer::create</a>(buf, buf_size);
<a name="l00424"></a>00424     <a class="code" href="classMemoryMap_1_1Segment.html">MemoryMap::Segment</a> segment(buffer, 0, <a class="code" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd57589290f94ccb75d2e8b659c4ef50bb700">MemoryMap::MM_PROT_RX</a>, <span class="stringliteral">"disassembleBlock temp"</span>);
<a name="l00425"></a>00425     <a class="code" href="classMemoryMap.html">MemoryMap</a> map;
<a name="l00426"></a>00426     map.<a class="code" href="classMemoryMap.html#d8b51b8c73d8bb8d5922cbf1360800ef">insert</a>(<a class="code" href="Cxx__Grammar_8h.html#d8e49820aaa106bb8a2dc17d9ad38d87">Extent</a>(buf_va, buf_size), segment);
<a name="l00427"></a>00427     <span class="keywordflow">return</span> <a class="code" href="classDisassembler.html#e6e5cf2f743d1c9815e724cc2cfd55b8">disassembleBlock</a>(&amp;map, start_va, successors, cache);
<a name="l00428"></a>00428 }
<a name="l00429"></a>00429 
<a name="l00430"></a>00430 <span class="comment">/* Disassemble reachable instructions from a buffer */</span>
<a name="l00431"></a>00431 <a class="code" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">Disassembler::InstructionMap</a>
<a name="l00432"></a><a class="code" href="classDisassembler.html#529504e76680ce23f076337b276003a9">00432</a> <a class="code" href="classDisassembler.html#529504e76680ce23f076337b276003a9">Disassembler::disassembleBuffer</a>(<span class="keyword">const</span> <a class="code" href="classMemoryMap.html">MemoryMap</a> *map, size_t start_va, <a class="code" href="namespaceVirtualBinCFG.html#21495b08e1c020b22a49fbf0c569c3ec">AddressSet</a> *successors, BadMap *bad)
<a name="l00433"></a>00433 {
<a name="l00434"></a>00434     <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">AddressSet</a> worklist;
<a name="l00435"></a>00435     worklist.insert(start_va);
<a name="l00436"></a>00436     <span class="keywordflow">return</span> <a class="code" href="classDisassembler.html#529504e76680ce23f076337b276003a9">disassembleBuffer</a>(map, worklist, successors, bad);
<a name="l00437"></a>00437 }
<a name="l00438"></a>00438 
<a name="l00439"></a>00439 <span class="comment">/* Disassemble reachable instructions from a buffer */</span>
<a name="l00440"></a>00440 <a class="code" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">Disassembler::InstructionMap</a>
<a name="l00441"></a><a class="code" href="classDisassembler.html#5cf5531e09ee3b0c98435aeb772b472a">00441</a> <a class="code" href="classDisassembler.html#529504e76680ce23f076337b276003a9">Disassembler::disassembleBuffer</a>(<span class="keyword">const</span> <a class="code" href="classMemoryMap.html">MemoryMap</a> *map, <a class="code" href="namespaceVirtualBinCFG.html#21495b08e1c020b22a49fbf0c569c3ec">AddressSet</a> worklist, <a class="code" href="namespaceVirtualBinCFG.html#21495b08e1c020b22a49fbf0c569c3ec">AddressSet</a> *successors, BadMap *bad)
<a name="l00442"></a>00442 {
<a name="l00443"></a>00443     <a class="code" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">InstructionMap</a> insns;
<a name="l00444"></a>00444     <a class="code" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">InstructionMap</a> icache;              <span class="comment">/* to help speed up disassembleBlock() when SEARCH_DEADEND is disabled */</span>
<a name="l00445"></a>00445     <span class="keywordflow">try</span> {
<a name="l00446"></a>00446         <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> next_search = 0;
<a name="l00447"></a>00447 
<a name="l00448"></a>00448         <span class="comment">/* Per-buffer search methods */</span>
<a name="l00449"></a>00449         <span class="keywordflow">if</span> (<a class="code" href="classDisassembler.html#15730211163d1de76e77a8673f54465e">p_search</a> &amp; <a class="code" href="classDisassembler.html#bf0472f94be5962208d1944c644337023cabd4da3280e245233393925dfae696">SEARCH_WORDS</a>)
<a name="l00450"></a>00450             <a class="code" href="classDisassembler.html#d3e45f4c745a3a52eebc63ec59e08f80">search_words</a>(&amp;worklist, map, bad);
<a name="l00451"></a>00451 
<a name="l00452"></a>00452         <span class="comment">/* Look for more addresses */</span>
<a name="l00453"></a>00453         <span class="keywordflow">if</span> (worklist.size()==0 &amp;&amp; (<a class="code" href="classDisassembler.html#15730211163d1de76e77a8673f54465e">p_search</a> &amp; (<a class="code" href="classDisassembler.html#bf0472f94be5962208d1944c6443370292e1794f3dc36276d713f3ce4ab8b32a">SEARCH_ALLBYTES</a>|<a class="code" href="classDisassembler.html#bf0472f94be5962208d1944c6443370263b4361b25a275377f1b610200feaea0">SEARCH_UNUSED</a>))) {
<a name="l00454"></a>00454             <span class="keywordtype">bool</span> avoid_overlap = (<a class="code" href="classDisassembler.html#15730211163d1de76e77a8673f54465e">p_search</a> &amp; <a class="code" href="classDisassembler.html#bf0472f94be5962208d1944c6443370263b4361b25a275377f1b610200feaea0">SEARCH_UNUSED</a>) ? <span class="keyword">true</span> : <span class="keyword">false</span>;
<a name="l00455"></a>00455             <a class="code" href="classDisassembler.html#8ef3399860cc88e77a83d5f96e6f0d85">search_next_address</a>(&amp;worklist, next_search, map, insns, bad, avoid_overlap);
<a name="l00456"></a>00456             <span class="keywordflow">if</span> (worklist.size()&gt;0)
<a name="l00457"></a>00457                 next_search = *(--worklist.end())+1;
<a name="l00458"></a>00458         }
<a name="l00459"></a>00459 
<a name="l00460"></a>00460         <span class="keywordflow">while</span> (worklist.size()&gt;0) {
<a name="l00461"></a>00461             <span class="comment">/* Get next address to disassemble */</span>
<a name="l00462"></a>00462             AddressSet::iterator i = worklist.begin();
<a name="l00463"></a>00463             <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va = *i;
<a name="l00464"></a>00464             worklist.erase(i);
<a name="l00465"></a>00465 
<a name="l00466"></a>00466             <span class="keywordflow">if</span> (insns.find(va)!=insns.end() || (bad &amp;&amp; bad-&gt;find(va)!=bad-&gt;end())) {
<a name="l00467"></a>00467                 <span class="comment">/* Skip this if we've already tried to disassemble it. */</span>
<a name="l00468"></a>00468             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!map-&gt;<a class="code" href="classMemoryMap.html#372b80eef545c53a95b322c53e526e64">exists</a>(va)) {
<a name="l00469"></a>00469                 <span class="comment">/* Any address that's outside the range we're allowed to work on will be added to the successors. */</span>
<a name="l00470"></a>00470                 <span class="keywordflow">if</span> (successors)
<a name="l00471"></a>00471                     successors-&gt;insert(va);
<a name="l00472"></a>00472             } <span class="keywordflow">else</span> {
<a name="l00473"></a>00473                 <span class="comment">/* Disassemble a basic block and add successors to the work list. If a disassembly error occurs then</span>
<a name="l00474"></a>00474 <span class="comment">                 * disassembleBlock() will throw an exception that we'll add to the bad list. We must be careful when adding the</span>
<a name="l00475"></a>00475 <span class="comment">                 * basic block's instructions to the return value: although we check above to prevent disassembling the same</span>
<a name="l00476"></a>00476 <span class="comment">                 * basic block more than once, it's still possible that two basic blocks could overlap (e.g., block A could start</span>
<a name="l00477"></a>00477 <span class="comment">                 * at the second instruction of block B, or on a viariable-size instruction architecture, block A could start</span>
<a name="l00478"></a>00478 <span class="comment">                 * between instructions of block B and then become synchronized with B). */</span>
<a name="l00479"></a>00479                 <a class="code" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">InstructionMap</a> bb;
<a name="l00480"></a>00480                 <span class="keywordflow">try</span> {
<a name="l00481"></a>00481                     bb = <a class="code" href="classDisassembler.html#e6e5cf2f743d1c9815e724cc2cfd55b8">disassembleBlock</a>(map, va, &amp;worklist, &amp;icache);
<a name="l00482"></a>00482                     insns.insert(bb.begin(), bb.end()); <span class="comment">/*not inserted if already existing*/</span>
<a name="l00483"></a>00483                 } <span class="keywordflow">catch</span>(<span class="keyword">const</span> <a class="code" href="classDisassembler_1_1Exception.html">Exception</a> &amp;e) {
<a name="l00484"></a>00484                     <span class="keywordflow">if</span> (bad)
<a name="l00485"></a>00485                         bad-&gt;insert(std::make_pair(va, e));
<a name="l00486"></a>00486                 }
<a name="l00487"></a>00487 
<a name="l00488"></a>00488                 <span class="comment">/* Per-basicblock search methods */</span>
<a name="l00489"></a>00489                 <span class="keywordflow">if</span> (<a class="code" href="classDisassembler.html#15730211163d1de76e77a8673f54465e">p_search</a> &amp; <a class="code" href="classDisassembler.html#bf0472f94be5962208d1944c644337024ea6287ee40f180ae7ca70435a72db12">SEARCH_FOLLOWING</a>)
<a name="l00490"></a>00490                     <a class="code" href="classDisassembler.html#e279ade84d462c55d1d78b1c39f6edad">search_following</a>(&amp;worklist, bb, va, map, bad);
<a name="l00491"></a>00491                 <span class="keywordflow">if</span> (<a class="code" href="classDisassembler.html#15730211163d1de76e77a8673f54465e">p_search</a> &amp; <a class="code" href="classDisassembler.html#bf0472f94be5962208d1944c64433702ca5b02f67163cb932a95bd7bead7fd67">SEARCH_IMMEDIATE</a>)
<a name="l00492"></a>00492                     <a class="code" href="classDisassembler.html#22face8ccdd1cee35dd79948614de67b">search_immediate</a>(&amp;worklist, bb, map, bad);
<a name="l00493"></a>00493             }
<a name="l00494"></a>00494 
<a name="l00495"></a>00495             <span class="comment">/* Look for more addresses */</span>
<a name="l00496"></a>00496             <span class="keywordflow">if</span> (worklist.size()==0 &amp;&amp; (<a class="code" href="classDisassembler.html#15730211163d1de76e77a8673f54465e">p_search</a> &amp; (<a class="code" href="classDisassembler.html#bf0472f94be5962208d1944c6443370292e1794f3dc36276d713f3ce4ab8b32a">SEARCH_ALLBYTES</a>|<a class="code" href="classDisassembler.html#bf0472f94be5962208d1944c6443370263b4361b25a275377f1b610200feaea0">SEARCH_UNUSED</a>))) {
<a name="l00497"></a>00497                 <span class="keywordtype">bool</span> avoid_overlap = (<a class="code" href="classDisassembler.html#15730211163d1de76e77a8673f54465e">p_search</a> &amp; <a class="code" href="classDisassembler.html#bf0472f94be5962208d1944c6443370263b4361b25a275377f1b610200feaea0">SEARCH_UNUSED</a>) ? <span class="keyword">true</span> : <span class="keyword">false</span>;
<a name="l00498"></a>00498                 <a class="code" href="classDisassembler.html#8ef3399860cc88e77a83d5f96e6f0d85">search_next_address</a>(&amp;worklist, next_search, map, insns, bad, avoid_overlap);
<a name="l00499"></a>00499                 <span class="keywordflow">if</span> (worklist.size()&gt;0)
<a name="l00500"></a>00500                     next_search = *(--worklist.end())+1;
<a name="l00501"></a>00501 
<a name="l00502"></a>00502             }
<a name="l00503"></a>00503         }
<a name="l00504"></a>00504     } <span class="keywordflow">catch</span>(...) {
<a name="l00505"></a>00505         <span class="keywordflow">for</span> (InstructionMap::iterator ii=icache.begin(); ii!=icache.end(); ++ii)
<a name="l00506"></a>00506             <a class="code" href="namespaceSageInterface.html#57437bbbb806858dda0cea7444fbafef">SageInterface::deleteAST</a>(ii-&gt;second);
<a name="l00507"></a>00507         <span class="keywordflow">throw</span>;
<a name="l00508"></a>00508     }
<a name="l00509"></a>00509 
<a name="l00510"></a>00510     <span class="keywordflow">return</span> insns;
<a name="l00511"></a>00511 }
<a name="l00512"></a>00512 
<a name="l00513"></a>00513 <span class="comment">/* Add basic block following address to work list. */</span>
<a name="l00514"></a>00514 <span class="keywordtype">void</span>
<a name="l00515"></a><a class="code" href="classDisassembler.html#e279ade84d462c55d1d78b1c39f6edad">00515</a> <a class="code" href="classDisassembler.html#e279ade84d462c55d1d78b1c39f6edad">Disassembler::search_following</a>(<a class="code" href="namespaceVirtualBinCFG.html#21495b08e1c020b22a49fbf0c569c3ec">AddressSet</a> *worklist, <span class="keyword">const</span> InstructionMap &amp;bb, <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> bb_va, <span class="keyword">const</span> <a class="code" href="classMemoryMap.html">MemoryMap</a> *map,
<a name="l00516"></a>00516                                <span class="keyword">const</span> BadMap *bad)
<a name="l00517"></a>00517 {
<a name="l00518"></a>00518     <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> following_va = 0;
<a name="l00519"></a>00519     <span class="keywordflow">if</span> (bb.empty()) {
<a name="l00520"></a>00520         following_va = bb_va+1;
<a name="l00521"></a>00521     } <span class="keywordflow">else</span> {
<a name="l00522"></a>00522         InstructionMap::const_iterator bbi = bb.end();
<a name="l00523"></a>00523         --bbi;
<a name="l00524"></a>00524         <a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *last_insn = bbi-&gt;second;
<a name="l00525"></a>00525         following_va = last_insn-&gt;<a class="code" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>() + last_insn-&gt;<a class="code" href="classSgAsmInstruction.html#6adcc4eb7c725185baa3a2425a57843c">get_size</a>();
<a name="l00526"></a>00526     }
<a name="l00527"></a>00527 
<a name="l00528"></a>00528     <span class="keywordflow">if</span> (map-&gt;<a class="code" href="classMemoryMap.html#372b80eef545c53a95b322c53e526e64">exists</a>(following_va) &amp;&amp; (!bad || bad-&gt;find(following_va)==bad-&gt;end())) {
<a name="l00529"></a>00529         <span class="keywordflow">if</span> (<a class="code" href="classDisassembler.html#296d72c41fe8ab803feed162ea7dd6e3">p_debug</a> &amp;&amp; worklist-&gt;find(following_va)==worklist-&gt;end()) {
<a name="l00530"></a>00530             <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va = bb.begin()-&gt;first;
<a name="l00531"></a>00531             fprintf(<a class="code" href="classDisassembler.html#296d72c41fe8ab803feed162ea7dd6e3">p_debug</a>, <span class="stringliteral">"Disassembler[va 0x%08"</span>PRIx64<span class="stringliteral">"]: SEARCH_FOLLOWING added 0x%08"</span>PRIx64<span class="stringliteral">"\n"</span>, va, following_va);
<a name="l00532"></a>00532         }
<a name="l00533"></a>00533         worklist-&gt;insert(following_va);
<a name="l00534"></a>00534     }
<a name="l00535"></a>00535 }
<a name="l00536"></a>00536 
<a name="l00537"></a>00537 <span class="comment">/* Add values of immediate operands to work list */</span>
<a name="l00538"></a>00538 <span class="keywordtype">void</span>
<a name="l00539"></a><a class="code" href="classDisassembler.html#22face8ccdd1cee35dd79948614de67b">00539</a> <a class="code" href="classDisassembler.html#22face8ccdd1cee35dd79948614de67b">Disassembler::search_immediate</a>(<a class="code" href="namespaceVirtualBinCFG.html#21495b08e1c020b22a49fbf0c569c3ec">AddressSet</a> *worklist, <span class="keyword">const</span> InstructionMap &amp;bb,  <span class="keyword">const</span> <a class="code" href="classMemoryMap.html">MemoryMap</a> *map, <span class="keyword">const</span> BadMap *bad)
<a name="l00540"></a>00540 {
<a name="l00541"></a>00541     <span class="keywordflow">for</span> (InstructionMap::const_iterator bbi=bb.begin(); bbi!=bb.end(); bbi++) {
<a name="l00542"></a>00542         <span class="keyword">const</span> std::vector&lt;SgAsmExpression*&gt; &amp;operands = bbi-&gt;second-&gt;get_operandList()-&gt;get_operands();
<a name="l00543"></a>00543         <span class="keywordflow">for</span> (size_t i=0; i&lt;operands.size(); i++) {
<a name="l00544"></a>00544             uint64_t constant=0;
<a name="l00545"></a>00545             <span class="keywordflow">switch</span> (operands[i]-&gt;variantT()) {
<a name="l00546"></a>00546                 <span class="keywordflow">case</span> <a class="code" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464387fc91652d62410b89c79c170243b1f">V_SgAsmWordValueExpression</a>:
<a name="l00547"></a>00547                     constant = <a class="code" href="Cxx__Grammar_8h.html#26f8959436fc609bf33bb645b4e41bed">isSgAsmWordValueExpression</a>(operands[i])-&gt;<a class="code" href="classSgAsmWordValueExpression.html#ec7880171b93b65b8b4fd9b39846d17b">get_value</a>();
<a name="l00548"></a>00548                     <span class="keywordflow">break</span>;
<a name="l00549"></a>00549                 <span class="keywordflow">case</span> <a class="code" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464e0eb7c370762f0e7338c8f34fb9c69e1">V_SgAsmDoubleWordValueExpression</a>:
<a name="l00550"></a>00550                     constant = <a class="code" href="Cxx__Grammar_8h.html#da4951b2a5743765b3427d5ea4057e48">isSgAsmDoubleWordValueExpression</a>(operands[i])-&gt;<a class="code" href="classSgAsmDoubleWordValueExpression.html#0776831c616546c0a277f1b5ce2782f7">get_value</a>();
<a name="l00551"></a>00551                     <span class="keywordflow">break</span>;
<a name="l00552"></a>00552                 <span class="keywordflow">case</span> <a class="code" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e346473347a77bede6263a2f62e84a88282fe">V_SgAsmQuadWordValueExpression</a>:
<a name="l00553"></a>00553                     constant = <a class="code" href="Cxx__Grammar_8h.html#86d1906725133b85b9114c14572db22b">isSgAsmQuadWordValueExpression</a>(operands[i])-&gt;<a class="code" href="classSgAsmQuadWordValueExpression.html#51cd0cde04f955e1c111da2fb4fa1c84">get_value</a>();
<a name="l00554"></a>00554                     <span class="keywordflow">break</span>;
<a name="l00555"></a>00555                 <span class="keywordflow">default</span>:
<a name="l00556"></a>00556                     <span class="keywordflow">continue</span>; <span class="comment">/* Not an appropriately-sized constant */</span>
<a name="l00557"></a>00557             }
<a name="l00558"></a>00558             <span class="keywordflow">if</span> (map-&gt;<a class="code" href="classMemoryMap.html#372b80eef545c53a95b322c53e526e64">exists</a>(constant) &amp;&amp; (!bad || bad-&gt;find(constant)==bad-&gt;end())) {
<a name="l00559"></a>00559                 <span class="keywordflow">if</span> (<a class="code" href="classDisassembler.html#296d72c41fe8ab803feed162ea7dd6e3">p_debug</a> &amp;&amp; worklist-&gt;find(constant)==worklist-&gt;end())
<a name="l00560"></a>00560                     fprintf(<a class="code" href="classDisassembler.html#296d72c41fe8ab803feed162ea7dd6e3">p_debug</a>, <span class="stringliteral">"Disassembler[va 0x%08"</span>PRIx64<span class="stringliteral">"]: SEARCH_IMMEDIATE added 0x%08"</span>PRIx64<span class="stringliteral">"\n"</span>,
<a name="l00561"></a>00561                             bbi-&gt;first, constant);
<a name="l00562"></a>00562                 worklist-&gt;insert(constant);
<a name="l00563"></a>00563             }
<a name="l00564"></a>00564         }
<a name="l00565"></a>00565     }
<a name="l00566"></a>00566 }
<a name="l00567"></a>00567 
<a name="l00568"></a>00568 <span class="comment">/* Add word-aligned values to work list */</span>
<a name="l00569"></a>00569 <span class="keywordtype">void</span>
<a name="l00570"></a><a class="code" href="classDisassembler.html#d3e45f4c745a3a52eebc63ec59e08f80">00570</a> <a class="code" href="classDisassembler.html#d3e45f4c745a3a52eebc63ec59e08f80">Disassembler::search_words</a>(<a class="code" href="namespaceVirtualBinCFG.html#21495b08e1c020b22a49fbf0c569c3ec">AddressSet</a> *worklist, <span class="keyword">const</span> <a class="code" href="classMemoryMap.html">MemoryMap</a> *map, <span class="keyword">const</span> BadMap *bad)
<a name="l00571"></a>00571 {
<a name="l00572"></a>00572     <span class="comment">// Predicate is used only for its side effects</span>
<a name="l00573"></a>00573     <span class="keyword">struct </span>Visitor: <span class="keyword">public</span> <a class="code" href="classMemoryMap.html">MemoryMap</a>::Visitor {
<a name="l00574"></a>00574         <a class="code" href="classDisassembler.html">Disassembler</a> *d;
<a name="l00575"></a>00575         <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">AddressSet</a> *worklist;
<a name="l00576"></a>00576         <span class="keyword">const</span> <a class="code" href="classDisassembler.html#30c51578d70dfc05fb46047867ceadcd">BadMap</a> *bad;
<a name="l00577"></a>00577         Visitor(<a class="code" href="classDisassembler.html">Disassembler</a> *d, <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">AddressSet</a> *worklist, <span class="keyword">const</span> <a class="code" href="classDisassembler.html#30c51578d70dfc05fb46047867ceadcd">BadMap</a> *bad): d(d), worklist(worklist), bad(bad) {}
<a name="l00578"></a>00578         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <a class="code" href="classMemoryMap.html">MemoryMap</a> *map, <span class="keyword">const</span> <a class="code" href="classRange.html">Extent</a> &amp;range, <span class="keyword">const</span> <a class="code" href="classMemoryMap_1_1Segment.html">MemoryMap::Segment</a> &amp;segment) {
<a name="l00579"></a>00579             <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va = range.<a class="code" href="classRange.html#130cadb6ba89a4777ca44fa1a6489f27">first</a>();
<a name="l00580"></a>00580             va = <a class="code" href="MemoryMap_8h.html#1d446e305acb3a6aaa3bea9cce6f0aa4">ALIGN_UP</a>(va, d-&gt;<a class="code" href="classDisassembler.html#12066551a408a9bdca7d76d47a4d42de">get_alignment</a>());
<a name="l00581"></a>00581 
<a name="l00582"></a>00582             <span class="comment">/* Scan through this segment */</span>
<a name="l00583"></a>00583             <span class="keywordflow">while</span> (va+d-&gt;<a class="code" href="classDisassembler.html#0b8bb2cc293a3887eb823d0cdf9935d5">get_wordsize</a>() &lt;= range.<a class="code" href="classRange.html#347c0e723bcd929107dc0fffe31478f2">last</a>()) {
<a name="l00584"></a>00584                 <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> constant = 0; <span class="comment">/*virtual address*/</span>
<a name="l00585"></a>00585                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[<span class="keyword">sizeof</span> constant];
<a name="l00586"></a>00586                 assert(d-&gt;<a class="code" href="classDisassembler.html#0b8bb2cc293a3887eb823d0cdf9935d5">get_wordsize</a>()&lt;=<span class="keyword">sizeof</span> constant);
<a name="l00587"></a>00587                 <span class="keywordflow">if</span> (map-&gt;<a class="code" href="classMemoryMap.html#f8683ff784134fad5c016d51e03143e0">read1</a>(buf, va, d-&gt;<a class="code" href="classDisassembler.html#0b8bb2cc293a3887eb823d0cdf9935d5">get_wordsize</a>())&lt;d-&gt;<a class="code" href="classDisassembler.html#0b8bb2cc293a3887eb823d0cdf9935d5">get_wordsize</a>())
<a name="l00588"></a>00588                     <span class="keywordflow">break</span>; <span class="comment">/*shouldn't happen since we checked sizes above*/</span>
<a name="l00589"></a>00589 
<a name="l00590"></a>00590                 <span class="keywordflow">for</span> (size_t i=0; i&lt;d-&gt;<a class="code" href="classDisassembler.html#0b8bb2cc293a3887eb823d0cdf9935d5">get_wordsize</a>(); i++) {
<a name="l00591"></a>00591                     <span class="keywordflow">switch</span> (d-&gt;<a class="code" href="classDisassembler.html#53044be3d22b1de97a4ed94c2c4de707">get_sex</a>()) {
<a name="l00592"></a>00592                         <span class="keywordflow">case</span> <a class="code" href="classSgAsmExecutableFileFormat.html#9f34e9e7666815ddeee9be5df5573a8091735fb4441f9caf9effbd171df1bf76">SgAsmExecutableFileFormat::ORDER_LSB</a>:
<a name="l00593"></a>00593                             constant |= buf[i] &lt;&lt; (8*i);
<a name="l00594"></a>00594                             <span class="keywordflow">break</span>;
<a name="l00595"></a>00595                         <span class="keywordflow">case</span> <a class="code" href="classSgAsmExecutableFileFormat.html#9f34e9e7666815ddeee9be5df5573a8023944468b1aa305394a63a5608fb1b4d">SgAsmExecutableFileFormat::ORDER_MSB</a>:
<a name="l00596"></a>00596                             constant |= buf[i] &lt;&lt; (8*(d-&gt;<a class="code" href="classDisassembler.html#0b8bb2cc293a3887eb823d0cdf9935d5">get_wordsize</a>()-(i+1)));
<a name="l00597"></a>00597                             <span class="keywordflow">break</span>;
<a name="l00598"></a>00598                         <span class="keywordflow">default</span>:
<a name="l00599"></a>00599                             ROSE_ASSERT(!<span class="stringliteral">"not implemented"</span>);
<a name="l00600"></a>00600                     }
<a name="l00601"></a>00601                 }
<a name="l00602"></a>00602                 <span class="keywordflow">if</span> (map-&gt;<a class="code" href="classMemoryMap.html#372b80eef545c53a95b322c53e526e64">exists</a>(constant) &amp;&amp; (!bad || bad-&gt;find(constant)==bad-&gt;end())) {
<a name="l00603"></a>00603                     <span class="keywordflow">if</span> (d-&gt;<a class="code" href="classDisassembler.html#42a48d3ff1218c4e7a01291300246aa0">get_debug</a>() &amp;&amp; worklist-&gt;find(constant)==worklist-&gt;end())
<a name="l00604"></a>00604                         fprintf(d-&gt;<a class="code" href="classDisassembler.html#42a48d3ff1218c4e7a01291300246aa0">get_debug</a>(), <span class="stringliteral">"Disassembler[va 0x%08"</span>PRIx64<span class="stringliteral">"]: SEARCH_WORD added 0x%08"</span>PRIx64<span class="stringliteral">"\n"</span>, va, constant);
<a name="l00605"></a>00605                     worklist-&gt;insert(constant);
<a name="l00606"></a>00606                 }
<a name="l00607"></a>00607                 va += d-&gt;<a class="code" href="classDisassembler.html#12066551a408a9bdca7d76d47a4d42de">get_alignment</a>();
<a name="l00608"></a>00608             }
<a name="l00609"></a>00609             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00610"></a>00610         }
<a name="l00611"></a>00611     } visitor(<span class="keyword">this</span>, worklist, bad);
<a name="l00612"></a>00612     map-&gt;<a class="code" href="classMemoryMap.html#8eabb07a63d701ffb17649284a35eb2a">traverse</a>(visitor);
<a name="l00613"></a>00613 }
<a name="l00614"></a>00614 
<a name="l00615"></a>00615 <span class="comment">/* Find next unused address. */</span>
<a name="l00616"></a>00616 <span class="keywordtype">void</span>
<a name="l00617"></a><a class="code" href="classDisassembler.html#8ef3399860cc88e77a83d5f96e6f0d85">00617</a> <a class="code" href="classDisassembler.html#8ef3399860cc88e77a83d5f96e6f0d85">Disassembler::search_next_address</a>(<a class="code" href="namespaceVirtualBinCFG.html#21495b08e1c020b22a49fbf0c569c3ec">AddressSet</a> *worklist, <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> start_va, <span class="keyword">const</span> <a class="code" href="classMemoryMap.html">MemoryMap</a> *map,
<a name="l00618"></a>00618                                   <span class="keyword">const</span> InstructionMap &amp;insns, <span class="keyword">const</span> BadMap *bad, <span class="keywordtype">bool</span> avoid_overlap)
<a name="l00619"></a>00619 {
<a name="l00620"></a>00620     <span class="comment">/* Assume a maximum instruction size so that while we're search backward (by virtual address) through previously</span>
<a name="l00621"></a>00621 <span class="comment">     * disassembled instructions we don't have to go all the way to the beginning of the instruction map to prove that an</span>
<a name="l00622"></a>00622 <span class="comment">     * instruction doesn't overlap with a specified address. */</span>
<a name="l00623"></a>00623     <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> next_va = start_va;
<a name="l00624"></a>00624 
<a name="l00625"></a>00625     <span class="keywordflow">while</span> (1) {
<a name="l00626"></a>00626 
<a name="l00627"></a>00627         <span class="comment">/* Advance to the next valid mapped address if necessary by scanning for the first map element that has a higher</span>
<a name="l00628"></a>00628 <span class="comment">         * virtual address and is executable. */</span>
<a name="l00629"></a>00629         <a class="code" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">MemoryMap::Segments::const_iterator</a> si = map-&gt;<a class="code" href="classMemoryMap.html#48c9dda77ad1d1335a441aaeef55d98e">segments</a>().lower_bound(next_va);
<a name="l00630"></a>00630         <span class="keywordflow">if</span> (si==map-&gt;<a class="code" href="classMemoryMap.html#48c9dda77ad1d1335a441aaeef55d98e">segments</a>().end())
<a name="l00631"></a>00631             <span class="keywordflow">return</span>; <span class="comment">// no subsequent valid mapped address</span>
<a name="l00632"></a>00632         <span class="keyword">const</span> <a class="code" href="classRange.html">Extent</a> &amp;range = si-&gt;first;
<a name="l00633"></a>00633         <span class="keyword">const</span> <a class="code" href="classMemoryMap_1_1Segment.html">MemoryMap::Segment</a> &amp;segment = si-&gt;second;
<a name="l00634"></a>00634         assert(range.<a class="code" href="classRange.html#347c0e723bcd929107dc0fffe31478f2">last</a>()&gt;=next_va);
<a name="l00635"></a>00635 
<a name="l00636"></a>00636         <span class="keywordflow">if</span> (0==(segment.<a class="code" href="classMemoryMap_1_1Segment.html#7e05789bb2cb05c0e86cf0978d7169d8">get_mapperms</a>() &amp; <a class="code" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575a061dc1ffe578fdaea067d730efb00ac">MemoryMap::MM_PROT_EXEC</a>)) {
<a name="l00637"></a>00637             next_va = range.<a class="code" href="classRange.html#347c0e723bcd929107dc0fffe31478f2">last</a>() + 1;
<a name="l00638"></a>00638             <span class="keywordflow">continue</span>;
<a name="l00639"></a>00639         }
<a name="l00640"></a>00640 
<a name="l00641"></a>00641         next_va = std::max(next_va, range.<a class="code" href="classRange.html#130cadb6ba89a4777ca44fa1a6489f27">first</a>());
<a name="l00642"></a>00642 
<a name="l00643"></a>00643         <span class="comment">/* If we tried to disassemble at this address and failed, then try the next address. */</span>
<a name="l00644"></a>00644         <span class="keywordflow">if</span> (bad &amp;&amp; bad-&gt;find(next_va)!=bad-&gt;end()) {
<a name="l00645"></a>00645             next_va++;
<a name="l00646"></a>00646             <span class="keywordflow">continue</span>; <span class="comment">/*tail recursion*/</span>
<a name="l00647"></a>00647         }
<a name="l00648"></a>00648 
<a name="l00649"></a>00649         <span class="keywordflow">if</span> (avoid_overlap) {
<a name="l00650"></a>00650             <span class="comment">/* Are there any instructions that overlap with this address? */</span>
<a name="l00651"></a>00651             <a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *overlap = <a class="code" href="classDisassembler.html#5f947a0d435b201bda4fd2f10a02fc37">find_instruction_containing</a>(insns, next_va);
<a name="l00652"></a>00652             <span class="keywordflow">if</span> (overlap) {
<a name="l00653"></a>00653                 next_va = overlap-&gt;<a class="code" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>() + overlap-&gt;<a class="code" href="classSgAsmInstruction.html#6adcc4eb7c725185baa3a2425a57843c">get_size</a>() + 1;
<a name="l00654"></a>00654                 <span class="keywordflow">continue</span>; <span class="comment">/*tail recursion*/</span>
<a name="l00655"></a>00655             }
<a name="l00656"></a>00656         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (insns.find(next_va)!=insns.end()) {
<a name="l00657"></a>00657             <span class="comment">/* There is an instruction starting at this address */</span>
<a name="l00658"></a>00658             next_va++;
<a name="l00659"></a>00659             <span class="keywordflow">continue</span>; <span class="comment">/*tail recursion*/</span>
<a name="l00660"></a>00660         }
<a name="l00661"></a>00661 
<a name="l00662"></a>00662         <span class="keywordflow">if</span> (<a class="code" href="classDisassembler.html#296d72c41fe8ab803feed162ea7dd6e3">p_debug</a>)
<a name="l00663"></a>00663             fprintf(<a class="code" href="classDisassembler.html#296d72c41fe8ab803feed162ea7dd6e3">p_debug</a>, <span class="stringliteral">"Disassembler[va 0x%08"</span>PRIx64<span class="stringliteral">"]: SEARCH_%s added 0x%08"</span>PRIx64<span class="stringliteral">"\n"</span>,
<a name="l00664"></a>00664                     start_va, avoid_overlap?<span class="stringliteral">"UNUSED"</span>:<span class="stringliteral">"ALLBYTES"</span>, next_va);
<a name="l00665"></a>00665 
<a name="l00666"></a>00666         worklist-&gt;insert(next_va);
<a name="l00667"></a>00667         <span class="keywordflow">return</span>;
<a name="l00668"></a>00668     }
<a name="l00669"></a>00669 }
<a name="l00670"></a>00670 
<a name="l00671"></a>00671 <span class="keywordtype">void</span>
<a name="l00672"></a><a class="code" href="classDisassembler.html#94916adedc686310e3c7e773909ffe62">00672</a> <a class="code" href="classDisassembler.html#94916adedc686310e3c7e773909ffe62">Disassembler::search_function_symbols</a>(<a class="code" href="namespaceVirtualBinCFG.html#21495b08e1c020b22a49fbf0c569c3ec">AddressSet</a> *worklist, <span class="keyword">const</span> <a class="code" href="classMemoryMap.html">MemoryMap</a> *map, <a class="code" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a> *header)
<a name="l00673"></a>00673 {
<a name="l00674"></a>00674     <span class="keyword">struct </span>T: <span class="keyword">public</span> <a class="code" href="classAstSimpleProcessing.html">AstSimpleProcessing</a> {
<a name="l00675"></a>00675         T(<a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">AddressSet</a> *wl, <span class="keyword">const</span> <a class="code" href="classMemoryMap.html">MemoryMap</a> *map, FILE *f)
<a name="l00676"></a>00676             : worklist(wl), map(map), <a class="code" href="classDisassembler.html#296d72c41fe8ab803feed162ea7dd6e3">p_debug</a>(f) {}
<a name="l00677"></a>00677         <span class="keywordtype">void</span> visit(<a class="code" href="classSgNode.html">SgNode</a> *node) {
<a name="l00678"></a>00678             <a class="code" href="classSgAsmGenericSymbol.html">SgAsmGenericSymbol</a> *symbol = <a class="code" href="Cxx__Grammar_8h.html#1e43f3eb7b10c1884e4c271e0bf3c2c1">isSgAsmGenericSymbol</a>(node);
<a name="l00679"></a>00679             <span class="keywordflow">if</span> (symbol &amp;&amp; symbol-&gt;<a class="code" href="classSgAsmGenericSymbol.html#5e8431a123f40b27833d7926a2f59cde">get_type</a>()==<a class="code" href="classSgAsmGenericSymbol.html#25348ff5aed9d9e7c581db9d610f955cf63811b9d936e39b907895e2565b553f">SgAsmGenericSymbol::SYM_FUNC</a>) {
<a name="l00680"></a>00680                 <a class="code" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *section = symbol-&gt;<a class="code" href="classSgAsmGenericSymbol.html#b54ea63adff5a7cc0fd4963854d0b27c">get_bound</a>();
<a name="l00681"></a>00681                 <span class="keywordflow">if</span> (section &amp;&amp; (section-&gt;is_mapped() || section-&gt;get_contains_code())) {
<a name="l00682"></a>00682                     <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va = section-&gt;get_mapped_actual_va();
<a name="l00683"></a>00683                     <span class="keywordflow">if</span> (map-&gt;<a class="code" href="classMemoryMap.html#372b80eef545c53a95b322c53e526e64">exists</a>(va)) {
<a name="l00684"></a>00684                         <span class="keywordflow">if</span> (<a class="code" href="classDisassembler.html#296d72c41fe8ab803feed162ea7dd6e3">p_debug</a>)
<a name="l00685"></a>00685                             fprintf(p_debug, <span class="stringliteral">"Disassembler: SEARCH_FUNCSYMS added 0x%08"</span>PRIx64<span class="stringliteral">" for \"%s\"\n"</span>,
<a name="l00686"></a>00686                                     va, symbol-&gt;<a class="code" href="classSgAsmGenericSymbol.html#8cef0d96af06bb5e741df6a332c67e2c">get_name</a>()-&gt;<a class="code" href="classSgAsmGenericString.html#ba8bc51c8d891e4f8e8e87c45c62f7d5">get_string</a>(<span class="keyword">true</span>).c_str());
<a name="l00687"></a>00687                         worklist-&gt;insert(va);
<a name="l00688"></a>00688                     }
<a name="l00689"></a>00689                 }
<a name="l00690"></a>00690             }
<a name="l00691"></a>00691         }
<a name="l00692"></a>00692         <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">AddressSet</a> *worklist;
<a name="l00693"></a>00693         <span class="keyword">const</span> <a class="code" href="classMemoryMap.html">MemoryMap</a> *map;
<a name="l00694"></a>00694         FILE *<a class="code" href="classDisassembler.html#296d72c41fe8ab803feed162ea7dd6e3">p_debug</a>;
<a name="l00695"></a>00695     } t(worklist, map, <a class="code" href="classDisassembler.html#296d72c41fe8ab803feed162ea7dd6e3">p_debug</a>);
<a name="l00696"></a>00696     t.traverse(header, <a class="code" href="Cxx__Grammar_8h.html#59f7fee88581c4dd75f5fb25dbefa29edefb5d09673c144dc5b4dc177e278696">preorder</a>);
<a name="l00697"></a>00697 }
<a name="l00698"></a>00698 
<a name="l00699"></a>00699 <a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *
<a name="l00700"></a><a class="code" href="classDisassembler.html#5f947a0d435b201bda4fd2f10a02fc37">00700</a> <a class="code" href="classDisassembler.html#5f947a0d435b201bda4fd2f10a02fc37">Disassembler::find_instruction_containing</a>(<span class="keyword">const</span> InstructionMap &amp;insns, <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va)
<a name="l00701"></a>00701 {
<a name="l00702"></a>00702     <span class="keyword">const</span> size_t max_insns_size = 16;
<a name="l00703"></a>00703     InstructionMap::const_iterator ii=insns.upper_bound(va);
<a name="l00704"></a>00704     <span class="keywordflow">if</span> (ii==insns.begin())
<a name="l00705"></a>00705         <span class="keywordflow">return</span> NULL;
<a name="l00706"></a>00706     <span class="keywordflow">while</span> (1) {
<a name="l00707"></a>00707         --ii;
<a name="l00708"></a>00708         ROSE_ASSERT(ii-&gt;first &lt;= va);
<a name="l00709"></a>00709         <span class="keywordflow">if</span> (ii-&gt;first + max_insns_size &lt; va)
<a name="l00710"></a>00710             <span class="keywordflow">return</span> NULL;
<a name="l00711"></a>00711         <span class="keywordflow">if</span> (ii-&gt;first + ii-&gt;second-&gt;get_size() &gt; va)
<a name="l00712"></a>00712             <span class="keywordflow">return</span> ii-&gt;second;
<a name="l00713"></a>00713         if (ii==insns.begin())
<a name="l00714"></a>00714             <span class="keywordflow">return</span> NULL;
<a name="l00715"></a>00715     }
<a name="l00716"></a>00716 }
<a name="l00717"></a>00717     
<a name="l00718"></a>00718 <span class="comment">/* Disassemble reachable instructions from a buffer */</span>
<a name="l00719"></a>00719 <a class="code" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">Disassembler::InstructionMap</a>
<a name="l00720"></a><a class="code" href="classDisassembler.html#794b10f7544425165babecb042d6ca9b">00720</a> <a class="code" href="classDisassembler.html#529504e76680ce23f076337b276003a9">Disassembler::disassembleBuffer</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buf, <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> buf_va, size_t buf_size, <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> start_va,
<a name="l00721"></a>00721                                 <a class="code" href="namespaceVirtualBinCFG.html#21495b08e1c020b22a49fbf0c569c3ec">AddressSet</a> *successors, BadMap *bad)
<a name="l00722"></a>00722 {
<a name="l00723"></a>00723     <a class="code" href="classMemoryMap.html">MemoryMap</a> map;
<a name="l00724"></a>00724     map.<a class="code" href="classMemoryMap.html#d8b51b8c73d8bb8d5922cbf1360800ef">insert</a>(<a class="code" href="Cxx__Grammar_8h.html#d8e49820aaa106bb8a2dc17d9ad38d87">Extent</a>(buf_va, buf_size),
<a name="l00725"></a>00725                <a class="code" href="classMemoryMap_1_1Segment.html">MemoryMap::Segment</a>(<a class="code" href="classMemoryMap_1_1ExternBuffer.html#84cf5d396b6cca4a0f4289b6f80e7982">MemoryMap::ExternBuffer::create</a>(buf, buf_size), 0,
<a name="l00726"></a>00726                                   <a class="code" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd57589290f94ccb75d2e8b659c4ef50bb700">MemoryMap::MM_PROT_RX</a>, <span class="stringliteral">"disassembleBuffer temp"</span>));
<a name="l00727"></a>00727     <span class="keywordflow">return</span> <a class="code" href="classDisassembler.html#529504e76680ce23f076337b276003a9">disassembleBuffer</a>(&amp;map, start_va, successors, bad);
<a name="l00728"></a>00728 }
<a name="l00729"></a>00729 
<a name="l00730"></a>00730 <span class="comment">/* Disassemble instructions in a single section. */</span>
<a name="l00731"></a>00731 <a class="code" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">Disassembler::InstructionMap</a>
<a name="l00732"></a><a class="code" href="classDisassembler.html#eb7f7497f70c88265bb04fabf48bf147">00732</a> <a class="code" href="classDisassembler.html#eb7f7497f70c88265bb04fabf48bf147">Disassembler::disassembleSection</a>(<a class="code" href="classSgAsmGenericSection.html">SgAsmGenericSection</a> *section, <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> section_va, <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> start_offset,
<a name="l00733"></a>00733                                  <a class="code" href="namespaceVirtualBinCFG.html#21495b08e1c020b22a49fbf0c569c3ec">AddressSet</a> *successors, BadMap *bad)
<a name="l00734"></a>00734 {
<a name="l00735"></a>00735     <a class="code" href="classSgAsmGenericFile.html">SgAsmGenericFile</a> *file = section-&gt;<a class="code" href="classSgAsmGenericSection.html#3fd79ae169d298678808d6a07223de9a">get_file</a>();
<a name="l00736"></a>00736     ROSE_ASSERT(file!=NULL);
<a name="l00737"></a>00737     <span class="keyword">const</span> <span class="keywordtype">void</span> *file_buf = &amp;(file-&gt;<a class="code" href="classSgAsmGenericFile.html#366577b3e22f0fc732973afcb1a5bc05">get_data</a>()[0]);
<a name="l00738"></a>00738 
<a name="l00739"></a>00739     <a class="code" href="classMemoryMap_1_1Segment.html">MemoryMap::Segment</a> sgmt(<a class="code" href="classMemoryMap_1_1ExternBuffer.html#84cf5d396b6cca4a0f4289b6f80e7982">MemoryMap::ExternBuffer::create</a>(file_buf, section-&gt;<a class="code" href="classSgAsmGenericSection.html#4c0fa714119712ac19d50340d62ab8f1">get_size</a>()), 0,
<a name="l00740"></a>00740                             <a class="code" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd57589290f94ccb75d2e8b659c4ef50bb700">MemoryMap::MM_PROT_RX</a>, section-&gt;<a class="code" href="classSgAsmGenericSection.html#51a0421548dbe52e9f2dd06a0ba8d4a9">get_name</a>()-&gt;<a class="code" href="classSgAsmGenericString.html#ba8bc51c8d891e4f8e8e87c45c62f7d5">get_string</a>());
<a name="l00741"></a>00741     <a class="code" href="classMemoryMap.html">MemoryMap</a> map;
<a name="l00742"></a>00742     map.insert(<a class="code" href="Cxx__Grammar_8h.html#d8e49820aaa106bb8a2dc17d9ad38d87">Extent</a>(section_va, section-&gt;<a class="code" href="classSgAsmGenericSection.html#4c0fa714119712ac19d50340d62ab8f1">get_size</a>()), sgmt);
<a name="l00743"></a>00743     <span class="keywordflow">return</span> <a class="code" href="classDisassembler.html#529504e76680ce23f076337b276003a9">disassembleBuffer</a>(&amp;map, section_va+start_offset, successors, bad);
<a name="l00744"></a>00744 }
<a name="l00745"></a>00745 
<a name="l00746"></a>00746 <span class="comment">/* Disassemble instructions for an interpretation (set of headers) */</span>
<a name="l00747"></a>00747 <a class="code" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">Disassembler::InstructionMap</a>
<a name="l00748"></a><a class="code" href="classDisassembler.html#d5dcbb23495e19e34dd84d4b2035b2bb">00748</a> <a class="code" href="classDisassembler.html#d5dcbb23495e19e34dd84d4b2035b2bb">Disassembler::disassembleInterp</a>(<a class="code" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *interp, <a class="code" href="namespaceVirtualBinCFG.html#21495b08e1c020b22a49fbf0c569c3ec">AddressSet</a> *successors, BadMap *bad)
<a name="l00749"></a>00749 {
<a name="l00750"></a>00750     <span class="keyword">const</span> <a class="code" href="Cxx__Grammar_8h.html#2b92a9464e206badb3c042fe0456d37e">SgAsmGenericHeaderPtrList</a> &amp;headers = interp-&gt;<a class="code" href="classSgAsmInterpretation.html#5d116938aaa9da9f3e27ca598965c77b">get_headers</a>()-&gt;<a class="code" href="classSgAsmGenericHeaderList.html#c3d9878c64af6c90e2d52988f8578b36">get_headers</a>();
<a name="l00751"></a>00751     <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">AddressSet</a> worklist;
<a name="l00752"></a>00752 
<a name="l00753"></a>00753     <span class="comment">/* Use the memory map attached to the interpretation, or build a new one and attach it. */</span>
<a name="l00754"></a>00754     <a class="code" href="classMemoryMap.html">MemoryMap</a> *map = interp-&gt;<a class="code" href="classSgAsmInterpretation.html#afcc3fea0b7b32d1f46ec2789920caab">get_map</a>();
<a name="l00755"></a>00755     <span class="keywordflow">if</span> (!map) {
<a name="l00756"></a>00756         <span class="keywordflow">if</span> (<a class="code" href="classDisassembler.html#296d72c41fe8ab803feed162ea7dd6e3">p_debug</a>)
<a name="l00757"></a>00757             fprintf(p_debug, <span class="stringliteral">"Disassembler: no memory map; remapping all sections\n"</span>);
<a name="l00758"></a>00758         <a class="code" href="classBinaryLoader.html">BinaryLoader</a> *loader = <a class="code" href="classBinaryLoader.html#89262fe2e395773fe9836c77efd76978">BinaryLoader::lookup</a>(interp);
<a name="l00759"></a>00759         assert(loader);
<a name="l00760"></a>00760         loader = loader-&gt;<a class="code" href="classBinaryLoader.html#063c18d860994aca8906f59205a6b0a0">clone</a>();
<a name="l00761"></a>00761         assert(loader);
<a name="l00762"></a>00762         loader-&gt;<a class="code" href="classBinaryLoader.html#fff0d69b2afefef511a3466e7b2b1509">set_perform_dynamic_linking</a>(<span class="keyword">false</span>);
<a name="l00763"></a>00763         loader-&gt;<a class="code" href="classBinaryLoader.html#968fb512f0bb8336615fb78afdee7a99">set_perform_remap</a>(<span class="keyword">true</span>);
<a name="l00764"></a>00764         loader-&gt;<a class="code" href="classBinaryLoader.html#42e43adbdc47efae909e27bb9feb80f2">set_perform_relocations</a>(<span class="keyword">false</span>);
<a name="l00765"></a>00765         loader-&gt;<a class="code" href="classBinaryLoader.html#4fde9becfe3b388c98271ca1aeb8d941">load</a>(interp);
<a name="l00766"></a>00766         map = interp-&gt;<a class="code" href="classSgAsmInterpretation.html#afcc3fea0b7b32d1f46ec2789920caab">get_map</a>();
<a name="l00767"></a>00767     }
<a name="l00768"></a>00768     ROSE_ASSERT(map);
<a name="l00769"></a>00769     <span class="keywordflow">if</span> (<a class="code" href="classDisassembler.html#296d72c41fe8ab803feed162ea7dd6e3">p_debug</a>) {
<a name="l00770"></a>00770         fprintf(<a class="code" href="classDisassembler.html#296d72c41fe8ab803feed162ea7dd6e3">p_debug</a>, <span class="stringliteral">"Disassembler: MemoryMap for disassembly:\n"</span>);
<a name="l00771"></a>00771         map-&gt;<a class="code" href="classMemoryMap.html#c45b1135441de2185b0b72c858066911">dump</a>(p_debug, <span class="stringliteral">"    "</span>);
<a name="l00772"></a>00772     }
<a name="l00773"></a>00773 
<a name="l00774"></a>00774     <span class="comment">/* Seed disassembly with entry points and function symbols from each header. */</span>
<a name="l00775"></a>00775     <span class="keywordflow">for</span> (size_t i=0; i&lt;headers.size(); i++) {
<a name="l00776"></a>00776         <a class="code" href="Cxx__Grammar_8h.html#58a225317d7a3fabc34e22bda238c740">SgRVAList</a> entry_rvalist = headers[i]-&gt;get_entry_rvas();
<a name="l00777"></a>00777         <span class="keywordflow">for</span> (size_t j=0; j&lt;entry_rvalist.size(); j++) {
<a name="l00778"></a>00778             <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> entry_va = entry_rvalist[j].get_rva() + headers[i]-&gt;get_base_va();
<a name="l00779"></a>00779             worklist.insert(entry_va);
<a name="l00780"></a>00780             <span class="keywordflow">if</span> (<a class="code" href="classDisassembler.html#296d72c41fe8ab803feed162ea7dd6e3">p_debug</a>)
<a name="l00781"></a>00781                 fprintf(<a class="code" href="classDisassembler.html#296d72c41fe8ab803feed162ea7dd6e3">p_debug</a>, <span class="stringliteral">"Disassembler[va 0x%08"</span>PRIx64<span class="stringliteral">"]: entry point\n"</span>, entry_va);
<a name="l00782"></a>00782         }
<a name="l00783"></a>00783         <span class="keywordflow">if</span> (<a class="code" href="classDisassembler.html#15730211163d1de76e77a8673f54465e">p_search</a> &amp; <a class="code" href="classDisassembler.html#bf0472f94be5962208d1944c644337026c0bec3b2d4180faa1ff82478790f010">SEARCH_FUNCSYMS</a>)
<a name="l00784"></a>00784             <a class="code" href="classDisassembler.html#94916adedc686310e3c7e773909ffe62">search_function_symbols</a>(&amp;worklist, map, headers[i]);
<a name="l00785"></a>00785     }
<a name="l00786"></a>00786 
<a name="l00787"></a>00787     <span class="comment">/* Do not require execute permission if the user wants to disassemble everything. */</span>
<a name="l00788"></a>00788     <span class="comment">/* FIXME: Not thread safe! [RPM 2011-01-27] */</span>
<a name="l00789"></a>00789     <span class="keywordtype">unsigned</span> orig_protections = <a class="code" href="classDisassembler.html#2e92614caa7e50a4ea5b02f0f11e49a4">get_protection</a>();
<a name="l00790"></a>00790     <span class="keywordflow">if</span> (<a class="code" href="classDisassembler.html#15730211163d1de76e77a8673f54465e">p_search</a> &amp; <a class="code" href="classDisassembler.html#bf0472f94be5962208d1944c644337028d32f00e4d4baef3f0cf3b4e01534f3b">SEARCH_NONEXE</a>)
<a name="l00791"></a>00791         <a class="code" href="classDisassembler.html#7456766a1fb671713ffbab33a57c3d73">set_protection</a>(orig_protections &amp; ~<a class="code" href="classMemoryMap.html#33a974d3db4ffc22f5ccc7311e4fd575a061dc1ffe578fdaea067d730efb00ac">MemoryMap::MM_PROT_EXEC</a>);
<a name="l00792"></a>00792 
<a name="l00793"></a>00793     <span class="comment">/* Disassemble all that we've mapped, according to aggressiveness settings. */</span>
<a name="l00794"></a>00794     <a class="code" href="classDisassembler.html#737c2be60ae2d7d7b9205fdd0d3017fd">InstructionMap</a> retval;
<a name="l00795"></a>00795     <span class="keywordflow">try</span> {
<a name="l00796"></a>00796         retval = <a class="code" href="classDisassembler.html#529504e76680ce23f076337b276003a9">disassembleBuffer</a>(map, worklist, successors, bad);
<a name="l00797"></a>00797     } <span class="keywordflow">catch</span> (...) {
<a name="l00798"></a>00798         <a class="code" href="classDisassembler.html#7456766a1fb671713ffbab33a57c3d73">set_protection</a>(orig_protections);
<a name="l00799"></a>00799         <span class="keywordflow">throw</span>;
<a name="l00800"></a>00800     }
<a name="l00801"></a>00801 
<a name="l00802"></a>00802 <span class="preprocessor">#if 0</span>
<a name="l00803"></a>00803 <span class="preprocessor"></span>    <span class="comment">/* Mark the parts of the file corresponding to the instructions as having been referenced, since this is part of parsing.</span>
<a name="l00804"></a>00804 <span class="comment">     *</span>
<a name="l00805"></a>00805 <span class="comment">     * NOTE: I turned this off because it's slow if there's a lot of instructions (e.g., about 20s/million instructions on my</span>
<a name="l00806"></a>00806 <span class="comment">     *       machine). If the user really needs to know this information they can probably calculate it using an ExtentMap and</span>
<a name="l00807"></a>00807 <span class="comment">     *       traversing the instructions in the final AST.  Another problem is that since the disassembler runs before the</span>
<a name="l00808"></a>00808 <span class="comment">     *       partitioner, and the partitioner might throw away unused instructions, calculating the references here in the</span>
<a name="l00809"></a>00809 <span class="comment">     *       disassembler is not accurate.  [RPM 2010-04-30]</span>
<a name="l00810"></a>00810 <span class="comment">     *</span>
<a name="l00811"></a>00811 <span class="comment">     * NOTE: Since mark_referenced_instructions() is not thread safe, its inclusion here would cause this method to be not</span>
<a name="l00812"></a>00812 <span class="comment">     *       thread safe also. [RPM 2011-01-27] */</span>
<a name="l00813"></a>00813     <a class="code" href="classDisassembler.html#7fb4bc70f650f0720fc44ab0fc5e77f6">mark_referenced_instructions</a>(interp, map, retval);
<a name="l00814"></a>00814 <span class="preprocessor">#endif</span>
<a name="l00815"></a>00815 <span class="preprocessor"></span>
<a name="l00816"></a>00816     <span class="keywordflow">return</span> retval;
<a name="l00817"></a>00817 }
<a name="l00818"></a>00818         
<a name="l00819"></a>00819 <span class="comment">/* Re-read instruction bytes from file if necessary in order to mark them as referenced. */</span>
<a name="l00820"></a>00820 <span class="keywordtype">void</span>
<a name="l00821"></a><a class="code" href="classDisassembler.html#7fb4bc70f650f0720fc44ab0fc5e77f6">00821</a> <a class="code" href="classDisassembler.html#7fb4bc70f650f0720fc44ab0fc5e77f6">Disassembler::mark_referenced_instructions</a>(<a class="code" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *interp, <span class="keyword">const</span> <a class="code" href="classMemoryMap.html">MemoryMap</a> *map, <span class="keyword">const</span> InstructionMap &amp;insns)
<a name="l00822"></a>00822 {
<a name="l00823"></a>00823     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[32];
<a name="l00824"></a>00824     <a class="code" href="classSgAsmGenericFile.html">SgAsmGenericFile</a> *file = NULL;
<a name="l00825"></a>00825     <span class="keyword">const</span> <a class="code" href="Cxx__Grammar_8h.html#f3d213b43c7dff7dcff4cee56fb39288">SgAsmGenericFilePtrList</a> &amp;files = interp-&gt;<a class="code" href="classSgAsmInterpretation.html#69fcce591fb17fc87ad9b78a542fe257">get_files</a>();
<a name="l00826"></a>00826     <span class="keywordtype">bool</span> was_tracking = <span class="keyword">false</span>; <span class="comment">// only valid when file!=NULL  (value here is to shut of used-before-defined warnings from GCC)</span>
<a name="l00827"></a>00827     <a class="code" href="classRangeMap.html#b5c65ae6400776a38fe42e05b7b411cd">MemoryMap::Segments::const_iterator</a> si = map-&gt;<a class="code" href="classMemoryMap.html#48c9dda77ad1d1335a441aaeef55d98e">segments</a>().end();
<a name="l00828"></a>00828 
<a name="l00829"></a>00829     <span class="comment">/* Re-read each instruction so the file has a chance to track the reference. */</span>
<a name="l00830"></a>00830     <span class="keywordflow">try</span> {
<a name="l00831"></a>00831         <span class="keywordflow">for</span> (InstructionMap::const_iterator ii=insns.begin(); ii!=insns.end(); ++ii) {
<a name="l00832"></a>00832             <a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn = ii-&gt;second;
<a name="l00833"></a>00833             ROSE_ASSERT(insn-&gt;get_size()&lt;=<span class="keyword">sizeof</span> buf);
<a name="l00834"></a>00834             <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> va = insn-&gt;get_address();
<a name="l00835"></a>00835             size_t nbytes = insn-&gt;get_size();
<a name="l00836"></a>00836 
<a name="l00837"></a>00837             <span class="keywordflow">while</span> (nbytes&gt;0) {
<a name="l00838"></a>00838                 <span class="comment">/* Find the memory map segment and the file that goes with that segment (if any) */</span>
<a name="l00839"></a>00839                 <span class="keywordflow">if</span> (si==map-&gt;<a class="code" href="classMemoryMap.html#48c9dda77ad1d1335a441aaeef55d98e">segments</a>().end() || !si-&gt;first.contains(<a class="code" href="Cxx__Grammar_8h.html#d8e49820aaa106bb8a2dc17d9ad38d87">Extent</a>(va))) {
<a name="l00840"></a>00840                     <span class="keywordflow">if</span> (file) {
<a name="l00841"></a>00841                         file-&gt;set_tracking_references(was_tracking);
<a name="l00842"></a>00842                         file = NULL;
<a name="l00843"></a>00843                     }
<a name="l00844"></a>00844                     si = map-&gt;<a class="code" href="classMemoryMap.html#48c9dda77ad1d1335a441aaeef55d98e">segments</a>().find(va);
<a name="l00845"></a>00845                     <span class="keywordflow">if</span> (si==map-&gt;<a class="code" href="classMemoryMap.html#48c9dda77ad1d1335a441aaeef55d98e">segments</a>().end()) {
<a name="l00846"></a>00846                         <span class="comment">/* This byte of the instruction is not mapped. Perhaps the next one is. */</span>
<a name="l00847"></a>00847                         ++va;
<a name="l00848"></a>00848                         --nbytes;
<a name="l00849"></a>00849                         <span class="keywordflow">continue</span>;
<a name="l00850"></a>00850                     }
<a name="l00851"></a>00851 
<a name="l00852"></a>00852                     <span class="comment">/* Find the file that goes with this segment. */</span>
<a name="l00853"></a>00853                     <span class="keywordflow">for</span> (size_t i=0; i&lt;files.size(); i++) {
<a name="l00854"></a>00854                         <span class="keywordflow">if</span> (&amp;(files[i]-&gt;get_data()[0]) == si-&gt;second.get_buffer()-&gt;get_data_ptr()) {
<a name="l00855"></a>00855                             file = files[i];
<a name="l00856"></a>00856                             was_tracking = file-&gt;get_tracking_references();
<a name="l00857"></a>00857                             file-&gt;set_tracking_references(<span class="keyword">true</span>);
<a name="l00858"></a>00858                             <span class="keywordflow">break</span>;
<a name="l00859"></a>00859                         }
<a name="l00860"></a>00860                     }
<a name="l00861"></a>00861 
<a name="l00862"></a>00862                 }
<a name="l00863"></a>00863 
<a name="l00864"></a>00864                 <span class="comment">/* Read the file for its reference tracking side effect. */</span>
<a name="l00865"></a>00865                 size_t sgmt_offset = va - si-&gt;first.first();
<a name="l00866"></a>00866                 size_t n = std::min(nbytes, (size_t)si-&gt;first.size()-sgmt_offset);
<a name="l00867"></a>00867                 <span class="keywordflow">if</span> (file) {
<a name="l00868"></a>00868                     size_t file_offset = si-&gt;second.get_buffer_offset() + sgmt_offset;
<a name="l00869"></a>00869                     file-&gt;read_content(file_offset, buf, n, <span class="keyword">false</span>);
<a name="l00870"></a>00870                 }
<a name="l00871"></a>00871                 nbytes -= n;
<a name="l00872"></a>00872                 va += n;
<a name="l00873"></a>00873             }
<a name="l00874"></a>00874         }
<a name="l00875"></a>00875         <span class="keywordflow">if</span> (file)
<a name="l00876"></a>00876             file-&gt;<a class="code" href="classSgAsmGenericFile.html#726172a6521dd95a9e8f7015eab98d93">set_tracking_references</a>(was_tracking);
<a name="l00877"></a>00877     } <span class="keywordflow">catch</span>(...) {
<a name="l00878"></a>00878         <span class="keywordflow">if</span> (file)
<a name="l00879"></a>00879             file-&gt;<a class="code" href="classSgAsmGenericFile.html#726172a6521dd95a9e8f7015eab98d93">set_tracking_references</a>(was_tracking);
<a name="l00880"></a>00880         <span class="keywordflow">throw</span>;
<a name="l00881"></a>00881     }
<a name="l00882"></a>00882 }
<a name="l00883"></a>00883 
<a name="l00884"></a>00884 <span class="comment">/* Add last instruction's successors to returned successors. */</span>
<a name="l00885"></a>00885 <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a>
<a name="l00886"></a><a class="code" href="classDisassembler.html#6b43093bcbec9db07aa30e34b754051e">00886</a> <a class="code" href="classDisassembler.html#6b43093bcbec9db07aa30e34b754051e">Disassembler::get_block_successors</a>(<span class="keyword">const</span> InstructionMap&amp; insns, <span class="keywordtype">bool</span> *complete)
<a name="l00887"></a>00887 {
<a name="l00888"></a>00888     std::vector&lt;SgAsmInstruction*&gt; block;
<a name="l00889"></a>00889     <span class="keywordflow">for</span> (InstructionMap::const_iterator ii=insns.begin(); ii!=insns.end(); ++ii)
<a name="l00890"></a>00890         block.push_back(ii-&gt;second);
<a name="l00891"></a>00891     <a class="code" href="classDisassembler.html#7d930e04b0d619cb057ff0e5a559534b">Disassembler::AddressSet</a> successors = block.front()-&gt;get_successors(block, complete);
<a name="l00892"></a>00892 
<a name="l00893"></a>00893     <span class="comment">/* For the purposes of disassembly, assume that a CALL instruction eventually executes a RET that causes execution to</span>
<a name="l00894"></a>00894 <span class="comment">     * resume at the address following the CALL. This is true 99% of the time.  Higher software layers (e.g., Partitioner) may</span>
<a name="l00895"></a>00895 <span class="comment">     * make other assumptions, which is why this code is not in SgAsmx86Instruction::get_successors(). [RPM 2010-05-09] */</span>
<a name="l00896"></a>00896     <a class="code" href="rosedefs_8h.html#03b4aab6bc70ede394422915678b18df">rose_addr_t</a> target;
<a name="l00897"></a>00897     <a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *last_insn = block.back();
<a name="l00898"></a>00898     <span class="keywordflow">if</span> (last_insn-&gt;<a class="code" href="classSgAsmInstruction.html#b11a9d7f8905f899b62a892716a301a2">is_function_call</a>(block, &amp;target))
<a name="l00899"></a>00899         successors.insert(last_insn-&gt;<a class="code" href="classSgAsmStatement.html#9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>() + last_insn-&gt;<a class="code" href="classSgAsmInstruction.html#6adcc4eb7c725185baa3a2425a57843c">get_size</a>());
<a name="l00900"></a>00900 
<a name="l00901"></a>00901     <span class="keywordflow">return</span> successors;
<a name="l00902"></a>00902 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
