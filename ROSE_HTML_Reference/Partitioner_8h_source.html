<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ROSE: Partitioner.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ROSE
   &#160;<span id="projectnumber">0.9.5a</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('Partitioner_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Partitioner.h</div>  </div>
</div>
<div class="contents">
<a href="Partitioner_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef ROSE_DISASSEMBLER_PARTITIONER_H</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define ROSE_DISASSEMBLER_PARTITIONER_H</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &quot;<a class="code" href="callbacks_8h.html">callbacks.h</a>&quot;</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &quot;<a class="code" href="Disassembler_8h.html">Disassembler.h</a>&quot;</span>
<a name="l00006"></a>00006 
<a name="l00111"></a><a class="code" href="classPartitioner.html">00111</a> <span class="keyword">class </span><a class="code" href="classPartitioner.html" title="Partitions instructions into basic blocks and functions.">Partitioner</a> {
<a name="l00112"></a>00112     <span class="comment">/*************************************************************************************************************************</span>
<a name="l00113"></a>00113 <span class="comment">     *                                        Public Exceptions</span>
<a name="l00114"></a>00114 <span class="comment">     *************************************************************************************************************************/</span>
<a name="l00115"></a>00115 <span class="keyword">public</span>:
<a name="l00116"></a><a class="code" href="structPartitioner_1_1Exception.html">00116</a>     <span class="keyword">struct </span><a class="code" href="structPartitioner_1_1Exception.html">Exception</a> {
<a name="l00117"></a><a class="code" href="structPartitioner_1_1Exception.html#a04394b7419f91ce0f393122abea33df8">00117</a>         std::string <a class="code" href="structPartitioner_1_1Exception.html#a04394b7419f91ce0f393122abea33df8">mesg</a>;
<a name="l00118"></a><a class="code" href="structPartitioner_1_1Exception.html#ae938e562c80566bc037368d8e611fbe2">00118</a>         <a class="code" href="structPartitioner_1_1Exception.html#ae938e562c80566bc037368d8e611fbe2">Exception</a>(<span class="keyword">const</span> std::string &amp;<a class="code" href="structPartitioner_1_1Exception.html#a04394b7419f91ce0f393122abea33df8">mesg</a>): mesg(mesg) {}
<a name="l00119"></a><a class="code" href="structPartitioner_1_1Exception.html#a3f942618d4619383b4d199f27df68510">00119</a>         <span class="keywordtype">void</span> <a class="code" href="structPartitioner_1_1Exception.html#a3f942618d4619383b4d199f27df68510">print</a>(std::ostream &amp;o)<span class="keyword"> const </span>{ o &lt;&lt;<a class="code" href="structPartitioner_1_1Exception.html#a04394b7419f91ce0f393122abea33df8">mesg</a>; }
<a name="l00120"></a>00120         <span class="keyword">friend</span> std::ostream&amp; <a class="code" href="structPartitioner_1_1Exception.html#a3a99c7cd470628c0af113622ae26a6a1">operator&lt;&lt;</a>(std::ostream &amp;o, <span class="keyword">const</span> <a class="code" href="structPartitioner_1_1Exception.html">Exception</a> &amp;e);
<a name="l00121"></a>00121     };
<a name="l00122"></a>00122 
<a name="l00123"></a>00123     <span class="comment">/*************************************************************************************************************************</span>
<a name="l00124"></a>00124 <span class="comment">     *                                        Data Structures Useful to Subclasses</span>
<a name="l00125"></a>00125 <span class="comment">     *************************************************************************************************************************/</span>
<a name="l00126"></a>00126 <span class="keyword">protected</span>:
<a name="l00127"></a>00127 
<a name="l00128"></a>00128     <span class="keyword">struct </span>Function;
<a name="l00129"></a>00129     <span class="keyword">struct </span>DataBlock;
<a name="l00130"></a>00130     <span class="keyword">struct </span>BasicBlock;
<a name="l00131"></a>00131 
<a name="l00135"></a><a class="code" href="classPartitioner_1_1Instruction.html">00135</a>     <span class="keyword">class </span><a class="code" href="classPartitioner_1_1Instruction.html" title="Holds an instruction along with some other information about the instruction.">Instruction</a> {
<a name="l00136"></a>00136     <span class="keyword">public</span>:
<a name="l00137"></a><a class="code" href="classPartitioner_1_1Instruction.html#aef19ad1d65f95cd2cd1b702e712c8052">00137</a>         <a class="code" href="classPartitioner_1_1Instruction.html#aef19ad1d65f95cd2cd1b702e712c8052">Instruction</a>(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *<a class="code" href="classPartitioner_1_1Instruction.html#a4b229dbd56516c2f986029271ea77b1a" title="The underlying instruction node for an AST.">node</a>): node(node), <a class="code" href="classPartitioner_1_1Instruction.html#a4ca5b571a28bd3a9fb719baec4b99777" title="Block to which this instruction belongs, if any.">bblock</a>(NULL) { assert(node!=NULL); }
<a name="l00138"></a><a class="code" href="classPartitioner_1_1Instruction.html#a4b229dbd56516c2f986029271ea77b1a">00138</a>         <a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *<a class="code" href="classPartitioner_1_1Instruction.html#a4b229dbd56516c2f986029271ea77b1a" title="The underlying instruction node for an AST.">node</a>;                 
<a name="l00139"></a><a class="code" href="classPartitioner_1_1Instruction.html#a4ca5b571a28bd3a9fb719baec4b99777">00139</a>         <a class="code" href="structPartitioner_1_1BasicBlock.html" title="Represents a basic block within the Partitioner.">BasicBlock</a> *<a class="code" href="classPartitioner_1_1Instruction.html#a4ca5b571a28bd3a9fb719baec4b99777" title="Block to which this instruction belongs, if any.">bblock</a>;                     
<a name="l00141"></a>00141         <span class="comment">/* These methods are forwarded to the underlying instruction node for convenience. */</span>
<a name="l00142"></a><a class="code" href="classPartitioner_1_1Instruction.html#a53841c5001628a1cdbedeb3a90eebcd0">00142</a>         <a class="code" href="classDisassembler.html#a7d930e04b0d619cb057ff0e5a559534b" title="An AddressSet contains virtual addresses (alternatively, relative virtual addresses) for such things ...">Disassembler::AddressSet</a> <a class="code" href="classPartitioner_1_1Instruction.html#a53841c5001628a1cdbedeb3a90eebcd0">get_successors</a>(<span class="keywordtype">bool</span> *complete)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classPartitioner_1_1Instruction.html#a4b229dbd56516c2f986029271ea77b1a" title="The underlying instruction node for an AST.">node</a>-&gt;<a class="code" href="classSgAsmInstruction.html#af6899182698893142221e72f0f88ac0e">get_successors</a>(complete); }
<a name="l00143"></a><a class="code" href="classPartitioner_1_1Instruction.html#aa9c8dd5cf80780b59c4e74e4bb8b2811">00143</a>         <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> <a class="code" href="classPartitioner_1_1Instruction.html#aa9c8dd5cf80780b59c4e74e4bb8b2811">get_address</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classPartitioner_1_1Instruction.html#a4b229dbd56516c2f986029271ea77b1a" title="The underlying instruction node for an AST.">node</a>-&gt;<a class="code" href="classSgAsmStatement.html#a9d16f5ff82380f8b9c4071afe9f094a5">get_address</a>(); }
<a name="l00144"></a><a class="code" href="classPartitioner_1_1Instruction.html#a46940b414c39f0fd10186868d40715f7">00144</a>         <span class="keywordtype">size_t</span> <a class="code" href="classPartitioner_1_1Instruction.html#a46940b414c39f0fd10186868d40715f7">get_size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classPartitioner_1_1Instruction.html#a4b229dbd56516c2f986029271ea77b1a" title="The underlying instruction node for an AST.">node</a>-&gt;<a class="code" href="classSgAsmInstruction.html#a6adcc4eb7c725185baa3a2425a57843c">get_size</a>(); }
<a name="l00145"></a><a class="code" href="classPartitioner_1_1Instruction.html#a024965895dbe27a542b72c4900595120">00145</a>         <span class="keywordtype">bool</span> <a class="code" href="classPartitioner_1_1Instruction.html#a024965895dbe27a542b72c4900595120">terminatesBasicBlock</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classPartitioner_1_1Instruction.html#a4b229dbd56516c2f986029271ea77b1a" title="The underlying instruction node for an AST.">node</a>-&gt;<a class="code" href="classSgAsmInstruction.html#af359a9ca1bec7b95cbbf5fa7537136b1">terminatesBasicBlock</a>(); }
<a name="l00146"></a><a class="code" href="classPartitioner_1_1Instruction.html#acafbaec42b52828d4f51e5b579728782">00146</a>         <a class="code" href="Cxx__Grammar_8h.html#a4f57773a5fc8d0d005f7553cd47cbc4e">SgUnsignedCharList</a> <a class="code" href="classPartitioner_1_1Instruction.html#acafbaec42b52828d4f51e5b579728782">get_raw_bytes</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classPartitioner_1_1Instruction.html#a4b229dbd56516c2f986029271ea77b1a" title="The underlying instruction node for an AST.">node</a>-&gt;<a class="code" href="classSgAsmInstruction.html#ac239f0d80ab88127b2543fb0990803c3">get_raw_bytes</a>(); } <span class="comment">// FIXME: should return const ref?</span>
<a name="l00147"></a>00147     };
<a name="l00148"></a>00148 
<a name="l00149"></a><a class="code" href="classPartitioner.html#acff82cb76be01d1207e5653e6ef2c5c0">00149</a>     <span class="keyword">typedef</span> std::map&lt;rose_addr_t, Instruction*&gt; <a class="code" href="classPartitioner.html#acff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a>;
<a name="l00150"></a><a class="code" href="classPartitioner.html#a8a540a6d610b0b6746bdb3900842fec7">00150</a>     <span class="keyword">typedef</span> std::vector&lt;Instruction*&gt; <a class="code" href="classPartitioner.html#a8a540a6d610b0b6746bdb3900842fec7">InstructionVector</a>;
<a name="l00151"></a>00151 
<a name="l00159"></a>00159     <span class="keyword">static</span> <a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *<a class="code" href="classPartitioner.html#a9c2b4ede732f01bb1ce72270e0ee68da" title="Augments dynamic casts defined from ROSETTA.">isSgAsmInstruction</a>(<span class="keyword">const</span> <a class="code" href="classPartitioner_1_1Instruction.html" title="Holds an instruction along with some other information about the instruction.">Instruction</a> *);
<a name="l00160"></a>00160     <span class="keyword">static</span> <a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *<a class="code" href="classPartitioner.html#a9c2b4ede732f01bb1ce72270e0ee68da" title="Augments dynamic casts defined from ROSETTA.">isSgAsmInstruction</a>(<a class="code" href="classSgNode.html" title="This class represents the base class for all IR nodes within Sage III.">SgNode</a>*);
<a name="l00161"></a>00161     <span class="keyword">static</span> <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *<a class="code" href="classPartitioner.html#a8ca4106dccc0db0f0a69bc84efd48474" title="Augments dynamic casts defined from ROSETTA.">isSgAsmx86Instruction</a>(<span class="keyword">const</span> <a class="code" href="classPartitioner_1_1Instruction.html" title="Holds an instruction along with some other information about the instruction.">Instruction</a>*);
<a name="l00162"></a>00162     <span class="keyword">static</span> <a class="code" href="classSgAsmx86Instruction.html">SgAsmx86Instruction</a> *<a class="code" href="classPartitioner.html#a8ca4106dccc0db0f0a69bc84efd48474" title="Augments dynamic casts defined from ROSETTA.">isSgAsmx86Instruction</a>(<a class="code" href="classSgNode.html" title="This class represents the base class for all IR nodes within Sage III.">SgNode</a>*);
<a name="l00169"></a><a class="code" href="classPartitioner_1_1BlockAnalysisCache.html">00169</a>     <span class="keyword">class </span><a class="code" href="classPartitioner_1_1BlockAnalysisCache.html" title="Analysis that can be cached in a block.">BlockAnalysisCache</a> {
<a name="l00170"></a>00170     <span class="keyword">public</span>:
<a name="l00171"></a><a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#a00fe8d849bba06152b80369f12837751">00171</a>         <a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#a00fe8d849bba06152b80369f12837751">BlockAnalysisCache</a>(): <a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#a3a6a83a79cf25bc4d8cb45a678812632" title="Non zero implies locally computed successors are cached.">age</a>(0), <a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#af313f383147607c7dfb9f8ba84481c1c" title="True if locally computed successors are fully known.">sucs_complete</a>(false), <a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#abd097a4c305a32171e17b9052089982d" title="True if this block ends with a CALL-like instruction.">is_function_call</a>(false), <a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#a4dc50b42608304f08524efc3c1952531" title="Target of a CALL instruction if this block ends with what appears to be a function call (whether...">call_target</a>(<a class="code" href="classPartitioner.html#a7e4a76ae7ab4113b2ec7acf9093c3810">NO_TARGET</a>),
<a name="l00172"></a>00172                               <a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#a26b33ba9fb4b4fd4317f202e49c7fbf7" title="Does this block serve as the return of a function? For example, does it end with an x86 RET instructi...">function_return</a>(false), <a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#af467853c71f06381965defc324078562" title="If non-zero, then this block is an alias for the specified block.">alias_for</a>(0) {}
<a name="l00173"></a><a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#a63d950f1d5ce84cf7a948e4de9611b42">00173</a>         <span class="keywordtype">void</span> <a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#a63d950f1d5ce84cf7a948e4de9611b42">clear</a>() {
<a name="l00174"></a>00174             <a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#a3a6a83a79cf25bc4d8cb45a678812632" title="Non zero implies locally computed successors are cached.">age</a> = 0;
<a name="l00175"></a>00175             <a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#a5d6d186d12ba71d10851ef6133350243" title="Locally computed cached successors.">sucs</a>.clear();
<a name="l00176"></a>00176             <a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#af313f383147607c7dfb9f8ba84481c1c" title="True if locally computed successors are fully known.">sucs_complete</a> = <span class="keyword">false</span>;
<a name="l00177"></a>00177             <a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#abd097a4c305a32171e17b9052089982d" title="True if this block ends with a CALL-like instruction.">is_function_call</a> = <span class="keyword">false</span>;
<a name="l00178"></a>00178             <a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#a4dc50b42608304f08524efc3c1952531" title="Target of a CALL instruction if this block ends with what appears to be a function call (whether...">call_target</a> = <a class="code" href="classPartitioner.html#a7e4a76ae7ab4113b2ec7acf9093c3810">NO_TARGET</a>;
<a name="l00179"></a>00179             <a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#a26b33ba9fb4b4fd4317f202e49c7fbf7" title="Does this block serve as the return of a function? For example, does it end with an x86 RET instructi...">function_return</a> = <span class="keyword">false</span>;
<a name="l00180"></a>00180             <a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#af467853c71f06381965defc324078562" title="If non-zero, then this block is an alias for the specified block.">alias_for</a> = 0;
<a name="l00181"></a>00181         }
<a name="l00182"></a>00182 
<a name="l00183"></a><a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#a3a6a83a79cf25bc4d8cb45a678812632">00183</a>         <span class="keywordtype">size_t</span> <a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#a3a6a83a79cf25bc4d8cb45a678812632" title="Non zero implies locally computed successors are cached.">age</a>;                             
<a name="l00188"></a><a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#a5d6d186d12ba71d10851ef6133350243">00188</a>         <a class="code" href="classDisassembler.html#a7d930e04b0d619cb057ff0e5a559534b" title="An AddressSet contains virtual addresses (alternatively, relative virtual addresses) for such things ...">Disassembler::AddressSet</a> <a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#a5d6d186d12ba71d10851ef6133350243" title="Locally computed cached successors.">sucs</a>;          
<a name="l00189"></a><a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#af313f383147607c7dfb9f8ba84481c1c">00189</a>         <span class="keywordtype">bool</span> <a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#af313f383147607c7dfb9f8ba84481c1c" title="True if locally computed successors are fully known.">sucs_complete</a>;                     
<a name="l00190"></a><a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#abd097a4c305a32171e17b9052089982d">00190</a>         <span class="keywordtype">bool</span> <a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#abd097a4c305a32171e17b9052089982d" title="True if this block ends with a CALL-like instruction.">is_function_call</a>;                  
<a name="l00191"></a><a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#a4dc50b42608304f08524efc3c1952531">00191</a>         <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> <a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#a4dc50b42608304f08524efc3c1952531" title="Target of a CALL instruction if this block ends with what appears to be a function call (whether...">call_target</a>;                
<a name="l00196"></a><a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#a26b33ba9fb4b4fd4317f202e49c7fbf7">00196</a>         <span class="keywordtype">bool</span> <a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#a26b33ba9fb4b4fd4317f202e49c7fbf7" title="Does this block serve as the return of a function? For example, does it end with an x86 RET instructi...">function_return</a>;                   
<a name="l00199"></a><a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#af467853c71f06381965defc324078562">00199</a>         <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> <a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#af467853c71f06381965defc324078562" title="If non-zero, then this block is an alias for the specified block.">alias_for</a>;                  
<a name="l00202"></a>00202     };
<a name="l00203"></a>00203 
<a name="l00210"></a><a class="code" href="structPartitioner_1_1BasicBlock.html">00210</a>     <span class="keyword">struct </span><a class="code" href="structPartitioner_1_1BasicBlock.html" title="Represents a basic block within the Partitioner.">BasicBlock</a> {
<a name="l00213"></a><a class="code" href="structPartitioner_1_1BasicBlock.html#a6b7dcb9b8e0905622210e261caf79960">00213</a>         <a class="code" href="structPartitioner_1_1BasicBlock.html#a6b7dcb9b8e0905622210e261caf79960" title="Constructor.">BasicBlock</a>(): <a class="code" href="structPartitioner_1_1BasicBlock.html#a601ae03fbe778f2497dea0e5a3493cf9" title="Reasons this block was created; SgAsmBlock::Reason bit flags.">reason</a>(<a class="code" href="classSgAsmBlock.html">SgAsmBlock</a>::BLK_NONE), <a class="code" href="structPartitioner_1_1BasicBlock.html#aaa4f8d6ea142164591d7c86c1cf18718" title="Function to which this basic block is assigned, or null.">function</a>(NULL) {}
<a name="l00214"></a>00214 
<a name="l00217"></a><a class="code" href="structPartitioner_1_1BasicBlock.html#ab31cdb738cbbd2ac1c6523275eb04ae0">00217</a>         <a class="code" href="structPartitioner_1_1BasicBlock.html#ab31cdb738cbbd2ac1c6523275eb04ae0" title="Destructor.">~BasicBlock</a>() {}
<a name="l00218"></a>00218 
<a name="l00220"></a><a class="code" href="structPartitioner_1_1BasicBlock.html#a2cafe44b1ada952aee62894fabe14006">00220</a>         <span class="keywordtype">bool</span> <a class="code" href="structPartitioner_1_1BasicBlock.html#a2cafe44b1ada952aee62894fabe14006" title="Returns true if the block analysis cache is up to date.">valid_cache</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="structPartitioner_1_1BasicBlock.html#aa72f8961ccc40c25a9643634b35cd3cd" title="Cached results of local analyses.">cache</a>.<a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#a3a6a83a79cf25bc4d8cb45a678812632" title="Non zero implies locally computed successors are cached.">age</a>==<a class="code" href="structPartitioner_1_1BasicBlock.html#a2101ed1bd314a6279a3f07c04d5e0a2e" title="Non-empty set of instructions composing this basic block, in address order.">insns</a>.size(); }
<a name="l00221"></a>00221 
<a name="l00223"></a><a class="code" href="structPartitioner_1_1BasicBlock.html#a1fe68d3efbcfc9b761d9fac124aa8fdf">00223</a>         <span class="keywordtype">void</span> <a class="code" href="structPartitioner_1_1BasicBlock.html#a1fe68d3efbcfc9b761d9fac124aa8fdf" title="Marks the block analysis cache as being outdated.">invalidate_cache</a>() { <a class="code" href="structPartitioner_1_1BasicBlock.html#aa72f8961ccc40c25a9643634b35cd3cd" title="Cached results of local analyses.">cache</a>.<a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#a3a6a83a79cf25bc4d8cb45a678812632" title="Non zero implies locally computed successors are cached.">age</a>=0; }
<a name="l00224"></a>00224 
<a name="l00226"></a><a class="code" href="structPartitioner_1_1BasicBlock.html#af0030dfa1c05b84df2e7b095ae0a19a3">00226</a>         <span class="keywordtype">void</span> <a class="code" href="structPartitioner_1_1BasicBlock.html#af0030dfa1c05b84df2e7b095ae0a19a3" title="Marks the block analysis cache as being up to date.">validate_cache</a>() { <a class="code" href="structPartitioner_1_1BasicBlock.html#aa72f8961ccc40c25a9643634b35cd3cd" title="Cached results of local analyses.">cache</a>.<a class="code" href="classPartitioner_1_1BlockAnalysisCache.html#a3a6a83a79cf25bc4d8cb45a678812632" title="Non zero implies locally computed successors are cached.">age</a>=<a class="code" href="structPartitioner_1_1BasicBlock.html#a2101ed1bd314a6279a3f07c04d5e0a2e" title="Non-empty set of instructions composing this basic block, in address order.">insns</a>.size(); }
<a name="l00227"></a>00227 
<a name="l00230"></a>00230         <span class="keywordtype">void</span> <a class="code" href="structPartitioner_1_1BasicBlock.html#a23febe57dd258c7426a39980c2f1b511" title="Remove all data blocks from this basic block.">clear_data_blocks</a>();
<a name="l00231"></a>00231 
<a name="l00232"></a>00232         <a class="code" href="classPartitioner_1_1Instruction.html" title="Holds an instruction along with some other information about the instruction.">Instruction</a>* <a class="code" href="structPartitioner_1_1BasicBlock.html#a1ad984a08e9fb6cc311b0a2dc7951e49" title="Returns the last executed (exit) instruction of the block.">last_insn</a>() <span class="keyword">const</span>;         
<a name="l00233"></a>00233         <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> <a class="code" href="structPartitioner_1_1BasicBlock.html#a7e120c89ba03d66a308381c0b82173c9" title="Returns the first address of a basic block.">address</a>() <span class="keyword">const</span>;            <span class="comment">/* Return the address of the basic block&#39;s first (entry) instruction. */</span>
<a name="l00234"></a><a class="code" href="structPartitioner_1_1BasicBlock.html#a601ae03fbe778f2497dea0e5a3493cf9">00234</a>         <span class="keywordtype">unsigned</span> <a class="code" href="structPartitioner_1_1BasicBlock.html#a601ae03fbe778f2497dea0e5a3493cf9" title="Reasons this block was created; SgAsmBlock::Reason bit flags.">reason</a>;                        
<a name="l00235"></a><a class="code" href="structPartitioner_1_1BasicBlock.html#a2101ed1bd314a6279a3f07c04d5e0a2e">00235</a>         std::vector&lt;Instruction*&gt; <a class="code" href="structPartitioner_1_1BasicBlock.html#a2101ed1bd314a6279a3f07c04d5e0a2e" title="Non-empty set of instructions composing this basic block, in address order.">insns</a>;        
<a name="l00236"></a><a class="code" href="structPartitioner_1_1BasicBlock.html#a78c634ed49a131d7c2e6e302f78d0e55">00236</a>         std::set&lt;DataBlock*&gt; <a class="code" href="structPartitioner_1_1BasicBlock.html#a78c634ed49a131d7c2e6e302f78d0e55" title="Data blocks owned by this basic block.">data_blocks</a>;       
<a name="l00237"></a><a class="code" href="structPartitioner_1_1BasicBlock.html#aa72f8961ccc40c25a9643634b35cd3cd">00237</a>         <a class="code" href="classPartitioner_1_1BlockAnalysisCache.html" title="Analysis that can be cached in a block.">BlockAnalysisCache</a> <a class="code" href="structPartitioner_1_1BasicBlock.html#aa72f8961ccc40c25a9643634b35cd3cd" title="Cached results of local analyses.">cache</a>;               
<a name="l00238"></a><a class="code" href="structPartitioner_1_1BasicBlock.html#aaa4f8d6ea142164591d7c86c1cf18718">00238</a>         <a class="code" href="structPartitioner_1_1Function.html" title="Represents a function within the Partitioner.">Function</a>* <span class="keyword">function</span>;                     
<a name="l00239"></a>00239     };
<a name="l00240"></a><a class="code" href="classPartitioner.html#aa3a62d239fd07ca47ffc37dd21b74006">00240</a>     <span class="keyword">typedef</span> std::map&lt;rose_addr_t, BasicBlock*&gt; <a class="code" href="classPartitioner.html#aa3a62d239fd07ca47ffc37dd21b74006">BasicBlocks</a>;
<a name="l00241"></a>00241 
<a name="l00254"></a><a class="code" href="structPartitioner_1_1DataBlock.html">00254</a>     <span class="keyword">struct </span><a class="code" href="structPartitioner_1_1DataBlock.html" title="Represents a region of static data within the address space being disassembled.">DataBlock</a> {
<a name="l00258"></a><a class="code" href="structPartitioner_1_1DataBlock.html#a547c72943e0529dfb6fe916bd01ecf73">00258</a>         <a class="code" href="structPartitioner_1_1DataBlock.html#a547c72943e0529dfb6fe916bd01ecf73" title="Constructor.">DataBlock</a>(): <a class="code" href="structPartitioner_1_1DataBlock.html#a024f1606c04323776f0958542e451ac2" title="Reasons this block was created; SgAsmBlock::Reason bit flags.">reason</a>(<a class="code" href="classSgAsmBlock.html">SgAsmBlock</a>::BLK_NONE), <a class="code" href="structPartitioner_1_1DataBlock.html#aef1d5b36cc38db48693a00b9de89ec1b" title="Function to which this data block is explicitly assigned, or null.">function</a>(NULL), <a class="code" href="structPartitioner_1_1DataBlock.html#a00e9f5268dbd139a8f076452fde6efa2" title="Basic block to which this data block is bound, or null.">basic_block</a>(NULL) {}
<a name="l00259"></a>00259 
<a name="l00262"></a><a class="code" href="structPartitioner_1_1DataBlock.html#aab7236912849c4d6417a131e37b346c8">00262</a>         <a class="code" href="structPartitioner_1_1DataBlock.html#aab7236912849c4d6417a131e37b346c8" title="Destructor.">~DataBlock</a>() {}
<a name="l00263"></a>00263 
<a name="l00264"></a>00264         <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> <a class="code" href="structPartitioner_1_1DataBlock.html#a30602458b400eee36e9c7b1298797250" title="Returns the first address of a data block.">address</a>() <span class="keyword">const</span>;            <span class="comment">/* Return the address of the first node of a data block. */</span>
<a name="l00265"></a><a class="code" href="structPartitioner_1_1DataBlock.html#afdc2bd13ec3bc86896eebb7ac65fcd08">00265</a>         std::vector&lt;SgAsmStaticData*&gt; <a class="code" href="structPartitioner_1_1DataBlock.html#afdc2bd13ec3bc86896eebb7ac65fcd08" title="The static data nodes belonging to this block; not deleted.">nodes</a>;    
<a name="l00266"></a><a class="code" href="structPartitioner_1_1DataBlock.html#a024f1606c04323776f0958542e451ac2">00266</a>         <span class="keywordtype">unsigned</span> <a class="code" href="structPartitioner_1_1DataBlock.html#a024f1606c04323776f0958542e451ac2" title="Reasons this block was created; SgAsmBlock::Reason bit flags.">reason</a>;                        
<a name="l00267"></a><a class="code" href="structPartitioner_1_1DataBlock.html#aef1d5b36cc38db48693a00b9de89ec1b">00267</a>         <a class="code" href="structPartitioner_1_1Function.html" title="Represents a function within the Partitioner.">Function</a> *<span class="keyword">function</span>;                     
<a name="l00268"></a><a class="code" href="structPartitioner_1_1DataBlock.html#a00e9f5268dbd139a8f076452fde6efa2">00268</a>         <a class="code" href="structPartitioner_1_1BasicBlock.html" title="Represents a basic block within the Partitioner.">BasicBlock</a> *<a class="code" href="structPartitioner_1_1DataBlock.html#a00e9f5268dbd139a8f076452fde6efa2" title="Basic block to which this data block is bound, or null.">basic_block</a>;                
<a name="l00269"></a>00269     };
<a name="l00270"></a><a class="code" href="classPartitioner.html#ac9034b33e56a9e1d2e95dcd9c97cf431">00270</a>     <span class="keyword">typedef</span> std::map&lt;rose_addr_t, DataBlock*&gt; <a class="code" href="classPartitioner.html#ac9034b33e56a9e1d2e95dcd9c97cf431">DataBlocks</a>;
<a name="l00271"></a>00271 
<a name="l00273"></a><a class="code" href="structPartitioner_1_1Function.html">00273</a>     <span class="keyword">struct </span><a class="code" href="structPartitioner_1_1Function.html" title="Represents a function within the Partitioner.">Function</a> {
<a name="l00274"></a><a class="code" href="structPartitioner_1_1Function.html#a4409c7fd10f322e94f8b2e132f99d3a4">00274</a>         <a class="code" href="structPartitioner_1_1Function.html#a4409c7fd10f322e94f8b2e132f99d3a4">Function</a>(<a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> <a class="code" href="structPartitioner_1_1Function.html#af9e0fcf754bb14416253d5b873f25cd1" title="Entry virtual address.">entry_va</a>): <a class="code" href="structPartitioner_1_1Function.html#a84232118f03482d3eb09c76063ef73ef" title="SgAsmFunction::FunctionReason bit flags.">reason</a>(0), <a class="code" href="structPartitioner_1_1Function.html#ad433af52820775a021eeae99f8e31ff2" title="True if we need to (re)discover the basic blocks.">pending</a>(true), entry_va(entry_va), <a class="code" href="structPartitioner_1_1Function.html#aee43ad14b7958628361c22efc3343565" title="Is it possible for this function to return?">may_return</a>(false) {}
<a name="l00275"></a><a class="code" href="structPartitioner_1_1Function.html#a2d52982c81f09eb5643bd6f3d9ce43cf">00275</a>         <a class="code" href="structPartitioner_1_1Function.html#a2d52982c81f09eb5643bd6f3d9ce43cf">Function</a>(<a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> <a class="code" href="structPartitioner_1_1Function.html#af9e0fcf754bb14416253d5b873f25cd1" title="Entry virtual address.">entry_va</a>, <span class="keywordtype">unsigned</span> r): <a class="code" href="structPartitioner_1_1Function.html#a84232118f03482d3eb09c76063ef73ef" title="SgAsmFunction::FunctionReason bit flags.">reason</a>(r), <a class="code" href="structPartitioner_1_1Function.html#ad433af52820775a021eeae99f8e31ff2" title="True if we need to (re)discover the basic blocks.">pending</a>(true), entry_va(entry_va), <a class="code" href="structPartitioner_1_1Function.html#aee43ad14b7958628361c22efc3343565" title="Is it possible for this function to return?">may_return</a>(false) {}
<a name="l00276"></a><a class="code" href="structPartitioner_1_1Function.html#a8d98801b07a6adcd766e2acc83aaa20e">00276</a>         <a class="code" href="structPartitioner_1_1Function.html#a4409c7fd10f322e94f8b2e132f99d3a4">Function</a>(<a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> <a class="code" href="structPartitioner_1_1Function.html#af9e0fcf754bb14416253d5b873f25cd1" title="Entry virtual address.">entry_va</a>, <span class="keywordtype">unsigned</span> r, <span class="keyword">const</span> std::string&amp; <a class="code" href="structPartitioner_1_1Function.html#a3445a927f772aa09859896fa5681eb62" title="Name of function if known.">name</a>)
<a name="l00277"></a>00277             : <a class="code" href="structPartitioner_1_1Function.html#a84232118f03482d3eb09c76063ef73ef" title="SgAsmFunction::FunctionReason bit flags.">reason</a>(r), name(name), <a class="code" href="structPartitioner_1_1Function.html#ad433af52820775a021eeae99f8e31ff2" title="True if we need to (re)discover the basic blocks.">pending</a>(true), entry_va(entry_va), <a class="code" href="structPartitioner_1_1Function.html#aee43ad14b7958628361c22efc3343565" title="Is it possible for this function to return?">may_return</a>(false) {}
<a name="l00278"></a>00278         <span class="keywordtype">void</span> <a class="code" href="structPartitioner_1_1Function.html#aebb899dee2d38549d338e2ed9a11c63b" title="Remove all basic blocks from this function w/out deleting the blocks.">clear_basic_blocks</a>();              
<a name="l00279"></a>00279         <span class="keywordtype">void</span> <a class="code" href="structPartitioner_1_1Function.html#a49652421fa901651e9f1269369e2990c" title="Remove all data blocks from this function w/out deleting the blocks.">clear_data_blocks</a>();               
<a name="l00280"></a><a class="code" href="structPartitioner_1_1Function.html#a84232118f03482d3eb09c76063ef73ef">00280</a>         <span class="keywordtype">unsigned</span> <a class="code" href="structPartitioner_1_1Function.html#a84232118f03482d3eb09c76063ef73ef" title="SgAsmFunction::FunctionReason bit flags.">reason</a>;                        
<a name="l00281"></a><a class="code" href="structPartitioner_1_1Function.html#a3445a927f772aa09859896fa5681eb62">00281</a>         std::string <a class="code" href="structPartitioner_1_1Function.html#a3445a927f772aa09859896fa5681eb62" title="Name of function if known.">name</a>;                       
<a name="l00282"></a><a class="code" href="structPartitioner_1_1Function.html#a8bdb95ca10afda44f8dacb28248f5c6c">00282</a>         <a class="code" href="classPartitioner.html#aa3a62d239fd07ca47ffc37dd21b74006">BasicBlocks</a> <a class="code" href="structPartitioner_1_1Function.html#a8bdb95ca10afda44f8dacb28248f5c6c" title="Basic blocks belonging to this function.">basic_blocks</a>;               
<a name="l00283"></a><a class="code" href="structPartitioner_1_1Function.html#aa4ec341f0aa8ef699a36dda8389036d8">00283</a>         <a class="code" href="classPartitioner.html#ac9034b33e56a9e1d2e95dcd9c97cf431">DataBlocks</a> <a class="code" href="structPartitioner_1_1Function.html#aa4ec341f0aa8ef699a36dda8389036d8" title="Data blocks belonging to this function.">data_blocks</a>;                 
<a name="l00284"></a><a class="code" href="structPartitioner_1_1Function.html#ad433af52820775a021eeae99f8e31ff2">00284</a>         <span class="keywordtype">bool</span> <a class="code" href="structPartitioner_1_1Function.html#ad433af52820775a021eeae99f8e31ff2" title="True if we need to (re)discover the basic blocks.">pending</a>;                           
<a name="l00285"></a><a class="code" href="structPartitioner_1_1Function.html#af9e0fcf754bb14416253d5b873f25cd1">00285</a>         <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> <a class="code" href="structPartitioner_1_1Function.html#af9e0fcf754bb14416253d5b873f25cd1" title="Entry virtual address.">entry_va</a>;                   
<a name="l00286"></a><a class="code" href="structPartitioner_1_1Function.html#a41ac95e38f7681fd66736276a833f931">00286</a>         <a class="code" href="classDisassembler.html#a7d930e04b0d619cb057ff0e5a559534b" title="An AddressSet contains virtual addresses (alternatively, relative virtual addresses) for such things ...">Disassembler::AddressSet</a> <a class="code" href="structPartitioner_1_1Function.html#a41ac95e38f7681fd66736276a833f931" title="CFG heads, excluding func entry: addresses of additional blocks.">heads</a>;         
<a name="l00287"></a><a class="code" href="structPartitioner_1_1Function.html#aee43ad14b7958628361c22efc3343565">00287</a>         <span class="keywordtype">bool</span> <a class="code" href="structPartitioner_1_1Function.html#aee43ad14b7958628361c22efc3343565" title="Is it possible for this function to return?">may_return</a>;                        
<a name="l00288"></a>00288         <span class="comment">/* If you add more here, also update split_attached_thunks() */</span>
<a name="l00289"></a>00289     };
<a name="l00290"></a><a class="code" href="classPartitioner.html#ad68aee879b03b498c5d988d7fdfd6ae8">00290</a>     <span class="keyword">typedef</span> std::map&lt;rose_addr_t, Function*&gt; <a class="code" href="classPartitioner.html#ad68aee879b03b498c5d988d7fdfd6ae8">Functions</a>;
<a name="l00291"></a>00291 
<a name="l00293"></a><a class="code" href="classPartitioner.html#a98a5bc735d38ef38b979cec8174a2241">00293</a>     <span class="keyword">typedef</span> void (*<a class="code" href="classPartitioner.html#a98a5bc735d38ef38b979cec8174a2241" title="Data type for user-defined function detectors.">FunctionDetector</a>)(<a class="code" href="classPartitioner.html" title="Partitions instructions into basic blocks and functions.">Partitioner</a>*, <a class="code" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a>*);
<a name="l00294"></a>00294 
<a name="l00296"></a><a class="code" href="structPartitioner_1_1BlockConfig.html">00296</a>     <span class="keyword">struct </span><a class="code" href="structPartitioner_1_1BlockConfig.html" title="Basic block configuration information.">BlockConfig</a> {
<a name="l00297"></a><a class="code" href="structPartitioner_1_1BlockConfig.html#ab70bb0887a9c3b666ac0cb87b908def1">00297</a>         <a class="code" href="structPartitioner_1_1BlockConfig.html#ab70bb0887a9c3b666ac0cb87b908def1">BlockConfig</a>(): <a class="code" href="structPartitioner_1_1BlockConfig.html#a964a8afda248870c616c6b8488564478" title="Number of instructions expected in the basic block.">ninsns</a>(0), <a class="code" href="structPartitioner_1_1BlockConfig.html#adb6c2a594ea4bc06a82a2ab144d1e7ed" title="If non-zero then this block is an alias for another block.">alias_for</a>(0), <a class="code" href="structPartitioner_1_1BlockConfig.html#a8eb755c9516b0bb2c3bc0866b52095fb" title="True if IPD file specifies successors for this block.">sucs_specified</a>(false), <a class="code" href="structPartitioner_1_1BlockConfig.html#a74ec8ed7b70d759f68ff978e11549f50" title="True if successors are fully known.">sucs_complete</a>(false) {}
<a name="l00298"></a><a class="code" href="structPartitioner_1_1BlockConfig.html#a964a8afda248870c616c6b8488564478">00298</a>         <span class="keywordtype">size_t</span> <a class="code" href="structPartitioner_1_1BlockConfig.html#a964a8afda248870c616c6b8488564478" title="Number of instructions expected in the basic block.">ninsns</a>;                          
<a name="l00299"></a><a class="code" href="structPartitioner_1_1BlockConfig.html#adb6c2a594ea4bc06a82a2ab144d1e7ed">00299</a>         <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> <a class="code" href="structPartitioner_1_1BlockConfig.html#adb6c2a594ea4bc06a82a2ab144d1e7ed" title="If non-zero then this block is an alias for another block.">alias_for</a>;                  
<a name="l00300"></a><a class="code" href="structPartitioner_1_1BlockConfig.html#a8eb755c9516b0bb2c3bc0866b52095fb">00300</a>         <span class="keywordtype">bool</span> <a class="code" href="structPartitioner_1_1BlockConfig.html#a8eb755c9516b0bb2c3bc0866b52095fb" title="True if IPD file specifies successors for this block.">sucs_specified</a>;                    
<a name="l00301"></a><a class="code" href="structPartitioner_1_1BlockConfig.html#aa23dc5dbbe1e7dabeb5a979c22da8fe0">00301</a>         <a class="code" href="classDisassembler.html#a7d930e04b0d619cb057ff0e5a559534b" title="An AddressSet contains virtual addresses (alternatively, relative virtual addresses) for such things ...">Disassembler::AddressSet</a> <a class="code" href="structPartitioner_1_1BlockConfig.html#aa23dc5dbbe1e7dabeb5a979c22da8fe0" title="Address to which this block might branch or fall through.">sucs</a>;          
<a name="l00302"></a><a class="code" href="structPartitioner_1_1BlockConfig.html#a74ec8ed7b70d759f68ff978e11549f50">00302</a>         <span class="keywordtype">bool</span> <a class="code" href="structPartitioner_1_1BlockConfig.html#a74ec8ed7b70d759f68ff978e11549f50" title="True if successors are fully known.">sucs_complete</a>;                     
<a name="l00303"></a><a class="code" href="structPartitioner_1_1BlockConfig.html#ac315b8048fb9e4d7526ee621c3a4336d">00303</a>         <a class="code" href="Cxx__Grammar_8h.html#a4f57773a5fc8d0d005f7553cd47cbc4e">SgUnsignedCharList</a> <a class="code" href="structPartitioner_1_1BlockConfig.html#ac315b8048fb9e4d7526ee621c3a4336d" title="i386 code to simulate to find successors.">sucs_program</a>;        
<a name="l00304"></a>00304     };
<a name="l00305"></a><a class="code" href="classPartitioner.html#af15dc59805f5188b3a9a91f2a9906ca3">00305</a>     <span class="keyword">typedef</span> std::map&lt;rose_addr_t, BlockConfig*&gt; <a class="code" href="classPartitioner.html#af15dc59805f5188b3a9a91f2a9906ca3">BlockConfigMap</a>;
<a name="l00306"></a>00306 
<a name="l00307"></a>00307     <span class="comment">/*************************************************************************************************************************</span>
<a name="l00308"></a>00308 <span class="comment">     *                                                     Deprecated</span>
<a name="l00309"></a>00309 <span class="comment">     *************************************************************************************************************************/</span>
<a name="l00310"></a>00310 <span class="keyword">public</span>:
<a name="l00311"></a>00311 
<a name="l00312"></a>00312     <span class="comment">/* FIXME: Backward compatibility stuff prior to 2010-01-01. These are deprecated and should eventually be removed. They</span>
<a name="l00313"></a>00313 <span class="comment">     *        are currently used by src/midend/binaryAnalyses/binary_analysis.C for some of the CFG and call graph functions. */</span>
<a name="l00314"></a>00314 
<a name="l00321"></a><a class="code" href="classPartitioner.html#a9a75d765cbfecc297f7d47063095a3c5">00321</a>     <span class="keyword">typedef</span> std::map&lt;rose_addr_t, Disassembler::AddressSet&gt; <a class="code" href="classPartitioner.html#a9a75d765cbfecc297f7d47063095a3c5" title="Map of basic block starting addresses.">BasicBlockStarts</a>;
<a name="l00322"></a>00322 
<a name="l00326"></a>00326     <a class="code" href="classPartitioner.html#a9a75d765cbfecc297f7d47063095a3c5" title="Map of basic block starting addresses.">BasicBlockStarts</a> <a class="code" href="classPartitioner.html#a4812db8f83f8858ae85b382cc3a6acdc" title="Find the beginnings of basic blocks based on instruction type and call targets.">detectBasicBlocks</a>(<span class="keyword">const</span> <a class="code" href="classDisassembler.html#a737c2be60ae2d7d7b9205fdd0d3017fd" title="The InstructionMap is a mapping from (absolute) virtual address to disassembled instruction.">Disassembler::InstructionMap</a>&amp;) const __attribute__((deprecated));
<a name="l00327"></a>00327 
<a name="l00332"></a><a class="code" href="structPartitioner_1_1FunctionStart.html">00332</a>     struct <a class="code" href="structPartitioner_1_1FunctionStart.html" title="Information about each function starting address.">FunctionStart</a> {
<a name="l00333"></a><a class="code" href="structPartitioner_1_1FunctionStart.html#ab7cca5ef54c313ca751f4d14901c2e48">00333</a>         <a class="code" href="structPartitioner_1_1FunctionStart.html#ab7cca5ef54c313ca751f4d14901c2e48">FunctionStart</a>(<span class="keywordtype">unsigned</span> reason, std::string <a class="code" href="Cxx__Grammar_8h.html#aaf1bd07e95aeff0f585394fccaf479ab">name</a>): reason(reason), name(name) {}
<a name="l00334"></a><a class="code" href="structPartitioner_1_1FunctionStart.html#a30908c944e9800b08c2d93e05fd66b65">00334</a>         <span class="keywordtype">unsigned</span> <a class="code" href="structPartitioner_1_1FunctionStart.html#a30908c944e9800b08c2d93e05fd66b65">reason</a>;                        
<a name="l00335"></a><a class="code" href="structPartitioner_1_1FunctionStart.html#a443540e71201c52887de597c57a84aef">00335</a>         std::string <a class="code" href="structPartitioner_1_1FunctionStart.html#a443540e71201c52887de597c57a84aef" title="SgAsmFunction::FunctionReason bit flags.">name</a>;                       
<a name="l00336"></a>00336     };
<a name="l00337"></a>00337 
<a name="l00342"></a><a class="code" href="classPartitioner.html#ab8bf5254df78bd41a374776dc956c0b0">00342</a>     <span class="keyword">typedef</span> std::map&lt;rose_addr_t, FunctionStart&gt; <a class="code" href="classPartitioner.html#ab8bf5254df78bd41a374776dc956c0b0" title="Map describing the starting address of each known function.">FunctionStarts</a>;
<a name="l00343"></a>00343 
<a name="l00347"></a>00347     <a class="code" href="classPartitioner.html#ab8bf5254df78bd41a374776dc956c0b0" title="Map describing the starting address of each known function.">FunctionStarts</a> <a class="code" href="classPartitioner.html#a2661469599426a48867a62e649c3585b" title="Returns a list of the currently defined functions.">detectFunctions</a>(<a class="code" href="classSgAsmInterpretation.html">SgAsmInterpretation</a>*, <span class="keyword">const</span> <a class="code" href="classDisassembler.html#a737c2be60ae2d7d7b9205fdd0d3017fd" title="The InstructionMap is a mapping from (absolute) virtual address to disassembled instruction.">Disassembler::InstructionMap</a> &amp;<a class="code" href="classPartitioner.html#af9d5d92a9d9ca6a35ade7c5b3906ab97" title="Instruction cache, filled in by user or populated by disassembler.">insns</a>,
<a name="l00348"></a>00348                                    <a class="code" href="classPartitioner.html#a9a75d765cbfecc297f7d47063095a3c5" title="Map of basic block starting addresses.">BasicBlockStarts</a> &amp;bb_starts<span class="comment">/*out*/</span>) <span class="keyword">const</span> __attribute__((deprecated));
<a name="l00349"></a>00349 
<a name="l00350"></a>00350 
<a name="l00351"></a>00351     <span class="comment">/*************************************************************************************************************************</span>
<a name="l00352"></a>00352 <span class="comment">     *                                                 Constructors, etc.</span>
<a name="l00353"></a>00353 <span class="comment">     *************************************************************************************************************************/</span>
<a name="l00354"></a>00354 <span class="keyword">public</span>:
<a name="l00355"></a>00355 
<a name="l00356"></a><a class="code" href="classPartitioner.html#ab3788db43d9594c28b201255991e85c2">00356</a>     <a class="code" href="classPartitioner.html#ab3788db43d9594c28b201255991e85c2">Partitioner</a>()
<a name="l00357"></a>00357         : <a class="code" href="classPartitioner.html#a320e02804f0d9ae5bc55e1ba26791a72" title="Optional disassembler to call when an instruction is needed.">disassembler</a>(NULL), <a class="code" href="classPartitioner.html#aa8aa1ec02714f0608e72147f2dee7ffc" title="Memory map used for disassembly if disassembler is present.">map</a>(NULL), <a class="code" href="classPartitioner.html#a61a820e23e3d57c012d0928aa9c4d1a2" title="Bit mask of SgAsmFunction::FunctionReason bits.">func_heuristics</a>(<a class="code" href="classSgAsmFunction.html">SgAsmFunction</a>::FUNC_DEFAULT), <a class="code" href="classPartitioner.html#a7ea39de5e72216dbece1d9f3b9c79f8f" title="Stream where diagnistics are sent (or null).">debug</a>(NULL),
<a name="l00358"></a>00358           <a class="code" href="classPartitioner.html#aa89d8e06b1a855108422287a46b63b04" title="Allow basic blocks to be discontiguous in virtual memory.">allow_discont_blocks</a>(true)
<a name="l00359"></a>00359         {}
<a name="l00360"></a><a class="code" href="classPartitioner.html#a8adefe825a9988129017f650bac676d4">00360</a>     <span class="keyword">virtual</span> <a class="code" href="classPartitioner.html#a8adefe825a9988129017f650bac676d4">~Partitioner</a>() { <a class="code" href="classPartitioner.html#ad64a57bb09ffe9557d1ad51f2ca30bf8" title="Reset partitioner to initial conditions by discarding all instructions, basic blocks, functions, and configuration file settings and definitions.">clear</a>(); }
<a name="l00361"></a>00361 
<a name="l00362"></a>00362     <span class="comment">/*************************************************************************************************************************</span>
<a name="l00363"></a>00363 <span class="comment">     *                                              Accessors for Properties</span>
<a name="l00364"></a>00364 <span class="comment">     *************************************************************************************************************************/</span>
<a name="l00365"></a>00365 <span class="keyword">public</span>:
<a name="l00366"></a>00366 
<a name="l00370"></a><a class="code" href="classPartitioner.html#ae52ab7e0fa20592ae95f858404b3234b">00370</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#ae52ab7e0fa20592ae95f858404b3234b" title="Sets the set of heuristics used by the partitioner.">set_search</a>(<span class="keywordtype">unsigned</span> heuristics) {
<a name="l00371"></a>00371         <a class="code" href="classPartitioner.html#a61a820e23e3d57c012d0928aa9c4d1a2" title="Bit mask of SgAsmFunction::FunctionReason bits.">func_heuristics</a> = heuristics;
<a name="l00372"></a>00372     }
<a name="l00373"></a>00373 
<a name="l00376"></a><a class="code" href="classPartitioner.html#a27dadf58c669d89a6ddb3993075ade12">00376</a>     <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <a class="code" href="classPartitioner.html#a27dadf58c669d89a6ddb3993075ade12" title="Returns a bit mask of SgAsmFunction::FunctionReason bits indicating which heuristics would be used by...">get_search</a>()<span class="keyword"> const </span>{
<a name="l00377"></a>00377         <span class="keywordflow">return</span> <a class="code" href="classPartitioner.html#a61a820e23e3d57c012d0928aa9c4d1a2" title="Bit mask of SgAsmFunction::FunctionReason bits.">func_heuristics</a>;
<a name="l00378"></a>00378     }
<a name="l00379"></a>00379 
<a name="l00409"></a><a class="code" href="classPartitioner.html#a07ab675418fbe36332333be50b0b78b8">00409</a>     <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a07ab675418fbe36332333be50b0b78b8" title="Turns on/off the allowing of discontiguous basic blocks.">set_allow_discontiguous_blocks</a>(<span class="keywordtype">bool</span> b) {
<a name="l00410"></a>00410         <a class="code" href="classPartitioner.html#aa89d8e06b1a855108422287a46b63b04" title="Allow basic blocks to be discontiguous in virtual memory.">allow_discont_blocks</a> = b;
<a name="l00411"></a>00411     }
<a name="l00412"></a>00412 
<a name="l00414"></a><a class="code" href="classPartitioner.html#a7b2621f78594a4269ddf84ac5b038705">00414</a>     <span class="keywordtype">bool</span> <a class="code" href="classPartitioner.html#a7b2621f78594a4269ddf84ac5b038705" title="Returns an indication of whether discontiguous blocks are allowed.">get_allow_discontiguous_blocks</a>()<span class="keyword"> const </span>{
<a name="l00415"></a>00415         <span class="keywordflow">return</span> <a class="code" href="classPartitioner.html#aa89d8e06b1a855108422287a46b63b04" title="Allow basic blocks to be discontiguous in virtual memory.">allow_discont_blocks</a>;
<a name="l00416"></a>00416     }
<a name="l00417"></a>00417 
<a name="l00419"></a><a class="code" href="classPartitioner.html#a3779f2493e75745eb5a0d8abf8317316">00419</a>     <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a3779f2493e75745eb5a0d8abf8317316" title="Sends diagnostics to the specified output stream.">set_debug</a>(FILE *f) {
<a name="l00420"></a>00420         <a class="code" href="classPartitioner.html#a7ea39de5e72216dbece1d9f3b9c79f8f" title="Stream where diagnistics are sent (or null).">debug</a> = f;
<a name="l00421"></a>00421     }
<a name="l00422"></a>00422 
<a name="l00424"></a><a class="code" href="classPartitioner.html#a878a062caa7908af34df84d4bedae71e">00424</a>     FILE *<a class="code" href="classPartitioner.html#a878a062caa7908af34df84d4bedae71e" title="Returns the file currently used for debugging; null implies no debugging.">get_debug</a>()<span class="keyword"> const </span>{
<a name="l00425"></a>00425         <span class="keywordflow">return</span> <a class="code" href="classPartitioner.html#a7ea39de5e72216dbece1d9f3b9c79f8f" title="Stream where diagnistics are sent (or null).">debug</a>;
<a name="l00426"></a>00426     }
<a name="l00427"></a>00427 
<a name="l00444"></a>00444     <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a3c46fdd567c72ad245ab7e2e6351a9d8" title="Accessors for the memory maps.">set_map</a>(<a class="code" href="classMemoryMap.html" title="A MemoryMap is an efficient mapping from virtual addresses to source bytes.">MemoryMap</a> *mmap, <a class="code" href="classMemoryMap.html" title="A MemoryMap is an efficient mapping from virtual addresses to source bytes.">MemoryMap</a> *ro_mmap=NULL);
<a name="l00445"></a><a class="code" href="classPartitioner.html#a697de2be7e07894883304357a546438b">00445</a>     <a class="code" href="classMemoryMap.html" title="A MemoryMap is an efficient mapping from virtual addresses to source bytes.">MemoryMap</a> *<a class="code" href="classPartitioner.html#a697de2be7e07894883304357a546438b" title="Accessors for the memory maps.">get_map</a>()<span class="keyword"> const </span>{
<a name="l00446"></a>00446         <span class="keywordflow">return</span> <a class="code" href="classPartitioner.html#aa8aa1ec02714f0608e72147f2dee7ffc" title="Memory map used for disassembly if disassembler is present.">map</a>;
<a name="l00447"></a>00447     }
<a name="l00453"></a>00453     <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a072171925925389189b7206fd5897f3d" title="Set progress reporting properties.">set_progress_reporting</a>(FILE*, <span class="keywordtype">unsigned</span> min_interval);
<a name="l00454"></a>00454 
<a name="l00455"></a>00455     <span class="comment">/*************************************************************************************************************************</span>
<a name="l00456"></a>00456 <span class="comment">     *                                                High-level Functions</span>
<a name="l00457"></a>00457 <span class="comment">     *************************************************************************************************************************/</span>
<a name="l00458"></a>00458 <span class="keyword">public</span>:
<a name="l00459"></a>00459 
<a name="l00466"></a><a class="code" href="classPartitioner.html#afc4d3b064e80e0124eda08827c9cfa07">00466</a>     <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#afc4d3b064e80e0124eda08827c9cfa07" title="Adds a user-defined function detector to this partitioner.">add_function_detector</a>(<a class="code" href="classPartitioner.html#a98a5bc735d38ef38b979cec8174a2241" title="Data type for user-defined function detectors.">FunctionDetector</a> f) {
<a name="l00467"></a>00467         <a class="code" href="classPartitioner.html#ae8ccefb002c5a4bea6abc98c226d19d6" title="List of user-defined function detection methods.">user_detectors</a>.push_back(f);
<a name="l00468"></a>00468     }
<a name="l00469"></a>00469     
<a name="l00478"></a>00478     <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <a class="code" href="classPartitioner.html#a63758ffe8d586886ebfcdb2f69c7d107" title="Parses a string describing the heuristics and returns the bit vector that can be passed to set_search...">parse_switches</a>(<span class="keyword">const</span> std::string&amp;, <span class="keywordtype">unsigned</span> initial_flags);
<a name="l00479"></a>00479 
<a name="l00484"></a>00484     <span class="keyword">virtual</span> <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a>* <a class="code" href="classPartitioner.html#ad8d4292001cbf0490676f8bc148c1a24" title="Top-level function to run the partitioner on some instructions and build an AST.">partition</a>(<a class="code" href="classSgAsmInterpretation.html">SgAsmInterpretation</a>*, <span class="keyword">const</span> <a class="code" href="classDisassembler.html#a737c2be60ae2d7d7b9205fdd0d3017fd" title="The InstructionMap is a mapping from (absolute) virtual address to disassembled instruction.">Disassembler::InstructionMap</a>&amp;, <a class="code" href="classMemoryMap.html" title="A MemoryMap is an efficient mapping from virtual addresses to source bytes.">MemoryMap</a> *mmap=NULL);
<a name="l00485"></a>00485 
<a name="l00487"></a>00487     <span class="keyword">virtual</span> <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a>* <a class="code" href="classPartitioner.html#ad8d4292001cbf0490676f8bc148c1a24" title="Top-level function to run the partitioner on some instructions and build an AST.">partition</a>(<a class="code" href="classSgAsmInterpretation.html">SgAsmInterpretation</a>*, <a class="code" href="classDisassembler.html" title="Virtual base class for instruction disassemblers.">Disassembler</a>*, <a class="code" href="classMemoryMap.html" title="A MemoryMap is an efficient mapping from virtual addresses to source bytes.">MemoryMap</a>*);
<a name="l00488"></a>00488 
<a name="l00491"></a>00491     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#ad64a57bb09ffe9557d1ad51f2ca30bf8" title="Reset partitioner to initial conditions by discarding all instructions, basic blocks, functions, and configuration file settings and definitions.">clear</a>();
<a name="l00492"></a>00492 
<a name="l00495"></a>00495     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a7adb0e1cb0359b14d928ad1d7ffd0a03" title="Loads the specified configuration file.">load_config</a>(<span class="keyword">const</span> std::string &amp;filename);
<a name="l00496"></a>00496 
<a name="l00499"></a>00499     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a33a895f0f8724262d24404a67be98a2f" title="Adds additional instructions to be processed.">add_instructions</a>(<span class="keyword">const</span> <a class="code" href="classDisassembler.html#a737c2be60ae2d7d7b9205fdd0d3017fd" title="The InstructionMap is a mapping from (absolute) virtual address to disassembled instruction.">Disassembler::InstructionMap</a>&amp; <a class="code" href="classPartitioner.html#af9d5d92a9d9ca6a35ade7c5b3906ab97" title="Instruction cache, filled in by user or populated by disassembler.">insns</a>);
<a name="l00500"></a>00500 
<a name="l00503"></a>00503     <a class="code" href="classDisassembler.html#a737c2be60ae2d7d7b9205fdd0d3017fd" title="The InstructionMap is a mapping from (absolute) virtual address to disassembled instruction.">Disassembler::InstructionMap</a> <a class="code" href="classPartitioner.html#a45a9d059b28d95033aa343fd4689ac0e" title="Get the list of all instructions.">get_instructions</a>() <span class="keyword">const</span>;
<a name="l00504"></a>00504 
<a name="l00507"></a><a class="code" href="classPartitioner.html#a72f6b3bb0baf5d2978b27174626ad1b4">00507</a>     <span class="keyword">const</span> <a class="code" href="classDisassembler.html#a30c51578d70dfc05fb46047867ceadcd" title="The BadMap is a mapping from (absolute) virtual address to information about a failed disassembly att...">Disassembler::BadMap</a>&amp; <a class="code" href="classPartitioner.html#a72f6b3bb0baf5d2978b27174626ad1b4" title="Get the list of disassembler errors.">get_disassembler_errors</a>()<span class="keyword"> const </span>{
<a name="l00508"></a>00508         <span class="keywordflow">return</span> <a class="code" href="classPartitioner.html#a44a78932a6c3307dbdd9d9327bbb3eba" title="Captured disassembler exceptions.">bad_insns</a>;
<a name="l00509"></a>00509     }
<a name="l00510"></a>00510 
<a name="l00515"></a><a class="code" href="classPartitioner.html#af993c26936e910eedaa5b433a74e70b3">00515</a>     <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#af993c26936e910eedaa5b433a74e70b3" title="Clears errors from the disassembler.">clear_disassembler_errors</a>() {
<a name="l00516"></a>00516         <a class="code" href="classPartitioner.html#a44a78932a6c3307dbdd9d9327bbb3eba" title="Captured disassembler exceptions.">bad_insns</a>.clear();
<a name="l00517"></a>00517     }
<a name="l00518"></a>00518 
<a name="l00523"></a>00523     <span class="keyword">virtual</span> Instruction* <a class="code" href="classPartitioner.html#a1dcdd3e0993256cd5ed93fd4d178679f" title="Finds an instruction at the specified address.">find_instruction</a>(<a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a>, <span class="keywordtype">bool</span> create=<span class="keyword">true</span>);
<a name="l00524"></a>00524 
<a name="l00531"></a>00531     <span class="keyword">virtual</span> Instruction* <a class="code" href="classPartitioner.html#a8b679c9a4b6fb7a7f4f45900d10819c0" title="Drop an instruction from consideration.">discard</a>(Instruction*, <span class="keywordtype">bool</span> discard_entire_block=<span class="keyword">false</span>);
<a name="l00532"></a>00532 
<a name="l00536"></a>00536     <span class="keyword">virtual</span> BasicBlock *<a class="code" href="classPartitioner.html#a8b679c9a4b6fb7a7f4f45900d10819c0" title="Drop an instruction from consideration.">discard</a>(BasicBlock*);
<a name="l00537"></a>00537 
<a name="l00541"></a>00541     <span class="keyword">virtual</span> Function* <a class="code" href="classPartitioner.html#a91e9b8ad59e4657d6f3dbece95752a4e" title="Adds a new function definition to the partitioner.">add_function</a>(<a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> entry_va, <span class="keywordtype">unsigned</span> reasons, std::string <a class="code" href="Cxx__Grammar_8h.html#aaf1bd07e95aeff0f585394fccaf479ab">name</a>=<span class="stringliteral">&quot;&quot;</span>);
<a name="l00542"></a>00542 
<a name="l00544"></a>00544     <span class="keyword">virtual</span> Function* <a class="code" href="classPartitioner.html#ae9238319a8257ac90435cce78d96dc9d" title="Looks up a function by address.">find_function</a>(<a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> entry_va);
<a name="l00545"></a>00545 
<a name="l00552"></a>00552     <span class="keyword">virtual</span> <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a>* <a class="code" href="classPartitioner.html#a4018aada4c16434ec0895c86e65bc5ec" title="Builds the AST describing all the functions.">build_ast</a>();
<a name="l00553"></a>00553 
<a name="l00557"></a>00557     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a05f33c889b526d67506ed26631965580" title="Update SgAsmTarget block pointers.">update_targets</a>(<a class="code" href="classSgNode.html" title="This class represents the base class for all IR nodes within Sage III.">SgNode</a> *ast);
<a name="l00558"></a>00558 
<a name="l00559"></a>00559     <span class="comment">/**************************************************************************************************************************</span>
<a name="l00560"></a>00560 <span class="comment">     *                                  Range maps relating address ranges to objects</span>
<a name="l00561"></a>00561 <span class="comment">     **************************************************************************************************************************/</span>
<a name="l00562"></a>00562 <span class="keyword">public</span>:
<a name="l00564"></a><a class="code" href="classPartitioner_1_1FunctionRangeMapValue.html">00564</a>     <span class="keyword">class </span><a class="code" href="classPartitioner_1_1FunctionRangeMapValue.html" title="Value type for FunctionRangeMap.">FunctionRangeMapValue</a>: <span class="keyword">public</span> <a class="code" href="classRangeMapValue.html" title="Scalar value type for a RangeMap.">RangeMapValue</a>&lt;Extent, Function*&gt; {
<a name="l00565"></a>00565     <span class="keyword">public</span>:
<a name="l00566"></a><a class="code" href="classPartitioner_1_1FunctionRangeMapValue.html#aac038b00f78c625730c155bd8a33239f">00566</a>         <a class="code" href="classPartitioner_1_1FunctionRangeMapValue.html#aac038b00f78c625730c155bd8a33239f">FunctionRangeMapValue</a>():            <a class="code" href="classRangeMapValue.html" title="Scalar value type for a RangeMap.">RangeMapValue</a>&lt;<a class="code" href="classRange.html">Extent</a>, <a class="code" href="structPartitioner_1_1Function.html" title="Represents a function within the Partitioner.">Function</a>*&gt;(NULL) {}
<a name="l00567"></a><a class="code" href="classPartitioner_1_1FunctionRangeMapValue.html#a908a065e4baa5ede7d0171f90af390eb">00567</a>         <a class="code" href="classPartitioner_1_1FunctionRangeMapValue.html#a908a065e4baa5ede7d0171f90af390eb">FunctionRangeMapValue</a>(<a class="code" href="structPartitioner_1_1Function.html" title="Represents a function within the Partitioner.">Function</a> *f): <a class="code" href="classRangeMapValue.html" title="Scalar value type for a RangeMap.">RangeMapValue</a>&lt;<a class="code" href="classRange.html">Extent</a>, <a class="code" href="structPartitioner_1_1Function.html" title="Represents a function within the Partitioner.">Function</a>*&gt;(f)    {} <span class="comment">// implicit</span>
<a name="l00568"></a>00568 
<a name="l00569"></a><a class="code" href="classPartitioner_1_1FunctionRangeMapValue.html#a99ee899b05475fe1c8f73a326a6898f1">00569</a>         <a class="code" href="classPartitioner_1_1FunctionRangeMapValue.html" title="Value type for FunctionRangeMap.">FunctionRangeMapValue</a> <a class="code" href="classPartitioner_1_1FunctionRangeMapValue.html#a99ee899b05475fe1c8f73a326a6898f1">split</a>(<span class="keyword">const</span> <a class="code" href="classRange.html">Extent</a> &amp;my_range, <span class="keyword">const</span> <a class="code" href="classRange.html#a0110e09e84e56cb5b63bc5bde2a2a241">Extent::Value</a> &amp;new_end) {
<a name="l00570"></a>00570             assert(my_range.<a class="code" href="classRange.html#a7bfc28d2d8efb645ffc65dd563f3964f" title="Does this range contain the argument range?">contains</a>(<a class="code" href="classRange.html">Extent</a>(new_end)));
<a name="l00571"></a>00571             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00572"></a>00572         }
<a name="l00573"></a>00573 
<a name="l00574"></a><a class="code" href="classPartitioner_1_1FunctionRangeMapValue.html#aa4794559a5b6c62d5897801b75616d74">00574</a>         <span class="keywordtype">void</span> <a class="code" href="classPartitioner_1_1FunctionRangeMapValue.html#aa4794559a5b6c62d5897801b75616d74" title="Print a RangeMap value.">print</a>(std::ostream &amp;o)<span class="keyword"> const </span>{
<a name="l00575"></a>00575             <span class="keywordflow">if</span> (NULL==<a class="code" href="classRangeMapValue.html#a16c06d37653cc336bd87de06909e7298">value</a>) {
<a name="l00576"></a>00576                 o &lt;&lt;<span class="stringliteral">&quot;(null)&quot;</span>;
<a name="l00577"></a>00577             } <span class="keywordflow">else</span> {
<a name="l00578"></a>00578                 o &lt;&lt;<span class="stringliteral">&quot;F&quot;</span> &lt;&lt;<a class="code" href="namespaceStringUtility.html#a3df35e2d0c2f48226c623ad418240402" title="Convert an address to a string, preferring a hexadecimal representation with at least 8 digits...">StringUtility::addrToString</a>(<a class="code" href="classRangeMapValue.html#a16c06d37653cc336bd87de06909e7298">value</a>-&gt;entry_va);
<a name="l00579"></a>00579             }
<a name="l00580"></a>00580         }
<a name="l00581"></a>00581     };
<a name="l00582"></a>00582 
<a name="l00584"></a><a class="code" href="classPartitioner.html#afa61b430928023cd27ec0227c5a45f4f">00584</a>     <span class="keyword">typedef</span> <a class="code" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap&lt;Extent, FunctionRangeMapValue&gt;</a> <a class="code" href="classPartitioner.html#afa61b430928023cd27ec0227c5a45f4f" title="Range map associating addresses with functions.">FunctionRangeMap</a>;
<a name="l00585"></a>00585 
<a name="l00587"></a><a class="code" href="classPartitioner_1_1DataRangeMapValue.html">00587</a>     <span class="keyword">class </span><a class="code" href="classPartitioner_1_1DataRangeMapValue.html" title="Value type for DataRangeMap.">DataRangeMapValue</a>: <span class="keyword">public</span> <a class="code" href="classRangeMapValue.html" title="Scalar value type for a RangeMap.">RangeMapValue</a>&lt;Extent, DataBlock*&gt; {
<a name="l00588"></a>00588     <span class="keyword">public</span>:
<a name="l00589"></a><a class="code" href="classPartitioner_1_1DataRangeMapValue.html#a220222fca81df3e395d1537fb25856cc">00589</a>         <a class="code" href="classPartitioner_1_1DataRangeMapValue.html#a220222fca81df3e395d1537fb25856cc">DataRangeMapValue</a>():             <a class="code" href="classRangeMapValue.html" title="Scalar value type for a RangeMap.">RangeMapValue</a>&lt;<a class="code" href="classRange.html">Extent</a>, <a class="code" href="structPartitioner_1_1DataBlock.html" title="Represents a region of static data within the address space being disassembled.">DataBlock</a>*&gt;(NULL) {}
<a name="l00590"></a><a class="code" href="classPartitioner_1_1DataRangeMapValue.html#afc594fbdd8a49a0ad0e9905e6eb730f8">00590</a>         <a class="code" href="classPartitioner_1_1DataRangeMapValue.html#afc594fbdd8a49a0ad0e9905e6eb730f8">DataRangeMapValue</a>(<a class="code" href="structPartitioner_1_1DataBlock.html" title="Represents a region of static data within the address space being disassembled.">DataBlock</a> *d): <a class="code" href="classRangeMapValue.html" title="Scalar value type for a RangeMap.">RangeMapValue</a>&lt;<a class="code" href="classRange.html">Extent</a>, <a class="code" href="structPartitioner_1_1DataBlock.html" title="Represents a region of static data within the address space being disassembled.">DataBlock</a>*&gt;(d)    {} <span class="comment">// implicit</span>
<a name="l00591"></a>00591 
<a name="l00592"></a><a class="code" href="classPartitioner_1_1DataRangeMapValue.html#adca1e6bd48cf31901840b87474ef16d2">00592</a>         <a class="code" href="classPartitioner_1_1DataRangeMapValue.html" title="Value type for DataRangeMap.">DataRangeMapValue</a> <a class="code" href="classPartitioner_1_1DataRangeMapValue.html#adca1e6bd48cf31901840b87474ef16d2">split</a>(<span class="keyword">const</span> <a class="code" href="classRange.html">Extent</a> &amp;my_range, <span class="keyword">const</span> <a class="code" href="classRange.html#a0110e09e84e56cb5b63bc5bde2a2a241">Extent::Value</a> &amp;new_end) {
<a name="l00593"></a>00593             assert(my_range.<a class="code" href="classRange.html#a7bfc28d2d8efb645ffc65dd563f3964f" title="Does this range contain the argument range?">contains</a>(<a class="code" href="classRange.html">Extent</a>(new_end)));
<a name="l00594"></a>00594             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00595"></a>00595         }
<a name="l00596"></a>00596 
<a name="l00597"></a><a class="code" href="classPartitioner_1_1DataRangeMapValue.html#af7f5197564ec5acb091002b98ab854e0">00597</a>         <span class="keywordtype">void</span> <a class="code" href="classPartitioner_1_1DataRangeMapValue.html#af7f5197564ec5acb091002b98ab854e0" title="Print a RangeMap value.">print</a>(std::ostream &amp;o)<span class="keyword"> const </span>{
<a name="l00598"></a>00598             <span class="keywordflow">if</span> (NULL==<a class="code" href="classRangeMapValue.html#a16c06d37653cc336bd87de06909e7298">value</a>) {
<a name="l00599"></a>00599                 o &lt;&lt;<span class="stringliteral">&quot;(null)&quot;</span>;
<a name="l00600"></a>00600             } <span class="keywordflow">else</span> {
<a name="l00601"></a>00601                 o &lt;&lt;<span class="stringliteral">&quot;D&quot;</span> &lt;&lt;<a class="code" href="namespaceStringUtility.html#a3df35e2d0c2f48226c623ad418240402" title="Convert an address to a string, preferring a hexadecimal representation with at least 8 digits...">StringUtility::addrToString</a>(<a class="code" href="classRangeMapValue.html#a16c06d37653cc336bd87de06909e7298">value</a>-&gt;address());
<a name="l00602"></a>00602             }
<a name="l00603"></a>00603         }
<a name="l00604"></a>00604     };
<a name="l00605"></a>00605 
<a name="l00607"></a><a class="code" href="classPartitioner.html#a908ae714b9d63d22397ba1d44c0a131e">00607</a>     <span class="keyword">typedef</span> <a class="code" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">RangeMap&lt;Extent, DataRangeMapValue&gt;</a> <a class="code" href="classPartitioner.html#a908ae714b9d63d22397ba1d44c0a131e" title="Range map associating addresses with functions.">DataRangeMap</a>;
<a name="l00608"></a>00608 
<a name="l00609"></a>00609     <span class="comment">/**************************************************************************************************************************</span>
<a name="l00610"></a>00610 <span class="comment">     *                                  Functions for scanning through memory</span>
<a name="l00611"></a>00611 <span class="comment">     **************************************************************************************************************************/</span>
<a name="l00612"></a>00612 <span class="keyword">public</span>:
<a name="l00613"></a>00613 
<a name="l00615"></a><a class="code" href="classPartitioner_1_1InsnRangeCallback.html">00615</a>     <span class="keyword">class </span><a class="code" href="classPartitioner_1_1InsnRangeCallback.html" title="Base class for instruction scanning callbacks.">InsnRangeCallback</a> {
<a name="l00616"></a>00616     <span class="keyword">public</span>:
<a name="l00618"></a><a class="code" href="structPartitioner_1_1InsnRangeCallback_1_1Args.html">00618</a>         <span class="keyword">struct </span><a class="code" href="structPartitioner_1_1InsnRangeCallback_1_1Args.html" title="Arguments for the callback.">Args</a> {
<a name="l00619"></a><a class="code" href="structPartitioner_1_1InsnRangeCallback_1_1Args.html#a74d093f3fcb29678c1d3fe69a361c5cb">00619</a>             <a class="code" href="structPartitioner_1_1InsnRangeCallback_1_1Args.html#a74d093f3fcb29678c1d3fe69a361c5cb">Args</a>(<a class="code" href="classPartitioner.html" title="Partitions instructions into basic blocks and functions.">Partitioner</a> *<a class="code" href="structPartitioner_1_1InsnRangeCallback_1_1Args.html#a41a50b8f5505d0d314c1dce6afe21491">partitioner</a>, <a class="code" href="classPartitioner_1_1Instruction.html" title="Holds an instruction along with some other information about the instruction.">Instruction</a> *<a class="code" href="structPartitioner_1_1InsnRangeCallback_1_1Args.html#a11a5775fcb8f0681a2d5f45c0518b113" title="Previous instruction not in range, or null.">insn_prev</a>, <a class="code" href="classPartitioner_1_1Instruction.html" title="Holds an instruction along with some other information about the instruction.">Instruction</a> *<a class="code" href="structPartitioner_1_1InsnRangeCallback_1_1Args.html#a31c87642690726a299a985c08480a6c4" title="First instruction in range of instructions.">insn_begin</a>,
<a name="l00620"></a>00620                  <a class="code" href="classPartitioner_1_1Instruction.html" title="Holds an instruction along with some other information about the instruction.">Instruction</a> *<a class="code" href="structPartitioner_1_1InsnRangeCallback_1_1Args.html#a32365977e9e327a43ff51a37d99260df" title="First subsequent instruction not in range, or null.">insn_end</a>, <span class="keywordtype">size_t</span> <a class="code" href="structPartitioner_1_1InsnRangeCallback_1_1Args.html#ad99a9f8546efd5949aa4fcdc40626e3a" title="Number of instructions in range.">ninsns</a>)
<a name="l00621"></a>00621                 : partitioner(partitioner), insn_prev(insn_prev), insn_begin(insn_begin), insn_end(insn_end),
<a name="l00622"></a>00622                   ninsns(ninsns) {}
<a name="l00623"></a><a class="code" href="structPartitioner_1_1InsnRangeCallback_1_1Args.html#a41a50b8f5505d0d314c1dce6afe21491">00623</a>             <a class="code" href="classPartitioner.html" title="Partitions instructions into basic blocks and functions.">Partitioner</a> *<a class="code" href="structPartitioner_1_1InsnRangeCallback_1_1Args.html#a41a50b8f5505d0d314c1dce6afe21491">partitioner</a>;
<a name="l00624"></a><a class="code" href="structPartitioner_1_1InsnRangeCallback_1_1Args.html#a11a5775fcb8f0681a2d5f45c0518b113">00624</a>             <a class="code" href="classPartitioner_1_1Instruction.html" title="Holds an instruction along with some other information about the instruction.">Instruction</a> *<a class="code" href="structPartitioner_1_1InsnRangeCallback_1_1Args.html#a11a5775fcb8f0681a2d5f45c0518b113" title="Previous instruction not in range, or null.">insn_prev</a>;                     
<a name="l00625"></a><a class="code" href="structPartitioner_1_1InsnRangeCallback_1_1Args.html#a31c87642690726a299a985c08480a6c4">00625</a>             <a class="code" href="classPartitioner_1_1Instruction.html" title="Holds an instruction along with some other information about the instruction.">Instruction</a> *<a class="code" href="structPartitioner_1_1InsnRangeCallback_1_1Args.html#a31c87642690726a299a985c08480a6c4" title="First instruction in range of instructions.">insn_begin</a>;                    
<a name="l00626"></a><a class="code" href="structPartitioner_1_1InsnRangeCallback_1_1Args.html#a32365977e9e327a43ff51a37d99260df">00626</a>             <a class="code" href="classPartitioner_1_1Instruction.html" title="Holds an instruction along with some other information about the instruction.">Instruction</a> *<a class="code" href="structPartitioner_1_1InsnRangeCallback_1_1Args.html#a32365977e9e327a43ff51a37d99260df" title="First subsequent instruction not in range, or null.">insn_end</a>;                      
<a name="l00627"></a><a class="code" href="structPartitioner_1_1InsnRangeCallback_1_1Args.html#ad99a9f8546efd5949aa4fcdc40626e3a">00627</a>             <span class="keywordtype">size_t</span> <a class="code" href="structPartitioner_1_1InsnRangeCallback_1_1Args.html#ad99a9f8546efd5949aa4fcdc40626e3a" title="Number of instructions in range.">ninsns</a>;                              
<a name="l00628"></a>00628         };
<a name="l00629"></a>00629 
<a name="l00630"></a><a class="code" href="classPartitioner_1_1InsnRangeCallback.html#a0fb83976ef030c695eb5a27a16f61b1c">00630</a>         <span class="keyword">virtual</span> <a class="code" href="classPartitioner_1_1InsnRangeCallback.html#a0fb83976ef030c695eb5a27a16f61b1c">~InsnRangeCallback</a>() {}
<a name="l00631"></a>00631 
<a name="l00633"></a>00633         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classPartitioner_1_1InsnRangeCallback.html#afe8ae68f1a728bf093743f7482a053a6" title="The actual callback function.">operator()</a>(<span class="keywordtype">bool</span> enabled, <span class="keyword">const</span> Args &amp;args) = 0;
<a name="l00634"></a>00634     };
<a name="l00635"></a><a class="code" href="classPartitioner.html#ad3746ef9608772aa918629792f10b2b9">00635</a>     <span class="keyword">typedef</span> <a class="code" href="classROSE__Callbacks_1_1List.html" title="List of callback functors.">ROSE_Callbacks::List&lt;InsnRangeCallback&gt;</a> <a class="code" href="classPartitioner.html#ad3746ef9608772aa918629792f10b2b9">InsnRangeCallbacks</a>;
<a name="l00636"></a>00636 
<a name="l00638"></a><a class="code" href="classPartitioner_1_1ByteRangeCallback.html">00638</a>     <span class="keyword">class </span><a class="code" href="classPartitioner_1_1ByteRangeCallback.html" title="Base class for byte scanning callbacks.">ByteRangeCallback</a> {
<a name="l00639"></a>00639     <span class="keyword">public</span>:
<a name="l00641"></a><a class="code" href="structPartitioner_1_1ByteRangeCallback_1_1Args.html">00641</a>         <span class="keyword">struct </span><a class="code" href="structPartitioner_1_1ByteRangeCallback_1_1Args.html" title="Arguments for the callback.">Args</a> {
<a name="l00642"></a><a class="code" href="structPartitioner_1_1ByteRangeCallback_1_1Args.html#a7c978d88725e83eceb1bce0245aee806">00642</a>             <a class="code" href="structPartitioner_1_1ByteRangeCallback_1_1Args.html#a7c978d88725e83eceb1bce0245aee806">Args</a>(<a class="code" href="classPartitioner.html" title="Partitions instructions into basic blocks and functions.">Partitioner</a> *<a class="code" href="structPartitioner_1_1ByteRangeCallback_1_1Args.html#ae5ac6bedb4648e4470d06ffa01170a80">partitioner</a>, <span class="keyword">const</span> <a class="code" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">FunctionRangeMap</a> &amp;<a class="code" href="structPartitioner_1_1ByteRangeCallback_1_1Args.html#a21f3a45b265bc9bb01e02994deef1c55" title="The range map over which we are iterating.">ranges</a>, <span class="keyword">const</span> <a class="code" href="classRange.html">Extent</a> &amp;<a class="code" href="structPartitioner_1_1ByteRangeCallback_1_1Args.html#aea3d17d72bea988da0ad177a1d7a9f73" title="Range of address space being processed by the callback.">range</a>)
<a name="l00643"></a>00643                 : partitioner(partitioner), ranges(ranges), range(range) {}
<a name="l00644"></a><a class="code" href="structPartitioner_1_1ByteRangeCallback_1_1Args.html#ae5ac6bedb4648e4470d06ffa01170a80">00644</a>             <a class="code" href="classPartitioner.html" title="Partitions instructions into basic blocks and functions.">Partitioner</a> *<a class="code" href="structPartitioner_1_1ByteRangeCallback_1_1Args.html#ae5ac6bedb4648e4470d06ffa01170a80">partitioner</a>;
<a name="l00645"></a><a class="code" href="structPartitioner_1_1ByteRangeCallback_1_1Args.html#a21f3a45b265bc9bb01e02994deef1c55">00645</a>             <span class="keyword">const</span> <a class="code" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">FunctionRangeMap</a> &amp;<a class="code" href="structPartitioner_1_1ByteRangeCallback_1_1Args.html#a21f3a45b265bc9bb01e02994deef1c55" title="The range map over which we are iterating.">ranges</a>;             
<a name="l00646"></a><a class="code" href="structPartitioner_1_1ByteRangeCallback_1_1Args.html#aea3d17d72bea988da0ad177a1d7a9f73">00646</a>             <a class="code" href="classRange.html">Extent</a> <a class="code" href="structPartitioner_1_1ByteRangeCallback_1_1Args.html#aea3d17d72bea988da0ad177a1d7a9f73" title="Range of address space being processed by the callback.">range</a>;                               
<a name="l00647"></a>00647         };
<a name="l00648"></a>00648 
<a name="l00649"></a><a class="code" href="classPartitioner_1_1ByteRangeCallback.html#a55b88a9ef6fe69697deb78ff5b475e91">00649</a>         <span class="keyword">virtual</span> <a class="code" href="classPartitioner_1_1ByteRangeCallback.html#a55b88a9ef6fe69697deb78ff5b475e91">~ByteRangeCallback</a>() {}
<a name="l00650"></a>00650 
<a name="l00652"></a>00652         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classPartitioner_1_1ByteRangeCallback.html#a0496db8be16b2cafc7fe5f1f653a03fa" title="The actual callback function.">operator()</a>(<span class="keywordtype">bool</span> enabled, <span class="keyword">const</span> Args &amp;args) = 0;
<a name="l00653"></a>00653     };
<a name="l00654"></a><a class="code" href="classPartitioner.html#a28a95ae28faba1e516a9e230258ee7ee">00654</a>     <span class="keyword">typedef</span> <a class="code" href="classROSE__Callbacks_1_1List.html" title="List of callback functors.">ROSE_Callbacks::List&lt;ByteRangeCallback&gt;</a> <a class="code" href="classPartitioner.html#a28a95ae28faba1e516a9e230258ee7ee">ByteRangeCallbacks</a>;
<a name="l00655"></a>00655 
<a name="l00666"></a>00666     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a128338b3c819f629c68058ca40545c18" title="Scans contiguous sequences of instructions.">scan_contiguous_insns</a>(<a class="code" href="classPartitioner.html#acff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a> <a class="code" href="classPartitioner.html#af9d5d92a9d9ca6a35ade7c5b3906ab97" title="Instruction cache, filled in by user or populated by disassembler.">insns</a>, <a class="code" href="classROSE__Callbacks_1_1List.html" title="List of callback functors.">InsnRangeCallbacks</a> &amp;cblist,
<a name="l00667"></a>00667                                        <a class="code" href="classPartitioner_1_1Instruction.html" title="Holds an instruction along with some other information about the instruction.">Instruction</a> *insn_prev, <a class="code" href="classPartitioner_1_1Instruction.html" title="Holds an instruction along with some other information about the instruction.">Instruction</a> *insn_end);
<a name="l00668"></a><a class="code" href="classPartitioner.html#ad76daaae13e84b22b42098fc1a58641f">00668</a>     <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a128338b3c819f629c68058ca40545c18" title="Scans contiguous sequences of instructions.">scan_contiguous_insns</a>(<span class="keyword">const</span> <a class="code" href="classPartitioner.html#acff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a> &amp;<a class="code" href="classPartitioner.html#af9d5d92a9d9ca6a35ade7c5b3906ab97" title="Instruction cache, filled in by user or populated by disassembler.">insns</a>, <a class="code" href="classPartitioner_1_1InsnRangeCallback.html" title="Base class for instruction scanning callbacks.">InsnRangeCallback</a> *callback,
<a name="l00669"></a>00669                                <a class="code" href="classPartitioner_1_1Instruction.html" title="Holds an instruction along with some other information about the instruction.">Instruction</a> *insn_prev, <a class="code" href="classPartitioner_1_1Instruction.html" title="Holds an instruction along with some other information about the instruction.">Instruction</a> *insn_end) {
<a name="l00670"></a>00670         <a class="code" href="classROSE__Callbacks_1_1List.html" title="List of callback functors.">InsnRangeCallbacks</a> cblist(callback);
<a name="l00671"></a>00671         <a class="code" href="classPartitioner.html#a128338b3c819f629c68058ca40545c18" title="Scans contiguous sequences of instructions.">scan_contiguous_insns</a>(insns, cblist, insn_prev, insn_end);
<a name="l00672"></a>00672     }
<a name="l00691"></a>00691     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a296180568b4a21d4435f264a05f1837f" title="Scans ranges of unassigned instructions.">scan_unassigned_insns</a>(<a class="code" href="classPartitioner.html#ad3746ef9608772aa918629792f10b2b9">InsnRangeCallbacks</a> &amp;callbacks);
<a name="l00692"></a><a class="code" href="classPartitioner.html#a36686cdb1a5fee0a8033ef7708f70b6f">00692</a>     <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a36686cdb1a5fee0a8033ef7708f70b6f" title="Scans ranges of unassigned instructions.">scan_unassigned_insns</a>(<a class="code" href="classPartitioner_1_1InsnRangeCallback.html" title="Base class for instruction scanning callbacks.">InsnRangeCallback</a> *callback) {
<a name="l00693"></a>00693         <a class="code" href="classROSE__Callbacks_1_1List.html" title="List of callback functors.">InsnRangeCallbacks</a> cblist(callback);
<a name="l00694"></a>00694         <a class="code" href="classPartitioner.html#a296180568b4a21d4435f264a05f1837f" title="Scans ranges of unassigned instructions.">scan_unassigned_insns</a>(cblist);
<a name="l00695"></a>00695     }
<a name="l00707"></a>00707     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a6d6f280eb993c9ec09c0b79d1ae790f7" title="Scans the unassigned instructions within a function.">scan_intrafunc_insns</a>(<a class="code" href="classPartitioner.html#ad3746ef9608772aa918629792f10b2b9">InsnRangeCallbacks</a> &amp;callbacks);
<a name="l00708"></a><a class="code" href="classPartitioner.html#a155f8d6d64429bab633e256b48cd32d0">00708</a>     <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a155f8d6d64429bab633e256b48cd32d0" title="Scans the unassigned instructions within a function.">scan_intrafunc_insns</a>(<a class="code" href="classPartitioner_1_1InsnRangeCallback.html" title="Base class for instruction scanning callbacks.">InsnRangeCallback</a> *callback) {
<a name="l00709"></a>00709         <a class="code" href="classROSE__Callbacks_1_1List.html" title="List of callback functors.">InsnRangeCallbacks</a> cblist(callback);
<a name="l00710"></a>00710         <a class="code" href="classPartitioner.html#a6d6f280eb993c9ec09c0b79d1ae790f7" title="Scans the unassigned instructions within a function.">scan_intrafunc_insns</a>(cblist);
<a name="l00711"></a>00711     }
<a name="l00728"></a>00728     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#aff3f578d277b534b4e2e703a39414e73" title="Scans the instructions between functions.">scan_interfunc_insns</a>(<a class="code" href="classPartitioner.html#ad3746ef9608772aa918629792f10b2b9">InsnRangeCallbacks</a> &amp;callbacks);
<a name="l00729"></a><a class="code" href="classPartitioner.html#a1e3a66407625c4723589f867064709ac">00729</a>     <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a1e3a66407625c4723589f867064709ac" title="Scans the instructions between functions.">scan_interfunc_insns</a>(<a class="code" href="classPartitioner_1_1InsnRangeCallback.html" title="Base class for instruction scanning callbacks.">InsnRangeCallback</a> *callback) {
<a name="l00730"></a>00730         <a class="code" href="classROSE__Callbacks_1_1List.html" title="List of callback functors.">InsnRangeCallbacks</a> cblist(callback);
<a name="l00731"></a>00731         <a class="code" href="classPartitioner.html#aff3f578d277b534b4e2e703a39414e73" title="Scans the instructions between functions.">scan_interfunc_insns</a>(cblist);
<a name="l00732"></a>00732     }
<a name="l00744"></a>00744     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a1b34a47428d9dc6c31a540ae1c724520" title="Scans ranges of the address space that have not been assigned to any function.">scan_unassigned_bytes</a>(<a class="code" href="classPartitioner.html#a28a95ae28faba1e516a9e230258ee7ee">ByteRangeCallbacks</a> &amp;callbacks, <a class="code" href="classMemoryMap.html" title="A MemoryMap is an efficient mapping from virtual addresses to source bytes.">MemoryMap</a> *restrict_var=NULL);
<a name="l00745"></a><a class="code" href="classPartitioner.html#ae106ae6f664cf6e1b948ae0bad6844a0">00745</a>     <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#ae106ae6f664cf6e1b948ae0bad6844a0" title="Scans ranges of the address space that have not been assigned to any function.">scan_unassigned_bytes</a>(<a class="code" href="classPartitioner_1_1ByteRangeCallback.html" title="Base class for byte scanning callbacks.">ByteRangeCallback</a> *callback, <a class="code" href="classMemoryMap.html" title="A MemoryMap is an efficient mapping from virtual addresses to source bytes.">MemoryMap</a> *restrict_var=NULL) {
<a name="l00746"></a>00746         <a class="code" href="classROSE__Callbacks_1_1List.html" title="List of callback functors.">ByteRangeCallbacks</a> cblist(callback);
<a name="l00747"></a>00747         <a class="code" href="classPartitioner.html#a1b34a47428d9dc6c31a540ae1c724520" title="Scans ranges of the address space that have not been assigned to any function.">scan_unassigned_bytes</a>(cblist, restrict_var);
<a name="l00748"></a>00748     }
<a name="l00759"></a>00759     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a60e266ca72ebe30e823bdcb553264bff" title="Scans unassigned ranges of the address space within a function.">scan_intrafunc_bytes</a>(<a class="code" href="classPartitioner.html#a28a95ae28faba1e516a9e230258ee7ee">ByteRangeCallbacks</a> &amp;callbacks, <a class="code" href="classMemoryMap.html" title="A MemoryMap is an efficient mapping from virtual addresses to source bytes.">MemoryMap</a> *restrict_var=NULL);
<a name="l00760"></a><a class="code" href="classPartitioner.html#ad6cfd1d1dd359485b4f83736f73630df">00760</a>     <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#ad6cfd1d1dd359485b4f83736f73630df" title="Scans unassigned ranges of the address space within a function.">scan_intrafunc_bytes</a>(<a class="code" href="classPartitioner_1_1ByteRangeCallback.html" title="Base class for byte scanning callbacks.">ByteRangeCallback</a> *callback, <a class="code" href="classMemoryMap.html" title="A MemoryMap is an efficient mapping from virtual addresses to source bytes.">MemoryMap</a> *restrict_var=NULL) {
<a name="l00761"></a>00761         <a class="code" href="classROSE__Callbacks_1_1List.html" title="List of callback functors.">ByteRangeCallbacks</a> cblist(callback);
<a name="l00762"></a>00762         <a class="code" href="classPartitioner.html#a60e266ca72ebe30e823bdcb553264bff" title="Scans unassigned ranges of the address space within a function.">scan_intrafunc_bytes</a>(cblist, restrict_var);
<a name="l00763"></a>00763     }
<a name="l00774"></a>00774     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#adb08063071ec20f90ba00db54af7aba8" title="Scans unassigned ranges of the address space between functions.">scan_interfunc_bytes</a>(<a class="code" href="classPartitioner.html#a28a95ae28faba1e516a9e230258ee7ee">ByteRangeCallbacks</a> &amp;callbacks, <a class="code" href="classMemoryMap.html" title="A MemoryMap is an efficient mapping from virtual addresses to source bytes.">MemoryMap</a> *restrict_var=NULL);
<a name="l00775"></a><a class="code" href="classPartitioner.html#aa1f831bc5844b6bb85f10e3c0b912a28">00775</a>     <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#aa1f831bc5844b6bb85f10e3c0b912a28" title="Scans unassigned ranges of the address space between functions.">scan_interfunc_bytes</a>(<a class="code" href="classPartitioner_1_1ByteRangeCallback.html" title="Base class for byte scanning callbacks.">ByteRangeCallback</a> *callback, <a class="code" href="classMemoryMap.html" title="A MemoryMap is an efficient mapping from virtual addresses to source bytes.">MemoryMap</a> *restrict_var=NULL) {
<a name="l00776"></a>00776         <a class="code" href="classROSE__Callbacks_1_1List.html" title="List of callback functors.">ByteRangeCallbacks</a> cblist(callback);
<a name="l00777"></a>00777         <a class="code" href="classPartitioner.html#adb08063071ec20f90ba00db54af7aba8" title="Scans unassigned ranges of the address space between functions.">scan_interfunc_bytes</a>(cblist, restrict_var);
<a name="l00778"></a>00778     }
<a name="l00790"></a><a class="code" href="structPartitioner_1_1FindDataPadding.html">00790</a>     <span class="keyword">struct </span><a class="code" href="structPartitioner_1_1FindDataPadding.html" title="Callback to detect padding.">FindDataPadding</a>: <span class="keyword">public</span> <a class="code" href="classPartitioner_1_1ByteRangeCallback.html" title="Base class for byte scanning callbacks.">ByteRangeCallback</a> {
<a name="l00791"></a><a class="code" href="structPartitioner_1_1FindDataPadding.html#afeb31329993876d61d1911a020ced648">00791</a>         std::vector&lt;SgUnsignedCharList&gt; <a class="code" href="structPartitioner_1_1FindDataPadding.html#afeb31329993876d61d1911a020ced648" title="Pattern of padding, repeated at least minimum_size times.">patterns</a>;       
<a name="l00792"></a><a class="code" href="structPartitioner_1_1FindDataPadding.html#a33a6ebd0a32698893da1fe3969473314">00792</a>         <span class="keywordtype">size_t</span> <a class="code" href="structPartitioner_1_1FindDataPadding.html#a33a6ebd0a32698893da1fe3969473314" title="Minimum number of matched patterns to be considered padding.">minimum_nrep</a>;                            
<a name="l00793"></a><a class="code" href="structPartitioner_1_1FindDataPadding.html#a66f37c43985eaece53973cbd448fed23">00793</a>         <span class="keywordtype">size_t</span> <a class="code" href="structPartitioner_1_1FindDataPadding.html#a66f37c43985eaece53973cbd448fed23" title="Maximum number of mathced patterns to be considered padding.">maximum_nrep</a>;                            
<a name="l00794"></a><a class="code" href="structPartitioner_1_1FindDataPadding.html#a6b5d276a6335acb237a5fac292ed3fd1">00794</a>         <span class="keywordtype">bool</span> <a class="code" href="structPartitioner_1_1FindDataPadding.html#a6b5d276a6335acb237a5fac292ed3fd1" title="If true, pattern must start immediately after a function.">begins_contiguously</a>;                       
<a name="l00795"></a><a class="code" href="structPartitioner_1_1FindDataPadding.html#abf467f8bd8fe421c05aa827ff2c3ff83">00795</a>         <span class="keywordtype">bool</span> <a class="code" href="structPartitioner_1_1FindDataPadding.html#abf467f8bd8fe421c05aa827ff2c3ff83" title="If true, pattern must end immediately before a function.">ends_contiguously</a>;                         
<a name="l00796"></a><a class="code" href="structPartitioner_1_1FindDataPadding.html#a684ff3383631bc64fdc48a1d56fda272">00796</a>         <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> <a class="code" href="structPartitioner_1_1FindDataPadding.html#a684ff3383631bc64fdc48a1d56fda272" title="Skip this callback if the range is larger than this.">maximum_range_size</a>;                 
<a name="l00797"></a><a class="code" href="structPartitioner_1_1FindDataPadding.html#ae069737f1ad1f17a7eb96420bed7c139">00797</a>         <span class="keywordtype">size_t</span> <a class="code" href="structPartitioner_1_1FindDataPadding.html#ae069737f1ad1f17a7eb96420bed7c139" title="Total number of blocks found by this callback.">nfound</a>;                                  
<a name="l00799"></a><a class="code" href="structPartitioner_1_1FindDataPadding.html#a6bab8b8aa7f25df133a52285f42cfeb4">00799</a>         <a class="code" href="structPartitioner_1_1FindDataPadding.html#a6bab8b8aa7f25df133a52285f42cfeb4">FindDataPadding</a>()
<a name="l00800"></a>00800             : <a class="code" href="structPartitioner_1_1FindDataPadding.html#a33a6ebd0a32698893da1fe3969473314" title="Minimum number of matched patterns to be considered padding.">minimum_nrep</a>(2), <a class="code" href="structPartitioner_1_1FindDataPadding.html#a66f37c43985eaece53973cbd448fed23" title="Maximum number of mathced patterns to be considered padding.">maximum_nrep</a>(1024*1024), <a class="code" href="structPartitioner_1_1FindDataPadding.html#a6b5d276a6335acb237a5fac292ed3fd1" title="If true, pattern must start immediately after a function.">begins_contiguously</a>(false), <a class="code" href="structPartitioner_1_1FindDataPadding.html#abf467f8bd8fe421c05aa827ff2c3ff83" title="If true, pattern must end immediately before a function.">ends_contiguously</a>(true),
<a name="l00801"></a>00801               <a class="code" href="structPartitioner_1_1FindDataPadding.html#a684ff3383631bc64fdc48a1d56fda272" title="Skip this callback if the range is larger than this.">maximum_range_size</a>(100*1024*1024),  <a class="code" href="structPartitioner_1_1FindDataPadding.html#ae069737f1ad1f17a7eb96420bed7c139" title="Total number of blocks found by this callback.">nfound</a>(0) {}
<a name="l00802"></a>00802         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="structPartitioner_1_1FindDataPadding.html#a65b0ed5e516b2077a0a342452ad1cf18" title="The actual callback function.">operator()</a>(<span class="keywordtype">bool</span> enabled, <span class="keyword">const</span> Args &amp;args);
<a name="l00803"></a>00803     };
<a name="l00804"></a>00804 
<a name="l00809"></a><a class="code" href="structPartitioner_1_1FindData.html">00809</a>     <span class="keyword">struct </span><a class="code" href="structPartitioner_1_1FindData.html" title="Callback to add unassigned addresses to a function.">FindData</a>: <span class="keyword">public</span> <a class="code" href="classPartitioner_1_1ByteRangeCallback.html" title="Base class for byte scanning callbacks.">ByteRangeCallback</a> {
<a name="l00810"></a><a class="code" href="structPartitioner_1_1FindData.html#a8a92b8c0d8a8e3bdd6e8820b2f74fcf0">00810</a>         <span class="keywordtype">unsigned</span> <a class="code" href="structPartitioner_1_1FindData.html#a8a92b8c0d8a8e3bdd6e8820b2f74fcf0" title="Bit mask of function reasons to be avoided.">excluded_reasons</a>;                      
<a name="l00811"></a><a class="code" href="structPartitioner_1_1FindData.html#ad9f6d1ebce605c312597fc6f5b04bad2">00811</a>         <a class="code" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">DataRangeMap</a> *<a class="code" href="structPartitioner_1_1FindData.html#ad9f6d1ebce605c312597fc6f5b04bad2" title="Padding ranges created on demand and cached.">padding_ranges</a>;                   
<a name="l00812"></a><a class="code" href="structPartitioner_1_1FindData.html#a744d7c19ffb8d8c80d6a506cedef0645">00812</a>         <span class="keywordtype">size_t</span> <a class="code" href="structPartitioner_1_1FindData.html#a744d7c19ffb8d8c80d6a506cedef0645" title="Number of data blocks added by this callback.">nfound</a>;                                  
<a name="l00814"></a><a class="code" href="structPartitioner_1_1FindData.html#a66e1bf4bcb9af94cc610c5cb2b6a45b6">00814</a>         <a class="code" href="structPartitioner_1_1FindData.html#a66e1bf4bcb9af94cc610c5cb2b6a45b6">FindData</a>(): <a class="code" href="structPartitioner_1_1FindData.html#a8a92b8c0d8a8e3bdd6e8820b2f74fcf0" title="Bit mask of function reasons to be avoided.">excluded_reasons</a>(<a class="code" href="classSgAsmFunction.html">SgAsmFunction</a>::FUNC_PADDING|<a class="code" href="classSgAsmFunction.html">SgAsmFunction</a>::FUNC_THUNK), <a class="code" href="structPartitioner_1_1FindData.html#ad9f6d1ebce605c312597fc6f5b04bad2" title="Padding ranges created on demand and cached.">padding_ranges</a>(NULL), <a class="code" href="structPartitioner_1_1FindData.html#a744d7c19ffb8d8c80d6a506cedef0645" title="Number of data blocks added by this callback.">nfound</a>(0) {}
<a name="l00815"></a><a class="code" href="structPartitioner_1_1FindData.html#a6940aea03f3dd12c036d5951503d756f">00815</a>         <a class="code" href="structPartitioner_1_1FindData.html#a6940aea03f3dd12c036d5951503d756f">~FindData</a>() { <span class="keyword">delete</span> <a class="code" href="structPartitioner_1_1FindData.html#ad9f6d1ebce605c312597fc6f5b04bad2" title="Padding ranges created on demand and cached.">padding_ranges</a>; }
<a name="l00816"></a>00816         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="structPartitioner_1_1FindData.html#a29a959188e5df3c25a0897b0ab9002b6" title="The actual callback function.">operator()</a>(<span class="keywordtype">bool</span> enabled, <span class="keyword">const</span> Args &amp;args);
<a name="l00817"></a>00817     };
<a name="l00818"></a>00818 
<a name="l00860"></a><a class="code" href="structPartitioner_1_1FindInsnPadding.html">00860</a>     <span class="keyword">struct </span><a class="code" href="structPartitioner_1_1FindInsnPadding.html" title="Callback to create inter-function instruction padding.">FindInsnPadding</a>: <span class="keyword">public</span> <a class="code" href="classPartitioner_1_1InsnRangeCallback.html" title="Base class for instruction scanning callbacks.">InsnRangeCallback</a> {
<a name="l00861"></a><a class="code" href="structPartitioner_1_1FindInsnPadding.html#a880dadbb6d82ff55d32b6478cc39ea6d">00861</a>         std::set&lt;X86InstructionKind&gt; <a class="code" href="structPartitioner_1_1FindInsnPadding.html#a880dadbb6d82ff55d32b6478cc39ea6d" title="Kinds of x86 instructions allowed.">x86_kinds</a>;                 
<a name="l00862"></a><a class="code" href="structPartitioner_1_1FindInsnPadding.html#a89ef0d1a8eb2880399ee134de94bc698">00862</a>         std::vector&lt;SgUnsignedCharList&gt; <a class="code" href="structPartitioner_1_1FindInsnPadding.html#a89ef0d1a8eb2880399ee134de94bc698" title="Match instructions with specified byte patterns.">byte_patterns</a>;          
<a name="l00863"></a><a class="code" href="structPartitioner_1_1FindInsnPadding.html#aef820cd1b1c4009b0d09fb53627a0329">00863</a>         <span class="keywordtype">bool</span> <a class="code" href="structPartitioner_1_1FindInsnPadding.html#aef820cd1b1c4009b0d09fb53627a0329" title="Must immediately follow the end of a function?">begins_contiguously</a>;                               
<a name="l00864"></a><a class="code" href="structPartitioner_1_1FindInsnPadding.html#a29652be29e0a267cba0d1102d620d475">00864</a>         <span class="keywordtype">bool</span> <a class="code" href="structPartitioner_1_1FindInsnPadding.html#a29652be29e0a267cba0d1102d620d475" title="Must immediately precede the beginning of a func?">ends_contiguously</a>;                                 
<a name="l00865"></a><a class="code" href="structPartitioner_1_1FindInsnPadding.html#af0b52f591caf8383d070bdf3107f20cc">00865</a>         <span class="keywordtype">size_t</span> <a class="code" href="structPartitioner_1_1FindInsnPadding.html#af0b52f591caf8383d070bdf3107f20cc" title="Minimum size in bytes.">minimum_size</a>;                                    
<a name="l00866"></a><a class="code" href="structPartitioner_1_1FindInsnPadding.html#a186bf3385d4220cacc90c1b8e0887f66">00866</a>         <span class="keywordtype">bool</span> <a class="code" href="structPartitioner_1_1FindInsnPadding.html#a186bf3385d4220cacc90c1b8e0887f66" title="If true, create data otherwise create a function.">add_as_data</a>;                                       
<a name="l00867"></a><a class="code" href="structPartitioner_1_1FindInsnPadding.html#a3ee7941ea138ffb8442ff5d1d8cd2c5f">00867</a>         <span class="keywordtype">size_t</span> <a class="code" href="structPartitioner_1_1FindInsnPadding.html#a3ee7941ea138ffb8442ff5d1d8cd2c5f" title="Number of padding areas found by this callback.">nfound</a>;                                          
<a name="l00869"></a><a class="code" href="structPartitioner_1_1FindInsnPadding.html#ad5e6c90e4a07976988f2934008b41687">00869</a>         <a class="code" href="structPartitioner_1_1FindInsnPadding.html#ad5e6c90e4a07976988f2934008b41687">FindInsnPadding</a>()
<a name="l00870"></a>00870             : <a class="code" href="structPartitioner_1_1FindInsnPadding.html#aef820cd1b1c4009b0d09fb53627a0329" title="Must immediately follow the end of a function?">begins_contiguously</a>(true), <a class="code" href="structPartitioner_1_1FindInsnPadding.html#a29652be29e0a267cba0d1102d620d475" title="Must immediately precede the beginning of a func?">ends_contiguously</a>(true), <a class="code" href="structPartitioner_1_1FindInsnPadding.html#af0b52f591caf8383d070bdf3107f20cc" title="Minimum size in bytes.">minimum_size</a>(0), <a class="code" href="structPartitioner_1_1FindInsnPadding.html#a186bf3385d4220cacc90c1b8e0887f66" title="If true, create data otherwise create a function.">add_as_data</a>(true), <a class="code" href="structPartitioner_1_1FindInsnPadding.html#a3ee7941ea138ffb8442ff5d1d8cd2c5f" title="Number of padding areas found by this callback.">nfound</a>(0) {}
<a name="l00871"></a>00871         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="structPartitioner_1_1FindInsnPadding.html#a3571a91a3b823eb2de2c1a2a8a4d6a98" title="The actual callback function.">operator()</a>(<span class="keywordtype">bool</span> enabled, <span class="keyword">const</span> Args &amp;args);
<a name="l00872"></a>00872     };
<a name="l00873"></a>00873 
<a name="l00885"></a><a class="code" href="structPartitioner_1_1FindIntraFunctionInsns.html">00885</a>     <span class="keyword">struct </span><a class="code" href="structPartitioner_1_1FindIntraFunctionInsns.html" title="Callback to insert unreachable intra-function blocks.">FindIntraFunctionInsns</a>: <span class="keyword">public</span> <a class="code" href="classPartitioner_1_1ByteRangeCallback.html" title="Base class for byte scanning callbacks.">ByteRangeCallback</a> {
<a name="l00886"></a><a class="code" href="structPartitioner_1_1FindIntraFunctionInsns.html#a75a5d8e13237a3e7e7216eae47481dbb">00886</a>         <span class="keywordtype">bool</span> <a class="code" href="structPartitioner_1_1FindIntraFunctionInsns.html#a75a5d8e13237a3e7e7216eae47481dbb" title="If set, then surrounding function must be contiguous.">require_contiguous</a>;                                
<a name="l00887"></a><a class="code" href="structPartitioner_1_1FindIntraFunctionInsns.html#a6b4aaec2843a016d5d9f5f79afa07c5f">00887</a>         <a class="code" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">FunctionRangeMap</a> *<a class="code" href="structPartitioner_1_1FindIntraFunctionInsns.html#a6b4aaec2843a016d5d9f5f79afa07c5f" title="Cached function extents computed on first call.">function_extents</a>;                     
<a name="l00888"></a><a class="code" href="structPartitioner_1_1FindIntraFunctionInsns.html#ac861113c350ebce4dbde14ba89b4b0c3">00888</a>         <span class="keywordtype">size_t</span> <a class="code" href="structPartitioner_1_1FindIntraFunctionInsns.html#ac861113c350ebce4dbde14ba89b4b0c3" title="Number of basic blocks added by this callback.">nfound</a>;                                          
<a name="l00890"></a><a class="code" href="structPartitioner_1_1FindIntraFunctionInsns.html#a2aee371b14d6374688a9d9c6abc0deeb">00890</a>         <a class="code" href="structPartitioner_1_1FindIntraFunctionInsns.html#a2aee371b14d6374688a9d9c6abc0deeb">FindIntraFunctionInsns</a>(): <a class="code" href="structPartitioner_1_1FindIntraFunctionInsns.html#a75a5d8e13237a3e7e7216eae47481dbb" title="If set, then surrounding function must be contiguous.">require_contiguous</a>(true), <a class="code" href="structPartitioner_1_1FindIntraFunctionInsns.html#a6b4aaec2843a016d5d9f5f79afa07c5f" title="Cached function extents computed on first call.">function_extents</a>(NULL), <a class="code" href="structPartitioner_1_1FindIntraFunctionInsns.html#ac861113c350ebce4dbde14ba89b4b0c3" title="Number of basic blocks added by this callback.">nfound</a>(0) {}
<a name="l00891"></a><a class="code" href="structPartitioner_1_1FindIntraFunctionInsns.html#a5965ba550a9d031a3ab135e0a3ad3661">00891</a>         <span class="keyword">virtual</span> <a class="code" href="structPartitioner_1_1FindIntraFunctionInsns.html#a5965ba550a9d031a3ab135e0a3ad3661">~FindIntraFunctionInsns</a>() { <span class="keyword">delete</span> <a class="code" href="structPartitioner_1_1FindIntraFunctionInsns.html#a6b4aaec2843a016d5d9f5f79afa07c5f" title="Cached function extents computed on first call.">function_extents</a>; }
<a name="l00892"></a>00892         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="structPartitioner_1_1FindIntraFunctionInsns.html#a6729eaf8f50d3486fe262a7f01cde345" title="The actual callback function.">operator()</a>(<span class="keywordtype">bool</span> enabled, <span class="keyword">const</span> Args &amp;args);
<a name="l00893"></a>00893     };
<a name="l00894"></a>00894 
<a name="l00903"></a><a class="code" href="structPartitioner_1_1FindThunks.html">00903</a>     <span class="keyword">struct </span><a class="code" href="structPartitioner_1_1FindThunks.html" title="Callback to find thunks.">FindThunks</a>: <span class="keyword">public</span> <a class="code" href="classPartitioner_1_1InsnRangeCallback.html" title="Base class for instruction scanning callbacks.">InsnRangeCallback</a> {
<a name="l00904"></a><a class="code" href="structPartitioner_1_1FindThunks.html#a0e586c0af4c138b3f6c35de5f9901a49">00904</a>         <span class="keywordtype">size_t</span> <a class="code" href="structPartitioner_1_1FindThunks.html#a0e586c0af4c138b3f6c35de5f9901a49" title="If true, then the successor must point to the entry point of an existing function.">validate_targets</a>;        
<a name="l00905"></a><a class="code" href="structPartitioner_1_1FindThunks.html#a2689fcf231b7a9657169b8e3c369bc71">00905</a>         <span class="keywordtype">size_t</span> <a class="code" href="structPartitioner_1_1FindThunks.html#a2689fcf231b7a9657169b8e3c369bc71" title="Incremented for each thunk found and added.">nfound</a>;                  
<a name="l00907"></a><a class="code" href="structPartitioner_1_1FindThunks.html#a54bb5f6a81743affa9fec3cb0132f1c1">00907</a>         <a class="code" href="structPartitioner_1_1FindThunks.html#a54bb5f6a81743affa9fec3cb0132f1c1">FindThunks</a>(): <a class="code" href="structPartitioner_1_1FindThunks.html#a0e586c0af4c138b3f6c35de5f9901a49" title="If true, then the successor must point to the entry point of an existing function.">validate_targets</a>(true), <a class="code" href="structPartitioner_1_1FindThunks.html#a2689fcf231b7a9657169b8e3c369bc71" title="Incremented for each thunk found and added.">nfound</a>(0) {}
<a name="l00908"></a>00908         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="structPartitioner_1_1FindThunks.html#abcaf0f2a7797f23d60bdbff4f355bc0c" title="The actual callback function.">operator()</a>(<span class="keywordtype">bool</span> enabled, <span class="keyword">const</span> Args &amp;args);
<a name="l00909"></a>00909     };
<a name="l00910"></a>00910 
<a name="l00918"></a><a class="code" href="structPartitioner_1_1FindThunkTables.html">00918</a>     <span class="keyword">struct </span><a class="code" href="structPartitioner_1_1FindThunkTables.html" title="Callback to find thunk tables.">FindThunkTables</a>: <span class="keyword">public</span> <a class="code" href="classPartitioner_1_1ByteRangeCallback.html" title="Base class for byte scanning callbacks.">ByteRangeCallback</a> {
<a name="l00919"></a><a class="code" href="structPartitioner_1_1FindThunkTables.html#a7fc8dd4714f84b8ba2654e5a8d2cacd2">00919</a>         <span class="keywordtype">bool</span> <a class="code" href="structPartitioner_1_1FindThunkTables.html#a7fc8dd4714f84b8ba2654e5a8d2cacd2" title="Match table only at the beginning of the address range.">begins_contiguously</a>;       
<a name="l00920"></a><a class="code" href="structPartitioner_1_1FindThunkTables.html#a07e2f8dd5c208907265a831aed2edb24">00920</a>         <span class="keywordtype">bool</span> <a class="code" href="structPartitioner_1_1FindThunkTables.html#a07e2f8dd5c208907265a831aed2edb24" title="Match table only at the end of the address range.">ends_contiguously</a>;         
<a name="l00921"></a><a class="code" href="structPartitioner_1_1FindThunkTables.html#a87b2107fff1914c79e5419cf3a710a28">00921</a>         <span class="keywordtype">size_t</span> <a class="code" href="structPartitioner_1_1FindThunkTables.html#a87b2107fff1914c79e5419cf3a710a28" title="Mininum number of JMPs necessary to be considered a thunk table.">minimum_nthunks</a>;         
<a name="l00922"></a><a class="code" href="structPartitioner_1_1FindThunkTables.html#a6af964ccb6b86516db4cf1b1577cfbd8">00922</a>         <span class="keywordtype">bool</span> <a class="code" href="structPartitioner_1_1FindThunkTables.html#a6af964ccb6b86516db4cf1b1577cfbd8" title="If true, then successors must point to instructions.">validate_targets</a>;          
<a name="l00923"></a><a class="code" href="structPartitioner_1_1FindThunkTables.html#a5e5cdbe0703bb2c1d3b0daabba654ac7">00923</a>         <span class="keywordtype">size_t</span> <a class="code" href="structPartitioner_1_1FindThunkTables.html#a5e5cdbe0703bb2c1d3b0daabba654ac7" title="Number of thunks (not tables) found by this callback.">nfound</a>;                  
<a name="l00925"></a><a class="code" href="structPartitioner_1_1FindThunkTables.html#af1abfd6ed90002990cd1979afbd2e353">00925</a>         <a class="code" href="structPartitioner_1_1FindThunkTables.html#af1abfd6ed90002990cd1979afbd2e353">FindThunkTables</a>()
<a name="l00926"></a>00926             : <a class="code" href="structPartitioner_1_1FindThunkTables.html#a7fc8dd4714f84b8ba2654e5a8d2cacd2" title="Match table only at the beginning of the address range.">begins_contiguously</a>(false), <a class="code" href="structPartitioner_1_1FindThunkTables.html#a07e2f8dd5c208907265a831aed2edb24" title="Match table only at the end of the address range.">ends_contiguously</a>(false), <a class="code" href="structPartitioner_1_1FindThunkTables.html#a87b2107fff1914c79e5419cf3a710a28" title="Mininum number of JMPs necessary to be considered a thunk table.">minimum_nthunks</a>(3), <a class="code" href="structPartitioner_1_1FindThunkTables.html#a6af964ccb6b86516db4cf1b1577cfbd8" title="If true, then successors must point to instructions.">validate_targets</a>(true), <a class="code" href="structPartitioner_1_1FindThunkTables.html#a5e5cdbe0703bb2c1d3b0daabba654ac7" title="Number of thunks (not tables) found by this callback.">nfound</a>(0) {}
<a name="l00927"></a>00927         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="structPartitioner_1_1FindThunkTables.html#a6b04620cb35e22eefbda50f1e2c3e14c" title="The actual callback function.">operator()</a>(<span class="keywordtype">bool</span> enabled, <span class="keyword">const</span> Args &amp;args);
<a name="l00928"></a>00928     };
<a name="l00929"></a>00929 
<a name="l00933"></a><a class="code" href="structPartitioner_1_1FindInterPadFunctions.html">00933</a>     <span class="keyword">struct </span><a class="code" href="structPartitioner_1_1FindInterPadFunctions.html" title="Callback to find functions that are between padding.">FindInterPadFunctions</a>: <span class="keyword">public</span> <a class="code" href="classPartitioner_1_1ByteRangeCallback.html" title="Base class for byte scanning callbacks.">ByteRangeCallback</a> {
<a name="l00934"></a><a class="code" href="structPartitioner_1_1FindInterPadFunctions.html#a77e8b4c3c10e7614c46d3596e95fe53c">00934</a>         <a class="code" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">DataRangeMap</a> *<a class="code" href="structPartitioner_1_1FindInterPadFunctions.html#a77e8b4c3c10e7614c46d3596e95fe53c" title="Information about all the padding data blocks that belong to functions.">padding_ranges</a>;   
<a name="l00935"></a><a class="code" href="structPartitioner_1_1FindInterPadFunctions.html#a75adb69d444a81663e01ae0f6b9d4f5c">00935</a>         <span class="keywordtype">size_t</span> <a class="code" href="structPartitioner_1_1FindInterPadFunctions.html#a75adb69d444a81663e01ae0f6b9d4f5c" title="Number of functions found and added by this callback.">nfound</a>;                  
<a name="l00937"></a><a class="code" href="structPartitioner_1_1FindInterPadFunctions.html#a53167e81fe6e898cd76522d0b5c15b7d">00937</a>         <a class="code" href="structPartitioner_1_1FindInterPadFunctions.html#a53167e81fe6e898cd76522d0b5c15b7d">FindInterPadFunctions</a>(): <a class="code" href="structPartitioner_1_1FindInterPadFunctions.html#a77e8b4c3c10e7614c46d3596e95fe53c" title="Information about all the padding data blocks that belong to functions.">padding_ranges</a>(NULL), <a class="code" href="structPartitioner_1_1FindInterPadFunctions.html#a75adb69d444a81663e01ae0f6b9d4f5c" title="Number of functions found and added by this callback.">nfound</a>(0) {}
<a name="l00938"></a><a class="code" href="structPartitioner_1_1FindInterPadFunctions.html#a06e5ca1e7528375fb338fc94ba7eb769">00938</a>         <a class="code" href="structPartitioner_1_1FindInterPadFunctions.html#a06e5ca1e7528375fb338fc94ba7eb769">~FindInterPadFunctions</a>() { <span class="keyword">delete</span> <a class="code" href="structPartitioner_1_1FindInterPadFunctions.html#a77e8b4c3c10e7614c46d3596e95fe53c" title="Information about all the padding data blocks that belong to functions.">padding_ranges</a>; }
<a name="l00939"></a>00939         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="structPartitioner_1_1FindInterPadFunctions.html#a76b72a15ad3f327dab06f1a3804a2835" title="The actual callback function.">operator()</a>(<span class="keywordtype">bool</span> enabled, <span class="keyword">const</span> Args &amp;args);
<a name="l00940"></a>00940     };
<a name="l00941"></a>00941 
<a name="l00950"></a><a class="code" href="structPartitioner_1_1FindPostFunctionInsns.html">00950</a>     <span class="keyword">struct </span><a class="code" href="structPartitioner_1_1FindPostFunctionInsns.html" title="Callback to add post-function instructions to the preceding function.">FindPostFunctionInsns</a>: <span class="keyword">public</span> <a class="code" href="classPartitioner_1_1InsnRangeCallback.html" title="Base class for instruction scanning callbacks.">InsnRangeCallback</a> {
<a name="l00951"></a><a class="code" href="structPartitioner_1_1FindPostFunctionInsns.html#ac32280f2603e5d95de59a540b2c46d9a">00951</a>         <span class="keywordtype">size_t</span> <a class="code" href="structPartitioner_1_1FindPostFunctionInsns.html#ac32280f2603e5d95de59a540b2c46d9a" title="Number of basic blocks added to functions by this callback.">nfound</a>;                  
<a name="l00953"></a><a class="code" href="structPartitioner_1_1FindPostFunctionInsns.html#aa121b5ac7f1890d17cf0632f7d04ec13">00953</a>         <a class="code" href="structPartitioner_1_1FindPostFunctionInsns.html#aa121b5ac7f1890d17cf0632f7d04ec13">FindPostFunctionInsns</a>(): <a class="code" href="structPartitioner_1_1FindPostFunctionInsns.html#ac32280f2603e5d95de59a540b2c46d9a" title="Number of basic blocks added to functions by this callback.">nfound</a>(0) {}
<a name="l00954"></a>00954         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="structPartitioner_1_1FindPostFunctionInsns.html#afa973ec4096b5c4f1e20f1257ca805f9" title="The actual callback function.">operator()</a>(<span class="keywordtype">bool</span> enabled, <span class="keyword">const</span> Args &amp;args);
<a name="l00955"></a>00955     };
<a name="l00956"></a>00956 
<a name="l00957"></a>00957     <span class="comment">/**************************************************************************************************************************</span>
<a name="l00958"></a>00958 <span class="comment">     *                                  Methods for finding functions by patterns</span>
<a name="l00959"></a>00959 <span class="comment">     **************************************************************************************************************************/</span>
<a name="l00960"></a>00960 <span class="keyword">protected</span>:
<a name="l00965"></a>00965     <span class="keyword">static</span> InstructionMap::const_iterator <a class="code" href="classPartitioner.html#a211865359a987a4e353615bb427bda34" title="Looks for stack frame setup.">pattern1</a>(<span class="keyword">const</span> <a class="code" href="classPartitioner.html#acff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a>&amp; <a class="code" href="classPartitioner.html#af9d5d92a9d9ca6a35ade7c5b3906ab97" title="Instruction cache, filled in by user or populated by disassembler.">insns</a>, InstructionMap::const_iterator first,
<a name="l00966"></a>00966                                                    <a class="code" href="classDisassembler.html#a7d930e04b0d619cb057ff0e5a559534b" title="An AddressSet contains virtual addresses (alternatively, relative virtual addresses) for such things ...">Disassembler::AddressSet</a> &amp;exclude);
<a name="l00967"></a>00967 
<a name="l00968"></a>00968 <span class="preprocessor">#if 0 </span><span class="comment">/* Definitions are also commented out */</span>
<a name="l00969"></a>00969 
<a name="l00971"></a>00971     <span class="keyword">static</span> InstructionMap::const_iterator pattern2(<span class="keyword">const</span> <a class="code" href="classPartitioner.html#acff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a>&amp; <a class="code" href="classPartitioner.html#af9d5d92a9d9ca6a35ade7c5b3906ab97" title="Instruction cache, filled in by user or populated by disassembler.">insns</a>, InstructionMap::const_iterator first,
<a name="l00972"></a>00972                                                    <a class="code" href="classDisassembler.html#a7d930e04b0d619cb057ff0e5a559534b" title="An AddressSet contains virtual addresses (alternatively, relative virtual addresses) for such things ...">Disassembler::AddressSet</a> &amp;exclude);
<a name="l00973"></a>00973 
<a name="l00976"></a>00976     <span class="keyword">static</span> InstructionMap::const_iterator pattern3(<span class="keyword">const</span> <a class="code" href="classPartitioner.html#acff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a>&amp; <a class="code" href="classPartitioner.html#af9d5d92a9d9ca6a35ade7c5b3906ab97" title="Instruction cache, filled in by user or populated by disassembler.">insns</a>, InstructionMap::const_iterator first,
<a name="l00977"></a>00977                                                    <a class="code" href="classDisassembler.html#a7d930e04b0d619cb057ff0e5a559534b" title="An AddressSet contains virtual addresses (alternatively, relative virtual addresses) for such things ...">Disassembler::AddressSet</a> &amp;exclude);
<a name="l00978"></a>00978 <span class="preprocessor">#endif</span>
<a name="l00979"></a>00979 <span class="preprocessor"></span>    
<a name="l00980"></a>00980     
<a name="l00981"></a>00981 
<a name="l00982"></a>00982     <span class="comment">/*************************************************************************************************************************</span>
<a name="l00983"></a>00983 <span class="comment">     *                                                 Low-level Functions</span>
<a name="l00984"></a>00984 <span class="comment">     *</span>
<a name="l00985"></a>00985 <span class="comment">     * These are public because they might need to be called by the partitioner&#39;s instruction or address traversal callbacks,</span>
<a name="l00986"></a>00986 <span class="comment">     * and its often convenient to declare those functors outside any Partitioner subclass.</span>
<a name="l00987"></a>00987 <span class="comment">     *************************************************************************************************************************/</span>
<a name="l00988"></a>00988 <span class="keyword">public</span>:
<a name="l00989"></a>00989     <span class="comment">/* NOTE: Some of these are documented at their implementation because the documentation is more than what conveniently</span>
<a name="l00990"></a>00990 <span class="comment">     *       fits here. */</span>
<a name="l00991"></a><a class="code" href="structPartitioner_1_1AbandonFunctionDiscovery.html">00991</a>     <span class="keyword">struct </span><a class="code" href="structPartitioner_1_1AbandonFunctionDiscovery.html" title="Exception thrown to defer function block discovery.">AbandonFunctionDiscovery</a> {};                         
<a name="l00993"></a>00993     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a3d11541835dec7b94d67c6a23db908cd" title="Add an instruction to a basic block.">append</a>(<a class="code" href="structPartitioner_1_1BasicBlock.html" title="Represents a basic block within the Partitioner.">BasicBlock</a>*, <a class="code" href="classPartitioner_1_1Instruction.html" title="Holds an instruction along with some other information about the instruction.">Instruction</a>*);             
<a name="l00994"></a>00994     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a3d11541835dec7b94d67c6a23db908cd" title="Add an instruction to a basic block.">append</a>(<a class="code" href="structPartitioner_1_1BasicBlock.html" title="Represents a basic block within the Partitioner.">BasicBlock</a>*, <a class="code" href="structPartitioner_1_1DataBlock.html" title="Represents a region of static data within the address space being disassembled.">DataBlock</a>*, <span class="keywordtype">unsigned</span> reasons); <span class="comment">/* Add a data block to a basic block. */</span>
<a name="l00995"></a>00995     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a3d11541835dec7b94d67c6a23db908cd" title="Add an instruction to a basic block.">append</a>(<a class="code" href="structPartitioner_1_1Function.html" title="Represents a function within the Partitioner.">Function</a>*, <a class="code" href="structPartitioner_1_1BasicBlock.html" title="Represents a basic block within the Partitioner.">BasicBlock</a>*, <span class="keywordtype">unsigned</span> reasons, <span class="keywordtype">bool</span> keep=<span class="keyword">false</span>); <span class="comment">/* Append a basic block to a function */</span>
<a name="l00996"></a>00996     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a3d11541835dec7b94d67c6a23db908cd" title="Add an instruction to a basic block.">append</a>(<a class="code" href="structPartitioner_1_1Function.html" title="Represents a function within the Partitioner.">Function</a>*, <a class="code" href="structPartitioner_1_1DataBlock.html" title="Represents a region of static data within the address space being disassembled.">DataBlock</a>*, <span class="keywordtype">unsigned</span> reasons, <span class="keywordtype">bool</span> force=<span class="keyword">false</span>); <span class="comment">/* Append a data block to a function */</span>
<a name="l00997"></a>00997     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <span class="keyword">remove</span>(<a class="code" href="structPartitioner_1_1Function.html" title="Represents a function within the Partitioner.">Function</a>*, <a class="code" href="structPartitioner_1_1BasicBlock.html" title="Represents a basic block within the Partitioner.">BasicBlock</a>*);                <span class="comment">/* Remove a basic block from a function. */</span>
<a name="l00998"></a>00998     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <span class="keyword">remove</span>(<a class="code" href="structPartitioner_1_1Function.html" title="Represents a function within the Partitioner.">Function</a>*, <a class="code" href="structPartitioner_1_1DataBlock.html" title="Represents a region of static data within the address space being disassembled.">DataBlock</a>*);                 <span class="comment">/* Remove a data block from a function. */</span>
<a name="l00999"></a>00999     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <span class="keyword">remove</span>(<a class="code" href="structPartitioner_1_1BasicBlock.html" title="Represents a basic block within the Partitioner.">BasicBlock</a>*, <a class="code" href="structPartitioner_1_1DataBlock.html" title="Represents a region of static data within the address space being disassembled.">DataBlock</a>*);               <span class="comment">/* Remove association between basic block and data block. */</span>
<a name="l01000"></a>01000     <span class="keyword">virtual</span> <a class="code" href="structPartitioner_1_1BasicBlock.html" title="Represents a basic block within the Partitioner.">BasicBlock</a>* <a class="code" href="classPartitioner.html#a67b4f858bb93fcef7d4c24be86cd10f3" title="Finds a basic block containing the specified instruction address.">find_bb_containing</a>(<a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a>, <span class="keywordtype">bool</span> create=<span class="keyword">true</span>); <span class="comment">/* Find basic block containing instruction address */</span>
<a name="l01001"></a>01001     <span class="keyword">virtual</span> <a class="code" href="structPartitioner_1_1BasicBlock.html" title="Represents a basic block within the Partitioner.">BasicBlock</a>* <a class="code" href="classPartitioner.html#a67702e97dcbfb27fa18f6186fe30538a" title="Makes sure the block at the specified address exists.">find_bb_starting</a>(<a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a>, <span class="keywordtype">bool</span> create=<span class="keyword">true</span>);   <span class="comment">/* Find or create block starting at specified address */</span>
<a name="l01002"></a>01002     <span class="keyword">virtual</span> <a class="code" href="structPartitioner_1_1DataBlock.html" title="Represents a region of static data within the address space being disassembled.">DataBlock</a>* <a class="code" href="classPartitioner.html#a72fe4f436de7235fa06629810a5f1494" title="Finds (or creates) a data block.">find_db_starting</a>(<a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a>, <span class="keywordtype">size_t</span> size); <span class="comment">/* Find (or create if size&gt;0) a data block */</span>
<a name="l01003"></a>01003     <span class="keyword">virtual</span> <a class="code" href="classDisassembler.html#a7d930e04b0d619cb057ff0e5a559534b" title="An AddressSet contains virtual addresses (alternatively, relative virtual addresses) for such things ...">Disassembler::AddressSet</a> <a class="code" href="classPartitioner.html#ae2e3e09e5194ba8c87bc968b65b63e3c" title="Returns known successors of a basic block.">successors</a>(<a class="code" href="structPartitioner_1_1BasicBlock.html" title="Represents a basic block within the Partitioner.">BasicBlock</a>*, <span class="keywordtype">bool</span> *complete=NULL); <span class="comment">/* Calculates known successors */</span>
<a name="l01004"></a>01004     <span class="keyword">virtual</span> <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> <a class="code" href="classPartitioner.html#a5665dc5ef1c3aef6670dc6ab5d66815f" title="Returns call target if block could be a function call.">call_target</a>(<a class="code" href="structPartitioner_1_1BasicBlock.html" title="Represents a basic block within the Partitioner.">BasicBlock</a>*);               <span class="comment">/* Returns address if block could be a function call */</span>
<a name="l01005"></a>01005     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#aa1fd20a852585175fc0be71ef5bd97bd" title="Reduces the size of a basic block by truncating its list of instructions.">truncate</a>(<a class="code" href="structPartitioner_1_1BasicBlock.html" title="Represents a basic block within the Partitioner.">BasicBlock</a>*, <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a>);            <span class="comment">/* Remove instructions from the end of a basic block. */</span>
<a name="l01006"></a>01006     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a810bddfe83b19037ed710bdb98a34f50" title="Adds first basic block to empty function before we start discovering blocks of any other functions...">discover_first_block</a>(<a class="code" href="structPartitioner_1_1Function.html" title="Represents a function within the Partitioner.">Function</a>*);               <span class="comment">/* Adds first basic block to empty function to start discovery. */</span>
<a name="l01007"></a>01007     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a354aa1fce4dcbc80c99038829a3ddb76">discover_blocks</a>(<a class="code" href="structPartitioner_1_1Function.html" title="Represents a function within the Partitioner.">Function</a>*, <span class="keywordtype">unsigned</span> reason);   <span class="comment">/* Start to recursively discover blocks of a function. */</span>
<a name="l01008"></a>01008     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a354aa1fce4dcbc80c99038829a3ddb76">discover_blocks</a>(<a class="code" href="structPartitioner_1_1Function.html" title="Represents a function within the Partitioner.">Function</a>*, <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a>, <span class="keywordtype">unsigned</span> reason); <span class="comment">/* Recursively discovers blocks of a function. */</span>
<a name="l01009"></a>01009     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a815304b7ef093a74bc419662d54df49b" title="Detects functions before analyzing the CFG.">pre_cfg</a>(<a class="code" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *interp=NULL);     
<a name="l01010"></a>01010     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a19725656eaa83118d75bdd77c617cef4" title="Detect functions by analyzing the CFG.">analyze_cfg</a>(<a class="code" href="classSgAsmBlock.html#a94a08ed03be6bcd089f1106a0aa7e48c" title="Reasons why a basic block might have been assigned to a function.">SgAsmBlock::Reason</a>);               
<a name="l01011"></a>01011     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a48a2e4d8bd6d15fb31a0ae8e41a747a3" title="Detects functions after analyzing the CFG.">post_cfg</a>(<a class="code" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *interp=NULL);    
<a name="l01012"></a>01012     <span class="keyword">virtual</span> <a class="code" href="classSgAsmFunction.html">SgAsmFunction</a>* <a class="code" href="classPartitioner.html#a4018aada4c16434ec0895c86e65bc5ec" title="Builds the AST describing all the functions.">build_ast</a>(<a class="code" href="structPartitioner_1_1Function.html" title="Represents a function within the Partitioner.">Function</a>*);                
<a name="l01013"></a>01013     <span class="keyword">virtual</span> <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a>* <a class="code" href="classPartitioner.html#a4018aada4c16434ec0895c86e65bc5ec" title="Builds the AST describing all the functions.">build_ast</a>(<a class="code" href="structPartitioner_1_1BasicBlock.html" title="Represents a basic block within the Partitioner.">BasicBlock</a>*);                 
<a name="l01014"></a>01014     <span class="keyword">virtual</span> <a class="code" href="classSgAsmBlock.html">SgAsmBlock</a>* <a class="code" href="classPartitioner.html#a4018aada4c16434ec0895c86e65bc5ec" title="Builds the AST describing all the functions.">build_ast</a>(<a class="code" href="structPartitioner_1_1DataBlock.html" title="Represents a region of static data within the address space being disassembled.">DataBlock</a>*);                  
<a name="l01015"></a>01015     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classPartitioner.html#a6da761bf550bd07c05fa615f4091adba" title="Determines if a block pops the stack w/o returning.">pops_return_address</a>(<a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a>);              
<a name="l01016"></a>01016     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a8652c15bcdd9d9dca2efb2d9f865f519" title="Runs local block analyses if their cached results are invalid and caches the results.">update_analyses</a>(<a class="code" href="structPartitioner_1_1BasicBlock.html" title="Represents a basic block within the Partitioner.">BasicBlock</a>*);                  <span class="comment">/* Makes sure cached analysis results are current. */</span>
<a name="l01017"></a>01017     <span class="keyword">virtual</span> <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> <a class="code" href="classPartitioner.html#abd63242c67a32e6de5434d21956a01bf" title="Follow alias links in basic blocks.">canonic_block</a>(<a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a>);             
<a name="l01018"></a>01018     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classPartitioner.html#a9c333715d5d353bab9fd4f46ce2c2d8d" title="Returns true if basic block appears to end with a function call.">is_function_call</a>(<a class="code" href="structPartitioner_1_1BasicBlock.html" title="Represents a basic block within the Partitioner.">BasicBlock</a>*, <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a>*);   <span class="comment">/* True if basic block appears to call a function. */</span>
<a name="l01019"></a>01019     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classPartitioner.html#a64d3ebb83d085cd1709305c13a2bbd7d" title="Determines if function is a thunk.">is_thunk</a>(<a class="code" href="structPartitioner_1_1Function.html" title="Represents a function within the Partitioner.">Function</a>*);                           <span class="comment">/* True if function is a thunk. */</span>
<a name="l01020"></a>01020     <span class="keyword">virtual</span> <a class="code" href="structPartitioner_1_1Function.html" title="Represents a function within the Partitioner.">Function</a> *<a class="code" href="classPartitioner.html#acd1de02179852d54139e2f4eb366ebdc" title="Returns the function to which this data block is effectively assigned.">effective_function</a>(<a class="code" href="structPartitioner_1_1DataBlock.html" title="Represents a region of static data within the address space being disassembled.">DataBlock</a>*);           <span class="comment">/* Function to which a data block is currently bound. */</span>
<a name="l01021"></a>01021 
<a name="l01022"></a>01022     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#ae9e536212c2e5efdf21ad22993d5c888" title="Naive marking of CALL instruction targets as functions.">mark_call_insns</a>();                             
<a name="l01023"></a>01023     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#afd2b60293bc45d47e74befebde631533" title="Seeds partitioner with IPD configuration information.">mark_ipd_configuration</a>();                      
<a name="l01024"></a>01024     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a1f7de70089099ce3d31af5ed455fc9b7" title="Seeds functions for program entry points.">mark_entry_targets</a>(<a class="code" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a>*);       
<a name="l01025"></a>01025     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a167cda7ee682478117f8480d86815efc" title="Seeds functions for error handling frames.">mark_eh_frames</a>(<a class="code" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a>*);           
<a name="l01026"></a>01026     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a20bab02d75f2c49035e63dc029635698" title="Seeds functions that are dynamically linked via .plt.">mark_elf_plt_entries</a>(<a class="code" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a>*);     
<a name="l01027"></a>01027     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a5856443d8da3aeb540e193491619dab8" title="Seeds functions that correspond to function symbols.">mark_func_symbols</a>(<a class="code" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a>*);        
<a name="l01028"></a>01028     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a608c32001c0e56d18e41ce2d77976f9d" title="Seeds functions according to instruction patterns.">mark_func_patterns</a>();                          <span class="comment">/* Seeds functions according to instruction patterns */</span>
<a name="l01029"></a>01029     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a17cac3fb6a8a12bf633c70e4640728ff" title="Gives names to dynmaic linking trampolines for ELF.">name_plt_entries</a>(<a class="code" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a>*);         <span class="comment">/* Assign names to ELF PLT functions */</span>
<a name="l01030"></a>01030     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#adc7b9b7851ee14847eed8454619cb505" title="Gives names to dynamic linking thunks for PE.">name_import_entries</a>(<a class="code" href="classSgAsmGenericHeader.html">SgAsmGenericHeader</a>*);      <span class="comment">/* Assign names to PE import functions */</span>
<a name="l01031"></a>01031 
<a name="l01034"></a>01034     <span class="keyword">virtual</span> <span class="keywordtype">size_t</span> <a class="code" href="classPartitioner.html#a3a1386d81012e94a46184c4703fd9e40" title="Adds extents for all defined functions.">function_extent</a>(<a class="code" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">FunctionRangeMap</a> *extents);
<a name="l01035"></a>01035 
<a name="l01044"></a>01044     <span class="keyword">virtual</span> <span class="keywordtype">size_t</span> <a class="code" href="classPartitioner.html#a3a1386d81012e94a46184c4703fd9e40" title="Adds extents for all defined functions.">function_extent</a>(<a class="code" href="structPartitioner_1_1Function.html" title="Represents a function within the Partitioner.">Function</a>*,
<a name="l01045"></a>01045                                    <a class="code" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">FunctionRangeMap</a> *extents=NULL<span class="comment">/*in,out*/</span>,
<a name="l01046"></a>01046                                    <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> *lo_addr=NULL<span class="comment">/*out*/</span>, <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> *hi_addr=NULL<span class="comment">/*out*/</span>);
<a name="l01047"></a>01047 
<a name="l01053"></a>01053     <span class="keyword">virtual</span> <span class="keywordtype">size_t</span> <a class="code" href="classPartitioner.html#ab887328bc3f2afab215f8c0e7e5603c9" title="Returns information about the datablock addresses.">datablock_extent</a>(<a class="code" href="structPartitioner_1_1DataBlock.html" title="Represents a region of static data within the address space being disassembled.">DataBlock</a>*,
<a name="l01054"></a>01054                                     <a class="code" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">DataRangeMap</a> *extents=NULL<span class="comment">/*in,out*/</span>,
<a name="l01055"></a>01055                                     <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> *lo_addr=NULL<span class="comment">/*out*/</span>, <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> *hi_addr=NULL<span class="comment">/*out*/</span>);
<a name="l01056"></a>01056 
<a name="l01059"></a>01059     <span class="keyword">virtual</span> <span class="keywordtype">size_t</span> <a class="code" href="classPartitioner.html#ab887328bc3f2afab215f8c0e7e5603c9" title="Returns information about the datablock addresses.">datablock_extent</a>(<a class="code" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">DataRangeMap</a> *extent<span class="comment">/*in,out*/</span>);
<a name="l01060"></a>01060 
<a name="l01063"></a>01063     <span class="keyword">virtual</span> <span class="keywordtype">size_t</span> <a class="code" href="classPartitioner.html#aaf310f1d4a77ace2f3b3ecc05e376c20" title="Adds padding datablocks to extent.">padding_extent</a>(<a class="code" href="classRangeMap.html" title="A container of ranges, somewhat like a set.">DataRangeMap</a> *extent<span class="comment">/*in,out*/</span>);
<a name="l01064"></a>01064 
<a name="l01069"></a>01069     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classPartitioner.html#a8e3fb4de9cbbd0a0bba2c3392f3361f9" title="Returns an indication of whether a function is contiguous.">is_contiguous</a>(<a class="code" href="structPartitioner_1_1Function.html" title="Represents a function within the Partitioner.">Function</a>*, <span class="keywordtype">bool</span> strict=<span class="keyword">false</span>);
<a name="l01070"></a>01070 
<a name="l01080"></a>01080     <span class="keyword">static</span> <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> <a class="code" href="classPartitioner.html#aa4ec978230e19cc6bd34d60be7801452" title="Return the virtual address that holds the branch target for an indirect branch.">get_indirection_addr</a>(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a>*);
<a name="l01081"></a>01081 
<a name="l01083"></a>01083     <span class="keyword">static</span> <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> <a class="code" href="classPartitioner.html#a36e3aa4734377dacea3614c7dd5fd5e6" title="Returns the integer value of a value expression since there&#39;s no virtual method for doing this...">value_of</a>(<a class="code" href="classSgAsmValueExpression.html" title="Assembly operands that contain numeric values.">SgAsmValueExpression</a>*);
<a name="l01084"></a>01084 
<a name="l01088"></a>01088     <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a044f608ba9d2cf1d4b9d22b2c53ccea9" title="Conditionally prints a progress report.">progress</a>(FILE*, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...) const __attribute__((format(printf, 3, 4)));
<a name="l01089"></a>01089 
<a name="l01093"></a>01093     virtual <span class="keywordtype">size_t</span> <a class="code" href="classPartitioner.html#a50ae683bbc187c44dc13dcac778fd502" title="Splits thunks off of the start of functions.">detach_thunks</a>();
<a name="l01094"></a>01094 
<a name="l01100"></a>01100     virtual <span class="keywordtype">bool</span> <a class="code" href="classPartitioner.html#ab6d3411d68e7aa9a994850b672f01af0" title="Splits one thunk off the start of a function if possible.">detach_thunk</a>(<a class="code" href="structPartitioner_1_1Function.html" title="Represents a function within the Partitioner.">Function</a>*);
<a name="l01101"></a>01101 
<a name="l01105"></a>01105     virtual <span class="keywordtype">void</span> <a class="code" href="classPartitioner.html#a6280eae4362e64e6b5df4ed55fc17c91" title="Adjusts ownership of padding data blocks.">adjust_padding</a>();
<a name="l01106"></a>01106 
<a name="l01107"></a>01107     <span class="comment">/*************************************************************************************************************************</span>
<a name="l01108"></a>01108 <span class="comment">     *                                   IPD Parser for initializing the Partitioner</span>
<a name="l01109"></a>01109 <span class="comment">     *************************************************************************************************************************/</span>
<a name="l01110"></a>01110 public:
<a name="l01111"></a>01111 
<a name="l01276"></a><a class="code" href="classPartitioner_1_1IPDParser.html">01276</a>     class <a class="code" href="classPartitioner_1_1IPDParser.html" title="This is the parser for the instruction partitioning data (IPD) files.">IPDParser</a> {
<a name="l01277"></a>01277     <span class="keyword">private</span>:
<a name="l01278"></a><a class="code" href="classPartitioner_1_1IPDParser.html#a51f92296196be6d6c2d3ef1515f870dd">01278</a>         <a class="code" href="classPartitioner.html" title="Partitions instructions into basic blocks and functions.">Partitioner</a> *<a class="code" href="classPartitioner_1_1IPDParser.html#a51f92296196be6d6c2d3ef1515f870dd" title="Partitioner to be initialized.">partitioner</a>;               
<a name="l01279"></a><a class="code" href="classPartitioner_1_1IPDParser.html#a15a2d4db13147114192c939159020be4">01279</a>         <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classPartitioner_1_1IPDParser.html#a15a2d4db13147114192c939159020be4" title="Input to be parsed.">input</a>;                      
<a name="l01280"></a><a class="code" href="classPartitioner_1_1IPDParser.html#abbac81ec3315c410bc06e8cc5c31688c">01280</a>         <span class="keywordtype">size_t</span> <a class="code" href="classPartitioner_1_1IPDParser.html#abbac81ec3315c410bc06e8cc5c31688c" title="Length of input, not counting NUL termination (if any).">len</a>;                             
<a name="l01281"></a><a class="code" href="classPartitioner_1_1IPDParser.html#a1aeda08e05b72a1646ce308dde982d2e">01281</a>         std::string <a class="code" href="classPartitioner_1_1IPDParser.html#a1aeda08e05b72a1646ce308dde982d2e" title="Optional name of input (usually a file name).">input_name</a>;                 
<a name="l01282"></a><a class="code" href="classPartitioner_1_1IPDParser.html#a54eeee743e0eeb8a16703918dcdf5f0d">01282</a>         <span class="keywordtype">size_t</span> <a class="code" href="classPartitioner_1_1IPDParser.html#a54eeee743e0eeb8a16703918dcdf5f0d" title="Current parse position w.r.t.">at</a>;                              
<a name="l01283"></a><a class="code" href="classPartitioner_1_1IPDParser.html#ac5a37a339ea4e1ded645e5b2df437832">01283</a>         Function *<a class="code" href="classPartitioner_1_1IPDParser.html#ac5a37a339ea4e1ded645e5b2df437832" title="Non-null when inside a FuncBody nonterminal.">cur_func</a>;                     
<a name="l01284"></a><a class="code" href="classPartitioner_1_1IPDParser.html#adb53b0b7475e5c86c347329f52364432">01284</a>         <a class="code" href="structPartitioner_1_1BlockConfig.html" title="Basic block configuration information.">BlockConfig</a> *<a class="code" href="classPartitioner_1_1IPDParser.html#adb53b0b7475e5c86c347329f52364432" title="Non-null when inside a BlockBody nonterminal.">cur_block</a>;                 
<a name="l01286"></a>01286     <span class="keyword">public</span>:
<a name="l01287"></a><a class="code" href="classPartitioner_1_1IPDParser.html#a39c5a87225d5ed405f2c4a66bc4de867">01287</a>         IPDParser(<a class="code" href="classPartitioner.html" title="Partitions instructions into basic blocks and functions.">Partitioner</a> *p, <span class="keyword">const</span> <span class="keywordtype">char</span> *input, <span class="keywordtype">size_t</span> len, <span class="keyword">const</span> std::string &amp;input_name=<span class="stringliteral">&quot;&quot;</span>)
<a name="l01288"></a>01288             : partitioner(p), input(input), len(len), input_name(input_name), at(0), cur_func(NULL), cur_block(NULL) {}
<a name="l01289"></a>01289 
<a name="l01290"></a><a class="code" href="classPartitioner_1_1IPDParser_1_1Exception.html">01290</a>         <span class="keyword">class </span><a class="code" href="classPartitioner_1_1IPDParser_1_1Exception.html">Exception</a> {                      
<a name="l01291"></a>01291         <span class="keyword">public</span>:
<a name="l01292"></a><a class="code" href="classPartitioner_1_1IPDParser_1_1Exception.html#a252809f9c9eff5d5fada8e8a8df84a5a">01292</a>             <a class="code" href="structPartitioner_1_1Exception.html#ae938e562c80566bc037368d8e611fbe2">Exception</a>(<span class="keyword">const</span> std::string &amp;<a class="code" href="structPartitioner_1_1Exception.html#a04394b7419f91ce0f393122abea33df8">mesg</a>)
<a name="l01293"></a>01293                 : lnum(0), mesg(mesg) {}
<a name="l01294"></a><a class="code" href="classPartitioner_1_1IPDParser_1_1Exception.html#a72ce9ff80a16f7354cdca13dfc3d195f">01294</a>             <a class="code" href="structPartitioner_1_1Exception.html#ae938e562c80566bc037368d8e611fbe2">Exception</a>(<span class="keyword">const</span> std::string &amp;<a class="code" href="structPartitioner_1_1Exception.html#a04394b7419f91ce0f393122abea33df8">mesg</a>, <span class="keyword">const</span> std::string &amp;<a class="code" href="Cxx__Grammar_8h.html#aaf1bd07e95aeff0f585394fccaf479ab">name</a>, <span class="keywordtype">unsigned</span> lnum=0)
<a name="l01295"></a>01295                 : name(name), lnum(lnum), mesg(mesg) {}
<a name="l01296"></a>01296             std::string format() <span class="keyword">const</span>;         
<a name="l01297"></a>01297             <span class="keyword">friend</span> std::ostream&amp; <a class="code" href="structPartitioner_1_1Exception.html#a3a99c7cd470628c0af113622ae26a6a1">operator&lt;&lt;</a>(std::ostream&amp;, <span class="keyword">const</span> <a class="code" href="classPartitioner_1_1IPDParser_1_1Exception.html">Exception</a> &amp;e);
<a name="l01298"></a>01298 
<a name="l01299"></a><a class="code" href="classPartitioner_1_1IPDParser_1_1Exception.html#a4039361fb2f60ebc57092669052d1d13">01299</a>             std::string <a class="code" href="classPartitioner_1_1IPDParser_1_1Exception.html#a4039361fb2f60ebc57092669052d1d13" title="Optional name of input.">name</a>;                   
<a name="l01300"></a><a class="code" href="classPartitioner_1_1IPDParser_1_1Exception.html#afb7369dbbfb3bc2f42360ba4881ffdc2">01300</a>             <span class="keywordtype">unsigned</span> <a class="code" href="classPartitioner_1_1IPDParser_1_1Exception.html#afb7369dbbfb3bc2f42360ba4881ffdc2" title="Line number (1-origin); zero if unknown.">lnum</a>;                      
<a name="l01301"></a><a class="code" href="classPartitioner_1_1IPDParser_1_1Exception.html#a8811d1a40707b778c2bae094194524e7">01301</a>             std::string <a class="code" href="classPartitioner_1_1IPDParser_1_1Exception.html#a8811d1a40707b778c2bae094194524e7" title="Error message.">mesg</a>;                   
<a name="l01302"></a>01302         };
<a name="l01303"></a>01303 
<a name="l01304"></a>01304         <span class="keywordtype">void</span> parse();                           
<a name="l01307"></a>01307         <span class="comment">/*************************************************************************************************************************</span>
<a name="l01308"></a>01308 <span class="comment">         * Lexical analysis functions.</span>
<a name="l01309"></a>01309 <span class="comment">         *************************************************************************************************************************/</span>
<a name="l01310"></a>01310     <span class="keyword">private</span>:
<a name="l01311"></a>01311         <span class="keywordtype">void</span> skip_space();
<a name="l01312"></a>01312 
<a name="l01313"></a>01313         <span class="comment">/* The is_* functions return true if the next token after white space and comments is of the specified type. */</span>
<a name="l01314"></a>01314         <span class="keywordtype">bool</span> is_terminal(<span class="keyword">const</span> <span class="keywordtype">char</span> *to_match);
<a name="l01315"></a>01315         <span class="keywordtype">bool</span> is_symbol(<span class="keyword">const</span> <span class="keywordtype">char</span> *to_match);
<a name="l01316"></a>01316         <span class="keywordtype">bool</span> is_string();
<a name="l01317"></a>01317         <span class="keywordtype">bool</span> is_number();
<a name="l01318"></a>01318 
<a name="l01319"></a>01319         <span class="comment">/* The match_* functions skip over white space and comments and attempt to match (and consume) the next token. If the next</span>
<a name="l01320"></a>01320 <span class="comment">         * token is not as expected then an exception is thrown. */</span>
<a name="l01321"></a>01321         <span class="keywordtype">void</span> match_terminal(<span class="keyword">const</span> <span class="keywordtype">char</span> *to_match);
<a name="l01322"></a>01322         <span class="keywordtype">void</span> match_symbol(<span class="keyword">const</span> <span class="keywordtype">char</span> *to_match);
<a name="l01323"></a>01323         std::string match_symbol();
<a name="l01324"></a>01324         std::string match_string();
<a name="l01325"></a>01325         <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> match_number();
<a name="l01326"></a>01326         std::string match_asm();        <span class="comment">/* assembly code inside nested curly braces */</span>
<a name="l01327"></a>01327 
<a name="l01328"></a>01328 
<a name="l01329"></a>01329         <span class="comment">/*************************************************************************************************************************</span>
<a name="l01330"></a>01330 <span class="comment">         * Parsing functions (see rules above). Each returns true if the construct is present and was parsed, false if the</span>
<a name="l01331"></a>01331 <span class="comment">         * construct was not present. They throw an exception if the construct was partially present but an error occurred during</span>
<a name="l01332"></a>01332 <span class="comment">         * parsing.</span>
<a name="l01333"></a>01333 <span class="comment">         *************************************************************************************************************************/</span>
<a name="l01334"></a>01334     <span class="keyword">private</span>:
<a name="l01335"></a>01335         <span class="keywordtype">bool</span> parse_File();
<a name="l01336"></a>01336         <span class="keywordtype">bool</span> parse_Declaration();
<a name="l01337"></a>01337         <span class="keywordtype">bool</span> parse_FuncDecl();
<a name="l01338"></a>01338         <span class="keywordtype">bool</span> parse_FuncBody();
<a name="l01339"></a>01339         <span class="keywordtype">bool</span> parse_FuncStmtList();
<a name="l01340"></a>01340         <span class="keywordtype">bool</span> parse_FuncStmt();
<a name="l01341"></a>01341         <span class="keywordtype">bool</span> parse_ReturnSpec();
<a name="l01342"></a>01342         <span class="keywordtype">bool</span> parse_BlockDecl();
<a name="l01343"></a>01343         <span class="keywordtype">bool</span> parse_BlockBody();
<a name="l01344"></a>01344         <span class="keywordtype">bool</span> parse_BlockStmtList();
<a name="l01345"></a>01345         <span class="keywordtype">bool</span> parse_BlockStmt();
<a name="l01346"></a>01346         <span class="keywordtype">bool</span> parse_Alias();
<a name="l01347"></a>01347         <span class="keywordtype">bool</span> parse_Successors();
<a name="l01348"></a>01348     };
<a name="l01349"></a>01349 
<a name="l01350"></a>01350     <span class="comment">/*************************************************************************************************************************</span>
<a name="l01351"></a>01351 <span class="comment">     *                                                     Data Members</span>
<a name="l01352"></a>01352 <span class="comment">     *</span>
<a name="l01353"></a>01353 <span class="comment">     * These are public so they can be accessed by user-defined traversal callbacks that might be declared outside any</span>
<a name="l01354"></a>01354 <span class="comment">     * Partitioner subclass.</span>
<a name="l01355"></a>01355 <span class="comment">     *************************************************************************************************************************/</span>
<a name="l01356"></a>01356 <span class="keyword">public</span>:
<a name="l01357"></a><a class="code" href="classPartitioner.html#a320e02804f0d9ae5bc55e1ba26791a72">01357</a>     <a class="code" href="classDisassembler.html" title="Virtual base class for instruction disassemblers.">Disassembler</a> *<a class="code" href="classPartitioner.html#a320e02804f0d9ae5bc55e1ba26791a72" title="Optional disassembler to call when an instruction is needed.">disassembler</a>;                         
<a name="l01358"></a><a class="code" href="classPartitioner.html#af9d5d92a9d9ca6a35ade7c5b3906ab97">01358</a>     <a class="code" href="classPartitioner.html#acff82cb76be01d1207e5653e6ef2c5c0">InstructionMap</a> <a class="code" href="classPartitioner.html#af9d5d92a9d9ca6a35ade7c5b3906ab97" title="Instruction cache, filled in by user or populated by disassembler.">insns</a>;                               
<a name="l01359"></a><a class="code" href="classPartitioner.html#aa8aa1ec02714f0608e72147f2dee7ffc">01359</a>     <a class="code" href="classMemoryMap.html" title="A MemoryMap is an efficient mapping from virtual addresses to source bytes.">MemoryMap</a> *<a class="code" href="classPartitioner.html#aa8aa1ec02714f0608e72147f2dee7ffc" title="Memory map used for disassembly if disassembler is present.">map</a>;                                     
<a name="l01360"></a><a class="code" href="classPartitioner.html#a0b160d2ed1a5b32606e0deaf4c8cbb43">01360</a>     <a class="code" href="classMemoryMap.html" title="A MemoryMap is an efficient mapping from virtual addresses to source bytes.">MemoryMap</a> <a class="code" href="classPartitioner.html#a0b160d2ed1a5b32606e0deaf4c8cbb43" title="The read-only parts of &#39;map&#39;, used for insn semantics mem reads.">ro_map</a>;                                   
<a name="l01361"></a><a class="code" href="classPartitioner.html#a44a78932a6c3307dbdd9d9327bbb3eba">01361</a>     <a class="code" href="classDisassembler.html#a30c51578d70dfc05fb46047867ceadcd" title="The BadMap is a mapping from (absolute) virtual address to information about a failed disassembly att...">Disassembler::BadMap</a> <a class="code" href="classPartitioner.html#a44a78932a6c3307dbdd9d9327bbb3eba" title="Captured disassembler exceptions.">bad_insns</a>;                     
<a name="l01363"></a><a class="code" href="classPartitioner.html#a1f1a02cff90220dd026d8a344404fbea">01363</a>     <a class="code" href="classPartitioner.html#aa3a62d239fd07ca47ffc37dd21b74006">BasicBlocks</a> <a class="code" href="classPartitioner.html#a1f1a02cff90220dd026d8a344404fbea" title="All known basic blocks.">basic_blocks</a>;                           
<a name="l01364"></a><a class="code" href="classPartitioner.html#a85fdfbc700ab9b3eaf1a1fa77c53c216">01364</a>     <a class="code" href="classPartitioner.html#ad68aee879b03b498c5d988d7fdfd6ae8">Functions</a> <a class="code" href="classPartitioner.html#a85fdfbc700ab9b3eaf1a1fa77c53c216" title="All known functions, pending and complete.">functions</a>;                                
<a name="l01366"></a><a class="code" href="classPartitioner.html#ab8b08dc01aab15b7ae2dff4af899046f">01366</a>     <a class="code" href="classPartitioner.html#ac9034b33e56a9e1d2e95dcd9c97cf431">DataBlocks</a> <a class="code" href="classPartitioner.html#ab8b08dc01aab15b7ae2dff4af899046f" title="Blocks that point to static data.">data_blocks</a>;                             
<a name="l01368"></a><a class="code" href="classPartitioner.html#a61a820e23e3d57c012d0928aa9c4d1a2">01368</a>     <span class="keywordtype">unsigned</span> <a class="code" href="classPartitioner.html#a61a820e23e3d57c012d0928aa9c4d1a2" title="Bit mask of SgAsmFunction::FunctionReason bits.">func_heuristics</a>;                           
<a name="l01369"></a><a class="code" href="classPartitioner.html#ae8ccefb002c5a4bea6abc98c226d19d6">01369</a>     std::vector&lt;FunctionDetector&gt; <a class="code" href="classPartitioner.html#ae8ccefb002c5a4bea6abc98c226d19d6" title="List of user-defined function detection methods.">user_detectors</a>;       
<a name="l01371"></a><a class="code" href="classPartitioner.html#a7ea39de5e72216dbece1d9f3b9c79f8f">01371</a>     FILE *<a class="code" href="classPartitioner.html#a7ea39de5e72216dbece1d9f3b9c79f8f" title="Stream where diagnistics are sent (or null).">debug</a>;                                        
<a name="l01372"></a><a class="code" href="classPartitioner.html#aa89d8e06b1a855108422287a46b63b04">01372</a>     <span class="keywordtype">bool</span> <a class="code" href="classPartitioner.html#aa89d8e06b1a855108422287a46b63b04" title="Allow basic blocks to be discontiguous in virtual memory.">allow_discont_blocks</a>;                          
<a name="l01373"></a><a class="code" href="classPartitioner.html#ae4d5b142571b09b4cb8e77016991d3d0">01373</a>     <a class="code" href="classPartitioner.html#af15dc59805f5188b3a9a91f2a9906ca3">BlockConfigMap</a> <a class="code" href="classPartitioner.html#ae4d5b142571b09b4cb8e77016991d3d0" title="IPD configuration info for basic blocks.">block_config</a>;                        
<a name="l01375"></a><a class="code" href="classPartitioner.html#a2663919047a75925b65a999ab6ea2f40">01375</a>     <span class="keyword">static</span> time_t <a class="code" href="classPartitioner.html#a2663919047a75925b65a999ab6ea2f40" title="Minimum interval between progress reports.">progress_interval</a>;                    
<a name="l01376"></a><a class="code" href="classPartitioner.html#a868d4534cf2da160c4ed12cb304323c9">01376</a>     <span class="keyword">static</span> time_t <a class="code" href="classPartitioner.html#a868d4534cf2da160c4ed12cb304323c9" title="Time of last report, or zero if no report has been generated.">progress_time</a>;                        
<a name="l01377"></a><a class="code" href="classPartitioner.html#a2b8e2de19780bf27ea1ab31b1b20f51a">01377</a>     <span class="keyword">static</span> FILE *<a class="code" href="classPartitioner.html#a2b8e2de19780bf27ea1ab31b1b20f51a" title="File to which reports are made.">progress_file</a>;                         
<a name="l01379"></a>01379 <span class="keyword">public</span>:
<a name="l01380"></a><a class="code" href="classPartitioner.html#a7e4a76ae7ab4113b2ec7acf9093c3810">01380</a>     <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a> <a class="code" href="classPartitioner.html#a7e4a76ae7ab4113b2ec7acf9093c3810">NO_TARGET</a> = (<a class="code" href="rosedefs_8h.html#a03b4aab6bc70ede394422915678b18df">rose_addr_t</a>)-1;
<a name="l01381"></a>01381 };
<a name="l01382"></a>01382 
<a name="l01383"></a>01383 <span class="preprocessor">#endif</span>
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="Partitioner_8h.html">Partitioner.h</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Thu Dec 1 2011 16:31:43 for ROSE by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
