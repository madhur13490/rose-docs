<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: yicesParserLib.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>yicesParserLib.h</h1><a href="yicesParserLib_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00002"></a>00002 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00003"></a>00003 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &lt;err.h&gt;</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &lt;<a class="code" href="SgGraphTemplate_8h.html">SgGraphTemplate.h</a>&gt;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;<a class="code" href="graphProcessing_8h.html">graphProcessing.h</a>&gt;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &lt;<a class="code" href="staticCFG_8h.html">staticCFG.h</a>&gt;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &lt;yices_c.h&gt;</span>
<a name="l00009"></a>00009 <span class="comment">/* Testing the graph traversal mechanism now implementing in AstProcessing.h (inside src/midend/astProcessing/)*/</span>
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 
<a name="l00012"></a>00012 <span class="keyword">using namespace </span>std;
<a name="l00013"></a>00013 <span class="keyword">using namespace </span>boost;
<a name="l00014"></a><a class="code" href="yicesParserLib_8h.html#ec58e468363518c3dd79045de7ae1fa7">00014</a> <span class="keywordtype">int</span> <a class="code" href="yicesParserLib_8h.html#ec58e468363518c3dd79045de7ae1fa7">FORLOOPS</a>;
<a name="l00015"></a><a class="code" href="yicesParserLib_8h.html#8ee962f3a476a38b126c24b0b06de591">00015</a> <span class="keywordtype">bool</span> <a class="code" href="yicesParserLib_8h.html#8ee962f3a476a38b126c24b0b06de591">inconsistent</a>;
<a name="l00016"></a>00016 yices_expr <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(vector&lt;SgGraphNode*&gt; expr, yices_context&amp; ctx);
<a name="l00017"></a><a class="code" href="yicesParserLib_8h.html#4e86b11357a2d99aa38a756cbc07d085">00017</a> <span class="keywordtype">int</span> <a class="code" href="yicesParserLib_8h.html#4e86b11357a2d99aa38a756cbc07d085">qst</a>;
<a name="l00018"></a>00018 
<a name="l00019"></a><a class="code" href="yicesParserLib_8h.html#03ae8d9960ef4d518b7f38a6e5e18a40">00019</a> <span class="keyword">typedef</span> <a class="code" href="SgGraphTemplate_8h.html#66b50e592d5aefbd7d9950d9742731fe">myGraph</a> <a class="code" href="yicesParserLib_8h.html#03ae8d9960ef4d518b7f38a6e5e18a40">CFGforT</a>;
<a name="l00020"></a><a class="code" href="yicesParserLib_8h.html#ecc8aa7e3d5e014159a274d129d468f8">00020</a> <span class="keywordtype">bool</span> <a class="code" href="yicesParserLib_8h.html#ecc8aa7e3d5e014159a274d129d468f8">unknown_flag</a>;
<a name="l00021"></a><a class="code" href="yicesParserLib_8h.html#b045f2a580863d59bb16abe16d0f586f">00021</a> std::map&lt;SgInitializedName*, yices_var_decl&gt; <a class="code" href="yicesParserLib_8h.html#b045f2a580863d59bb16abe16d0f586f">unknowns</a>;
<a name="l00022"></a><a class="code" href="yicesParserLib_8h.html#6cbb91bd6acaee78621ab5353ccbd78c">00022</a> std::map&lt;yices_var_decl, SgInitializedName*&gt; <a class="code" href="yicesParserLib_8h.html#6cbb91bd6acaee78621ab5353ccbd78c">IName</a>;
<a name="l00023"></a><a class="code" href="yicesParserLib_8h.html#19d33e1e3b620862dfc2dd0d05c838ba">00023</a> std::vector&lt;yices_var_decl&gt; <a class="code" href="yicesParserLib_8h.html#19d33e1e3b620862dfc2dd0d05c838ba">unknownvdeclis</a>;
<a name="l00024"></a><a class="code" href="yicesParserLib_8h.html#99ae78e96160b26ce175394c6deb89cb">00024</a> <span class="keywordtype">bool</span> <a class="code" href="yicesParserLib_8h.html#99ae78e96160b26ce175394c6deb89cb">usingNots</a>;
<a name="l00025"></a><a class="code" href="yicesParserLib_8h.html#2191c6072731519cf2f129aa28b6268b">00025</a> std::map&lt;SgInitializedName*, std::vector&lt;int&gt; &gt; <a class="code" href="yicesParserLib_8h.html#2191c6072731519cf2f129aa28b6268b">notMap</a>;
<a name="l00026"></a>00026 <span class="comment">//std::vector&lt;yices_var_decl&gt; unknowndecls;</span>
<a name="l00027"></a>00027 
<a name="l00028"></a><a class="code" href="yicesParserLib_8h.html#aea0b2d639e35a0c7ff7daf512abdaa2">00028</a> std::map&lt;std::vector&lt;SgGraphNode*&gt;, std::set&lt;int&gt; &gt; <a class="code" href="yicesParserLib_8h.html#aea0b2d639e35a0c7ff7daf512abdaa2">calledMap</a>;
<a name="l00029"></a><a class="code" href="yicesParserLib_8h.html#2253cf621c18f487291341f164ffdc57">00029</a> std::set&lt;SgNode*&gt; <a class="code" href="yicesParserLib_8h.html#2253cf621c18f487291341f164ffdc57">unknownFunctions</a>;
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 string <a class="code" href="yicesParserLib_8h.html#154c30051e33d53ed0f6131c3f8460e5">getGraphNodeType</a>(<a class="code" href="classSgGraphNode.html">SgGraphNode</a>* sn);
<a name="l00032"></a><a class="code" href="classvisitorTraversalFunc.html">00032</a> <span class="keyword">class </span><a class="code" href="classvisitorTraversalFunc.html">visitorTraversalFunc</a> : <span class="keyword">public</span> <a class="code" href="classSgGraphTraversal.html">SgGraphTraversal</a>&lt;CFGforT&gt;
<a name="l00033"></a>00033    {
<a name="l00034"></a>00034      <span class="keyword">public</span>:
<a name="l00035"></a><a class="code" href="classvisitorTraversalFunc.html#58b2e6c08614b098a250815d703ef991">00035</a>           <span class="keywordtype">int</span> <a class="code" href="classvisitorTraversalFunc.html#58b2e6c08614b098a250815d703ef991">tltnodes</a>;
<a name="l00036"></a><a class="code" href="classvisitorTraversalFunc.html#1aa18a3ac1c45fdd7efb7f7626fa5664">00036</a>           std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; <a class="code" href="classvisitorTraversalFunc.html#1aa18a3ac1c45fdd7efb7f7626fa5664">vpaths</a>;
<a name="l00037"></a>00037           <span class="keywordtype">void</span> <a class="code" href="classvisitorTraversalFunc.html#993f8eb5df98c9a31aee626786c5af12">analyzePath</a>(std::vector&lt;VertexID&gt;&amp; pth);
<a name="l00038"></a><a class="code" href="classvisitorTraversalFunc.html#bcd055ed9bce0880b81e4f00b3bd013d">00038</a>           <a class="code" href="yicesParserLib_8h.html#03ae8d9960ef4d518b7f38a6e5e18a40">CFGforT</a>* <a class="code" href="classvisitorTraversalFunc.html#bcd055ed9bce0880b81e4f00b3bd013d">orig</a>;
<a name="l00039"></a>00039           <span class="comment">//std::map&lt;SgVariableSymbol, string&gt; nameOf;</span>
<a name="l00040"></a>00040           <span class="comment">//int nvars;</span>
<a name="l00041"></a>00041    };
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 
<a name="l00044"></a><a class="code" href="classvisitorTraversalFunc.html#993f8eb5df98c9a31aee626786c5af12">00044</a> <span class="keywordtype">void</span> <a class="code" href="classvisitorTraversalFunc.html#993f8eb5df98c9a31aee626786c5af12">visitorTraversalFunc::analyzePath</a>(std::vector&lt;VertexID&gt;&amp; pathR) {
<a name="l00045"></a>00045     <span class="comment">//ROSE_ASSERT(pathcheck.find(pathR) == pathcheck.end());</span>
<a name="l00046"></a>00046     <span class="comment">//pathcheck.insert(pathR);</span>
<a name="l00047"></a>00047 
<a name="l00048"></a>00048     <span class="comment">//std::cout &lt;&lt; "funcAnalyze" &lt;&lt; std::endl;</span>
<a name="l00049"></a>00049     std::vector&lt;SgGraphNode*&gt; path;
<a name="l00050"></a>00050     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; pathR.size(); j++) {
<a name="l00051"></a>00051        <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* R = (*<a class="code" href="classvisitorTraversalFunc.html#bcd055ed9bce0880b81e4f00b3bd013d">orig</a>)[pathR[j]].sg;
<a name="l00052"></a>00052        path.push_back(R);
<a name="l00053"></a>00053     }
<a name="l00054"></a>00054     ROSE_ASSERT(<a class="code" href="Cxx__Grammar_8h.html#5cf651a4651efb47c056d36981fa552b">isSgFunctionDefinition</a>(path[0]-&gt;get_SgNode()));
<a name="l00055"></a>00055     <span class="keywordtype">int</span> curr = 0;
<a name="l00056"></a>00056     <span class="comment">//std::cout &lt;&lt; "a vpath" &lt;&lt; std::endl;</span>
<a name="l00057"></a>00057    <span class="comment">// for (int q = 0; q &lt; path.size(); q++) {</span>
<a name="l00058"></a>00058    <span class="comment">//     std::cout &lt;&lt; getGraphNodeType(path[q]) &lt;&lt; std::endl;</span>
<a name="l00059"></a>00059    <span class="comment">// }</span>
<a name="l00060"></a>00060    <span class="comment">// std::cout &lt;&lt; "\n\n";</span>
<a name="l00061"></a>00061     <span class="keywordflow">if</span> (path.back()-&gt;get_SgNode() == path.front()-&gt;get_SgNode()) {
<a name="l00062"></a>00062     <a class="code" href="classvisitorTraversalFunc.html#1aa18a3ac1c45fdd7efb7f7626fa5664">vpaths</a>.push_back(path);
<a name="l00063"></a>00063     }
<a name="l00064"></a>00064 }
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 
<a name="l00067"></a><a class="code" href="yicesParserLib_8h.html#4856956a3abce81ef0edec0d2191cb0f">00067</a> std::map&lt;SgNode*, std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; &gt; <a class="code" href="yicesParserLib_8h.html#4856956a3abce81ef0edec0d2191cb0f">FuncPathMap</a>;
<a name="l00068"></a>00068 
<a name="l00069"></a><a class="code" href="yicesParserLib_8h.html#9427d97d66f016a61cc07e07c99c9a4e">00069</a> <span class="keywordtype">bool</span> <a class="code" href="yicesParserLib_8h.html#9427d97d66f016a61cc07e07c99c9a4e">forFlag</a>;
<a name="l00070"></a>00070 
<a name="l00071"></a><a class="code" href="yicesParserLib_8h.html#e8f6d2fd6490d3153cb4133bf183a404">00071</a> <span class="keywordtype">int</span> <a class="code" href="yicesParserLib_8h.html#e8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l00072"></a><a class="code" href="yicesParserLib_8h.html#d9c55e63216a3f4b4d8f344149a3646b">00072</a> std::map&lt;SgName, string&gt; <a class="code" href="yicesParserLib_8h.html#d9c55e63216a3f4b4d8f344149a3646b">nameOf</a>;
<a name="l00073"></a><a class="code" href="yicesParserLib_8h.html#cf72a788e5ca240904eed58d8f702e85">00073</a> <span class="keywordtype">bool</span> <a class="code" href="yicesParserLib_8h.html#cf72a788e5ca240904eed58d8f702e85">noAssert</a>;
<a name="l00074"></a><a class="code" href="yicesParserLib_8h.html#f7fd4cdab60eb7b0f657fa95a0500b38">00074</a> std::map&lt;SgNode*, int&gt; <a class="code" href="yicesParserLib_8h.html#f7fd4cdab60eb7b0f657fa95a0500b38">forsts</a>;
<a name="l00075"></a>00075 
<a name="l00076"></a><a class="code" href="yicesParserLib_8h.html#de5bf9ed247e18d2b1af6d97d13ba523">00076</a> std::map&lt;int, std::vector&lt;SgGraphNode*&gt; &gt; <a class="code" href="yicesParserLib_8h.html#de5bf9ed247e18d2b1af6d97d13ba523">intvecmap</a>;
<a name="l00077"></a><a class="code" href="yicesParserLib_8h.html#15e59e7906778423143898391994deed">00077</a> std::map&lt;std::vector&lt;SgGraphNode*&gt;, <span class="keywordtype">int</span>&gt; <a class="code" href="yicesParserLib_8h.html#15e59e7906778423143898391994deed">vecintmap</a>;
<a name="l00078"></a>00078 
<a name="l00079"></a><a class="code" href="yicesParserLib_8h.html#03ae8d9960ef4d518b7f38a6e5e18a40">00079</a> <span class="keyword">typedef</span> <a class="code" href="SgGraphTemplate_8h.html#66b50e592d5aefbd7d9950d9742731fe">myGraph</a> <a class="code" href="yicesParserLib_8h.html#03ae8d9960ef4d518b7f38a6e5e18a40">CFGforT</a>;
<a name="l00080"></a>00080 
<a name="l00081"></a><a class="code" href="yicesParserLib_8h.html#0ab651cea734fb0eb3ed32cef06b99ec">00081</a> std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; <a class="code" href="yicesParserLib_8h.html#0ab651cea734fb0eb3ed32cef06b99ec">paths</a>;
<a name="l00082"></a>00082 
<a name="l00083"></a><a class="code" href="structVertex2.html">00083</a> <span class="keyword">struct </span><a class="code" href="structVertex2.html">Vertex2</a> {
<a name="l00084"></a><a class="code" href="structVertex2.html#8be3bae3b64f13fe364cbf275562d1f8">00084</a>     <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* <a class="code" href="structVertex2.html#8be3bae3b64f13fe364cbf275562d1f8">sg</a>;
<a name="l00085"></a><a class="code" href="structVertex2.html#9a7c64587a9db61322f5c60451c655f6">00085</a>     <span class="keywordtype">bool</span> <a class="code" href="structVertex2.html#9a7c64587a9db61322f5c60451c655f6">vardec</a>;
<a name="l00086"></a><a class="code" href="structVertex2.html#bd34c6f719074e995cce3eba4fd1253a">00086</a>     string <a class="code" href="structVertex2.html#bd34c6f719074e995cce3eba4fd1253a">varstr</a>;
<a name="l00087"></a><a class="code" href="structVertex2.html#150d8ec3948a1be8c0177688f5d3fabd">00087</a>     <span class="keywordtype">bool</span> <a class="code" href="structVertex2.html#150d8ec3948a1be8c0177688f5d3fabd">expr</a>;
<a name="l00088"></a><a class="code" href="structVertex2.html#3d8d33832b0a8ad6ffe21f0a1a9eb835">00088</a>     string <a class="code" href="structVertex2.html#3d8d33832b0a8ad6ffe21f0a1a9eb835">exprstr</a>;
<a name="l00089"></a>00089 };
<a name="l00090"></a>00090 
<a name="l00091"></a><a class="code" href="structEdge2.html">00091</a> <span class="keyword">struct </span><a class="code" href="structEdge2.html">Edge2</a> {
<a name="l00092"></a><a class="code" href="structEdge2.html#c3c3e24bcda723e72650356c86004ae4">00092</a>     <a class="code" href="classSgDirectedGraphEdge.html">SgDirectedGraphEdge</a>* <a class="code" href="structEdge2.html#c3c3e24bcda723e72650356c86004ae4">gedge</a>;
<a name="l00093"></a>00093 };
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 <span class="keyword">typedef</span> boost::adjacency_list&lt;
<a name="l00096"></a>00096         boost::vecS,
<a name="l00097"></a>00097         boost::vecS,
<a name="l00098"></a>00098         boost::bidirectionalS,
<a name="l00099"></a>00099         <a class="code" href="structVertex2.html">Vertex2</a>,
<a name="l00100"></a>00100         <a class="code" href="structEdge2.html">Edge2</a>
<a name="l00101"></a><a class="code" href="yicesParserLib_8h.html#61d3a0d631c1a6ea6ba6b157fd5ca0ea">00101</a> &gt; <a class="code" href="yicesParserLib_8h.html#61d3a0d631c1a6ea6ba6b157fd5ca0ea">newGraph</a>;
<a name="l00102"></a>00102 
<a name="l00103"></a><a class="code" href="yicesParserLib_8h.html#483b93ceaa9447a8265035c058ee460a">00103</a> <span class="keyword">typedef</span> newGraph::vertex_descriptor <a class="code" href="yicesParserLib_8h.html#483b93ceaa9447a8265035c058ee460a">VertexID2</a>;
<a name="l00104"></a><a class="code" href="yicesParserLib_8h.html#564ca3d7a753752580dcd54a16d72119">00104</a> <span class="keyword">typedef</span> newGraph::edge_descriptor <a class="code" href="yicesParserLib_8h.html#564ca3d7a753752580dcd54a16d72119">EdgeID2</a>;
<a name="l00105"></a>00105 
<a name="l00106"></a><a class="code" href="yicesParserLib_8h.html#01a59c9f4634ace001a235e23a2bc31d">00106</a>     <span class="keyword">typedef</span> <a class="code" href="yicesParserLib_8h.html#01a59c9f4634ace001a235e23a2bc31d">boost::graph_traits&lt;newGraph&gt;::vertex_iterator</a> <a class="code" href="yicesParserLib_8h.html#01a59c9f4634ace001a235e23a2bc31d">vertex_iterator</a>;
<a name="l00107"></a><a class="code" href="yicesParserLib_8h.html#e39522b66bd1fadf51820604a43801b0">00107</a>     <span class="keyword">typedef</span> <a class="code" href="yicesParserLib_8h.html#e39522b66bd1fadf51820604a43801b0">boost::graph_traits&lt;newGraph&gt;::out_edge_iterator</a> <a class="code" href="yicesParserLib_8h.html#e39522b66bd1fadf51820604a43801b0">out_edge_iterator</a>;
<a name="l00108"></a><a class="code" href="yicesParserLib_8h.html#bea97cfa64faa5d3febde696c16eed04">00108</a>     <span class="keyword">typedef</span> <a class="code" href="yicesParserLib_8h.html#bea97cfa64faa5d3febde696c16eed04">boost::graph_traits&lt;newGraph&gt;::in_edge_iterator</a> <a class="code" href="yicesParserLib_8h.html#bea97cfa64faa5d3febde696c16eed04">in_edge_iterator</a>;
<a name="l00109"></a><a class="code" href="yicesParserLib_8h.html#c5f273d32fb3bb35cf86b98e401fe9b6">00109</a>     <span class="keyword">typedef</span> <a class="code" href="yicesParserLib_8h.html#c5f273d32fb3bb35cf86b98e401fe9b6">boost::graph_traits&lt;newGraph&gt;::edge_iterator</a> <a class="code" href="yicesParserLib_8h.html#c5f273d32fb3bb35cf86b98e401fe9b6">edge_iterator</a>;
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 
<a name="l00163"></a>00163 <span class="comment">//Process CFG representation into SMT</span>
<a name="l00164"></a>00164 
<a name="l00165"></a>00165 
<a name="l00166"></a>00166 
<a name="l00167"></a><a class="code" href="yicesParserLib_8h.html#dff518c7e2524c5e961d2390af810489">00167</a> <span class="keywordtype">void</span> <a class="code" href="yicesParserLib_8h.html#dff518c7e2524c5e961d2390af810489">propagateFunctionCall</a>(std::vector&lt;SgGraphNode*&gt; path, <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> <a class="code" href="yicesParserLib_8h.html#56763f6036a9484c9dfe6ef6210fa74f">pathnum</a>) {
<a name="l00168"></a>00168             <a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>* sgfd = <a class="code" href="Cxx__Grammar_8h.html#dfd4ff9ab7ae7515d1f66b6f565006df">isSgFunctionCallExp</a>(path[i]-&gt;get_SgNode())-&gt;<a class="code" href="classSgFunctionCallExp.html#ecfaba690023f19b13e18887102f033a">getAssociatedFunctionDeclaration</a>();
<a name="l00169"></a>00169             <a class="code" href="classSgName.html">SgName</a> nam = sgfd-&gt;<a class="code" href="classSgFunctionDeclaration.html#49181f0af447c1e061002d994e55325f">get_qualified_name</a>();
<a name="l00170"></a>00170             <span class="comment">//std::cout &lt;&lt; "function: " &lt;&lt; nam.getString() &lt;&lt; std::endl;</span>
<a name="l00171"></a>00171             ROSE_ASSERT(sgfd != NULL);
<a name="l00172"></a>00172             <a class="code" href="classSgFunctionDefinition.html">SgFunctionDefinition</a>* sgfdef = sgfd-&gt;<a class="code" href="classSgFunctionDeclaration.html#1519d0c01ed1b542c06f151d42b5ea88">get_definition</a>();
<a name="l00173"></a>00173             ROSE_ASSERT(sgfdef != NULL);
<a name="l00174"></a>00174             <span class="keywordtype">int</span> kk = i + 1;
<a name="l00175"></a>00175             <span class="keywordtype">int</span> indiec = 0;
<a name="l00176"></a>00176             std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; funcPaths = <a class="code" href="yicesParserLib_8h.html#4856956a3abce81ef0edec0d2191cb0f">FuncPathMap</a>[sgfdef];
<a name="l00177"></a>00177             ROSE_ASSERT(funcPaths.size() &gt; 0);
<a name="l00178"></a>00178             <span class="keywordtype">int</span> funcIndEnd = path[i]-&gt;get_SgNode()-&gt;cfgIndexForEnd();
<a name="l00179"></a>00179             <span class="keywordflow">if</span> (path.size() &gt; 1) {
<a name="l00180"></a>00180               <span class="comment">//  std::cout &lt;&lt; "funcIndEnd: " &lt;&lt; funcIndEnd &lt;&lt; std::endl;</span>
<a name="l00181"></a>00181 
<a name="l00182"></a>00182                 <span class="keywordflow">while</span> (indiec &lt; funcIndEnd) {
<a name="l00183"></a>00183 
<a name="l00184"></a>00184                 <span class="keywordflow">if</span> (path[kk]-&gt;get_SgNode() == path[i]-&gt;get_SgNode()) {
<a name="l00185"></a>00185                     indiec++;
<a name="l00186"></a>00186                     <span class="keywordflow">if</span> (indiec == funcIndEnd) {
<a name="l00187"></a>00187                         <span class="keywordflow">break</span>;
<a name="l00188"></a>00188                     }
<a name="l00189"></a>00189                 }
<a name="l00190"></a>00190                 kk++;
<a name="l00191"></a>00191             }
<a name="l00192"></a>00192             }
<a name="l00193"></a>00193             <span class="keywordtype">int</span> startingpoint = kk;
<a name="l00194"></a>00194 
<a name="l00195"></a>00195 
<a name="l00196"></a>00196             <span class="comment">//std::vector&lt;SgGraphNode*&gt;::iterator it = path.begin();</span>
<a name="l00197"></a>00197             <span class="comment">//it += kk;</span>
<a name="l00198"></a>00198             std::vector&lt;SgGraphNode*&gt; oldpath = path;
<a name="l00199"></a>00199             std::vector&lt;SgGraphNode*&gt; newpath;
<a name="l00200"></a>00200            <span class="comment">// std::cout &lt;&lt; "oldpath.size(): " &lt;&lt; oldpath.size() &lt;&lt; std::endl;</span>
<a name="l00201"></a>00201             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> qe = 0; qe &lt; startingpoint; qe++) {
<a name="l00202"></a>00202                 newpath.push_back(path[qe]);
<a name="l00203"></a>00203             }
<a name="l00204"></a>00204             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> qe2 = 0; qe2 &lt; funcPaths[0].size(); qe2++) {
<a name="l00205"></a>00205                 newpath.push_back(funcPaths[0][qe2]);
<a name="l00206"></a>00206             }
<a name="l00207"></a>00207             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> qe3 = startingpoint; qe3 &lt; path.size(); qe3++) {
<a name="l00208"></a>00208                 newpath.push_back(path[qe3]);
<a name="l00209"></a>00209             }
<a name="l00210"></a>00210             <span class="comment">//path = newpath; </span>
<a name="l00211"></a>00211             <a class="code" href="yicesParserLib_8h.html#0ab651cea734fb0eb3ed32cef06b99ec">paths</a>[pathnum] = newpath;
<a name="l00212"></a>00212             <a class="code" href="yicesParserLib_8h.html#aea0b2d639e35a0c7ff7daf512abdaa2">calledMap</a>[newpath] = <a class="code" href="yicesParserLib_8h.html#aea0b2d639e35a0c7ff7daf512abdaa2">calledMap</a>[path];
<a name="l00213"></a>00213             <a class="code" href="yicesParserLib_8h.html#aea0b2d639e35a0c7ff7daf512abdaa2">calledMap</a>[newpath].insert(i);
<a name="l00214"></a>00214             <span class="comment">//npaths.push_back(newpath);</span>
<a name="l00215"></a>00215             <span class="comment">//path.insert(it, funcPaths[0].begin(), funcPaths[0].end());</span>
<a name="l00216"></a>00216             <span class="comment">//std::cout &lt;&lt; "newpath.size(): " &lt;&lt; newpath.size() &lt;&lt; std::endl;</span>
<a name="l00217"></a>00217             <span class="comment">//std::cout &lt;&lt; "funcPaths.size(): " &lt;&lt; funcPaths.size() &lt;&lt; std::endl;</span>
<a name="l00218"></a>00218            <span class="keywordflow">if</span> (funcPaths.size() == 1) {
<a name="l00219"></a>00219             <span class="keywordflow">return</span>;
<a name="l00220"></a>00220            }
<a name="l00221"></a>00221             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> qw = 1; qw &lt; funcPaths.size(); qw++) {
<a name="l00222"></a>00222             <span class="comment">//if (qw != pathnum) {</span>
<a name="l00223"></a>00223                 std::vector&lt;SgGraphNode*&gt; npath;<span class="comment">// = oldpath;</span>
<a name="l00224"></a>00224           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> qe = 0; qe &lt; startingpoint; qe++) {
<a name="l00225"></a>00225                 npath.push_back(path[qe]);
<a name="l00226"></a>00226            }
<a name="l00227"></a>00227            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> qe2 = 0; qe2 &lt; funcPaths[qw].size(); qe2++) {
<a name="l00228"></a>00228                 npath.push_back(funcPaths[qw][qe2]);
<a name="l00229"></a>00229             }
<a name="l00230"></a>00230             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> qe3 = startingpoint; qe3 &lt; path.size(); qe3++) {
<a name="l00231"></a>00231                 npath.push_back(path[qe3]);
<a name="l00232"></a>00232             }
<a name="l00233"></a>00233             <a class="code" href="yicesParserLib_8h.html#aea0b2d639e35a0c7ff7daf512abdaa2">calledMap</a>[npath] = <a class="code" href="yicesParserLib_8h.html#aea0b2d639e35a0c7ff7daf512abdaa2">calledMap</a>[newpath];
<a name="l00234"></a>00234 
<a name="l00235"></a>00235              
<a name="l00236"></a>00236 
<a name="l00237"></a>00237 
<a name="l00238"></a>00238                 <span class="comment">//npath.insert(it, funcPaths[qw].begin(), funcPaths[qw].end());</span>
<a name="l00239"></a>00239                 <a class="code" href="yicesParserLib_8h.html#0ab651cea734fb0eb3ed32cef06b99ec">paths</a>.push_back(npath);
<a name="l00240"></a>00240             }
<a name="l00241"></a>00241             <span class="comment">//}</span>
<a name="l00242"></a>00242             <span class="comment">//std::cout &lt;&lt; "paths.size(): " &lt;&lt; paths.size() &lt;&lt; std::endl;</span>
<a name="l00243"></a>00243             std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt;::iterator tt = <a class="code" href="yicesParserLib_8h.html#0ab651cea734fb0eb3ed32cef06b99ec">paths</a>.begin();
<a name="l00244"></a>00244             <span class="comment">//tt += pathnum;</span>
<a name="l00245"></a>00245            <span class="comment">// (*tt) = npaths[0]; </span>
<a name="l00246"></a>00246            <span class="comment">// tt+=1;</span>
<a name="l00247"></a>00247            <span class="comment">// paths.insert((*tt), </span>
<a name="l00248"></a>00248             <span class="comment">//called.push_back(path[i+1]-&gt;get_SgNode());</span>
<a name="l00249"></a>00249        }
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 
<a name="l00252"></a>00252 
<a name="l00253"></a><a class="code" href="yicesParserLib_8h.html#3703af20b0be2697db1fcd0452dd9c6e">00253</a> std::map&lt;SgName, yices_expr&gt; <a class="code" href="yicesParserLib_8h.html#3703af20b0be2697db1fcd0452dd9c6e">getExpr</a>;
<a name="l00254"></a>00254 <span class="comment">//string getGraphNodeType(SgGraphNode* sn);</span>
<a name="l00255"></a>00255 
<a name="l00256"></a><a class="code" href="classvisitorTraversal.html">00256</a> <span class="keyword">class </span><a class="code" href="classvisitorTraversal.html">visitorTraversal</a> : <span class="keyword">public</span> <a class="code" href="classSgGraphTraversal.html">SgGraphTraversal</a>&lt;CFGforT&gt;
<a name="l00257"></a>00257    {
<a name="l00258"></a>00258      <span class="keyword">public</span>:
<a name="l00259"></a><a class="code" href="classvisitorTraversal.html#499a600257d925244b7ff4baf0223a95">00259</a>           <span class="keywordtype">int</span> <a class="code" href="classvisitorTraversal.html#499a600257d925244b7ff4baf0223a95">tltnodes</a>;
<a name="l00260"></a>00260       <span class="comment">//    int paths;</span>
<a name="l00261"></a>00261           <span class="comment">//std::map&lt;SgName, yices_expr&gt; getExpr;</span>
<a name="l00262"></a><a class="code" href="classvisitorTraversal.html#83baa2767d9e85ff51bda3e8a7e9bd4a">00262</a>           std::set&lt;SgNode*&gt; <a class="code" href="classvisitorTraversal.html#83baa2767d9e85ff51bda3e8a7e9bd4a">knownNodes</a>;     
<a name="l00263"></a>00263     <span class="comment">//      std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; pathstore;</span>
<a name="l00264"></a>00264           <span class="keywordtype">void</span> <a class="code" href="classvisitorTraversal.html#b1564bd0d456d813becf7694b1bac8f6">analyzePath</a>(std::vector&lt;VertexID&gt;&amp; pth);
<a name="l00265"></a><a class="code" href="classvisitorTraversal.html#0e51ac7d19a1f78d0b03e8ab0c1c4c90">00265</a>           <a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* <a class="code" href="classvisitorTraversal.html#0e51ac7d19a1f78d0b03e8ab0c1c4c90">g</a>;
<a name="l00266"></a><a class="code" href="classvisitorTraversal.html#12e9d13c7871b33e4efa045c5fbf086f">00266</a>           <a class="code" href="SgGraphTemplate_8h.html#66b50e592d5aefbd7d9950d9742731fe">myGraph</a>* <a class="code" href="classvisitorTraversal.html#12e9d13c7871b33e4efa045c5fbf086f">orig</a>;
<a name="l00267"></a><a class="code" href="classvisitorTraversal.html#8a91215f8d9119d2fd2b3d24a87a12f7">00267</a>           <a class="code" href="classStaticCFG_1_1CFG.html">StaticCFG::CFG</a>* <a class="code" href="classvisitorTraversal.html#8a91215f8d9119d2fd2b3d24a87a12f7">cfg</a>;
<a name="l00268"></a><a class="code" href="classvisitorTraversal.html#b20d536027de3f2189d6b30fae63e5a4">00268</a>           <span class="keywordtype">int</span> <a class="code" href="classvisitorTraversal.html#b20d536027de3f2189d6b30fae63e5a4">pathnumber</a>;
<a name="l00269"></a>00269           <span class="comment">//std::map&lt;SgVariableSymbol, string&gt; nameOf;</span>
<a name="l00270"></a>00270           <span class="comment">//int nvars;</span>
<a name="l00271"></a>00271    };
<a name="l00272"></a>00272 
<a name="l00273"></a><a class="code" href="classvisitorTraversal2.html">00273</a> <span class="keyword">class </span><a class="code" href="classvisitorTraversal2.html">visitorTraversal2</a> : <span class="keyword">public</span> <a class="code" href="classSgGraphTraversal.html">SgGraphTraversal</a>&lt;newGraph&gt;
<a name="l00274"></a>00274    {
<a name="l00275"></a>00275      <span class="keyword">public</span>:
<a name="l00276"></a><a class="code" href="classvisitorTraversal2.html#025d6e5f3c7bc650624ecb0be035119e">00276</a>           <span class="keywordtype">int</span> <a class="code" href="classvisitorTraversal2.html#025d6e5f3c7bc650624ecb0be035119e">tltnodes</a>;
<a name="l00277"></a><a class="code" href="classvisitorTraversal2.html#e0d5911f0549053170f2166a07eeed85">00277</a>           <span class="keywordtype">int</span> <a class="code" href="classvisitorTraversal2.html#e0d5911f0549053170f2166a07eeed85">paths</a>;
<a name="l00278"></a>00278           <span class="keywordtype">void</span> <a class="code" href="classvisitorTraversal2.html#561b71abb0dbab540e6bf558b0777cbf">analyzePath</a>(std::vector&lt;VertexID&gt;&amp; pth);
<a name="l00279"></a>00279           <span class="comment">//std::map&lt;SgVariableSymbol, string&gt; nameOf;</span>
<a name="l00280"></a>00280           <span class="comment">//int nvars;</span>
<a name="l00281"></a>00281    };
<a name="l00282"></a>00282 
<a name="l00283"></a><a class="code" href="yicesParserLib_8h.html#6135c3326da11f54e16f8eec2de22411">00283</a> <a class="code" href="yicesParserLib_8h.html#61d3a0d631c1a6ea6ba6b157fd5ca0ea">newGraph</a>* <a class="code" href="yicesParserLib_8h.html#6135c3326da11f54e16f8eec2de22411">nGraph</a>;
<a name="l00284"></a><a class="code" href="yicesParserLib_8h.html#8b0b5b9c54a359f221198d7d558224a8">00284</a>          <a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* <a class="code" href="yicesParserLib_8h.html#8b0b5b9c54a359f221198d7d558224a8">openg</a>;
<a name="l00285"></a><a class="code" href="yicesParserLib_8h.html#b1111206c9c1b043793a5ab3fcdfaae0">00285</a>           <a class="code" href="SgGraphTemplate_8h.html#66b50e592d5aefbd7d9950d9742731fe">myGraph</a>* <a class="code" href="yicesParserLib_8h.html#b1111206c9c1b043793a5ab3fcdfaae0">openorig</a>;
<a name="l00286"></a><a class="code" href="yicesParserLib_8h.html#1567203b4990b38c06dc3fdd400ecdbb">00286</a>           <a class="code" href="classStaticCFG_1_1CFG.html">StaticCFG::CFG</a>* <a class="code" href="yicesParserLib_8h.html#1567203b4990b38c06dc3fdd400ecdbb">opencfg</a>;
<a name="l00287"></a>00287 
<a name="l00288"></a>00288 
<a name="l00289"></a>00289 
<a name="l00290"></a><a class="code" href="yicesParserLib_8h.html#52915da0ccf84e2dff73655c4ecb49ab">00290</a> <span class="keywordtype">long</span> <a class="code" href="yicesParserLib_8h.html#52915da0ccf84e2dff73655c4ecb49ab">getIndex</a>(<a class="code" href="classSgGraphNode.html">SgGraphNode</a>* n) {
<a name="l00291"></a>00291     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = n-&gt;<a class="code" href="classSgGraphNode.html#5d9c20d84e5cda80e95287a384c9a27e">get_index</a>(); 
<a name="l00292"></a>00292     <span class="keywordflow">return</span> i;
<a name="l00293"></a>00293 }
<a name="l00294"></a>00294 
<a name="l00295"></a>00295 
<a name="l00296"></a>00296 <span class="comment">//yices_expr mainParse(vector&lt;SgGraphNode*&gt; expr, yices_context&amp; ctx);</span>
<a name="l00297"></a>00297 
<a name="l00298"></a><a class="code" href="yicesParserLib_8h.html#b951ebd61b5fff7fb5c4212d7fc63254">00298</a> <span class="keywordtype">int</span> <a class="code" href="yicesParserLib_8h.html#b951ebd61b5fff7fb5c4212d7fc63254">rounds</a>;
<a name="l00299"></a><a class="code" href="yicesParserLib_8h.html#56763f6036a9484c9dfe6ef6210fa74f">00299</a> <span class="keywordtype">int</span> <a class="code" href="yicesParserLib_8h.html#56763f6036a9484c9dfe6ef6210fa74f">pathnum</a>;
<a name="l00300"></a>00300 <span class="comment">//std::set&lt;SgGraphNode*&gt; knownGraphNodes;</span>
<a name="l00301"></a><a class="code" href="yicesParserLib_8h.html#ba64c12feaf73681f2083642091f3543">00301</a> std::set&lt;std::pair&lt;VertexID2, VertexID2&gt; &gt; <a class="code" href="yicesParserLib_8h.html#ba64c12feaf73681f2083642091f3543">knownEdges</a>;
<a name="l00302"></a><a class="code" href="yicesParserLib_8h.html#660feac13508a7ae1fd9c8d64278c071">00302</a> std::map&lt;SgGraphNode*, VertexID2&gt; <a class="code" href="yicesParserLib_8h.html#660feac13508a7ae1fd9c8d64278c071">graphVertex</a>;
<a name="l00303"></a>00303 
<a name="l00304"></a>00304 <span class="keywordtype">void</span> <a class="code" href="classvisitorTraversal2.html#561b71abb0dbab540e6bf558b0777cbf">visitorTraversal2::analyzePath</a>(std::vector&lt;VertexID2&gt;&amp; pathR) {
<a name="l00305"></a>00305     <a class="code" href="classvisitorTraversal2.html#025d6e5f3c7bc650624ecb0be035119e">tltnodes</a> += pathR.size();
<a name="l00306"></a>00306     <a class="code" href="classvisitorTraversal2.html#e0d5911f0549053170f2166a07eeed85">paths</a>++;
<a name="l00307"></a>00307     <span class="comment">//std::cout &lt;&lt; "path: " &lt;&lt; paths &lt;&lt; std::endl;</span>
<a name="l00308"></a>00308 }
<a name="l00309"></a>00309 
<a name="l00310"></a>00310 
<a name="l00311"></a><a class="code" href="yicesParserLib_8h.html#8bd97a9afc006aa870b7c658bf619db5">00311</a> std::map&lt;int, EdgeID2&gt; <a class="code" href="yicesParserLib_8h.html#8bd97a9afc006aa870b7c658bf619db5">intedgemap</a>;
<a name="l00312"></a><a class="code" href="yicesParserLib_8h.html#6789112fd65811f78d78750ec7e94ecc">00312</a> std::map&lt;EdgeID2, int&gt; <a class="code" href="yicesParserLib_8h.html#6789112fd65811f78d78750ec7e94ecc">edgeintmap</a>;
<a name="l00313"></a><a class="code" href="yicesParserLib_8h.html#25b88b32b607ebc6557a01bd5ec0dba1">00313</a> std::map&lt;VertexID2, int&gt; <a class="code" href="yicesParserLib_8h.html#25b88b32b607ebc6557a01bd5ec0dba1">intmap</a>;
<a name="l00314"></a>00314 
<a name="l00315"></a>00315 <span class="keywordtype">int</span>
<a name="l00316"></a><a class="code" href="yicesParserLib_8h.html#37b0785a94133481cccfda984b865d5e">00316</a> <a class="code" href="yicesParserLib_8h.html#37b0785a94133481cccfda984b865d5e">getSource</a>(<span class="keywordtype">int</span>&amp; edge, <a class="code" href="yicesParserLib_8h.html#61d3a0d631c1a6ea6ba6b157fd5ca0ea">newGraph</a>*&amp; g)
<a name="l00317"></a>00317 {
<a name="l00318"></a>00318     <a class="code" href="yicesParserLib_8h.html#564ca3d7a753752580dcd54a16d72119">EdgeID2</a> e = <a class="code" href="yicesParserLib_8h.html#8bd97a9afc006aa870b7c658bf619db5">intedgemap</a>[edge];
<a name="l00319"></a>00319     <a class="code" href="yicesParserLib_8h.html#483b93ceaa9447a8265035c058ee460a">VertexID2</a> v = boost::source(e, *g);
<a name="l00320"></a>00320     <span class="keywordflow">return</span>(<a class="code" href="yicesParserLib_8h.html#25b88b32b607ebc6557a01bd5ec0dba1">intmap</a>[v]);
<a name="l00321"></a>00321 }
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 
<a name="l00324"></a>00324 
<a name="l00325"></a><a class="code" href="yicesParserLib_8h.html#c6745c287dda35fc65f5d8136028b164">00325</a> <span class="keywordtype">int</span> <a class="code" href="yicesParserLib_8h.html#c6745c287dda35fc65f5d8136028b164">getTarget</a>(<span class="keywordtype">int</span>&amp; edge, <a class="code" href="yicesParserLib_8h.html#61d3a0d631c1a6ea6ba6b157fd5ca0ea">newGraph</a>*&amp; g)
<a name="l00326"></a>00326 {
<a name="l00327"></a>00327     <a class="code" href="yicesParserLib_8h.html#564ca3d7a753752580dcd54a16d72119">EdgeID2</a> e = <a class="code" href="yicesParserLib_8h.html#8bd97a9afc006aa870b7c658bf619db5">intedgemap</a>[edge];
<a name="l00328"></a>00328     <a class="code" href="yicesParserLib_8h.html#483b93ceaa9447a8265035c058ee460a">VertexID2</a> v = boost::target(e, *g);
<a name="l00329"></a>00329     <span class="keywordflow">return</span> (<a class="code" href="yicesParserLib_8h.html#25b88b32b607ebc6557a01bd5ec0dba1">intmap</a>[v]);
<a name="l00330"></a>00330 }
<a name="l00331"></a>00331 
<a name="l00332"></a><a class="code" href="yicesParserLib_8h.html#ae6114c41e64dd3300da290c03c55f7f">00332</a>         <span class="keywordtype">void</span> <a class="code" href="yicesParserLib_8h.html#ae6114c41e64dd3300da290c03c55f7f">printCFGNode2</a>(<span class="keywordtype">int</span>&amp; cf, <a class="code" href="yicesParserLib_8h.html#483b93ceaa9447a8265035c058ee460a">VertexID2</a> v, <a class="code" href="yicesParserLib_8h.html#61d3a0d631c1a6ea6ba6b157fd5ca0ea">newGraph</a>*&amp; g, std::ofstream&amp; o)
<a name="l00333"></a>00333         {
<a name="l00334"></a>00334             stringstream str;
<a name="l00335"></a>00335             <span class="keywordflow">if</span> ((*g)[v].expr) {
<a name="l00336"></a>00336             <span class="comment">//std::cout &lt;&lt; cf &lt;&lt; "expr: " &lt;&lt; (*g)[v].exprstr &lt;&lt; std::endl;</span>
<a name="l00337"></a>00337             str &lt;&lt; cf &lt;&lt; <span class="stringliteral">" expr: "</span> &lt;&lt; (*g)[v].exprstr;
<a name="l00338"></a>00338             }
<a name="l00339"></a>00339             <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((*g)[v].vardec) {
<a name="l00340"></a>00340             <span class="comment">//std::cout &lt;&lt; cf &lt;&lt; " vardec: " &lt;&lt; (*g)[v].varstr &lt;&lt; std::endl;</span>
<a name="l00341"></a>00341             str &lt;&lt; cf &lt;&lt; <span class="stringliteral">" vardec: "</span> &lt;&lt; (*g)[v].varstr;
<a name="l00342"></a>00342             }
<a name="l00343"></a>00343             <span class="keywordflow">else</span> {
<a name="l00344"></a>00344                str &lt;&lt; cf;
<a name="l00345"></a>00345             }
<a name="l00346"></a>00346             std::string nodeColor = <span class="stringliteral">"black"</span>;
<a name="l00347"></a>00347             o &lt;&lt; cf &lt;&lt; <span class="stringliteral">" [label=\""</span> &lt;&lt; <span class="stringliteral">" num:"</span> &lt;&lt; str.str() &lt;&lt; <span class="stringliteral">"\", color=\""</span> &lt;&lt; nodeColor &lt;&lt; <span class="stringliteral">"\", style=\""</span> &lt;&lt; <span class="stringliteral">"solid"</span> &lt;&lt; <span class="stringliteral">"\"];\n"</span>;
<a name="l00348"></a>00348         }
<a name="l00349"></a>00349 
<a name="l00350"></a><a class="code" href="yicesParserLib_8h.html#6da4c3ad474c7bdeb2fd4c36e4c88520">00350</a>         <span class="keywordtype">void</span> <a class="code" href="yicesParserLib_8h.html#6da4c3ad474c7bdeb2fd4c36e4c88520">printCFGEdge2</a>(<span class="keywordtype">int</span>&amp; cf, <a class="code" href="yicesParserLib_8h.html#61d3a0d631c1a6ea6ba6b157fd5ca0ea">newGraph</a>*&amp; <a class="code" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>, std::ofstream&amp; o)
<a name="l00351"></a>00351         {
<a name="l00352"></a>00352             <span class="keywordtype">int</span> src = <a class="code" href="yicesParserLib_8h.html#37b0785a94133481cccfda984b865d5e">getSource</a>(cf, cfg);
<a name="l00353"></a>00353             <span class="keywordtype">int</span> tar = <a class="code" href="yicesParserLib_8h.html#c6745c287dda35fc65f5d8136028b164">getTarget</a>(cf, cfg);
<a name="l00354"></a>00354             o &lt;&lt; src &lt;&lt; <span class="stringliteral">" -&gt; "</span> &lt;&lt; tar &lt;&lt; <span class="stringliteral">" [label=\""</span> &lt;&lt; src &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; tar &lt;&lt; <span class="stringliteral">"\", style=\""</span> &lt;&lt; <span class="stringliteral">"solid"</span> &lt;&lt; <span class="stringliteral">"\"];\n"</span>;
<a name="l00355"></a>00355         }
<a name="l00356"></a>00356 
<a name="l00357"></a><a class="code" href="yicesParserLib_8h.html#b068724e7be3bba630a9c06a9ae8b454">00357</a>         <span class="keywordtype">void</span> <a class="code" href="yicesParserLib_8h.html#b068724e7be3bba630a9c06a9ae8b454">printHotness2</a>(<a class="code" href="yicesParserLib_8h.html#61d3a0d631c1a6ea6ba6b157fd5ca0ea">newGraph</a>*&amp; g)
<a name="l00358"></a>00358         {
<a name="l00359"></a>00359             <span class="keyword">const</span> <a class="code" href="yicesParserLib_8h.html#61d3a0d631c1a6ea6ba6b157fd5ca0ea">newGraph</a>* gc = g;
<a name="l00360"></a>00360             <span class="keywordtype">int</span> currhot = 0;
<a name="l00361"></a>00361             
<a name="l00362"></a>00362             std::ofstream mf;
<a name="l00363"></a>00363             std::stringstream filenam;
<a name="l00364"></a>00364             filenam &lt;&lt; <span class="stringliteral">"hotness2"</span> &lt;&lt; currhot &lt;&lt; <span class="stringliteral">".dot"</span>;
<a name="l00365"></a>00365             std::string fn = filenam.str();
<a name="l00366"></a>00366             mf.open(fn.c_str());
<a name="l00367"></a>00367 
<a name="l00368"></a>00368             mf &lt;&lt; <span class="stringliteral">"digraph defaultName { \n"</span>;
<a name="l00369"></a>00369             <a class="code" href="yicesParserLib_8h.html#01a59c9f4634ace001a235e23a2bc31d">vertex_iterator</a> v, vend;
<a name="l00370"></a>00370             <a class="code" href="yicesParserLib_8h.html#c5f273d32fb3bb35cf86b98e401fe9b6">edge_iterator</a> e, eend;
<a name="l00371"></a>00371             <span class="keywordtype">int</span> intcurr = 1;
<a name="l00372"></a>00372             <span class="keywordtype">int</span> intcurr2 = 1;
<a name="l00373"></a>00373             <span class="keywordflow">for</span> (tie(v, vend) = vertices(*g); v != vend; ++v)
<a name="l00374"></a>00374             {
<a name="l00375"></a>00375                 <a class="code" href="yicesParserLib_8h.html#25b88b32b607ebc6557a01bd5ec0dba1">intmap</a>[*v] = intcurr;
<a name="l00376"></a>00376                 <a class="code" href="yicesParserLib_8h.html#ae6114c41e64dd3300da290c03c55f7f">printCFGNode2</a>(intcurr, *v, g,  mf);
<a name="l00377"></a>00377                 intcurr++;
<a name="l00378"></a>00378             }
<a name="l00379"></a>00379             <span class="keywordflow">for</span> (tie(e, eend) = edges(*g); e != eend; ++e)
<a name="l00380"></a>00380             {
<a name="l00381"></a>00381                 <a class="code" href="yicesParserLib_8h.html#6789112fd65811f78d78750ec7e94ecc">edgeintmap</a>[*e] = intcurr2;
<a name="l00382"></a>00382                 <a class="code" href="yicesParserLib_8h.html#8bd97a9afc006aa870b7c658bf619db5">intedgemap</a>[intcurr2] = *e;
<a name="l00383"></a>00383                 <a class="code" href="yicesParserLib_8h.html#6da4c3ad474c7bdeb2fd4c36e4c88520">printCFGEdge2</a>(intcurr2, g, mf);
<a name="l00384"></a>00384                 intcurr2++;
<a name="l00385"></a>00385             }
<a name="l00386"></a>00386             mf.close();
<a name="l00387"></a>00387         }
<a name="l00388"></a>00388 
<a name="l00389"></a>00389 
<a name="l00390"></a><a class="code" href="yicesParserLib_8h.html#2a78ff2b912bbb36235508d39c77c9b6">00390</a> string <a class="code" href="yicesParserLib_8h.html#2a78ff2b912bbb36235508d39c77c9b6">getType</a>(<a class="code" href="classSgNode.html">SgNode</a>* n) {
<a name="l00391"></a>00391     <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#8747d62c732d8f83b31ffbacadd487c2">isSgTypeInt</a>(n)) {
<a name="l00392"></a>00392         <span class="keywordflow">return</span> <span class="stringliteral">"int"</span>;
<a name="l00393"></a>00393     }
<a name="l00394"></a>00394     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#0cbbf3c6c6388bfa7a23f62d83c0c882">isSgTypeDouble</a>(n)) {
<a name="l00395"></a>00395         <span class="keywordflow">return</span> <span class="stringliteral">"double"</span>;
<a name="l00396"></a>00396     }
<a name="l00397"></a>00397     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#a61ed1f7eefcaf0d8c2db1295a62e681">isSgTypeFloat</a>(n)) {
<a name="l00398"></a>00398         <span class="keywordflow">return</span> <span class="stringliteral">"float"</span>;
<a name="l00399"></a>00399     }
<a name="l00400"></a>00400     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#bf0c1470e4c992cd983b7ed8af7f987d">isSgTypeShort</a>(n)) {
<a name="l00401"></a>00401         <span class="keywordflow">return</span> <span class="stringliteral">"short"</span>;
<a name="l00402"></a>00402     }
<a name="l00403"></a>00403     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#0e95ac48ee41d9b4dd9b935c1a5a2b2e">isSgTypeLong</a>(n)) {
<a name="l00404"></a>00404         <span class="keywordflow">return</span> <span class="stringliteral">"long"</span>;
<a name="l00405"></a>00405     }
<a name="l00406"></a>00406     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#d4038765cfc274008198505c8f58c0ed">isSgTypeLongLong</a>(n)) {
<a name="l00407"></a>00407         <span class="keywordflow">return</span> <span class="stringliteral">"long long int"</span>;
<a name="l00408"></a>00408     }
<a name="l00409"></a>00409     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#71d1214883e58d5581fe562d275377b0">isSgTypeLongDouble</a>(n)) {
<a name="l00410"></a>00410         <span class="keywordflow">return</span> <span class="stringliteral">"long double"</span>;
<a name="l00411"></a>00411     }
<a name="l00412"></a>00412     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#3a9ddeebfac3aaf9660589c3706d3218">isSgTypeBool</a>(n)) {
<a name="l00413"></a>00413         <span class="keywordflow">return</span> <span class="stringliteral">"bool"</span>;
<a name="l00414"></a>00414     }
<a name="l00415"></a>00415     <span class="keywordflow">return</span> <span class="stringliteral">""</span>;
<a name="l00416"></a>00416 }
<a name="l00417"></a>00417 
<a name="l00418"></a>00418 <span class="comment">//string getSentence(SgGraphNode* n, std::vector&lt;SgGraphNode*&gt; nodesentence) {</span>
<a name="l00419"></a>00419    
<a name="l00420"></a>00420 
<a name="l00421"></a>00421 yices_expr <a class="code" href="yicesParserLib_8h.html#1ae824aad11e84a5193ed6f737f1402b">evalFunction</a>(std::vector&lt;SgGraphNode*&gt; path, yices_context&amp; ctx, <span class="keywordtype">bool</span> mainFlag);
<a name="l00422"></a>00422 
<a name="l00423"></a><a class="code" href="yicesParserLib_8h.html#17a26f2fa17de70c7881e2bb7231eae6">00423</a> std::vector&lt;VertexID&gt; <a class="code" href="yicesParserLib_8h.html#17a26f2fa17de70c7881e2bb7231eae6">exprs</a>;
<a name="l00424"></a>00424 
<a name="l00425"></a><a class="code" href="yicesParserLib_8h.html#a1014aaa0c222827ec6431f1f6c2133d">00425</a> <span class="keywordtype">int</span> <a class="code" href="yicesParserLib_8h.html#a1014aaa0c222827ec6431f1f6c2133d">ipaths</a>;
<a name="l00426"></a>00426 
<a name="l00427"></a>00427 
<a name="l00428"></a>00428 <span class="comment">//std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; paths;</span>
<a name="l00429"></a>00429 
<a name="l00430"></a><a class="code" href="yicesParserLib_8h.html#b8bccd34a4d4d292e9e369cb69decda2">00430</a> std::set&lt;std::vector&lt;SgGraphNode*&gt; &gt; <a class="code" href="yicesParserLib_8h.html#b8bccd34a4d4d292e9e369cb69decda2">globalPaths</a>;
<a name="l00431"></a>00431 
<a name="l00432"></a>00432 <span class="comment">//std::map&lt;std::vector&lt;SgGraphNode*&gt;, std::set&lt;SgNode*&gt; &gt; calledMap;</span>
<a name="l00433"></a>00433 
<a name="l00434"></a><a class="code" href="classvisitorTraversal.html#b1564bd0d456d813becf7694b1bac8f6">00434</a> <span class="keywordtype">void</span> <a class="code" href="classvisitorTraversal.html#b1564bd0d456d813becf7694b1bac8f6">visitorTraversal::analyzePath</a>(std::vector&lt;VertexID&gt;&amp; pathR) {
<a name="l00435"></a>00435    <span class="comment">//ROSE_ASSERT(globalPaths.find(pathR) == globalPaths.end());</span>
<a name="l00436"></a>00436    <span class="comment">//globalPaths.insert(pathR);</span>
<a name="l00437"></a>00437    <span class="comment">//yices_context ctx;</span>
<a name="l00438"></a>00438    <a class="code" href="yicesParserLib_8h.html#0ab651cea734fb0eb3ed32cef06b99ec">paths</a>.clear();
<a name="l00439"></a>00439    <a class="code" href="yicesParserLib_8h.html#99ae78e96160b26ce175394c6deb89cb">usingNots</a>=<span class="keyword">false</span>;
<a name="l00440"></a>00440    <span class="comment">//FuncPathMap.clear();</span>
<a name="l00441"></a>00441    <a class="code" href="yicesParserLib_8h.html#8b0b5b9c54a359f221198d7d558224a8">openg</a> = <a class="code" href="classvisitorTraversal.html#0e51ac7d19a1f78d0b03e8ab0c1c4c90">g</a>;
<a name="l00442"></a>00442    <a class="code" href="yicesParserLib_8h.html#1567203b4990b38c06dc3fdd400ecdbb">opencfg</a> = <a class="code" href="classvisitorTraversal.html#8a91215f8d9119d2fd2b3d24a87a12f7">cfg</a>;
<a name="l00443"></a>00443    <a class="code" href="yicesParserLib_8h.html#b1111206c9c1b043793a5ab3fcdfaae0">openorig</a> = <a class="code" href="classvisitorTraversal.html#12e9d13c7871b33e4efa045c5fbf086f">orig</a>; 
<a name="l00444"></a>00444    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
<a name="l00445"></a>00445     <a class="code" href="yicesParserLib_8h.html#cf72a788e5ca240904eed58d8f702e85">noAssert</a> = <span class="keyword">false</span>;
<a name="l00446"></a>00446     <a class="code" href="yicesParserLib_8h.html#b951ebd61b5fff7fb5c4212d7fc63254">rounds</a> = 0;
<a name="l00447"></a>00447     <a class="code" href="yicesParserLib_8h.html#9427d97d66f016a61cc07e07c99c9a4e">forFlag</a> = <span class="keyword">false</span>;
<a name="l00448"></a>00448     stringstream pathstream;
<a name="l00449"></a>00449     <span class="comment">//std::set&lt;SgNode*&gt; knownNodes;</span>
<a name="l00450"></a>00450     <a class="code" href="yicesParserLib_8h.html#d9c55e63216a3f4b4d8f344149a3646b">nameOf</a>.clear();
<a name="l00451"></a>00451     <a class="code" href="yicesParserLib_8h.html#3703af20b0be2697db1fcd0452dd9c6e">getExpr</a>.clear();
<a name="l00452"></a>00452     <span class="comment">//VertexID2 start = boost::add_vertex(*nGraph);</span>
<a name="l00453"></a>00453     <span class="comment">//graphVertex[(*orig)[pathR[0]]] = start;</span>
<a name="l00454"></a>00454     <span class="comment">//std::cout &lt;&lt; "path: " &lt;&lt; pathnum &lt;&lt; std::endl;</span>
<a name="l00455"></a>00455     <span class="comment">//for (int i = 0; i &lt; pathR.size(); i++) {</span>
<a name="l00456"></a>00456     <span class="comment">//    std::cout &lt;&lt; vertintmap[pathR[i]] &lt;&lt; ", ";</span>
<a name="l00457"></a>00457    <span class="comment">// }</span>
<a name="l00458"></a>00458     <span class="comment">//std::cout &lt;&lt; std::endl;</span>
<a name="l00459"></a>00459     <a class="code" href="classSgGraphTraversal.html#b88ac29234d7d1182af47cd9ee944179">pathnum</a>++;
<a name="l00460"></a>00460     <a class="code" href="yicesParserLib_8h.html#8ee962f3a476a38b126c24b0b06de591">inconsistent</a> = <span class="keyword">false</span>;
<a name="l00461"></a>00461     std::vector&lt;SgGraphNode*&gt; path;
<a name="l00462"></a>00462     <span class="comment">//std::vector&lt;SgGraphNode*&gt; pathR;</span>
<a name="l00463"></a>00463     std::vector&lt;SgGraphNode*&gt; exprPath;
<a name="l00464"></a>00464     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; pathR.size(); j++) {
<a name="l00465"></a>00465        <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* R = (*<a class="code" href="classvisitorTraversal.html#12e9d13c7871b33e4efa045c5fbf086f">orig</a>)[pathR[j]].sg;
<a name="l00466"></a>00466        path.push_back(R);
<a name="l00467"></a>00467     }
<a name="l00468"></a>00468     <span class="keywordflow">if</span> (path.back()-&gt;get_SgNode() != path.front()-&gt;get_SgNode()) {
<a name="l00469"></a>00469         <span class="keywordflow">return</span>;
<a name="l00470"></a>00470     }
<a name="l00471"></a>00471     <span class="comment">//ROSE_ASSERT(globalPaths.find(path) == globalPaths.end());</span>
<a name="l00472"></a>00472     <span class="comment">//globalPaths.insert(path);</span>
<a name="l00473"></a>00473   <span class="comment">//  std::cout &lt;&lt; "path: " &lt;&lt; std::endl;</span>
<a name="l00474"></a>00474   <span class="comment">// ofstream fout;</span>
<a name="l00475"></a>00475   <span class="comment">//  string fileSaver = "pathsets";</span>
<a name="l00476"></a>00476   <span class="comment">//  fout.open(fileSaver.c_str(),ios::app);</span>
<a name="l00477"></a>00477   <span class="comment">//  for (int qr = 0; qr &lt; path.size(); qr++) {</span>
<a name="l00478"></a>00478   <span class="comment">//       fout &lt;&lt; getGraphNodeType(path[qr]) &lt;&lt; std::endl;</span>
<a name="l00479"></a>00479   <span class="comment">//  }</span>
<a name="l00480"></a>00480   <span class="comment">//  fout &lt;&lt; "************************\n";</span>
<a name="l00481"></a>00481   <span class="comment">//  fout.close();</span>
<a name="l00482"></a>00482     <span class="comment">//graphVertex[path[0]] = start;</span>
<a name="l00483"></a>00483     yices_context ctx = yices_mk_context();
<a name="l00484"></a>00484 <span class="keywordtype">bool</span> noadd = <span class="keyword">false</span>;
<a name="l00485"></a>00485 <span class="keywordtype">int</span> jjf = 0;
<a name="l00486"></a>00486 <a class="code" href="yicesParserLib_8h.html#0ab651cea734fb0eb3ed32cef06b99ec">paths</a>.push_back(path);
<a name="l00487"></a>00487 std::vector&lt;SgNode*&gt; called;
<a name="l00488"></a>00488     <span class="keywordflow">while</span> (jjf != <a class="code" href="yicesParserLib_8h.html#0ab651cea734fb0eb3ed32cef06b99ec">paths</a>.size()) {
<a name="l00489"></a>00489         <span class="comment">//std::cout &lt;&lt; "propagating" &lt;&lt; std::endl;</span>
<a name="l00490"></a>00490         std::vector&lt;SgGraphNode*&gt; pathc = <a class="code" href="yicesParserLib_8h.html#0ab651cea734fb0eb3ed32cef06b99ec">paths</a>[jjf];
<a name="l00491"></a>00491         <span class="keywordtype">int</span> jj = 0;
<a name="l00492"></a>00492         <span class="keywordflow">while</span> (jj != pathc.size()) {
<a name="l00493"></a>00493             <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#dfd4ff9ab7ae7515d1f66b6f565006df">isSgFunctionCallExp</a>(pathc[jj]-&gt;get_SgNode()) &amp;&amp; <a class="code" href="yicesParserLib_8h.html#aea0b2d639e35a0c7ff7daf512abdaa2">calledMap</a>[pathc].<a class="code" href="namespaceSageInterface.html#ff5394b21cf11cd338671af3a11a7f92">find</a>(jj) == <a class="code" href="yicesParserLib_8h.html#aea0b2d639e35a0c7ff7daf512abdaa2">calledMap</a>[pathc].end() &amp;&amp; <a class="code" href="yicesParserLib_8h.html#1567203b4990b38c06dc3fdd400ecdbb">opencfg</a>-&gt;<a class="code" href="classStaticCFG_1_1CFG.html#6758ebe66068f45146dd9c7554ad8524">toCFGNode</a>(pathc[jj]).getIndex() == 0) { <span class="comment">//find(called.begin(), called.end(), pathc[jj]-&gt;get_SgNode()) == called.end()) {</span>
<a name="l00494"></a>00494              <a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>* sgfd = <a class="code" href="Cxx__Grammar_8h.html#dfd4ff9ab7ae7515d1f66b6f565006df">isSgFunctionCallExp</a>(pathc[jj]-&gt;get_SgNode())-&gt;<a class="code" href="classSgFunctionCallExp.html#ecfaba690023f19b13e18887102f033a">getAssociatedFunctionDeclaration</a>();
<a name="l00495"></a>00495             <a class="code" href="classSgName.html">SgName</a> nam = sgfd-&gt;<a class="code" href="classSgFunctionDeclaration.html#49181f0af447c1e061002d994e55325f">get_qualified_name</a>();
<a name="l00496"></a>00496           <span class="comment">//  std::cout &lt;&lt; "function: " &lt;&lt; nam.getString() &lt;&lt; std::endl;</span>
<a name="l00497"></a>00497             ROSE_ASSERT(sgfd != NULL);
<a name="l00498"></a>00498             <a class="code" href="classSgFunctionDefinition.html">SgFunctionDefinition</a>* sgfdef = sgfd-&gt;get_definition();
<a name="l00499"></a>00499             <span class="comment">//ROSE_ASSERT(sgfdef != NULL);</span>
<a name="l00500"></a>00500 
<a name="l00501"></a>00501                 <span class="keywordflow">if</span> (sgfdef != NULL) {
<a name="l00502"></a>00502                <span class="comment">//std::cout &lt;&lt; "index:  " &lt;&lt; opencfg-&gt;toCFGNode(pathc[jj]).getIndex() &lt;&lt; std::endl;//pathc[jj]-&gt;get_index() &lt;&lt; std::endl;</span>
<a name="l00503"></a>00503                 ROSE_ASSERT(<a class="code" href="yicesParserLib_8h.html#1567203b4990b38c06dc3fdd400ecdbb">opencfg</a>-&gt;<a class="code" href="classStaticCFG_1_1CFG.html#6758ebe66068f45146dd9c7554ad8524">toCFGNode</a>(pathc[jj]).getIndex() == 0);
<a name="l00504"></a>00504                 <span class="comment">//ROSE_ASSERT(pathc[jj]-&gt;get_index() == 0);</span>
<a name="l00505"></a>00505                 <a class="code" href="yicesParserLib_8h.html#dff518c7e2524c5e961d2390af810489">propagateFunctionCall</a>(pathc, jj, jjf);
<a name="l00506"></a>00506                 
<a name="l00507"></a>00507                 <span class="comment">//called.push_back(pathc[jj]-&gt;get_SgNode());</span>
<a name="l00508"></a>00508                <span class="comment">//jjf = 0;</span>
<a name="l00509"></a>00509                 noadd = <span class="keyword">true</span>;
<a name="l00510"></a>00510                <span class="comment">//jj = 0;</span>
<a name="l00511"></a>00511                 <span class="keywordflow">break</span>;
<a name="l00512"></a>00512                 }
<a name="l00513"></a>00513                 <span class="keywordflow">else</span> {
<a name="l00514"></a>00514                 <span class="comment">//std::cout &lt;&lt; "ufunc: " &lt;&lt; nam.getString() &lt;&lt; std::endl;</span>
<a name="l00515"></a>00515                 <a class="code" href="yicesParserLib_8h.html#2253cf621c18f487291341f164ffdc57">unknownFunctions</a>.insert(pathc[jj]-&gt;get_SgNode());
<a name="l00516"></a>00516                 jj++;
<a name="l00517"></a>00517                 }
<a name="l00518"></a>00518             }
<a name="l00519"></a>00519             <span class="keywordflow">else</span> {
<a name="l00520"></a>00520                 jj++;
<a name="l00521"></a>00521             }
<a name="l00522"></a>00522        }
<a name="l00523"></a>00523        <span class="keywordflow">if</span> (noadd) {
<a name="l00524"></a>00524        jjf = 0;
<a name="l00525"></a>00525        noadd = <span class="keyword">false</span>;
<a name="l00526"></a>00526        }
<a name="l00527"></a>00527 
<a name="l00528"></a>00528        <span class="keywordflow">else</span> {
<a name="l00529"></a>00529        jjf++;
<a name="l00530"></a>00530        }
<a name="l00531"></a>00531        }
<a name="l00532"></a>00532 
<a name="l00533"></a>00533     <span class="comment">//std::cout &lt;&lt; "paths.size(): " &lt;&lt; paths.size() &lt;&lt; std::endl;</span>
<a name="l00534"></a>00534     <span class="comment">//ROSE_ASSERT(false); </span>
<a name="l00535"></a>00535     <a class="code" href="classvisitorTraversal.html#b20d536027de3f2189d6b30fae63e5a4">pathnumber</a> += <a class="code" href="yicesParserLib_8h.html#0ab651cea734fb0eb3ed32cef06b99ec">paths</a>.size();
<a name="l00536"></a>00536     std::vector&lt;SgNode*&gt; ncalled;
<a name="l00537"></a>00537 
<a name="l00538"></a>00538 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> q = 0; q &lt; <a class="code" href="yicesParserLib_8h.html#0ab651cea734fb0eb3ed32cef06b99ec">paths</a>.size(); q++) {
<a name="l00539"></a>00539    stringstream y;
<a name="l00540"></a>00540    y &lt;&lt; <span class="stringliteral">"yices"</span> &lt;&lt; <a class="code" href="yicesParserLib_8h.html#4e86b11357a2d99aa38a756cbc07d085">qst</a> + q &lt;&lt; <span class="stringliteral">".txt"</span>;
<a name="l00541"></a>00541     ofstream fout;
<a name="l00542"></a>00542     string fileSaver = <span class="stringliteral">"pathsets"</span>;
<a name="l00543"></a>00543     fout.open(fileSaver.c_str(),ios::app);
<a name="l00544"></a>00544     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> qr = 0; qr &lt; <a class="code" href="yicesParserLib_8h.html#0ab651cea734fb0eb3ed32cef06b99ec">paths</a>[q].size(); qr++) {
<a name="l00545"></a>00545          fout &lt;&lt; <a class="code" href="yicesParserLib_8h.html#154c30051e33d53ed0f6131c3f8460e5">getGraphNodeType</a>(<a class="code" href="yicesParserLib_8h.html#0ab651cea734fb0eb3ed32cef06b99ec">paths</a>[q][qr]) &lt;&lt; std::endl;
<a name="l00546"></a>00546     }
<a name="l00547"></a>00547     fout &lt;&lt; <span class="stringliteral">"************************\n"</span>;
<a name="l00548"></a>00548     fout.close();
<a name="l00549"></a>00549  
<a name="l00550"></a>00550   yices_enable_log_file((<span class="keywordtype">char</span>*) y.str().c_str());
<a name="l00551"></a>00551 
<a name="l00552"></a>00552   <a class="code" href="yicesParserLib_8h.html#d9c55e63216a3f4b4d8f344149a3646b">nameOf</a>.clear();
<a name="l00553"></a>00553   <a class="code" href="yicesParserLib_8h.html#3703af20b0be2697db1fcd0452dd9c6e">getExpr</a>.clear();
<a name="l00554"></a>00554   <span class="comment">//std::cout &lt;&lt; "q=" &lt;&lt; q &lt;&lt; std::endl;</span>
<a name="l00555"></a>00555   <span class="comment">//std::cout &lt;&lt; "path: " &lt;&lt; std::endl;</span>
<a name="l00556"></a>00556   <span class="comment">//for (int q1 = 0; q1 &lt; paths[q].size(); q1++) {</span>
<a name="l00557"></a>00557   <span class="comment">//    std::cout &lt;&lt; getGraphNodeType(paths[q][q1]);</span>
<a name="l00558"></a>00558  <span class="comment">//}</span>
<a name="l00559"></a>00559   <span class="comment">//std::cout &lt;&lt; "endpath" &lt;&lt; std::endl;</span>
<a name="l00560"></a>00560  <span class="comment">// std::cout &lt;&lt; "evalFunction" &lt;&lt; std::endl;</span>
<a name="l00561"></a>00561   std::vector&lt;SgGraphNode*&gt; path = <a class="code" href="yicesParserLib_8h.html#0ab651cea734fb0eb3ed32cef06b99ec">paths</a>[q];
<a name="l00562"></a>00562    <span class="comment">//yices_reset(ctx);</span>
<a name="l00563"></a>00563     <span class="comment">//for (int j = 0; j &lt; 4; j++) {</span>
<a name="l00564"></a>00564     ROSE_ASSERT(path.front()-&gt;get_SgNode() == path.back()-&gt;get_SgNode());
<a name="l00565"></a>00565     yices_context ctx = yices_mk_context();
<a name="l00566"></a>00566     yices_expr ye = <a class="code" href="yicesParserLib_8h.html#1ae824aad11e84a5193ed6f737f1402b">evalFunction</a>(path, ctx, <span class="keyword">true</span>);
<a name="l00567"></a>00567   <span class="comment">//for (int j = 0; j &lt; 4; j++) {</span>
<a name="l00568"></a>00568    <span class="comment">// yices_model ym = yices_get_model(ctx);</span>
<a name="l00569"></a>00569   <span class="comment">//yices_dump_context(ctx);</span>
<a name="l00570"></a>00570   <span class="keywordflow">switch</span>(yices_check(ctx)) {
<a name="l00571"></a>00571   <span class="keywordflow">case</span> l_true:
<a name="l00572"></a>00572   {
<a name="l00573"></a>00573     <span class="keywordflow">if</span> (<a class="code" href="yicesParserLib_8h.html#19d33e1e3b620862dfc2dd0d05c838ba">unknownvdeclis</a>.size() != 0) {
<a name="l00574"></a>00574     <span class="comment">//printf("satisfiable\n");</span>
<a name="l00575"></a>00575     yices_model m = yices_get_model(ctx);
<a name="l00576"></a>00576     <span class="comment">//printf("e1 = %d\n", yices_get_value(m, yices_get_var_decl(e1)));</span>
<a name="l00577"></a>00577     <span class="comment">//printf("e2 = %d\n", yices_get_value(m, yices_get_var_decl(e2)));</span>
<a name="l00578"></a>00578     <span class="comment">//yices_display_model(m);</span>
<a name="l00579"></a>00579     <a class="code" href="yicesParserLib_8h.html#99ae78e96160b26ce175394c6deb89cb">usingNots</a> = <span class="keyword">true</span>;
<a name="l00580"></a>00580     <span class="comment">//if (unknownvdeclis.size() != 0) {</span>
<a name="l00581"></a>00581     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> yy = 0; yy &lt; 4; yy++) {
<a name="l00582"></a>00582     std::cout &lt;&lt; <span class="stringliteral">"unknownvdeclis.size(): "</span> &lt;&lt; <a class="code" href="yicesParserLib_8h.html#19d33e1e3b620862dfc2dd0d05c838ba">unknownvdeclis</a>.size() &lt;&lt; std::endl;
<a name="l00583"></a>00583     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> yy2 = 0; yy2 &lt; <a class="code" href="yicesParserLib_8h.html#19d33e1e3b620862dfc2dd0d05c838ba">unknownvdeclis</a>.size(); yy2++) {
<a name="l00584"></a>00584     yices_var_decl vdecli = <span class="keyword">new</span> yices_var_decl();
<a name="l00585"></a>00585     vdecli = <a class="code" href="yicesParserLib_8h.html#19d33e1e3b620862dfc2dd0d05c838ba">unknownvdeclis</a>[yy2];
<a name="l00586"></a>00586     <a class="code" href="classSgInitializedName.html">SgInitializedName</a>* sg = <span class="keyword">new</span> <a class="code" href="classSgInitializedName.html">SgInitializedName</a>();
<a name="l00587"></a>00587     sg = <a class="code" href="yicesParserLib_8h.html#6cbb91bd6acaee78621ab5353ccbd78c">IName</a>[vdecli];
<a name="l00588"></a>00588     ROSE_ASSERT(sg != NULL);
<a name="l00589"></a>00589     ROSE_ASSERT(<a class="code" href="yicesParserLib_8h.html#6cbb91bd6acaee78621ab5353ccbd78c">IName</a>.find(vdecli) != <a class="code" href="yicesParserLib_8h.html#6cbb91bd6acaee78621ab5353ccbd78c">IName</a>.end());
<a name="l00590"></a>00590     <span class="keywordtype">long</span>* val = <span class="keyword">new</span> long;
<a name="l00591"></a>00591     yices_get_int_value(m,vdecli,val);
<a name="l00592"></a>00592     <a class="code" href="classSgName.html">SgName</a> sn = sg-&gt;<a class="code" href="classSgInitializedName.html#564cb1f49b92b7e08a4d4da072f3d26c">get_qualified_name</a>();
<a name="l00593"></a>00593     
<a name="l00594"></a>00594     std::cout &lt;&lt; <span class="stringliteral">"unknown "</span> &lt;&lt; sn.<a class="code" href="classSgName.html#f0b50e9570235a749205387bfa04cead">getString</a>() &lt;&lt;  <span class="stringliteral">" is: "</span> &lt;&lt; *val &lt;&lt; std::endl;
<a name="l00595"></a>00595     <a class="code" href="yicesParserLib_8h.html#2191c6072731519cf2f129aa28b6268b">notMap</a>[sg].push_back(<span class="keywordtype">int</span>(*val));
<a name="l00596"></a>00596    }
<a name="l00597"></a>00597     yices_reset(ctx);
<a name="l00598"></a>00598     <span class="comment">//yices_del_context(ctx);</span>
<a name="l00599"></a>00599    <span class="comment">// ctx = yices_mk_context();</span>
<a name="l00600"></a>00600     <a class="code" href="yicesParserLib_8h.html#d9c55e63216a3f4b4d8f344149a3646b">nameOf</a>.clear();
<a name="l00601"></a>00601     <a class="code" href="yicesParserLib_8h.html#3703af20b0be2697db1fcd0452dd9c6e">getExpr</a>.clear();
<a name="l00602"></a>00602     <a class="code" href="yicesParserLib_8h.html#b045f2a580863d59bb16abe16d0f586f">unknowns</a>.clear();
<a name="l00603"></a>00603     <a class="code" href="yicesParserLib_8h.html#19d33e1e3b620862dfc2dd0d05c838ba">unknownvdeclis</a>.clear();
<a name="l00604"></a>00604     <a class="code" href="yicesParserLib_8h.html#6cbb91bd6acaee78621ab5353ccbd78c">IName</a>.clear();
<a name="l00605"></a>00605      
<a name="l00606"></a>00606     <a class="code" href="yicesParserLib_8h.html#8ee962f3a476a38b126c24b0b06de591">inconsistent</a> = <span class="keyword">false</span>;
<a name="l00607"></a>00607     <a class="code" href="yicesParserLib_8h.html#1ae824aad11e84a5193ed6f737f1402b">evalFunction</a>(path, ctx, <span class="keyword">true</span>);
<a name="l00608"></a>00608     
<a name="l00609"></a>00609     <span class="keywordflow">if</span> (yices_inconsistent(ctx)) {
<a name="l00610"></a>00610        std::cout &lt;&lt; <span class="stringliteral">"********************"</span> &lt;&lt; std::endl;
<a name="l00611"></a>00611        std::cout &lt;&lt; <span class="stringliteral">"inconsistent at yy: "</span> &lt;&lt; yy &lt;&lt; std::endl; 
<a name="l00612"></a>00612        std::cout &lt;&lt; <span class="stringliteral">"********************"</span> &lt;&lt; std::endl;
<a name="l00613"></a>00613        <span class="keywordflow">break</span>;
<a name="l00614"></a>00614     }
<a name="l00615"></a>00615     <span class="keywordflow">else</span> {
<a name="l00616"></a>00616        <span class="comment">// yices_dump_context(ctx);</span>
<a name="l00617"></a>00617         yices_check(ctx);
<a name="l00618"></a>00618         yices_model m = yices_get_model(ctx);
<a name="l00619"></a>00619         std::cout &lt;&lt; <span class="stringliteral">"*****************"</span> &lt;&lt; std::endl;
<a name="l00620"></a>00620         std::cout &lt;&lt; <span class="stringliteral">"consistent at yy: "</span> &lt;&lt; yy &lt;&lt; std::endl;
<a name="l00621"></a>00621         std::cout &lt;&lt; <span class="stringliteral">"*****************"</span> &lt;&lt; std::endl;
<a name="l00622"></a>00622     <span class="comment">//    yices_display_model(m);</span>
<a name="l00623"></a>00623     }
<a name="l00624"></a>00624     } 
<a name="l00625"></a>00625     <span class="comment">//unknownvdeclis.clear();</span>
<a name="l00626"></a>00626     <a class="code" href="yicesParserLib_8h.html#99ae78e96160b26ce175394c6deb89cb">usingNots</a> = <span class="keyword">false</span>;
<a name="l00627"></a>00627    <span class="comment">// break;</span>
<a name="l00628"></a>00628   }
<a name="l00629"></a>00629   <span class="keywordflow">break</span>; 
<a name="l00630"></a>00630   }
<a name="l00631"></a>00631   <span class="keywordflow">case</span> l_false:
<a name="l00632"></a>00632    <span class="comment">// printf("unsatisfiable\n");</span>
<a name="l00633"></a>00633     <span class="keywordflow">break</span>;
<a name="l00634"></a>00634   <span class="keywordflow">case</span> l_undef:
<a name="l00635"></a>00635     printf(<span class="stringliteral">"unknown\n"</span>);
<a name="l00636"></a>00636     <span class="keywordflow">break</span>;
<a name="l00637"></a>00637   }
<a name="l00638"></a>00638 
<a name="l00639"></a>00639     <a class="code" href="yicesParserLib_8h.html#99ae78e96160b26ce175394c6deb89cb">usingNots</a> = <span class="keyword">false</span>;
<a name="l00640"></a>00640     yices_reset(ctx);
<a name="l00641"></a>00641     <a class="code" href="yicesParserLib_8h.html#2191c6072731519cf2f129aa28b6268b">notMap</a>.clear();   
<a name="l00642"></a>00642     <a class="code" href="yicesParserLib_8h.html#d9c55e63216a3f4b4d8f344149a3646b">nameOf</a>.clear();
<a name="l00643"></a>00643     <a class="code" href="yicesParserLib_8h.html#3703af20b0be2697db1fcd0452dd9c6e">getExpr</a>.clear();
<a name="l00644"></a>00644     <a class="code" href="yicesParserLib_8h.html#b045f2a580863d59bb16abe16d0f586f">unknowns</a>.clear();
<a name="l00645"></a>00645     <a class="code" href="yicesParserLib_8h.html#19d33e1e3b620862dfc2dd0d05c838ba">unknownvdeclis</a>.clear();
<a name="l00646"></a>00646 }
<a name="l00647"></a>00647 <span class="comment">//}</span>
<a name="l00648"></a>00648 <a class="code" href="yicesParserLib_8h.html#4e86b11357a2d99aa38a756cbc07d085">qst</a> += <a class="code" href="yicesParserLib_8h.html#0ab651cea734fb0eb3ed32cef06b99ec">paths</a>.size();
<a name="l00649"></a>00649 }
<a name="l00650"></a>00650 
<a name="l00651"></a>00651 <span class="comment">//bool inconsistent;</span>
<a name="l00652"></a>00652 
<a name="l00653"></a><a class="code" href="yicesParserLib_8h.html#1ae824aad11e84a5193ed6f737f1402b">00653</a> yices_expr <a class="code" href="yicesParserLib_8h.html#1ae824aad11e84a5193ed6f737f1402b">evalFunction</a>(std::vector&lt;SgGraphNode*&gt; path, yices_context&amp; ctx, <span class="keywordtype">bool</span> mainFlag) {
<a name="l00654"></a>00654     <span class="keywordtype">int</span> i = 0;
<a name="l00655"></a>00655     <span class="keywordtype">bool</span> <a class="code" href="yicesParserLib_8h.html#cf72a788e5ca240904eed58d8f702e85">noAssert</a> = <span class="keyword">false</span>;
<a name="l00656"></a>00656     <span class="keywordtype">int</span> <a class="code" href="yicesParserLib_8h.html#b951ebd61b5fff7fb5c4212d7fc63254">rounds</a> = 0;
<a name="l00657"></a>00657     <span class="comment">//bool forFlag = false;</span>
<a name="l00658"></a>00658     <span class="keywordtype">int</span> defscount = 0;
<a name="l00659"></a>00659     <span class="comment">//bool inconsistent = false;</span>
<a name="l00660"></a>00660     std::vector&lt;SgGraphNode*&gt; exprPath;
<a name="l00661"></a>00661 <span class="comment">/*</span>
<a name="l00662"></a>00662 <span class="comment">    if (!mainFlag &amp;&amp; isSgFunctionCallExp(path.front()-&gt;get_SgNode())) {</span>
<a name="l00663"></a>00663 <span class="comment">        path.pop_back();</span>
<a name="l00664"></a>00664 <span class="comment">        int qq = 0;</span>
<a name="l00665"></a>00665 <span class="comment">        while (defscount &lt; 2) {</span>
<a name="l00666"></a>00666 <span class="comment">        while (path[qq]-&gt;get_SgNode() != path[0]-&gt;get_SgNode()) {</span>
<a name="l00667"></a>00667 <span class="comment">           qq++;</span>
<a name="l00668"></a>00668 <span class="comment">        }</span>
<a name="l00669"></a>00669 <span class="comment">        defscount++;</span>
<a name="l00670"></a>00670 <span class="comment">        }</span>
<a name="l00671"></a>00671 <span class="comment">        std::vector&lt;SgGraphNode*&gt; npath;</span>
<a name="l00672"></a>00672 <span class="comment">        for (int qw = qq; qw &lt; path.size(); qw++) {</span>
<a name="l00673"></a>00673 <span class="comment">            npath.push_back(path[qw]);</span>
<a name="l00674"></a>00674 <span class="comment">        }</span>
<a name="l00675"></a>00675 <span class="comment">        path = npath;</span>
<a name="l00676"></a>00676 <span class="comment">       </span>
<a name="l00677"></a>00677 <span class="comment">    }</span>
<a name="l00678"></a>00678 <span class="comment">*/</span>
<a name="l00679"></a>00679 <span class="comment">/*</span>
<a name="l00680"></a>00680 <span class="comment">    if (unknownFunctions.find(isSgFunctionCallExp(path[0]-&gt;get_SgNode())) != unknownFunctions.end()) {</span>
<a name="l00681"></a>00681 <span class="comment">        SgFunctionDeclaration* afd = (isSgFunctionCallExp(path[0]-&gt;get_SgNode()))-&gt;getAssociatedFunctionDeclaration();</span>
<a name="l00682"></a>00682 <span class="comment">        SgType* ty = afd.get_orig_return_type();</span>
<a name="l00683"></a>00683 <span class="comment">        string ty_str = getType(ty);</span>
<a name="l00684"></a>00684 <span class="comment">        SgInitializedNamePtrList* sipl = afd-&gt;get_args();</span>
<a name="l00685"></a>00685 <span class="comment">        yices_type dom[sipl-&gt;size()]</span>
<a name="l00686"></a>00686 <span class="comment">        int iic = 0;;</span>
<a name="l00687"></a>00687 <span class="comment">        for (SgInitializedNamePtrList::iterator ii = sipl.begin(); ii != sipl.end(); ii++) {</span>
<a name="l00688"></a>00688 <span class="comment">            dom[iic] = (*ii)-&gt;get_type();</span>
<a name="l00689"></a>00689 <span class="comment">            </span>
<a name="l00690"></a>00690 <span class="comment">            iic++;</span>
<a name="l00691"></a>00691 <span class="comment">        }</span>
<a name="l00692"></a>00692 <span class="comment">        int ds = iic;</span>
<a name="l00693"></a>00693 <span class="comment">        yices_type fty = yices_mk_function_type(ctx, dom, ds, ty);</span>
<a name="l00694"></a>00694 <span class="comment">        yices_var_decl ftydecl = (ctx, afd-&gt;get_qualified_name()-&gt;getString(),fty);</span>
<a name="l00695"></a>00695 <span class="comment">        yices_expr f = yices_mk_var_from_decl(ctx, ftydecl);</span>
<a name="l00696"></a>00696 <span class="comment"></span>
<a name="l00697"></a>00697 <span class="comment"></span>
<a name="l00698"></a>00698 <span class="comment"></span>
<a name="l00699"></a>00699 <span class="comment"></span>
<a name="l00700"></a>00700 <span class="comment">    }</span>
<a name="l00701"></a>00701 <span class="comment">*/</span>
<a name="l00702"></a>00702     <span class="keywordflow">while</span> (i &lt; path.size()) {
<a name="l00703"></a>00703        <span class="comment">// std::cout &lt;&lt; "in evalFunction" &lt;&lt; std::endl;</span>
<a name="l00704"></a>00704        <span class="comment">// std::cout &lt;&lt; "ith node: " &lt;&lt; getGraphNodeType(path[i]) &lt;&lt; "at i = " &lt;&lt; i &lt;&lt; std::endl;</span>
<a name="l00705"></a>00705        <span class="comment">// std::cout &lt;&lt; "path.size(): " &lt;&lt; path.size() &lt;&lt; std::endl;</span>
<a name="l00706"></a>00706 <span class="comment">/*</span>
<a name="l00707"></a>00707 <span class="comment">        if (inconsistent) {</span>
<a name="l00708"></a>00708 <span class="comment">            if (!mainFlag) {</span>
<a name="l00709"></a>00709 <span class="comment">                yices_expr wrong;</span>
<a name="l00710"></a>00710 <span class="comment">                return wrong;</span>
<a name="l00711"></a>00711 <span class="comment">            }</span>
<a name="l00712"></a>00712 <span class="comment">            else {</span>
<a name="l00713"></a>00713 <span class="comment">                inconsistent = false;</span>
<a name="l00714"></a>00714 <span class="comment">                yices_expr zrong;</span>
<a name="l00715"></a>00715 <span class="comment">                return zrong;</span>
<a name="l00716"></a>00716 <span class="comment">            }</span>
<a name="l00717"></a>00717 <span class="comment">        }*/</span>
<a name="l00718"></a>00718         <span class="keywordflow">if</span> (yices_inconsistent(ctx)<span class="comment">/* || inconsistent*/</span>) {
<a name="l00719"></a>00719             <a class="code" href="yicesParserLib_8h.html#8ee962f3a476a38b126c24b0b06de591">inconsistent</a> = <span class="keyword">true</span>;
<a name="l00720"></a>00720            <span class="comment">// std::cout &lt;&lt; "inconsistent" &lt;&lt; std::endl;</span>
<a name="l00721"></a>00721             <span class="keywordflow">if</span> (mainFlag) {
<a name="l00722"></a>00722            <span class="comment">// std::cout &lt;&lt; "*****************************************" &lt;&lt; std::endl;</span>
<a name="l00723"></a>00723            <span class="comment">// std::cout &lt;&lt; "inconsistent path: " &lt;&lt; std::endl;</span>
<a name="l00724"></a>00724             <span class="comment">//for (int q4 = 0; q4 &lt; path.size(); q4++) {</span>
<a name="l00725"></a>00725              <span class="comment">//   std::cout &lt;&lt; getGraphNodeType(path[q4]);</span>
<a name="l00726"></a>00726             <span class="comment">//}</span>
<a name="l00727"></a>00727             <span class="comment">//std::cout &lt;&lt; "end path" &lt;&lt; std::endl;</span>
<a name="l00728"></a>00728             <span class="comment">//std::cout &lt;&lt; "******************************************" &lt;&lt; std::endl;</span>
<a name="l00729"></a>00729             <span class="keywordflow">if</span> (!<a class="code" href="yicesParserLib_8h.html#99ae78e96160b26ce175394c6deb89cb">usingNots</a>) {
<a name="l00730"></a>00730             <a class="code" href="yicesParserLib_8h.html#a1014aaa0c222827ec6431f1f6c2133d">ipaths</a>++;
<a name="l00731"></a>00731             }
<a name="l00732"></a>00732             <a class="code" href="yicesParserLib_8h.html#8ee962f3a476a38b126c24b0b06de591">inconsistent</a> = <span class="keyword">false</span>;
<a name="l00733"></a>00733             }
<a name="l00734"></a>00734             yices_expr ywrong = yices_mk_fresh_bool_var(ctx);
<a name="l00735"></a>00735             <span class="keywordflow">return</span> ywrong;
<a name="l00736"></a>00736         }
<a name="l00737"></a>00737         <span class="comment">//std::cout &lt;&lt; "i: " &lt;&lt; i &lt;&lt; std::endl;</span>
<a name="l00738"></a>00738         exprPath.clear(); 
<a name="l00739"></a>00739         <span class="comment">//VertexID2 v1;</span>
<a name="l00740"></a>00740         <span class="comment">//VertexID2 v2;</span>
<a name="l00741"></a>00741         <span class="comment">//std::cout &lt;&lt; "in while" &lt;&lt; std::endl;</span>
<a name="l00742"></a>00742         <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#6b53e0a9cc36bc2fcb155a5b5c8bfdac">isSgReturnStmt</a>(path[i]-&gt;get_SgNode())) {
<a name="l00743"></a>00743           <span class="comment">// std::cout &lt;&lt; "retstmt" &lt;&lt; std::endl;</span>
<a name="l00744"></a>00744           <span class="comment">// std::cout &lt;&lt; "i: " &lt;&lt; i &lt;&lt; ", path.size(): " &lt;&lt; path.size() &lt;&lt; std::endl;</span>
<a name="l00745"></a>00745            std::vector&lt;SgGraphNode*&gt; retpath;
<a name="l00746"></a>00746            <span class="comment">//retpath.push_back(path[i]);</span>
<a name="l00747"></a>00747             
<a name="l00748"></a>00748            <span class="keywordtype">int</span> j = i+1;
<a name="l00749"></a>00749            <span class="keywordflow">while</span> (path[j]-&gt;get_SgNode() != path[i]-&gt;get_SgNode()) {
<a name="l00750"></a>00750               retpath.push_back(path[j]);
<a name="l00751"></a>00751             <span class="comment">//  std::cout &lt;&lt; "path[j]: " &lt;&lt; getGraphNodeType(path[j]) &lt;&lt; std::endl;</span>
<a name="l00752"></a>00752               j++;
<a name="l00753"></a>00753               <span class="keywordflow">if</span> (j == path.size()) {
<a name="l00754"></a>00754                   <span class="keywordflow">break</span>;
<a name="l00755"></a>00755               }
<a name="l00756"></a>00756            }
<a name="l00757"></a>00757            <span class="comment">//retpath.push_back(path[j]);</span>
<a name="l00758"></a>00758            yices_expr retparse = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(retpath, ctx);
<a name="l00759"></a>00759            <span class="keywordflow">if</span> (!mainFlag) {
<a name="l00760"></a>00760                <span class="keywordflow">return</span> retparse;
<a name="l00761"></a>00761                <span class="comment">//yices_assert(retparse, ctx);</span>
<a name="l00762"></a>00762            }
<a name="l00763"></a>00763            i += retpath.size()+2;
<a name="l00764"></a>00764         }
<a name="l00765"></a>00765 
<a name="l00766"></a>00766         <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#3d55e45b923661b7efeeb664266d2527">isSgInitializedName</a>(path[i]-&gt;get_SgNode()) <span class="comment">/*&amp;&amp; knownNodes.find(path[i]-&gt;get_SgNode()) == knownNodes.end()*/</span>) {
<a name="l00767"></a>00767            <span class="comment">// exprs.push_back(path[i]);</span>
<a name="l00768"></a>00768             exprPath.clear();
<a name="l00769"></a>00769            exprPath.push_back(path[i]);
<a name="l00770"></a>00770            <span class="keywordflow">if</span> (path[i]-&gt;get_SgNode()-&gt;cfgIndexForEnd() == 0) {
<a name="l00771"></a>00771                     
<a name="l00772"></a>00772                     <a class="code" href="classSgName.html">SgName</a> svs = (<a class="code" href="Cxx__Grammar_8h.html#3d55e45b923661b7efeeb664266d2527">isSgInitializedName</a>(exprPath[0]-&gt;get_SgNode()))-&gt;get_qualified_name();
<a name="l00773"></a>00773                     <span class="keywordflow">if</span> (<a class="code" href="yicesParserLib_8h.html#d9c55e63216a3f4b4d8f344149a3646b">nameOf</a>.find(svs) == <a class="code" href="yicesParserLib_8h.html#d9c55e63216a3f4b4d8f344149a3646b">nameOf</a>.end()) {
<a name="l00774"></a>00774                     <a class="code" href="classSgType.html">SgType</a>* typ = (<a class="code" href="Cxx__Grammar_8h.html#3d55e45b923661b7efeeb664266d2527">isSgInitializedName</a>(exprPath[0]-&gt;get_SgNode()))-&gt;get_type();
<a name="l00775"></a>00775                     string typ_str = <a class="code" href="yicesParserLib_8h.html#2a78ff2b912bbb36235508d39c77c9b6">getType</a>(typ);
<a name="l00776"></a>00776                     stringstream funN;
<a name="l00777"></a>00777                     <span class="comment">//funN &lt;&lt; "V" &lt;&lt; nvars;</span>
<a name="l00778"></a>00778                     <a class="code" href="yicesParserLib_8h.html#e8f6d2fd6490d3153cb4133bf183a404">nvars</a>++; 
<a name="l00779"></a>00779                     funN &lt;&lt; svs.<a class="code" href="classSgName.html#f0b50e9570235a749205387bfa04cead">getString</a>() &lt;&lt; <a class="code" href="yicesParserLib_8h.html#e8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l00780"></a>00780                     <span class="keywordtype">char</span>* fun = (<span class="keywordtype">char</span>*) funN.str().c_str();
<a name="l00781"></a>00781                     <span class="keywordtype">char</span>* valTypeCh = (<span class="keywordtype">char</span>*) typ_str.c_str();
<a name="l00782"></a>00782                     yices_type ty = yices_mk_type(ctx, valTypeCh);
<a name="l00783"></a>00783                     yices_var_decl vdecl = yices_mk_var_decl(ctx, fun, ty);
<a name="l00784"></a>00784                     yices_expr e1 = yices_mk_var_from_decl(ctx, vdecl);
<a name="l00785"></a>00785                     <a class="code" href="yicesParserLib_8h.html#3703af20b0be2697db1fcd0452dd9c6e">getExpr</a>[svs] = e1;
<a name="l00786"></a>00786                     <a class="code" href="yicesParserLib_8h.html#d9c55e63216a3f4b4d8f344149a3646b">nameOf</a>[svs] = funN.str();
<a name="l00787"></a>00787                     }
<a name="l00788"></a>00788                     i++; 
<a name="l00789"></a>00789             }
<a name="l00790"></a>00790             <span class="keywordflow">else</span> { 
<a name="l00791"></a>00791             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = i+1;
<a name="l00792"></a>00792             <span class="comment">//while (k &lt; path.size() &amp;&amp; (!isSgInitializedName(path[k]-&gt;get_SgNode()) || path[k]-&gt;get_SgNode() != path[i]-&gt;get_SgNode())) {</span>
<a name="l00793"></a>00793             <span class="comment">//    exprPath.push_back(path[k]);</span>
<a name="l00794"></a>00794             <span class="comment">//    k++;</span>
<a name="l00795"></a>00795            <span class="comment">// }</span>
<a name="l00796"></a>00796            <span class="comment">// exprPath.push_back(path[i]);</span>
<a name="l00797"></a>00797             <span class="keywordtype">int</span> check = 0;
<a name="l00798"></a>00798             <span class="keywordflow">while</span> (check &lt; path[i]-&gt;get_SgNode()-&gt;cfgIndexForEnd()) {<span class="comment">//path[k]-&gt;get_SgNode() != path[i]-&gt;get_SgNode()) {</span>
<a name="l00799"></a>00799                 <span class="keywordflow">if</span> (path[i]-&gt;get_SgNode() == path[k]-&gt;get_SgNode()) {
<a name="l00800"></a>00800                     check++;
<a name="l00801"></a>00801                     <span class="keywordflow">if</span> (check == path[i]-&gt;get_SgNode()-&gt;cfgIndexForEnd()) {
<a name="l00802"></a>00802                         <span class="keywordflow">break</span>;
<a name="l00803"></a>00803                     }
<a name="l00804"></a>00804                 }
<a name="l00805"></a>00805                 exprPath.push_back(path[k]);
<a name="l00806"></a>00806                 k++;
<a name="l00807"></a>00807             }
<a name="l00808"></a>00808             exprPath.push_back(path[k]);
<a name="l00809"></a>00809             <span class="comment">//std::cout &lt;&lt; "EXPRPATH: " &lt;&lt; std::endl;</span>
<a name="l00810"></a>00810             <span class="comment">//for (int oo = 0; oo &lt; exprPath.size(); oo++) {</span>
<a name="l00811"></a>00811             <span class="comment">//    std::cout &lt;&lt; getGraphNodeType(exprPath[oo]) &lt;&lt; std::endl;</span>
<a name="l00812"></a>00812            <span class="comment">// }</span>
<a name="l00813"></a>00813            <span class="comment">// std::cout &lt;&lt; std::endl;</span>
<a name="l00814"></a>00814            <span class="comment">// SE_ASSERT(y1 != NULL);</span>
<a name="l00815"></a>00815             yices_expr y1;
<a name="l00816"></a>00816             <span class="comment">//std::cout &lt;&lt; "exprPath.size(): " &lt;&lt; exprPath.size() &lt;&lt; std::endl; </span>
<a name="l00817"></a>00817           <span class="comment">//  if (isSgIfStmt(exprPath[0]-&gt;get_SgNode()) || isSgForStatement(exprPath[0]-&gt;get_SgNode())) {</span>
<a name="l00818"></a>00818           <span class="comment">//       y1 = evalFunction(exprPath,ctx,false);</span>
<a name="l00819"></a>00819           <span class="comment">//  }</span>
<a name="l00820"></a>00820           <span class="comment">//  else {</span>
<a name="l00821"></a>00821                 y1 = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(exprPath, ctx);
<a name="l00822"></a>00822           <span class="comment">//  }</span>
<a name="l00823"></a>00823             ROSE_ASSERT(y1 != NULL);
<a name="l00824"></a>00824             <span class="keywordflow">if</span> (!<a class="code" href="yicesParserLib_8h.html#ecc8aa7e3d5e014159a274d129d468f8">unknown_flag</a> &amp;&amp; <a class="code" href="yicesParserLib_8h.html#b045f2a580863d59bb16abe16d0f586f">unknowns</a>.find(<a class="code" href="Cxx__Grammar_8h.html#3d55e45b923661b7efeeb664266d2527">isSgInitializedName</a>(path[i]-&gt;get_SgNode())) == <a class="code" href="yicesParserLib_8h.html#b045f2a580863d59bb16abe16d0f586f">unknowns</a>.end()) {<span class="comment">//find(unknowns.begin(), unknowns.end(), path[i]-&gt;get_SgNode()) == unknowns.end()) {</span>
<a name="l00825"></a>00825             <span class="comment">//if (y1 != NULL) {</span>
<a name="l00826"></a>00826             
<a name="l00827"></a>00827             yices_assert(ctx, y1);
<a name="l00828"></a>00828             <span class="comment">//}</span>
<a name="l00829"></a>00829             }
<a name="l00830"></a>00830             <span class="keywordflow">else</span> {
<a name="l00831"></a>00831                <span class="comment">// if (find(unknowns.begin(), unknowns.end(), path[i]-&gt;get_SgNode()) == unknowns.end()) {</span>
<a name="l00832"></a>00832                <span class="comment">// unknowns.push_back(path[i]-&gt;get_SgNode()); </span>
<a name="l00833"></a>00833                <span class="comment">// }</span>
<a name="l00834"></a>00834                 <a class="code" href="yicesParserLib_8h.html#ecc8aa7e3d5e014159a274d129d468f8">unknown_flag</a> = <span class="keyword">false</span>;
<a name="l00835"></a>00835             }
<a name="l00836"></a>00836             i += exprPath.size()+1;
<a name="l00837"></a>00837             exprPath.clear();
<a name="l00838"></a>00838             k = 0;
<a name="l00839"></a>00839         }
<a name="l00840"></a>00840         }
<a name="l00841"></a>00841         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#957bbfe0b3f81bb2e7d79e2bf9a78daa">isSgWhileStmt</a>(path[i]-&gt;get_SgNode()) &amp;&amp; <a class="code" href="yicesParserLib_8h.html#1567203b4990b38c06dc3fdd400ecdbb">opencfg</a>-&gt;<a class="code" href="classStaticCFG_1_1CFG.html#6758ebe66068f45146dd9c7554ad8524">toCFGNode</a>(path[i]).getIndex() == 0) {
<a name="l00842"></a>00842             std::vector&lt;SgGraphNode*&gt; internals;
<a name="l00843"></a>00843             std::vector&lt;SgGraphNode*&gt; exitStmt;
<a name="l00844"></a>00844             <span class="keywordtype">int</span> iorig = i;
<a name="l00845"></a>00845             i = i + 2;
<a name="l00846"></a>00846           <span class="comment">//  std::cout &lt;&lt; "path[i+1]: " &lt;&lt; getGraphNodeType(path[iorig+1]) &lt;&lt; ", " &lt;&lt; "path[i+2]: " &lt;&lt; getGraphNodeType(path[iorig+2]) &lt;&lt; std::endl;</span>
<a name="l00847"></a>00847           <span class="comment">//  std::cout &lt;&lt; "exitStmt" &lt;&lt; std::endl; </span>
<a name="l00848"></a>00848            <span class="comment">// std::cout &lt;&lt; "internals" &lt;&lt; std::endl;</span>
<a name="l00849"></a>00849             <span class="keywordflow">while</span> (i &lt; path.size() &amp;&amp; path[i]-&gt;get_SgNode() != path[iorig]-&gt;get_SgNode()) {
<a name="l00850"></a>00850                 <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#4d34219f3b936907cada5220a0514ec3">isSgBasicBlock</a>(path[i]-&gt;get_SgNode())) {
<a name="l00851"></a>00851                     i++;
<a name="l00852"></a>00852                 }
<a name="l00853"></a>00853                 <span class="keywordflow">else</span> {
<a name="l00854"></a>00854                 exitStmt.push_back(path[i]);
<a name="l00855"></a>00855                 
<a name="l00856"></a>00856             <span class="comment">//    std::cout &lt;&lt; getGraphNodeType(path[i]) &lt;&lt; std::endl;</span>
<a name="l00857"></a>00857                 i++;
<a name="l00858"></a>00858                 }
<a name="l00859"></a>00859             }
<a name="l00860"></a>00860             exitStmt.pop_back();
<a name="l00861"></a>00861             i++;
<a name="l00862"></a>00862             <span class="comment">//std::cout &lt;&lt; "end exitStmt" &lt;&lt; std::endl;//end internals" &lt;&lt; std::endl;</span>
<a name="l00863"></a>00863            <span class="comment">// std::cout &lt;&lt; "exitStmt" &lt;&lt; std::endl;</span>
<a name="l00864"></a>00864            <span class="comment">// std::cout &lt;&lt; "internals" &lt;&lt; std::endl;</span>
<a name="l00865"></a>00865             <span class="keywordflow">while</span> (i &lt; path.size() &amp;&amp; path[iorig]-&gt;get_SgNode() != path[i]-&gt;get_SgNode()){
<a name="l00866"></a>00866                <span class="comment">// if (!isSgBasicBlock(path[i]-&gt;get_SgNode())) {</span>
<a name="l00867"></a>00867                 internals.push_back(path[i]);
<a name="l00868"></a>00868                <span class="comment">// }</span>
<a name="l00869"></a>00869              <span class="comment">//   std::cout &lt;&lt; getGraphNodeType(path[i]) &lt;&lt; std::endl;</span>
<a name="l00870"></a>00870                 i++;
<a name="l00871"></a>00871             }
<a name="l00872"></a>00872             <span class="comment">//std::cout &lt;&lt; "end internals" &lt;&lt; std::endl;</span>
<a name="l00873"></a>00873            <span class="comment">// std::cout &lt;&lt; "end exit stmt" &lt;&lt; std::endl;</span>
<a name="l00874"></a>00874             <span class="keywordflow">if</span> (internals.size() == 0) {
<a name="l00875"></a>00875                 yices_expr wh = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(exitStmt, ctx);
<a name="l00876"></a>00876                 yices_expr nwhile = yices_mk_not(ctx,wh);
<a name="l00877"></a>00877                 yices_assert(ctx,nwhile);
<a name="l00878"></a>00878                 i++;
<a name="l00879"></a>00879             }
<a name="l00880"></a>00880             
<a name="l00881"></a>00881             <span class="keywordflow">else</span> {
<a name="l00882"></a>00882                iorig = i;
<a name="l00883"></a>00883                i++;
<a name="l00884"></a>00884                <span class="keywordflow">while</span> (path[i]-&gt;get_SgNode() != path[iorig]-&gt;get_SgNode()) {
<a name="l00885"></a>00885                    i++;
<a name="l00886"></a>00886                }
<a name="l00887"></a>00887                <span class="keywordtype">bool</span> good = <span class="keyword">false</span>;
<a name="l00888"></a>00888                <span class="keywordtype">int</span> n = 0;
<a name="l00889"></a>00889                <span class="keywordflow">while</span> (n &lt; <a class="code" href="yicesParserLib_8h.html#ec58e468363518c3dd79045de7ae1fa7">FORLOOPS</a>) {
<a name="l00890"></a>00890               <span class="comment">//      std::cout &lt;&lt; "n = " &lt;&lt; n &lt;&lt; std::endl;</span>
<a name="l00891"></a>00891                     yices_push(ctx);
<a name="l00892"></a>00892                     yices_expr exityi = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(exitStmt, ctx);
<a name="l00893"></a>00893                     yices_assert(ctx, exityi);
<a name="l00894"></a>00894                     <span class="keywordflow">if</span> (yices_inconsistent(ctx)) {
<a name="l00895"></a>00895                         yices_pop(ctx);
<a name="l00896"></a>00896                         <span class="keywordflow">if</span> (!yices_inconsistent(ctx)) {
<a name="l00897"></a>00897                         good = <span class="keyword">true</span>;
<a name="l00898"></a>00898                         <span class="keywordflow">break</span>;
<a name="l00899"></a>00899                         }
<a name="l00900"></a>00900                         <span class="keywordflow">else</span> {
<a name="l00901"></a>00901                         good = <span class="keyword">false</span>;
<a name="l00902"></a>00902                         <span class="keywordflow">break</span>;
<a name="l00903"></a>00903                         }
<a name="l00904"></a>00904                     }
<a name="l00905"></a>00905                     <span class="keywordflow">else</span> {
<a name="l00906"></a>00906                         yices_pop(ctx);
<a name="l00907"></a>00907                         yices_expr ev = <a class="code" href="yicesParserLib_8h.html#1ae824aad11e84a5193ed6f737f1402b">evalFunction</a>(internals, ctx, <span class="keyword">false</span>);
<a name="l00908"></a>00908                         <span class="comment">//yices_expr eupdate = mainParse(update, ctx);</span>
<a name="l00909"></a>00909                         <span class="comment">//yices_assert(ctx, eupdate);</span>
<a name="l00910"></a>00910                         <span class="comment">//yices_expr ev = evalFunction(internals, ctx, false);</span>
<a name="l00911"></a>00911                         <span class="comment">//yices_assert(ctx,ev);</span>
<a name="l00912"></a>00912                         n++;
<a name="l00913"></a>00913                     }
<a name="l00914"></a>00914                     <span class="comment">//else {</span>
<a name="l00915"></a>00915                     <span class="comment">//    yices_pop(ctx);</span>
<a name="l00916"></a>00916                     <span class="comment">//    good = true;</span>
<a name="l00917"></a>00917                     <span class="comment">//    break;</span>
<a name="l00918"></a>00918                    <span class="comment">// }</span>
<a name="l00919"></a>00919                }
<a name="l00920"></a>00920                <span class="keywordflow">if</span> (good) {
<a name="l00921"></a>00921                     yices_expr mP = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(exitStmt, ctx);
<a name="l00922"></a>00922                     yices_expr nmP = yices_mk_not(ctx, mP);
<a name="l00923"></a>00923                     yices_assert(ctx, nmP);
<a name="l00924"></a>00924             <span class="comment">//        std::cout &lt;&lt; "while, good in: " &lt;&lt; n &lt;&lt; " loops" &lt;&lt; std::endl;</span>
<a name="l00925"></a>00925                }
<a name="l00926"></a>00926                <span class="keywordflow">else</span> {
<a name="l00927"></a>00927                     yices_expr yf = yices_mk_false(ctx);
<a name="l00928"></a>00928                     yices_assert(ctx,yf);
<a name="l00929"></a>00929                }
<a name="l00930"></a>00930           <span class="comment">//while (i &lt; path.size() &amp;&amp; !isSgWhileStmt(path[i]-&gt;get_SgNode())) {</span>
<a name="l00931"></a>00931          <span class="comment">//     i++;  </span>
<a name="l00932"></a>00932          <span class="comment">// }</span>
<a name="l00933"></a>00933           <span class="comment">//std::cout &lt;&lt; "i+2" &lt;&lt; getGraphNodeType(path[i+2]) &lt;&lt; std::endl;</span>
<a name="l00934"></a>00934           i++;
<a name="l00935"></a>00935           <span class="keywordflow">while</span> (<a class="code" href="Cxx__Grammar_8h.html#4d34219f3b936907cada5220a0514ec3">isSgBasicBlock</a>(path[i]-&gt;get_SgNode())) {
<a name="l00936"></a>00936               i++;
<a name="l00937"></a>00937           }
<a name="l00938"></a>00938            
<a name="l00939"></a>00939         }
<a name="l00940"></a>00940         }
<a name="l00941"></a>00941 
<a name="l00942"></a>00942                 
<a name="l00943"></a>00943         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#8744ae8411519301478e4b4c1ab05361">isSgForStatement</a>(path[i]-&gt;get_SgNode()) &amp;&amp; <a class="code" href="yicesParserLib_8h.html#1567203b4990b38c06dc3fdd400ecdbb">opencfg</a>-&gt;<a class="code" href="classStaticCFG_1_1CFG.html#6758ebe66068f45146dd9c7554ad8524">toCFGNode</a>(path[i]).getIndex() == 0) {
<a name="l00944"></a>00944             std::vector&lt;SgGraphNode*&gt; internals;
<a name="l00945"></a>00945             std::vector&lt;SgGraphNode*&gt; initStmt;
<a name="l00946"></a>00946             std::vector&lt;SgGraphNode*&gt; exitStmt;
<a name="l00947"></a>00947             std::vector&lt;SgGraphNode*&gt; update;
<a name="l00948"></a>00948             <span class="comment">//std::cout &lt;&lt; "ForStmt" &lt;&lt; std::endl;</span>
<a name="l00949"></a>00949             ROSE_ASSERT(<a class="code" href="Cxx__Grammar_8h.html#ecaf12b181743cd52ddc2b87d8083453">isSgForInitStatement</a>(path[i+1]-&gt;get_SgNode()));
<a name="l00950"></a>00950             <span class="keywordtype">int</span> k = i+3;
<a name="l00951"></a>00951            <span class="comment">// std::cout &lt;&lt; "i: " &lt;&lt; getGraphNodeType(path[i]) &lt;&lt; std::endl;</span>
<a name="l00952"></a>00952            <span class="comment">// std::cout &lt;&lt; "k: " &lt;&lt; getGraphNodeType(path[k]) &lt;&lt; std::endl;</span>
<a name="l00953"></a>00953             <span class="comment">//std::cout &lt;&lt; "path[i+3]: " &lt;&lt; getGraphNodeType(path[i+3]) &lt;&lt; ", path[i+2]: " &lt;&lt; getGraphNodeType(path[i+2]) &lt;&lt; std::endl;</span>
<a name="l00954"></a>00954             <span class="comment">//std::cout &lt;&lt; "initStmt: " &lt;&lt; std::endl;</span>
<a name="l00955"></a>00955             <span class="keywordflow">while</span> (path[i+1]-&gt;get_SgNode() != path[k]-&gt;get_SgNode()) {
<a name="l00956"></a>00956                 initStmt.push_back(path[k]);
<a name="l00957"></a>00957             <span class="comment">//    std::cout &lt;&lt; getGraphNodeType(path[k]) &lt;&lt; std::endl;</span>
<a name="l00958"></a>00958                 k++;   
<a name="l00959"></a>00959             }
<a name="l00960"></a>00960             initStmt.pop_back(); 
<a name="l00961"></a>00961             <span class="comment">//std::cout &lt;&lt; std::endl;</span>
<a name="l00962"></a>00962             k++;
<a name="l00963"></a>00963             <span class="comment">//forFlag = true;</span>
<a name="l00964"></a>00964             yices_expr yk = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(initStmt, ctx);
<a name="l00965"></a>00965             <span class="comment">//forFlag = true;</span>
<a name="l00966"></a>00966            <span class="comment">// forFlag = false;</span>
<a name="l00967"></a>00967             yices_assert(ctx, yk);
<a name="l00968"></a>00968             ROSE_ASSERT(<a class="code" href="Cxx__Grammar_8h.html#8744ae8411519301478e4b4c1ab05361">isSgForStatement</a>(path[k]-&gt;get_SgNode()));
<a name="l00969"></a>00969             <span class="keywordtype">int</span> j = k+2;
<a name="l00970"></a>00970             <span class="keywordflow">while</span> (path[j]-&gt;get_SgNode() != path[k]-&gt;get_SgNode()) {
<a name="l00971"></a>00971                 exitStmt.push_back(path[j]);
<a name="l00972"></a>00972                 j++;
<a name="l00973"></a>00973             }
<a name="l00974"></a>00974             j++;
<a name="l00975"></a>00975            <span class="comment">// std::cout &lt;&lt; "exitStmt.front(): " &lt;&lt; getGraphNodeType(exitStmt.front()) &lt;&lt; std::endl;</span>
<a name="l00976"></a>00976            <span class="comment">// std::cout &lt;&lt; "exitStmt.back(): " &lt;&lt; getGraphNodeType(exitStmt.back()) &lt;&lt; std::endl;</span>
<a name="l00977"></a>00977             exitStmt.pop_back();
<a name="l00978"></a>00978             <span class="comment">//ROSE_ASSERT(exitStmt.size() != 0);</span>
<a name="l00979"></a>00979             <span class="comment">//std::cout &lt;&lt; "**********************" &lt;&lt; std::endl;</span>
<a name="l00980"></a>00980             <span class="comment">//std::cout &lt;&lt; "exitStmt" &lt;&lt; std::endl;</span>
<a name="l00981"></a>00981             <span class="comment">//for (int j2 = 0; j2 &lt; exitStmt.size(); j2++) {</span>
<a name="l00982"></a>00982             <span class="comment">//    std::cout &lt;&lt; getGraphNodeType(exitStmt[j2]) &lt;&lt; std::endl;</span>
<a name="l00983"></a>00983           <span class="comment">// }</span>
<a name="l00984"></a>00984           <span class="comment">// std::cout &lt;&lt; "end exitStmt" &lt;&lt; std::endl;</span>
<a name="l00985"></a>00985           <span class="comment">// std::cout &lt;&lt; "***********************" &lt;&lt; std::endl;</span>
<a name="l00986"></a>00986             <span class="comment">//j = j+1;</span>
<a name="l00987"></a>00987             <span class="keywordflow">while</span> (<a class="code" href="Cxx__Grammar_8h.html#4d34219f3b936907cada5220a0514ec3">isSgBasicBlock</a>(path[j]-&gt;get_SgNode())) {
<a name="l00988"></a>00988                 j++;
<a name="l00989"></a>00989             }
<a name="l00990"></a>00990             <span class="comment">//std::cout &lt;&lt; "j type: " &lt;&lt; getGraphNodeType(path[j]) &lt;&lt; std::endl;</span>
<a name="l00991"></a>00991             <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#8744ae8411519301478e4b4c1ab05361">isSgForStatement</a>(path[j]-&gt;get_SgNode()) &amp;&amp; <a class="code" href="yicesParserLib_8h.html#1567203b4990b38c06dc3fdd400ecdbb">opencfg</a>-&gt;<a class="code" href="classStaticCFG_1_1CFG.html#6758ebe66068f45146dd9c7554ad8524">toCFGNode</a>(path[j]).getIndex() == 4) {<span class="comment">// == path[i]-&gt;get_SgNode()) {</span>
<a name="l00992"></a>00992              <span class="comment">//   forFlag = true;</span>
<a name="l00993"></a>00993                <span class="comment">//std::cout &lt;&lt; "path btwn i and j: " &lt;&lt; std::endl;</span>
<a name="l00994"></a>00994                <span class="comment">//for (int k = i; k &lt; j+1; k++) {</span>
<a name="l00995"></a>00995                <span class="comment">//    std::cout &lt;&lt; getGraphNodeType(path[k]) &lt;&lt; std::endl;</span>
<a name="l00996"></a>00996                <span class="comment">//}</span>
<a name="l00997"></a>00997                <span class="comment">//std::cout &lt;&lt; "endpath" &lt;&lt; std::endl;</span>
<a name="l00998"></a>00998                 yices_expr exity = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(exitStmt, ctx);
<a name="l00999"></a>00999              <span class="comment">//   forFlag = true;</span>
<a name="l01000"></a>01000              <span class="comment">//   yices_assert(ctx, exity);</span>
<a name="l01001"></a>01001                 yices_expr notexp = yices_mk_not(ctx, exity);
<a name="l01002"></a>01002                 yices_assert(ctx, notexp);
<a name="l01003"></a>01003                 i++;
<a name="l01004"></a>01004                 <span class="comment">//i = j+1;</span>
<a name="l01005"></a>01005                 
<a name="l01006"></a>01006             }
<a name="l01007"></a>01007             <span class="keywordflow">else</span> {
<a name="l01008"></a>01008             <span class="keywordflow">while</span> (path[j]-&gt;get_SgNode() != path[i]-&gt;get_SgNode() &amp;&amp; j &lt; path.size()-1) {
<a name="l01009"></a>01009               <span class="comment">//  std::cout &lt;&lt; "currj: " &lt;&lt; getGraphNodeType(path[j]) &lt;&lt; std::endl;</span>
<a name="l01010"></a>01010                <span class="comment">// if (!isSgBasicBlock(path[j]-&gt;get_SgNode())) {</span>
<a name="l01011"></a>01011                 internals.push_back(path[j]);
<a name="l01012"></a>01012                <span class="comment">// }</span>
<a name="l01013"></a>01013                 j++;
<a name="l01014"></a>01014             }
<a name="l01015"></a>01015             <span class="comment">//std::cout &lt;&lt; "currj: " &lt;&lt; j &lt;&lt; ", path.size(): " &lt;&lt; path.size() &lt;&lt; ", node type: " &lt;&lt; getGraphNodeType(path[j]) &lt;&lt; std::endl;</span>
<a name="l01016"></a>01016             j++;
<a name="l01017"></a>01017            <span class="comment">// std::cout &lt;&lt; "XXXXXXXXXXXXXXXX" &lt;&lt; std::endl;</span>
<a name="l01018"></a>01018            <span class="comment">// std::cout &lt;&lt; "internals.size(): " &lt;&lt; internals.size() &lt;&lt; std::endl;</span>
<a name="l01019"></a>01019           <span class="comment">//  for (int qr = 0; qr &lt; internals.size(); qr++) {</span>
<a name="l01020"></a>01020           <span class="comment">//      std::cout &lt;&lt; getGraphNodeType(internals[qr]) &lt;&lt; std::endl;</span>
<a name="l01021"></a>01021           <span class="comment">//  }</span>
<a name="l01022"></a>01022            <span class="comment">// std::cout &lt;&lt; "internals done" &lt;&lt; std::endl;</span>
<a name="l01023"></a>01023           <span class="comment">//  std::cout &lt;&lt; "XXXXXXXXXXXXXX" &lt;&lt; std::endl;</span>
<a name="l01024"></a>01024            <span class="comment">// forFlag = true;</span>
<a name="l01025"></a>01025            <span class="comment">// yices_expr ev = evalFunction(internals, ctx, false);</span>
<a name="l01026"></a>01026             <span class="comment">//yices_assert(ctx,ev);</span>
<a name="l01027"></a>01027            <span class="comment">// forFlag = true;</span>
<a name="l01028"></a>01028             <span class="comment">//if (ev == NULL) {</span>
<a name="l01029"></a>01029                 <span class="keywordflow">while</span> (path[j]-&gt;get_SgNode() != path[i]-&gt;get_SgNode()) {
<a name="l01030"></a>01030                     update.push_back(path[j]);
<a name="l01031"></a>01031                     j++;
<a name="l01032"></a>01032                 }
<a name="l01033"></a>01033                <span class="comment">// yices_expr updatey = mainParse(update, ctx);</span>
<a name="l01034"></a>01034                <span class="comment">// j++;</span>
<a name="l01035"></a>01035                 
<a name="l01036"></a>01036                 ROSE_ASSERT(path[j]-&gt;get_SgNode() == path[i]-&gt;get_SgNode());
<a name="l01037"></a>01037                 j++;
<a name="l01038"></a>01038                 <span class="keywordflow">while</span>(path[j]-&gt;get_SgNode() != path[i]-&gt;get_SgNode()) {
<a name="l01039"></a>01039                 j++;
<a name="l01040"></a>01040                 }
<a name="l01041"></a>01041                 i = j+1;
<a name="l01042"></a>01042              <span class="comment">//   forFlag = true;</span>
<a name="l01043"></a>01043                
<a name="l01044"></a>01044                <span class="comment">// yices_expr exity2 = mainParse(exitStmt, ctx);</span>
<a name="l01045"></a>01045              <span class="comment">//   forFlag = true;</span>
<a name="l01046"></a>01046                 <span class="keywordtype">int</span> n = 0;
<a name="l01047"></a>01047                 <span class="comment">//yices_push(ctx);</span>
<a name="l01048"></a>01048                 <span class="keywordtype">bool</span> good = <span class="keyword">false</span>;
<a name="l01049"></a>01049                 <span class="keywordflow">while</span> (n &lt; <a class="code" href="yicesParserLib_8h.html#ec58e468363518c3dd79045de7ae1fa7">FORLOOPS</a>) {
<a name="l01050"></a>01050                     <span class="comment">//std::cout &lt;&lt; "n = " &lt;&lt; n &lt;&lt; std::endl;</span>
<a name="l01051"></a>01051                     yices_push(ctx);
<a name="l01052"></a>01052                     yices_expr exityi = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(exitStmt, ctx);
<a name="l01053"></a>01053                     yices_assert(ctx, exityi);
<a name="l01054"></a>01054                     <span class="keywordflow">if</span> (yices_inconsistent(ctx)) {
<a name="l01055"></a>01055                         yices_pop(ctx);
<a name="l01056"></a>01056                         <span class="keywordflow">if</span> (!yices_inconsistent(ctx)) {
<a name="l01057"></a>01057                         good = <span class="keyword">true</span>;
<a name="l01058"></a>01058                         <span class="keywordflow">break</span>;
<a name="l01059"></a>01059                         }
<a name="l01060"></a>01060                         <span class="keywordflow">else</span> {
<a name="l01061"></a>01061                         good = <span class="keyword">false</span>;
<a name="l01062"></a>01062                         <span class="keywordflow">break</span>;
<a name="l01063"></a>01063                         }
<a name="l01064"></a>01064                     }
<a name="l01065"></a>01065                     <span class="keywordflow">else</span> {
<a name="l01066"></a>01066                         yices_pop(ctx);
<a name="l01067"></a>01067                         yices_expr ev = <a class="code" href="yicesParserLib_8h.html#1ae824aad11e84a5193ed6f737f1402b">evalFunction</a>(internals, ctx, <span class="keyword">false</span>);
<a name="l01068"></a>01068                         yices_expr eupdate = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(update, ctx);
<a name="l01069"></a>01069                         yices_assert(ctx, eupdate);
<a name="l01070"></a>01070                         <span class="comment">//yices_expr ev = evalFunction(internals, ctx, false);</span>
<a name="l01071"></a>01071                         <span class="comment">//yices_assert(ctx,ev);</span>
<a name="l01072"></a>01072                         n++;
<a name="l01073"></a>01073                     }
<a name="l01074"></a>01074                     <span class="comment">//else {</span>
<a name="l01075"></a>01075                     <span class="comment">//    yices_pop(ctx);</span>
<a name="l01076"></a>01076                     <span class="comment">//    good = true;</span>
<a name="l01077"></a>01077                     <span class="comment">//    break;</span>
<a name="l01078"></a>01078                    <span class="comment">// }</span>
<a name="l01079"></a>01079                }
<a name="l01080"></a>01080                <span class="keywordflow">if</span> (good) {
<a name="l01081"></a>01081                     <span class="comment">//std::cout &lt;&lt; "for, good in: " &lt;&lt; n &lt;&lt; " loops" &lt;&lt; std::endl;</span>
<a name="l01082"></a>01082                     yices_expr ey = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(exitStmt, ctx);
<a name="l01083"></a>01083                     yices_expr eyn = yices_mk_not(ctx,ey);
<a name="l01084"></a>01084                     yices_assert(ctx,eyn);
<a name="l01085"></a>01085                }
<a name="l01086"></a>01086                <span class="keywordflow">else</span> {
<a name="l01087"></a>01087                     <span class="comment">//std::cout &lt;&lt; "bad loop" &lt;&lt; std::endl;</span>
<a name="l01088"></a>01088                     yices_expr yf = yices_mk_false(ctx);
<a name="l01089"></a>01089                     yices_assert(ctx,yf);
<a name="l01090"></a>01090                }
<a name="l01091"></a>01091                     <span class="comment">//yices_assert(ctx, exity2);</span>
<a name="l01092"></a>01092                <span class="comment">// }</span>
<a name="l01093"></a>01093             <span class="comment">//}</span>
<a name="l01094"></a>01094             <span class="comment">// {</span>
<a name="l01095"></a>01095                 <span class="comment">//ROSE_ASSERT(false);</span>
<a name="l01096"></a>01096             <span class="comment">//    forFlag = false;</span>
<a name="l01097"></a>01097             <span class="comment">//    return ev;</span>
<a name="l01098"></a>01098            <span class="comment">// }</span>
<a name="l01099"></a>01099             }
<a name="l01100"></a>01100             <span class="comment">//i++;</span>
<a name="l01101"></a>01101             <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#ecaf12b181743cd52ddc2b87d8083453">isSgForInitStatement</a>(path[i]-&gt;get_SgNode())) {
<a name="l01102"></a>01102                i--;
<a name="l01103"></a>01103             }
<a name="l01104"></a>01104            <span class="comment">// std::cout &lt;&lt; "i: " &lt;&lt; getGraphNodeType(path[i]) &lt;&lt; std::endl;</span>
<a name="l01105"></a>01105       <a class="code" href="yicesParserLib_8h.html#9427d97d66f016a61cc07e07c99c9a4e">forFlag</a> = <span class="keyword">false</span>;
<a name="l01106"></a>01106       } 
<a name="l01107"></a>01107             
<a name="l01108"></a>01108            <span class="comment">// yices_expr yexit = mainParse(exitStmt);</span>
<a name="l01109"></a>01109             <span class="comment">//yices_assert(yexit);</span>
<a name="l01110"></a>01110             
<a name="l01111"></a>01111             
<a name="l01112"></a>01112 
<a name="l01113"></a>01113 
<a name="l01114"></a>01114 
<a name="l01115"></a>01115 <span class="comment">/*</span>
<a name="l01116"></a>01116 <span class="comment">        else if (isSgForStatement(path[i]-&gt;get_SgNode()) &amp;&amp; isSgForInitStatement(path[i+1]-&gt;get_SgNode())) {</span>
<a name="l01117"></a>01117 <span class="comment">            forFlag = true;</span>
<a name="l01118"></a>01118 <span class="comment">            std::vector&lt;SgGraphNode*&gt; vec1;</span>
<a name="l01119"></a>01119 <span class="comment">            unsigned int j = i+2;</span>
<a name="l01120"></a>01120 <span class="comment">            int w = 2;</span>
<a name="l01121"></a>01121 <span class="comment">            while (!isSgInitializedName(path[j]-&gt;get_SgNode()) &amp;&amp; !isSgAssignOp(path[j]-&gt;get_SgNode())) {</span>
<a name="l01122"></a>01122 <span class="comment">                j++;</span>
<a name="l01123"></a>01123 <span class="comment">                w++;</span>
<a name="l01124"></a>01124 <span class="comment">            }</span>
<a name="l01125"></a>01125 <span class="comment">            vec1.push_back(path[j]);</span>
<a name="l01126"></a>01126 <span class="comment">            int k = j+1;</span>
<a name="l01127"></a>01127 <span class="comment">            while (k &lt; path.size() &amp;&amp; !isSgInitializedName(path[k]-&gt;get_SgNode())) {</span>
<a name="l01128"></a>01128 <span class="comment">                vec1.push_back(path[k]);</span>
<a name="l01129"></a>01129 <span class="comment">                k++;</span>
<a name="l01130"></a>01130 <span class="comment">            }</span>
<a name="l01131"></a>01131 <span class="comment">            vec1.push_back(path[k]);</span>
<a name="l01132"></a>01132 <span class="comment">            int q = 0;</span>
<a name="l01133"></a>01133 <span class="comment">            while (k &lt; path.size() &amp;&amp; !isSgForInitStatement(path[k]-&gt;get_SgNode())) {</span>
<a name="l01134"></a>01134 <span class="comment">                q++;</span>
<a name="l01135"></a>01135 <span class="comment">                k++;</span>
<a name="l01136"></a>01136 <span class="comment">            }</span>
<a name="l01137"></a>01137 <span class="comment">            yices_expr y1 = mainParse(vec1, ctx);</span>
<a name="l01138"></a>01138 <span class="comment">            yices_assert(ctx, y1);</span>
<a name="l01139"></a>01139 <span class="comment">            forFlag = false;</span>
<a name="l01140"></a>01140 <span class="comment">            i += vec1.size() + w + q;           </span>
<a name="l01141"></a>01141 <span class="comment">        }</span>
<a name="l01142"></a>01142 <span class="comment">*/</span> 
<a name="l01143"></a>01143         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#06a176ab1570bb1492dac4289a78a6cf">isSgIfStmt</a>(path[i]-&gt;get_SgNode()) &amp;&amp; <a class="code" href="yicesParserLib_8h.html#1567203b4990b38c06dc3fdd400ecdbb">opencfg</a>-&gt;<a class="code" href="classStaticCFG_1_1CFG.html#6758ebe66068f45146dd9c7554ad8524">toCFGNode</a>(path[i]).getIndex() == 0) {
<a name="l01144"></a>01144             <span class="comment">//std::cout &lt;&lt; "ifstmt" &lt;&lt; std::endl;</span>
<a name="l01145"></a>01145             <span class="comment">//for (int wq = i; wq &lt; path.size(); wq++) {</span>
<a name="l01146"></a>01146             <span class="comment">//std::cout &lt;&lt; getGraphNodeType(path[wq]) &lt;&lt; std::endl;</span>
<a name="l01147"></a>01147            <span class="comment">// }</span>
<a name="l01148"></a>01148            <span class="comment">// std::cout &lt;&lt; "endifstmt" &lt;&lt; std::endl;</span>
<a name="l01149"></a>01149           <span class="comment">//  std::cout &lt;&lt; "next node: " &lt;&lt; getGraphNodeType(path[i+1]) &lt;&lt; std::endl; </span>
<a name="l01150"></a>01150             <span class="keywordflow">while</span> (<a class="code" href="Cxx__Grammar_8h.html#4d34219f3b936907cada5220a0514ec3">isSgBasicBlock</a>(path[i+1]-&gt;get_SgNode())) {
<a name="l01151"></a>01151                 i++;
<a name="l01152"></a>01152             }
<a name="l01153"></a>01153             <span class="keywordflow">if</span> (!<a class="code" href="Cxx__Grammar_8h.html#d9c653991cea544c0ff54e0c59be2af0">isSgExprStatement</a>(path[i+1]-&gt;get_SgNode())) {
<a name="l01154"></a>01154                 i++;
<a name="l01155"></a>01155             }
<a name="l01156"></a>01156             <span class="keywordflow">else</span> {
<a name="l01157"></a>01157             ROSE_ASSERT(<a class="code" href="Cxx__Grammar_8h.html#d9c653991cea544c0ff54e0c59be2af0">isSgExprStatement</a>(path[i+1]-&gt;get_SgNode()));
<a name="l01158"></a>01158             <span class="keywordtype">int</span> k = i+2;
<a name="l01159"></a>01159             std::vector&lt;SgGraphNode*&gt; fpath;
<a name="l01160"></a>01160             <span class="keywordflow">while</span> (path[k]-&gt;get_SgNode() != path[i+1]-&gt;get_SgNode()) {
<a name="l01161"></a>01161                 <span class="keywordflow">if</span> (!<a class="code" href="Cxx__Grammar_8h.html#4d34219f3b936907cada5220a0514ec3">isSgBasicBlock</a>(path[k]-&gt;get_SgNode())) {
<a name="l01162"></a>01162                 fpath.push_back(path[k]);
<a name="l01163"></a>01163                 }
<a name="l01164"></a>01164                 k++;
<a name="l01165"></a>01165             }
<a name="l01166"></a>01166             <span class="comment">//fpath.push_back(path[k]);</span>
<a name="l01167"></a>01167             ROSE_ASSERT(<a class="code" href="Cxx__Grammar_8h.html#d9c653991cea544c0ff54e0c59be2af0">isSgExprStatement</a>(path[k]-&gt;get_SgNode()));;
<a name="l01168"></a>01168            <span class="comment">//std::cout &lt;&lt; "fpath: " &lt;&lt; std::endl;</span>
<a name="l01169"></a>01169            <span class="comment">// for (int xx = 0; xx &lt; fpath.size(); xx++) {</span>
<a name="l01170"></a>01170            <span class="comment">//     std::cout &lt;&lt; getGraphNodeType(fpath[xx]) &lt;&lt; std::endl;</span>
<a name="l01171"></a>01171             <span class="comment">//}</span>
<a name="l01172"></a>01172             <span class="comment">//std::cout &lt;&lt; "endfpath" &lt;&lt; std::endl;</span>
<a name="l01173"></a>01173             yices_expr y1 = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(fpath, ctx);
<a name="l01174"></a>01174             <span class="keywordtype">int</span> kk = k+1;
<a name="l01175"></a>01175             ROSE_ASSERT(<a class="code" href="Cxx__Grammar_8h.html#06a176ab1570bb1492dac4289a78a6cf">isSgIfStmt</a>(path[kk]-&gt;get_SgNode()));
<a name="l01176"></a>01176             std::set&lt;SgDirectedGraphEdge*&gt; ifoeds = <a class="code" href="yicesParserLib_8h.html#8b0b5b9c54a359f221198d7d558224a8">openg</a>-&gt;<a class="code" href="classSgIncidenceDirectedGraph.html#f313470c8b7ba952134a8420ef425726">computeEdgeSetOut</a>(path[kk]);
<a name="l01177"></a>01177             CFGNode cn = <a class="code" href="yicesParserLib_8h.html#1567203b4990b38c06dc3fdd400ecdbb">opencfg</a>-&gt;<a class="code" href="classStaticCFG_1_1CFG.html#6758ebe66068f45146dd9c7554ad8524">toCFGNode</a>(path[kk+1]);
<a name="l01178"></a>01178             std::vector&lt;CFGEdge&gt; ed = cn.inEdges();
<a name="l01179"></a>01179             
<a name="l01180"></a>01180             <span class="keywordtype">int</span> qw = 0;
<a name="l01181"></a>01181             <a class="code" href="namespaceVirtualBinCFG.html#1b52c24be4392322d2b388408373b20d">EdgeConditionKind</a> kn;
<a name="l01182"></a>01182             CFGEdge needEdge;
<a name="l01183"></a>01183             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> qt = 0; qt &lt; ed.size(); qt++) {
<a name="l01184"></a>01184                 <span class="keywordflow">if</span> (ed[qt].source() == <a class="code" href="yicesParserLib_8h.html#1567203b4990b38c06dc3fdd400ecdbb">opencfg</a>-&gt;<a class="code" href="classStaticCFG_1_1CFG.html#6758ebe66068f45146dd9c7554ad8524">toCFGNode</a>(path[kk])) {
<a name="l01185"></a>01185                     needEdge = ed[qt];
<a name="l01186"></a>01186                     kn = needEdge.condition();
<a name="l01187"></a>01187                 }
<a name="l01188"></a>01188             } 
<a name="l01189"></a>01189             <span class="keywordflow">while</span> (<a class="code" href="Cxx__Grammar_8h.html#4d34219f3b936907cada5220a0514ec3">isSgBasicBlock</a>(path[kk+1]-&gt;get_SgNode())) {
<a name="l01190"></a>01190                 kk++;
<a name="l01191"></a>01191            }
<a name="l01192"></a>01192             <span class="comment">//std::cout &lt;&lt; "currnode: " &lt;&lt; getGraphNodeType(path[kk+1]) &lt;&lt; std::endl;</span>
<a name="l01193"></a>01193            <span class="comment">// for (int q2 = 0; q2 &lt; path.size(); q2++) {</span>
<a name="l01194"></a>01194           <span class="comment">//  iqw = 0;</span>
<a name="l01195"></a>01195           <span class="comment">//  while (ed[qw].source() != opencfg-&gt;toCFGNode(path[q2])) {</span>
<a name="l01196"></a>01196           <span class="comment">//      qw++;</span>
<a name="l01197"></a>01197           <span class="comment">//      if (qw &gt;= ed.size()) {</span>
<a name="l01198"></a>01198           <span class="comment">//          break;</span>
<a name="l01199"></a>01199           <span class="comment">//      }</span>
<a name="l01200"></a>01200           <span class="comment">//  }</span>
<a name="l01201"></a>01201            <span class="comment">// qw = 0;</span>
<a name="l01202"></a>01202             <span class="comment">//}</span>
<a name="l01203"></a>01203             <span class="comment">//CFGEdge needEdge = ed[qw];</span>
<a name="l01204"></a>01204             <span class="keywordflow">if</span> (<a class="code" href="yicesParserLib_8h.html#ecc8aa7e3d5e014159a274d129d468f8">unknown_flag</a>) {
<a name="l01205"></a>01205                 <a class="code" href="yicesParserLib_8h.html#ecc8aa7e3d5e014159a274d129d468f8">unknown_flag</a> = <span class="keyword">false</span>;
<a name="l01206"></a>01206                 yices_expr uf;
<a name="l01207"></a>01207                 <span class="keywordflow">return</span> uf;
<a name="l01208"></a>01208             }
<a name="l01209"></a>01209             <span class="comment">//std::cout &lt;&lt; "condition" &lt;&lt; std::endl;</span>
<a name="l01210"></a>01210             <span class="comment">//std::cout &lt;&lt; getGraphNodeType(path[kk+1]) &lt;&lt; std::endl;</span>
<a name="l01211"></a>01211             <span class="comment">//std::cout &lt;&lt; "end condition" &lt;&lt; std::endl;</span>
<a name="l01212"></a>01212             <span class="comment">//EdgeConditionKind kn = needEdge.condition();</span>
<a name="l01213"></a>01213             <span class="keywordflow">if</span> (kn == <a class="code" href="namespaceVirtualBinCFG.html#1b52c24be4392322d2b388408373b20d919608fab30d5a7e4a9cd809f13e3e9c">eckTrue</a>) {
<a name="l01214"></a>01214                 yices_assert(ctx, y1);
<a name="l01215"></a>01215             }
<a name="l01216"></a>01216             <span class="keywordflow">else</span> {
<a name="l01217"></a>01217                 ROSE_ASSERT(kn == <a class="code" href="namespaceVirtualBinCFG.html#1b52c24be4392322d2b388408373b20d69f992b6607a6f9b9fc1dff77ebe6076">eckFalse</a>);
<a name="l01218"></a>01218                 yices_expr ynot = yices_mk_not(ctx,y1);
<a name="l01219"></a>01219                 yices_assert(ctx,ynot);
<a name="l01220"></a>01220             }
<a name="l01221"></a>01221             <span class="keywordtype">int</span> kk2 = kk+1;
<a name="l01222"></a>01222             <span class="comment">//while (isSgBasicBlock(path[kk2]-&gt;get_SgNode())) {</span>
<a name="l01223"></a>01223             <span class="comment">//    kk2++;</span>
<a name="l01224"></a>01224            <span class="comment">// }</span>
<a name="l01225"></a>01225             
<a name="l01226"></a>01226             <span class="comment">//int kk2 = kk+1;</span>
<a name="l01227"></a>01227             <span class="comment">//std::cout &lt;&lt; "kk: " &lt;&lt; getGraphNodeType(path[kk]) &lt;&lt; std::endl;</span>
<a name="l01228"></a>01228             <span class="comment">//std::cout &lt;&lt; "kk2: " &lt;&lt; getGraphNodeType(path[kk2]) &lt;&lt; std::endl;</span>
<a name="l01229"></a>01229             <span class="comment">//std::cout &lt;&lt; "path.back(): " &lt;&lt; getGraphNodeType(path.back()) &lt;&lt; std::endl;</span>
<a name="l01230"></a>01230             std::vector&lt;SgGraphNode*&gt; fpath2;
<a name="l01231"></a>01231             fpath2.push_back(path[kk2]);
<a name="l01232"></a>01232             kk2++;
<a name="l01233"></a>01233            <span class="keywordflow">while</span> (path[kk2]-&gt;get_SgNode() != path[kk+1]-&gt;get_SgNode() || <a class="code" href="yicesParserLib_8h.html#1567203b4990b38c06dc3fdd400ecdbb">opencfg</a>-&gt;<a class="code" href="classStaticCFG_1_1CFG.html#6758ebe66068f45146dd9c7554ad8524">toCFGNode</a>(path[kk2]).getIndex() != path[kk+1]-&gt;get_SgNode()-&gt;cfgIndexForEnd()) {<span class="comment">//&amp;&amp; yicesParser_LDFLAGS  =  -fopenmp -O3 -L/home/hoffman34/yices/yices-1.0.292/lib -lyices</span>
<a name="l01234"></a>01234            <span class="comment">// while (path[kk2]-&gt;get_SgNode() != path[kk]-&gt;get_SgNode() &amp;&amp; kk2 &lt; path.size()) {</span>
<a name="l01235"></a>01235            <span class="comment">//     if (!isSgBasicBlock(path[kk2]-&gt;get_SgNode())) {</span>
<a name="l01236"></a>01236                 fpath2.push_back(path[kk2]);
<a name="l01237"></a>01237            <span class="comment">//     }</span>
<a name="l01238"></a>01238                 kk2++;
<a name="l01239"></a>01239                 <span class="keywordflow">if</span> (kk2 == path.size()) {
<a name="l01240"></a>01240                     <span class="keywordflow">break</span>;
<a name="l01241"></a>01241                 }
<a name="l01242"></a>01242                 
<a name="l01243"></a>01243             }
<a name="l01244"></a>01244            <span class="comment">// std::cout &lt;&lt; "kk2: " &lt;&lt; getGraphNodeType(path[kk2]) &lt;&lt; std::endl;</span>
<a name="l01245"></a>01245             <span class="keywordflow">if</span> (kk2 &lt; path.size()) {
<a name="l01246"></a>01246             fpath2.push_back(path[kk2]);
<a name="l01247"></a>01247             }
<a name="l01248"></a>01248             <span class="keywordflow">if</span> (kk2 == path.size()) {
<a name="l01249"></a>01249                 <span class="comment">//std::cout &lt;&lt; "kk2 path: " &lt;&lt; std::endl;</span>
<a name="l01250"></a>01250                <span class="comment">// for (int u = kk+1; u &lt; kk2; u++) {</span>
<a name="l01251"></a>01251                <span class="comment">//     std::cout &lt;&lt; getGraphNodeType(path[u]) &lt;&lt; std::endl;</span>
<a name="l01252"></a>01252                <span class="comment">// }</span>
<a name="l01253"></a>01253                <span class="comment">// std::cout &lt;&lt; "kk2 end: " &lt;&lt; std::endl;        </span>
<a name="l01254"></a>01254                 i = kk2;
<a name="l01255"></a>01255                 yices_expr ewe = <a class="code" href="yicesParserLib_8h.html#1ae824aad11e84a5193ed6f737f1402b">evalFunction</a>(fpath2,ctx,<span class="keyword">false</span>);
<a name="l01256"></a>01256                 <span class="keywordflow">return</span> ewe;
<a name="l01257"></a>01257               <span class="comment">//  return;</span>
<a name="l01258"></a>01258             }
<a name="l01259"></a>01259             <span class="keywordflow">else</span> {
<a name="l01260"></a>01260             <span class="keywordtype">int</span> kk3 = kk2+1;
<a name="l01261"></a>01261             
<a name="l01262"></a>01262            <span class="comment">// while (path[kk3]-&gt;get_SgNode() != path[kk2]-&gt;get_SgNode()) {</span>
<a name="l01263"></a>01263            <span class="comment">//    kk3++;</span>
<a name="l01264"></a>01264            <span class="comment">// }</span>
<a name="l01265"></a>01265             <span class="keywordflow">if</span> (fpath2.size() != 0) {
<a name="l01266"></a>01266             <a class="code" href="yicesParserLib_8h.html#1ae824aad11e84a5193ed6f737f1402b">evalFunction</a>(fpath2,ctx,<span class="keyword">false</span>);
<a name="l01267"></a>01267             
<a name="l01268"></a>01268             <span class="comment">//std::cout &lt;&lt; "fpath2" &lt;&lt; std::endl;</span>
<a name="l01269"></a>01269            <span class="comment">// std::cout &lt;&lt; std::endl;</span>
<a name="l01270"></a>01270            <span class="comment">// for (int qp = 0; qp &lt; fpath2.size(); qp++) {</span>
<a name="l01271"></a>01271              <span class="comment">//   std::cout &lt;&lt; getGraphNodeType(fpath2[qp]) &lt;&lt; std::endl;</span>
<a name="l01272"></a>01272           <span class="comment">//  }</span>
<a name="l01273"></a>01273            <span class="comment">//std::cout &lt;&lt; "fpath2end" &lt;&lt; std::endl;</span>
<a name="l01274"></a>01274  <span class="comment">//           if (isSgExprStatement(fpath2[0]-&gt;get_SgNode())) {</span>
<a name="l01275"></a>01275    <span class="comment">//             std::vector&lt;SgGraphNode*&gt; fpathnew;</span>
<a name="l01276"></a>01276               <span class="comment">//  ROSE_ASSERT(isSgExprStatement(fpath2.back()-&gt;get_SgNode()));</span>
<a name="l01277"></a>01277      <span class="comment">//           for (int qq = 1; qq &lt; fpath2.size()-1; qq++) {</span>
<a name="l01278"></a>01278        <span class="comment">//             fpathnew.push_back(fpath2[qq]);</span>
<a name="l01279"></a>01279        <span class="comment">//         }</span>
<a name="l01280"></a>01280        <span class="comment">//         fpath2 = fpathnew;</span>
<a name="l01281"></a>01281        <span class="comment">//     }</span>
<a name="l01282"></a>01282             <span class="comment">//if (fpath2.size() != 0) {</span>
<a name="l01283"></a>01283        <span class="comment">//     SgGraphNode* pathj = fpath2.front();</span>
<a name="l01284"></a>01284        <span class="comment">//     if (isSgWhileStmt(pathj-&gt;get_SgNode()) || isSgIfStmt(pathj-&gt;get_SgNode()) || isSgForStatement(pathj-&gt;get_SgNode()) || isSgInitializedName(pathj-&gt;get_SgNode()) /*|| isSgReturnStmt(pathj-&gt;get_SgNode())*/) {</span>
<a name="l01285"></a>01285        <span class="comment">//     yices_expr y3 = evalFunction(fpath2, ctx, false);</span>
<a name="l01286"></a>01286        <span class="comment">//     }</span>
<a name="l01287"></a>01287        <span class="comment">//     else if (isSgReturnStmt(pathj-&gt;get_SgNode())) {</span>
<a name="l01288"></a>01288        <span class="comment">//     std::vector&lt;SgGraphNode*&gt; ffpath;</span>
<a name="l01289"></a>01289        <span class="comment">//     for (int ff = 1; ff &lt; fpath2.size()-1; ff++) {</span>
<a name="l01290"></a>01290        <span class="comment">//        ffpath.push_back(fpath2[ff]);</span>
<a name="l01291"></a>01291        <span class="comment">//     }</span>
<a name="l01292"></a>01292        <span class="comment">//     yices_expr y3 = mainParse(ffpath, ctx);</span>
<a name="l01293"></a>01293            <span class="comment">// yices_expr y3 = evalFunction(fpath2, ctx, false);</span>
<a name="l01294"></a>01294        <span class="comment">//    return y3;</span>
<a name="l01295"></a>01295          <span class="comment">//   }</span>
<a name="l01296"></a>01296          <span class="comment">//   else {</span>
<a name="l01297"></a>01297             <span class="comment">//std::cout &lt;&lt; "fpath2: " &lt;&lt; std::endl;</span>
<a name="l01298"></a>01298             <span class="comment">//for (int wq = 0; wq &lt; fpath2.size(); wq++) {</span>
<a name="l01299"></a>01299             <span class="comment">//    std::cout &lt;&lt; getGraphNodeType(fpath2[wq]) &lt;&lt; std::endl;</span>
<a name="l01301"></a>01301 <span class="comment"></span>          <span class="comment">//  std::cout &lt;&lt; "\n\n" &lt;&lt; std::endl;</span>
<a name="l01302"></a>01302            <span class="comment">// yices_expr y3 = mainParse(fpath2, ctx);</span>
<a name="l01303"></a>01303            <span class="comment">// yices_assert(ctx, y3);</span>
<a name="l01304"></a>01304             }
<a name="l01305"></a>01305             
<a name="l01306"></a>01306             <span class="comment">//else {</span>
<a name="l01307"></a>01307             <span class="comment">//    ROSE_ASSERT(false);</span>
<a name="l01308"></a>01308            <span class="comment">// }</span>
<a name="l01309"></a>01309             
<a name="l01310"></a>01310             i = kk3;
<a name="l01311"></a>01311             }
<a name="l01312"></a>01312        }
<a name="l01313"></a>01313        }
<a name="l01314"></a>01314         
<a name="l01315"></a>01315        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#d9c653991cea544c0ff54e0c59be2af0">isSgExprStatement</a>(path[i]-&gt;get_SgNode()) &amp;&amp; <a class="code" href="yicesParserLib_8h.html#1567203b4990b38c06dc3fdd400ecdbb">opencfg</a>-&gt;<a class="code" href="classStaticCFG_1_1CFG.html#6758ebe66068f45146dd9c7554ad8524">toCFGNode</a>(path[i]).getIndex() == 0  <span class="comment">/*&amp;&amp; knownNodes.find(path[i]-&gt;get_SgNode()) == knownNodes.end()*/</span>) {
<a name="l01316"></a>01316             <span class="keywordtype">int</span> j = i+1;
<a name="l01317"></a>01317        std::vector&lt;SgGraphNode*&gt; ses;
<a name="l01318"></a>01318       ses.push_back(path[i]);
<a name="l01319"></a>01319        <span class="keywordflow">while</span> (path[i]-&gt;get_SgNode() != path[j]-&gt;get_SgNode()) {
<a name="l01320"></a>01320        <span class="comment">//    std::cout &lt;&lt; "ses[j]: " &lt;&lt; getGraphNodeType(path[j]) &lt;&lt; std::endl;</span>
<a name="l01321"></a>01321            ses.push_back(path[j]);
<a name="l01322"></a>01322            j++;
<a name="l01323"></a>01323        }
<a name="l01324"></a>01324        <span class="comment">//std::cout &lt;&lt; "ses end" &lt;&lt; std::endl;</span>
<a name="l01325"></a>01325        ses.push_back(path[j]);
<a name="l01326"></a>01326        yices_expr mP = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(ses, ctx);
<a name="l01327"></a>01327        yices_assert(ctx, mP);
<a name="l01328"></a>01328        i = j+1;
<a name="l01329"></a>01329        <span class="comment">//     std::vector&lt;SgGraphNode*&gt; eStmt;</span>
<a name="l01330"></a>01330        <span class="comment">//     eStmt.push_back(path[i]);</span>
<a name="l01331"></a>01331        <span class="comment">//     while (path[j]-&gt;get_SgNode() != path[i]-&gt;get_SgNode()) {</span>
<a name="l01332"></a>01332        <span class="comment">//        eStmt.push_back(path[j]);</span>
<a name="l01333"></a>01333        <span class="comment">//        j++;</span>
<a name="l01334"></a>01334        <span class="comment">//     }</span>
<a name="l01335"></a>01335        <span class="comment">//     eStmt.push_back(path[j]);</span>
<a name="l01336"></a>01336        <span class="comment">//     yices_expr ee = mainParse(eStmt, ctx);</span>
<a name="l01337"></a>01337        <span class="comment">//     yices_assert(ctx,ee);</span>
<a name="l01338"></a>01338             <span class="comment">//yices_expr ymain = mainParse(eStmt, ctx);</span>
<a name="l01339"></a>01339             <span class="comment">//yices_assert(ctx, ymain);</span>
<a name="l01340"></a>01340        <span class="comment">//     i = j+1;</span>
<a name="l01341"></a>01341        }
<a name="l01342"></a>01342 <span class="comment">/*</span>
<a name="l01343"></a>01343 <span class="comment">            unsigned int j = i+1;</span>
<a name="l01344"></a>01344 <span class="comment">            while (path[j]-&gt;get_SgNode() != path[i]-&gt;get_SgNode()) {</span>
<a name="l01345"></a>01345 <span class="comment">                exprPath.push_back(path[j]);</span>
<a name="l01346"></a>01346 <span class="comment">                j++;</span>
<a name="l01347"></a>01347 <span class="comment">            }</span>
<a name="l01348"></a>01348 <span class="comment">            if (isSgIfStmt(path[j]-&gt;get_SgNode()) || isSgForStatement(path[j]-&gt;get_SgNode()) || isSgInitializedName(path[j]-&gt;get_SgNode()) || isSgReturnStmt(path[j]-&gt;get_SgNode())) {</span>
<a name="l01349"></a>01349 <span class="comment">                i = j;</span>
<a name="l01350"></a>01350 <span class="comment">            }</span>
<a name="l01351"></a>01351 <span class="comment">            else {</span>
<a name="l01352"></a>01352 <span class="comment">            //    std::cout &lt;&lt; "Exprpath: " &lt;&lt; std::endl;</span>
<a name="l01353"></a>01353 <span class="comment">            //    for (int qq = 0; qq &lt; exprPath.size(); qq++) {</span>
<a name="l01354"></a>01354 <span class="comment">              //      std::cout &lt;&lt; getGraphNodeType(exprPath[qq]) &lt;&lt; std::endl;</span>
<a name="l01355"></a>01355 <span class="comment">              //  }</span>
<a name="l01356"></a>01356 <span class="comment">                //std::cout &lt;&lt; std::endl;</span>
<a name="l01357"></a>01357 <span class="comment">              //  if (!unknown_flag) {</span>
<a name="l01358"></a>01358 <span class="comment">                yices_expr y1 = mainParse(exprPath, ctx);</span>
<a name="l01359"></a>01359 <span class="comment">                if (!unknown_flag) {</span>
<a name="l01360"></a>01360 <span class="comment">                yices_assert(ctx,y1);</span>
<a name="l01361"></a>01361 <span class="comment">                }</span>
<a name="l01362"></a>01362 <span class="comment">                else {</span>
<a name="l01363"></a>01363 <span class="comment">                unknown_flag = false;</span>
<a name="l01364"></a>01364 <span class="comment">                }</span>
<a name="l01365"></a>01365 <span class="comment">                i += exprPath.size()+2;</span>
<a name="l01366"></a>01366 <span class="comment">            }</span>
<a name="l01367"></a>01367 <span class="comment">       }</span>
<a name="l01368"></a>01368 <span class="comment">*/</span>
<a name="l01369"></a>01369         
<a name="l01370"></a>01370 <span class="comment">/*        </span>
<a name="l01371"></a>01371 <span class="comment">            ROSE_ASSERT(j &lt; path.size());</span>
<a name="l01372"></a>01372 <span class="comment">            yices_expr y2 =  mainParse(exprPath, ctx);</span>
<a name="l01373"></a>01373 <span class="comment">            ROSE_ASSERT(y2 != NULL);</span>
<a name="l01374"></a>01374 <span class="comment">            //std::cout &lt;&lt; "exprPath.size(): " &lt;&lt; exprPath.size() &lt;&lt; std::endl; </span>
<a name="l01375"></a>01375 <span class="comment">            std::set&lt;SgDirectedGraphEdge*&gt; oeds = openg-&gt;computeEdgeSetOut(path[j]);</span>
<a name="l01376"></a>01376 <span class="comment">            ROSE_ASSERT(oeds.size() == 1);</span>
<a name="l01377"></a>01377 <span class="comment">            SgGraphNode* onn = (*(oeds.begin()))-&gt;get_to();</span>
<a name="l01378"></a>01378 <span class="comment">               </span>
<a name="l01379"></a>01379 <span class="comment">            </span>
<a name="l01380"></a>01380 <span class="comment">            ROSE_ASSERT(onn == path[j+1]);</span>
<a name="l01381"></a>01381 <span class="comment">            std::set&lt;SgDirectedGraphEdge*&gt; ifoeds = openg-&gt;computeEdgeSetOut(path[j+1]); </span>
<a name="l01382"></a>01382 <span class="comment">            if ((isSgForStatement(onn-&gt;get_SgNode()) || (isSgIfStmt(onn-&gt;get_SgNode())) &amp;&amp; ifoeds.size() &gt;= 2)) { </span>
<a name="l01383"></a>01383 <span class="comment">                //std::cout &lt;&lt; "got a for or if" &lt;&lt; std::endl;</span>
<a name="l01384"></a>01384 <span class="comment"></span>
<a name="l01385"></a>01385 <span class="comment">                CFGNode cn = opencfg-&gt;toCFGNode(path[j+2]);</span>
<a name="l01386"></a>01386 <span class="comment">                std::vector&lt;CFGEdge&gt; ed = cn.inEdges();</span>
<a name="l01387"></a>01387 <span class="comment">                //ROSE_ASSERT(ed.size() == 1);</span>
<a name="l01388"></a>01388 <span class="comment">                int qw = 0;</span>
<a name="l01389"></a>01389 <span class="comment">                while (ed[qw].source() != opencfg-&gt;toCFGNode(path[j+1])) {</span>
<a name="l01390"></a>01390 <span class="comment">                    qw++;</span>
<a name="l01391"></a>01391 <span class="comment">                } </span>
<a name="l01392"></a>01392 <span class="comment">                CFGEdge needEdge =  ed[qw];</span>
<a name="l01393"></a>01393 <span class="comment">                EdgeConditionKind kn = needEdge.condition();</span>
<a name="l01394"></a>01394 <span class="comment">                ROSE_ASSERT(kn == eckTrue || kn == eckFalse);</span>
<a name="l01395"></a>01395 <span class="comment">                if (kn == eckFalse) {</span>
<a name="l01396"></a>01396 <span class="comment">                    yices_expr y2n = yices_mk_not(ctx, y2);</span>
<a name="l01397"></a>01397 <span class="comment"></span>
<a name="l01398"></a>01398 <span class="comment">                        yices_assert(ctx, y2n);</span>
<a name="l01399"></a>01399 <span class="comment">                }</span>
<a name="l01400"></a>01400 <span class="comment">                else {</span>
<a name="l01401"></a>01401 <span class="comment">                    ROSE_ASSERT(kn == eckTrue);</span>
<a name="l01402"></a>01402 <span class="comment">                    //std::cout &lt;&lt; "got a eckTrue" &lt;&lt; std::endl;</span>
<a name="l01403"></a>01403 <span class="comment">                    if (isSgForStatement(onn-&gt;get_SgNode())) {</span>
<a name="l01404"></a>01404 <span class="comment">                   //     int yr = yices_assert_retractable(ctx, y2);</span>
<a name="l01405"></a>01405 <span class="comment">                   //     forsts[onn-&gt;get_SgNode()] = yr;</span>
<a name="l01406"></a>01406 <span class="comment">                    }</span>
<a name="l01407"></a>01407 <span class="comment">                    else {</span>
<a name="l01408"></a>01408 <span class="comment">                        yices_assert(ctx, y2);</span>
<a name="l01409"></a>01409 <span class="comment">                    }</span>
<a name="l01410"></a>01410 <span class="comment">                }</span>
<a name="l01411"></a>01411 <span class="comment">            }</span>
<a name="l01412"></a>01412 <span class="comment">            else {      </span>
<a name="l01413"></a>01413 <span class="comment">                yices_assert(ctx, y2);</span>
<a name="l01414"></a>01414 <span class="comment">            }</span>
<a name="l01415"></a>01415 <span class="comment">            i += exprPath.size()+2;</span>
<a name="l01416"></a>01416 <span class="comment">            j = 0;</span>
<a name="l01417"></a>01417 <span class="comment"></span>
<a name="l01418"></a>01418 <span class="comment"> </span>
<a name="l01419"></a>01419 <span class="comment">      }</span>
<a name="l01420"></a>01420 <span class="comment">*/</span>
<a name="l01421"></a>01421         <span class="keywordflow">else</span> {
<a name="l01422"></a>01422             <span class="comment">//std::cout &lt;&lt; "elsed: " &lt;&lt; getGraphNodeType(path[i]) &lt;&lt;  std::endl;</span>
<a name="l01423"></a>01423             
<a name="l01424"></a>01424             i++;
<a name="l01425"></a>01425         }
<a name="l01426"></a>01426     
<a name="l01427"></a>01427     }
<a name="l01428"></a>01428     <span class="comment">//if (yices_inconsistent(ctx)) {</span>
<a name="l01429"></a>01429      <span class="comment">//   std::cout &lt;&lt; "inconsistent path: " &lt;&lt; ipaths &lt;&lt; std::endl;</span>
<a name="l01430"></a>01430      <span class="comment">//   ipaths++;</span>
<a name="l01431"></a>01431      <span class="comment">//   inconsistent = false;</span>
<a name="l01432"></a>01432         
<a name="l01433"></a>01433    <span class="comment">// }</span>
<a name="l01434"></a>01434     <span class="keywordflow">if</span> (mainFlag) {
<a name="l01435"></a>01435     <span class="comment">//yices_del_context(ctx);</span>
<a name="l01436"></a>01436     }
<a name="l01437"></a>01437 }
<a name="l01438"></a>01438 
<a name="l01439"></a><a class="code" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">01439</a> <a class="code" href="classStaticCFG_1_1CFG.html">StaticCFG::CFG</a>* <a class="code" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>;
<a name="l01440"></a>01440 
<a name="l01441"></a>01441 
<a name="l01442"></a><a class="code" href="yicesParserLib_8h.html#f3e2edc97812f1b2c2c8878033c72364">01442</a> std::vector&lt;int&gt; <a class="code" href="yicesParserLib_8h.html#f3e2edc97812f1b2c2c8878033c72364">breakTriple</a>(std::vector&lt;SgGraphNode*&gt; expr) {
<a name="l01443"></a>01443     <a class="code" href="classSgNode.html">SgNode</a>* index = expr[0]-&gt;get_SgNode();
<a name="l01444"></a>01444     std::vector&lt;int&gt; bounds(3, 0);
<a name="l01445"></a>01445     bounds[0] = 0;
<a name="l01446"></a>01446     <span class="keywordtype">int</span> i = 1;
<a name="l01447"></a>01447     <span class="keywordflow">while</span> (expr[i]-&gt;get_SgNode() != index) {
<a name="l01448"></a>01448         <span class="comment">//std::cout &lt;&lt; "expr[i]: " &lt;&lt; cfg-&gt;toCFGNode(expr[i]).toString() &lt;&lt; std::endl;</span>
<a name="l01449"></a>01449         ROSE_ASSERT(i &lt; expr.size());
<a name="l01450"></a>01450         i++;
<a name="l01451"></a>01451     }
<a name="l01452"></a>01452     bounds[1] = i;
<a name="l01453"></a>01453     bounds[2] = expr.size()-1;
<a name="l01454"></a>01454 
<a name="l01455"></a>01455     <span class="keywordflow">return</span> bounds;
<a name="l01456"></a>01456     }
<a name="l01457"></a>01457    
<a name="l01458"></a>01458 
<a name="l01459"></a>01459 
<a name="l01460"></a>01460 <span class="comment">//string mainParse(vector&lt;SgGraphNode*&gt; expr);</span>
<a name="l01461"></a>01461 string <a class="code" href="yicesParserLib_8h.html#0e2b091991daad5711a33ca835ae753c">isAtom</a>(<a class="code" href="classSgNode.html">SgNode</a>*);
<a name="l01462"></a>01462 <span class="keywordtype">bool</span> <a class="code" href="yicesParserLib_8h.html#57481b2c51b7924c3d3628c412ae7691">isLogicalSplit</a>(<a class="code" href="classSgNode.html">SgNode</a>*);
<a name="l01463"></a>01463 string <a class="code" href="yicesParserLib_8h.html#3782c828710c259d81600813639f1752">getLogicalSplit</a>(<a class="code" href="classSgNode.html">SgNode</a>*);
<a name="l01464"></a>01464 string <a class="code" href="yicesParserLib_8h.html#9919f7194d5f3918d5f0ed1620d80f98">getBinaryLogicOp</a>(<a class="code" href="classSgNode.html">SgNode</a>*);
<a name="l01465"></a>01465 <span class="keywordtype">bool</span> <a class="code" href="yicesParserLib_8h.html#829e1926858e10820b25e92ffc2757ac">isBinaryLogicOp</a>(<a class="code" href="classSgNode.html">SgNode</a>*);
<a name="l01466"></a>01466 <span class="keywordtype">bool</span> <a class="code" href="yicesParserLib_8h.html#f615c7424ab8ea00c1faefc1c0a1a6ec">isBinaryOp</a>(<a class="code" href="classSgNode.html">SgNode</a>*);
<a name="l01467"></a>01467 string <a class="code" href="yicesParserLib_8h.html#a870bfe46596003d476a434c5a198835">getBinaryOp</a>(<a class="code" href="classSgNode.html">SgNode</a>*);
<a name="l01468"></a>01468 
<a name="l01469"></a>01469 
<a name="l01470"></a><a class="code" href="yicesParserLib_8h.html#52e5645019935a12b4e31249490ed15d">01470</a> std::vector&lt;SgGraphNode*&gt; <a class="code" href="yicesParserLib_8h.html#52e5645019935a12b4e31249490ed15d">getSlice</a>(std::vector&lt;SgGraphNode*&gt; vv, <span class="keywordtype">int</span> i) {
<a name="l01471"></a>01471     <span class="keywordtype">int</span> cfgEnd = vv[i]-&gt;get_SgNode()-&gt;cfgIndexForEnd();
<a name="l01472"></a>01472     <span class="keywordtype">int</span> ind = 0;
<a name="l01473"></a>01473     std::vector&lt;SgGraphNode*&gt; slice;
<a name="l01474"></a>01474     <span class="keywordflow">if</span> (cfgEnd == 0) {
<a name="l01475"></a>01475         <span class="comment">//std::cout &lt;&lt; "nullend" &lt;&lt; std::endl;</span>
<a name="l01476"></a>01476         slice.push_back(vv[i]);
<a name="l01477"></a>01477         <span class="keywordflow">return</span> slice;
<a name="l01478"></a>01478     }
<a name="l01479"></a>01479     slice.push_back(vv[i]);
<a name="l01480"></a>01480     <span class="keywordtype">int</span> k = i+1;
<a name="l01481"></a>01481     <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l01482"></a>01482         ROSE_ASSERT(cfgEnd != ind);
<a name="l01483"></a>01483         <span class="comment">//ROSE_ASSERT(k &lt; vv.size());</span>
<a name="l01484"></a>01484         <span class="keywordflow">if</span> (vv[i]-&gt;get_SgNode() == vv[k]-&gt;get_SgNode()) {
<a name="l01485"></a>01485             ind++;
<a name="l01486"></a>01486             <span class="keywordflow">if</span> (ind == cfgEnd) {
<a name="l01487"></a>01487                 slice.push_back(vv[k]);
<a name="l01488"></a>01488                 <span class="keywordflow">return</span> slice;
<a name="l01489"></a>01489             }
<a name="l01490"></a>01490          }
<a name="l01491"></a>01491          slice.push_back(vv[k]);
<a name="l01492"></a>01492          k++;
<a name="l01493"></a>01493     }
<a name="l01494"></a>01494 }
<a name="l01495"></a>01495 
<a name="l01496"></a>01496 <span class="comment">//yices_expr evalFunction(vector&lt;SgGraphNode*&gt; funcLine, yices_context&amp; ctx) {</span>
<a name="l01497"></a>01497     
<a name="l01498"></a><a class="code" href="yicesParserLib_8h.html#154c30051e33d53ed0f6131c3f8460e5">01498</a> string <a class="code" href="yicesParserLib_8h.html#154c30051e33d53ed0f6131c3f8460e5">getGraphNodeType</a>(<a class="code" href="classSgGraphNode.html">SgGraphNode</a>* sn) {
<a name="l01499"></a>01499                    CFGNode cf = <a class="code" href="yicesParserLib_8h.html#1567203b4990b38c06dc3fdd400ecdbb">opencfg</a>-&gt;<a class="code" href="classStaticCFG_1_1CFG.html#6758ebe66068f45146dd9c7554ad8524">toCFGNode</a>(sn);
<a name="l01500"></a>01500                      string str = cf.toString();
<a name="l01501"></a>01501                      <span class="keywordflow">return</span> str;
<a name="l01502"></a>01502 }
<a name="l01503"></a>01503 
<a name="l01504"></a>01504 
<a name="l01505"></a>01505 
<a name="l01506"></a><a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">01506</a> yices_expr <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(vector&lt;SgGraphNode*&gt; expr, yices_context&amp; ctx) {
<a name="l01507"></a>01507     <span class="comment">//std::cout &lt;&lt; "rounds" &lt;&lt; rounds &lt;&lt; std::endl;</span>
<a name="l01508"></a>01508     string typ = <a class="code" href="yicesParserLib_8h.html#154c30051e33d53ed0f6131c3f8460e5">getGraphNodeType</a>(expr[0]);
<a name="l01509"></a>01509     <span class="comment">//std::cout &lt;&lt; "nodetype: " &lt;&lt; typ &lt;&lt; std::endl;</span>
<a name="l01510"></a>01510     <span class="comment">//std::cout &lt;&lt; "mainParse" &lt;&lt; std::endl;</span>
<a name="l01511"></a>01511      <a class="code" href="yicesParserLib_8h.html#b951ebd61b5fff7fb5c4212d7fc63254">rounds</a>++;
<a name="l01512"></a>01512     <span class="keywordtype">bool</span> yices = <span class="keyword">true</span>;
<a name="l01513"></a>01513     std::stringstream stst;
<a name="l01514"></a>01514     string parsed;
<a name="l01515"></a>01515     <span class="comment">//bool unknown_flag = false;</span>
<a name="l01516"></a>01516     std::vector&lt;SgGraphNode*&gt; vec1;
<a name="l01517"></a>01517     std::vector&lt;SgGraphNode*&gt; vec2;
<a name="l01518"></a>01518     stringstream ss;
<a name="l01519"></a>01519     yices_expr ret;
<a name="l01520"></a>01520     <span class="keywordflow">if</span> (expr.size() == 0) {
<a name="l01521"></a>01521         yices_expr empty = <span class="keyword">new</span> yices_expr;
<a name="l01522"></a>01522         <span class="keywordflow">return</span> empty;
<a name="l01523"></a>01523     }
<a name="l01524"></a>01524     <span class="comment">//if (unknown_flag) {</span>
<a name="l01525"></a>01525     <span class="comment">//    yices_expr empty;</span>
<a name="l01526"></a>01526     <span class="comment">//     return empty;</span>
<a name="l01527"></a>01527    <span class="comment">// }</span>
<a name="l01528"></a>01528     <span class="comment">//else </span>
<a name="l01529"></a>01529     <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#6b53e0a9cc36bc2fcb155a5b5c8bfdac">isSgReturnStmt</a>(expr[0]-&gt;get_SgNode())) {
<a name="l01530"></a>01530         ROSE_ASSERT(<a class="code" href="Cxx__Grammar_8h.html#6b53e0a9cc36bc2fcb155a5b5c8bfdac">isSgReturnStmt</a>(expr.back()));
<a name="l01531"></a>01531         std::vector&lt;SgGraphNode*&gt; toSolve;
<a name="l01532"></a>01532         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 1; j &lt; expr.size()-1; j++) {
<a name="l01533"></a>01533                     toSolve.push_back(expr[j]);
<a name="l01534"></a>01534         }
<a name="l01535"></a>01535         yices_expr ts = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(toSolve, ctx);
<a name="l01536"></a>01536         <span class="keywordflow">return</span> ts;
<a name="l01537"></a>01537     }
<a name="l01538"></a>01538     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#dfd4ff9ab7ae7515d1f66b6f565006df">isSgFunctionCallExp</a>(expr[0]-&gt;get_SgNode())) {
<a name="l01539"></a>01539         <span class="comment">//yices_type ty;</span>
<a name="l01540"></a>01540         yices_type fty;
<a name="l01541"></a>01541         yices_var_decl ftydecl;
<a name="l01542"></a>01542         yices_expr f;
<a name="l01543"></a>01543         <span class="keywordtype">bool</span> ufunc = <span class="keyword">false</span>;
<a name="l01544"></a>01544         <span class="keywordflow">if</span> (<a class="code" href="yicesParserLib_8h.html#2253cf621c18f487291341f164ffdc57">unknownFunctions</a>.find(expr[0]-&gt;get_SgNode()) != <a class="code" href="yicesParserLib_8h.html#2253cf621c18f487291341f164ffdc57">unknownFunctions</a>.end()) {
<a name="l01545"></a>01545            <span class="comment">//yices_expr unknown;;</span>
<a name="l01546"></a>01546            <span class="comment">//return unknown;</span>
<a name="l01547"></a>01547         
<a name="l01548"></a>01548         <a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>* afd = (<a class="code" href="Cxx__Grammar_8h.html#dfd4ff9ab7ae7515d1f66b6f565006df">isSgFunctionCallExp</a>(expr[0]-&gt;get_SgNode()))-&gt;getAssociatedFunctionDeclaration();
<a name="l01549"></a>01549         <a class="code" href="classSgType.html">SgType</a>* ty = afd-&gt;get_orig_return_type();
<a name="l01550"></a>01550         string ty_str = <a class="code" href="yicesParserLib_8h.html#2a78ff2b912bbb36235508d39c77c9b6">getType</a>(ty);
<a name="l01551"></a>01551         <span class="keyword">const</span> <span class="keywordtype">char</span>* ty_const_char = ty_str.c_str();
<a name="l01552"></a>01552         yices_type rty = yices_mk_type(ctx,(<span class="keywordtype">char</span>*)ty_const_char);
<a name="l01553"></a>01553         <a class="code" href="Cxx__Grammar_8h.html#f5484e8d253ed1622192c3c08221ff2e">SgInitializedNamePtrList</a> sipl = afd-&gt;get_args();
<a name="l01554"></a>01554         yices_type dom[sipl.size()];
<a name="l01555"></a>01555         <span class="keywordtype">int</span> iic = 0;;
<a name="l01556"></a>01556         <span class="keywordflow">for</span> (SgInitializedNamePtrList::iterator ii = sipl.begin(); ii != sipl.end(); ii++) {
<a name="l01557"></a>01557             string domY = <a class="code" href="yicesParserLib_8h.html#2a78ff2b912bbb36235508d39c77c9b6">getType</a>((*ii)-&gt;get_type());
<a name="l01558"></a>01558             yices_type typdom = yices_mk_type(ctx,(<span class="keywordtype">char</span>*)domY.c_str());
<a name="l01559"></a>01559             dom[iic] = typdom;
<a name="l01560"></a>01560 
<a name="l01561"></a>01561             iic++;
<a name="l01562"></a>01562         }
<a name="l01563"></a>01563         <span class="keywordtype">int</span> ds = iic;
<a name="l01564"></a>01564         stringstream nam;
<a name="l01565"></a>01565         <a class="code" href="yicesParserLib_8h.html#e8f6d2fd6490d3153cb4133bf183a404">nvars</a>++;
<a name="l01566"></a>01566         nam &lt;&lt; afd-&gt;get_qualified_name().getString();
<a name="l01567"></a>01567         nam &lt;&lt; <a class="code" href="yicesParserLib_8h.html#e8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l01568"></a>01568         fty = yices_mk_function_type(ctx, dom, ds, rty);;
<a name="l01569"></a>01569         ftydecl = yices_mk_var_decl(ctx, (<span class="keywordtype">char</span>*) nam.str().c_str(),fty);
<a name="l01570"></a>01570         f = yices_mk_var_from_decl(ctx, ftydecl);
<a name="l01571"></a>01571 
<a name="l01572"></a>01572  <span class="comment">//yices_type fty = yices_mk_function_type(ctx, domain, 1, ty);</span>
<a name="l01573"></a>01573  <span class="comment">// yices_var_decl fdecl = yices_mk_var_decl(ctx, "f", fty);</span>
<a name="l01574"></a>01574 
<a name="l01575"></a>01575            ufunc = <span class="keyword">true</span>;
<a name="l01576"></a>01576         }
<a name="l01577"></a>01577        <span class="keywordtype">int</span> i = 1;
<a name="l01578"></a>01578        <span class="keywordflow">while</span> (!<a class="code" href="Cxx__Grammar_8h.html#e4578fcdd7e2d5f903384187575f2f23">isSgExprListExp</a>(expr[i]-&gt;get_SgNode())) {
<a name="l01579"></a>01579            i++;
<a name="l01580"></a>01580            <span class="keywordflow">if</span> (i &gt; expr.size()) {
<a name="l01581"></a>01581                ROSE_ASSERT(<span class="keyword">false</span>);
<a name="l01582"></a>01582                yices_expr empty = <span class="keyword">new</span> yices_expr;
<a name="l01583"></a>01583                <span class="keywordflow">return</span> empty;
<a name="l01584"></a>01584            }
<a name="l01585"></a>01585        }
<a name="l01586"></a>01586        <span class="keywordtype">int</span> j = i+1;
<a name="l01587"></a>01587        <span class="keywordtype">int</span> checks = 0;
<a name="l01588"></a>01588        std::vector&lt;yices_expr&gt; argsyices;
<a name="l01589"></a>01589        std::vector&lt;SgGraphNode*&gt; yexp;
<a name="l01590"></a>01590        <span class="keywordflow">while</span> (checks != expr[i]-&gt;get_SgNode()-&gt;cfgIndexForEnd()) {
<a name="l01591"></a>01591        <span class="comment">//std::vector&lt;SgGraphNode*&gt; yexp;</span>
<a name="l01592"></a>01592        <span class="keywordflow">while</span> (expr[j]-&gt;get_SgNode() != expr[i]-&gt;get_SgNode()) {
<a name="l01593"></a>01593            yexp.push_back(expr[j]);
<a name="l01594"></a>01594            j++;
<a name="l01595"></a>01595            <span class="keywordflow">if</span> (j &gt;= expr.size()) {
<a name="l01596"></a>01596                ROSE_ASSERT(<span class="keyword">false</span>);
<a name="l01597"></a>01597                yices_expr empty = <span class="keyword">new</span> yices_expr;
<a name="l01598"></a>01598                <span class="keywordflow">return</span> empty;
<a name="l01599"></a>01599            }
<a name="l01600"></a>01600       }
<a name="l01601"></a>01601       j++;
<a name="l01602"></a>01602       <span class="comment">//yices_expr argsaryices[argsyices.size()];</span>
<a name="l01603"></a>01603       <span class="comment">//std::cout &lt;&lt; "yexp: " &lt;&lt; std::endl;</span>
<a name="l01604"></a>01604       <span class="comment">//for (int qy = 0; qy &lt; yexp.size(); qy++) {</span>
<a name="l01605"></a>01605       <span class="comment">//    std::cout &lt;&lt; getGraphNodeType(yexp[qy]) &lt;&lt; std::endl;</span>
<a name="l01606"></a>01606      <span class="comment">// }</span>
<a name="l01607"></a>01607       <span class="comment">//ROSE_ASSERT(false);</span>
<a name="l01608"></a>01608      <span class="comment">// std::cout &lt;&lt; std::endl;</span>
<a name="l01609"></a>01609       yices_expr yex = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(yexp,ctx);
<a name="l01610"></a>01610       <span class="comment">//yices_assert(ctx, yex);</span>
<a name="l01611"></a>01611       ROSE_ASSERT(yex != NULL);
<a name="l01612"></a>01612       argsyices.push_back(yex);
<a name="l01613"></a>01613       checks++;
<a name="l01614"></a>01614       }
<a name="l01615"></a>01615       <span class="keywordflow">if</span> (ufunc) {
<a name="l01616"></a>01616           <span class="comment">//yices_expr argsaryyices[argsyices.size()];</span>
<a name="l01617"></a>01617        <span class="comment">//   std::cout &lt;&lt; "ufunc" &lt;&lt; std::endl;</span>
<a name="l01618"></a>01618           yices_expr argsaryices[argsyices.size()];
<a name="l01619"></a>01619           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> tt = 0; tt &lt; argsyices.size(); tt++) {
<a name="l01620"></a>01620           argsaryices[tt] = argsyices[tt];
<a name="l01621"></a>01621           }
<a name="l01622"></a>01622        
<a name="l01623"></a>01623           yices_expr app = yices_mk_app(ctx,f,argsaryices,argsyices.size());
<a name="l01624"></a>01624           <span class="keywordflow">return</span> app;
<a name="l01625"></a>01625       }
<a name="l01626"></a>01626       <a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>* sgfd = <a class="code" href="Cxx__Grammar_8h.html#dfd4ff9ab7ae7515d1f66b6f565006df">isSgFunctionCallExp</a>(expr[0]-&gt;get_SgNode())-&gt;<a class="code" href="classSgFunctionCallExp.html#ecfaba690023f19b13e18887102f033a">getAssociatedFunctionDeclaration</a>();
<a name="l01627"></a>01627       <a class="code" href="classSgFunctionParameterList.html">SgFunctionParameterList</a>* sfpl = sgfd-&gt;<a class="code" href="classSgFunctionDeclaration.html#3a1bad1e10a54667863c700ee24045a7">get_parameterList</a>();
<a name="l01628"></a>01628       <a class="code" href="Cxx__Grammar_8h.html#f5484e8d253ed1622192c3c08221ff2e">SgInitializedNamePtrList</a> sinp = sfpl-&gt;<a class="code" href="classSgFunctionParameterList.html#c928788a5c774f679de76611829a8d0a">get_args</a>();
<a name="l01629"></a>01629       SgInitializedNamePtrList::iterator ite = sinp.begin();
<a name="l01630"></a>01630       <span class="keywordtype">int</span> argnum = 0;
<a name="l01631"></a>01631       <span class="keywordflow">for</span> (ite = sinp.begin(); ite != sinp.end(); ite++) {
<a name="l01632"></a>01632           <a class="code" href="classSgName.html">SgName</a> svs = (<a class="code" href="Cxx__Grammar_8h.html#3d55e45b923661b7efeeb664266d2527">isSgInitializedName</a>((*ite)))-&gt;get_qualified_name();
<a name="l01633"></a>01633           stringstream funN;
<a name="l01634"></a>01634           <a class="code" href="yicesParserLib_8h.html#e8f6d2fd6490d3153cb4133bf183a404">nvars</a>++;
<a name="l01635"></a>01635           funN &lt;&lt; svs.getString() &lt;&lt; <a class="code" href="yicesParserLib_8h.html#e8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l01636"></a>01636           <span class="comment">//funN &lt;&lt; "V" &lt;&lt; nvars;</span>
<a name="l01637"></a>01637           <a class="code" href="yicesParserLib_8h.html#d9c55e63216a3f4b4d8f344149a3646b">nameOf</a>[svs] = funN.str();<span class="comment">//funN.str();</span>
<a name="l01638"></a>01638           string valType = <a class="code" href="yicesParserLib_8h.html#2a78ff2b912bbb36235508d39c77c9b6">getType</a>(<a class="code" href="Cxx__Grammar_8h.html#3d55e45b923661b7efeeb664266d2527">isSgInitializedName</a>(*ite)-&gt;<a class="code" href="classSgInitializedName.html#f4c8f922e442071cf6de3532ca8bc486">get_type</a>());
<a name="l01639"></a>01639             yices_type ty1 = yices_mk_type(ctx, (<span class="keywordtype">char</span>*) valType.c_str());
<a name="l01640"></a>01640             yices_var_decl decl1 = yices_mk_var_decl(ctx, (<span class="keywordtype">char</span>*) funN.str().c_str(), ty1);
<a name="l01641"></a>01641             yices_expr e1 = yices_mk_var_from_decl(ctx, decl1);
<a name="l01642"></a>01642             <span class="comment">//yices_expr e2 = mainParse(vec2, ctx);</span>
<a name="l01643"></a>01643 
<a name="l01644"></a>01644           <span class="comment">//if (isSgVarRefExp(yexp[0]-&gt;get_SgNode())) {</span>
<a name="l01645"></a>01645           <span class="comment">//getExpr[svs] = getExpr[isSgVarRefExp(yexp[0]-&gt;get_SgNode())-&gt;get_symbol()-&gt;get_name()];//argsyices[argnum];</span>
<a name="l01646"></a>01646          <span class="comment">// }</span>
<a name="l01647"></a>01647          <span class="comment">// else {</span>
<a name="l01648"></a>01648           ROSE_ASSERT(argsyices[argnum] != NULL); 
<a name="l01649"></a>01649           <a class="code" href="yicesParserLib_8h.html#3703af20b0be2697db1fcd0452dd9c6e">getExpr</a>[svs] = argsyices[argnum];
<a name="l01650"></a>01650           
<a name="l01651"></a>01651           yices_expr exp = yices_mk_eq(ctx,e1,argsyices[argnum]);
<a name="l01652"></a>01652           yices_assert(ctx,exp);
<a name="l01653"></a>01653          
<a name="l01654"></a>01654         <span class="comment">//      ROSE_ASSERT(false);</span>
<a name="l01655"></a>01655           <span class="comment">//}</span>
<a name="l01656"></a>01656           argnum++;
<a name="l01657"></a>01657        }
<a name="l01658"></a>01658        <span class="comment">//std::cout &lt;&lt; "argnum: " &lt;&lt; argnum &lt;&lt; std::endl;</span>
<a name="l01659"></a>01659        <span class="comment">//std::cout &lt;&lt; std::endl;</span>
<a name="l01660"></a>01660        <span class="comment">//for (int ww = 0; ww &lt; expr.size(); ww++) {</span>
<a name="l01661"></a>01661        <span class="comment">//    std::cout &lt;&lt; getGraphNodeType(expr[ww]) &lt;&lt; std::endl;</span>
<a name="l01662"></a>01662       <span class="comment">// }</span>
<a name="l01663"></a>01663       <span class="comment">// std::cout &lt;&lt; std::endl;</span>
<a name="l01664"></a>01664        ROSE_ASSERT(<a class="code" href="Cxx__Grammar_8h.html#dfd4ff9ab7ae7515d1f66b6f565006df">isSgFunctionCallExp</a>(expr[j]-&gt;get_SgNode()));
<a name="l01665"></a>01665       <span class="comment">// std::cout &lt;&lt; "graphnodeafterexp: " &lt;&lt; getGraphNodeType(expr[j+1]) &lt;&lt; std::endl;</span>
<a name="l01666"></a>01666        <span class="comment">//ROSE_ASSERT(isSgFunctionCallExp(expr[j+1]-&gt;get_SgNode()));</span>
<a name="l01667"></a>01667        <span class="keywordtype">int</span> k = j;
<a name="l01668"></a>01668        <span class="comment">//j+=2;</span>
<a name="l01669"></a>01669        <span class="comment">//int k = j-2;</span>
<a name="l01670"></a>01670        std::vector&lt;SgGraphNode*&gt; funcLine;
<a name="l01671"></a>01671        <span class="keywordtype">int</span> check2 = 2;
<a name="l01672"></a>01672       <span class="comment">// std::cout &lt;&lt; "k-1: " &lt;&lt; getGraphNodeType(expr[k]) &lt;&lt; std::endl;</span>
<a name="l01673"></a>01673        j++;
<a name="l01674"></a>01674        <span class="comment">//std::cout &lt;&lt; "funcLinePath: " &lt;&lt; std::endl;</span>
<a name="l01675"></a>01675        <span class="comment">//for (int qt = 0; qt &lt; expr.size(); qt++) {</span>
<a name="l01676"></a>01676        <span class="comment">//    std::cout &lt;&lt; getGraphNodeType(expr[qt]) &lt;&lt; std::endl;</span>
<a name="l01677"></a>01677       <span class="comment">// }</span>
<a name="l01678"></a>01678        <span class="comment">//std::cout &lt;&lt; "endpath" &lt;&lt; std::endl;</span>
<a name="l01679"></a>01679        <span class="comment">//std::cout &lt;&lt; std::endl;</span>
<a name="l01680"></a>01680        <span class="keywordflow">while</span> (check2 &lt; expr[k]-&gt;get_SgNode()-&gt;cfgIndexForEnd()) {
<a name="l01681"></a>01681        <span class="keywordflow">if</span> (expr[k]-&gt;get_SgNode() == expr[j]-&gt;get_SgNode()) {
<a name="l01682"></a>01682            check2++;
<a name="l01683"></a>01683            <span class="comment">//if (check2 &gt;= expr[k]-&gt;get_SgNode()-&gt;cfgIndexForEnd()) {</span>
<a name="l01684"></a>01684          <span class="comment">//      break;</span>
<a name="l01685"></a>01685            <span class="comment">//}</span>
<a name="l01686"></a>01686            <span class="comment">//check2++;</span>
<a name="l01687"></a>01687         <span class="comment">//   funcLine.push_back(expr[j]);</span>
<a name="l01688"></a>01688          <span class="comment">//  j++;</span>
<a name="l01689"></a>01689        }
<a name="l01690"></a>01690        <span class="comment">//check2++;</span>
<a name="l01691"></a>01691        funcLine.push_back(expr[j]);
<a name="l01692"></a>01692        j++;
<a name="l01693"></a>01693        }
<a name="l01694"></a>01694       <span class="comment">// std::cout &lt;&lt; "funcLine.size(): " &lt;&lt; funcLine.size() &lt;&lt; std::endl;</span>
<a name="l01695"></a>01695        <span class="comment">//std::cout &lt;&lt; "formed funcLine" &lt;&lt; std::endl;</span>
<a name="l01696"></a>01696        std::vector&lt;SgGraphNode*&gt; funcLine2;
<a name="l01697"></a>01697        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> kk = 1; kk &lt; funcLine.size()-1; kk++) {
<a name="l01698"></a>01698            funcLine2.push_back(funcLine[kk]);
<a name="l01699"></a>01699        }
<a name="l01700"></a>01700        <span class="comment">//std::cout &lt;&lt; std::endl;</span>
<a name="l01701"></a>01701       <span class="comment">// std::cout &lt;&lt; "funcLine1 size: " &lt;&lt; funcLine.size() &lt;&lt; std::endl;</span>
<a name="l01702"></a>01702       <span class="comment">// for (int ww2 = 0; ww2 &lt; funcLine.size(); ww2++) {</span>
<a name="l01703"></a>01703       <span class="comment">//     std::cout &lt;&lt; getGraphNodeType(funcLine[ww2]) &lt;&lt; std::endl;</span>
<a name="l01704"></a>01704       <span class="comment">// }</span>
<a name="l01705"></a>01705       <span class="comment">// std::cout &lt;&lt; std::endl;</span>
<a name="l01706"></a>01706        ROSE_ASSERT(!<a class="code" href="yicesParserLib_8h.html#ecc8aa7e3d5e014159a274d129d468f8">unknown_flag</a>);
<a name="l01707"></a>01707         
<a name="l01708"></a>01708        yices_expr funcexp = <a class="code" href="yicesParserLib_8h.html#1ae824aad11e84a5193ed6f737f1402b">evalFunction</a>(funcLine2, ctx, <span class="keyword">false</span>); 
<a name="l01709"></a>01709        ROSE_ASSERT(funcexp != NULL);
<a name="l01710"></a>01710        <span class="keywordflow">return</span> funcexp;   
<a name="l01711"></a>01711 
<a name="l01712"></a>01712 
<a name="l01713"></a>01713  
<a name="l01714"></a>01714     }
<a name="l01715"></a>01715     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#bcd565659a602a4d3f12b563250e7107">isSgNotOp</a>(expr[0]-&gt;get_SgNode())) {
<a name="l01716"></a>01716         ret = yices_mk_fresh_bool_var(ctx);
<a name="l01717"></a>01717         <span class="keywordtype">int</span> i = 1;
<a name="l01718"></a>01718         <a class="code" href="classSgGraphNode.html">SgGraphNode</a>* curr = expr[1];
<a name="l01719"></a>01719         <span class="keywordflow">while</span> (curr-&gt;<a class="code" href="classSgGraphNode.html#f46f3de48322cbe97296e7aef49a5566">get_SgNode</a>() != expr[0]-&gt;get_SgNode()) {
<a name="l01720"></a>01720             vec1.push_back(curr);
<a name="l01721"></a>01721             i++;
<a name="l01722"></a>01722             curr = expr[i];
<a name="l01723"></a>01723         }
<a name="l01724"></a>01724         yices_expr e1 = yices_mk_fresh_bool_var(ctx);
<a name="l01725"></a>01725         e1 = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(vec1, ctx);
<a name="l01726"></a>01726         ret = yices_mk_not(ctx, e1);
<a name="l01727"></a>01727         <span class="keywordflow">return</span> ret;
<a name="l01728"></a>01728     }     
<a name="l01729"></a>01729     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="yicesParserLib_8h.html#57481b2c51b7924c3d3628c412ae7691">isLogicalSplit</a>(expr[0]-&gt;get_SgNode())) {
<a name="l01730"></a>01730         ret = yices_mk_fresh_bool_var(ctx);
<a name="l01731"></a>01731         string ls = <a class="code" href="yicesParserLib_8h.html#3782c828710c259d81600813639f1752">getLogicalSplit</a>(expr[0]-&gt;get_SgNode());
<a name="l01732"></a>01732        <span class="comment">// std::vector&lt;int&gt; bounds = breakTriple(expr);</span>
<a name="l01733"></a>01733         std::map&lt;int, std::vector&lt;SgGraphNode*&gt; &gt; vec;
<a name="l01734"></a>01734         std::vector&lt;SgGraphNode*&gt; vecX;
<a name="l01735"></a>01735         <span class="keywordtype">int</span> qt = 1;
<a name="l01736"></a>01736         <span class="keywordtype">int</span> curr = 0;
<a name="l01737"></a>01737         <span class="comment">//std::cout &lt;&lt; "expr logical split: " &lt;&lt; std::endl;</span>
<a name="l01738"></a>01738         <span class="comment">//for (int qy = 0; qy &lt; expr.size(); qy++) {</span>
<a name="l01739"></a>01739          <span class="comment">//   std::cout &lt;&lt; getGraphNodeType(expr[qy]) &lt;&lt; std::endl;</span>
<a name="l01740"></a>01740        <span class="comment">// }</span>
<a name="l01741"></a>01741        <span class="comment">// std::cout &lt;&lt; std::endl;</span>
<a name="l01742"></a>01742         <span class="keywordflow">while</span> (curr &lt; 2) {
<a name="l01743"></a>01743             <span class="keywordflow">if</span> (expr[qt]-&gt;get_SgNode() == expr[0]-&gt;get_SgNode()) {
<a name="l01744"></a>01744                 vec[curr] = vecX;
<a name="l01745"></a>01745                 vecX.clear();
<a name="l01746"></a>01746                 curr++;
<a name="l01747"></a>01747             }
<a name="l01748"></a>01748             <span class="keywordflow">else</span> {
<a name="l01749"></a>01749             vecX.push_back(expr[qt]);
<a name="l01750"></a>01750             }
<a name="l01751"></a>01751             qt++;
<a name="l01752"></a>01752         }
<a name="l01753"></a>01753         vec1 = vec[0];
<a name="l01754"></a>01754         vec2 = vec[1];
<a name="l01755"></a>01755 <span class="comment">/*</span>
<a name="l01756"></a>01756 <span class="comment">        for (int i = bounds[0]+1; i &lt; bounds[1]; i++) {</span>
<a name="l01757"></a>01757 <span class="comment">            vec1.push_back(expr[i]);</span>
<a name="l01758"></a>01758 <span class="comment">        }</span>
<a name="l01759"></a>01759 <span class="comment">        for (int j = bounds[1]+1; j &lt; bounds[2]; j++) {</span>
<a name="l01760"></a>01760 <span class="comment">            vec2.push_back(expr[j]);</span>
<a name="l01761"></a>01761 <span class="comment">        }</span>
<a name="l01762"></a>01762 <span class="comment">*/</span>
<a name="l01763"></a>01763         <span class="comment">//if (yices) {</span>
<a name="l01764"></a>01764                 yices_expr e1 = yices_mk_fresh_bool_var(ctx);
<a name="l01765"></a>01765                 yices_expr e2 = yices_mk_fresh_bool_var(ctx);
<a name="l01766"></a>01766             <span class="comment">//    std::cout &lt;&lt; "vec1: " &lt;&lt; std::endl;</span>
<a name="l01767"></a>01767                 <span class="comment">//for (int qw = 0; qw &lt; vec1.size(); qw++) {</span>
<a name="l01768"></a>01768                 <span class="comment">//    std::cout &lt;&lt; getGraphNodeType(vec1[qw]) &lt;&lt; std::endl;</span>
<a name="l01769"></a>01769                <span class="comment">// }</span>
<a name="l01770"></a>01770               <span class="comment">//  std::cout &lt;&lt; "vec2: " &lt;&lt; std::endl;</span>
<a name="l01771"></a>01771                <span class="comment">// for (int qw2 = 0; qw2 &lt; vec2.size(); qw2++) {</span>
<a name="l01772"></a>01772                 <span class="comment">//    std::cout &lt;&lt; getGraphNodeType(vec2[qw2]) &lt;&lt; std::endl;</span>
<a name="l01773"></a>01773                <span class="comment">// }</span>
<a name="l01774"></a>01774               <span class="comment">//  std::cout &lt;&lt; "\n\n";</span>
<a name="l01775"></a>01775                 e1 = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(vec1, ctx);
<a name="l01776"></a>01776                 <span class="keywordflow">if</span> (vec2.size() != 0) {
<a name="l01777"></a>01777                 e2 = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(vec2, ctx);
<a name="l01778"></a>01778                 } 
<a name="l01779"></a>01779                 <span class="comment">//std::cout &lt;&lt; "vec1.size()" &lt;&lt; vec1.size() &lt;&lt; " vec2.size(): " &lt;&lt; vec2.size() &lt;&lt; std::endl;</span>
<a name="l01780"></a>01780                 
<a name="l01781"></a>01781                 <span class="keywordflow">if</span> (vec1.size() == 0 &amp;&amp; ls == <span class="stringliteral">"and"</span>) { 
<a name="l01782"></a>01782                     e1 = yices_mk_false(ctx);
<a name="l01783"></a>01783                 }
<a name="l01784"></a>01784                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vec1.size() == 0 &amp;&amp; ls == <span class="stringliteral">"or"</span>) {
<a name="l01785"></a>01785                     e1 = yices_mk_true(ctx);
<a name="l01786"></a>01786                 }
<a name="l01787"></a>01787                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vec2.size() == 0 &amp;&amp; ls == <span class="stringliteral">"and"</span>) {
<a name="l01788"></a>01788                     e2 = yices_mk_false(ctx);
<a name="l01789"></a>01789                 }
<a name="l01790"></a>01790                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vec2.size() == 0 &amp;&amp; ls == <span class="stringliteral">"or"</span>) {
<a name="l01791"></a>01791                     e2 = yices_mk_true(ctx);
<a name="l01792"></a>01792                 }
<a name="l01793"></a>01793                
<a name="l01794"></a>01794                 yices_expr arr[2];
<a name="l01795"></a>01795                 arr[0] = e1;
<a name="l01796"></a>01796                 arr[1] = e2;
<a name="l01797"></a>01797                <span class="comment">// yices_expr ret = yices_mk_fresh_bool_var(ctx);</span>
<a name="l01798"></a>01798             <span class="keywordflow">if</span> (ls == <span class="stringliteral">"or"</span>) {
<a name="l01799"></a>01799                 ret = yices_mk_or(ctx, arr, 2);
<a name="l01800"></a>01800             }
<a name="l01801"></a>01801             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ls == <span class="stringliteral">"and"</span>) {
<a name="l01802"></a>01802                 ret = yices_mk_and(ctx, arr, 2);
<a name="l01803"></a>01803             }
<a name="l01804"></a>01804             <span class="keywordflow">else</span> {
<a name="l01805"></a>01805                 <span class="comment">//std::cout &lt;&lt; "bad logical command" &lt;&lt; std::endl;</span>
<a name="l01806"></a>01806                 ROSE_ASSERT(<span class="keyword">false</span>);
<a name="l01807"></a>01807             }
<a name="l01808"></a>01808             <span class="comment">//yices_assert(ctx, ret);</span>
<a name="l01809"></a>01809             <span class="keywordflow">return</span> ret;    
<a name="l01810"></a>01810         <span class="comment">//}</span>
<a name="l01811"></a>01811         <span class="comment">//stst &lt;&lt; "( "&lt;&lt; ls &lt;&lt; " " &lt;&lt; mainParse(vec1) &lt;&lt; " " &lt;&lt; mainParse(vec2) &lt;&lt; ")";</span>
<a name="l01812"></a>01812         <span class="comment">//parsed = stst.str();</span>
<a name="l01813"></a>01813         <span class="comment">//stst &lt;&lt; "and " &lt;&lt; mainParse(vec2) &lt;&lt; ")\n";</span>
<a name="l01814"></a>01814         
<a name="l01815"></a>01815     }
<a name="l01816"></a>01816     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="yicesParserLib_8h.html#829e1926858e10820b25e92ffc2757ac">isBinaryLogicOp</a>(expr[0]-&gt;get_SgNode()) || <a class="code" href="yicesParserLib_8h.html#f615c7424ab8ea00c1faefc1c0a1a6ec">isBinaryOp</a>(expr[0]-&gt;get_SgNode())) {
<a name="l01817"></a>01817         <span class="comment">//std::vector&lt;int&gt; bounds = breakTriple(expr);</span>
<a name="l01818"></a>01818         <span class="keywordtype">int</span> i = 1;
<a name="l01819"></a>01819         <span class="keywordtype">int</span> check = 0;
<a name="l01820"></a>01820        <span class="comment">// std::cout &lt;&lt; "binarylogic vec: " &lt;&lt; std::endl;</span>
<a name="l01821"></a>01821        <span class="comment">// for (int ws = 0; ws &lt; expr.size(); ws++) {</span>
<a name="l01822"></a>01822        <span class="comment">//     std::cout &lt;&lt; getGraphNodeType(expr[ws]) &lt;&lt; std::endl;</span>
<a name="l01823"></a>01823        <span class="comment">// }</span>
<a name="l01824"></a>01824        <span class="comment">// std::cout &lt;&lt; "endlogic" &lt;&lt; std::endl;</span>
<a name="l01825"></a>01825        <span class="comment">// std::cout &lt;&lt; "\n";</span>
<a name="l01826"></a>01826         std::vector&lt;SgGraphNode*&gt; vecX;
<a name="l01827"></a>01827         std::map&lt;int, std::vector&lt;SgGraphNode*&gt; &gt; vec;
<a name="l01828"></a>01828         <span class="keywordflow">while</span> (check &lt; expr[0]-&gt;get_SgNode()-&gt;cfgIndexForEnd()) {
<a name="l01829"></a>01829             <span class="keywordflow">if</span> (expr[0]-&gt;get_SgNode() == expr[i]-&gt;get_SgNode()) { 
<a name="l01830"></a>01830                 vec[check] = vecX;
<a name="l01831"></a>01831                 vecX.clear();
<a name="l01832"></a>01832                 check++;
<a name="l01833"></a>01833                 <span class="keywordflow">if</span> (check == expr[0]-&gt;get_SgNode()-&gt;cfgIndexForEnd()) {
<a name="l01834"></a>01834                     <span class="keywordflow">break</span>;
<a name="l01835"></a>01835                 }
<a name="l01836"></a>01836              }
<a name="l01837"></a>01837              <span class="keywordflow">if</span> (expr[0]-&gt;get_SgNode() != expr[i]-&gt;get_SgNode()) {
<a name="l01838"></a>01838              vecX.push_back(expr[i]);
<a name="l01839"></a>01839              }
<a name="l01840"></a>01840              i++;
<a name="l01841"></a>01841         }
<a name="l01842"></a>01842         vec1 = vec[0];
<a name="l01843"></a>01843         vec2 = vec[1];
<a name="l01844"></a>01844 <span class="comment">/*</span>
<a name="l01845"></a>01845 <span class="comment">        for (int i = bounds[0]+1; i &lt; bounds[1]; i++) {</span>
<a name="l01846"></a>01846 <span class="comment">            vec1.push_back(expr[i]);</span>
<a name="l01847"></a>01847 <span class="comment">        }</span>
<a name="l01848"></a>01848 <span class="comment">        for (int j = bounds[1]+1; j &lt; bounds[2]; j++) {</span>
<a name="l01849"></a>01849 <span class="comment">            vec2.push_back(expr[j]);</span>
<a name="l01850"></a>01850 <span class="comment">        }</span>
<a name="l01851"></a>01851 <span class="comment">*/</span>
<a name="l01852"></a>01852         <span class="keywordflow">if</span> (<a class="code" href="yicesParserLib_8h.html#829e1926858e10820b25e92ffc2757ac">isBinaryLogicOp</a>(expr[0]-&gt;get_SgNode())) {
<a name="l01853"></a>01853             parsed = <a class="code" href="yicesParserLib_8h.html#9919f7194d5f3918d5f0ed1620d80f98">getBinaryLogicOp</a>(expr[0]-&gt;get_SgNode());
<a name="l01854"></a>01854         }
<a name="l01855"></a>01855         <span class="keywordflow">else</span> {
<a name="l01856"></a>01856             parsed = <a class="code" href="yicesParserLib_8h.html#a870bfe46596003d476a434c5a198835">getBinaryOp</a>(expr[0]-&gt;get_SgNode());
<a name="l01857"></a>01857         }
<a name="l01858"></a>01858         <span class="comment">//yices_expr ret;</span>
<a name="l01859"></a>01859         <span class="keywordflow">if</span> (<a class="code" href="yicesParserLib_8h.html#829e1926858e10820b25e92ffc2757ac">isBinaryLogicOp</a>(expr[0]-&gt;get_SgNode())) {
<a name="l01860"></a>01860             ret = yices_mk_fresh_bool_var(ctx);
<a name="l01861"></a>01861             yices_expr e1 = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(vec1, ctx);
<a name="l01862"></a>01862             yices_expr e2 = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(vec2, ctx);
<a name="l01863"></a>01863             <span class="keywordflow">if</span> (parsed == <span class="stringliteral">"&gt;"</span>) {
<a name="l01864"></a>01864                 ret = yices_mk_gt(ctx,e1, e2); 
<a name="l01865"></a>01865             }
<a name="l01866"></a>01866             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parsed == <span class="stringliteral">"&lt;"</span>) {
<a name="l01867"></a>01867                 ret = yices_mk_lt(ctx, e1, e2);
<a name="l01868"></a>01868             }
<a name="l01869"></a>01869             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parsed == <span class="stringliteral">"="</span>) {
<a name="l01870"></a>01870                 ret = yices_mk_eq(ctx, e1, e2);
<a name="l01871"></a>01871             }
<a name="l01872"></a>01872             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parsed == <span class="stringliteral">"!="</span>) {
<a name="l01873"></a>01873                 ret = yices_mk_diseq(ctx, e1, e2);
<a name="l01874"></a>01874             }
<a name="l01875"></a>01875             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parsed == <span class="stringliteral">"&lt;="</span>) {
<a name="l01876"></a>01876                 ret = yices_mk_le(ctx, e1, e2);
<a name="l01877"></a>01877             }
<a name="l01878"></a>01878             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parsed == <span class="stringliteral">"&gt;="</span>) {
<a name="l01879"></a>01879                 ret = yices_mk_ge(ctx, e1, e2);
<a name="l01880"></a>01880             }
<a name="l01881"></a>01881             <span class="keywordflow">else</span> {
<a name="l01882"></a>01882                 <span class="comment">//std::cout &lt;&lt; "unknown binary logic op" &lt;&lt; std::endl;</span>
<a name="l01883"></a>01883                 <span class="keywordflow">return</span> ret;
<a name="l01884"></a>01884             }
<a name="l01885"></a>01885             <span class="comment">//std::cout &lt;&lt; "parsed: " &lt;&lt; parsed &lt;&lt; std::endl;</span>
<a name="l01886"></a>01886             ROSE_ASSERT(ret != NULL);
<a name="l01887"></a>01887             <span class="comment">//yices_assert(ctx, ret);</span>
<a name="l01888"></a>01888             <span class="keywordflow">return</span> ret;
<a name="l01889"></a>01889         }
<a name="l01890"></a>01890          <span class="comment">//   stst &lt;&lt; "( " &lt;&lt;  parsed &lt;&lt; " " &lt;&lt; mainParse(vec1) &lt;&lt; " " &lt;&lt; mainParse(vec2) &lt;&lt; ")";</span>
<a name="l01891"></a>01891         <span class="keywordflow">else</span> {
<a name="l01892"></a>01892             yices_expr e1 = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(vec1, ctx);
<a name="l01893"></a>01893             yices_expr e2 = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(vec2, ctx);
<a name="l01894"></a>01894             yices_expr yicesarr[2];
<a name="l01895"></a>01895             yicesarr[0] = e1;
<a name="l01896"></a>01896             yicesarr[1] = e2; 
<a name="l01897"></a>01897             string bop = <a class="code" href="yicesParserLib_8h.html#a870bfe46596003d476a434c5a198835">getBinaryOp</a>(expr[0]-&gt;get_SgNode());
<a name="l01898"></a>01898             <span class="keywordflow">if</span> (bop == <span class="stringliteral">"+"</span>) {
<a name="l01899"></a>01899                 
<a name="l01900"></a>01900                 ret = yices_mk_sum(ctx, yicesarr, 2);
<a name="l01901"></a>01901             }
<a name="l01902"></a>01902             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bop == <span class="stringliteral">"-"</span>) {
<a name="l01903"></a>01903                 ret = yices_mk_sub(ctx, yicesarr, 2);
<a name="l01904"></a>01904             }
<a name="l01905"></a>01905             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bop == <span class="stringliteral">"*"</span>) {
<a name="l01906"></a>01906                 ret = yices_mk_mul(ctx, yicesarr, 2);
<a name="l01907"></a>01907             }
<a name="l01908"></a>01908             <span class="comment">//else if (bop == "/") {</span>
<a name="l01909"></a>01909             <span class="comment">//    ret = yices_mk_div(ctx, e1, e2);</span>
<a name="l01910"></a>01910            <span class="comment">// }</span>
<a name="l01911"></a>01911             <span class="keywordflow">else</span> {
<a name="l01912"></a>01912                 <span class="comment">//std::cout &lt;&lt; "bad binary op: " &lt;&lt; bop &lt;&lt; endl;</span>
<a name="l01913"></a>01913                 ROSE_ASSERT(<span class="keyword">false</span>);
<a name="l01914"></a>01914             }
<a name="l01915"></a>01915         <span class="keywordflow">return</span> ret;
<a name="l01916"></a>01916             <span class="comment">//stst &lt;&lt; "( " &lt;&lt; parsed &lt;&lt; " " &lt;&lt; mainParse(vec1) &lt;&lt; " " &lt;&lt; mainParse(vec2) &lt;&lt; " ) ";</span>
<a name="l01917"></a>01917         }
<a name="l01918"></a>01918         <span class="comment">//parsed = stst.str();</span>
<a name="l01919"></a>01919     }
<a name="l01920"></a>01920     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#9e11da482d419525433ef5df81084c5a">isSgPlusPlusOp</a>(expr[0]-&gt;get_SgNode())) {
<a name="l01921"></a>01921         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; expr.size() - 1; i++) {
<a name="l01922"></a>01922             vec1.push_back(expr[i]);
<a name="l01923"></a>01923         }
<a name="l01924"></a>01924         yices_expr e1 = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(vec1, ctx);
<a name="l01925"></a>01925         stringstream funN;
<a name="l01926"></a>01926         <a class="code" href="yicesParserLib_8h.html#e8f6d2fd6490d3153cb4133bf183a404">nvars</a>++;
<a name="l01927"></a>01927         funN &lt;&lt; <span class="stringliteral">"V"</span> &lt;&lt; <a class="code" href="yicesParserLib_8h.html#e8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l01928"></a>01928        
<a name="l01929"></a>01929         <span class="keywordtype">char</span>* fun = (<span class="keywordtype">char</span>*) funN.str().c_str();
<a name="l01930"></a>01930         yices_type ty = yices_mk_type(ctx, <span class="stringliteral">"int"</span>);
<a name="l01931"></a>01931         yices_var_decl vdecl = yices_mk_var_decl(ctx, fun, ty);
<a name="l01932"></a>01932         yices_expr e2 = yices_mk_var_from_decl(ctx, vdecl);
<a name="l01933"></a>01933         yices_expr arr[2];
<a name="l01934"></a>01934         yices_expr en = yices_mk_num(ctx, 1);
<a name="l01935"></a>01935         arr[0] = e1;
<a name="l01936"></a>01936         arr[1] = en; 
<a name="l01937"></a>01937         ret = yices_mk_sum(ctx, arr, 2);
<a name="l01938"></a>01938         <span class="keywordflow">return</span> ret;
<a name="l01939"></a>01939     }    
<a name="l01940"></a>01940     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="yicesParserLib_8h.html#0e2b091991daad5711a33ca835ae753c">isAtom</a>(expr[0]-&gt;get_SgNode()) != <span class="stringliteral">""</span>) {
<a name="l01941"></a>01941         string ty = <a class="code" href="yicesParserLib_8h.html#0e2b091991daad5711a33ca835ae753c">isAtom</a>(expr[0]-&gt;get_SgNode());
<a name="l01942"></a>01942         <span class="keywordflow">if</span> (ty == <span class="stringliteral">"int"</span>) {
<a name="l01943"></a>01943             <span class="keywordtype">int</span> ival = <a class="code" href="Cxx__Grammar_8h.html#271740fb8df92ff5fc69f6bfd193794c">isSgIntVal</a>(expr[0]-&gt;get_SgNode())-&gt;<a class="code" href="classSgIntVal.html#5e67cb3301c41a7e04365efff85c58a4">get_value</a>();
<a name="l01944"></a>01944             ret = yices_mk_num(ctx, ival);
<a name="l01945"></a>01945             <span class="comment">//std::cout &lt;&lt; "ival: " &lt;&lt;  ival &lt;&lt; std::endl;</span>
<a name="l01946"></a>01946             
<a name="l01947"></a>01947             <span class="comment">//parsed = ss.str();</span>
<a name="l01948"></a>01948         }
<a name="l01949"></a>01949         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ty == <span class="stringliteral">"double"</span>) {
<a name="l01950"></a>01950             <span class="keywordtype">double</span> dval = <a class="code" href="Cxx__Grammar_8h.html#e48c1fcd1978f66ef4caae88edb0b0e1">isSgDoubleVal</a>(expr[0]-&gt;get_SgNode())-&gt;<a class="code" href="classSgDoubleVal.html#2a1d1bb77d2662faed65c81aab484449">get_value</a>();
<a name="l01951"></a>01951             <span class="comment">//ss &lt;&lt; dval;</span>
<a name="l01952"></a>01952             <span class="comment">//parsed = ss.str();</span>
<a name="l01953"></a>01953             ret = yices_mk_num(ctx, dval);    
<a name="l01954"></a>01954         }
<a name="l01955"></a>01955         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ty == <span class="stringliteral">"float"</span>) {
<a name="l01956"></a>01956            <span class="keywordtype">float</span> fval = <a class="code" href="Cxx__Grammar_8h.html#7121dbcf3af72ced55f79082e708f74c">isSgFloatVal</a>(expr[0]-&gt;get_SgNode())-&gt;<a class="code" href="classSgFloatVal.html#a56b1223e63cdc98c37bf564439bfdc3">get_value</a>();
<a name="l01957"></a>01957           <span class="comment">// ss &lt;&lt; fval;</span>
<a name="l01958"></a>01958           <span class="comment">// parsed =  ss.str();</span>
<a name="l01959"></a>01959            ret = yices_mk_num(ctx, fval);
<a name="l01960"></a>01960         }
<a name="l01961"></a>01961         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ty == <span class="stringliteral">"short"</span>) {
<a name="l01962"></a>01962            <span class="keywordtype">short</span> sval = <a class="code" href="Cxx__Grammar_8h.html#37633f6c6e825dec951b2440e5958c8f">isSgShortVal</a>(expr[0]-&gt;get_SgNode())-&gt;<a class="code" href="classSgShortVal.html#440adf96563ab729f2d4a3dafc15d26a">get_value</a>();
<a name="l01963"></a>01963            <span class="comment">//ss &lt;&lt; sval;</span>
<a name="l01964"></a>01964            <span class="comment">//parsed =  ss.str();</span>
<a name="l01965"></a>01965            ret = yices_mk_num(ctx, sval);
<a name="l01966"></a>01966         }
<a name="l01967"></a>01967         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ty == <span class="stringliteral">"long"</span>) {
<a name="l01968"></a>01968             <span class="keywordtype">long</span> lval = <a class="code" href="Cxx__Grammar_8h.html#8d641a4dc877a64a34939bccd7206b3d">isSgLongIntVal</a>(expr[0]-&gt;get_SgNode())-&gt;<a class="code" href="classSgLongIntVal.html#7d9ac95205a638fd22fdff4cc6f357c3">get_value</a>();
<a name="l01969"></a>01969             <span class="comment">//ss &lt;&lt; lval;</span>
<a name="l01970"></a>01970             <span class="comment">//parsed = ss.str();</span>
<a name="l01971"></a>01971             ret = yices_mk_num(ctx, lval);
<a name="l01972"></a>01972         }
<a name="l01973"></a>01973         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ty == <span class="stringliteral">"long long int"</span>) {
<a name="l01974"></a>01974             <span class="keywordtype">long</span> <span class="keywordtype">long</span> llval = <a class="code" href="Cxx__Grammar_8h.html#0de548d3fc05ea2d92a851a45adfbcd0">isSgLongLongIntVal</a>(expr[0]-&gt;get_SgNode())-&gt;<a class="code" href="classSgLongLongIntVal.html#4002e332d14745c06e092efa4b9f1047">get_value</a>();
<a name="l01975"></a>01975             <span class="comment">//ss &lt;&lt; llval;</span>
<a name="l01976"></a>01976             <span class="comment">//parsed = ss.str();</span>
<a name="l01977"></a>01977             ret = yices_mk_num(ctx, llval);
<a name="l01978"></a>01978         }
<a name="l01979"></a>01979         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ty == <span class="stringliteral">"long double"</span>) {
<a name="l01980"></a>01980             <span class="keywordtype">long</span> <span class="keywordtype">double</span> lldval = <a class="code" href="Cxx__Grammar_8h.html#8d9aebaeef960636dc0ac8d9cb9a210c">isSgLongDoubleVal</a>(expr[0]-&gt;get_SgNode())-&gt;<a class="code" href="classSgLongDoubleVal.html#8704d630f6ec3761bf285c968b10b4c8">get_value</a>();
<a name="l01981"></a>01981             <span class="comment">//ss &lt;&lt; lldval;</span>
<a name="l01982"></a>01982             <span class="comment">//parsed =  ss.str();</span>
<a name="l01983"></a>01983             ret = yices_mk_num(ctx, lldval);
<a name="l01984"></a>01984         }
<a name="l01985"></a>01985         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ty == <span class="stringliteral">"bool"</span>) {
<a name="l01986"></a>01986             <span class="keywordtype">bool</span> bval = <a class="code" href="Cxx__Grammar_8h.html#c4439e159a27201c54e285cf47109a2f">isSgBoolValExp</a>(expr[0]-&gt;get_SgNode())-&gt;<a class="code" href="classSgBoolValExp.html#9ff7f1712e0b6ffe46ed4b6141f1b8c7">get_value</a>();
<a name="l01987"></a>01987             <span class="keywordflow">if</span> (bval == <span class="keyword">true</span>) {
<a name="l01988"></a>01988                 parsed = <span class="stringliteral">"true"</span>;
<a name="l01989"></a>01989                 ret = yices_mk_true(ctx);
<a name="l01990"></a>01990             }
<a name="l01991"></a>01991             <span class="keywordflow">else</span> {
<a name="l01992"></a>01992                 parsed = <span class="stringliteral">"false"</span>;
<a name="l01993"></a>01993                 ret = yices_mk_false(ctx);
<a name="l01994"></a>01994             }
<a name="l01995"></a>01995         }
<a name="l01996"></a>01996         <span class="keywordflow">else</span> {
<a name="l01997"></a>01997             <span class="comment">//cout &lt;&lt; "unsupported atomic type";</span>
<a name="l01998"></a>01998             ROSE_ASSERT(<span class="keyword">false</span>);
<a name="l01999"></a>01999         }
<a name="l02000"></a>02000         <span class="keywordflow">return</span> ret;
<a name="l02001"></a>02001     }
<a name="l02002"></a>02002     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#29790f42abd6bd84cfe6d03bf892a5b6">isSgVarRefExp</a>((expr[0])-&gt;get_SgNode())) {
<a name="l02003"></a>02003         <a class="code" href="classSgName.html">SgName</a> svs = <a class="code" href="Cxx__Grammar_8h.html#29790f42abd6bd84cfe6d03bf892a5b6">isSgVarRefExp</a>(expr[0]-&gt;get_SgNode())-&gt;<a class="code" href="classSgVarRefExp.html#283df7407d1eb0c59488029f1d93f7fe">get_symbol</a>()-&gt;<a class="code" href="classSgVariableSymbol.html#dcd7f9c9e3a26f8993d80a732d747077">get_declaration</a>()-&gt;<a class="code" href="classSgInitializedName.html#564cb1f49b92b7e08a4d4da072f3d26c">get_qualified_name</a>();
<a name="l02004"></a>02004         <span class="comment">//stringstream ss;</span>
<a name="l02005"></a>02005         ROSE_ASSERT(<a class="code" href="yicesParserLib_8h.html#3703af20b0be2697db1fcd0452dd9c6e">getExpr</a>.find(svs) != <a class="code" href="yicesParserLib_8h.html#3703af20b0be2697db1fcd0452dd9c6e">getExpr</a>.end());
<a name="l02006"></a>02006         ROSE_ASSERT(<a class="code" href="yicesParserLib_8h.html#d9c55e63216a3f4b4d8f344149a3646b">nameOf</a>.find(svs) != <a class="code" href="yicesParserLib_8h.html#d9c55e63216a3f4b4d8f344149a3646b">nameOf</a>.end());
<a name="l02007"></a>02007         <span class="comment">//    parsed = nameOf[svs];</span>
<a name="l02008"></a>02008         <span class="comment">//}</span>
<a name="l02009"></a>02009         <span class="comment">//else {</span>
<a name="l02010"></a>02010         <span class="comment">//    ss &lt;&lt;  "V" &lt;&lt; nvars;</span>
<a name="l02011"></a>02011         <span class="comment">//    nvars++;</span>
<a name="l02012"></a>02012         <span class="comment">//    nameOf[svs] = ss.str();</span>
<a name="l02013"></a>02013         <span class="comment">//    parsed = nameOf[svs];</span>
<a name="l02014"></a>02014         <span class="comment">//}</span>
<a name="l02015"></a>02015         <span class="comment">//std::cout &lt;&lt; "nameOf[svs]: " &lt;&lt; nameOf[svs] &lt;&lt; std::endl;</span>
<a name="l02016"></a>02016        yices_expr e1;<span class="comment">// = new yices_expr; </span>
<a name="l02017"></a>02017        <span class="keywordflow">if</span> (<a class="code" href="yicesParserLib_8h.html#3703af20b0be2697db1fcd0452dd9c6e">getExpr</a>.find(svs) != <a class="code" href="yicesParserLib_8h.html#3703af20b0be2697db1fcd0452dd9c6e">getExpr</a>.end()) {
<a name="l02018"></a>02018         e1 = <a class="code" href="yicesParserLib_8h.html#3703af20b0be2697db1fcd0452dd9c6e">getExpr</a>[svs];
<a name="l02019"></a>02019         }
<a name="l02020"></a>02020         <span class="keywordflow">else</span> {
<a name="l02021"></a>02021         <a class="code" href="classSgType.html">SgType</a>* typ = <a class="code" href="Cxx__Grammar_8h.html#29790f42abd6bd84cfe6d03bf892a5b6">isSgVarRefExp</a>(expr[0]-&gt;get_SgNode())-&gt;<a class="code" href="classSgVarRefExp.html#698f2223580203cf549c671c66941b81">get_type</a>();
<a name="l02022"></a>02022         string valType = <a class="code" href="yicesParserLib_8h.html#2a78ff2b912bbb36235508d39c77c9b6">getType</a>(typ);
<a name="l02023"></a>02023         <span class="keywordtype">char</span>* valTypeCh = (<span class="keywordtype">char</span>*) valType.c_str();
<a name="l02024"></a>02024         stringstream stst;
<a name="l02025"></a>02025         <a class="code" href="yicesParserLib_8h.html#e8f6d2fd6490d3153cb4133bf183a404">nvars</a>++;
<a name="l02026"></a>02026         stst &lt;&lt; svs.<a class="code" href="classSgName.html#f0b50e9570235a749205387bfa04cead">getString</a>() &lt;&lt; <a class="code" href="yicesParserLib_8h.html#e8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l02027"></a>02027         <a class="code" href="yicesParserLib_8h.html#d9c55e63216a3f4b4d8f344149a3646b">nameOf</a>[svs] = stst.str();
<a name="l02028"></a>02028         
<a name="l02029"></a>02029         <span class="keywordtype">char</span>* fun = (<span class="keywordtype">char</span>*) stst.str().c_str();
<a name="l02030"></a>02030         yices_type ty = yices_mk_type(ctx, valTypeCh);
<a name="l02031"></a>02031         yices_var_decl vdecl = yices_mk_var_decl(ctx, fun, ty);
<a name="l02032"></a>02032         e1 = yices_mk_var_from_decl(ctx, vdecl);
<a name="l02033"></a>02033         <a class="code" href="yicesParserLib_8h.html#3703af20b0be2697db1fcd0452dd9c6e">getExpr</a>[svs] = e1;
<a name="l02034"></a>02034         }
<a name="l02035"></a>02035         ret = e1;
<a name="l02036"></a>02036         <span class="keywordflow">return</span> ret;
<a name="l02037"></a>02037         
<a name="l02038"></a>02038     }
<a name="l02039"></a>02039     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#3d55e45b923661b7efeeb664266d2527">isSgInitializedName</a>(expr[0]-&gt;get_SgNode())) {
<a name="l02040"></a>02040         stringstream stst;
<a name="l02041"></a>02041         std::vector&lt;SgGraphNode*&gt; vec1;
<a name="l02042"></a>02042         <span class="comment">//ROSE_ASSERT(isAtom((expr[2])-&gt;get_SgNode()) != "");</span>
<a name="l02043"></a>02043       <span class="comment">//  string valType = isAtom((expr[2])-&gt;get_SgNode());</span>
<a name="l02044"></a>02044         <span class="keywordtype">int</span> p = 3;
<a name="l02045"></a>02045          
<a name="l02046"></a>02046 
<a name="l02047"></a>02047               <a class="code" href="classSgName.html">SgName</a> svs = (<a class="code" href="Cxx__Grammar_8h.html#3d55e45b923661b7efeeb664266d2527">isSgInitializedName</a>(expr[0]-&gt;get_SgNode()))-&gt;get_qualified_name();
<a name="l02048"></a>02048                     <a class="code" href="classSgType.html">SgType</a>* typ = (<a class="code" href="Cxx__Grammar_8h.html#3d55e45b923661b7efeeb664266d2527">isSgInitializedName</a>(expr[0]-&gt;get_SgNode()))-&gt;get_type();
<a name="l02049"></a>02049                     string valType = <a class="code" href="yicesParserLib_8h.html#2a78ff2b912bbb36235508d39c77c9b6">getType</a>(typ);
<a name="l02050"></a>02050                     <span class="comment">//stringstream funN;</span>
<a name="l02051"></a>02051 <span class="comment">/*</span>
<a name="l02052"></a>02052 <span class="comment">                    funN &lt;&lt; "V" &lt;&lt; nvars;</span>
<a name="l02053"></a>02053 <span class="comment">                    nvars++;</span>
<a name="l02054"></a>02054 <span class="comment">                    char* fun = (char*) funN.str().c_str();</span>
<a name="l02055"></a>02055 <span class="comment">                    char* valTypeCh = (char*) typ_str.c_str();</span>
<a name="l02056"></a>02056 <span class="comment">                    yices_type ty = yices_mk_type(ctx, valTypeCh);</span>
<a name="l02057"></a>02057 <span class="comment">                    yices_var_decl vdecl = yices_mk_var_decl(ctx, fun, ty);</span>
<a name="l02058"></a>02058 <span class="comment">                    yices_expr e1 = yices_mk_var_from_decl(ctx, vdecl);</span>
<a name="l02059"></a>02059 <span class="comment">                    getExpr[svs] = e1;</span>
<a name="l02060"></a>02060 <span class="comment">                    nameOf[svs] = fun;</span>
<a name="l02061"></a>02061 <span class="comment">*/</span>
<a name="l02062"></a>02062 
<a name="l02063"></a>02063 
<a name="l02064"></a>02064 
<a name="l02065"></a>02065          <span class="comment">// SgName svs = (isSgInitializedName(expr[0]-&gt;get_SgNode()))-&gt;get_qualified_name();</span>
<a name="l02066"></a>02066 
<a name="l02067"></a>02067       <span class="comment">//  if (isAtom(expr[2]) == "") {</span>
<a name="l02068"></a>02068 <span class="comment">//        SgName svs = (isSgInitializedName(expr[0]-&gt;get_SgNode()))-&gt;get_qualified_name();</span>
<a name="l02069"></a>02069         <span class="keywordtype">int</span> check = 0;
<a name="l02070"></a>02070         vec1.push_back(expr[2]);
<a name="l02071"></a>02071         <span class="comment">//std::cout &lt;&lt; "expr[2]: " &lt;&lt; getGraphNodeType(expr[2]) &lt;&lt; std::endl;</span>
<a name="l02072"></a>02072         <span class="keywordflow">if</span> (!<a class="code" href="Cxx__Grammar_8h.html#29790f42abd6bd84cfe6d03bf892a5b6">isSgVarRefExp</a>(vec1[0])) {
<a name="l02073"></a>02073          
<a name="l02074"></a>02074         <span class="keywordflow">while</span> (<span class="comment">/*expr[2]-&gt;get_SgNode() != expr[p]-&gt;get_SgNode()) { &amp;&amp;*/</span> check &lt; expr[2]-&gt;get_SgNode()-&gt;cfgIndexForEnd()) {
<a name="l02075"></a>02075             <span class="keywordflow">if</span> (expr[2]-&gt;get_SgNode() == expr[p]-&gt;get_SgNode()) {
<a name="l02076"></a>02076                 check++;
<a name="l02077"></a>02077                 <span class="keywordflow">if</span> (check &gt;= expr[2]-&gt;get_SgNode()-&gt;cfgIndexForEnd()) {
<a name="l02078"></a>02078                     <span class="keywordflow">break</span>;
<a name="l02079"></a>02079                 }
<a name="l02080"></a>02080             }
<a name="l02081"></a>02081             vec1.push_back(expr[p]);
<a name="l02082"></a>02082             p++;
<a name="l02083"></a>02083             <span class="comment">//vec1.push_back(expr[p]);</span>
<a name="l02084"></a>02084          <span class="comment">//   p++;</span>
<a name="l02085"></a>02085         }
<a name="l02086"></a>02086         vec1.push_back(expr[p]);
<a name="l02087"></a>02087         }
<a name="l02088"></a>02088         stringstream funN;
<a name="l02089"></a>02089         string ss;
<a name="l02090"></a>02090         <span class="comment">//std::cout &lt;&lt; "vec1: " &lt;&lt; std::endl;</span>
<a name="l02091"></a>02091        <span class="comment">// for (int tt = 0; tt &lt; vec1.size(); tt++) {</span>
<a name="l02092"></a>02092        <span class="comment">//     std::cout &lt;&lt; getGraphNodeType(vec1[tt]) &lt;&lt; std::endl;</span>
<a name="l02093"></a>02093       <span class="comment">//  }</span>
<a name="l02094"></a>02094       <span class="comment">//  std::cout &lt;&lt; "\n\n";</span>
<a name="l02095"></a>02095         <span class="comment">//if (nameOf.find(svs) != nameOf.end()) {</span>
<a name="l02096"></a>02096         <span class="comment">//    ss = nameOf[svs];</span>
<a name="l02097"></a>02097         <span class="comment">//}</span>
<a name="l02098"></a>02098         <span class="comment">//else {</span>
<a name="l02099"></a>02099             <a class="code" href="yicesParserLib_8h.html#e8f6d2fd6490d3153cb4133bf183a404">nvars</a>++;
<a name="l02100"></a>02100             funN &lt;&lt; svs.<a class="code" href="classSgName.html#f0b50e9570235a749205387bfa04cead">getString</a>() &lt;&lt; <a class="code" href="yicesParserLib_8h.html#e8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l02101"></a>02101             <a class="code" href="yicesParserLib_8h.html#d9c55e63216a3f4b4d8f344149a3646b">nameOf</a>[svs] = funN.str();
<a name="l02102"></a>02102             <span class="comment">//ss = funN.str();</span>
<a name="l02103"></a>02103             <span class="comment">//nvars++;  </span>
<a name="l02104"></a>02104             <span class="comment">//stst &lt;&lt; "(declare-fun " &lt;&lt; ss &lt;&lt; " () " &lt;&lt; valType &lt;&lt; ")\n";</span>
<a name="l02105"></a>02105         <span class="comment">//}i</span>
<a name="l02106"></a>02106         <span class="keywordtype">char</span>* fun = (<span class="keywordtype">char</span>*) funN.str().c_str();<span class="comment">//funN.str().c_str();</span>
<a name="l02107"></a>02107         <span class="comment">//for (int i = 0; i &lt; funN.str().size(); i++) {</span>
<a name="l02108"></a>02108         <span class="comment">//    fun[i] = funN.str()[i];</span>
<a name="l02109"></a>02109         <span class="comment">//}</span>
<a name="l02110"></a>02110         <span class="comment">//std::cout &lt;&lt; "fun: " &lt;&lt; fun &lt;&lt; std::endl;</span>
<a name="l02111"></a>02111         <span class="keywordtype">char</span>* valTypeCh = (<span class="keywordtype">char</span>*) valType.c_str();
<a name="l02112"></a>02112         <span class="comment">//for (int j = 0; j &lt; valType.size(); j++) {</span>
<a name="l02113"></a>02113         <span class="comment">//    valTypeCh[j] = valType[j];</span>
<a name="l02114"></a>02114         <span class="comment">//}</span>
<a name="l02115"></a>02115         <span class="comment">//std::cout &lt;&lt; "valTypeCh: " &lt;&lt; valTypeCh &lt;&lt; std::endl;</span>
<a name="l02116"></a>02116         <span class="comment">//std::cout &lt;&lt; "fun" &lt;&lt; fun &lt;&lt; std::endl;</span>
<a name="l02117"></a>02117         <span class="comment">//char* fun = (char*)(funN.str().c_str());</span>
<a name="l02118"></a>02118         yices_type ty = yices_mk_type(ctx, valTypeCh);
<a name="l02119"></a>02119         yices_var_decl vdecl = yices_mk_var_decl(ctx, fun, ty);
<a name="l02120"></a>02120         yices_expr e1 = yices_mk_var_from_decl(ctx, vdecl);
<a name="l02121"></a>02121         <span class="comment">//getType[e1] = valType;</span>
<a name="l02122"></a>02122         <span class="comment">//getExpr[svs] = e1;</span>
<a name="l02123"></a>02123         <span class="comment">//std::cout &lt;&lt; "vec1.size(): " &lt;&lt; vec1.size() &lt;&lt; std::endl;</span>
<a name="l02124"></a>02124         <span class="comment">//std::cout &lt;&lt; "vec1[0]: " &lt;&lt; getGraphNodeType(vec1[0]) &lt;&lt; std::endl;</span>
<a name="l02125"></a>02125 
<a name="l02126"></a>02126         <span class="comment">//ROSE_ASSERT(e2 != NULL);</span>
<a name="l02127"></a>02127         <span class="comment">//ret = yices_mk_eq(ctx,e1,e1);</span>
<a name="l02128"></a>02128         yices_expr e2 = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(vec1,ctx);
<a name="l02129"></a>02129         <span class="keywordflow">if</span> (<a class="code" href="yicesParserLib_8h.html#ecc8aa7e3d5e014159a274d129d468f8">unknown_flag</a> || <a class="code" href="yicesParserLib_8h.html#b045f2a580863d59bb16abe16d0f586f">unknowns</a>.find(<a class="code" href="Cxx__Grammar_8h.html#3d55e45b923661b7efeeb664266d2527">isSgInitializedName</a>(expr[0]-&gt;get_SgNode())) != <a class="code" href="yicesParserLib_8h.html#b045f2a580863d59bb16abe16d0f586f">unknowns</a>.end()) {
<a name="l02130"></a>02130             <span class="keywordflow">if</span> (<a class="code" href="yicesParserLib_8h.html#ecc8aa7e3d5e014159a274d129d468f8">unknown_flag</a> || <a class="code" href="yicesParserLib_8h.html#b045f2a580863d59bb16abe16d0f586f">unknowns</a>.find(<a class="code" href="Cxx__Grammar_8h.html#3d55e45b923661b7efeeb664266d2527">isSgInitializedName</a>(expr[0]-&gt;get_SgNode())) != <a class="code" href="yicesParserLib_8h.html#b045f2a580863d59bb16abe16d0f586f">unknowns</a>.end()) {
<a name="l02131"></a>02131                 <a class="code" href="yicesParserLib_8h.html#b045f2a580863d59bb16abe16d0f586f">unknowns</a>[<a class="code" href="Cxx__Grammar_8h.html#3d55e45b923661b7efeeb664266d2527">isSgInitializedName</a>(expr[0]-&gt;get_SgNode())] = vdecl;
<a name="l02132"></a>02132                 <span class="comment">//if (!usingNots) {</span>
<a name="l02133"></a>02133                 <a class="code" href="yicesParserLib_8h.html#19d33e1e3b620862dfc2dd0d05c838ba">unknownvdeclis</a>.push_back(vdecl);
<a name="l02134"></a>02134                 
<a name="l02135"></a>02135                 <a class="code" href="yicesParserLib_8h.html#6cbb91bd6acaee78621ab5353ccbd78c">IName</a>[vdecl] = <a class="code" href="Cxx__Grammar_8h.html#3d55e45b923661b7efeeb664266d2527">isSgInitializedName</a>(expr[0]-&gt;get_SgNode());
<a name="l02136"></a>02136                 <span class="comment">//}</span>
<a name="l02137"></a>02137                 <span class="keywordflow">if</span> (<a class="code" href="yicesParserLib_8h.html#99ae78e96160b26ce175394c6deb89cb">usingNots</a>) {
<a name="l02138"></a>02138                     <span class="comment">//std::cout &lt;&lt; "uN" &lt;&lt; std::endl;</span>
<a name="l02139"></a>02139                     ROSE_ASSERT(<a class="code" href="yicesParserLib_8h.html#2191c6072731519cf2f129aa28b6268b">notMap</a>.find(<a class="code" href="Cxx__Grammar_8h.html#3d55e45b923661b7efeeb664266d2527">isSgInitializedName</a>(expr[0]-&gt;get_SgNode())) != <a class="code" href="yicesParserLib_8h.html#2191c6072731519cf2f129aa28b6268b">notMap</a>.end());
<a name="l02140"></a>02140                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; <a class="code" href="yicesParserLib_8h.html#2191c6072731519cf2f129aa28b6268b">notMap</a>[<a class="code" href="Cxx__Grammar_8h.html#3d55e45b923661b7efeeb664266d2527">isSgInitializedName</a>(expr[0]-&gt;get_SgNode())].size(); j++) {
<a name="l02141"></a>02141                             <span class="keywordtype">int</span> jv = <a class="code" href="yicesParserLib_8h.html#2191c6072731519cf2f129aa28b6268b">notMap</a>[<a class="code" href="Cxx__Grammar_8h.html#3d55e45b923661b7efeeb664266d2527">isSgInitializedName</a>(expr[0]-&gt;get_SgNode())][j];
<a name="l02142"></a>02142                             yices_expr jvexpr =yices_mk_num(ctx, jv);
<a name="l02143"></a>02143                             yices_expr ei = yices_mk_diseq(ctx, e1, jvexpr);
<a name="l02144"></a>02144                             yices_assert(ctx,ei);
<a name="l02145"></a>02145                         }
<a name="l02146"></a>02146                }
<a name="l02147"></a>02147                <span class="comment">// unknowndecls.push_back(vdecl);</span>
<a name="l02148"></a>02148             }  
<a name="l02149"></a>02149             <a class="code" href="yicesParserLib_8h.html#3703af20b0be2697db1fcd0452dd9c6e">getExpr</a>[svs] = e1;
<a name="l02150"></a>02150             <a class="code" href="yicesParserLib_8h.html#ecc8aa7e3d5e014159a274d129d468f8">unknown_flag</a> = <span class="keyword">false</span>;
<a name="l02151"></a>02151             ret = yices_mk_eq(ctx, e1, e1);
<a name="l02152"></a>02152         }
<a name="l02153"></a>02153          <span class="keywordflow">else</span> {
<a name="l02154"></a>02154             yices_expr e2 = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(vec1, ctx);
<a name="l02155"></a>02155            <span class="comment">// std::cout &lt;&lt; "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n";</span>
<a name="l02156"></a>02156            <span class="comment">// std::cout &lt;&lt; "valType: " &lt;&lt; valType &lt;&lt; std::endl;</span>
<a name="l02157"></a>02157           <span class="comment">//  std::cout &lt;&lt; "vec1: " &lt;&lt; std::endl;</span>
<a name="l02158"></a>02158           <span class="comment">//  for (int rr = 0; rr &lt; vec1.size(); rr++) {</span>
<a name="l02159"></a>02159           <span class="comment">//      std::cout &lt;&lt; getGraphNodeType(vec1[rr]) &lt;&lt; std::endl;</span>
<a name="l02160"></a>02160           <span class="comment">//  }</span>
<a name="l02161"></a>02161           <span class="comment">//  std::cout &lt;&lt; "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n";</span>
<a name="l02162"></a>02162             
<a name="l02163"></a>02163             <span class="comment">//yices_expr e2 = mainParse(vec1, ctx);</span>
<a name="l02164"></a>02164             ROSE_ASSERT(e1 != NULL);
<a name="l02165"></a>02165             ROSE_ASSERT(e2 != NULL);
<a name="l02166"></a>02166             ret = yices_mk_eq(ctx, e1, e2);
<a name="l02167"></a>02167             <a class="code" href="yicesParserLib_8h.html#3703af20b0be2697db1fcd0452dd9c6e">getExpr</a>[svs] = e2;
<a name="l02168"></a>02168             
<a name="l02169"></a>02169         }
<a name="l02170"></a>02170         <span class="comment">//yices_assert(ctx, ret); </span>
<a name="l02171"></a>02171         <span class="comment">//stst &lt;&lt; "(let (" &lt;&lt; ss &lt;&lt; " " &lt;&lt; mainParse(vec1) &lt;&lt; ")\n";</span>
<a name="l02172"></a>02172         <span class="comment">//parsed =  stst.str();</span>
<a name="l02173"></a>02173         
<a name="l02174"></a>02174         <span class="keywordflow">return</span> ret;
<a name="l02175"></a>02175     }
<a name="l02176"></a>02176     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#e068ff9eed6e5d17c277f1a2ce5da95f">isSgVariableDeclaration</a>(expr[0]-&gt;get_SgNode())) {
<a name="l02177"></a>02177        <span class="comment">// ROSE_ASSERT(isSgVariableDeclaration(expr.back()-&gt;get_SgNode()));</span>
<a name="l02178"></a>02178         std::vector&lt;SgGraphNode*&gt; expr2;
<a name="l02179"></a>02179         <span class="comment">//std::cout &lt;&lt; "back node: " &lt;&lt; getGraphNodeType(expr.back()) &lt;&lt; std::endl;</span>
<a name="l02180"></a>02180         ROSE_ASSERT(<a class="code" href="Cxx__Grammar_8h.html#e068ff9eed6e5d17c277f1a2ce5da95f">isSgVariableDeclaration</a>(expr.back()-&gt;get_SgNode()));
<a name="l02181"></a>02181         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> tt = 1; tt &lt; expr.size()-1; tt++) {
<a name="l02182"></a>02182             expr2.push_back(expr[tt]);
<a name="l02183"></a>02183         }
<a name="l02184"></a>02184         yices_expr y2 = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(expr2, ctx);
<a name="l02185"></a>02185         ret = y2;
<a name="l02186"></a>02186         <span class="keywordflow">return</span> ret;
<a name="l02187"></a>02187     }
<a name="l02188"></a>02188         
<a name="l02189"></a>02189     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#f11cf11e221c78ed704f42d42e854083">isSgAssignOp</a>(expr[0]-&gt;get_SgNode())) {
<a name="l02190"></a>02190         stringstream stst;
<a name="l02191"></a>02191         ROSE_ASSERT(<a class="code" href="Cxx__Grammar_8h.html#29790f42abd6bd84cfe6d03bf892a5b6">isSgVarRefExp</a>(expr[1]-&gt;get_SgNode()));
<a name="l02192"></a>02192         <span class="comment">//ROSE_ASSERT(isAtom(expr[3]-&gt;get_SgNode()) != "");</span>
<a name="l02193"></a>02193         <span class="comment">//string valType = isAtom(expr[3]-&gt;get_SgNode());</span>
<a name="l02194"></a>02194         std::vector&lt;int&gt; bounds = <a class="code" href="yicesParserLib_8h.html#f3e2edc97812f1b2c2c8878033c72364">breakTriple</a>(expr);
<a name="l02195"></a>02195         <span class="comment">//for (int i = bounds[0]+1; i &lt; bounds[1]; i++) {</span>
<a name="l02196"></a>02196         <span class="comment">//    vec1.push_back(expr[i]);</span>
<a name="l02197"></a>02197         <span class="comment">//}</span>
<a name="l02198"></a>02198         <a class="code" href="classSgName.html">SgName</a> svs = (<a class="code" href="Cxx__Grammar_8h.html#29790f42abd6bd84cfe6d03bf892a5b6">isSgVarRefExp</a>((expr[1]-&gt;get_SgNode()))-&gt;<a class="code" href="classSgVarRefExp.html#283df7407d1eb0c59488029f1d93f7fe">get_symbol</a>()-&gt;<a class="code" href="classSgVariableSymbol.html#dcd7f9c9e3a26f8993d80a732d747077">get_declaration</a>()-&gt;<a class="code" href="classSgInitializedName.html#564cb1f49b92b7e08a4d4da072f3d26c">get_qualified_name</a>());
<a name="l02199"></a>02199         <a class="code" href="classSgType.html">SgType</a>* typ = <a class="code" href="Cxx__Grammar_8h.html#29790f42abd6bd84cfe6d03bf892a5b6">isSgVarRefExp</a>((expr[1]-&gt;get_SgNode()))-&gt;<a class="code" href="classSgVarRefExp.html#283df7407d1eb0c59488029f1d93f7fe">get_symbol</a>()-&gt;<a class="code" href="classSgVariableSymbol.html#dcd7f9c9e3a26f8993d80a732d747077">get_declaration</a>()-&gt;<a class="code" href="classSgInitializedName.html#f4c8f922e442071cf6de3532ca8bc486">get_type</a>();
<a name="l02200"></a>02200         string valType = <a class="code" href="yicesParserLib_8h.html#2a78ff2b912bbb36235508d39c77c9b6">getType</a>(typ);
<a name="l02201"></a>02201         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = bounds[1]+1; j &lt; bounds[2]; j++) {
<a name="l02202"></a>02202             vec2.push_back(expr[j]);
<a name="l02203"></a>02203         }
<a name="l02204"></a>02204         <span class="keywordflow">if</span> (<a class="code" href="yicesParserLib_8h.html#d9c55e63216a3f4b4d8f344149a3646b">nameOf</a>.find(svs) != <a class="code" href="yicesParserLib_8h.html#d9c55e63216a3f4b4d8f344149a3646b">nameOf</a>.end()) {
<a name="l02205"></a>02205             stringstream ss;
<a name="l02206"></a>02206             <a class="code" href="yicesParserLib_8h.html#e8f6d2fd6490d3153cb4133bf183a404">nvars</a>++;
<a name="l02207"></a>02207             ss &lt;&lt; svs.<a class="code" href="classSgName.html#f0b50e9570235a749205387bfa04cead">getString</a>();
<a name="l02208"></a>02208             ss &lt;&lt; <a class="code" href="yicesParserLib_8h.html#e8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l02209"></a>02209             <span class="comment">//nvars++;</span>
<a name="l02210"></a>02210             yices_type ty1 = yices_mk_type(ctx, (<span class="keywordtype">char</span>*) valType.c_str());
<a name="l02211"></a>02211             yices_var_decl decl1 = yices_mk_var_decl(ctx, (<span class="keywordtype">char</span>*) ss.str().c_str(), ty1);
<a name="l02212"></a>02212             yices_expr e1 = yices_mk_var_from_decl(ctx, decl1);
<a name="l02213"></a>02213             yices_expr e2 = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(vec2, ctx);
<a name="l02214"></a>02214             <span class="keywordflow">if</span> (<a class="code" href="yicesParserLib_8h.html#ecc8aa7e3d5e014159a274d129d468f8">unknown_flag</a>) {
<a name="l02215"></a>02215                 <a class="code" href="yicesParserLib_8h.html#ecc8aa7e3d5e014159a274d129d468f8">unknown_flag</a> = <span class="keyword">false</span>;
<a name="l02216"></a>02216                 ret = yices_mk_eq(ctx, e1, e1);
<a name="l02217"></a>02217                 <a class="code" href="yicesParserLib_8h.html#3703af20b0be2697db1fcd0452dd9c6e">getExpr</a>[svs] = e1;
<a name="l02218"></a>02218             }
<a name="l02219"></a>02219             <span class="keywordflow">else</span> {
<a name="l02220"></a>02220                 ret = yices_mk_eq(ctx, e1, e2);
<a name="l02221"></a>02221                 <a class="code" href="yicesParserLib_8h.html#3703af20b0be2697db1fcd0452dd9c6e">getExpr</a>[svs] = e2;
<a name="l02222"></a>02222             }
<a name="l02223"></a>02223             <a class="code" href="yicesParserLib_8h.html#d9c55e63216a3f4b4d8f344149a3646b">nameOf</a>[svs] = ss.str();
<a name="l02224"></a>02224             <span class="comment">//getExpr[svs] = e2;</span>
<a name="l02225"></a>02225             <span class="keywordflow">return</span> ret;
<a name="l02226"></a>02226         }
<a name="l02227"></a>02227         <span class="keywordflow">else</span> {
<a name="l02228"></a>02228             stringstream ss;
<a name="l02229"></a>02229            <span class="comment">// ss &lt;&lt; "V";</span>
<a name="l02230"></a>02230            <span class="comment">// ss &lt;&lt; nvars;</span>
<a name="l02231"></a>02231             <a class="code" href="yicesParserLib_8h.html#e8f6d2fd6490d3153cb4133bf183a404">nvars</a>++;
<a name="l02232"></a>02232             ss &lt;&lt; svs.<a class="code" href="classSgName.html#f0b50e9570235a749205387bfa04cead">getString</a>();
<a name="l02233"></a>02233             ss &lt;&lt; <a class="code" href="yicesParserLib_8h.html#e8f6d2fd6490d3153cb4133bf183a404">nvars</a>;
<a name="l02234"></a>02234             <span class="keywordtype">char</span> valTypeCh[valType.size()];
<a name="l02235"></a>02235             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; valType.size(); k++) {
<a name="l02236"></a>02236                 valTypeCh[k] = valType[k];
<a name="l02237"></a>02237             }
<a name="l02238"></a>02238             <span class="keywordtype">char</span> nam[ss.str().size()];
<a name="l02239"></a>02239             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> q = 0; q &lt; ss.str().size(); q++) {
<a name="l02240"></a>02240                 nam[q] = ss.str()[q];
<a name="l02241"></a>02241             }
<a name="l02242"></a>02242             string fun = valType;
<a name="l02243"></a>02243             <span class="comment">//char* funC = fun.c_str();</span>
<a name="l02244"></a>02244             yices_type ty = yices_mk_type(ctx, (<span class="keywordtype">char</span>*) valType.c_str());
<a name="l02245"></a>02245             yices_var_decl decl1 = yices_mk_var_decl(ctx,(<span class="keywordtype">char</span>*) ss.str().c_str(), ty);
<a name="l02246"></a>02246             yices_expr e1 = yices_mk_var_from_decl(ctx, decl1);
<a name="l02247"></a>02247             yices_expr e2 = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(vec2, ctx);
<a name="l02248"></a>02248             <span class="comment">//if (forFlag) {</span>
<a name="l02249"></a>02249             <span class="comment">//    ret = yices_mk_eq(ctx, e1, e1);</span>
<a name="l02250"></a>02250            <span class="comment">// }</span>
<a name="l02251"></a>02251            <span class="comment">// else {</span>
<a name="l02252"></a>02252                 ret = yices_mk_eq(ctx, e1, e2);
<a name="l02253"></a>02253            <span class="comment">// }</span>
<a name="l02254"></a>02254             <a class="code" href="yicesParserLib_8h.html#3703af20b0be2697db1fcd0452dd9c6e">getExpr</a>[svs] = e2;
<a name="l02255"></a>02255             <a class="code" href="yicesParserLib_8h.html#d9c55e63216a3f4b4d8f344149a3646b">nameOf</a>[svs] = ss.str();<span class="comment">//svs.getString();//fun;</span>
<a name="l02256"></a>02256         }
<a name="l02257"></a>02257         <span class="comment">//yices_assert(ctx, ret);</span>
<a name="l02258"></a>02258         <span class="comment">//getExpr[svs] = e1;</span>
<a name="l02259"></a>02259         <span class="comment">//stringstream stst;</span>
<a name="l02260"></a>02260         <span class="comment">//noAssert = true;</span>
<a name="l02261"></a>02261         
<a name="l02262"></a>02262        <span class="comment">// stst &lt;&lt; "(let (" &lt;&lt; mainParse(vec1) &lt;&lt; " " &lt;&lt; mainParse(vec2) &lt;&lt; ") )";</span>
<a name="l02263"></a>02263         <span class="comment">//parsed = stst.str();</span>
<a name="l02264"></a>02264         <span class="keywordflow">return</span> ret;
<a name="l02265"></a>02265     }
<a name="l02266"></a>02266     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#d9c653991cea544c0ff54e0c59be2af0">isSgExprStatement</a>(expr[0]-&gt;get_SgNode())) {
<a name="l02267"></a>02267        
<a name="l02268"></a>02268         ROSE_ASSERT(<a class="code" href="Cxx__Grammar_8h.html#d9c653991cea544c0ff54e0c59be2af0">isSgExprStatement</a>(expr.back()-&gt;get_SgNode()));
<a name="l02269"></a>02269         std::vector&lt;SgGraphNode*&gt; nexpr;
<a name="l02270"></a>02270         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> q = 1; q &lt; expr.size()-1; q++) {
<a name="l02271"></a>02271             nexpr.push_back(expr[q]);
<a name="l02272"></a>02272        }
<a name="l02273"></a>02273         yices_expr y2 = <a class="code" href="yicesParserLib_8h.html#204b5f738c85f52e20596e500fc86591">mainParse</a>(nexpr, ctx);
<a name="l02274"></a>02274         <span class="keywordflow">return</span> y2;
<a name="l02275"></a>02275     }
<a name="l02276"></a>02276     <span class="keywordflow">else</span> {
<a name="l02277"></a>02277         <span class="comment">//cout &lt;&lt; "unknown type" &lt;&lt; endl;</span>
<a name="l02278"></a>02278         <span class="comment">//cout &lt;&lt; getGraphNodeType(expr[0]) &lt;&lt; std::endl;//cfg-&gt;toCFGNode(expr[0]).toString() &lt;&lt; std::endl;</span>
<a name="l02279"></a>02279         <span class="comment">//ROSE_ASSERT(false);</span>
<a name="l02280"></a>02280         <span class="comment">//ROSE_ASSERT(false);</span>
<a name="l02281"></a>02281         <a class="code" href="yicesParserLib_8h.html#ecc8aa7e3d5e014159a274d129d468f8">unknown_flag</a> = <span class="keyword">true</span>;
<a name="l02282"></a>02282         yices_expr y1 = yices_mk_fresh_bool_var(ctx);
<a name="l02283"></a>02283         <span class="keywordflow">return</span> y1;
<a name="l02284"></a>02284     }
<a name="l02285"></a>02285     <span class="comment">//std::cout &lt;&lt; "parsed: " &lt;&lt; parsed &lt;&lt; std::endl;</span>
<a name="l02286"></a>02286     <span class="keywordflow">return</span> ret;   
<a name="l02287"></a>02287 }
<a name="l02288"></a>02288 
<a name="l02289"></a><a class="code" href="yicesParserLib_8h.html#0e2b091991daad5711a33ca835ae753c">02289</a> string <a class="code" href="yicesParserLib_8h.html#0e2b091991daad5711a33ca835ae753c">isAtom</a>(<a class="code" href="classSgNode.html">SgNode</a>* n) {
<a name="l02290"></a>02290     <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#271740fb8df92ff5fc69f6bfd193794c">isSgIntVal</a>(n)) {
<a name="l02291"></a>02291         <span class="keywordflow">return</span> <span class="stringliteral">"int"</span>;
<a name="l02292"></a>02292     }
<a name="l02293"></a>02293     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#e48c1fcd1978f66ef4caae88edb0b0e1">isSgDoubleVal</a>(n)) {
<a name="l02294"></a>02294         <span class="keywordflow">return</span> <span class="stringliteral">"double"</span>;
<a name="l02295"></a>02295     }
<a name="l02296"></a>02296     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#7121dbcf3af72ced55f79082e708f74c">isSgFloatVal</a>(n)) {
<a name="l02297"></a>02297         <span class="keywordflow">return</span> <span class="stringliteral">"float"</span>;
<a name="l02298"></a>02298     }
<a name="l02299"></a>02299     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#37633f6c6e825dec951b2440e5958c8f">isSgShortVal</a>(n)) {
<a name="l02300"></a>02300         <span class="keywordflow">return</span> <span class="stringliteral">"short"</span>;
<a name="l02301"></a>02301     }
<a name="l02302"></a>02302     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#8d641a4dc877a64a34939bccd7206b3d">isSgLongIntVal</a>(n)) {
<a name="l02303"></a>02303         <span class="keywordflow">return</span> <span class="stringliteral">"long"</span>;
<a name="l02304"></a>02304     }
<a name="l02305"></a>02305     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#0de548d3fc05ea2d92a851a45adfbcd0">isSgLongLongIntVal</a>(n)) {
<a name="l02306"></a>02306         <span class="keywordflow">return</span> <span class="stringliteral">"long long int"</span>;
<a name="l02307"></a>02307     }
<a name="l02308"></a>02308     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#8d9aebaeef960636dc0ac8d9cb9a210c">isSgLongDoubleVal</a>(n)) {
<a name="l02309"></a>02309         <span class="keywordflow">return</span> <span class="stringliteral">"long double"</span>;
<a name="l02310"></a>02310     }
<a name="l02311"></a>02311     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#c4439e159a27201c54e285cf47109a2f">isSgBoolValExp</a>(n)) {
<a name="l02312"></a>02312         <span class="keywordflow">return</span> <span class="stringliteral">"bool"</span>;
<a name="l02313"></a>02313     }
<a name="l02314"></a>02314     <span class="keywordflow">return</span> <span class="stringliteral">""</span>;
<a name="l02315"></a>02315 }
<a name="l02316"></a>02316 
<a name="l02317"></a><a class="code" href="yicesParserLib_8h.html#57481b2c51b7924c3d3628c412ae7691">02317</a> <span class="keywordtype">bool</span> <a class="code" href="yicesParserLib_8h.html#57481b2c51b7924c3d3628c412ae7691">isLogicalSplit</a>(<a class="code" href="classSgNode.html">SgNode</a>* n) {
<a name="l02318"></a>02318     <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#8c9609cbe5ab164a482a53d6918a408f">isSgAndOp</a>(n) || <a class="code" href="Cxx__Grammar_8h.html#edbacbfbe271fd9e556eda9bc744023d">isSgOrOp</a>(n) || <a class="code" href="Cxx__Grammar_8h.html#bcd565659a602a4d3f12b563250e7107">isSgNotOp</a>(n)) {
<a name="l02319"></a>02319         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02320"></a>02320     }
<a name="l02321"></a>02321     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02322"></a>02322 }
<a name="l02323"></a>02323 
<a name="l02324"></a><a class="code" href="yicesParserLib_8h.html#3782c828710c259d81600813639f1752">02324</a> std::string <a class="code" href="yicesParserLib_8h.html#3782c828710c259d81600813639f1752">getLogicalSplit</a>(<a class="code" href="classSgNode.html">SgNode</a>* n) {
<a name="l02325"></a>02325     <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#8c9609cbe5ab164a482a53d6918a408f">isSgAndOp</a>(n)) {
<a name="l02326"></a>02326         <span class="keywordflow">return</span> <span class="stringliteral">"and"</span>;
<a name="l02327"></a>02327     }
<a name="l02328"></a>02328     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#edbacbfbe271fd9e556eda9bc744023d">isSgOrOp</a>(n)) {
<a name="l02329"></a>02329         <span class="keywordflow">return</span> <span class="stringliteral">"or"</span>;
<a name="l02330"></a>02330     }
<a name="l02331"></a>02331     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#bcd565659a602a4d3f12b563250e7107">isSgNotOp</a>(n)) {
<a name="l02332"></a>02332         <span class="keywordflow">return</span> <span class="stringliteral">"not"</span>;
<a name="l02333"></a>02333     }
<a name="l02334"></a>02334     <span class="keywordflow">else</span> {
<a name="l02335"></a>02335        <span class="comment">// cout &lt;&lt; "not a logicalSplit Operator" &lt;&lt; std::endl;</span>
<a name="l02336"></a>02336         ROSE_ASSERT(<span class="keyword">false</span>);
<a name="l02337"></a>02337     }
<a name="l02338"></a>02338 }
<a name="l02339"></a>02339 
<a name="l02340"></a><a class="code" href="yicesParserLib_8h.html#9919f7194d5f3918d5f0ed1620d80f98">02340</a> std::string <a class="code" href="yicesParserLib_8h.html#9919f7194d5f3918d5f0ed1620d80f98">getBinaryLogicOp</a>(<a class="code" href="classSgNode.html">SgNode</a>* n) {
<a name="l02341"></a>02341     std::string ss;
<a name="l02342"></a>02342     <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#2e65ff63f4059949ea0032f3e5110e50">isSgEqualityOp</a>(n)) {
<a name="l02343"></a>02343         ss = <span class="stringliteral">"="</span>;
<a name="l02344"></a>02344     }
<a name="l02345"></a>02345     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#8517a5e79b32bac27471b615084c633c">isSgLessThanOp</a>(n)) {
<a name="l02346"></a>02346         ss = <span class="stringliteral">"&lt;"</span>;
<a name="l02347"></a>02347     }
<a name="l02348"></a>02348     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#41beaeb1c44ff0649ab65d6e13ceaad3">isSgGreaterThanOp</a>(n)) {
<a name="l02349"></a>02349         ss = <span class="stringliteral">"&gt;"</span>;
<a name="l02350"></a>02350     }
<a name="l02351"></a>02351     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#a628b71381b0e81aff795012aecc15a9">isSgNotEqualOp</a>(n)) {
<a name="l02352"></a>02352        ss = <span class="stringliteral">"/="</span>;
<a name="l02353"></a>02353     }
<a name="l02354"></a>02354     <span class="keywordflow">else</span> {
<a name="l02355"></a>02355         <span class="comment">//std::cout &lt;&lt; "bad eqOp" &lt;&lt; std::endl;</span>
<a name="l02356"></a>02356         ROSE_ASSERT(<span class="keyword">false</span>);
<a name="l02357"></a>02357     }
<a name="l02358"></a>02358     <span class="keywordflow">return</span> ss;
<a name="l02359"></a>02359 }
<a name="l02360"></a>02360 
<a name="l02361"></a><a class="code" href="yicesParserLib_8h.html#829e1926858e10820b25e92ffc2757ac">02361</a> <span class="keywordtype">bool</span> <a class="code" href="yicesParserLib_8h.html#829e1926858e10820b25e92ffc2757ac">isBinaryLogicOp</a>(<a class="code" href="classSgNode.html">SgNode</a>* n) {
<a name="l02362"></a>02362     <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#2e65ff63f4059949ea0032f3e5110e50">isSgEqualityOp</a>(n) || <a class="code" href="Cxx__Grammar_8h.html#8517a5e79b32bac27471b615084c633c">isSgLessThanOp</a>(n) || <a class="code" href="Cxx__Grammar_8h.html#41beaeb1c44ff0649ab65d6e13ceaad3">isSgGreaterThanOp</a>(n) || <a class="code" href="Cxx__Grammar_8h.html#a628b71381b0e81aff795012aecc15a9">isSgNotEqualOp</a>(n)) {
<a name="l02363"></a>02363         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02364"></a>02364     }
<a name="l02365"></a>02365     <span class="keywordflow">else</span> {
<a name="l02366"></a>02366         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02367"></a>02367     }
<a name="l02368"></a>02368 }
<a name="l02369"></a>02369 
<a name="l02370"></a><a class="code" href="yicesParserLib_8h.html#f615c7424ab8ea00c1faefc1c0a1a6ec">02370</a> <span class="keywordtype">bool</span> <a class="code" href="yicesParserLib_8h.html#f615c7424ab8ea00c1faefc1c0a1a6ec">isBinaryOp</a>(<a class="code" href="classSgNode.html">SgNode</a>* n) {
<a name="l02371"></a>02371     <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#b1f9e573593c7c38b428cbb390c7c0c0">isSgAddOp</a>(n) || <a class="code" href="Cxx__Grammar_8h.html#4c55d6ad74ce7cd82ae01c101a32f586">isSgSubtractOp</a>(n) || <a class="code" href="Cxx__Grammar_8h.html#2b9b92ac03fc17238e7b6bd0e789d4eb">isSgMultiplyOp</a>(n) || <a class="code" href="Cxx__Grammar_8h.html#9c8591e088d5c0105e4b3dfbeb52ddbd">isSgDivideOp</a>(n)) {
<a name="l02372"></a>02372         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02373"></a>02373     }
<a name="l02374"></a>02374     <span class="keywordflow">else</span> {
<a name="l02375"></a>02375         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02376"></a>02376     }
<a name="l02377"></a>02377 }
<a name="l02378"></a>02378 
<a name="l02379"></a><a class="code" href="yicesParserLib_8h.html#a870bfe46596003d476a434c5a198835">02379</a> std::string <a class="code" href="yicesParserLib_8h.html#a870bfe46596003d476a434c5a198835">getBinaryOp</a>(<a class="code" href="classSgNode.html">SgNode</a>* n) {
<a name="l02380"></a>02380     std::string ss;
<a name="l02381"></a>02381     <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#b1f9e573593c7c38b428cbb390c7c0c0">isSgAddOp</a>(n)) {
<a name="l02382"></a>02382         ss = <span class="stringliteral">"+"</span>;
<a name="l02383"></a>02383     }
<a name="l02384"></a>02384     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#4c55d6ad74ce7cd82ae01c101a32f586">isSgSubtractOp</a>(n)) {
<a name="l02385"></a>02385         ss = <span class="stringliteral">"-"</span>;
<a name="l02386"></a>02386     }
<a name="l02387"></a>02387     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#2b9b92ac03fc17238e7b6bd0e789d4eb">isSgMultiplyOp</a>(n)) {
<a name="l02388"></a>02388         ss = <span class="stringliteral">"*"</span>;
<a name="l02389"></a>02389     }
<a name="l02390"></a>02390     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#9c8591e088d5c0105e4b3dfbeb52ddbd">isSgDivideOp</a>(n)) {
<a name="l02391"></a>02391         ss = <span class="stringliteral">"/"</span>;
<a name="l02392"></a>02392     }
<a name="l02393"></a>02393     <span class="keywordflow">else</span> {
<a name="l02394"></a>02394         <span class="comment">//std::cout &lt;&lt; "unknown op in getBinaryOp" &lt;&lt; std::endl;</span>
<a name="l02395"></a>02395         ROSE_ASSERT(<span class="keyword">false</span>);
<a name="l02396"></a>02396     }
<a name="l02397"></a>02397     <span class="keywordflow">return</span> ss;
<a name="l02398"></a>02398 }
<a name="l02399"></a>02399 
<a name="l02400"></a>02400 
<a name="l02401"></a>02401 <span class="comment">/*</span>
<a name="l02402"></a>02402 <span class="comment">int main(int argc, char *argv[]) {</span>
<a name="l02403"></a>02403 <span class="comment"></span>
<a name="l02404"></a>02404 <span class="comment">  struct timeval t1, t2;</span>
<a name="l02405"></a>02405 <span class="comment">  SgProject* proj = frontend(argc,argv);</span>
<a name="l02406"></a>02406 <span class="comment">  ROSE_ASSERT (proj != NULL);</span>
<a name="l02407"></a>02407 <span class="comment"></span>
<a name="l02408"></a>02408 <span class="comment">  SgFunctionDeclaration* mainDefDecl = SageInterface::findMain(proj);</span>
<a name="l02409"></a>02409 <span class="comment"></span>
<a name="l02410"></a>02410 <span class="comment">  SgFunctionDefinition* mainDef = mainDefDecl-&gt;get_definition();</span>
<a name="l02411"></a>02411 <span class="comment">   visitorTraversal* vis = new visitorTraversal();</span>
<a name="l02412"></a>02412 <span class="comment">    StaticCFG::CFG cfg(mainDef);</span>
<a name="l02413"></a>02413 <span class="comment">   //cfg.buildFullCFG();</span>
<a name="l02414"></a>02414 <span class="comment">    stringstream ss;</span>
<a name="l02415"></a>02415 <span class="comment">    string fileName= StringUtility::stripPathFromFileName(mainDef-&gt;get_file_info()-&gt;get_filenameString());</span>
<a name="l02416"></a>02416 <span class="comment">    string dotFileName1=fileName+"."+ mainDef-&gt;get_declaration()-&gt;get_name() +".dot";</span>
<a name="l02417"></a>02417 <span class="comment"></span>
<a name="l02418"></a>02418 <span class="comment">    cfgToDot(mainDef,dotFileName1);</span>
<a name="l02419"></a>02419 <span class="comment">    //cfg-&gt;buildFullCFG();</span>
<a name="l02420"></a>02420 <span class="comment">    SgIncidenceDirectedGraph* g = new SgIncidenceDirectedGraph();</span>
<a name="l02421"></a>02421 <span class="comment">    g = cfg.getGraph();</span>
<a name="l02422"></a>02422 <span class="comment">    myGraph* mg = new myGraph();</span>
<a name="l02423"></a>02423 <span class="comment">    mg = instantiateGraph(g, cfg);</span>
<a name="l02424"></a>02424 <span class="comment">    vis-&gt;tltnodes = 0;</span>
<a name="l02425"></a>02425 <span class="comment">    vis-&gt;paths = 0;</span>
<a name="l02426"></a>02426 <span class="comment">    ipaths = 0;</span>
<a name="l02427"></a>02427 <span class="comment">    vis-&gt;orig = mg;</span>
<a name="l02428"></a>02428 <span class="comment">    vis-&gt;g = g;</span>
<a name="l02429"></a>02429 <span class="comment">    //vis-&gt;firstPrepGraph(constcfg);</span>
<a name="l02430"></a>02430 <span class="comment">    //t1 = getCPUTime();</span>
<a name="l02431"></a>02431 <span class="comment">    vis-&gt;constructPathAnalyzer(mg, true);</span>
<a name="l02432"></a>02432 <span class="comment">    //t2 = getCPUTime();</span>
<a name="l02433"></a>02433 <span class="comment">    //std::cout &lt;&lt; "took: " &lt;&lt; timeDifference(t2, t1) &lt;&lt; std::endl;</span>
<a name="l02434"></a>02434 <span class="comment">    //cfg.clearNodesAndEdges();</span>
<a name="l02435"></a>02435 <span class="comment">    std::cout &lt;&lt; "finished" &lt;&lt; std::endl;</span>
<a name="l02436"></a>02436 <span class="comment">    std::cout &lt;&lt; "tltnodes: " &lt;&lt; vis-&gt;tltnodes &lt;&lt; " paths: " &lt;&lt; vis-&gt;paths &lt;&lt; " ipaths: " &lt;&lt; ipaths &lt;&lt;  std::endl;</span>
<a name="l02437"></a>02437 <span class="comment">    //delete vis;</span>
<a name="l02438"></a>02438 <span class="comment">    return 0;</span>
<a name="l02439"></a>02439 <span class="comment">}</span>
<a name="l02440"></a>02440 <span class="comment">*/</span>
<a name="l02441"></a>02441 
<a name="l02442"></a><a class="code" href="yicesParserLib_8h.html#868605d807d754f1e1d53bc0c54540ab">02442</a> <span class="keywordtype">int</span> <a class="code" href="yicesParserLib_8h.html#868605d807d754f1e1d53bc0c54540ab">yicesCheck</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {
<a name="l02443"></a>02443 <span class="comment">//int main(int argc, char *argv[]) {</span>
<a name="l02444"></a>02444   <a class="code" href="yicesParserLib_8h.html#ec58e468363518c3dd79045de7ae1fa7">FORLOOPS</a> = 10;
<a name="l02445"></a>02445   string y = <span class="stringliteral">"yices.txt"</span>;
<a name="l02446"></a>02446   yices_enable_log_file((<span class="keywordtype">char</span>*) y.c_str());
<a name="l02447"></a>02447   <a class="code" href="yicesParserLib_8h.html#4e86b11357a2d99aa38a756cbc07d085">qst</a> = 0;
<a name="l02448"></a>02448   string fileSaver = <span class="stringliteral">"saviorStuff"</span>;
<a name="l02449"></a>02449   <span class="comment">//ofstream fout;</span>
<a name="l02450"></a>02450   <span class="comment">//  fout.open(fileSaver.c_str(),ios::app);</span>
<a name="l02451"></a>02451 
<a name="l02452"></a>02452   <a class="code" href="classSgProject.html">SgProject</a>* proj = <a class="code" href="utility__functions_8h.html#48fd701ae63655987f71cf749dd996ed">frontend</a>(argc,argv);
<a name="l02453"></a>02453   ROSE_ASSERT (proj != NULL);
<a name="l02454"></a>02454 
<a name="l02455"></a>02455 <a class="code" href="classSgFunctionDefinition.html">SgFunctionDefinition</a>* mainDef = <a class="code" href="namespaceSageInterface.html#0c4e4490c4d20ef7f32dd2d6459c7548">SageInterface::findMain</a>(proj)-&gt;<a class="code" href="classSgFunctionDeclaration.html#1519d0c01ed1b542c06f151d42b5ea88">get_definition</a>();
<a name="l02456"></a>02456   Rose_STL_Container&lt;SgNode*&gt; functionDeclarationList = <a class="code" href="namespaceSageInterface.html#1123219ebb32a1140a1c10e73b97ca22">NodeQuery::querySubTree</a>(proj,<a class="code" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464f22b0b9c5b91b0cfb60c0c513b1ff036">V_SgFunctionDeclaration</a>);
<a name="l02457"></a>02457   Rose_STL_Container&lt;SgNode*&gt; functionDefinitionList = <a class="code" href="namespaceSageInterface.html#1123219ebb32a1140a1c10e73b97ca22">NodeQuery::querySubTree</a>(proj, <a class="code" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464cd3f4a3d1d26a02ba6fb479de53db81b">V_SgFunctionDefinition</a>);
<a name="l02458"></a>02458  <span class="comment">// std::cout &lt;&lt; "functionDeclarationList.size(): " &lt;&lt; functionDeclarationList.size() &lt;&lt; std::endl;</span>
<a name="l02459"></a>02459  <span class="comment">// std::cout &lt;&lt; "functionDefinitionList.size(): " &lt;&lt; functionDefinitionList.size() &lt;&lt; std::endl;</span>
<a name="l02460"></a>02460   <span class="comment">//ROSE_ASSERT(false);</span>
<a name="l02461"></a>02461   std::vector&lt;SgNode*&gt; funcs;
<a name="l02462"></a>02462   <span class="keywordflow">for</span> (Rose_STL_Container&lt;SgNode*&gt;::iterator i = functionDefinitionList.begin(); i != functionDefinitionList.end(); i++) {
<a name="l02463"></a>02463           <span class="keywordflow">if</span> (<a class="code" href="Cxx__Grammar_8h.html#5cf651a4651efb47c056d36981fa552b">isSgFunctionDefinition</a>(*i) != mainDef) {
<a name="l02464"></a>02464           <a class="code" href="classSgFunctionDefinition.html">SgFunctionDefinition</a>* fni = <a class="code" href="Cxx__Grammar_8h.html#5cf651a4651efb47c056d36981fa552b">isSgFunctionDefinition</a>(*i);
<a name="l02465"></a>02465           ROSE_ASSERT(fni != NULL);
<a name="l02466"></a>02466           <span class="comment">//ROSE_ASSERT(find(funcs.begin(), funcs.end(), fni) == funcs.end());</span>
<a name="l02467"></a>02467           funcs.push_back(fni);
<a name="l02468"></a>02468           }
<a name="l02469"></a>02469   }
<a name="l02470"></a>02470   <span class="comment">//std::cout &lt;&lt; "funcs.size(): " &lt;&lt; funcs.size() &lt;&lt; std::endl;</span>
<a name="l02471"></a>02471   <span class="comment">//ROSE_ASSERT(false);</span>
<a name="l02472"></a>02472     <span class="keywordtype">int</span> jj = 0;
<a name="l02473"></a>02473   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; funcs.size(); i++) {
<a name="l02474"></a>02474      <span class="comment">// if (funcs[i] != mainDef) {</span>
<a name="l02475"></a>02475       <a class="code" href="classvisitorTraversalFunc.html">visitorTraversalFunc</a>* visfunc = <span class="keyword">new</span> <a class="code" href="classvisitorTraversalFunc.html">visitorTraversalFunc</a>();
<a name="l02476"></a>02476       <span class="comment">//SgFunctionDeclaration* sfd = isSgFunctionDeclaration(funcs[i]);</span>
<a name="l02477"></a>02477       <a class="code" href="classSgFunctionDefinition.html">SgFunctionDefinition</a>* sfdd = <a class="code" href="Cxx__Grammar_8h.html#5cf651a4651efb47c056d36981fa552b">isSgFunctionDefinition</a>(funcs[i]);
<a name="l02478"></a>02478      <span class="comment">//}</span>
<a name="l02479"></a>02479 <span class="keywordtype">int</span> counter = i;
<a name="l02480"></a>02480    <a class="code" href="classSgFunctionDefinition.html">SgFunctionDefinition</a>* fnc = <a class="code" href="Cxx__Grammar_8h.html#5cf651a4651efb47c056d36981fa552b">isSgFunctionDefinition</a>(sfdd);
<a name="l02481"></a>02481    <span class="keywordflow">if</span> (fnc != NULL) {
<a name="l02482"></a>02482   stringstream ss;
<a name="l02483"></a>02483   <a class="code" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>* functionDeclaration = fnc-&gt;<a class="code" href="classSgFunctionDefinition.html#2600e57677fad5d8256e432179dad318">get_declaration</a>();
<a name="l02484"></a>02484 
<a name="l02485"></a>02485   string fileName= functionDeclaration-&gt;<a class="code" href="classSgFunctionDeclaration.html#2f8974b0e4100dd1e186c479478d589a">get_name</a>().<a class="code" href="classSgName.html#9b23e24aa639974f049ddf3f676c20a5">str</a>();<span class="comment">//StringUtility::stripPathFromFileName(mainDef-&gt;get_file_info()-&gt;get_filenameString());</span>
<a name="l02486"></a>02486     string dotFileName1;
<a name="l02487"></a>02487 ss &lt;&lt; fileName &lt;&lt; <span class="stringliteral">"."</span> &lt;&lt; counter &lt;&lt; <span class="stringliteral">".dot"</span>;
<a name="l02488"></a>02488     counter++;
<a name="l02489"></a>02489     dotFileName1 = ss.str();
<a name="l02490"></a>02490     <a class="code" href="classStaticCFG_1_1InterproceduralCFG.html">StaticCFG::InterproceduralCFG</a>* <a class="code" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a> = <span class="keyword">new</span> <a class="code" href="classStaticCFG_1_1InterproceduralCFG.html">StaticCFG::InterproceduralCFG</a>(fnc);
<a name="l02491"></a>02491     <a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g = <span class="keyword">new</span> <a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>();
<a name="l02492"></a>02492 <span class="comment">//     visitorTraversalFunc* vis = new visitorTraversalFunc();</span>
<a name="l02493"></a>02493     g = <a class="code" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>-&gt;<a class="code" href="classStaticCFG_1_1CFG.html#b2d05df408ec4a6a51f13092048078f7">getGraph</a>();
<a name="l02494"></a>02494     <a class="code" href="yicesParserLib_8h.html#03ae8d9960ef4d518b7f38a6e5e18a40">CFGforT</a>* mg = <span class="keyword">new</span> <a class="code" href="yicesParserLib_8h.html#03ae8d9960ef4d518b7f38a6e5e18a40">CFGforT</a>();
<a name="l02495"></a>02495     mg = <a class="code" href="SgGraphTemplate_8h.html#3ae05ef289ee22c3a76ab8bab9adc726">instantiateGraph</a>(g, *<a class="code" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>, fnc);
<a name="l02496"></a>02496     visfunc-&gt;tltnodes = 0;
<a name="l02497"></a>02497     <span class="comment">//visfunc-&gt;paths = 0;</span>
<a name="l02498"></a>02498     <span class="comment">//std::vector&lt;std::vector&lt;VertexID&gt; &gt; pt;</span>
<a name="l02499"></a>02499     <span class="comment">//visfunc-&gt;paths = pt;</span>
<a name="l02500"></a>02500     visfunc-&gt;orig = mg;
<a name="l02501"></a>02501     <span class="comment">//visfunc-&gt;cfg = cfg;</span>
<a name="l02502"></a>02502     <span class="comment">//visfunc-&gt;g = g;</span>
<a name="l02503"></a>02503     visfunc-&gt;constructPathAnalyzer(mg, <span class="keyword">true</span>, 0, 0, <span class="keyword">true</span>);
<a name="l02504"></a>02504     std::vector&lt;std::vector&lt;SgGraphNode*&gt; &gt; vp = visfunc-&gt;vpaths;
<a name="l02505"></a>02505     ROSE_ASSERT(sfdd != NULL);
<a name="l02506"></a>02506     <a class="code" href="yicesParserLib_8h.html#4856956a3abce81ef0edec0d2191cb0f">FuncPathMap</a>[sfdd] = vp;
<a name="l02507"></a>02507     <span class="comment">//std::cout &lt;&lt; "vp.size(): " &lt;&lt; vp.size() &lt;&lt; std::endl;</span>
<a name="l02508"></a>02508 
<a name="l02509"></a>02509 }
<a name="l02510"></a>02510 }
<a name="l02511"></a>02511 <span class="comment">/*</span>
<a name="l02512"></a>02512 <span class="comment">int jjf = 0;</span>
<a name="l02513"></a>02513 <span class="comment">std::vector&lt;SgGraphNode*&gt; paths;</span>
<a name="l02514"></a>02514 <span class="comment">paths.push_back(path);</span>
<a name="l02515"></a>02515 <span class="comment">std::vector&lt;SgNode*&gt; called;</span>
<a name="l02516"></a>02516 <span class="comment">    while (jjf != paths.size()) {</span>
<a name="l02517"></a>02517 <span class="comment">        std::cout &lt;&lt; "propagating" &lt;&lt; std::endl;</span>
<a name="l02518"></a>02518 <span class="comment">        path = paths[jjf];</span>
<a name="l02519"></a>02519 <span class="comment">        int jj = 0;</span>
<a name="l02520"></a>02520 <span class="comment">        while (jj != path.size()) {</span>
<a name="l02521"></a>02521 <span class="comment">            if (isSgFunctionCallExp(path[jj]-&gt;get_SgNode()) &amp;&amp; find(called.begin(), called.end(), path[jj]-&gt;get_SgNode()) == called.end()) {</span>
<a name="l02522"></a>02522 <span class="comment">                propagateFunctionCall(path, jj, jjf);</span>
<a name="l02523"></a>02523 <span class="comment">                called.push_back(path[jj]-&gt;get_SgNode());</span>
<a name="l02524"></a>02524 <span class="comment">               jjf = 0;</span>
<a name="l02525"></a>02525 <span class="comment">             //   noadd = true;</span>
<a name="l02526"></a>02526 <span class="comment">               jj = 0;</span>
<a name="l02527"></a>02527 <span class="comment">                break;</span>
<a name="l02528"></a>02528 <span class="comment">            }</span>
<a name="l02529"></a>02529 <span class="comment">            else {</span>
<a name="l02530"></a>02530 <span class="comment">                jj++;</span>
<a name="l02531"></a>02531 <span class="comment">            }</span>
<a name="l02532"></a>02532 <span class="comment">       }</span>
<a name="l02533"></a>02533 <span class="comment">       if (noadd) {</span>
<a name="l02534"></a>02534 <span class="comment">       noadd = false;</span>
<a name="l02535"></a>02535 <span class="comment">       }</span>
<a name="l02536"></a>02536 <span class="comment"></span>
<a name="l02537"></a>02537 <span class="comment">       else {</span>
<a name="l02538"></a>02538 <span class="comment">       jjf++;</span>
<a name="l02539"></a>02539 <span class="comment">       }</span>
<a name="l02540"></a>02540 <span class="comment">       }</span>
<a name="l02541"></a>02541 <span class="comment"></span>
<a name="l02542"></a>02542 <span class="comment">    std::cout &lt;&lt; "paths.size(): " &lt;&lt; paths.size() &lt;&lt; std::endl;</span>
<a name="l02543"></a>02543 <span class="comment">    //ROSE_ASSERT(false); </span>
<a name="l02544"></a>02544 <span class="comment">    pathnumber += paths.size();</span>
<a name="l02545"></a>02545 <span class="comment">    std::vector&lt;SgNode*&gt; ncalled;</span>
<a name="l02546"></a>02546 <span class="comment"></span>
<a name="l02547"></a>02547 <span class="comment">for (int q = 0; q &lt; paths.size(); q++) {  </span>
<a name="l02548"></a>02548 <span class="comment">  std::vector&lt;SgGraphNode*&gt; path = path[q]; </span>
<a name="l02549"></a>02549 <span class="comment">  ROSE_ASSERT(mainDef != NULL);</span>
<a name="l02550"></a>02550 <span class="comment">  //if (mainDefDecl != NULL) {</span>
<a name="l02551"></a>02551 <span class="comment">*/</span>
<a name="l02552"></a>02552   <span class="comment">//SgFunctionDefinition* mainDef = mainDefDecl-&gt;get_definition();</span>
<a name="l02553"></a>02553    <a class="code" href="classvisitorTraversal.html">visitorTraversal</a>* vis = <span class="keyword">new</span> <a class="code" href="classvisitorTraversal.html">visitorTraversal</a>();
<a name="l02554"></a>02554     <a class="code" href="classStaticCFG_1_1CFG.html">StaticCFG::CFG</a>* <a class="code" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a> = <span class="keyword">new</span> <a class="code" href="classStaticCFG_1_1CFG.html">StaticCFG::CFG</a>(mainDef);
<a name="l02555"></a>02555     vis-&gt;<a class="code" href="classvisitorTraversal.html#b20d536027de3f2189d6b30fae63e5a4">pathnumber</a> = 0;
<a name="l02556"></a>02556     stringstream ss;
<a name="l02557"></a>02557     string fileName= <a class="code" href="namespaceStringUtility.html#db65546e74b257e4e5639cb60b020f22">StringUtility::stripPathFromFileName</a>(mainDef-&gt;<a class="code" href="classSgLocatedNode.html#46fd45c95294254b9f430cb1e024d8b1">get_file_info</a>()-&gt;<a class="code" href="classSg__File__Info.html#842f3fb572b09600d1354683f103659c">get_filenameString</a>());
<a name="l02558"></a>02558     string dotFileName1=fileName+<span class="stringliteral">"."</span>+ mainDef-&gt;<a class="code" href="classSgFunctionDefinition.html#2600e57677fad5d8256e432179dad318">get_declaration</a>()-&gt;<a class="code" href="classSgFunctionDeclaration.html#2f8974b0e4100dd1e186c479478d589a">get_name</a>() +<span class="stringliteral">".dot"</span>;
<a name="l02559"></a>02559 
<a name="l02560"></a>02560     <a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>* g = <span class="keyword">new</span> <a class="code" href="classSgIncidenceDirectedGraph.html">SgIncidenceDirectedGraph</a>();
<a name="l02561"></a>02561     g = <a class="code" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>-&gt;<a class="code" href="classStaticCFG_1_1CFG.html#b2d05df408ec4a6a51f13092048078f7">getGraph</a>();
<a name="l02562"></a>02562     <a class="code" href="SgGraphTemplate_8h.html#66b50e592d5aefbd7d9950d9742731fe">myGraph</a>* mg = <span class="keyword">new</span> <a class="code" href="SgGraphTemplate_8h.html#66b50e592d5aefbd7d9950d9742731fe">myGraph</a>();
<a name="l02563"></a>02563     mg = <a class="code" href="SgGraphTemplate_8h.html#3ae05ef289ee22c3a76ab8bab9adc726">instantiateGraph</a>(g, *<a class="code" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>);
<a name="l02564"></a>02564     vis-&gt;<a class="code" href="classvisitorTraversal.html#499a600257d925244b7ff4baf0223a95">tltnodes</a> = 0;
<a name="l02565"></a>02565     <span class="comment">//vis-&gt;pathnumber = 0;</span>
<a name="l02566"></a>02566     <a class="code" href="yicesParserLib_8h.html#a1014aaa0c222827ec6431f1f6c2133d">ipaths</a> = 0;
<a name="l02567"></a>02567     vis-&gt;<a class="code" href="classvisitorTraversal.html#12e9d13c7871b33e4efa045c5fbf086f">orig</a> = mg;
<a name="l02568"></a>02568     <span class="comment">//openorig = mg;</span>
<a name="l02569"></a>02569     vis-&gt;<a class="code" href="classvisitorTraversal.html#0e51ac7d19a1f78d0b03e8ab0c1c4c90">g</a> = g;
<a name="l02570"></a>02570     <span class="comment">//openg = g;</span>
<a name="l02571"></a>02571     vis-&gt;<a class="code" href="classvisitorTraversal.html#8a91215f8d9119d2fd2b3d24a87a12f7">cfg</a> = <a class="code" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>;
<a name="l02572"></a>02572     <span class="comment">//opencfg = cfg;</span>
<a name="l02573"></a>02573 
<a name="l02574"></a>02574     vis-&gt;<a class="code" href="classSgGraphTraversal.html#112773609abc35a0bb7750e67d5752a7">constructPathAnalyzer</a>(mg, <span class="keyword">true</span>);
<a name="l02575"></a>02575     <span class="comment">//if (ipaths &gt; 0) {</span>
<a name="l02576"></a>02576     cout &lt;&lt; <span class="stringliteral">"filename: "</span> &lt;&lt; fileName &lt;&lt; std::endl;
<a name="l02577"></a>02577     cout &lt;&lt; <span class="stringliteral">"finished"</span> &lt;&lt; std::endl;
<a name="l02578"></a>02578     cout &lt;&lt; <span class="stringliteral">"paths: "</span> &lt;&lt; vis-&gt;<a class="code" href="classvisitorTraversal.html#b20d536027de3f2189d6b30fae63e5a4">pathnumber</a> &lt;&lt; <span class="stringliteral">" ipaths: "</span> &lt;&lt; <a class="code" href="yicesParserLib_8h.html#a1014aaa0c222827ec6431f1f6c2133d">ipaths</a> &lt;&lt;  std::endl;
<a name="l02579"></a>02579    <span class="comment">//} </span>
<a name="l02580"></a>02580    <span class="comment">// }</span>
<a name="l02581"></a>02581    <span class="comment">// fout.close();</span>
<a name="l02582"></a>02582     <span class="keywordflow">return</span> 0;
<a name="l02583"></a>02583 }
<a name="l02584"></a>02584 
<a name="l02585"></a>02585 
<a name="l02586"></a>02586 
<a name="l02587"></a>02587 <span class="comment">/*</span>
<a name="l02588"></a>02588 <span class="comment"></span>
<a name="l02589"></a>02589 <span class="comment">int main(int argc, char *argv[]) {</span>
<a name="l02590"></a>02590 <span class="comment">  pathnum = 0;</span>
<a name="l02591"></a>02591 <span class="comment">  ipaths = 0;</span>
<a name="l02592"></a>02592 <span class="comment">  SgProject* proj = frontend(argc,argv);</span>
<a name="l02593"></a>02593 <span class="comment">  ROSE_ASSERT (proj != NULL);</span>
<a name="l02594"></a>02594 <span class="comment"></span>
<a name="l02595"></a>02595 <span class="comment">  SgFunctionDeclaration* mainDefDecl = SageInterface::findMain(proj);</span>
<a name="l02596"></a>02596 <span class="comment"></span>
<a name="l02597"></a>02597 <span class="comment">  SgFunctionDefinition* mainDef = mainDefDecl-&gt;get_definition();</span>
<a name="l02598"></a>02598 <span class="comment">   visitorTraversal* vis = new visitorTraversal();</span>
<a name="l02599"></a>02599 <span class="comment">   visitorTraversal* vis2 = new visitorTraversal();</span>
<a name="l02600"></a>02600 <span class="comment">   nGraph = new newGraph();</span>
<a name="l02601"></a>02601 <span class="comment">   //vis-&gt;nGraph = nGraph;</span>
<a name="l02602"></a>02602 <span class="comment">   //newGraph* nnGraph = new newGraph();</span>
<a name="l02603"></a>02603 <span class="comment">    StaticCFG::CFG* cfg1 = new StaticCFG::CFG(mainDef);</span>
<a name="l02604"></a>02604 <span class="comment">   //cfg.buildFullCFG();</span>
<a name="l02605"></a>02605 <span class="comment">    stringstream ss;</span>
<a name="l02606"></a>02606 <span class="comment">    string fileName= StringUtility::stripPathFromFileName(mainDef-&gt;get_file_info()-&gt;get_filenameString());</span>
<a name="l02607"></a>02607 <span class="comment">    string dotFileName1=fileName+"."+ mainDef-&gt;get_declaration()-&gt;get_name() +".dot";</span>
<a name="l02608"></a>02608 <span class="comment"></span>
<a name="l02609"></a>02609 <span class="comment">    cfgToDot(mainDef,dotFileName1);</span>
<a name="l02610"></a>02610 <span class="comment">    //cfg-&gt;buildFullCFG();</span>
<a name="l02611"></a>02611 <span class="comment">    //SgIncidenceDirectedGraph* cf = new SgIncidenceDirectedGraph();</span>
<a name="l02612"></a>02612 <span class="comment">    SgIncidenceDirectedGraph* cf = cfg1-&gt;getGraph();</span>
<a name="l02613"></a>02613 <span class="comment">    myGraph* mg = new myGraph();</span>
<a name="l02614"></a>02614 <span class="comment">    mg = instantiateGraph(cf, *cfg1);</span>
<a name="l02615"></a>02615 <span class="comment">    vis2-&gt;tltnodes = 0;</span>
<a name="l02616"></a>02616 <span class="comment">    vis2-&gt;paths = 0;</span>
<a name="l02617"></a>02617 <span class="comment">    vis-&gt;tltnodes = 0;</span>
<a name="l02618"></a>02618 <span class="comment">    vis-&gt;paths = 0;</span>
<a name="l02619"></a>02619 <span class="comment">    //vis-&gt;firstPrepGraph(constcfg);</span>
<a name="l02620"></a>02620 <span class="comment">    vis-&gt;g = cf;</span>
<a name="l02621"></a>02621 <span class="comment">    vis2-&gt;g = cf;</span>
<a name="l02622"></a>02622 <span class="comment">    vis2-&gt;orig = mg;</span>
<a name="l02623"></a>02623 <span class="comment">    cfg = cfg1;</span>
<a name="l02624"></a>02624 <span class="comment">    vis-&gt;orig = mg;</span>
<a name="l02625"></a>02625 <span class="comment">    vis-&gt;constructPathAnalyzer(mg, true);</span>
<a name="l02626"></a>02626 <span class="comment">    std::cout &lt;&lt; "constructed" &lt;&lt; std::endl;</span>
<a name="l02627"></a>02627 <span class="comment">    std::cout &lt;&lt; "ipaths: " &lt;&lt; ipaths &lt;&lt; std::endl; </span>
<a name="l02628"></a>02628 <span class="comment">   // printHotness2(nGraph);</span>
<a name="l02629"></a>02629 <span class="comment">   // std::cout &lt;&lt; "mapped" &lt;&lt; std::endl;i</span>
<a name="l02630"></a>02630 <span class="comment">   std::vector&lt;std::vector&lt;int&gt; &gt; pts;</span>
<a name="l02631"></a>02631 <span class="comment">   std::vector&lt;int&gt; ptsP;</span>
<a name="l02632"></a>02632 <span class="comment">    //std::vector&lt;SgExpressionStmt*&gt; exprs = SageInterface::querySubTree&lt;SgExpressionStmt&gt;(proj);</span>
<a name="l02633"></a>02633 <span class="comment">/*  </span>
<a name="l02634"></a>02634 <span class="comment"> for (int q1 = 0; q1 &lt; exprs.size(); q1++) {</span>
<a name="l02635"></a>02635 <span class="comment">      ptsP.clear();</span>
<a name="l02636"></a>02636 <span class="comment">      for (int q2 = 0; q2 &lt; exprs.size(); q2++) {</span>
<a name="l02637"></a>02637 <span class="comment">          if (q1 != q2) {</span>
<a name="l02638"></a>02638 <span class="comment">              vis-&gt;paths = 0;</span>
<a name="l02639"></a>02639 <span class="comment">              vis-&gt;tltnodes = 0;</span>
<a name="l02640"></a>02640 <span class="comment">              vis-&gt;constructPathAnalyzer(mg, exprs[q1], exprs[q2]);</span>
<a name="l02641"></a>02641 <span class="comment">              std::cout &lt;&lt; vis-&gt;paths &lt;&lt; " between expr" &lt;&lt; q1 &lt;&lt; " and expr" &lt;&lt; q2 &lt;&lt; std::endl;</span>
<a name="l02642"></a>02642 <span class="comment">              ptsP.push_back(vis-&gt;paths);</span>
<a name="l02643"></a>02643 <span class="comment">          }</span>
<a name="l02644"></a>02644 <span class="comment">          pts.push_back(ptsP);</span>
<a name="l02645"></a>02645 <span class="comment">      }</span>
<a name="l02646"></a>02646 <span class="comment">    }</span>
<a name="l02647"></a>02647 <span class="comment">    for (int i = 0; i &lt; pts.size(); i++) {</span>
<a name="l02648"></a>02648 <span class="comment">        for (int j = 0; j &lt; pts[i].size(); j++) {</span>
<a name="l02649"></a>02649 <span class="comment">            std::cout &lt;&lt; "between expr" &lt;&lt; i &lt;&lt; "and expr" &lt;&lt; j &lt;&lt; " there are " &lt;&lt; pts[i][j] &lt;&lt; std::endl;</span>
<a name="l02650"></a>02650 <span class="comment">        }</span>
<a name="l02651"></a>02651 <span class="comment">    }</span>
<a name="l02652"></a>02652 <span class="comment">*/</span>
<a name="l02653"></a>02653     <span class="comment">//cfg.clearNodesAndEdges();</span>
<a name="l02654"></a>02654     <span class="comment">//std::cout &lt;&lt; "finished" &lt;&lt; std::endl;</span>
<a name="l02655"></a>02655     <span class="comment">//std::cout &lt;&lt; "tltnodes: " &lt;&lt; vis-&gt;tltnodes &lt;&lt; " paths: " &lt;&lt; vis-&gt;paths &lt;&lt; std::endl;</span>
<a name="l02656"></a>02656     <span class="comment">//delete vis;</span>
<a name="l02657"></a>02657 <span class="comment">//}</span>
<a name="l02658"></a>02658                                                                                                                                                                                                                                                                                                                                                                                                                                                             
<a name="l02659"></a>02659 
<a name="l02660"></a>02660 <span class="comment">/*</span>
<a name="l02661"></a>02661 <span class="comment">std::vector&lt;SgExprStatement*&gt; exprList = SageInterface::querySubTree&lt;SgExprStatement&gt;(project);</span>
<a name="l02662"></a>02662 <span class="comment">for (Rose_STL_Container&lt;SgGraphNode*&gt;::iterator i = exprList.begin(); i != exprList.end(); i++) {</span>
<a name="l02663"></a>02663 <span class="comment">*/</span>
<a name="l02664"></a>02664 
<a name="l02665"></a>02665 <span class="comment">//          SgExprStatement* expr = isSgExprStatement(*i);</span>
<a name="l02666"></a>02666 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
