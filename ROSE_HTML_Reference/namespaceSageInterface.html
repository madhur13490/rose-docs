<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: SageInterface Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li id="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="namespaces.html"><span>Namespace List</span></a></li>
    <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
  </ul></div>
<h1>SageInterface Namespace Reference</h1>
<p>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSageInterface_1_1UniqueNameAttribute.html">UniqueNameAttribute</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A persistent attribute to represent a unique name for an expression.  <a href="classSageInterface_1_1UniqueNameAttribute.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSageInterface_1_1hash__nodeptr.html">hash_nodeptr</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSageInterface_1_1OutputLocalSymbolTables.html">OutputLocalSymbolTables</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSageInterface_1_1StatementGenerator.html">StatementGenerator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface for creating a statement whose computation writes its answer into a given variable.  <a href="classSageInterface_1_1StatementGenerator.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Symbol tables</h2></td></tr>
<tr><td colspan="2">utility functions for symbol tables <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#10bd491911b4d8d441c2b0f8d8542f50">lookupVariableSymbolInParentScopes</a> (const <a class="el" href="classSgName.html">SgName</a> &amp;name, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgSymbol.html">SgSymbol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#fbbf691f4ff947b83e93db1e9622a5a3">lookupSymbolInParentScopes</a> (const <a class="el" href="classSgName.html">SgName</a> &amp;name, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a symbol in current and ancestor scopes for a given variable name, starting from top of ScopeStack if currentscope is not given or NULL.  <a href="#fbbf691f4ff947b83e93db1e9622a5a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgFunctionSymbol.html">SgFunctionSymbol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c149a8d976bc90e89fed4d9d6cd3f34a">lookupFunctionSymbolInParentScopes</a> (const <a class="el" href="classSgName.html">SgName</a> &amp;functionName, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">look up the first matched function symbol in parent scopes given only a function name, starting from top of ScopeStack if currentscope is not given or NULL  <a href="#c149a8d976bc90e89fed4d9d6cd3f34a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgFunctionSymbol.html">SgFunctionSymbol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#6e0623b84a44ff5e85dd6334e199f418">lookupFunctionSymbolInParentScopes</a> (const <a class="el" href="classSgName.html">SgName</a> &amp;functionName, const <a class="el" href="classSgType.html">SgType</a> *t, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">look up function symbol in parent scopes given both name and function type, starting from top of ScopeStack if currentscope is not given or NULL  <a href="#6e0623b84a44ff5e85dd6334e199f418"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgClassSymbol.html">SgClassSymbol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4d0c71bada31301e6bd1a569965cdad6">lookupClassSymbolInParentScopes</a> (const <a class="el" href="classSgName.html">SgName</a> &amp;name, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgTypedefSymbol.html">SgTypedefSymbol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#f2272608021e9538be091a4f23ecfc6b">lookupTypedefSymbolInParentScopes</a> (const <a class="el" href="classSgName.html">SgName</a> &amp;name, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgTemplateSymbol.html">SgTemplateSymbol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#15bf8b9e0d05ab2441dfab12f4e0b8af">lookupTemplateSymbolInParentScopes</a> (const <a class="el" href="classSgName.html">SgName</a> &amp;name, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgEnumSymbol.html">SgEnumSymbol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c5944800817c61bf404f7948d0e9431c">lookupEnumSymbolInParentScopes</a> (const <a class="el" href="classSgName.html">SgName</a> &amp;name, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgNamespaceSymbol.html">SgNamespaceSymbol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#9f057986db266f3d6cc83fd8edbab917">lookupNamespaceSymbolInParentScopes</a> (const <a class="el" href="classSgName.html">SgName</a> &amp;name, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *currentScope=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#1bbf335d0e6ee069e94e73a62660b8da">set_name</a> (<a class="el" href="classSgInitializedName.html">SgInitializedName</a> *initializedNameNode, <a class="el" href="classSgName.html">SgName</a> new_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set_name of symbol in symbol table.  <a href="#1bbf335d0e6ee069e94e73a62660b8da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a3fbb86d0df5900f41a2b63a81b4355e">outputGlobalFunctionTypeSymbolTable</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output function type symbols in global function type symbol table.  <a href="#a3fbb86d0df5900f41a2b63a81b4355e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ab1b30cc17b041079ccd395c0f48d9a4">outputLocalSymbolTables</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output the local symbol tables.  <a href="#ab1b30cc17b041079ccd395c0f48d9a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#f77c4adbf8e70c2904f5c95f80aa32b4">rebuildSymbolTable</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Regenerate the symbol table.  <a href="#f77c4adbf8e70c2904f5c95f80aa32b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#72448c95af84d803ee677e49650cec12">clearUnusedVariableSymbols</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear those variable symbols (together with initialized names) which are not referenced by any variable references or declarations.  <a href="#72448c95af84d803ee677e49650cec12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#8dd3faa8aa1e1a39859ed2f4046db4c2">fixupReferencesToSymbols</a> (const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *this_scope, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *copy_scope, <a class="el" href="classSgCopyHelp.html">SgCopyHelp</a> &amp;help)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All the symbol table references in the copied AST need to be reset after rebuilding the copied scope's symbol table.  <a href="#8dd3faa8aa1e1a39859ed2f4046db4c2"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Stringify</h2></td></tr>
<tr><td colspan="2">Generate a useful string (name) to describe a <a class="el" href="classSgNode.html">SgNode</a> <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d8c38176c2d0e4d2bc851e70007902f9">get_name</a> (const <a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a useful name to describe the <a class="el" href="classSgNode.html">SgNode</a>.  <a href="#d8c38176c2d0e4d2bc851e70007902f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#fcdc4bf692f0a99cf6c9f8dedd5dba0c">get_name</a> (const <a class="el" href="classSgStatement.html">SgStatement</a> *stmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a useful name to describe the declaration.  <a href="#fcdc4bf692f0a99cf6c9f8dedd5dba0c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e041006d7194c3dcf1771905a310551f">get_name</a> (const <a class="el" href="classSgExpression.html">SgExpression</a> *expr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a useful name to describe the expression.  <a href="#e041006d7194c3dcf1771905a310551f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4a139b6ee7628669382055c4e5cc4091">get_name</a> (const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *declaration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a useful name to describe the declaration.  <a href="#4a139b6ee7628669382055c4e5cc4091"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#94a6b6ad81a1b4fe641ba34a6fa287fb">get_name</a> (const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a useful name to describe the scope.  <a href="#94a6b6ad81a1b4fe641ba34a6fa287fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#215e9d46d141268e3b4841b6a4d105a1">get_name</a> (const <a class="el" href="classSgSymbol.html">SgSymbol</a> *symbol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a useful name to describe the <a class="el" href="classSgSymbol.html">SgSymbol</a>.  <a href="#215e9d46d141268e3b4841b6a4d105a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a3dbafd1030e3d2995e938b98c9e8a34">get_name</a> (const <a class="el" href="classSgType.html">SgType</a> *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a useful name to describe the <a class="el" href="classSgType.html">SgType</a>.  <a href="#a3dbafd1030e3d2995e938b98c9e8a34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e5abb9bb7920c00cd4331354fc470049">get_name</a> (const <a class="el" href="classSgSupport.html">SgSupport</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a useful name to describe the <a class="el" href="classSgSupport.html">SgSupport</a> IR node.  <a href="#e5abb9bb7920c00cd4331354fc470049"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#1fb6f2b9749473b0efcbb19bfd8d019b">get_name</a> (const <a class="el" href="classSgLocatedNodeSupport.html">SgLocatedNodeSupport</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a useful name to describe the <a class="el" href="classSgLocatedNodeSupport.html">SgLocatedNodeSupport</a> IR node.  <a href="#1fb6f2b9749473b0efcbb19bfd8d019b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#571cc2dc63fcd697dcab3e43feb87dc2">get_name</a> (const <a class="el" href="classSgC__PreprocessorDirectiveStatement.html">SgC_PreprocessorDirectiveStatement</a> *directive)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a useful name to describe the <a class="el" href="classSgC__PreprocessorDirectiveStatement.html">SgC_PreprocessorDirectiveStatement</a> IR node.  <a href="#571cc2dc63fcd697dcab3e43feb87dc2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e80c3edde132b58538fe96a143a2f83d">get_name</a> (const <a class="el" href="classSgToken.html">SgToken</a> *token)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a useful name to describe the <a class="el" href="classSgToken.html">SgToken</a> IR node.  <a href="#e80c3edde132b58538fe96a143a2f83d"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Class utilities</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgMemberFunctionDeclaration.html">SgMemberFunctionDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b5161d0357f41bada1b0528284efc66e">getDefaultDestructor</a> (<a class="el" href="classSgClassDeclaration.html">SgClassDeclaration</a> *classDeclaration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the default destructor from the class declaration.  <a href="#b5161d0357f41bada1b0528284efc66e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgMemberFunctionDeclaration.html">SgMemberFunctionDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#44d0f9a4a27a11112c175c114165c5bc">getDefaultConstructor</a> (<a class="el" href="classSgClassDeclaration.html">SgClassDeclaration</a> *classDeclaration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the default constructor from the class declaration.  <a href="#44d0f9a4a27a11112c175c114165c5bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d800514689507e16297989c211bd1d46">templateDefinitionIsInClass</a> (<a class="el" href="classSgTemplateInstantiationMemberFunctionDecl.html">SgTemplateInstantiationMemberFunctionDecl</a> *memberFunctionDeclaration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if template definition is in the class, false if outside of class.  <a href="#d800514689507e16297989c211bd1d46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgTemplateInstantiationMemberFunctionDecl.html">SgTemplateInstantiationMemberFunctionDecl</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#05cf8a0be6e549502d66723997d7a1d6">buildForwardFunctionDeclaration</a> (<a class="el" href="classSgTemplateInstantiationMemberFunctionDecl.html">SgTemplateInstantiationMemberFunctionDecl</a> *memberFunctionInstantiation)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a non-defining (forward) declaration from a defining function declaration.  <a href="#05cf8a0be6e549502d66723997d7a1d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#2bd323ff608813e595cf631ec1f6c620">isStructDeclaration</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a <a class="el" href="classSgNode.html">SgNode</a> is a declaration for a structure.  <a href="#2bd323ff608813e595cf631ec1f6c620"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Misc.</h2></td></tr>
<tr><td colspan="2">Not sure the classifications right now <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#9cfd9f42a896937c833851eeba3b1228">extractPragmaKeyword</a> (const <a class="el" href="classSgPragmaDeclaration.html">SgPragmaDeclaration</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp".  <a href="#9cfd9f42a896937c833851eeba3b1228"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#cd2e56dc7614b724718c8c8bbd75f5d1">isOmpStatement</a> (<a class="el" href="classSgNode.html">SgNode</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a node is SgOmp*Statement.  <a href="#cd2e56dc7614b724718c8c8bbd75f5d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#1a75ef1b6fc0708f3a2791d5198bdf19">isOverloaded</a> (<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *functionDeclaration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if function is overloaded.  <a href="#1a75ef1b6fc0708f3a2791d5198bdf19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#041d0ad3164d050320ad7181d0aacd64">annotateExpressionsWithUniqueNames</a> (<a class="el" href="classSgProject.html">SgProject</a> *<a class="el" href="namespacecfgUtils.html#ce4abf2beca5826144d69d3a0283050f">project</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate unique names for expressions and attach the names as persistent attributes ("UniqueNameAttribute").  <a href="#041d0ad3164d050320ad7181d0aacd64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4d55ef6edf8eebf6577aca1e1fe0de6e">isMain</a> (const <a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a <a class="el" href="classSgNode.html">SgNode</a> is a main() function declaration.  <a href="#4d55ef6edf8eebf6577aca1e1fe0de6e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c088828a4143b77fa9e3b11ba6b40a0e">generateUniqueName</a> (const <a class="el" href="classSgNode.html">SgNode</a> *node, bool ignoreDifferenceBetweenDefiningAndNondefiningDeclarations)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate unique name from C and C++ constructs. The name may contain space.  <a href="#c088828a4143b77fa9e3b11ba6b40a0e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#6401801005892a56b2f337d0ce501eb7">generateUniqueVariableName</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope, std::string baseName=&quot;temp&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a name that is unique in the current scope and any parent and children scopes.  <a href="#6401801005892a56b2f337d0ce501eb7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#322a03f1d6ed3713ed72abcedeb8a51d">declarationPositionString</a> (const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *declaration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a unique string from the source file position information.  <a href="#322a03f1d6ed3713ed72abcedeb8a51d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#90ebac1577ef2a31448937b60c3c09d1">generateProjectName</a> (const <a class="el" href="classSgProject.html">SgProject</a> *<a class="el" href="namespacecfgUtils.html#ce4abf2beca5826144d69d3a0283050f">project</a>, bool supressSuffix=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Added mechanism to generate project name from list of file names.  <a href="#90ebac1577ef2a31448937b60c3c09d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#92c54986b591707f089705085a7b962e">getDeclarationOfNamedFunction</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *func)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a <a class="el" href="classSgExpression.html">SgExpression</a> that represents a named function (or bound member function), return the mentioned function.  <a href="#92c54986b591707f089705085a7b962e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ba53ce71d9c07fc4912d08bfa14aa6c0">forallMaskExpression</a> (<a class="el" href="classSgForAllStatement.html">SgForAllStatement</a> *stmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the mask expression from the header of a <a class="el" href="classSgForAllStatement.html">SgForAllStatement</a>.  <a href="#ba53ce71d9c07fc4912d08bfa14aa6c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#bebf0874533c9176d3dbe203c110d2b6">addVarRefExpFromArrayDimInfo</a> (<a class="el" href="classSgNode.html">SgNode</a> *astNode, Rose_STL_Container&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt; &amp;NodeList_t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find all <a class="el" href="classSgPntrArrRefExp.html">SgPntrArrRefExp</a> under astNode, then add <a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> (if any) of SgPntrArrRefExp's dim_info into NodeList_t.  <a href="#bebf0874533c9176d3dbe203c110d2b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#2e2c09133334d2db043980411ad65a7c">clearMangledNameCache</a> (<a class="el" href="classSgGlobal.html">SgGlobal</a> *globalScope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Support for faster mangled name generation (caching avoids recomputation).  <a href="#2e2c09133334d2db043980411ad65a7c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#939718eb45951e2200eeb23bc903ee40">resetMangledNameCache</a> (<a class="el" href="classSgGlobal.html">SgGlobal</a> *globalScope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp".  <a href="#939718eb45951e2200eeb23bc903ee40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#fec2eead58f0854713f92c73989787ea">getMangledNameFromCache</a> (<a class="el" href="classSgNode.html">SgNode</a> *astNode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp".  <a href="#fec2eead58f0854713f92c73989787ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#cd868f709a4ba10cc7e5367b51033e21">addMangledNameToCache</a> (<a class="el" href="classSgNode.html">SgNode</a> *astNode, const std::string &amp;mangledName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp".  <a href="#cd868f709a4ba10cc7e5367b51033e21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ea729c0291d71f4b0f34192c4e42f974">getNonInstantiatonDeclarationForClass</a> (<a class="el" href="classSgTemplateInstantiationMemberFunctionDecl.html">SgTemplateInstantiationMemberFunctionDecl</a> *memberFunctionInstantiation)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp".  <a href="#ea729c0291d71f4b0f34192c4e42f974"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#f7e85358ccd85bb87b78259de8f4d549">setBaseTypeDefiningDeclaration</a> (<a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *var_decl, <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *base_decl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a better version for SgVariableDeclaration::set_baseTypeDefininingDeclaration(), handling all side effects automatically Used to have a struct declaration embedded into a variable declaration  <a href="#f7e85358ccd85bb87b78259de8f4d549"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#2ad11c9bbccfc5c65ebd5a1e63df8457">declarationPreceedsDefinition</a> (<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *nonDefiningDeclaration, <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *definingDeclaration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a defining declaration comes before of after the non-defining declaration.  <a href="#2ad11c9bbccfc5c65ebd5a1e63df8457"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a7b0761edf91357c7d6b1820f18f95d0">functionCallExpressionPreceedsDeclarationWhichAssociatesScope</a> (<a class="el" href="classSgFunctionCallExp.html">SgFunctionCallExp</a> *functionCall)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp".  <a href="#a7b0761edf91357c7d6b1820f18f95d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#771883836d967b53906ffba1966f6f2c">astIntersection</a> (<a class="el" href="classSgNode.html">SgNode</a> *original, <a class="el" href="classSgNode.html">SgNode</a> *copy, <a class="el" href="classSgCopyHelp.html">SgCopyHelp</a> *help=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the intersection set for two ASTs.  <a href="#771883836d967b53906ffba1966f6f2c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#9fcc4b40da8ae6daa5f50df366350861">deepCopyNode</a> (const <a class="el" href="classSgNode.html">SgNode</a> *subtree)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deep copy an arbitrary subtree.  <a href="#9fcc4b40da8ae6daa5f50df366350861"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename NodeType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">NodeType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#3a89292adcceeeda5391c5f67857251d">deepCopy</a> (const NodeType *subtree)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A template function for deep copying a subtree. It is also used to create deepcopy functions with specialized parameter and return types. e.g SgExpression* <a class="el" href="namespaceSageInterface.html#b716e78a9af76b8ace53782ce98938f8">copyExpression(SgExpression* e)</a>;.  <a href="#3a89292adcceeeda5391c5f67857251d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b716e78a9af76b8ace53782ce98938f8">copyExpression</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deep copy an expression.  <a href="#b716e78a9af76b8ace53782ce98938f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ccb4140d5bad66ff517c5171a8e23790">copyStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deep copy a statement.  <a href="#ccb4140d5bad66ff517c5171a8e23790"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#2e4a80143b2c610c87c8ec6c8ae1a4f6">getFirstVarSym</a> (<a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *decl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the variable symbol for the first initialized name of a declaration stmt.  <a href="#2e4a80143b2c610c87c8ec6c8ae1a4f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgInitializedName.html">SgInitializedName</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#13d0ecca52ba48d86e137017800ace85">getFirstInitializedName</a> (<a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *decl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the first initialized name of a declaration statement.  <a href="#13d0ecca52ba48d86e137017800ace85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#f2a313ede41c7b731cb61c355d1c55e0">myRemoveStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A special purpose statement removal function, originally from inlinerSupport.h, Need Jeremiah's attention to refine it. Please don't use it for now.  <a href="#f2a313ede41c7b731cb61c355d1c55e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#8b764061b63990cb9a90a2e8fba1cd9e">isConstantTrue</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp".  <a href="#8b764061b63990cb9a90a2e8fba1cd9e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#aabc058b0a469b383db6dae596659b1e">isConstantFalse</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp".  <a href="#aabc058b0a469b383db6dae596659b1e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#eb16538d6d56b5b2ef2960c7f8c1ed9c">isCallToParticularFunction</a> (<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *decl, <a class="el" href="classSgExpression.html">SgExpression</a> *e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp".  <a href="#eb16538d6d56b5b2ef2960c7f8c1ed9c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#6fc323c375048618a3713f4f02d9d0fb">isCallToParticularFunction</a> (const std::string &amp;qualifiedName, size_t arity, <a class="el" href="classSgExpression.html">SgExpression</a> *e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp".  <a href="#6fc323c375048618a3713f4f02d9d0fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#345dac5d75b2039d24e0a4f9820d7b7c">isStatic</a> (<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *stmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a declaration has a "static' modifier.  <a href="#345dac5d75b2039d24e0a4f9820d7b7c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#7133b3ef7857297f8fe4cbbdc0757259">setStatic</a> (<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *stmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a declaration as static.  <a href="#7133b3ef7857297f8fe4cbbdc0757259"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#9ccb65716fdfa5b17abb793584b76a40">isExtern</a> (<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *stmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a declaration has an "extern" modifier.  <a href="#9ccb65716fdfa5b17abb793584b76a40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#5a4e98c40873b96844edc32c7b2604e7">setExtern</a> (<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *stmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a declaration as extern.  <a href="#5a4e98c40873b96844edc32c7b2604e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#746a92a94fcc6190e015e74aa1c911e8">isAssignmentStatement</a> (<a class="el" href="classSgNode.html">SgNode</a> *_s, <a class="el" href="classSgExpression.html">SgExpression</a> **lhs=NULL, <a class="el" href="classSgExpression.html">SgExpression</a> **rhs=NULL, bool *readlhs=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a <a class="el" href="classSgNode.html">SgNode</a> _s is an assignment statement (any of =,+=,-=,&amp;=,/=, ^=, etc).  <a href="#746a92a94fcc6190e015e74aa1c911e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgInitializedName.html">SgInitializedName</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#549a580089fff36d4184a4341cc08525">convertRefToInitializedName</a> (<a class="el" href="classSgNode.html">SgNode</a> *current)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classVariable.html">Variable</a> references can be introduced by SgVarRef, <a class="el" href="classSgPntrArrRefExp.html">SgPntrArrRefExp</a>, <a class="el" href="classSgInitializedName.html">SgInitializedName</a>, SgMemberFunctionRef etc. This function will convert them all to a top level <a class="el" href="classSgInitializedName.html">SgInitializedName</a>.  <a href="#549a580089fff36d4184a4341cc08525"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e96f2137bb71d4484508452e554e1ae6">getSgNodeFromAbstractHandleString</a> (const std::string &amp;input_string)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a matching <a class="el" href="classSgNode.html">SgNode</a> from an abstract handle string.  <a href="#e96f2137bb71d4484508452e554e1ae6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#db3bd3c96f7ee7b03abc333cf2d14d96">dumpInfo</a> (<a class="el" href="classSgNode.html">SgNode</a> *node, std::string desc=&quot;&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dump information about a <a class="el" href="classSgNode.html">SgNode</a> for debugging.  <a href="#db3bd3c96f7ee7b03abc333cf2d14d96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#74263a872d82b1b9f570120aad9205a8">sortSgNodeListBasedOnAppearanceOrderInSource</a> (const std::vector&lt; <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> * &gt; &amp;nodevec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reorder a list of declaration statements based on their appearance order in source files.  <a href="#74263a872d82b1b9f570120aad9205a8"></a><br></td></tr>
<tr><td colspan="2"><br><h2>AST properties</h2></td></tr>
<tr><td colspan="2">version, language properties of current AST. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#566a32e0c20fd3f5622ea88542e15fc1">is_C_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a60da61c638f8a24154b5825a61c6cd2">is_OpenMP_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b0e18374a0ed7b0e6316a99024f3d463">is_UPC_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#8ec5479617b0522a268f633eae672480">is_UPC_dynamic_threads</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if dynamic threads compilation is used for UPC programs.  <a href="#8ec5479617b0522a268f633eae672480"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#886098c3840ecd5cd66dc1407dd43276">is_C99_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#f05a80a2ebfff2af0adea468853b95c8">is_Cxx_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#49a362a0ab0c9d904277c2110b3ad49c">is_Java_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#83cad0fd2592f95e81d55335eb6b71c0">is_Fortran_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#92b55e430cd48fbaf0549c18346a5143">is_CAF_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#1d36075c44838671db22569634aa2938">is_PHP_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#23d423a93f8f98375f0d6270830945a2">is_Python_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#bac39765f90bd8e44841f94da97b0983">is_Cuda_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#8adea0a7bcd9c553286b10558f39dc88">is_binary_executable</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#6321d2c29de36e4e3b13d5ad2f05360f">is_mixed_C_and_Cxx_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#0c24f014eaa02cc009e4d5b4e82317b0">is_mixed_Fortran_and_C_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#8400c6f481f8578f7cd13c62abdc0e20">is_mixed_Fortran_and_Cxx_language</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c403d067f7bef971b67d9a1c4a78d50e">is_mixed_Fortran_and_C_and_Cxx_language</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Scope</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#1035757c3d70027ffd221d21b36af053">resetScopeNumbers</a> (<a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *functionDeclaration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns unique numbers to each <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> of a function.  <a href="#1035757c3d70027ffd221d21b36af053"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d3cad455182a3615812ac2597a50bd09">clearScopeNumbers</a> (<a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *functionDefinition)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the cache of scope,integer pairs for the input function.  <a href="#d3cad455182a3615812ac2597a50bd09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgNamespaceDefinitionStatement.html">SgNamespaceDefinitionStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a192374d0f4322f7c91324938c6b8894">enclosingNamespaceScope</a> (<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *declaration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the enclosing namespace of a declaration.  <a href="#a192374d0f4322f7c91324938c6b8894"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b456db305882bbb6be21968b59fc865c">isPrototypeInScope</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope, <a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *functionDeclaration, <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *startingAtDeclaration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns unique numbers to each <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> of a function.  <a href="#b456db305882bbb6be21968b59fc865c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#74b3faa5cdda97afa174085b4a34a2f1">isAncestor</a> (<a class="el" href="classSgNode.html">SgNode</a> *node1, <a class="el" href="classSgNode.html">SgNode</a> *node2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">check if node1 is a strict ancestor of node 2. (a node is not considered its own ancestor)  <a href="#74b3faa5cdda97afa174085b4a34a2f1"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Preprocessing Information</h2></td></tr>
<tr><td colspan="2">if-else-end, comments, include, etc <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#8d27ee1ca1349f91dc8a18d1aa6cc403">dumpPreprocInfo</a> (<a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> *locatedNode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dumps a located node's preprocessing information.  <a href="#8d27ee1ca1349f91dc8a18d1aa6cc403"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPreprocessingInfo.html">PreprocessingInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#56f045ed55445883dc3fc798738580a2">insertHeader</a> (const std::string &amp;filename, <a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> position=PreprocessingInfo::after, bool isSystemHeader=false, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert include "filename" or include &lt;filename&gt; (system header) into the global scope containing the current scope, right after other include XXX.  <a href="#56f045ed55445883dc3fc798738580a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#283532aef637c65f6d103afc09d5fd71">moveUpPreprocessingInfo</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt_dst, <a class="el" href="classSgStatement.html">SgStatement</a> *stmt_src, <a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> src_position=PreprocessingInfo::undef, <a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> dst_position=PreprocessingInfo::undef, bool usePrepend=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Identical to <a class="el" href="namespaceSageInterface.html#b6bc0e31d1ae1be2e221bb8ddbe1e098">movePreprocessingInfo()</a>, except for the stale name and confusing order of parameters. It will be deprecated soon.  <a href="#283532aef637c65f6d103afc09d5fd71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b6bc0e31d1ae1be2e221bb8ddbe1e098">movePreprocessingInfo</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt_src, <a class="el" href="classSgStatement.html">SgStatement</a> *stmt_dst, <a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> src_position=PreprocessingInfo::undef, <a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> dst_position=PreprocessingInfo::undef, bool usePrepend=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move preprocessing information of stmt_src to stmt_dst, Only move preprocessing information from the specified source-relative position to a specified target position, otherwise move all preprocessing information with position information intact. The preprocessing information is appended to the existing preprocessing information list of the target node by default. Prepending is used if usePreprend is set to true. Optionally, the relative position can be adjust after the moving using dst_position.  <a href="#b6bc0e31d1ae1be2e221bb8ddbe1e098"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#29f09cd84a8eadc2e1c0524898973233">cutPreprocessingInfo</a> (<a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> *src_node, <a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> pos, <a class="el" href="rose__attributes__list_8h.html#d4b5f34bc0846e58b38e0ba5e8aac8b0">AttachedPreprocessingInfoType</a> &amp;save_buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cut preprocessing information from a source node and save it into a buffer. Used in combination of <a class="el" href="namespaceSageInterface.html#fa35ff298b746401f5f535de8a9c3f99">pastePreprocessingInfo()</a>. The cut-paste operation is similar to <a class="el" href="namespaceSageInterface.html#283532aef637c65f6d103afc09d5fd71">moveUpPreprocessingInfo()</a> but it is more flexible in that the destination node can be unknown during the cut operation.  <a href="#29f09cd84a8eadc2e1c0524898973233"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#fa35ff298b746401f5f535de8a9c3f99">pastePreprocessingInfo</a> (<a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> *dst_node, <a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> pos, <a class="el" href="rose__attributes__list_8h.html#d4b5f34bc0846e58b38e0ba5e8aac8b0">AttachedPreprocessingInfoType</a> &amp;saved_buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Paste preprocessing information from a buffer to a destination node. Used in combination of <a class="el" href="namespaceSageInterface.html#29f09cd84a8eadc2e1c0524898973233">cutPreprocessingInfo()</a>.  <a href="#fa35ff298b746401f5f535de8a9c3f99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPreprocessingInfo.html">PreprocessingInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a5cdee81732f9fb464a0239093275d86">attachArbitraryText</a> (<a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> *target, const std::string &amp;text, <a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> position=PreprocessingInfo::before)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attach an arbitrary string to a located node. A workaround to insert irregular statements or vendor-specific attributes.  <a href="#a5cdee81732f9fb464a0239093275d86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#3bf4efffda1365f130307b6581dcc5c9">replaceMacroCallsWithExpandedStrings</a> (<a class="el" href="classSgPragmaDeclaration.html">SgPragmaDeclaration</a> *target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a pragma declaration node has macro calls attached, if yes, replace macro calls within the pragma string with expanded strings. This only works if -rose:wave is turned on.  <a href="#3bf4efffda1365f130307b6581dcc5c9"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Source File Position</h2></td></tr>
<tr><td colspan="2">set <a class="el" href="classSg__File__Info.html">Sg_File_Info</a> for a <a class="el" href="classSgNode.html">SgNode</a> <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPreprocessingInfo.html">PreprocessingInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#67b0e2f8c62c2a8858340e7f90605bc3">attachComment</a> (<a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> *target, const std::string &amp;content, <a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a> position=PreprocessingInfo::before, <a class="el" href="classPreprocessingInfo.html#e789144105bc700862c47070f4380064">PreprocessingInfo::DirectiveType</a> dtype=PreprocessingInfo::CpreprocessorUnknownDeclaration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build and attach comment, comment style is inferred from the language type of the target node if not provided.  <a href="#67b0e2f8c62c2a8858340e7f90605bc3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#0c8fca7b7763fe18fe2e65b7a3cf3ebe">addTextForUnparser</a> (<a class="el" href="classSgNode.html">SgNode</a> *astNode, std::string s, AstUnparseAttribute::RelativePositionType inputlocation)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a string to be unparsed to support code generation for back-end specific tools or compilers.  <a href="#0c8fca7b7763fe18fe2e65b7a3cf3ebe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#2d9f0cac1a208b285896a8f38d24910c">setOneSourcePositionForTransformation</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set current node's source position as transformation generated.  <a href="#2d9f0cac1a208b285896a8f38d24910c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c2dd84efb4bec39069ab07683078e29c">setOneSourcePositionNull</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set current node's source position as NULL.  <a href="#c2dd84efb4bec39069ab07683078e29c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4a000085908cd7fe8ab8cf07856b00fe">setSourcePositionForTransformation</a> (<a class="el" href="classSgNode.html">SgNode</a> *root)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recursively set source position info(Sg_File_Info) as transformation generated.  <a href="#4a000085908cd7fe8ab8cf07856b00fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#6bd0bf1527ae929472afba8b567fa808">setSourcePositionForTransformation_memoryPool</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set source position info(Sg_File_Info) as transformation generated for all SgNodes in memory pool.  <a href="#6bd0bf1527ae929472afba8b567fa808"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#bf0f6c68d90fe1d08e382fe8342b3992">setSourcePosition</a> (<a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> *locatedNode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the source position of <a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> to <a class="el" href="classSg__File__Info.html#d546c953744c52cf43459d6a8358851d">Sg_File_Info::generateDefaultFileInfo()</a>. These nodes WILL be unparsed. Not for transformation usage.  <a href="#bf0f6c68d90fe1d08e382fe8342b3992"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Data types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#5eb80ef8782c559e7721b5724889bdbe">getBoolType</a> (<a class="el" href="classSgNode.html">SgNode</a> *n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the right bool type according to C or C++ language input.  <a href="#5eb80ef8782c559e7721b5724889bdbe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#dbfdb7a0b32ca452c00f5e92c67ab504">isStrictIntegerType</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a type is an integral type, only allowing signed/unsigned short, int, long, long long.  <a href="#dbfdb7a0b32ca452c00f5e92c67ab504"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#da61c82df82783bc236b9fb30fbd74fd">getFirstVarType</a> (<a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *decl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the data type of the first initialized name of a declaration statement.  <a href="#da61c82df82783bc236b9fb30fbd74fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#009d6a3353b70c4ccbe95c6f7625afc1">isDefaultConstructible</a> (<a class="el" href="classSgType.html">SgType</a> *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is a type default constructible? This may not quite work properly.  <a href="#009d6a3353b70c4ccbe95c6f7625afc1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#32b9be9817f0b51872d3fcb8318ae729">isCopyConstructible</a> (<a class="el" href="classSgType.html">SgType</a> *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is a type copy constructible? This may not quite work properly.  <a href="#32b9be9817f0b51872d3fcb8318ae729"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#7a37edbdd90a230a51fc90448994cb8b">isAssignable</a> (<a class="el" href="classSgType.html">SgType</a> *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is a type assignable? This may not quite work properly.  <a href="#7a37edbdd90a230a51fc90448994cb8b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d3cb00d489f349ed6eaaaf0d5e1273fa">isPureVirtualClass</a> (<a class="el" href="classSgType.html">SgType</a> *type, const <a class="el" href="classClassHierarchyWrapper.html">ClassHierarchyWrapper</a> &amp;classHierarchy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a class type is a pure virtual class.  <a href="#d3cb00d489f349ed6eaaaf0d5e1273fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#756c8b08ca6df604e0e474ce92520240">hasTrivialDestructor</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does a type have a trivial (built-in) destructor?  <a href="#756c8b08ca6df604e0e474ce92520240"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#82f20af57da57491b26e6028fc4949c7">isNonconstReference</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this type a non-constant reference type? (Handles typedefs correctly).  <a href="#82f20af57da57491b26e6028fc4949c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#82448abd826a63fbf74cabde856223ec">isReferenceType</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this type a const or non-const reference type? (Handles typedefs correctly).  <a href="#82448abd826a63fbf74cabde856223ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#370c189fab51b8d9a5871c569fe2ae76">isPointerType</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this type a pointer type? (Handles typedefs correctly).  <a href="#370c189fab51b8d9a5871c569fe2ae76"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e88d4c976002995bdc89629bf5942812">isPointerToNonConstType</a> (<a class="el" href="classSgType.html">SgType</a> *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this a pointer to a non-const type? Note that this function will return true for const pointers pointing to non-const types.  <a href="#e88d4c976002995bdc89629bf5942812"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#3a8271b0d66df14cd687c3367c3530cc">isConstType</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this a const type?  <a href="#3a8271b0d66df14cd687c3367c3530cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#aad366e0a9271f41b1273169032163a9">removeConst</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove const (if present) from a type. stripType() cannot do this because it removes all modifiers.  <a href="#aad366e0a9271f41b1273169032163a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#bfdc4703511f9477641338f374d2efea">isVolatileType</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this a volatile type?  <a href="#bfdc4703511f9477641338f374d2efea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#9bb1cf771b3824b61f450868a4a37014">isRestrictType</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this a restrict type?  <a href="#9bb1cf771b3824b61f450868a4a37014"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#383e9d7c3a5ecf90215dc596491cb748">isScalarType</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this a scalar type?  <a href="#383e9d7c3a5ecf90215dc596491cb748"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#0c1abd9fda12ecad049dc846ab65dd99">isStructType</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a type is a struct type (a special <a class="el" href="classSgClassType.html">SgClassType</a> in <a class="el" href="namespaceROSE.html">ROSE</a>).  <a href="#0c1abd9fda12ecad049dc846ab65dd99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#42c6089ca6226d5f96cc54164a8c2dec">mangleType</a> (<a class="el" href="classSgType.html">SgType</a> *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a mangled string for a given type based on Itanium C++ ABI.  <a href="#42c6089ca6226d5f96cc54164a8c2dec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4ba1a020452edc07be8aefe8f87c7a52">mangleScalarType</a> (<a class="el" href="classSgType.html">SgType</a> *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate mangled scalar type names according to Itanium C++ ABI, the input type should pass <a class="el" href="namespaceSageInterface.html#383e9d7c3a5ecf90215dc596491cb748">isScalarType()</a> in <a class="el" href="namespaceROSE.html">ROSE</a>.  <a href="#4ba1a020452edc07be8aefe8f87c7a52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#181e5d76b90b579ffe02ce67a9a0ef8b">mangleModifierType</a> (<a class="el" href="classSgModifierType.html">SgModifierType</a> *type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generated mangled modifier types, include const, volatile,according to Itanium C++ ABI, with extension to handle UPC shared types.  <a href="#181e5d76b90b579ffe02ce67a9a0ef8b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d41b5baa74591e80698884761377ab6b">getArrayElementCount</a> (<a class="el" href="classSgArrayType.html">SgArrayType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the number of elements of an array type: dim1* dim2*... , assume element count is 1 for int a[]; Strip off THREADS if it is a UPC array.  <a href="#d41b5baa74591e80698884761377ab6b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#8a2ff021fc68f7aa3af9427133e94663">getDimensionCount</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of dimensions of an array type.  <a href="#8a2ff021fc68f7aa3af9427133e94663"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4be15625c027455c3ba044dbeff24f05">getArrayElementType</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the element type of an array.  <a href="#4be15625c027455c3ba044dbeff24f05"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#5eaa89e50137b40aab59321dcfed8d81">getElementType</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the element type of an array, pointer or string, or NULL if not applicable.  <a href="#5eaa89e50137b40aab59321dcfed8d81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgExpression.html">SgExpression</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4f543ac715559ff0b76bdf8fd004fc09">get_C_array_dimensions</a> (const <a class="el" href="classSgArrayType.html">SgArrayType</a> &amp;arrtype)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the array dimensions in an array as defined for arrtype  <a href="#4f543ac715559ff0b76bdf8fd004fc09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgExpression.html">SgExpression</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c4ca57179d072f3577b07b8e33818dca">get_C_array_dimensions</a> (const <a class="el" href="classSgArrayType.html">SgArrayType</a> &amp;arrtype, const <a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> &amp;varref)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the array dimensions in an array as defined for arrtype  <a href="#c4ca57179d072f3577b07b8e33818dca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgExpression.html">SgExpression</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ae2594fcfdf89b9fc795eb4b4c2d04aa">get_C_array_dimensions</a> (const <a class="el" href="classSgArrayType.html">SgArrayType</a> &amp;arrtype, <a class="el" href="classSgInitializedName.html">SgInitializedName</a> &amp;initname)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#ae2594fcfdf89b9fc795eb4b4c2d04aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#084d7c6b763876564745cdf9a33a65a3">isArrayReference</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *ref, <a class="el" href="classSgExpression.html">SgExpression</a> **arrayNameExp=NULL, std::vector&lt; <a class="el" href="classSgExpression.html">SgExpression</a> * &gt; **subscripts=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if an expression is an array access (<a class="el" href="classSgPntrArrRefExp.html">SgPntrArrRefExp</a>). If so, return its name expression and subscripts if requested. Users can use <a class="el" href="namespaceSageInterface.html#549a580089fff36d4184a4341cc08525">convertRefToInitializedName()</a> to get the possible name. It does not check if the expression is a top level <a class="el" href="classSgPntrArrRefExp.html">SgPntrArrRefExp</a>.  <a href="#084d7c6b763876564745cdf9a33a65a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#de40549fd13e8fe367b099dca26b05e9">hasUpcSharedType</a> (<a class="el" href="classSgType.html">SgType</a> *t, <a class="el" href="classSgModifierType.html">SgModifierType</a> **mod_type_out=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Has a UPC shared type of any kinds (shared-to-shared, private-to-shared, shared-to-private, shared scalar/array)? An optional parameter, mod_type_out, stores the first <a class="el" href="classSgModifierType.html">SgModifierType</a> with UPC access information.  <a href="#de40549fd13e8fe367b099dca26b05e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b376d542cfdc22ae95a4396a13f4bc93">isUpcSharedType</a> (<a class="el" href="classSgType.html">SgType</a> *t, <a class="el" href="classSgModifierType.html">SgModifierType</a> **mod_type_out=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a type is a UPC shared type, including shared array, shared pointers etc. Exclude private pointers to shared types. Optionally return the modifier type with the UPC shared property.  <a href="#b376d542cfdc22ae95a4396a13f4bc93"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d54acda16a47a2c0cfbf2cfb9acbe8ee">isUpcSharedModifierType</a> (<a class="el" href="classSgModifierType.html">SgModifierType</a> *mod_type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a modifier type is a UPC shared type.  <a href="#d54acda16a47a2c0cfbf2cfb9acbe8ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4d265b598c37bc424f98b5a95573ff15">isUpcSharedArrayType</a> (<a class="el" href="classSgArrayType.html">SgArrayType</a> *array_type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if an array type is a UPC shared type. <a class="el" href="namespaceROSE.html">ROSE</a> AST represents a UPC shared array as regular array of elements of UPC shared Modifier Type. Not directly a UPC shared Modifier Type of an array.  <a href="#4d265b598c37bc424f98b5a95573ff15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#3a8ddc7cf87c39a61529012d179d3dbe">isUpcStrictSharedModifierType</a> (<a class="el" href="classSgModifierType.html">SgModifierType</a> *mode_type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a shared UPC type is strict memory consistency or not. Return false if it is relaxed. (So isUpcRelaxedSharedModifierType() is not necessary.).  <a href="#3a8ddc7cf87c39a61529012d179d3dbe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ad5db4074aa860d969211e082b1fda2a">getUpcSharedBlockSize</a> (<a class="el" href="classSgModifierType.html">SgModifierType</a> *mod_type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the block size of a UPC shared modifier type.  <a href="#ad5db4074aa860d969211e082b1fda2a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a4517f3d9eb77e8c20978d259f05dae9">getUpcSharedBlockSize</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the block size of a UPC shared type, including Modifier types and array of modifier types (shared arrays).  <a href="#a4517f3d9eb77e8c20978d259f05dae9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#78e18bb017714a961c89e99658deaf62">isUpcPhaseLessSharedType</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is UPC phase-less shared type? Phase-less means block size of the first <a class="el" href="classSgModifierType.html">SgModifierType</a> with UPC information is 1 or 0/unspecified. Also return false if the type is not a UPC shared type.  <a href="#78e18bb017714a961c89e99658deaf62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a8dfe505ebec9aa2cc591ab6abd2eee6">isUpcPrivateToSharedType</a> (<a class="el" href="classSgType.html">SgType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is a UPC private-to-shared pointer? <a class="el" href="classSgPointerType.html">SgPointerType</a> comes first compared to <a class="el" href="classSgModifierType.html">SgModifierType</a> with UPC information. Input type must be any of UPC shared types first.  <a href="#a8dfe505ebec9aa2cc591ab6abd2eee6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c9d12d48cbb70bd32351ef1d11bf8a03">isUpcArrayWithThreads</a> (<a class="el" href="classSgArrayType.html">SgArrayType</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is a UPC array with dimension of X*THREADS.  <a href="#c9d12d48cbb70bd32351ef1d11bf8a03"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ef8c45dd50e90745d7a58043ff115b59">lookupNamedTypeInParentScopes</a> (const std::string &amp;type_name, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lookup a named type based on its name, bottomup searching from a specified scope. Note name collison might be allowed for c (not C++) between typedef and enum/struct. Only the first matched named type will be returned in this case. typedef is returned as it is, not the base type it actually refers to.  <a href="#ef8c45dd50e90745d7a58043ff115b59"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Loop handling</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#08fe811227383a60a96a1f35e33d58c7">addStepToLoopBody</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *loopStmt, <a class="el" href="classSgStatement.html">SgStatement</a> *step)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a step statement to the end of a loop body Add a new label to the end of the loop, with the step statement after it; then change all continue statements in the old loop body into jumps to the label.  <a href="#08fe811227383a60a96a1f35e33d58c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#8350cdaa61eb225618e5d32d1d6ead35">moveForStatementIncrementIntoBody</a> (<a class="el" href="classSgForStatement.html">SgForStatement</a> *f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a step statement to the end of a loop body Add a new label to the end of the loop, with the step statement after it; then change all continue statements in the old loop body into jumps to the label.  <a href="#8350cdaa61eb225618e5d32d1d6ead35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d8b390197b2be6ccda0b4cd5f5db5924">convertForToWhile</a> (<a class="el" href="classSgForStatement.html">SgForStatement</a> *f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a step statement to the end of a loop body Add a new label to the end of the loop, with the step statement after it; then change all continue statements in the old loop body into jumps to the label.  <a href="#d8b390197b2be6ccda0b4cd5f5db5924"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a952504e784c3893ff962859c02db863">convertAllForsToWhiles</a> (<a class="el" href="classSgNode.html">SgNode</a> *top)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a step statement to the end of a loop body Add a new label to the end of the loop, with the step statement after it; then change all continue statements in the old loop body into jumps to the label.  <a href="#a952504e784c3893ff962859c02db863"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a3c334c13af3f52296a321d7c35baa23">changeContinuesToGotos</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, <a class="el" href="classSgLabelStatement.html">SgLabelStatement</a> *label)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change continue statements in a given block of code to gotos to a label.  <a href="#a3c334c13af3f52296a321d7c35baa23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgInitializedName.html">SgInitializedName</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a665b7831b78df5befccba361619e346">getLoopIndexVariable</a> (<a class="el" href="classSgNode.html">SgNode</a> *loop)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the loop index variable for a for loop.  <a href="#a665b7831b78df5befccba361619e346"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#21ef5a8bfe9a660dbe9206d50f1750ce">isLoopIndexVariable</a> (<a class="el" href="classSgInitializedName.html">SgInitializedName</a> *ivar, <a class="el" href="classSgNode.html">SgNode</a> *subtree_root)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a <a class="el" href="classSgInitializedName.html">SgInitializedName</a> is used as a loop index within a AST subtree This function will use a bottom-up traverse starting from the subtree_root to find all enclosing loops and check if ivar is used as an index for either of them.  <a href="#21ef5a8bfe9a660dbe9206d50f1750ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#cdd84b0f648aacdf4d31692bbff98c42">getLoopBody</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *loop)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Routines to get and set the body of a loop.  <a href="#cdd84b0f648aacdf4d31692bbff98c42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e79df849100431065061cb615b27b5e7">setLoopBody</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *loop, <a class="el" href="classSgStatement.html">SgStatement</a> *body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a step statement to the end of a loop body Add a new label to the end of the loop, with the step statement after it; then change all continue statements in the old loop body into jumps to the label.  <a href="#e79df849100431065061cb615b27b5e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#8a48fa3afe244bdceaf9201f217d9873">getLoopCondition</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *loop)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Routines to get the condition of a loop. It recognize While-loop, For-loop, and Do-While-loop.  <a href="#8a48fa3afe244bdceaf9201f217d9873"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#3368c7c03cdd8fad0ff4dde8ac17a7bc">setLoopCondition</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *loop, <a class="el" href="classSgStatement.html">SgStatement</a> *cond)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the condition statement of a loop, including While-loop, For-loop, and Do-While-loop.  <a href="#3368c7c03cdd8fad0ff4dde8ac17a7bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#8fee9383277837dceac3130968eb447a">isCanonicalForLoop</a> (<a class="el" href="classSgNode.html">SgNode</a> *loop, <a class="el" href="classSgInitializedName.html">SgInitializedName</a> **ivar=NULL, <a class="el" href="classSgExpression.html">SgExpression</a> **lb=NULL, <a class="el" href="classSgExpression.html">SgExpression</a> **ub=NULL, <a class="el" href="classSgExpression.html">SgExpression</a> **step=NULL, <a class="el" href="classSgStatement.html">SgStatement</a> **body=NULL, bool *hasIncrementalIterationSpace=NULL, bool *isInclusiveUpperBound=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a for-loop has a canonical form, return loop index, bounds, step, and body if requested.  <a href="#8fee9383277837dceac3130968eb447a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#25ecfa1b43bb6bef8e6f0c4217206638">isCanonicalDoLoop</a> (<a class="el" href="classSgFortranDo.html">SgFortranDo</a> *loop, <a class="el" href="classSgInitializedName.html">SgInitializedName</a> **ivar, <a class="el" href="classSgExpression.html">SgExpression</a> **lb, <a class="el" href="classSgExpression.html">SgExpression</a> **ub, <a class="el" href="classSgExpression.html">SgExpression</a> **step, <a class="el" href="classSgStatement.html">SgStatement</a> **body, bool *hasIncrementalIterationSpace, bool *isInclusiveUpperBound)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a Fortran Do loop has a complete canonical form: Do I=1, 10, 1.  <a href="#25ecfa1b43bb6bef8e6f0c4217206638"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#9def1f61dcf1d975ebd823f921dc4a92">setLoopLowerBound</a> (<a class="el" href="classSgNode.html">SgNode</a> *loop, <a class="el" href="classSgExpression.html">SgExpression</a> *lb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the lower bound of a loop header for (i=lb; ...).  <a href="#9def1f61dcf1d975ebd823f921dc4a92"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#cc572630786f0e865742cc8274992e8b">setLoopUpperBound</a> (<a class="el" href="classSgNode.html">SgNode</a> *loop, <a class="el" href="classSgExpression.html">SgExpression</a> *ub)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the upper bound of a loop header,regardless the condition expression type. for (i=lb; i op up, ...).  <a href="#cc572630786f0e865742cc8274992e8b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#7ad626782e4cd15b81d486f1012e3944">setLoopStride</a> (<a class="el" href="classSgNode.html">SgNode</a> *loop, <a class="el" href="classSgExpression.html">SgExpression</a> *stride)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the stride(step) of a loop 's incremental expression, regardless the expression types (i+=s; i= i+s, etc).  <a href="#7ad626782e4cd15b81d486f1012e3944"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#56ad0d54049c684d5af206864adf7390">normalizeForLoopInitDeclaration</a> (<a class="el" href="classSgForStatement.html">SgForStatement</a> *loop)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize loop init stmt by promoting the single variable declaration statement outside of the for loop header's init statement, e.g. for (int i=0;) becomes int i_x; for (i_x=0;..) and rewrite the loop with the new index variable, if necessary.  <a href="#56ad0d54049c684d5af206864adf7390"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a500ce86ded48ff840d829a33e08b0d6">forLoopNormalization</a> (<a class="el" href="classSgForStatement.html">SgForStatement</a> *loop)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize a for loop, return true if successful.  <a href="#a500ce86ded48ff840d829a33e08b0d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#714c3bd1a8ad05aefd0a374f5449a975">doLoopNormalization</a> (<a class="el" href="classSgFortranDo.html">SgFortranDo</a> *loop)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize a Fortran Do loop. Make the default increment expression (1) explicit.  <a href="#714c3bd1a8ad05aefd0a374f5449a975"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#32c1cd741a34e12e81515e3e6e3ce6a1">loopUnrolling</a> (<a class="el" href="classSgForStatement.html">SgForStatement</a> *loop, size_t unrolling_factor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unroll a target loop with a specified unrolling factor. It handles steps larger than 1 and adds a fringe loop if the iteration count is not evenly divisible by the unrolling factor.  <a href="#32c1cd741a34e12e81515e3e6e3ce6a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#69c06c565033135bf031e02547d7ffd7">loopInterchange</a> (<a class="el" href="classSgForStatement.html">SgForStatement</a> *loop, size_t depth, size_t lexicoOrder)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interchange/permutate a n-level perfectly-nested loop rooted at 'loop' using a lexicographical order number within (0,depth!).  <a href="#69c06c565033135bf031e02547d7ffd7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#bf67276dd03b4d83fd53e8d17cfee342">loopTiling</a> (<a class="el" href="classSgForStatement.html">SgForStatement</a> *loopNest, size_t targetLevel, size_t tileSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tile the n-level (starting from 1) loop of a perfectly nested loop nest using tiling size s.  <a href="#bf67276dd03b4d83fd53e8d17cfee342"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Topdown search</h2></td></tr>
<tr><td colspan="2">Top-down traversal from current node to find a node of a specified type <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename NodeType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::vector&lt; NodeType * &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#1123219ebb32a1140a1c10e73b97ca22">querySubTree</a> (<a class="el" href="classSgNode.html">SgNode</a> *top, <a class="el" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a> variant=(<a class="el" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a>) NodeType::static_variant)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query a subtree to get all nodes of a given type, with an appropriate downcast.  <a href="#1123219ebb32a1140a1c10e73b97ca22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgFile.html">SgFile</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e033e337d88d92aa952932fdb077cbe4">generateFileList</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns STL vector of <a class="el" href="classSgFile.html">SgFile</a> IR node pointers.  <a href="#e033e337d88d92aa952932fdb077cbe4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgProject.html">SgProject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c2c6c9fdb8ba0b9a21677e11014216cf">getProject</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current <a class="el" href="classSgProject.html">SgProject</a> IR Node.  <a href="#c2c6c9fdb8ba0b9a21677e11014216cf"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename NodeType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static std::vector&lt; NodeType * &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#71fa312dbb8ef1d9a37f6897de49fcce">getSgNodeListFromMemoryPool</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query memory pools to grab <a class="el" href="classSgNode.html">SgNode</a> of a specified type.  <a href="#71fa312dbb8ef1d9a37f6897de49fcce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#0c4e4490c4d20ef7f32dd2d6459c7548">findMain</a> (<a class="el" href="classSgNode.html">SgNode</a> *currentNode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">top-down traversal from current node to find the main() function declaration  <a href="#0c4e4490c4d20ef7f32dd2d6459c7548"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#81e9af0e07a7ba45455e3a463d43ed9f">findLastDeclarationStatement</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the last declaration statement within a scope (if any). This is often useful to decide where to insert another declaration statement.  <a href="#81e9af0e07a7ba45455e3a463d43ed9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#be2c3ab6716f418f4706960427c71545">getSymbolsUsedInExpression</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *expr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find referenced symbols within an expression.  <a href="#be2c3ab6716f418f4706960427c71545"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgBreakStmt.html">SgBreakStmt</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b3fd7caa53c4504d7d668336d4be8097">findBreakStmts</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *code, const std::string &amp;fortranLabel=&quot;&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find break statements inside a particular statement, stopping at nested loops or switches.  <a href="#b3fd7caa53c4504d7d668336d4be8097"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgContinueStmt.html">SgContinueStmt</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d8f642bb83545acd486c40aeb6f3093f">findContinueStmts</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *code, const std::string &amp;fortranLabel=&quot;&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find all continue statements inside a particular statement, stopping at nested loops.  <a href="#d8f642bb83545acd486c40aeb6f3093f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgGotoStatement.html">SgGotoStatement</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c7ba7b7b9738ec66d5e39a0beb16e900">findGotoStmts</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *scope, <a class="el" href="classSgLabelStatement.html">SgLabelStatement</a> *l)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query a subtree to get all nodes of a given type, with an appropriate downcast.  <a href="#c7ba7b7b9738ec66d5e39a0beb16e900"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgStatement.html">SgStatement</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#51e681c5508ac6c664ed3dabdd230323">getSwitchCases</a> (<a class="el" href="classSgSwitchStatement.html">SgSwitchStatement</a> *sw)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query a subtree to get all nodes of a given type, with an appropriate downcast.  <a href="#51e681c5508ac6c664ed3dabdd230323"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b36728bc3a9ee699fb33c04efbb1b553">findDeclarationStatement</a> (<a class="el" href="classSgNode.html">SgNode</a> *root, std::string name, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope, bool isDefining)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Topdown traverse a subtree from root to find the first declaration given its name, scope (optional, can be NULL), and defining or nondefining flag.  <a href="#b36728bc3a9ee699fb33c04efbb1b553"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#25ba093b55f9983f1f3c385563e1b880">findFunctionDeclaration</a> (<a class="el" href="classSgNode.html">SgNode</a> *root, std::string name, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope, bool isDefining)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Topdown traverse a subtree from root to find the first function declaration matching the given name, scope (optional, can be NULL), and defining or nondefining flag. This is an instantiation of findDeclarationStatement&lt;T&gt;.  <a href="#25ba093b55f9983f1f3c385563e1b880"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Bottom up search</h2></td></tr>
<tr><td colspan="2">Backwards traverse through the AST to find a node, findEnclosingXXX() <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename NodeType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">NodeType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#0e13c06070acba9a4028596b14df37c0">getEnclosingNode</a> (const <a class="el" href="classSgNode.html">SgNode</a> *astNode, const bool includingSelf=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a node by type using upward traversal.  <a href="#0e13c06070acba9a4028596b14df37c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#6ec13831a4d9c0142db2f595d56ce862">getScope</a> (const <a class="el" href="classSgNode.html">SgNode</a> *astNode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the closest scope from astNode. Return astNode if it is already a scope.  <a href="#6ec13831a4d9c0142db2f595d56ce862"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgGlobal.html">SgGlobal</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#108fb9317605cd9d1228cb156993e34d">getGlobalScope</a> (const <a class="el" href="classSgNode.html">SgNode</a> *astNode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Traverse back through a node's parents to find the enclosing global scope.  <a href="#108fb9317605cd9d1228cb156993e34d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#3d1cde13da7917ba2ac6005d266f934d">getEnclosingProcedure</a> (<a class="el" href="classSgNode.html">SgNode</a> *n, const bool includingSelf=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the function definition.  <a href="#3d1cde13da7917ba2ac6005d266f934d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#89a3cd0446fb308e841a8844ec69f96e">getEnclosingFunctionDefinition</a> (<a class="el" href="classSgNode.html">SgNode</a> *astNode, const bool includingSelf=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a node by type using upward traversal.  <a href="#89a3cd0446fb308e841a8844ec69f96e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#5717c88c4a9675c30069319cfe913127">getEnclosingStatement</a> (<a class="el" href="classSgNode.html">SgNode</a> *n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the closest enclosing statement, including the given node.  <a href="#5717c88c4a9675c30069319cfe913127"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgSwitchStatement.html">SgSwitchStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ac586c26b215b6fb86a99370905e2044">findEnclosingSwitch</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the closest switch outside a given statement (normally used for case and default statements).  <a href="#ac586c26b215b6fb86a99370905e2044"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#9fc733ce75b79e34e7c85c0e5b5b1d1a">findEnclosingLoop</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *s, const std::string &amp;fortranLabel=&quot;&quot;, bool stopOnSwitches=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the closest loop outside the given statement; if fortranLabel is not empty, the Fortran label of the loop must be equal to it.  <a href="#9fc733ce75b79e34e7c85c0e5b5b1d1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ac9b45bdb148ec342cf14c95f39e64f9">getEnclosingFunctionDeclaration</a> (<a class="el" href="classSgNode.html">SgNode</a> *astNode, const bool includingSelf=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the enclosing function declaration, including its derived instances like isSgProcedureHeaderStatement, isSgProgramHeaderStatement, and isSgMemberFunctionDeclaration.  <a href="#ac9b45bdb148ec342cf14c95f39e64f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgFile.html">SgFile</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#73600ebdd020f6ffed566018c22e20b8">getEnclosingFileNode</a> (<a class="el" href="classSgNode.html">SgNode</a> *astNode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the <a class="el" href="classSgFile.html">SgFile</a> node from current node  <a href="#73600ebdd020f6ffed566018c22e20b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgInitializer.html">SgInitializer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a7ab26b36b4ddffb9db2c7f2160322c8">getInitializerOfExpression</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the initializer containing an expression if it is within an initializer.  <a href="#a7ab26b36b4ddffb9db2c7f2160322c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgClassDefinition.html">SgClassDefinition</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#f3212dbf1eb743a7f9cd2ed35142cd5f">getEnclosingClassDefinition</a> (<a class="el" href="classSgNode.html">SgNode</a> *astnode, const bool includingSelf=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the closest class definition enclosing the specified AST node,.  <a href="#f3212dbf1eb743a7f9cd2ed35142cd5f"></a><br></td></tr>
<tr><td colspan="2"><br><h2>AST Walk and Traversal</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgGlobal.html">SgGlobal</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b45dc06ff0224928a1ae1da997e52b08">getFirstGlobalScope</a> (<a class="el" href="classSgProject.html">SgProject</a> *<a class="el" href="namespacecfgUtils.html#ce4abf2beca5826144d69d3a0283050f">project</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the first global scope under current project  <a href="#b45dc06ff0224928a1ae1da997e52b08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4ad89114f9b3edc1d78c4ed0361b7b8c">getLastStatement</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the last statement within a scope, return NULL if it does not exit  <a href="#4ad89114f9b3edc1d78c4ed0361b7b8c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#2b15b529d2da9a8b370adc56def709fb">getFirstStatement</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope, bool includingCompilerGenerated=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the first statement within a scope, return NULL if it does not exist. Skip compiler-generated statement by default. Count transformation-generated ones, but excluding those which are not to be outputted in unparsers.  <a href="#2b15b529d2da9a8b370adc56def709fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d3bb1a781eb5b2ece057e620dcc3f83c">findFirstDefiningFunctionDecl</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the first defining function declaration statement in a scope.  <a href="#d3bb1a781eb5b2ece057e620dcc3f83c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#514decfd76850247d4e84d54f88ce1c9">getNextStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *currentStmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get next statement within the same scope of current statement.  <a href="#514decfd76850247d4e84d54f88ce1c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#1f85e0ded2e249c9e54b4204eeeed113">getPreviousStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *currentStmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get previous statement within the same scope of current statement.  <a href="#1f85e0ded2e249c9e54b4204eeeed113"></a><br></td></tr>
<tr><td colspan="2"><br><h2>AST Comparison</h2></td></tr>
<tr><td colspan="2">Compare AST nodes, subtree, etc <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#6b16a27989aff98b861e3a677563ae42">isEqualToIntConst</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *e, int value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a <a class="el" href="classSgIntVal.html">SgIntVal</a> node has a given value.  <a href="#6b16a27989aff98b861e3a677563ae42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#2ad29ecfbbcca49188ceb7468e91ae74">isSameFunction</a> (<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *func1, <a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *func2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if two function declarations refer to the same one. Two function declarations are the same when they are a) identical, b) same name in C c) same qualified named and mangled name in C++. A nondefining (prototype) declaration and a defining declaration of a same function are treated as the same.  <a href="#2ad29ecfbbcca49188ceb7468e91ae74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#01df9113c49dfbd3f7145e9a8259d125">isLastStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a statement is the last statement within its closed scope.  <a href="#01df9113c49dfbd3f7145e9a8259d125"></a><br></td></tr>
<tr><td colspan="2"><br><h2>AST insert, removal, and replacement</h2></td></tr>
<tr><td colspan="2">Add, remove,and replace AST<p>
scope-&gt;append_statement(), exprListExp-&gt;append_expression() etc. are not enough to handle side effect of parent pointers, symbol tables, preprocessing info, defining/nondefining pointers etc. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#57437bbbb806858dda0cea7444fbafef">deleteAST</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classFunction.html">Function</a> to delete AST subtree's nodes only, users must take care of any dangling pointers, symbols or types that result.  <a href="#57437bbbb806858dda0cea7444fbafef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#062f0bab3b5deef80a101471d2bc0c0e">deleteExpressionTreeWithOriginalExpressionSubtrees</a> (<a class="el" href="classSgNode.html">SgNode</a> *root)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special purpose function for deleting AST expression tress containing valid original expression trees in constant folded expressions (for internal use only).  <a href="#062f0bab3b5deef80a101471d2bc0c0e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d74e38bddc8dc4d5d0506102782680ef">moveStatementsBetweenBlocks</a> (<a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *sourceBlock, <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *targetBlock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move statements in first block to the second block (preserves order and rebuilds the symbol table).  <a href="#d74e38bddc8dc4d5d0506102782680ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#bd2b74fa3c7de0b27066790dfba32ab7">appendStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a statement to the end of the current scope, handle side effect of appending statements, e.g. preprocessing info, defining/nondefining pointers etc.  <a href="#bd2b74fa3c7de0b27066790dfba32ab7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#dc3d212ae841c07933c40e4235b4f0a9">appendStatementList</a> (const std::vector&lt; <a class="el" href="classSgStatement.html">SgStatement</a> * &gt; &amp;stmt, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a list of statements to the end of the current scope, handle side effect of appending statements, e.g. preprocessing info, defining/nondefining pointers etc.  <a href="#dc3d212ae841c07933c40e4235b4f0a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#6d20d118b27ab3675c748d6adb2ac467">appendStatementWithDependentDeclaration</a> (<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *decl, <a class="el" href="classSgGlobal.html">SgGlobal</a> *scope, <a class="el" href="classSgStatement.html">SgStatement</a> *original_statement, bool excludeHeaderFiles)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a copy ('decl') of a function ('original_statement') into a 'scope', include any referenced declarations required if the scope is within a compiler generated file. All referenced declarations, including those from headers, are inserted if excludeHeaderFiles is set to true (the new file will not have any headers).  <a href="#6d20d118b27ab3675c748d6adb2ac467"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e9c30cd9d9c2589e9534638c7a79e731">prependStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepend a statement to the beginning of the current scope, handling side effects as appropriate.  <a href="#e9c30cd9d9c2589e9534638c7a79e731"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#150082ead31a73a3cd272f7428521823">prependStatementList</a> (const std::vector&lt; <a class="el" href="classSgStatement.html">SgStatement</a> * &gt; &amp;stmt, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">prepend a list of statements to the beginning of the current scope, handling side effects as appropriate  <a href="#150082ead31a73a3cd272f7428521823"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e41c86d0aefd60c26c60bd6f0ec4b76b">hasSimpleChildrenList</a> (<a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a scope statement has a simple children statement list so insert additional statements under the scope is straightforward and unambiguous .  <a href="#e41c86d0aefd60c26c60bd6f0ec4b76b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#54e6780cc15a76ce7bc37a1212452e66">insertStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *targetStmt, <a class="el" href="classSgStatement.html">SgStatement</a> *newStmt, bool insertBefore=true, bool autoMovePreprocessingInfo=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a statement before or after the target statement within the target's scope. Move around preprocessing info automatically.  <a href="#54e6780cc15a76ce7bc37a1212452e66"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#07fb69a12095f93a9cbe325fe5a8b7d2">insertStatementList</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *targetStmt, const std::vector&lt; <a class="el" href="classSgStatement.html">SgStatement</a> * &gt; &amp;newStmts, bool insertBefore=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a list of statements before or after the target statement within the.  <a href="#07fb69a12095f93a9cbe325fe5a8b7d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#dab9927218b2709b3d99544db4386dc2">insertStatementBefore</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *targetStmt, <a class="el" href="classSgStatement.html">SgStatement</a> *newStmt, bool autoMovePreprocessingInfo=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a statement before a target statement.  <a href="#dab9927218b2709b3d99544db4386dc2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#193b6b847675d342d37b9917bf0a3f43">insertStatementListBefore</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *targetStmt, const std::vector&lt; <a class="el" href="classSgStatement.html">SgStatement</a> * &gt; &amp;newStmts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a list of statements before a target statement.  <a href="#193b6b847675d342d37b9917bf0a3f43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#f43f1edd321a11e4a9d6fd6cf8b4bcd6">insertStatementAfter</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *targetStmt, <a class="el" href="classSgStatement.html">SgStatement</a> *newStmt, bool autoMovePreprocessingInfo=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a statement after a target statement, Move around preprocessing info automatically by default.  <a href="#f43f1edd321a11e4a9d6fd6cf8b4bcd6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4c7e8d91522f9c76e28d35bcd76a07e6">insertStatementListAfter</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *targetStmt, const std::vector&lt; <a class="el" href="classSgStatement.html">SgStatement</a> * &gt; &amp;newStmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a list of statements after a target statement.  <a href="#4c7e8d91522f9c76e28d35bcd76a07e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#918939111ad1510bfc0c520156e8d9e9">insertStatementAfterLastDeclaration</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a statement after the last declaration within a scope. The statement will be prepended to the scope if there is no declaration statement found.  <a href="#918939111ad1510bfc0c520156e8d9e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#9c538bc1293c87f89917412d8729f679">insertStatementAfterLastDeclaration</a> (std::vector&lt; <a class="el" href="classSgStatement.html">SgStatement</a> * &gt; stmt_list, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a list of statements after the last declaration within a scope. The statement will be prepended to the scope if there is no declaration statement found.  <a href="#9c538bc1293c87f89917412d8729f679"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#f5972a33cb2e9b5723e50ceccdaccb9f">removeStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, bool autoRelocatePreprocessingInfo=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a statement from its attach point of the AST. Automatically keep its associated preprocessing information at the original place after the removal. The statement is still in memory and it is up to the users to decide if the removed one will be inserted somewhere else or released from memory (<a class="el" href="namespaceSageInterface.html#57437bbbb806858dda0cea7444fbafef">deleteAST()</a>).  <a href="#f5972a33cb2e9b5723e50ceccdaccb9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#03bd60c658db463cfc3791a7bba5017a">deepDelete</a> (<a class="el" href="classSgNode.html">SgNode</a> *root)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deep delete a sub AST tree. It uses postorder traversal to delete each child node. Users must take care of any dangling pointers, symbols or types that result. This is identical to <a class="el" href="namespaceSageInterface.html#57437bbbb806858dda0cea7444fbafef">deleteAST()</a>.  <a href="#03bd60c658db463cfc3791a7bba5017a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#69827cb64e737fdc661a48871c92ec96">replaceStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *oldStmt, <a class="el" href="classSgStatement.html">SgStatement</a> *newStmt, bool movePreprocessinInfo=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace a statement with another. Move preprocessing information from oldStmt to newStmt if requested.  <a href="#69827cb64e737fdc661a48871c92ec96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#40eb9c7f467b4e0830bae948562d2d89">replaceWithPattern</a> (<a class="el" href="classSgNode.html">SgNode</a> *anchor, <a class="el" href="classSgNode.html">SgNode</a> *new_pattern)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace an anchor node with a specified pattern subtree with optional <a class="el" href="classSgVariantExpression.html">SgVariantExpression</a>. All <a class="el" href="classSgVariantExpression.html">SgVariantExpression</a> in the pattern will be replaced with copies of the anchor node.  <a href="#40eb9c7f467b4e0830bae948562d2d89"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt; <a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *,<br>
 <a class="el" href="classSgExpression.html">SgExpression</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#8b8089083afe0aca12b1c9ba64d4ddc6">createTempVariableForExpression</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *expression, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope, bool initializeInDeclaration, <a class="el" href="classSgAssignOp.html">SgAssignOp</a> **reEvaluate=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an expression, generates a temporary variable whose initializer optionally evaluates that expression.  <a href="#8b8089083afe0aca12b1c9ba64d4ddc6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ef8223b9741c08bb50c4ee85e04bbe16">appendArg</a> (<a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a> *, <a class="el" href="classSgInitializedName.html">SgInitializedName</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an argument to <a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a>, transparently set parent,scope, and symbols for arguments when possible.  <a href="#ef8223b9741c08bb50c4ee85e04bbe16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e997b353e050f84a2e1663e2b0945efa">prependArg</a> (<a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a> *, <a class="el" href="classSgInitializedName.html">SgInitializedName</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepend an argument to <a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a>.  <a href="#e997b353e050f84a2e1663e2b0945efa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e81668e6c7307d8cc9ad38de73282102">appendExpression</a> (<a class="el" href="classSgExprListExp.html">SgExprListExp</a> *, <a class="el" href="classSgExpression.html">SgExpression</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an expression to a <a class="el" href="classSgExprListExp.html">SgExprListExp</a>, set the parent pointer also.  <a href="#e81668e6c7307d8cc9ad38de73282102"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#19c6d987024cdb9c93f33181928beaff">appendExpressionList</a> (<a class="el" href="classSgExprListExp.html">SgExprListExp</a> *, const std::vector&lt; <a class="el" href="classSgExpression.html">SgExpression</a> * &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an expression list to a <a class="el" href="classSgExprListExp.html">SgExprListExp</a>, set the parent pointers also.  <a href="#19c6d987024cdb9c93f33181928beaff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e4200b6d287e2c5b2d7a4d382f110863">setParameterList</a> (<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *func, <a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a> *paralist)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set parameter list for a function declaration, considering existing parameter list etc.  <a href="#e4200b6d287e2c5b2d7a4d382f110863"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#60d9ec8400d43be2985ea888afb69989">setPragma</a> (<a class="el" href="classSgPragmaDeclaration.html">SgPragmaDeclaration</a> *decl, <a class="el" href="classSgPragma.html">SgPragma</a> *pragma)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a pragma of a pragma declaration. handle memory release for preexisting pragma, and set parent pointer.  <a href="#60d9ec8400d43be2985ea888afb69989"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ba697ba095a90c110e020e411fd8158f">replaceExpression</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *oldExp, <a class="el" href="classSgExpression.html">SgExpression</a> *newExp, bool keepOldExp=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace an expression with another, used for variable reference substitution and others. the old expression can be deleted (default case) or kept.  <a href="#ba697ba095a90c110e020e411fd8158f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d85460fd6c32e78e4dda28984b0ab541">replaceExpressionWithStatement</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *from, <a class="el" href="classSageInterface_1_1StatementGenerator.html">SageInterface::StatementGenerator</a> *to)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace a given expression with a list of statements produced by a generator.  <a href="#d85460fd6c32e78e4dda28984b0ab541"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c8ce4794f2e0212a315bceb252fe93f2">replaceSubexpressionWithStatement</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *from, <a class="el" href="classSageInterface_1_1StatementGenerator.html">SageInterface::StatementGenerator</a> *to)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to replaceExpressionWithStatement, but with more restrictions.  <a href="#c8ce4794f2e0212a315bceb252fe93f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#abfd7a4f3af02dea61f7f808d0e60783">setOperand</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *target, <a class="el" href="classSgExpression.html">SgExpression</a> *operand)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set operands for expressions with single operand, such as unary expressions. handle file info, lvalue, pointer downcasting, parent pointer etc.  <a href="#abfd7a4f3af02dea61f7f808d0e60783"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#78098fceed35539df0aa51de3baba983">setLhsOperand</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *target, <a class="el" href="classSgExpression.html">SgExpression</a> *lhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set left hand operand for binary expressions, transparently downcasting target expressions when necessary  <a href="#78098fceed35539df0aa51de3baba983"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c30b58bb417c3b495f24207c81966716">setRhsOperand</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *target, <a class="el" href="classSgExpression.html">SgExpression</a> *rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set left hand operand for binary expression  <a href="#c30b58bb417c3b495f24207c81966716"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#76cf388fb6b43807542edf737bb97a96">removeAllOriginalExpressionTrees</a> (<a class="el" href="classSgNode.html">SgNode</a> *top)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set original expression trees to NULL for <a class="el" href="classSgValueExp.html">SgValueExp</a> or <a class="el" href="classSgCastExp.html">SgCastExp</a> expressions, so you can change the value and have it unparsed correctly.  <a href="#76cf388fb6b43807542edf737bb97a96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e348901720d34fdb3f333e552bcd5253">moveToSubdirectory</a> (std::string directoryName, <a class="el" href="classSgFile.html">SgFile</a> *file)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move file to be generated in a subdirectory (will be generated by the unparser).  <a href="#e348901720d34fdb3f333e552bcd5253"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#5b68578da4f96a5e644cfcb129a7e3dd">findSurroundingStatementFromSameFile</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *targetStmt, bool &amp;surroundingStatementPreceedsTargetStatement)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Supporting function to comment relocation in <a class="el" href="namespaceSageInterface.html#54e6780cc15a76ce7bc37a1212452e66">insertStatement()</a> and <a class="el" href="namespaceSageInterface.html#f5972a33cb2e9b5723e50ceccdaccb9f">removeStatement()</a>.  <a href="#5b68578da4f96a5e644cfcb129a7e3dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#accbb223ed5b025766c10745793d39c6">moveCommentsToNewStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *sourceStatement, const std::vector&lt; int &gt; &amp;indexList, <a class="el" href="classSgStatement.html">SgStatement</a> *targetStatement, bool surroundingStatementPreceedsTargetStatement)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Relocate comments and CPP directives from one statement to another.  <a href="#accbb223ed5b025766c10745793d39c6"></a><br></td></tr>
<tr><td colspan="2"><br><h2>AST repair, fix, and postprocessing.</h2></td></tr>
<tr><td colspan="2">Mostly used internally when some AST pieces are built without knowing their target scope/parent, especially during bottom-up construction of AST. The associated symbols, parent and scope pointers cannot be set on construction then. A set of utility functions are provided to patch up scope, parent, symbol for them when the target scope/parent become know. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#bc07365980c33e6d4f3cca65b2e73970">fixVariableReferences</a> (<a class="el" href="classSgNode.html">SgNode</a> *root)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect variable reference to the right variable symbols when feasible, return the number of references being fixed.  <a href="#bc07365980c33e6d4f3cca65b2e73970"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c56e358f18815a86ca4c9ad738733d37">fixVariableDeclaration</a> (<a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *varDecl, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Patch up symbol, scope, and parent information when a SgVariableDeclaration's scope is known.  <a href="#c56e358f18815a86ca4c9ad738733d37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#198dfdbeffb7cb4e282c0045de88b29d">fixStructDeclaration</a> (<a class="el" href="classSgClassDeclaration.html">SgClassDeclaration</a> *structDecl, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fix symbols, parent and scope pointers. Used internally within appendStatment(), <a class="el" href="namespaceSageInterface.html#54e6780cc15a76ce7bc37a1212452e66">insertStatement()</a> etc when a struct declaration was built without knowing its target scope.  <a href="#198dfdbeffb7cb4e282c0045de88b29d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4e2216ac11843189037ddb386cadbe9f">fixClassDeclaration</a> (<a class="el" href="classSgClassDeclaration.html">SgClassDeclaration</a> *classDecl, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fix symbols, parent and scope pointers. Used internally within appendStatment(), <a class="el" href="namespaceSageInterface.html#54e6780cc15a76ce7bc37a1212452e66">insertStatement()</a> etc when a class declaration was built without knowing its target scope.  <a href="#4e2216ac11843189037ddb386cadbe9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#0605947f38a73309b695c2511a6a008b">fixNamespaceDeclaration</a> (<a class="el" href="classSgNamespaceDeclarationStatement.html">SgNamespaceDeclarationStatement</a> *structDecl, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fix symbols, parent and scope pointers. Used internally within appendStatment(), <a class="el" href="namespaceSageInterface.html#54e6780cc15a76ce7bc37a1212452e66">insertStatement()</a> etc when a namespace declaration was built without knowing its target scope.  <a href="#0605947f38a73309b695c2511a6a008b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d8449795585ef098dedd58658b4ea265">fixLabelStatement</a> (<a class="el" href="classSgLabelStatement.html">SgLabelStatement</a> *label_stmt, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fix symbol table for <a class="el" href="classSgLabelStatement.html">SgLabelStatement</a>. Used Internally when the label is built without knowing its target scope. Both parameters cannot be NULL.  <a href="#d8449795585ef098dedd58658b4ea265"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#221ee5cf1957c22f8e37d2fa1ab96c68">setFortranNumericLabel</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, int label_value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a numerical label for a Fortran statement. The statement should have a enclosing function definition already. <a class="el" href="classSgLabelSymbol.html">SgLabelSymbol</a> and <a class="el" href="classSgLabelRefExp.html">SgLabelRefExp</a> are created transparently as needed.  <a href="#221ee5cf1957c22f8e37d2fa1ab96c68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#79b07f8a7d66fc51a0648df2940a5bf4">suggestNextNumericLabel</a> (<a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *func_def)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suggest next usable (non-conflicting) numeric label value for a Fortran function definition scope.  <a href="#79b07f8a7d66fc51a0648df2940a5bf4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#2410a8e2fc7310bd63c24d10b91594a3">fixStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A wrapper containing fixes (<a class="el" href="namespaceSageInterface.html#c56e358f18815a86ca4c9ad738733d37">fixVariableDeclaration()</a>,<a class="el" href="namespaceSageInterface.html#198dfdbeffb7cb4e282c0045de88b29d">fixStructDeclaration()</a>, <a class="el" href="namespaceSageInterface.html#d8449795585ef098dedd58658b4ea265">fixLabelStatement()</a>, etc) for all kinds statements. Should be used before attaching the statement into AST.  <a href="#2410a8e2fc7310bd63c24d10b91594a3"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Advanced AST transformations, analyses, and optimizations</h2></td></tr>
<tr><td colspan="2">Some complex but commonly used AST transformations. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#2f9dadd01d12ecdc779071da95843b83">collectReadWriteRefs</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, std::vector&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt; &amp;readRefs, std::vector&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt; &amp;writeRefs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collect all read and write references within stmt, which can be a function, a scope statement, or a single statement. Note that a reference can be both read and written, like i++.  <a href="#2f9dadd01d12ecdc779071da95843b83"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#11498284f603a3a574f02df0f44216b8">collectReadWriteVariables</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, std::set&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt; &amp;readVars, std::set&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt; &amp;writeVars)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collect unique variables which are read or written within a statement. Note that a variable can be both read and written. The statement can be either of a function, a scope, or a single line statement.  <a href="#11498284f603a3a574f02df0f44216b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#3dc3524267c97a90f85d723b462e4e8a">collectReadOnlyVariables</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, std::set&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt; &amp;readOnlyVars)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collect read only variables within a statement. The statement can be either of a function, a scope, or a single line statement.  <a href="#3dc3524267c97a90f85d723b462e4e8a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#7b50fd79f9c2175fea1fcfd8d66e8a7d">collectReadOnlySymbols</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, std::set&lt; <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> * &gt; &amp;readOnlySymbols)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collect read only variable symbols within a statement. The statement can be either of a function, a scope, or a single line statement.  <a href="#7b50fd79f9c2175fea1fcfd8d66e8a7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b854982b76a15a37881e460327d45b63">isUseByAddressVariableRef</a> (<a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> *ref)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a variable reference is used by its address: including &amp;a expression and foo(a) when type2 foo(Type&amp; parameter) in C++.  <a href="#b854982b76a15a37881e460327d45b63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#cff1c2e7a141a6360ad735dbe7d4dec8">collectUseByAddressVariableRefs</a> (const <a class="el" href="classSgStatement.html">SgStatement</a> *s, std::set&lt; <a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> * &gt; &amp;varSetB)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collect variable references involving use by address: including &amp;a expression and foo(a) when type2 foo(Type&amp; parameter) in C++.  <a href="#cff1c2e7a141a6360ad735dbe7d4dec8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LivenessAnalysis *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#d0fbd473b56e24b39b63f354b7dd61a1">call_liveness_analysis</a> (<a class="el" href="classSgProject.html">SgProject</a> *<a class="el" href="namespacecfgUtils.html#ce4abf2beca5826144d69d3a0283050f">project</a>, bool debug=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call liveness analysis on an entire project.  <a href="#d0fbd473b56e24b39b63f354b7dd61a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#7f94ad31631659aacacfe540a97bcb11">getLiveVariables</a> (LivenessAnalysis *liv, <a class="el" href="classSgForStatement.html">SgForStatement</a> *loop, std::set&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt; &amp;liveIns, std::set&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt; &amp;liveOuts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get liveIn and liveOut variables for a for loop from liveness analysis result liv.  <a href="#7f94ad31631659aacacfe540a97bcb11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a3155e7a4a833e87637709baecd5638d">ReductionRecognition</a> (<a class="el" href="classSgForStatement.html">SgForStatement</a> *loop, std::set&lt; std::pair&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> *, <a class="el" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a> &gt; &gt; &amp;results)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recognize and collect reduction variables and operations within a C/C++ loop, following OpenMP 3.0 specification for allowed reduction variable types and operation types.  <a href="#a3155e7a4a833e87637709baecd5638d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#6f1a171284027fd38c91507a33a12023">constantFolding</a> (<a class="el" href="classSgNode.html">SgNode</a> *r)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant folding an AST subtree rooted at 'r' (replacing its children with their constant values, if applicable). Please be advised that constant folding on floating point computation may decrease the accuracy of floating point computations!  <a href="#6f1a171284027fd38c91507a33a12023"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4087541939de003c4cfb4a51e8ae4737">instrumentEndOfFunction</a> (<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *func, <a class="el" href="classSgStatement.html">SgStatement</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instrument(Add a statement, often a function call) into a function right before the return points, handle multiple return statements and return expressions with side effects. Return the number of statements inserted.  <a href="#4087541939de003c4cfb4a51e8ae4737"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b3b17e2ceead1e6fcbe2671d795859e0">removeJumpsToNextStatement</a> (<a class="el" href="classSgNode.html">SgNode</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove jumps whose label is immediately after the jump. Used to clean up inlined code fragments.  <a href="#b3b17e2ceead1e6fcbe2671d795859e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#1cf3641ce21620223f92f3b00477a50b">removeUnusedLabels</a> (<a class="el" href="classSgNode.html">SgNode</a> *top)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove labels which are not targets of any goto statements.  <a href="#1cf3641ce21620223f92f3b00477a50b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e674125d5affe065c68f6540217b544c">removeConsecutiveLabels</a> (<a class="el" href="classSgNode.html">SgNode</a> *top)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove consecutive labels.  <a href="#e674125d5affe065c68f6540217b544c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgAssignInitializer.html">SgAssignInitializer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#9a28f3454dc1161d208d0eafa27267d5">splitExpression</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *from, std::string newName=&quot;&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace an expression with a temporary variable and an assignment statement.  <a href="#9a28f3454dc1161d208d0eafa27267d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c6a4105eaf9ecae213078b24d5dfc69f">splitExpressionIntoBasicBlock</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *expr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split long expressions into blocks of statements.  <a href="#c6a4105eaf9ecae213078b24d5dfc69f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#72277a774aaa30427c7ba19a5ae0e64e">removeLabeledGotos</a> (<a class="el" href="classSgNode.html">SgNode</a> *top)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove labeled goto statements.  <a href="#72277a774aaa30427c7ba19a5ae0e64e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#2e6c3a91ffcb6a4a8e0a26dd39170498">changeBreakStatementsToGotos</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *loopOrSwitch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the given statement contains any break statements in its body, add a new label below the statement and change the breaks into gotos to that new label.  <a href="#2e6c3a91ffcb6a4a8e0a26dd39170498"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a9363b5ef0fa341b6a69f3143010d03f">ensureBasicBlockAsBodyOfFor</a> (<a class="el" href="classSgForStatement.html">SgForStatement</a> *fs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the body of a 'for' statement is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not.  <a href="#a9363b5ef0fa341b6a69f3143010d03f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4b91f29c299fd9d36d23215caca641a9">ensureBasicBlockAsBodyOfUpcForAll</a> (<a class="el" href="classSgUpcForAllStatement.html">SgUpcForAllStatement</a> *fs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the body of a 'upc_forall' statement is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not.  <a href="#4b91f29c299fd9d36d23215caca641a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b420709b668cbcb97caaa2ba7a311047">ensureBasicBlockAsBodyOfWhile</a> (<a class="el" href="classSgWhileStmt.html">SgWhileStmt</a> *ws)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the body of a 'while' statement is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not.  <a href="#b420709b668cbcb97caaa2ba7a311047"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#10f7e44426ec5cc6cf4878a9f8f3737b">ensureBasicBlockAsBodyOfDoWhile</a> (<a class="el" href="classSgDoWhileStmt.html">SgDoWhileStmt</a> *ws)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the body of a 'do .. while' statement is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not.  <a href="#10f7e44426ec5cc6cf4878a9f8f3737b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#2ee0c40fe00b9aa2e33f07a1f63d1c78">ensureBasicBlockAsBodyOfSwitch</a> (<a class="el" href="classSgSwitchStatement.html">SgSwitchStatement</a> *ws)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the body of a 'switch' statement is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not.  <a href="#2ee0c40fe00b9aa2e33f07a1f63d1c78"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#5dddc30ac598e407d4b675b48817321a">ensureBasicBlockAsTrueBodyOfIf</a> (<a class="el" href="classSgIfStmt.html">SgIfStmt</a> *ifs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the true body of a 'if' statement is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not.  <a href="#5dddc30ac598e407d4b675b48817321a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a0d91d1274666339221f3186847d220a">ensureBasicBlockAsFalseBodyOfIf</a> (<a class="el" href="classSgIfStmt.html">SgIfStmt</a> *ifs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the false body of a 'if' statement is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not.  <a href="#a0d91d1274666339221f3186847d220a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#273d390c4b54e9dc4c02c4806b3747a5">ensureBasicBlockAsBodyOfCatch</a> (<a class="el" href="classSgCatchOptionStmt.html">SgCatchOptionStmt</a> *cos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the body of a 'catch' statement is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not.  <a href="#273d390c4b54e9dc4c02c4806b3747a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#0434e3f30f7426d0ff371c936b2f1e5e">ensureBasicBlockAsBodyOfOmpBodyStmt</a> (<a class="el" href="classSgOmpBodyStatement.html">SgOmpBodyStatement</a> *ompbodyStmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the body of a <a class="el" href="classSgOmpBodyStatement.html">SgOmpBodyStatement</a> is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not.  <a href="#0434e3f30f7426d0ff371c936b2f1e5e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a72050df89f2aa4351288454d544b695">isBodyStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a statement is a (true or false) body of a container-like parent, such as For, Upc_forall, Do-while, switch, If, Catch, OmpBodyStmt, etc.  <a href="#a72050df89f2aa4351288454d544b695"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#f052fc07989bd2870022a0aa4f075d53">changeAllBodiesToBlocks</a> (<a class="el" href="classSgNode.html">SgNode</a> *top)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fix up ifs, loops, while, switch, Catch, OmpBodyStatement, etc. to have blocks as body components. It also adds an empty else body to if statements that don't have them.  <a href="#f052fc07989bd2870022a0aa4f075d53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#fd793e1727df3c73fbd8384ccc604272">changeAllLoopBodiesToBlocks</a> (<a class="el" href="classSgNode.html">SgNode</a> *top)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The same as <a class="el" href="namespaceSageInterface.html#f052fc07989bd2870022a0aa4f075d53">changeAllBodiesToBlocks(SgNode* top)</a>. To be phased out.  <a href="#fd793e1727df3c73fbd8384ccc604272"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#f3cb2f040226ce2af1234b4e94a60d15">makeSingleStatementBodyToBlock</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *singleStmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a single statement body to be a basic block. Its parent is if, while, catch, or upc_forall etc.  <a href="#f3cb2f040226ce2af1234b4e94a60d15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned long long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#7c34b2c7c9c66106eb13c6d253217b5e">getIntegerConstantValue</a> (<a class="el" href="classSgValueExp.html">SgValueExp</a> *expr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the constant value from a constant integer expression; abort on everything else.  <a href="#7c34b2c7c9c66106eb13c6d253217b5e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#318f7cf455f620d5deecb5f37d41f4fe">getDependentDeclarations</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a statement's dependent declarations which declares the types used in the statement. The returned vector of declaration statements are sorted according to their appearance order in the original AST. Any reference to a class or template class from a namespace will treated as a reference to the enclosing namespace.  <a href="#318f7cf455f620d5deecb5f37d41f4fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgCommaOpExp.html">SgCommaOpExp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#88ea6b1684ee9c306a48e10e8a13910b">insertBeforeUsingCommaOp</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *new_exp, <a class="el" href="classSgExpression.html">SgExpression</a> *anchor_exp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert an expression (new_exp )before another expression (anchor_exp) has possible side effects, without changing the original semantics. This is achieved by using a comma operator: (new_exp, anchor_exp). The comma operator is returned.  <a href="#88ea6b1684ee9c306a48e10e8a13910b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgCommaOpExp.html">SgCommaOpExp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#57851892650845148e67407bf2389fd2">insertAfterUsingCommaOp</a> (<a class="el" href="classSgExpression.html">SgExpression</a> *new_exp, <a class="el" href="classSgExpression.html">SgExpression</a> *anchor_exp, <a class="el" href="classSgStatement.html">SgStatement</a> **temp_decl=NULL, <a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> **temp_ref=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert an expression (new_exp ) after another expression (anchor_exp) has possible side effects, without changing the original semantics. This is done by using two comma operators: type T1; ... ((T1 = anchor_exp, new_exp),T1) )... , where T1 is a temp variable saving the possible side effect of anchor_exp. The top level comma op exp is returned. The reference to T1 in T1 = anchor_exp is saved in temp_ref.  <a href="#57851892650845148e67407bf2389fd2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt; <a class="el" href="classSgStatement.html">SgStatement</a> *,<br>
 <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#db9d4a03d11809413cca4cac1dfc18a7">wrapFunction</a> (<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> &amp;definingDeclaration, <a class="el" href="classSgName.html">SgName</a> newName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">moves the body of a function f to a new function f`; f's body is replaced with code that forwards the call to f`.  <a href="#db9d4a03d11809413cca4cac1dfc18a7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class NameGen&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::pair&lt; <a class="el" href="classSgStatement.html">SgStatement</a> *,<br>
 <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#10d65c1ab5842a8ecb88b24abf0b562c">wrapFunction</a> (<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> &amp;definingDeclaration, NameGen nameGen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  NameGen functor that generates a new name based on the old name.see wrapFunction for details.  <a href="#10d65c1ab5842a8ecb88b24abf0b562c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgInitializedName.html">SgInitializedName</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e1fae2ae93d70efe722d0bde9473842e">getFirstVariable</a> (<a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> &amp;vardecl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">convenience function that returns the first initialized name in a list of variable declarations.  <a href="#e1fae2ae93d70efe722d0bde9473842e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef bool(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a50192df1669445c680604f06a73e865">EquivalenceTestFunctionType</a> (<a class="el" href="classSgNode.html">SgNode</a> *x, <a class="el" href="classSgNode.html">SgNode</a> *y)</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#a6670cd18aab211b99ab001c9e150575">getMainInterpretation</a> (<a class="el" href="classSgAsmGenericFile.html">SgAsmGenericFile</a> *file)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#20574ec78dea1f96ddfc689dcd6da9be">getAsmConstant</a> (<a class="el" href="classSgAsmValueExpression.html">SgAsmValueExpression</a> *e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the unsigned value of a disassembled constant.  <a href="#20574ec78dea1f96ddfc689dcd6da9be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#789ac1ef29111e96bf87fbd789dea421">getAsmSignedConstant</a> (<a class="el" href="classSgAsmValueExpression.html">SgAsmValueExpression</a> *e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the signed value of a disassembled constant.  <a href="#789ac1ef29111e96bf87fbd789dea421"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#21d19eaa21c197ce5c65363d225eb31d">addMessageStatement</a> (<a class="el" href="classSgStatement.html">SgStatement</a> *stmt, std::string message)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classFunction.html">Function</a> to add "C" style comment to statement.  <a href="#21d19eaa21c197ce5c65363d225eb31d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#732c7df1845f9c11495227cd9fa9e1e1">supplementReplacementSymbolMap</a> (rose_hash::unordered_map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, <a class="el" href="classSgNode.html">SgNode</a> *, <a class="el" href="structSageInterface_1_1hash__nodeptr.html">hash_nodeptr</a> &gt; &amp;inputReplacementMap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#7ee71882b367869506de6382d1b09cc2">updateDefiningNondefiningLinks</a> (<a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *func, <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *scope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update defining and nondefining links due to a newly introduced function declaration. Should be used after inserting the function into a scope.  <a href="#7ee71882b367869506de6382d1b09cc2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#4cc95056575d01624ccf78ebc97329f5">addComment</a> (<a class="el" href="classSgAsmStatement.html">SgAsmStatement</a> *stmt, const std::string &amp;input_string)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgAsmElfSection.html">SgAsmElfSection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#f022306442b888ef3560632bd5697dff">getSection</a> (<a class="el" href="classSgProject.html">SgProject</a> *<a class="el" href="namespacecfgUtils.html#ce4abf2beca5826144d69d3a0283050f">project</a>, const std::string &amp;name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgAsmElfSection.html">SgAsmElfSection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#6fafc25ba006fd7d16a89e9e4ecadbc3">getSection</a> (<a class="el" href="classSgProject.html">SgProject</a> *<a class="el" href="namespacecfgUtils.html#ce4abf2beca5826144d69d3a0283050f">project</a>, size_t ptr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgAsmFunction.html">SgAsmFunction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#5231e81126bc1969adf6fb100232ffb3">getAsmFunction</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *asmInstruction)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Traverses AST backwards up the tree along the "parent" edges to the <a class="el" href="classSgAsmFunction.html">SgAsmFunction</a>.  <a href="#5231e81126bc1969adf6fb100232ffb3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#747672ac53143bd77488c68e2ae1ea1e">getAsmBlock</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *asmInstruction)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Traverses AST backwards up the tree along the "parent" edges to the <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a>.  <a href="#747672ac53143bd77488c68e2ae1ea1e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#22f9e8f6fd5bc4fc436dce42f021eab0">getAsmInterpretation</a> (<a class="el" href="classSgAsmNode.html">SgAsmNode</a> *asmNode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Traverses AST backwards up the tree along the "parent" edges to the <a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a>.  <a href="#22f9e8f6fd5bc4fc436dce42f021eab0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#80f931189467b0b8a729ae2459aa848c">generateUniqueName</a> (size_t value, std::map&lt; size_t, int &gt; &amp;usedOffsets, size_t &amp;counter)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#1eafc1e4f7e80b8ab1a85c5ab6dffe5d">get_value</a> (<a class="el" href="classSgAsmValueExpression.html">SgAsmValueExpression</a> *asmValueExpression)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#1ac67db23cd773335d146e4d4533e0cd">get_valueString</a> (<a class="el" href="classSgAsmValueExpression.html">SgAsmValueExpression</a> *asmValueExpression)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c8ebd3d59d51a1060d98ce48a0c84d0a">isMovInstruction</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *asmInstruction)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#fb2b29d4031efe33cd50f5ac4748b6c4">isInstructionKind</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *asmInstruction, <a class="el" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571">X86InstructionKind</a> instuctionKind)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#bd5aab398d3e64ceaa6f8174470b7279">equivalenceTest</a> (<a class="el" href="classSgNode.html">SgNode</a> *x, <a class="el" href="classSgNode.html">SgNode</a> *y)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#b2e4624607ed5657fc31c021297694d1">flattenAST</a> (<a class="el" href="classSgNode.html">SgNode</a> *node)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#6b77bd20707c195fd34c8337bb77c234">matchAST</a> (<a class="el" href="classSgNode.html">SgNode</a> *node, std::vector&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt; &amp;listOfNodes, <a class="el" href="namespaceSageInterface.html#a50192df1669445c680604f06a73e865">EquivalenceTestFunctionType</a> equivalenceTest)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#ff5394b21cf11cd338671af3a11a7f92">find</a> (<a class="el" href="classSgNode.html">SgNode</a> *astNode, <a class="el" href="classSgNode.html">SgNode</a> *target, <a class="el" href="namespaceSageInterface.html#a50192df1669445c680604f06a73e865">EquivalenceTestFunctionType</a> equivalenceTest)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#414a9168eee41e2f7d7d247c3a49fd4e">isNOP</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *asmInstruction)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test an instruction for if it has no side-effect to the state (is so then it is a NOP). This is a more general test than if it is equivelent to the NOP memonic instruction.  <a href="#414a9168eee41e2f7d7d247c3a49fd4e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#de96f92f0e96eb8ebabb9220a84e6b4d">isNOP</a> (const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;asmInstructionList)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test a sequence of instructions for it they (as a set) have no side-effects to the state (is so then it is a NOP sequence).  <a href="#de96f92f0e96eb8ebabb9220a84e6b4d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; std::vector&lt;<br>
 <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#05bfe1145092f64638002356588ee5ab">find_NOP_sequences</a> (<a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *asmBlock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">find sequences of NOP instructions in a <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a>  <a href="#05bfe1145092f64638002356588ee5ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#1f1f75a3456361008d4e02ec102d5663">insertInstruction</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *targetInstruction, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *newInstruction, bool insertBefore)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Support for insertion of instruction relative to a target instruction.  <a href="#1f1f75a3456361008d4e02ec102d5663"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#e8257295538bc5792f543719660d08db">insertInstructionBefore</a> (<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *targetInstruction, <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *newInstruction)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a instruction before a target instruction.  <a href="#e8257295538bc5792f543719660d08db"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#cf2e80d430cfcbbb6165adbd6bd0e471">removeInstruction</a> (<a class="el" href="classSgAsmStatement.html">SgAsmStatement</a> *instruction)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a instruction.  <a href="#cf2e80d430cfcbbb6165adbd6bd0e471"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSageInterface.html#c634a179b840b4d55d9b32e0288fb1b4">gensym_counter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An internal counter for generating unique <a class="el" href="classSgName.html">SgName</a>.  <a href="#c634a179b840b4d55d9b32e0288fb1b4"></a><br></td></tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="a50192df1669445c680604f06a73e865"></a><!-- doxytag: member="SageInterface::EquivalenceTestFunctionType" ref="a50192df1669445c680604f06a73e865" args="(SgNode *x, SgNode *y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(*) <a class="el" href="namespaceSageInterface.html#a50192df1669445c680604f06a73e865">SageInterface::EquivalenceTestFunctionType</a>(<a class="el" href="classSgNode.html">SgNode</a> *x, <a class="el" href="classSgNode.html">SgNode</a> *y)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="sageInterfaceAsm_8h-source.html#l00036">36</a> of file <a class="el" href="sageInterfaceAsm_8h-source.html">sageInterfaceAsm.h</a>.
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a6670cd18aab211b99ab001c9e150575"></a><!-- doxytag: member="SageInterface::getMainInterpretation" ref="a6670cd18aab211b99ab001c9e150575" args="(SgAsmGenericFile *file)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a>* SageInterface::getMainInterpretation           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmGenericFile.html">SgAsmGenericFile</a> *&nbsp;</td>
          <td class="paramname"> <em>file</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="20574ec78dea1f96ddfc689dcd6da9be"></a><!-- doxytag: member="SageInterface::getAsmConstant" ref="20574ec78dea1f96ddfc689dcd6da9be" args="(SgAsmValueExpression *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t SageInterface::getAsmConstant           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmValueExpression.html">SgAsmValueExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>e</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the unsigned value of a disassembled constant. 
<p>

<p>
Referenced by <a class="el" href="SgAsmPowerpcInstruction_8C-source.html#l00009">SgAsmPowerpcInstruction::get_successors()</a>, <a class="el" href="SgAsmArmInstruction_8C-source.html#l00076">SgAsmArmInstruction::get_successors()</a>, <a class="el" href="unparseArmAsm_8C-source.html#l00063">unparseArmExpression()</a>, and <a class="el" href="unparsePowerpcAsm_8C-source.html#l00034">unparsePowerpcExpression()</a>.
</div>
</div><p>
<a class="anchor" name="789ac1ef29111e96bf87fbd789dea421"></a><!-- doxytag: member="SageInterface::getAsmSignedConstant" ref="789ac1ef29111e96bf87fbd789dea421" args="(SgAsmValueExpression *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t SageInterface::getAsmSignedConstant           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmValueExpression.html">SgAsmValueExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>e</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the signed value of a disassembled constant. 
<p>

<p>
Referenced by <a class="el" href="x86InstructionSemantics_8h-source.html#l00504">BinaryAnalysis::InstructionSemantics::X86InstructionSemantics&lt; Policy, WordType &gt;::Word()</a>.
</div>
</div><p>
<a class="anchor" name="21d19eaa21c197ce5c65363d225eb31d"></a><!-- doxytag: member="SageInterface::addMessageStatement" ref="21d19eaa21c197ce5c65363d225eb31d" args="(SgStatement *stmt, std::string message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::addMessageStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>message</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classFunction.html">Function</a> to add "C" style comment to statement. 
<p>

</div>
</div><p>
<a class="anchor" name="732c7df1845f9c11495227cd9fa9e1e1"></a><!-- doxytag: member="SageInterface::supplementReplacementSymbolMap" ref="732c7df1845f9c11495227cd9fa9e1e1" args="(rose_hash::unordered_map&lt; SgNode *, SgNode *, hash_nodeptr &gt; &amp;inputReplacementMap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::supplementReplacementSymbolMap           </td>
          <td>(</td>
          <td class="paramtype">rose_hash::unordered_map&lt; <a class="el" href="classSgNode.html">SgNode</a> *, <a class="el" href="classSgNode.html">SgNode</a> *, hash_nodeptr &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>inputReplacementMap</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="10bd491911b4d8d441c2b0f8d8542f50"></a><!-- doxytag: member="SageInterface::lookupVariableSymbolInParentScopes" ref="10bd491911b4d8d441c2b0f8d8542f50" args="(const SgName &amp;name, SgScopeStatement *currentScope=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a>* SageInterface::lookupVariableSymbolInParentScopes           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgName.html">SgName</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>currentScope</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="fbbf691f4ff947b83e93db1e9622a5a3"></a><!-- doxytag: member="SageInterface::lookupSymbolInParentScopes" ref="fbbf691f4ff947b83e93db1e9622a5a3" args="(const SgName &amp;name, SgScopeStatement *currentScope=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgSymbol.html">SgSymbol</a>* SageInterface::lookupSymbolInParentScopes           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgName.html">SgName</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>currentScope</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find a symbol in current and ancestor scopes for a given variable name, starting from top of ScopeStack if currentscope is not given or NULL. 
<p>

</div>
</div><p>
<a class="anchor" name="c149a8d976bc90e89fed4d9d6cd3f34a"></a><!-- doxytag: member="SageInterface::lookupFunctionSymbolInParentScopes" ref="c149a8d976bc90e89fed4d9d6cd3f34a" args="(const SgName &amp;functionName, SgScopeStatement *currentScope=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgFunctionSymbol.html">SgFunctionSymbol</a>* SageInterface::lookupFunctionSymbolInParentScopes           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgName.html">SgName</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>functionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>currentScope</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
look up the first matched function symbol in parent scopes given only a function name, starting from top of ScopeStack if currentscope is not given or NULL 
<p>

</div>
</div><p>
<a class="anchor" name="6e0623b84a44ff5e85dd6334e199f418"></a><!-- doxytag: member="SageInterface::lookupFunctionSymbolInParentScopes" ref="6e0623b84a44ff5e85dd6334e199f418" args="(const SgName &amp;functionName, const SgType *t, SgScopeStatement *currentScope=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgFunctionSymbol.html">SgFunctionSymbol</a>* SageInterface::lookupFunctionSymbolInParentScopes           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgName.html">SgName</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>functionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>currentScope</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
look up function symbol in parent scopes given both name and function type, starting from top of ScopeStack if currentscope is not given or NULL 
<p>

</div>
</div><p>
<a class="anchor" name="4d0c71bada31301e6bd1a569965cdad6"></a><!-- doxytag: member="SageInterface::lookupClassSymbolInParentScopes" ref="4d0c71bada31301e6bd1a569965cdad6" args="(const SgName &amp;name, SgScopeStatement *currentScope=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgClassSymbol.html">SgClassSymbol</a>* SageInterface::lookupClassSymbolInParentScopes           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgName.html">SgName</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>currentScope</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f2272608021e9538be091a4f23ecfc6b"></a><!-- doxytag: member="SageInterface::lookupTypedefSymbolInParentScopes" ref="f2272608021e9538be091a4f23ecfc6b" args="(const SgName &amp;name, SgScopeStatement *currentScope=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgTypedefSymbol.html">SgTypedefSymbol</a>* SageInterface::lookupTypedefSymbolInParentScopes           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgName.html">SgName</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>currentScope</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="15bf8b9e0d05ab2441dfab12f4e0b8af"></a><!-- doxytag: member="SageInterface::lookupTemplateSymbolInParentScopes" ref="15bf8b9e0d05ab2441dfab12f4e0b8af" args="(const SgName &amp;name, SgScopeStatement *currentScope=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgTemplateSymbol.html">SgTemplateSymbol</a>* SageInterface::lookupTemplateSymbolInParentScopes           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgName.html">SgName</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>currentScope</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c5944800817c61bf404f7948d0e9431c"></a><!-- doxytag: member="SageInterface::lookupEnumSymbolInParentScopes" ref="c5944800817c61bf404f7948d0e9431c" args="(const SgName &amp;name, SgScopeStatement *currentScope=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgEnumSymbol.html">SgEnumSymbol</a>* SageInterface::lookupEnumSymbolInParentScopes           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgName.html">SgName</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>currentScope</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="9f057986db266f3d6cc83fd8edbab917"></a><!-- doxytag: member="SageInterface::lookupNamespaceSymbolInParentScopes" ref="9f057986db266f3d6cc83fd8edbab917" args="(const SgName &amp;name, SgScopeStatement *currentScope=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgNamespaceSymbol.html">SgNamespaceSymbol</a>* SageInterface::lookupNamespaceSymbolInParentScopes           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgName.html">SgName</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>currentScope</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1bbf335d0e6ee069e94e73a62660b8da"></a><!-- doxytag: member="SageInterface::set_name" ref="1bbf335d0e6ee069e94e73a62660b8da" args="(SgInitializedName *initializedNameNode, SgName new_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SageInterface::set_name           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgInitializedName.html">SgInitializedName</a> *&nbsp;</td>
          <td class="paramname"> <em>initializedNameNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgName.html">SgName</a>&nbsp;</td>
          <td class="paramname"> <em>new_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
set_name of symbol in symbol table. 
<p>
This function extracts the symbol from the relavant symbol table, changes the name (at the declaration) and reinserts it into the symbol table.<p><b>For internal use only.</b></p>
<p>
I think this is what this function does, I need to double check. </p>

</div>
</div><p>
<a class="anchor" name="a3fbb86d0df5900f41a2b63a81b4355e"></a><!-- doxytag: member="SageInterface::outputGlobalFunctionTypeSymbolTable" ref="a3fbb86d0df5900f41a2b63a81b4355e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::outputGlobalFunctionTypeSymbolTable           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Output function type symbols in global function type symbol table. 
<p>

</div>
</div><p>
<a class="anchor" name="ab1b30cc17b041079ccd395c0f48d9a4"></a><!-- doxytag: member="SageInterface::outputLocalSymbolTables" ref="ab1b30cc17b041079ccd395c0f48d9a4" args="(SgNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::outputLocalSymbolTables           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Output the local symbol tables. 
<p>
Each symbol table is output with the file infor where it is located in the source code. 
</div>
</div><p>
<a class="anchor" name="f77c4adbf8e70c2904f5c95f80aa32b4"></a><!-- doxytag: member="SageInterface::rebuildSymbolTable" ref="f77c4adbf8e70c2904f5c95f80aa32b4" args="(SgScopeStatement *scope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::rebuildSymbolTable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Regenerate the symbol table. 
<p>
current symbol table must be NULL pointer before calling this function (for safety, but is this a good idea?) 
</div>
</div><p>
<a class="anchor" name="72448c95af84d803ee677e49650cec12"></a><!-- doxytag: member="SageInterface::clearUnusedVariableSymbols" ref="72448c95af84d803ee677e49650cec12" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::clearUnusedVariableSymbols           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear those variable symbols (together with initialized names) which are not referenced by any variable references or declarations. 
<p>

</div>
</div><p>
<a class="anchor" name="8dd3faa8aa1e1a39859ed2f4046db4c2"></a><!-- doxytag: member="SageInterface::fixupReferencesToSymbols" ref="8dd3faa8aa1e1a39859ed2f4046db4c2" args="(const SgScopeStatement *this_scope, SgScopeStatement *copy_scope, SgCopyHelp &amp;help)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::fixupReferencesToSymbols           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>this_scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>copy_scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgCopyHelp.html">SgCopyHelp</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>help</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
All the symbol table references in the copied AST need to be reset after rebuilding the copied scope's symbol table. 
<p>

</div>
</div><p>
<a class="anchor" name="d8c38176c2d0e4d2bc851e70007902f9"></a><!-- doxytag: member="SageInterface::get_name" ref="d8c38176c2d0e4d2bc851e70007902f9" args="(const SgNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::get_name           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate a useful name to describe the <a class="el" href="classSgNode.html">SgNode</a>. 
<p>
<p><b>For internal use only.</b></p>
<p>
default names are used for <a class="el" href="classSgNode.html">SgNode</a> objects that can not be associated with a name. </p>

<p>
Referenced by <a class="el" href="ElfSymbolVersion_8C-source.html#l00256">SgAsmElfSymverDefinedEntry::dump()</a>.
</div>
</div><p>
<a class="anchor" name="fcdc4bf692f0a99cf6c9f8dedd5dba0c"></a><!-- doxytag: member="SageInterface::get_name" ref="fcdc4bf692f0a99cf6c9f8dedd5dba0c" args="(const SgStatement *stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::get_name           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate a useful name to describe the declaration. 
<p>
<p><b>For internal use only.</b></p>
<p>
default names are used for declarations that can not be associated with a name. </p>

</div>
</div><p>
<a class="anchor" name="e041006d7194c3dcf1771905a310551f"></a><!-- doxytag: member="SageInterface::get_name" ref="e041006d7194c3dcf1771905a310551f" args="(const SgExpression *expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::get_name           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>expr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate a useful name to describe the expression. 
<p>
<p><b>For internal use only.</b></p>
<p>
default names are used for expressions that can not be associated with a name. </p>

</div>
</div><p>
<a class="anchor" name="4a139b6ee7628669382055c4e5cc4091"></a><!-- doxytag: member="SageInterface::get_name" ref="4a139b6ee7628669382055c4e5cc4091" args="(const SgDeclarationStatement *declaration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::get_name           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>declaration</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate a useful name to describe the declaration. 
<p>
<p><b>For internal use only.</b></p>
<p>
default names are used for declarations that can not be associated with a name. </p>

</div>
</div><p>
<a class="anchor" name="94a6b6ad81a1b4fe641ba34a6fa287fb"></a><!-- doxytag: member="SageInterface::get_name" ref="94a6b6ad81a1b4fe641ba34a6fa287fb" args="(const SgScopeStatement *scope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::get_name           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate a useful name to describe the scope. 
<p>
<p><b>For internal use only.</b></p>
<p>
default names are used for scope that cannot be associated with a name. </p>

</div>
</div><p>
<a class="anchor" name="215e9d46d141268e3b4841b6a4d105a1"></a><!-- doxytag: member="SageInterface::get_name" ref="215e9d46d141268e3b4841b6a4d105a1" args="(const SgSymbol *symbol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::get_name           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgSymbol.html">SgSymbol</a> *&nbsp;</td>
          <td class="paramname"> <em>symbol</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate a useful name to describe the <a class="el" href="classSgSymbol.html">SgSymbol</a>. 
<p>
<p><b>For internal use only.</b></p>
<p>
default names are used for <a class="el" href="classSgSymbol.html">SgSymbol</a> objects that cannot be associated with a name. </p>

</div>
</div><p>
<a class="anchor" name="a3dbafd1030e3d2995e938b98c9e8a34"></a><!-- doxytag: member="SageInterface::get_name" ref="a3dbafd1030e3d2995e938b98c9e8a34" args="(const SgType *type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::get_name           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate a useful name to describe the <a class="el" href="classSgType.html">SgType</a>. 
<p>
<p><b>For internal use only.</b></p>
<p>
default names are used for <a class="el" href="classSgType.html">SgType</a> objects that cannot be associated with a name. </p>

</div>
</div><p>
<a class="anchor" name="e5abb9bb7920c00cd4331354fc470049"></a><!-- doxytag: member="SageInterface::get_name" ref="e5abb9bb7920c00cd4331354fc470049" args="(const SgSupport *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::get_name           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgSupport.html">SgSupport</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate a useful name to describe the <a class="el" href="classSgSupport.html">SgSupport</a> IR node. 
<p>

</div>
</div><p>
<a class="anchor" name="1fb6f2b9749473b0efcbb19bfd8d019b"></a><!-- doxytag: member="SageInterface::get_name" ref="1fb6f2b9749473b0efcbb19bfd8d019b" args="(const SgLocatedNodeSupport *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::get_name           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgLocatedNodeSupport.html">SgLocatedNodeSupport</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate a useful name to describe the <a class="el" href="classSgLocatedNodeSupport.html">SgLocatedNodeSupport</a> IR node. 
<p>

</div>
</div><p>
<a class="anchor" name="571cc2dc63fcd697dcab3e43feb87dc2"></a><!-- doxytag: member="SageInterface::get_name" ref="571cc2dc63fcd697dcab3e43feb87dc2" args="(const SgC_PreprocessorDirectiveStatement *directive)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::get_name           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgC__PreprocessorDirectiveStatement.html">SgC_PreprocessorDirectiveStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>directive</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate a useful name to describe the <a class="el" href="classSgC__PreprocessorDirectiveStatement.html">SgC_PreprocessorDirectiveStatement</a> IR node. 
<p>

</div>
</div><p>
<a class="anchor" name="e80c3edde132b58538fe96a143a2f83d"></a><!-- doxytag: member="SageInterface::get_name" ref="e80c3edde132b58538fe96a143a2f83d" args="(const SgToken *token)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::get_name           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgToken.html">SgToken</a> *&nbsp;</td>
          <td class="paramname"> <em>token</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate a useful name to describe the <a class="el" href="classSgToken.html">SgToken</a> IR node. 
<p>

</div>
</div><p>
<a class="anchor" name="b5161d0357f41bada1b0528284efc66e"></a><!-- doxytag: member="SageInterface::getDefaultDestructor" ref="b5161d0357f41bada1b0528284efc66e" args="(SgClassDeclaration *classDeclaration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgMemberFunctionDeclaration.html">SgMemberFunctionDeclaration</a>* SageInterface::getDefaultDestructor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgClassDeclaration.html">SgClassDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>classDeclaration</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the default destructor from the class declaration. 
<p>

</div>
</div><p>
<a class="anchor" name="44d0f9a4a27a11112c175c114165c5bc"></a><!-- doxytag: member="SageInterface::getDefaultConstructor" ref="44d0f9a4a27a11112c175c114165c5bc" args="(SgClassDeclaration *classDeclaration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgMemberFunctionDeclaration.html">SgMemberFunctionDeclaration</a>* SageInterface::getDefaultConstructor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgClassDeclaration.html">SgClassDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>classDeclaration</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the default constructor from the class declaration. 
<p>

</div>
</div><p>
<a class="anchor" name="d800514689507e16297989c211bd1d46"></a><!-- doxytag: member="SageInterface::templateDefinitionIsInClass" ref="d800514689507e16297989c211bd1d46" args="(SgTemplateInstantiationMemberFunctionDecl *memberFunctionDeclaration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::templateDefinitionIsInClass           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgTemplateInstantiationMemberFunctionDecl.html">SgTemplateInstantiationMemberFunctionDecl</a> *&nbsp;</td>
          <td class="paramname"> <em>memberFunctionDeclaration</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if template definition is in the class, false if outside of class. 
<p>

</div>
</div><p>
<a class="anchor" name="05cf8a0be6e549502d66723997d7a1d6"></a><!-- doxytag: member="SageInterface::buildForwardFunctionDeclaration" ref="05cf8a0be6e549502d66723997d7a1d6" args="(SgTemplateInstantiationMemberFunctionDecl *memberFunctionInstantiation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgTemplateInstantiationMemberFunctionDecl.html">SgTemplateInstantiationMemberFunctionDecl</a>* SageInterface::buildForwardFunctionDeclaration           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgTemplateInstantiationMemberFunctionDecl.html">SgTemplateInstantiationMemberFunctionDecl</a> *&nbsp;</td>
          <td class="paramname"> <em>memberFunctionInstantiation</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate a non-defining (forward) declaration from a defining function declaration. 
<p>
<p><b>For internal use only.</b></p>
<p>
should put into sageBuilder ? </p>

</div>
</div><p>
<a class="anchor" name="2bd323ff608813e595cf631ec1f6c620"></a><!-- doxytag: member="SageInterface::isStructDeclaration" ref="2bd323ff608813e595cf631ec1f6c620" args="(SgNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isStructDeclaration           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if a <a class="el" href="classSgNode.html">SgNode</a> is a declaration for a structure. 
<p>

</div>
</div><p>
<a class="anchor" name="9cfd9f42a896937c833851eeba3b1228"></a><!-- doxytag: member="SageInterface::extractPragmaKeyword" ref="9cfd9f42a896937c833851eeba3b1228" args="(const SgPragmaDeclaration *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::extractPragmaKeyword           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgPragmaDeclaration.html">SgPragmaDeclaration</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp". 
<p>

</div>
</div><p>
<a class="anchor" name="cd2e56dc7614b724718c8c8bbd75f5d1"></a><!-- doxytag: member="SageInterface::isOmpStatement" ref="cd2e56dc7614b724718c8c8bbd75f5d1" args="(SgNode *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isOmpStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if a node is SgOmp*Statement. 
<p>

</div>
</div><p>
<a class="anchor" name="1a75ef1b6fc0708f3a2791d5198bdf19"></a><!-- doxytag: member="SageInterface::isOverloaded" ref="1a75ef1b6fc0708f3a2791d5198bdf19" args="(SgFunctionDeclaration *functionDeclaration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isOverloaded           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>functionDeclaration</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if function is overloaded. 
<p>

</div>
</div><p>
<a class="anchor" name="041d0ad3164d050320ad7181d0aacd64"></a><!-- doxytag: member="SageInterface::annotateExpressionsWithUniqueNames" ref="041d0ad3164d050320ad7181d0aacd64" args="(SgProject *project)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::annotateExpressionsWithUniqueNames           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgProject.html">SgProject</a> *&nbsp;</td>
          <td class="paramname"> <em>project</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate unique names for expressions and attach the names as persistent attributes ("UniqueNameAttribute"). 
<p>

</div>
</div><p>
<a class="anchor" name="4d55ef6edf8eebf6577aca1e1fe0de6e"></a><!-- doxytag: member="SageInterface::isMain" ref="4d55ef6edf8eebf6577aca1e1fe0de6e" args="(const SgNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isMain           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if a <a class="el" href="classSgNode.html">SgNode</a> is a main() function declaration. 
<p>

</div>
</div><p>
<a class="anchor" name="c088828a4143b77fa9e3b11ba6b40a0e"></a><!-- doxytag: member="SageInterface::generateUniqueName" ref="c088828a4143b77fa9e3b11ba6b40a0e" args="(const SgNode *node, bool ignoreDifferenceBetweenDefiningAndNondefiningDeclarations)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::generateUniqueName           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ignoreDifferenceBetweenDefiningAndNondefiningDeclarations</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate unique name from C and C++ constructs. The name may contain space. 
<p>
This is support for the AST merge, but is generally useful as a more general mechanism than name mangling which is more closely ties to the generation of names to support link-time function name resolution. This is more general than common name mangling in that it resolves more relevant differences between C and C++ declarations. (e.g. the type within the declaration: "struct { int:8; } foo;").<p>
current work does not support expressions. 
</div>
</div><p>
<a class="anchor" name="6401801005892a56b2f337d0ce501eb7"></a><!-- doxytag: member="SageInterface::generateUniqueVariableName" ref="6401801005892a56b2f337d0ce501eb7" args="(SgScopeStatement *scope, std::string baseName=&quot;temp&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::generateUniqueVariableName           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>baseName</em> = <code>&quot;temp&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate a name that is unique in the current scope and any parent and children scopes. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>baseName</em>&nbsp;</td><td>the word to be included in the variable names. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="322a03f1d6ed3713ed72abcedeb8a51d"></a><!-- doxytag: member="SageInterface::declarationPositionString" ref="322a03f1d6ed3713ed72abcedeb8a51d" args="(const SgDeclarationStatement *declaration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::declarationPositionString           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>declaration</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate a unique string from the source file position information. 
<p>

</div>
</div><p>
<a class="anchor" name="90ebac1577ef2a31448937b60c3c09d1"></a><!-- doxytag: member="SageInterface::generateProjectName" ref="90ebac1577ef2a31448937b60c3c09d1" args="(const SgProject *project, bool supressSuffix=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::generateProjectName           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgProject.html">SgProject</a> *&nbsp;</td>
          <td class="paramname"> <em>project</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>supressSuffix</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Added mechanism to generate project name from list of file names. 
<p>

</div>
</div><p>
<a class="anchor" name="92c54986b591707f089705085a7b962e"></a><!-- doxytag: member="SageInterface::getDeclarationOfNamedFunction" ref="92c54986b591707f089705085a7b962e" args="(SgExpression *func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>* SageInterface::getDeclarationOfNamedFunction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a <a class="el" href="classSgExpression.html">SgExpression</a> that represents a named function (or bound member function), return the mentioned function. 
<p>

</div>
</div><p>
<a class="anchor" name="ba53ce71d9c07fc4912d08bfa14aa6c0"></a><!-- doxytag: member="SageInterface::forallMaskExpression" ref="ba53ce71d9c07fc4912d08bfa14aa6c0" args="(SgForAllStatement *stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgExpression.html">SgExpression</a>* SageInterface::forallMaskExpression           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgForAllStatement.html">SgForAllStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the mask expression from the header of a <a class="el" href="classSgForAllStatement.html">SgForAllStatement</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="bebf0874533c9176d3dbe203c110d2b6"></a><!-- doxytag: member="SageInterface::addVarRefExpFromArrayDimInfo" ref="bebf0874533c9176d3dbe203c110d2b6" args="(SgNode *astNode, Rose_STL_Container&lt; SgNode * &gt; &amp;NodeList_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::addVarRefExpFromArrayDimInfo           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>astNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rose_STL_Container&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>NodeList_t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find all <a class="el" href="classSgPntrArrRefExp.html">SgPntrArrRefExp</a> under astNode, then add <a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> (if any) of SgPntrArrRefExp's dim_info into NodeList_t. 
<p>

</div>
</div><p>
<a class="anchor" name="2e2c09133334d2db043980411ad65a7c"></a><!-- doxytag: member="SageInterface::clearMangledNameCache" ref="2e2c09133334d2db043980411ad65a7c" args="(SgGlobal *globalScope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::clearMangledNameCache           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgGlobal.html">SgGlobal</a> *&nbsp;</td>
          <td class="paramname"> <em>globalScope</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Support for faster mangled name generation (caching avoids recomputation). 
<p>

</div>
</div><p>
<a class="anchor" name="939718eb45951e2200eeb23bc903ee40"></a><!-- doxytag: member="SageInterface::resetMangledNameCache" ref="939718eb45951e2200eeb23bc903ee40" args="(SgGlobal *globalScope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::resetMangledNameCache           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgGlobal.html">SgGlobal</a> *&nbsp;</td>
          <td class="paramname"> <em>globalScope</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp". 
<p>

</div>
</div><p>
<a class="anchor" name="fec2eead58f0854713f92c73989787ea"></a><!-- doxytag: member="SageInterface::getMangledNameFromCache" ref="fec2eead58f0854713f92c73989787ea" args="(SgNode *astNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::getMangledNameFromCache           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>astNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp". 
<p>

</div>
</div><p>
<a class="anchor" name="cd868f709a4ba10cc7e5367b51033e21"></a><!-- doxytag: member="SageInterface::addMangledNameToCache" ref="cd868f709a4ba10cc7e5367b51033e21" args="(SgNode *astNode, const std::string &amp;mangledName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::addMangledNameToCache           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>astNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>mangledName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp". 
<p>

</div>
</div><p>
<a class="anchor" name="ea729c0291d71f4b0f34192c4e42f974"></a><!-- doxytag: member="SageInterface::getNonInstantiatonDeclarationForClass" ref="ea729c0291d71f4b0f34192c4e42f974" args="(SgTemplateInstantiationMemberFunctionDecl *memberFunctionInstantiation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a>* SageInterface::getNonInstantiatonDeclarationForClass           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgTemplateInstantiationMemberFunctionDecl.html">SgTemplateInstantiationMemberFunctionDecl</a> *&nbsp;</td>
          <td class="paramname"> <em>memberFunctionInstantiation</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp". 
<p>

</div>
</div><p>
<a class="anchor" name="f7e85358ccd85bb87b78259de8f4d549"></a><!-- doxytag: member="SageInterface::setBaseTypeDefiningDeclaration" ref="f7e85358ccd85bb87b78259de8f4d549" args="(SgVariableDeclaration *var_decl, SgDeclarationStatement *base_decl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::setBaseTypeDefiningDeclaration           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>var_decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>base_decl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
a better version for SgVariableDeclaration::set_baseTypeDefininingDeclaration(), handling all side effects automatically Used to have a struct declaration embedded into a variable declaration 
<p>

</div>
</div><p>
<a class="anchor" name="2ad11c9bbccfc5c65ebd5a1e63df8457"></a><!-- doxytag: member="SageInterface::declarationPreceedsDefinition" ref="2ad11c9bbccfc5c65ebd5a1e63df8457" args="(SgDeclarationStatement *nonDefiningDeclaration, SgDeclarationStatement *definingDeclaration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::declarationPreceedsDefinition           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>nonDefiningDeclaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>definingDeclaration</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if a defining declaration comes before of after the non-defining declaration. 
<p>

</div>
</div><p>
<a class="anchor" name="a7b0761edf91357c7d6b1820f18f95d0"></a><!-- doxytag: member="SageInterface::functionCallExpressionPreceedsDeclarationWhichAssociatesScope" ref="a7b0761edf91357c7d6b1820f18f95d0" args="(SgFunctionCallExp *functionCall)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::functionCallExpressionPreceedsDeclarationWhichAssociatesScope           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionCallExp.html">SgFunctionCallExp</a> *&nbsp;</td>
          <td class="paramname"> <em>functionCall</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp". 
<p>

</div>
</div><p>
<a class="anchor" name="771883836d967b53906ffba1966f6f2c"></a><!-- doxytag: member="SageInterface::astIntersection" ref="771883836d967b53906ffba1966f6f2c" args="(SgNode *original, SgNode *copy, SgCopyHelp *help=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt; SageInterface::astIntersection           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgCopyHelp.html">SgCopyHelp</a> *&nbsp;</td>
          <td class="paramname"> <em>help</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the intersection set for two ASTs. 
<p>
This is part of a test done by the copy function to compute those IR nodes in the copy that still reference the original AST. 
</div>
</div><p>
<a class="anchor" name="9fcc4b40da8ae6daa5f50df366350861"></a><!-- doxytag: member="SageInterface::deepCopyNode" ref="9fcc4b40da8ae6daa5f50df366350861" args="(const SgNode *subtree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgNode.html">SgNode</a>* SageInterface::deepCopyNode           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>subtree</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deep copy an arbitrary subtree. 
<p>

<p>
Referenced by <a class="el" href="sageInterface_8h-source.html#l00440">deepCopy()</a>.
</div>
</div><p>
<a class="anchor" name="3a89292adcceeeda5391c5f67857251d"></a><!-- doxytag: member="SageInterface::deepCopy" ref="3a89292adcceeeda5391c5f67857251d" args="(const NodeType *subtree)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NodeType* SageInterface::deepCopy           </td>
          <td>(</td>
          <td class="paramtype">const NodeType *&nbsp;</td>
          <td class="paramname"> <em>subtree</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A template function for deep copying a subtree. It is also used to create deepcopy functions with specialized parameter and return types. e.g SgExpression* <a class="el" href="namespaceSageInterface.html#b716e78a9af76b8ace53782ce98938f8">copyExpression(SgExpression* e)</a>;. 
<p>

<p>
Definition at line <a class="el" href="sageInterface_8h-source.html#l00440">440</a> of file <a class="el" href="sageInterface_8h-source.html">sageInterface.h</a>.
<p>
References <a class="el" href="namespaceSageInterface.html#9fcc4b40da8ae6daa5f50df366350861">deepCopyNode()</a>.
<p>
Referenced by <a class="el" href="sageFunctors_8h-source.html#l00021">sg::cloneNode()</a>.
</div>
</div><p>
<a class="anchor" name="b716e78a9af76b8ace53782ce98938f8"></a><!-- doxytag: member="SageInterface::copyExpression" ref="b716e78a9af76b8ace53782ce98938f8" args="(SgExpression *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgExpression.html">SgExpression</a>* SageInterface::copyExpression           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>e</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deep copy an expression. 
<p>

</div>
</div><p>
<a class="anchor" name="ccb4140d5bad66ff517c5171a8e23790"></a><!-- doxytag: member="SageInterface::copyStatement" ref="ccb4140d5bad66ff517c5171a8e23790" args="(SgStatement *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgStatement.html">SgStatement</a>* SageInterface::copyStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deep copy a statement. 
<p>

</div>
</div><p>
<a class="anchor" name="2e4a80143b2c610c87c8ec6c8ae1a4f6"></a><!-- doxytag: member="SageInterface::getFirstVarSym" ref="2e4a80143b2c610c87c8ec6c8ae1a4f6" args="(SgVariableDeclaration *decl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a>* SageInterface::getFirstVarSym           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>decl</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the variable symbol for the first initialized name of a declaration stmt. 
<p>

</div>
</div><p>
<a class="anchor" name="13d0ecca52ba48d86e137017800ace85"></a><!-- doxytag: member="SageInterface::getFirstInitializedName" ref="13d0ecca52ba48d86e137017800ace85" args="(SgVariableDeclaration *decl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgInitializedName.html">SgInitializedName</a>* SageInterface::getFirstInitializedName           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>decl</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the first initialized name of a declaration statement. 
<p>

</div>
</div><p>
<a class="anchor" name="f2a313ede41c7b731cb61c355d1c55e0"></a><!-- doxytag: member="SageInterface::myRemoveStatement" ref="f2a313ede41c7b731cb61c355d1c55e0" args="(SgStatement *stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::myRemoveStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A special purpose statement removal function, originally from inlinerSupport.h, Need Jeremiah's attention to refine it. Please don't use it for now. 
<p>

</div>
</div><p>
<a class="anchor" name="8b764061b63990cb9a90a2e8fba1cd9e"></a><!-- doxytag: member="SageInterface::isConstantTrue" ref="8b764061b63990cb9a90a2e8fba1cd9e" args="(SgExpression *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isConstantTrue           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>e</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp". 
<p>

</div>
</div><p>
<a class="anchor" name="aabc058b0a469b383db6dae596659b1e"></a><!-- doxytag: member="SageInterface::isConstantFalse" ref="aabc058b0a469b383db6dae596659b1e" args="(SgExpression *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isConstantFalse           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>e</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp". 
<p>

</div>
</div><p>
<a class="anchor" name="eb16538d6d56b5b2ef2960c7f8c1ed9c"></a><!-- doxytag: member="SageInterface::isCallToParticularFunction" ref="eb16538d6d56b5b2ef2960c7f8c1ed9c" args="(SgFunctionDeclaration *decl, SgExpression *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isCallToParticularFunction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp". 
<p>

</div>
</div><p>
<a class="anchor" name="6fc323c375048618a3713f4f02d9d0fb"></a><!-- doxytag: member="SageInterface::isCallToParticularFunction" ref="6fc323c375048618a3713f4f02d9d0fb" args="(const std::string &amp;qualifiedName, size_t arity, SgExpression *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isCallToParticularFunction           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>qualifiedName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>arity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract a SgPragmaDeclaration's leading keyword . For example "#pragma omp parallel" has a keyword of "omp". 
<p>

</div>
</div><p>
<a class="anchor" name="345dac5d75b2039d24e0a4f9820d7b7c"></a><!-- doxytag: member="SageInterface::isStatic" ref="345dac5d75b2039d24e0a4f9820d7b7c" args="(SgDeclarationStatement *stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isStatic           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if a declaration has a "static' modifier. 
<p>

</div>
</div><p>
<a class="anchor" name="7133b3ef7857297f8fe4cbbdc0757259"></a><!-- doxytag: member="SageInterface::setStatic" ref="7133b3ef7857297f8fe4cbbdc0757259" args="(SgDeclarationStatement *stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::setStatic           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set a declaration as static. 
<p>

</div>
</div><p>
<a class="anchor" name="9ccb65716fdfa5b17abb793584b76a40"></a><!-- doxytag: member="SageInterface::isExtern" ref="9ccb65716fdfa5b17abb793584b76a40" args="(SgDeclarationStatement *stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isExtern           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if a declaration has an "extern" modifier. 
<p>

</div>
</div><p>
<a class="anchor" name="5a4e98c40873b96844edc32c7b2604e7"></a><!-- doxytag: member="SageInterface::setExtern" ref="5a4e98c40873b96844edc32c7b2604e7" args="(SgDeclarationStatement *stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::setExtern           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set a declaration as extern. 
<p>

</div>
</div><p>
<a class="anchor" name="746a92a94fcc6190e015e74aa1c911e8"></a><!-- doxytag: member="SageInterface::isAssignmentStatement" ref="746a92a94fcc6190e015e74aa1c911e8" args="(SgNode *_s, SgExpression **lhs=NULL, SgExpression **rhs=NULL, bool *readlhs=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isAssignmentStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> **&nbsp;</td>
          <td class="paramname"> <em>lhs</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> **&nbsp;</td>
          <td class="paramname"> <em>rhs</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>readlhs</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if a <a class="el" href="classSgNode.html">SgNode</a> _s is an assignment statement (any of =,+=,-=,&amp;=,/=, ^=, etc). 
<p>
Return the left hand, right hand expressions and if the left hand variable is also being read 
</div>
</div><p>
<a class="anchor" name="549a580089fff36d4184a4341cc08525"></a><!-- doxytag: member="SageInterface::convertRefToInitializedName" ref="549a580089fff36d4184a4341cc08525" args="(SgNode *current)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgInitializedName.html">SgInitializedName</a>* SageInterface::convertRefToInitializedName           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>current</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classVariable.html">Variable</a> references can be introduced by SgVarRef, <a class="el" href="classSgPntrArrRefExp.html">SgPntrArrRefExp</a>, <a class="el" href="classSgInitializedName.html">SgInitializedName</a>, SgMemberFunctionRef etc. This function will convert them all to a top level <a class="el" href="classSgInitializedName.html">SgInitializedName</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="e96f2137bb71d4484508452e554e1ae6"></a><!-- doxytag: member="SageInterface::getSgNodeFromAbstractHandleString" ref="e96f2137bb71d4484508452e554e1ae6" args="(const std::string &amp;input_string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgNode.html">SgNode</a>* SageInterface::getSgNodeFromAbstractHandleString           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>input_string</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtain a matching <a class="el" href="classSgNode.html">SgNode</a> from an abstract handle string. 
<p>

</div>
</div><p>
<a class="anchor" name="db3bd3c96f7ee7b03abc333cf2d14d96"></a><!-- doxytag: member="SageInterface::dumpInfo" ref="db3bd3c96f7ee7b03abc333cf2d14d96" args="(SgNode *node, std::string desc=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::dumpInfo           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>desc</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dump information about a <a class="el" href="classSgNode.html">SgNode</a> for debugging. 
<p>

</div>
</div><p>
<a class="anchor" name="74263a872d82b1b9f570120aad9205a8"></a><!-- doxytag: member="SageInterface::sortSgNodeListBasedOnAppearanceOrderInSource" ref="74263a872d82b1b9f570120aad9205a8" args="(const std::vector&lt; SgDeclarationStatement * &gt; &amp;nodevec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a>*&gt; SageInterface::sortSgNodeListBasedOnAppearanceOrderInSource           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nodevec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reorder a list of declaration statements based on their appearance order in source files. 
<p>

</div>
</div><p>
<a class="anchor" name="566a32e0c20fd3f5622ea88542e15fc1"></a><!-- doxytag: member="SageInterface::is_C_language" ref="566a32e0c20fd3f5622ea88542e15fc1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::is_C_language           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Brief These traverse the memory pool of <a class="el" href="classSgFile.html">SgFile</a> IR nodes and determine what languages are in use! 
</div>
</div><p>
<a class="anchor" name="a60da61c638f8a24154b5825a61c6cd2"></a><!-- doxytag: member="SageInterface::is_OpenMP_language" ref="a60da61c638f8a24154b5825a61c6cd2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::is_OpenMP_language           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Brief These traverse the memory pool of <a class="el" href="classSgFile.html">SgFile</a> IR nodes and determine what languages are in use! 
</div>
</div><p>
<a class="anchor" name="b0e18374a0ed7b0e6316a99024f3d463"></a><!-- doxytag: member="SageInterface::is_UPC_language" ref="b0e18374a0ed7b0e6316a99024f3d463" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::is_UPC_language           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Brief These traverse the memory pool of <a class="el" href="classSgFile.html">SgFile</a> IR nodes and determine what languages are in use! 
</div>
</div><p>
<a class="anchor" name="8ec5479617b0522a268f633eae672480"></a><!-- doxytag: member="SageInterface::is_UPC_dynamic_threads" ref="8ec5479617b0522a268f633eae672480" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::is_UPC_dynamic_threads           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if dynamic threads compilation is used for UPC programs. 
<p>

</div>
</div><p>
<a class="anchor" name="886098c3840ecd5cd66dc1407dd43276"></a><!-- doxytag: member="SageInterface::is_C99_language" ref="886098c3840ecd5cd66dc1407dd43276" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::is_C99_language           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Brief These traverse the memory pool of <a class="el" href="classSgFile.html">SgFile</a> IR nodes and determine what languages are in use! 
</div>
</div><p>
<a class="anchor" name="f05a80a2ebfff2af0adea468853b95c8"></a><!-- doxytag: member="SageInterface::is_Cxx_language" ref="f05a80a2ebfff2af0adea468853b95c8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::is_Cxx_language           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Brief These traverse the memory pool of <a class="el" href="classSgFile.html">SgFile</a> IR nodes and determine what languages are in use! 
</div>
</div><p>
<a class="anchor" name="49a362a0ab0c9d904277c2110b3ad49c"></a><!-- doxytag: member="SageInterface::is_Java_language" ref="49a362a0ab0c9d904277c2110b3ad49c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::is_Java_language           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Brief These traverse the memory pool of <a class="el" href="classSgFile.html">SgFile</a> IR nodes and determine what languages are in use! 
</div>
</div><p>
<a class="anchor" name="83cad0fd2592f95e81d55335eb6b71c0"></a><!-- doxytag: member="SageInterface::is_Fortran_language" ref="83cad0fd2592f95e81d55335eb6b71c0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::is_Fortran_language           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Brief These traverse the memory pool of <a class="el" href="classSgFile.html">SgFile</a> IR nodes and determine what languages are in use! 
</div>
</div><p>
<a class="anchor" name="92b55e430cd48fbaf0549c18346a5143"></a><!-- doxytag: member="SageInterface::is_CAF_language" ref="92b55e430cd48fbaf0549c18346a5143" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::is_CAF_language           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Brief These traverse the memory pool of <a class="el" href="classSgFile.html">SgFile</a> IR nodes and determine what languages are in use! 
</div>
</div><p>
<a class="anchor" name="1d36075c44838671db22569634aa2938"></a><!-- doxytag: member="SageInterface::is_PHP_language" ref="1d36075c44838671db22569634aa2938" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::is_PHP_language           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Brief These traverse the memory pool of <a class="el" href="classSgFile.html">SgFile</a> IR nodes and determine what languages are in use! 
</div>
</div><p>
<a class="anchor" name="23d423a93f8f98375f0d6270830945a2"></a><!-- doxytag: member="SageInterface::is_Python_language" ref="23d423a93f8f98375f0d6270830945a2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::is_Python_language           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Brief These traverse the memory pool of <a class="el" href="classSgFile.html">SgFile</a> IR nodes and determine what languages are in use! 
</div>
</div><p>
<a class="anchor" name="bac39765f90bd8e44841f94da97b0983"></a><!-- doxytag: member="SageInterface::is_Cuda_language" ref="bac39765f90bd8e44841f94da97b0983" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::is_Cuda_language           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Brief These traverse the memory pool of <a class="el" href="classSgFile.html">SgFile</a> IR nodes and determine what languages are in use! 
</div>
</div><p>
<a class="anchor" name="8adea0a7bcd9c553286b10558f39dc88"></a><!-- doxytag: member="SageInterface::is_binary_executable" ref="8adea0a7bcd9c553286b10558f39dc88" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::is_binary_executable           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Brief These traverse the memory pool of <a class="el" href="classSgFile.html">SgFile</a> IR nodes and determine what languages are in use! 
</div>
</div><p>
<a class="anchor" name="6321d2c29de36e4e3b13d5ad2f05360f"></a><!-- doxytag: member="SageInterface::is_mixed_C_and_Cxx_language" ref="6321d2c29de36e4e3b13d5ad2f05360f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::is_mixed_C_and_Cxx_language           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Brief These traverse the memory pool of <a class="el" href="classSgFile.html">SgFile</a> IR nodes and determine what languages are in use! 
</div>
</div><p>
<a class="anchor" name="0c24f014eaa02cc009e4d5b4e82317b0"></a><!-- doxytag: member="SageInterface::is_mixed_Fortran_and_C_language" ref="0c24f014eaa02cc009e4d5b4e82317b0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::is_mixed_Fortran_and_C_language           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Brief These traverse the memory pool of <a class="el" href="classSgFile.html">SgFile</a> IR nodes and determine what languages are in use! 
</div>
</div><p>
<a class="anchor" name="8400c6f481f8578f7cd13c62abdc0e20"></a><!-- doxytag: member="SageInterface::is_mixed_Fortran_and_Cxx_language" ref="8400c6f481f8578f7cd13c62abdc0e20" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::is_mixed_Fortran_and_Cxx_language           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Brief These traverse the memory pool of <a class="el" href="classSgFile.html">SgFile</a> IR nodes and determine what languages are in use! 
</div>
</div><p>
<a class="anchor" name="c403d067f7bef971b67d9a1c4a78d50e"></a><!-- doxytag: member="SageInterface::is_mixed_Fortran_and_C_and_Cxx_language" ref="c403d067f7bef971b67d9a1c4a78d50e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::is_mixed_Fortran_and_C_and_Cxx_language           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Brief These traverse the memory pool of <a class="el" href="classSgFile.html">SgFile</a> IR nodes and determine what languages are in use! 
</div>
</div><p>
<a class="anchor" name="1035757c3d70027ffd221d21b36af053"></a><!-- doxytag: member="SageInterface::resetScopeNumbers" ref="1035757c3d70027ffd221d21b36af053" args="(SgFunctionDefinition *functionDeclaration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::resetScopeNumbers           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *&nbsp;</td>
          <td class="paramname"> <em>functionDeclaration</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns unique numbers to each <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> of a function. 
<p>
This is used to provide unique names for variables and types defined is different nested scopes of a function (used in mangled name generation). 
</div>
</div><p>
<a class="anchor" name="d3cad455182a3615812ac2597a50bd09"></a><!-- doxytag: member="SageInterface::clearScopeNumbers" ref="d3cad455182a3615812ac2597a50bd09" args="(SgFunctionDefinition *functionDefinition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::clearScopeNumbers           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *&nbsp;</td>
          <td class="paramname"> <em>functionDefinition</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the cache of scope,integer pairs for the input function. 
<p>
This is used to clear the cache of computed unique labels for scopes in a function. This function should be called after any transformation on a function that might effect the allocation of scopes and cause the existing unique numbers to be incorrect. This is part of support to provide unique names for variables and types defined is different nested scopes of a function (used in mangled name generation). 
</div>
</div><p>
<a class="anchor" name="a192374d0f4322f7c91324938c6b8894"></a><!-- doxytag: member="SageInterface::enclosingNamespaceScope" ref="a192374d0f4322f7c91324938c6b8894" args="(SgDeclarationStatement *declaration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgNamespaceDefinitionStatement.html">SgNamespaceDefinitionStatement</a>* SageInterface::enclosingNamespaceScope           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>declaration</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the enclosing namespace of a declaration. 
<p>

</div>
</div><p>
<a class="anchor" name="b456db305882bbb6be21968b59fc865c"></a><!-- doxytag: member="SageInterface::isPrototypeInScope" ref="b456db305882bbb6be21968b59fc865c" args="(SgScopeStatement *scope, SgFunctionDeclaration *functionDeclaration, SgDeclarationStatement *startingAtDeclaration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isPrototypeInScope           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>functionDeclaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>startingAtDeclaration</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns unique numbers to each <a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> of a function. 
<p>
This is used to provide unique names for variables and types defined is different nested scopes of a function (used in mangled name generation). 
</div>
</div><p>
<a class="anchor" name="74b3faa5cdda97afa174085b4a34a2f1"></a><!-- doxytag: member="SageInterface::isAncestor" ref="74b3faa5cdda97afa174085b4a34a2f1" args="(SgNode *node1, SgNode *node2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isAncestor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
check if node1 is a strict ancestor of node 2. (a node is not considered its own ancestor) 
<p>

</div>
</div><p>
<a class="anchor" name="8d27ee1ca1349f91dc8a18d1aa6cc403"></a><!-- doxytag: member="SageInterface::dumpPreprocInfo" ref="8d27ee1ca1349f91dc8a18d1aa6cc403" args="(SgLocatedNode *locatedNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::dumpPreprocInfo           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> *&nbsp;</td>
          <td class="paramname"> <em>locatedNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dumps a located node's preprocessing information. 
<p>

</div>
</div><p>
<a class="anchor" name="56f045ed55445883dc3fc798738580a2"></a><!-- doxytag: member="SageInterface::insertHeader" ref="56f045ed55445883dc3fc798738580a2" args="(const std::string &amp;filename, PreprocessingInfo::RelativePositionType position=PreprocessingInfo::after, bool isSystemHeader=false, SgScopeStatement *scope=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPreprocessingInfo.html">PreprocessingInfo</a>* SageInterface::insertHeader           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code>PreprocessingInfo::after</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isSystemHeader</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert include "filename" or include &lt;filename&gt; (system header) into the global scope containing the current scope, right after other include XXX. 
<p>

</div>
</div><p>
<a class="anchor" name="283532aef637c65f6d103afc09d5fd71"></a><!-- doxytag: member="SageInterface::moveUpPreprocessingInfo" ref="283532aef637c65f6d103afc09d5fd71" args="(SgStatement *stmt_dst, SgStatement *stmt_src, PreprocessingInfo::RelativePositionType src_position=PreprocessingInfo::undef, PreprocessingInfo::RelativePositionType dst_position=PreprocessingInfo::undef, bool usePrepend=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::moveUpPreprocessingInfo           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a>&nbsp;</td>
          <td class="paramname"> <em>src_position</em> = <code>PreprocessingInfo::undef</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a>&nbsp;</td>
          <td class="paramname"> <em>dst_position</em> = <code>PreprocessingInfo::undef</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>usePrepend</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Identical to <a class="el" href="namespaceSageInterface.html#b6bc0e31d1ae1be2e221bb8ddbe1e098">movePreprocessingInfo()</a>, except for the stale name and confusing order of parameters. It will be deprecated soon. 
<p>

</div>
</div><p>
<a class="anchor" name="b6bc0e31d1ae1be2e221bb8ddbe1e098"></a><!-- doxytag: member="SageInterface::movePreprocessingInfo" ref="b6bc0e31d1ae1be2e221bb8ddbe1e098" args="(SgStatement *stmt_src, SgStatement *stmt_dst, PreprocessingInfo::RelativePositionType src_position=PreprocessingInfo::undef, PreprocessingInfo::RelativePositionType dst_position=PreprocessingInfo::undef, bool usePrepend=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::movePreprocessingInfo           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a>&nbsp;</td>
          <td class="paramname"> <em>src_position</em> = <code>PreprocessingInfo::undef</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a>&nbsp;</td>
          <td class="paramname"> <em>dst_position</em> = <code>PreprocessingInfo::undef</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>usePrepend</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Move preprocessing information of stmt_src to stmt_dst, Only move preprocessing information from the specified source-relative position to a specified target position, otherwise move all preprocessing information with position information intact. The preprocessing information is appended to the existing preprocessing information list of the target node by default. Prepending is used if usePreprend is set to true. Optionally, the relative position can be adjust after the moving using dst_position. 
<p>

</div>
</div><p>
<a class="anchor" name="29f09cd84a8eadc2e1c0524898973233"></a><!-- doxytag: member="SageInterface::cutPreprocessingInfo" ref="29f09cd84a8eadc2e1c0524898973233" args="(SgLocatedNode *src_node, PreprocessingInfo::RelativePositionType pos, AttachedPreprocessingInfoType &amp;save_buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::cutPreprocessingInfo           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> *&nbsp;</td>
          <td class="paramname"> <em>src_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a>&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rose__attributes__list_8h.html#d4b5f34bc0846e58b38e0ba5e8aac8b0">AttachedPreprocessingInfoType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>save_buf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cut preprocessing information from a source node and save it into a buffer. Used in combination of <a class="el" href="namespaceSageInterface.html#fa35ff298b746401f5f535de8a9c3f99">pastePreprocessingInfo()</a>. The cut-paste operation is similar to <a class="el" href="namespaceSageInterface.html#283532aef637c65f6d103afc09d5fd71">moveUpPreprocessingInfo()</a> but it is more flexible in that the destination node can be unknown during the cut operation. 
<p>

</div>
</div><p>
<a class="anchor" name="fa35ff298b746401f5f535de8a9c3f99"></a><!-- doxytag: member="SageInterface::pastePreprocessingInfo" ref="fa35ff298b746401f5f535de8a9c3f99" args="(SgLocatedNode *dst_node, PreprocessingInfo::RelativePositionType pos, AttachedPreprocessingInfoType &amp;saved_buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::pastePreprocessingInfo           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a>&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rose__attributes__list_8h.html#d4b5f34bc0846e58b38e0ba5e8aac8b0">AttachedPreprocessingInfoType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>saved_buf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Paste preprocessing information from a buffer to a destination node. Used in combination of <a class="el" href="namespaceSageInterface.html#29f09cd84a8eadc2e1c0524898973233">cutPreprocessingInfo()</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="a5cdee81732f9fb464a0239093275d86"></a><!-- doxytag: member="SageInterface::attachArbitraryText" ref="a5cdee81732f9fb464a0239093275d86" args="(SgLocatedNode *target, const std::string &amp;text, PreprocessingInfo::RelativePositionType position=PreprocessingInfo::before)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPreprocessingInfo.html">PreprocessingInfo</a>* SageInterface::attachArbitraryText           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code>PreprocessingInfo::before</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attach an arbitrary string to a located node. A workaround to insert irregular statements or vendor-specific attributes. 
<p>

</div>
</div><p>
<a class="anchor" name="3bf4efffda1365f130307b6581dcc5c9"></a><!-- doxytag: member="SageInterface::replaceMacroCallsWithExpandedStrings" ref="3bf4efffda1365f130307b6581dcc5c9" args="(SgPragmaDeclaration *target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::replaceMacroCallsWithExpandedStrings           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgPragmaDeclaration.html">SgPragmaDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>target</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if a pragma declaration node has macro calls attached, if yes, replace macro calls within the pragma string with expanded strings. This only works if -rose:wave is turned on. 
<p>

</div>
</div><p>
<a class="anchor" name="67b0e2f8c62c2a8858340e7f90605bc3"></a><!-- doxytag: member="SageInterface::attachComment" ref="67b0e2f8c62c2a8858340e7f90605bc3" args="(SgLocatedNode *target, const std::string &amp;content, PreprocessingInfo::RelativePositionType position=PreprocessingInfo::before, PreprocessingInfo::DirectiveType dtype=PreprocessingInfo::CpreprocessorUnknownDeclaration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPreprocessingInfo.html">PreprocessingInfo</a>* SageInterface::attachComment           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPreprocessingInfo.html#e538689c20a5660f89683f0647692fc1">PreprocessingInfo::RelativePositionType</a>&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code>PreprocessingInfo::before</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPreprocessingInfo.html#e789144105bc700862c47070f4380064">PreprocessingInfo::DirectiveType</a>&nbsp;</td>
          <td class="paramname"> <em>dtype</em> = <code>PreprocessingInfo::CpreprocessorUnknownDeclaration</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Build and attach comment, comment style is inferred from the language type of the target node if not provided. 
<p>

</div>
</div><p>
<a class="anchor" name="0c8fca7b7763fe18fe2e65b7a3cf3ebe"></a><!-- doxytag: member="SageInterface::addTextForUnparser" ref="0c8fca7b7763fe18fe2e65b7a3cf3ebe" args="(SgNode *astNode, std::string s, AstUnparseAttribute::RelativePositionType inputlocation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::addTextForUnparser           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>astNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AstUnparseAttribute::RelativePositionType&nbsp;</td>
          <td class="paramname"> <em>inputlocation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a string to be unparsed to support code generation for back-end specific tools or compilers. 
<p>

</div>
</div><p>
<a class="anchor" name="2d9f0cac1a208b285896a8f38d24910c"></a><!-- doxytag: member="SageInterface::setOneSourcePositionForTransformation" ref="2d9f0cac1a208b285896a8f38d24910c" args="(SgNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::setOneSourcePositionForTransformation           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set current node's source position as transformation generated. 
<p>

</div>
</div><p>
<a class="anchor" name="c2dd84efb4bec39069ab07683078e29c"></a><!-- doxytag: member="SageInterface::setOneSourcePositionNull" ref="c2dd84efb4bec39069ab07683078e29c" args="(SgNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::setOneSourcePositionNull           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set current node's source position as NULL. 
<p>

</div>
</div><p>
<a class="anchor" name="4a000085908cd7fe8ab8cf07856b00fe"></a><!-- doxytag: member="SageInterface::setSourcePositionForTransformation" ref="4a000085908cd7fe8ab8cf07856b00fe" args="(SgNode *root)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::setSourcePositionForTransformation           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recursively set source position info(Sg_File_Info) as transformation generated. 
<p>

</div>
</div><p>
<a class="anchor" name="6bd0bf1527ae929472afba8b567fa808"></a><!-- doxytag: member="SageInterface::setSourcePositionForTransformation_memoryPool" ref="6bd0bf1527ae929472afba8b567fa808" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::setSourcePositionForTransformation_memoryPool           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set source position info(Sg_File_Info) as transformation generated for all SgNodes in memory pool. 
<p>

</div>
</div><p>
<a class="anchor" name="bf0f6c68d90fe1d08e382fe8342b3992"></a><!-- doxytag: member="SageInterface::setSourcePosition" ref="bf0f6c68d90fe1d08e382fe8342b3992" args="(SgLocatedNode *locatedNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::setSourcePosition           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> *&nbsp;</td>
          <td class="paramname"> <em>locatedNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the source position of <a class="el" href="classSgLocatedNode.html">SgLocatedNode</a> to <a class="el" href="classSg__File__Info.html#d546c953744c52cf43459d6a8358851d">Sg_File_Info::generateDefaultFileInfo()</a>. These nodes WILL be unparsed. Not for transformation usage. 
<p>

</div>
</div><p>
<a class="anchor" name="5eb80ef8782c559e7721b5724889bdbe"></a><!-- doxytag: member="SageInterface::getBoolType" ref="5eb80ef8782c559e7721b5724889bdbe" args="(SgNode *n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgType.html">SgType</a>* SageInterface::getBoolType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the right bool type according to C or C++ language input. 
<p>

</div>
</div><p>
<a class="anchor" name="dbfdb7a0b32ca452c00f5e92c67ab504"></a><!-- doxytag: member="SageInterface::isStrictIntegerType" ref="dbfdb7a0b32ca452c00f5e92c67ab504" args="(SgType *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isStrictIntegerType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if a type is an integral type, only allowing signed/unsigned short, int, long, long long. 
<p>
There is another similar function named <a class="el" href="classSgType.html#40a92b3d4ed92a076be720b0083543c0">SgType::isIntegerType()</a>, which allows additional types char, wchar, and bool. 
</div>
</div><p>
<a class="anchor" name="da61c82df82783bc236b9fb30fbd74fd"></a><!-- doxytag: member="SageInterface::getFirstVarType" ref="da61c82df82783bc236b9fb30fbd74fd" args="(SgVariableDeclaration *decl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgType.html">SgType</a>* SageInterface::getFirstVarType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>decl</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the data type of the first initialized name of a declaration statement. 
<p>

</div>
</div><p>
<a class="anchor" name="009d6a3353b70c4ccbe95c6f7625afc1"></a><!-- doxytag: member="SageInterface::isDefaultConstructible" ref="009d6a3353b70c4ccbe95c6f7625afc1" args="(SgType *type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isDefaultConstructible           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is a type default constructible? This may not quite work properly. 
<p>

</div>
</div><p>
<a class="anchor" name="32b9be9817f0b51872d3fcb8318ae729"></a><!-- doxytag: member="SageInterface::isCopyConstructible" ref="32b9be9817f0b51872d3fcb8318ae729" args="(SgType *type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isCopyConstructible           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is a type copy constructible? This may not quite work properly. 
<p>

</div>
</div><p>
<a class="anchor" name="7a37edbdd90a230a51fc90448994cb8b"></a><!-- doxytag: member="SageInterface::isAssignable" ref="7a37edbdd90a230a51fc90448994cb8b" args="(SgType *type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isAssignable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is a type assignable? This may not quite work properly. 
<p>

</div>
</div><p>
<a class="anchor" name="d3cb00d489f349ed6eaaaf0d5e1273fa"></a><!-- doxytag: member="SageInterface::isPureVirtualClass" ref="d3cb00d489f349ed6eaaaf0d5e1273fa" args="(SgType *type, const ClassHierarchyWrapper &amp;classHierarchy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isPureVirtualClass           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classClassHierarchyWrapper.html">ClassHierarchyWrapper</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>classHierarchy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if a class type is a pure virtual class. 
<p>
True means that there is at least one pure virtual function that has not been overridden. In the case of an incomplete class type (forward declaration), this function returns false. 
</div>
</div><p>
<a class="anchor" name="756c8b08ca6df604e0e474ce92520240"></a><!-- doxytag: member="SageInterface::hasTrivialDestructor" ref="756c8b08ca6df604e0e474ce92520240" args="(SgType *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::hasTrivialDestructor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Does a type have a trivial (built-in) destructor? 
<p>

</div>
</div><p>
<a class="anchor" name="82f20af57da57491b26e6028fc4949c7"></a><!-- doxytag: member="SageInterface::isNonconstReference" ref="82f20af57da57491b26e6028fc4949c7" args="(SgType *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isNonconstReference           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is this type a non-constant reference type? (Handles typedefs correctly). 
<p>

</div>
</div><p>
<a class="anchor" name="82448abd826a63fbf74cabde856223ec"></a><!-- doxytag: member="SageInterface::isReferenceType" ref="82448abd826a63fbf74cabde856223ec" args="(SgType *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isReferenceType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is this type a const or non-const reference type? (Handles typedefs correctly). 
<p>

</div>
</div><p>
<a class="anchor" name="370c189fab51b8d9a5871c569fe2ae76"></a><!-- doxytag: member="SageInterface::isPointerType" ref="370c189fab51b8d9a5871c569fe2ae76" args="(SgType *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isPointerType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is this type a pointer type? (Handles typedefs correctly). 
<p>

</div>
</div><p>
<a class="anchor" name="e88d4c976002995bdc89629bf5942812"></a><!-- doxytag: member="SageInterface::isPointerToNonConstType" ref="e88d4c976002995bdc89629bf5942812" args="(SgType *type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isPointerToNonConstType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is this a pointer to a non-const type? Note that this function will return true for const pointers pointing to non-const types. 
<p>
For example, (int* const y) points to a modifiable int, so this function returns true. Meanwhile, it returns false for (int const * x) and (int const * const x) because these types point to a const int. Also, only the outer layer of nested pointers is unwrapped. So the function returns true for (const int ** y), but returns false for const (int * const * x) 
</div>
</div><p>
<a class="anchor" name="3a8271b0d66df14cd687c3367c3530cc"></a><!-- doxytag: member="SageInterface::isConstType" ref="3a8271b0d66df14cd687c3367c3530cc" args="(SgType *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isConstType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is this a const type? 
<p>

</div>
</div><p>
<a class="anchor" name="aad366e0a9271f41b1273169032163a9"></a><!-- doxytag: member="SageInterface::removeConst" ref="aad366e0a9271f41b1273169032163a9" args="(SgType *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgType.html">SgType</a>* SageInterface::removeConst           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove const (if present) from a type. stripType() cannot do this because it removes all modifiers. 
<p>

</div>
</div><p>
<a class="anchor" name="bfdc4703511f9477641338f374d2efea"></a><!-- doxytag: member="SageInterface::isVolatileType" ref="bfdc4703511f9477641338f374d2efea" args="(SgType *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isVolatileType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is this a volatile type? 
<p>

</div>
</div><p>
<a class="anchor" name="9bb1cf771b3824b61f450868a4a37014"></a><!-- doxytag: member="SageInterface::isRestrictType" ref="9bb1cf771b3824b61f450868a4a37014" args="(SgType *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isRestrictType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is this a restrict type? 
<p>

</div>
</div><p>
<a class="anchor" name="383e9d7c3a5ecf90215dc596491cb748"></a><!-- doxytag: member="SageInterface::isScalarType" ref="383e9d7c3a5ecf90215dc596491cb748" args="(SgType *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isScalarType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is this a scalar type? 
<p>
We define the following <a class="el" href="classSgType.html">SgType</a> as scalar types: char, short, int, long , void, Wchar, Float, double, long long, string, bool, complex, imaginary 
</div>
</div><p>
<a class="anchor" name="0c1abd9fda12ecad049dc846ab65dd99"></a><!-- doxytag: member="SageInterface::isStructType" ref="0c1abd9fda12ecad049dc846ab65dd99" args="(SgType *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isStructType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if a type is a struct type (a special <a class="el" href="classSgClassType.html">SgClassType</a> in <a class="el" href="namespaceROSE.html">ROSE</a>). 
<p>

</div>
</div><p>
<a class="anchor" name="42c6089ca6226d5f96cc54164a8c2dec"></a><!-- doxytag: member="SageInterface::mangleType" ref="42c6089ca6226d5f96cc54164a8c2dec" args="(SgType *type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::mangleType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate a mangled string for a given type based on Itanium C++ ABI. 
<p>

</div>
</div><p>
<a class="anchor" name="4ba1a020452edc07be8aefe8f87c7a52"></a><!-- doxytag: member="SageInterface::mangleScalarType" ref="4ba1a020452edc07be8aefe8f87c7a52" args="(SgType *type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::mangleScalarType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate mangled scalar type names according to Itanium C++ ABI, the input type should pass <a class="el" href="namespaceSageInterface.html#383e9d7c3a5ecf90215dc596491cb748">isScalarType()</a> in <a class="el" href="namespaceROSE.html">ROSE</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="181e5d76b90b579ffe02ce67a9a0ef8b"></a><!-- doxytag: member="SageInterface::mangleModifierType" ref="181e5d76b90b579ffe02ce67a9a0ef8b" args="(SgModifierType *type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::mangleModifierType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgModifierType.html">SgModifierType</a> *&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generated mangled modifier types, include const, volatile,according to Itanium C++ ABI, with extension to handle UPC shared types. 
<p>

</div>
</div><p>
<a class="anchor" name="d41b5baa74591e80698884761377ab6b"></a><!-- doxytag: member="SageInterface::getArrayElementCount" ref="d41b5baa74591e80698884761377ab6b" args="(SgArrayType *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SageInterface::getArrayElementCount           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgArrayType.html">SgArrayType</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the number of elements of an array type: dim1* dim2*... , assume element count is 1 for int a[]; Strip off THREADS if it is a UPC array. 
<p>

</div>
</div><p>
<a class="anchor" name="8a2ff021fc68f7aa3af9427133e94663"></a><!-- doxytag: member="SageInterface::getDimensionCount" ref="8a2ff021fc68f7aa3af9427133e94663" args="(SgType *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SageInterface::getDimensionCount           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of dimensions of an array type. 
<p>

</div>
</div><p>
<a class="anchor" name="4be15625c027455c3ba044dbeff24f05"></a><!-- doxytag: member="SageInterface::getArrayElementType" ref="4be15625c027455c3ba044dbeff24f05" args="(SgType *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgType.html">SgType</a>* SageInterface::getArrayElementType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the element type of an array. 
<p>

</div>
</div><p>
<a class="anchor" name="5eaa89e50137b40aab59321dcfed8d81"></a><!-- doxytag: member="SageInterface::getElementType" ref="5eaa89e50137b40aab59321dcfed8d81" args="(SgType *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgType.html">SgType</a>* SageInterface::getElementType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the element type of an array, pointer or string, or NULL if not applicable. 
<p>

</div>
</div><p>
<a class="anchor" name="4f543ac715559ff0b76bdf8fd004fc09"></a><!-- doxytag: member="SageInterface::get_C_array_dimensions" ref="4f543ac715559ff0b76bdf8fd004fc09" args="(const SgArrayType &amp;arrtype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSgExpression.html">SgExpression</a>*&gt; SageInterface::get_C_array_dimensions           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgArrayType.html">SgArrayType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arrtype</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns the array dimensions in an array as defined for arrtype 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>arrtype</em>&nbsp;</td><td>the type of a C/C++ array </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>an array that contains an expression indicating each dimension's size. OWNERSHIP of the expressions is TRANSFERED TO the CALLER (which becomes responsible for freeing the expressions). Note, the first entry of the array is a <a class="el" href="classSgNullExpression.html">SgNullExpression</a>, iff the first array dimension was not specified. <div class="fragment"><pre class="fragment">         <span class="keywordtype">int</span> x[] = { 1, 2, 3 };
</pre></div> note, the expression does not have to be a constant <div class="fragment"><pre class="fragment">         <span class="keywordtype">int</span> x[i*5];
</pre></div> </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>return-value.empty() == false <p>
return-value[*] != NULL (no nullptr in the returned vector) </dd></dl>

</div>
</div><p>
<a class="anchor" name="c4ca57179d072f3577b07b8e33818dca"></a><!-- doxytag: member="SageInterface::get_C_array_dimensions" ref="c4ca57179d072f3577b07b8e33818dca" args="(const SgArrayType &amp;arrtype, const SgVarRefExp &amp;varref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSgExpression.html">SgExpression</a>*&gt; SageInterface::get_C_array_dimensions           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgArrayType.html">SgArrayType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arrtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>varref</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns the array dimensions in an array as defined for arrtype 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>arrtype</em>&nbsp;</td><td>the type of a C/C++ array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>varref</em>&nbsp;</td><td>a reference to an array variable (the variable of type arrtype) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>an array that contains an expression indicating each dimension's size. OWNERSHIP of the expressions is TRANSFERED TO the CALLER (which becomes responsible for freeing the expressions). If the first array dimension was not specified an expression that indicates that size is generated. <div class="fragment"><pre class="fragment">         <span class="keywordtype">int</span> x[][3] = { 1, 2, 3, 4, 5, 6 };
</pre></div> the entry for the first dimension will be: <div class="fragment"><pre class="fragment">         <span class="comment">// 3 ... size of 2nd dimension</span>
         <span class="keyword">sizeof</span>(x) / (<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) * 3)
</pre></div> </dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>arrtype is the array-type of varref </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>return-value.empty() == false <p>
return-value[*] != NULL (no nullptr in the returned vector) <p>
!isSgNullExpression(return-value[*]) </dd></dl>

</div>
</div><p>
<a class="anchor" name="ae2594fcfdf89b9fc795eb4b4c2d04aa"></a><!-- doxytag: member="SageInterface::get_C_array_dimensions" ref="ae2594fcfdf89b9fc795eb4b4c2d04aa" args="(const SgArrayType &amp;arrtype, SgInitializedName &amp;initname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSgExpression.html">SgExpression</a>*&gt; SageInterface::get_C_array_dimensions           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgArrayType.html">SgArrayType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arrtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgInitializedName.html">SgInitializedName</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>initname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>see get_C_array_dimensions for <a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> for details. </dd></dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000143">Todo:</a></b></dt><dd>make initname const </dd></dl>

</div>
</div><p>
<a class="anchor" name="084d7c6b763876564745cdf9a33a65a3"></a><!-- doxytag: member="SageInterface::isArrayReference" ref="084d7c6b763876564745cdf9a33a65a3" args="(SgExpression *ref, SgExpression **arrayNameExp=NULL, std::vector&lt; SgExpression * &gt; **subscripts=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isArrayReference           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> **&nbsp;</td>
          <td class="paramname"> <em>arrayNameExp</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSgExpression.html">SgExpression</a> * &gt; **&nbsp;</td>
          <td class="paramname"> <em>subscripts</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if an expression is an array access (<a class="el" href="classSgPntrArrRefExp.html">SgPntrArrRefExp</a>). If so, return its name expression and subscripts if requested. Users can use <a class="el" href="namespaceSageInterface.html#549a580089fff36d4184a4341cc08525">convertRefToInitializedName()</a> to get the possible name. It does not check if the expression is a top level <a class="el" href="classSgPntrArrRefExp.html">SgPntrArrRefExp</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="de40549fd13e8fe367b099dca26b05e9"></a><!-- doxytag: member="SageInterface::hasUpcSharedType" ref="de40549fd13e8fe367b099dca26b05e9" args="(SgType *t, SgModifierType **mod_type_out=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::hasUpcSharedType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgModifierType.html">SgModifierType</a> **&nbsp;</td>
          <td class="paramname"> <em>mod_type_out</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Has a UPC shared type of any kinds (shared-to-shared, private-to-shared, shared-to-private, shared scalar/array)? An optional parameter, mod_type_out, stores the first <a class="el" href="classSgModifierType.html">SgModifierType</a> with UPC access information. 
<p>
Note: we classify private-to-shared as 'has shared' type for convenience here. It is indeed a private type in strict sense. AST graph for some examples:<ul>
<li>shared scalar: <a class="el" href="classSgModifierType.html">SgModifierType</a> --&gt;base type</li><li>shared array: <a class="el" href="classSgArrayType.html">SgArrayType</a> --&gt; SgModiferType --&gt; base type</li><li>shared to shared: <a class="el" href="classSgModifierType.html">SgModifierType</a> --&gt; <a class="el" href="classSgPointerType.html">SgPointerType</a> --&gt; <a class="el" href="classSgModifierType.html">SgModifierType</a> -&gt;<a class="el" href="classSgTypeInt.html">SgTypeInt</a></li><li>shared to private: <a class="el" href="classSgModifierType.html">SgModifierType</a> --&gt; <a class="el" href="classSgPointerType.html">SgPointerType</a> --&gt; base type</li><li>private to shared: <a class="el" href="classSgPointerType.html">SgPointerType</a> --&gt; <a class="el" href="classSgModifierType.html">SgModifierType</a> --&gt; base type </li></ul>

</div>
</div><p>
<a class="anchor" name="b376d542cfdc22ae95a4396a13f4bc93"></a><!-- doxytag: member="SageInterface::isUpcSharedType" ref="b376d542cfdc22ae95a4396a13f4bc93" args="(SgType *t, SgModifierType **mod_type_out=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isUpcSharedType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgModifierType.html">SgModifierType</a> **&nbsp;</td>
          <td class="paramname"> <em>mod_type_out</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if a type is a UPC shared type, including shared array, shared pointers etc. Exclude private pointers to shared types. Optionally return the modifier type with the UPC shared property. 
<p>
<a class="el" href="namespaceROSE.html">ROSE</a> uses <a class="el" href="classSgArrayType.html">SgArrayType</a> of <a class="el" href="classSgModifierType.html">SgModifierType</a> to represent shared arrays, not <a class="el" href="classSgModifierType.html">SgModifierType</a> points to <a class="el" href="classSgArrayType.html">SgArrayType</a>. Also typedef may cause a chain of nodes before reach the actual <a class="el" href="classSgModifierType.html">SgModifierType</a> with UPC shared property. 
</div>
</div><p>
<a class="anchor" name="d54acda16a47a2c0cfbf2cfb9acbe8ee"></a><!-- doxytag: member="SageInterface::isUpcSharedModifierType" ref="d54acda16a47a2c0cfbf2cfb9acbe8ee" args="(SgModifierType *mod_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isUpcSharedModifierType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgModifierType.html">SgModifierType</a> *&nbsp;</td>
          <td class="paramname"> <em>mod_type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if a modifier type is a UPC shared type. 
<p>

</div>
</div><p>
<a class="anchor" name="4d265b598c37bc424f98b5a95573ff15"></a><!-- doxytag: member="SageInterface::isUpcSharedArrayType" ref="4d265b598c37bc424f98b5a95573ff15" args="(SgArrayType *array_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isUpcSharedArrayType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgArrayType.html">SgArrayType</a> *&nbsp;</td>
          <td class="paramname"> <em>array_type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if an array type is a UPC shared type. <a class="el" href="namespaceROSE.html">ROSE</a> AST represents a UPC shared array as regular array of elements of UPC shared Modifier Type. Not directly a UPC shared Modifier Type of an array. 
<p>

</div>
</div><p>
<a class="anchor" name="3a8ddc7cf87c39a61529012d179d3dbe"></a><!-- doxytag: member="SageInterface::isUpcStrictSharedModifierType" ref="3a8ddc7cf87c39a61529012d179d3dbe" args="(SgModifierType *mode_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isUpcStrictSharedModifierType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgModifierType.html">SgModifierType</a> *&nbsp;</td>
          <td class="paramname"> <em>mode_type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if a shared UPC type is strict memory consistency or not. Return false if it is relaxed. (So isUpcRelaxedSharedModifierType() is not necessary.). 
<p>

</div>
</div><p>
<a class="anchor" name="ad5db4074aa860d969211e082b1fda2a"></a><!-- doxytag: member="SageInterface::getUpcSharedBlockSize" ref="ad5db4074aa860d969211e082b1fda2a" args="(SgModifierType *mod_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SageInterface::getUpcSharedBlockSize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgModifierType.html">SgModifierType</a> *&nbsp;</td>
          <td class="paramname"> <em>mod_type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the block size of a UPC shared modifier type. 
<p>

</div>
</div><p>
<a class="anchor" name="a4517f3d9eb77e8c20978d259f05dae9"></a><!-- doxytag: member="SageInterface::getUpcSharedBlockSize" ref="a4517f3d9eb77e8c20978d259f05dae9" args="(SgType *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SageInterface::getUpcSharedBlockSize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the block size of a UPC shared type, including Modifier types and array of modifier types (shared arrays). 
<p>

</div>
</div><p>
<a class="anchor" name="78e18bb017714a961c89e99658deaf62"></a><!-- doxytag: member="SageInterface::isUpcPhaseLessSharedType" ref="78e18bb017714a961c89e99658deaf62" args="(SgType *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isUpcPhaseLessSharedType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is UPC phase-less shared type? Phase-less means block size of the first <a class="el" href="classSgModifierType.html">SgModifierType</a> with UPC information is 1 or 0/unspecified. Also return false if the type is not a UPC shared type. 
<p>

</div>
</div><p>
<a class="anchor" name="a8dfe505ebec9aa2cc591ab6abd2eee6"></a><!-- doxytag: member="SageInterface::isUpcPrivateToSharedType" ref="a8dfe505ebec9aa2cc591ab6abd2eee6" args="(SgType *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isUpcPrivateToSharedType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgType.html">SgType</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is a UPC private-to-shared pointer? <a class="el" href="classSgPointerType.html">SgPointerType</a> comes first compared to <a class="el" href="classSgModifierType.html">SgModifierType</a> with UPC information. Input type must be any of UPC shared types first. 
<p>

</div>
</div><p>
<a class="anchor" name="c9d12d48cbb70bd32351ef1d11bf8a03"></a><!-- doxytag: member="SageInterface::isUpcArrayWithThreads" ref="c9d12d48cbb70bd32351ef1d11bf8a03" args="(SgArrayType *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isUpcArrayWithThreads           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgArrayType.html">SgArrayType</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is a UPC array with dimension of X*THREADS. 
<p>

</div>
</div><p>
<a class="anchor" name="ef8c45dd50e90745d7a58043ff115b59"></a><!-- doxytag: member="SageInterface::lookupNamedTypeInParentScopes" ref="ef8c45dd50e90745d7a58043ff115b59" args="(const std::string &amp;type_name, SgScopeStatement *scope=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgType.html">SgType</a>* SageInterface::lookupNamedTypeInParentScopes           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lookup a named type based on its name, bottomup searching from a specified scope. Note name collison might be allowed for c (not C++) between typedef and enum/struct. Only the first matched named type will be returned in this case. typedef is returned as it is, not the base type it actually refers to. 
<p>

</div>
</div><p>
<a class="anchor" name="08fe811227383a60a96a1f35e33d58c7"></a><!-- doxytag: member="SageInterface::addStepToLoopBody" ref="08fe811227383a60a96a1f35e33d58c7" args="(SgScopeStatement *loopStmt, SgStatement *step)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::addStepToLoopBody           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>loopStmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>step</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a step statement to the end of a loop body Add a new label to the end of the loop, with the step statement after it; then change all continue statements in the old loop body into jumps to the label. 
<p>
For example: while (a &lt; 5) {if (a &lt; -3) continue;} (adding "a++" to end) becomes while (a &lt; 5) {if (a &lt; -3) goto label; label: a++;} 
</div>
</div><p>
<a class="anchor" name="8350cdaa61eb225618e5d32d1d6ead35"></a><!-- doxytag: member="SageInterface::moveForStatementIncrementIntoBody" ref="8350cdaa61eb225618e5d32d1d6ead35" args="(SgForStatement *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::moveForStatementIncrementIntoBody           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgForStatement.html">SgForStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a step statement to the end of a loop body Add a new label to the end of the loop, with the step statement after it; then change all continue statements in the old loop body into jumps to the label. 
<p>
For example: while (a &lt; 5) {if (a &lt; -3) continue;} (adding "a++" to end) becomes while (a &lt; 5) {if (a &lt; -3) goto label; label: a++;} 
</div>
</div><p>
<a class="anchor" name="d8b390197b2be6ccda0b4cd5f5db5924"></a><!-- doxytag: member="SageInterface::convertForToWhile" ref="d8b390197b2be6ccda0b4cd5f5db5924" args="(SgForStatement *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::convertForToWhile           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgForStatement.html">SgForStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a step statement to the end of a loop body Add a new label to the end of the loop, with the step statement after it; then change all continue statements in the old loop body into jumps to the label. 
<p>
For example: while (a &lt; 5) {if (a &lt; -3) continue;} (adding "a++" to end) becomes while (a &lt; 5) {if (a &lt; -3) goto label; label: a++;} 
</div>
</div><p>
<a class="anchor" name="a952504e784c3893ff962859c02db863"></a><!-- doxytag: member="SageInterface::convertAllForsToWhiles" ref="a952504e784c3893ff962859c02db863" args="(SgNode *top)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::convertAllForsToWhiles           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>top</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a step statement to the end of a loop body Add a new label to the end of the loop, with the step statement after it; then change all continue statements in the old loop body into jumps to the label. 
<p>
For example: while (a &lt; 5) {if (a &lt; -3) continue;} (adding "a++" to end) becomes while (a &lt; 5) {if (a &lt; -3) goto label; label: a++;} 
</div>
</div><p>
<a class="anchor" name="a3c334c13af3f52296a321d7c35baa23"></a><!-- doxytag: member="SageInterface::changeContinuesToGotos" ref="a3c334c13af3f52296a321d7c35baa23" args="(SgStatement *stmt, SgLabelStatement *label)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::changeContinuesToGotos           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgLabelStatement.html">SgLabelStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>label</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Change continue statements in a given block of code to gotos to a label. 
<p>

</div>
</div><p>
<a class="anchor" name="a665b7831b78df5befccba361619e346"></a><!-- doxytag: member="SageInterface::getLoopIndexVariable" ref="a665b7831b78df5befccba361619e346" args="(SgNode *loop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgInitializedName.html">SgInitializedName</a>* SageInterface::getLoopIndexVariable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>loop</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the loop index variable for a for loop. 
<p>

</div>
</div><p>
<a class="anchor" name="21ef5a8bfe9a660dbe9206d50f1750ce"></a><!-- doxytag: member="SageInterface::isLoopIndexVariable" ref="21ef5a8bfe9a660dbe9206d50f1750ce" args="(SgInitializedName *ivar, SgNode *subtree_root)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isLoopIndexVariable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgInitializedName.html">SgInitializedName</a> *&nbsp;</td>
          <td class="paramname"> <em>ivar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>subtree_root</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if a <a class="el" href="classSgInitializedName.html">SgInitializedName</a> is used as a loop index within a AST subtree This function will use a bottom-up traverse starting from the subtree_root to find all enclosing loops and check if ivar is used as an index for either of them. 
<p>

</div>
</div><p>
<a class="anchor" name="cdd84b0f648aacdf4d31692bbff98c42"></a><!-- doxytag: member="SageInterface::getLoopBody" ref="cdd84b0f648aacdf4d31692bbff98c42" args="(SgScopeStatement *loop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgStatement.html">SgStatement</a>* SageInterface::getLoopBody           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>loop</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Routines to get and set the body of a loop. 
<p>

</div>
</div><p>
<a class="anchor" name="e79df849100431065061cb615b27b5e7"></a><!-- doxytag: member="SageInterface::setLoopBody" ref="e79df849100431065061cb615b27b5e7" args="(SgScopeStatement *loop, SgStatement *body)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::setLoopBody           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>body</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a step statement to the end of a loop body Add a new label to the end of the loop, with the step statement after it; then change all continue statements in the old loop body into jumps to the label. 
<p>
For example: while (a &lt; 5) {if (a &lt; -3) continue;} (adding "a++" to end) becomes while (a &lt; 5) {if (a &lt; -3) goto label; label: a++;} 
</div>
</div><p>
<a class="anchor" name="8a48fa3afe244bdceaf9201f217d9873"></a><!-- doxytag: member="SageInterface::getLoopCondition" ref="8a48fa3afe244bdceaf9201f217d9873" args="(SgScopeStatement *loop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgStatement.html">SgStatement</a>* SageInterface::getLoopCondition           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>loop</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Routines to get the condition of a loop. It recognize While-loop, For-loop, and Do-While-loop. 
<p>

</div>
</div><p>
<a class="anchor" name="3368c7c03cdd8fad0ff4dde8ac17a7bc"></a><!-- doxytag: member="SageInterface::setLoopCondition" ref="3368c7c03cdd8fad0ff4dde8ac17a7bc" args="(SgScopeStatement *loop, SgStatement *cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::setLoopCondition           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>cond</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the condition statement of a loop, including While-loop, For-loop, and Do-While-loop. 
<p>

</div>
</div><p>
<a class="anchor" name="8fee9383277837dceac3130968eb447a"></a><!-- doxytag: member="SageInterface::isCanonicalForLoop" ref="8fee9383277837dceac3130968eb447a" args="(SgNode *loop, SgInitializedName **ivar=NULL, SgExpression **lb=NULL, SgExpression **ub=NULL, SgExpression **step=NULL, SgStatement **body=NULL, bool *hasIncrementalIterationSpace=NULL, bool *isInclusiveUpperBound=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isCanonicalForLoop           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgInitializedName.html">SgInitializedName</a> **&nbsp;</td>
          <td class="paramname"> <em>ivar</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> **&nbsp;</td>
          <td class="paramname"> <em>lb</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> **&nbsp;</td>
          <td class="paramname"> <em>ub</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> **&nbsp;</td>
          <td class="paramname"> <em>step</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> **&nbsp;</td>
          <td class="paramname"> <em>body</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>hasIncrementalIterationSpace</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>isInclusiveUpperBound</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if a for-loop has a canonical form, return loop index, bounds, step, and body if requested. 
<p>
A canonical form is defined as : one initialization statement, a test expression, and an increment expression , loop index variable should be of an integer type. IsInclusiveUpperBound is true when &lt;= or &gt;= is used for loop condition 
</div>
</div><p>
<a class="anchor" name="25ecfa1b43bb6bef8e6f0c4217206638"></a><!-- doxytag: member="SageInterface::isCanonicalDoLoop" ref="25ecfa1b43bb6bef8e6f0c4217206638" args="(SgFortranDo *loop, SgInitializedName **ivar, SgExpression **lb, SgExpression **ub, SgExpression **step, SgStatement **body, bool *hasIncrementalIterationSpace, bool *isInclusiveUpperBound)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isCanonicalDoLoop           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFortranDo.html">SgFortranDo</a> *&nbsp;</td>
          <td class="paramname"> <em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgInitializedName.html">SgInitializedName</a> **&nbsp;</td>
          <td class="paramname"> <em>ivar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> **&nbsp;</td>
          <td class="paramname"> <em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> **&nbsp;</td>
          <td class="paramname"> <em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> **&nbsp;</td>
          <td class="paramname"> <em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> **&nbsp;</td>
          <td class="paramname"> <em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>hasIncrementalIterationSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>isInclusiveUpperBound</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if a Fortran Do loop has a complete canonical form: Do I=1, 10, 1. 
<p>

</div>
</div><p>
<a class="anchor" name="9def1f61dcf1d975ebd823f921dc4a92"></a><!-- doxytag: member="SageInterface::setLoopLowerBound" ref="9def1f61dcf1d975ebd823f921dc4a92" args="(SgNode *loop, SgExpression *lb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::setLoopLowerBound           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>lb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the lower bound of a loop header for (i=lb; ...). 
<p>

</div>
</div><p>
<a class="anchor" name="cc572630786f0e865742cc8274992e8b"></a><!-- doxytag: member="SageInterface::setLoopUpperBound" ref="cc572630786f0e865742cc8274992e8b" args="(SgNode *loop, SgExpression *ub)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::setLoopUpperBound           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>ub</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the upper bound of a loop header,regardless the condition expression type. for (i=lb; i op up, ...). 
<p>

</div>
</div><p>
<a class="anchor" name="7ad626782e4cd15b81d486f1012e3944"></a><!-- doxytag: member="SageInterface::setLoopStride" ref="7ad626782e4cd15b81d486f1012e3944" args="(SgNode *loop, SgExpression *stride)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::setLoopStride           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>stride</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the stride(step) of a loop 's incremental expression, regardless the expression types (i+=s; i= i+s, etc). 
<p>

</div>
</div><p>
<a class="anchor" name="56ad0d54049c684d5af206864adf7390"></a><!-- doxytag: member="SageInterface::normalizeForLoopInitDeclaration" ref="56ad0d54049c684d5af206864adf7390" args="(SgForStatement *loop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::normalizeForLoopInitDeclaration           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgForStatement.html">SgForStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>loop</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Normalize loop init stmt by promoting the single variable declaration statement outside of the for loop header's init statement, e.g. for (int i=0;) becomes int i_x; for (i_x=0;..) and rewrite the loop with the new index variable, if necessary. 
<p>

</div>
</div><p>
<a class="anchor" name="a500ce86ded48ff840d829a33e08b0d6"></a><!-- doxytag: member="SageInterface::forLoopNormalization" ref="a500ce86ded48ff840d829a33e08b0d6" args="(SgForStatement *loop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::forLoopNormalization           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgForStatement.html">SgForStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>loop</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Normalize a for loop, return true if successful. 
<p>
Translations are : For the init statement: for (int i=0;... ) becomes int i; for (i=0;..) For test expression: i&lt;x is normalized to i&lt;= (x-1) and i&gt;x is normalized to i&gt;= (x+1) For increment expression: i++ is normalized to i+=1 and i-- is normalized to i+=-1 i-=s is normalized to i+= -s 
</div>
</div><p>
<a class="anchor" name="714c3bd1a8ad05aefd0a374f5449a975"></a><!-- doxytag: member="SageInterface::doLoopNormalization" ref="714c3bd1a8ad05aefd0a374f5449a975" args="(SgFortranDo *loop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::doLoopNormalization           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFortranDo.html">SgFortranDo</a> *&nbsp;</td>
          <td class="paramname"> <em>loop</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Normalize a Fortran Do loop. Make the default increment expression (1) explicit. 
<p>

</div>
</div><p>
<a class="anchor" name="32c1cd741a34e12e81515e3e6e3ce6a1"></a><!-- doxytag: member="SageInterface::loopUnrolling" ref="32c1cd741a34e12e81515e3e6e3ce6a1" args="(SgForStatement *loop, size_t unrolling_factor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::loopUnrolling           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgForStatement.html">SgForStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>unrolling_factor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unroll a target loop with a specified unrolling factor. It handles steps larger than 1 and adds a fringe loop if the iteration count is not evenly divisible by the unrolling factor. 
<p>

</div>
</div><p>
<a class="anchor" name="69c06c565033135bf031e02547d7ffd7"></a><!-- doxytag: member="SageInterface::loopInterchange" ref="69c06c565033135bf031e02547d7ffd7" args="(SgForStatement *loop, size_t depth, size_t lexicoOrder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::loopInterchange           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgForStatement.html">SgForStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>lexicoOrder</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interchange/permutate a n-level perfectly-nested loop rooted at 'loop' using a lexicographical order number within (0,depth!). 
<p>

</div>
</div><p>
<a class="anchor" name="bf67276dd03b4d83fd53e8d17cfee342"></a><!-- doxytag: member="SageInterface::loopTiling" ref="bf67276dd03b4d83fd53e8d17cfee342" args="(SgForStatement *loopNest, size_t targetLevel, size_t tileSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::loopTiling           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgForStatement.html">SgForStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>loopNest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>targetLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>tileSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tile the n-level (starting from 1) loop of a perfectly nested loop nest using tiling size s. 
<p>

</div>
</div><p>
<a class="anchor" name="1123219ebb32a1140a1c10e73b97ca22"></a><!-- doxytag: member="SageInterface::querySubTree" ref="1123219ebb32a1140a1c10e73b97ca22" args="(SgNode *top, VariantT variant=(VariantT) NodeType::static_variant)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;NodeType*&gt; SageInterface::querySubTree           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a>&nbsp;</td>
          <td class="paramname"> <em>variant</em> = <code>(<a class="el" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a>)NodeType::static_variant</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Query a subtree to get all nodes of a given type, with an appropriate downcast. 
<p>

<p>
Definition at line <a class="el" href="sageInterface_8h-source.html#l00952">952</a> of file <a class="el" href="sageInterface_8h-source.html">sageInterface.h</a>.
<p>
Referenced by <a class="el" href="yicesParserLib_8h-source.html#l02442">yicesCheck()</a>.
</div>
</div><p>
<a class="anchor" name="e033e337d88d92aa952932fdb077cbe4"></a><!-- doxytag: member="SageInterface::generateFileList" ref="e033e337d88d92aa952932fdb077cbe4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classSgFile.html">SgFile</a> * &gt; SageInterface::generateFileList           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns STL vector of <a class="el" href="classSgFile.html">SgFile</a> IR node pointers. 
<p>
Demonstrates use of restricted traversal over just <a class="el" href="classSgFile.html">SgFile</a> IR nodes. 
</div>
</div><p>
<a class="anchor" name="c2c6c9fdb8ba0b9a21677e11014216cf"></a><!-- doxytag: member="SageInterface::getProject" ref="c2c6c9fdb8ba0b9a21677e11014216cf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgProject.html">SgProject</a>* SageInterface::getProject           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current <a class="el" href="classSgProject.html">SgProject</a> IR Node. 
<p>

</div>
</div><p>
<a class="anchor" name="71fa312dbb8ef1d9a37f6897de49fcce"></a><!-- doxytag: member="SageInterface::getSgNodeListFromMemoryPool" ref="71fa312dbb8ef1d9a37f6897de49fcce" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;NodeType*&gt; SageInterface::getSgNodeListFromMemoryPool           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Query memory pools to grab <a class="el" href="classSgNode.html">SgNode</a> of a specified type. 
<p>

<p>
Definition at line <a class="el" href="sageInterface_8h-source.html#l00976">976</a> of file <a class="el" href="sageInterface_8h-source.html">sageInterface.h</a>.
</div>
</div><p>
<a class="anchor" name="0c4e4490c4d20ef7f32dd2d6459c7548"></a><!-- doxytag: member="SageInterface::findMain" ref="0c4e4490c4d20ef7f32dd2d6459c7548" args="(SgNode *currentNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>* SageInterface::findMain           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>currentNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
top-down traversal from current node to find the main() function declaration 
<p>

<p>
Referenced by <a class="el" href="yicesParserLib_8h-source.html#l02442">yicesCheck()</a>.
</div>
</div><p>
<a class="anchor" name="81e9af0e07a7ba45455e3a463d43ed9f"></a><!-- doxytag: member="SageInterface::findLastDeclarationStatement" ref="81e9af0e07a7ba45455e3a463d43ed9f" args="(SgScopeStatement *scope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgStatement.html">SgStatement</a>* SageInterface::findLastDeclarationStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the last declaration statement within a scope (if any). This is often useful to decide where to insert another declaration statement. 
<p>

</div>
</div><p>
<a class="anchor" name="be2c3ab6716f418f4706960427c71545"></a><!-- doxytag: member="SageInterface::getSymbolsUsedInExpression" ref="be2c3ab6716f418f4706960427c71545" args="(SgExpression *expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a>*&gt; SageInterface::getSymbolsUsedInExpression           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>expr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find referenced symbols within an expression. 
<p>

</div>
</div><p>
<a class="anchor" name="b3fd7caa53c4504d7d668336d4be8097"></a><!-- doxytag: member="SageInterface::findBreakStmts" ref="b3fd7caa53c4504d7d668336d4be8097" args="(SgStatement *code, const std::string &amp;fortranLabel=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSgBreakStmt.html">SgBreakStmt</a>*&gt; SageInterface::findBreakStmts           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>fortranLabel</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find break statements inside a particular statement, stopping at nested loops or switches. 
<p>
loops or switch statements defines their own contexts for break statements. The function will stop immediately if run on a loop or switch statement. If fortranLabel is non-empty, breaks (EXITs) to that label within nested loops are included in the returned list. 
</div>
</div><p>
<a class="anchor" name="d8f642bb83545acd486c40aeb6f3093f"></a><!-- doxytag: member="SageInterface::findContinueStmts" ref="d8f642bb83545acd486c40aeb6f3093f" args="(SgStatement *code, const std::string &amp;fortranLabel=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSgContinueStmt.html">SgContinueStmt</a>*&gt; SageInterface::findContinueStmts           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>fortranLabel</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find all continue statements inside a particular statement, stopping at nested loops. 
<p>
Nested loops define their own contexts for continue statements. The function will stop immediately if run on a loop statement. If fortranLabel is non-empty, continues (CYCLEs) to that label within nested loops are included in the returned list. 
</div>
</div><p>
<a class="anchor" name="c7ba7b7b9738ec66d5e39a0beb16e900"></a><!-- doxytag: member="SageInterface::findGotoStmts" ref="c7ba7b7b9738ec66d5e39a0beb16e900" args="(SgStatement *scope, SgLabelStatement *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSgGotoStatement.html">SgGotoStatement</a>*&gt; SageInterface::findGotoStmts           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgLabelStatement.html">SgLabelStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>l</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Query a subtree to get all nodes of a given type, with an appropriate downcast. 
<p>

</div>
</div><p>
<a class="anchor" name="51e681c5508ac6c664ed3dabdd230323"></a><!-- doxytag: member="SageInterface::getSwitchCases" ref="51e681c5508ac6c664ed3dabdd230323" args="(SgSwitchStatement *sw)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSgStatement.html">SgStatement</a>*&gt; SageInterface::getSwitchCases           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgSwitchStatement.html">SgSwitchStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>sw</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Query a subtree to get all nodes of a given type, with an appropriate downcast. 
<p>

</div>
</div><p>
<a class="anchor" name="b36728bc3a9ee699fb33c04efbb1b553"></a><!-- doxytag: member="SageInterface::findDeclarationStatement" ref="b36728bc3a9ee699fb33c04efbb1b553" args="(SgNode *root, std::string name, SgScopeStatement *scope, bool isDefining)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* SageInterface::findDeclarationStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isDefining</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Topdown traverse a subtree from root to find the first declaration given its name, scope (optional, can be NULL), and defining or nondefining flag. 
<p>

<p>
Definition at line <a class="el" href="sageInterface_8h-source.html#l01032">1032</a> of file <a class="el" href="sageInterface_8h-source.html">sageInterface.h</a>.
<p>
References <a class="el" href="classSgNode.html#8f2fdab2e0a2561e9cb2d783703a8598">SgNode::get_traversalSuccessorContainer()</a>.
</div>
</div><p>
<a class="anchor" name="25ba093b55f9983f1f3c385563e1b880"></a><!-- doxytag: member="SageInterface::findFunctionDeclaration" ref="25ba093b55f9983f1f3c385563e1b880" args="(SgNode *root, std::string name, SgScopeStatement *scope, bool isDefining)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>* SageInterface::findFunctionDeclaration           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isDefining</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Topdown traverse a subtree from root to find the first function declaration matching the given name, scope (optional, can be NULL), and defining or nondefining flag. This is an instantiation of findDeclarationStatement&lt;T&gt;. 
<p>

</div>
</div><p>
<a class="anchor" name="0e13c06070acba9a4028596b14df37c0"></a><!-- doxytag: member="SageInterface::getEnclosingNode" ref="0e13c06070acba9a4028596b14df37c0" args="(const SgNode *astNode, const bool includingSelf=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NodeType* SageInterface::getEnclosingNode           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>astNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>includingSelf</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find a node by type using upward traversal. 
<p>
Traverse backward through a specified node's ancestors, starting with the node's parent and progressing to more distant ancestors, to find the first node matching the specified or derived type. If <code>includingSelf</code> is true then the starting node, <code>astNode</code>, is returned if its type matches, otherwise the search starts at the parent of <code>astNode</code>.<p>
If no ancestor of the requisite type of subtypes is found then this function returns a null pointer.<p>
If <code>astNode</code> is the null pointer, then the return value is a null pointer. That is, if there is no node, then there cannot be an enclosing node of the specified type. 
<p>
Definition at line <a class="el" href="sageInterface_8h-source.html#l01094">1094</a> of file <a class="el" href="sageInterface_8h-source.html">sageInterface.h</a>.
</div>
</div><p>
<a class="anchor" name="6ec13831a4d9c0142db2f595d56ce862"></a><!-- doxytag: member="SageInterface::getScope" ref="6ec13831a4d9c0142db2f595d56ce862" args="(const SgNode *astNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a>* SageInterface::getScope           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>astNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the closest scope from astNode. Return astNode if it is already a scope. 
<p>

</div>
</div><p>
<a class="anchor" name="108fb9317605cd9d1228cb156993e34d"></a><!-- doxytag: member="SageInterface::getGlobalScope" ref="108fb9317605cd9d1228cb156993e34d" args="(const SgNode *astNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgGlobal.html">SgGlobal</a>* SageInterface::getGlobalScope           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>astNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Traverse back through a node's parents to find the enclosing global scope. 
<p>

</div>
</div><p>
<a class="anchor" name="3d1cde13da7917ba2ac6005d266f934d"></a><!-- doxytag: member="SageInterface::getEnclosingProcedure" ref="3d1cde13da7917ba2ac6005d266f934d" args="(SgNode *n, const bool includingSelf=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a>* SageInterface::getEnclosingProcedure           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>includingSelf</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the function definition. 
<p>

</div>
</div><p>
<a class="anchor" name="89a3cd0446fb308e841a8844ec69f96e"></a><!-- doxytag: member="SageInterface::getEnclosingFunctionDefinition" ref="89a3cd0446fb308e841a8844ec69f96e" args="(SgNode *astNode, const bool includingSelf=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a>* SageInterface::getEnclosingFunctionDefinition           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>astNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>includingSelf</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find a node by type using upward traversal. 
<p>
Traverse backward through a specified node's ancestors, starting with the node's parent and progressing to more distant ancestors, to find the first node matching the specified or derived type. If <code>includingSelf</code> is true then the starting node, <code>astNode</code>, is returned if its type matches, otherwise the search starts at the parent of <code>astNode</code>.<p>
If no ancestor of the requisite type of subtypes is found then this function returns a null pointer.<p>
If <code>astNode</code> is the null pointer, then the return value is a null pointer. That is, if there is no node, then there cannot be an enclosing node of the specified type. 
</div>
</div><p>
<a class="anchor" name="5717c88c4a9675c30069319cfe913127"></a><!-- doxytag: member="SageInterface::getEnclosingStatement" ref="5717c88c4a9675c30069319cfe913127" args="(SgNode *n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgStatement.html">SgStatement</a>* SageInterface::getEnclosingStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the closest enclosing statement, including the given node. 
<p>

</div>
</div><p>
<a class="anchor" name="ac586c26b215b6fb86a99370905e2044"></a><!-- doxytag: member="SageInterface::findEnclosingSwitch" ref="ac586c26b215b6fb86a99370905e2044" args="(SgStatement *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgSwitchStatement.html">SgSwitchStatement</a>* SageInterface::findEnclosingSwitch           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the closest switch outside a given statement (normally used for case and default statements). 
<p>

</div>
</div><p>
<a class="anchor" name="9fc733ce75b79e34e7c85c0e5b5b1d1a"></a><!-- doxytag: member="SageInterface::findEnclosingLoop" ref="9fc733ce75b79e34e7c85c0e5b5b1d1a" args="(SgStatement *s, const std::string &amp;fortranLabel=&quot;&quot;, bool stopOnSwitches=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a>* SageInterface::findEnclosingLoop           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>fortranLabel</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>stopOnSwitches</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the closest loop outside the given statement; if fortranLabel is not empty, the Fortran label of the loop must be equal to it. 
<p>

</div>
</div><p>
<a class="anchor" name="ac9b45bdb148ec342cf14c95f39e64f9"></a><!-- doxytag: member="SageInterface::getEnclosingFunctionDeclaration" ref="ac9b45bdb148ec342cf14c95f39e64f9" args="(SgNode *astNode, const bool includingSelf=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>* SageInterface::getEnclosingFunctionDeclaration           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>astNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>includingSelf</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the enclosing function declaration, including its derived instances like isSgProcedureHeaderStatement, isSgProgramHeaderStatement, and isSgMemberFunctionDeclaration. 
<p>

</div>
</div><p>
<a class="anchor" name="73600ebdd020f6ffed566018c22e20b8"></a><!-- doxytag: member="SageInterface::getEnclosingFileNode" ref="73600ebdd020f6ffed566018c22e20b8" args="(SgNode *astNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgFile.html">SgFile</a>* SageInterface::getEnclosingFileNode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>astNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
get the <a class="el" href="classSgFile.html">SgFile</a> node from current node 
<p>

</div>
</div><p>
<a class="anchor" name="a7ab26b36b4ddffb9db2c7f2160322c8"></a><!-- doxytag: member="SageInterface::getInitializerOfExpression" ref="a7ab26b36b4ddffb9db2c7f2160322c8" args="(SgExpression *n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgInitializer.html">SgInitializer</a>* SageInterface::getInitializerOfExpression           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the initializer containing an expression if it is within an initializer. 
<p>

</div>
</div><p>
<a class="anchor" name="f3212dbf1eb743a7f9cd2ed35142cd5f"></a><!-- doxytag: member="SageInterface::getEnclosingClassDefinition" ref="f3212dbf1eb743a7f9cd2ed35142cd5f" args="(SgNode *astnode, const bool includingSelf=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgClassDefinition.html">SgClassDefinition</a>* SageInterface::getEnclosingClassDefinition           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>astnode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>includingSelf</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the closest class definition enclosing the specified AST node,. 
<p>

</div>
</div><p>
<a class="anchor" name="b45dc06ff0224928a1ae1da997e52b08"></a><!-- doxytag: member="SageInterface::getFirstGlobalScope" ref="b45dc06ff0224928a1ae1da997e52b08" args="(SgProject *project)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgGlobal.html">SgGlobal</a>* SageInterface::getFirstGlobalScope           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgProject.html">SgProject</a> *&nbsp;</td>
          <td class="paramname"> <em>project</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
return the first global scope under current project 
<p>

</div>
</div><p>
<a class="anchor" name="4ad89114f9b3edc1d78c4ed0361b7b8c"></a><!-- doxytag: member="SageInterface::getLastStatement" ref="4ad89114f9b3edc1d78c4ed0361b7b8c" args="(SgScopeStatement *scope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgStatement.html">SgStatement</a>* SageInterface::getLastStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
get the last statement within a scope, return NULL if it does not exit 
<p>

</div>
</div><p>
<a class="anchor" name="2b15b529d2da9a8b370adc56def709fb"></a><!-- doxytag: member="SageInterface::getFirstStatement" ref="2b15b529d2da9a8b370adc56def709fb" args="(SgScopeStatement *scope, bool includingCompilerGenerated=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgStatement.html">SgStatement</a>* SageInterface::getFirstStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>includingCompilerGenerated</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the first statement within a scope, return NULL if it does not exist. Skip compiler-generated statement by default. Count transformation-generated ones, but excluding those which are not to be outputted in unparsers. 
<p>

</div>
</div><p>
<a class="anchor" name="d3bb1a781eb5b2ece057e620dcc3f83c"></a><!-- doxytag: member="SageInterface::findFirstDefiningFunctionDecl" ref="d3bb1a781eb5b2ece057e620dcc3f83c" args="(SgScopeStatement *scope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a>* SageInterface::findFirstDefiningFunctionDecl           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the first defining function declaration statement in a scope. 
<p>

</div>
</div><p>
<a class="anchor" name="514decfd76850247d4e84d54f88ce1c9"></a><!-- doxytag: member="SageInterface::getNextStatement" ref="514decfd76850247d4e84d54f88ce1c9" args="(SgStatement *currentStmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgStatement.html">SgStatement</a>* SageInterface::getNextStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>currentStmt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get next statement within the same scope of current statement. 
<p>

</div>
</div><p>
<a class="anchor" name="1f85e0ded2e249c9e54b4204eeeed113"></a><!-- doxytag: member="SageInterface::getPreviousStatement" ref="1f85e0ded2e249c9e54b4204eeeed113" args="(SgStatement *currentStmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgStatement.html">SgStatement</a>* SageInterface::getPreviousStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>currentStmt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get previous statement within the same scope of current statement. 
<p>

</div>
</div><p>
<a class="anchor" name="6b16a27989aff98b861e3a677563ae42"></a><!-- doxytag: member="SageInterface::isEqualToIntConst" ref="6b16a27989aff98b861e3a677563ae42" args="(SgExpression *e, int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isEqualToIntConst           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if a <a class="el" href="classSgIntVal.html">SgIntVal</a> node has a given value. 
<p>

</div>
</div><p>
<a class="anchor" name="2ad29ecfbbcca49188ceb7468e91ae74"></a><!-- doxytag: member="SageInterface::isSameFunction" ref="2ad29ecfbbcca49188ceb7468e91ae74" args="(SgFunctionDeclaration *func1, SgFunctionDeclaration *func2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isSameFunction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>func1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>func2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if two function declarations refer to the same one. Two function declarations are the same when they are a) identical, b) same name in C c) same qualified named and mangled name in C++. A nondefining (prototype) declaration and a defining declaration of a same function are treated as the same. 
<p>
There is a similar function bool compareFunctionDeclarations(SgFunctionDeclaration *f1, SgFunctionDeclaration *f2) from Classhierarchy.C 
</div>
</div><p>
<a class="anchor" name="01df9113c49dfbd3f7145e9a8259d125"></a><!-- doxytag: member="SageInterface::isLastStatement" ref="01df9113c49dfbd3f7145e9a8259d125" args="(SgStatement *stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isLastStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if a statement is the last statement within its closed scope. 
<p>

</div>
</div><p>
<a class="anchor" name="57437bbbb806858dda0cea7444fbafef"></a><!-- doxytag: member="SageInterface::deleteAST" ref="57437bbbb806858dda0cea7444fbafef" args="(SgNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::deleteAST           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classFunction.html">Function</a> to delete AST subtree's nodes only, users must take care of any dangling pointers, symbols or types that result. 
<p>

<p>
Referenced by <a class="el" href="Disassembler_8C-source.html#l00324">Disassembler::disassembleBlock()</a>, <a class="el" href="Disassembler_8C-source.html#l00441">Disassembler::disassembleBuffer()</a>, <a class="el" href="Partitioner_8C-source.html#l01019">Partitioner::mark_ipd_configuration()</a>, <a class="el" href="AsmUnparser_8C-source.html#l00901">AsmUnparser::StaticDataDisassembler::operator()()</a>, <a class="el" href="PeImportSection_8C-source.html#l00196">SgAsmPEImportSection::parse()</a>, <a class="el" href="ExecGeneric_8C-source.html#l00043">SgAsmExecutableFileFormat::parseBinaryFormat()</a>, <a class="el" href="GenericSection_8C-source.html#l00135">SgAsmGenericSection::set_name()</a>, <a class="el" href="GenericDynamicLinking_8C-source.html#l00061">SgAsmGenericSymbol::set_name()</a>, <a class="el" href="GenericDynamicLinking_8C-source.html#l00012">SgAsmGenericDLL::set_name()</a>, <a class="el" href="ElfNote_8C-source.html#l00027">SgAsmElfNoteEntry::set_name()</a>, <a class="el" href="ElfDynamicLinking_8C-source.html#l00064">SgAsmElfDynamicEntry::set_name()</a>, <a class="el" href="GenericFile_8C-source.html#l01289">SgAsmGenericFile::unfill_holes()</a>, and <a class="el" href="GenericSection_8C-source.html#l00027">SgAsmGenericSection::~SgAsmGenericSection()</a>.
</div>
</div><p>
<a class="anchor" name="062f0bab3b5deef80a101471d2bc0c0e"></a><!-- doxytag: member="SageInterface::deleteExpressionTreeWithOriginalExpressionSubtrees" ref="062f0bab3b5deef80a101471d2bc0c0e" args="(SgNode *root)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::deleteExpressionTreeWithOriginalExpressionSubtrees           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Special purpose function for deleting AST expression tress containing valid original expression trees in constant folded expressions (for internal use only). 
<p>

</div>
</div><p>
<a class="anchor" name="d74e38bddc8dc4d5d0506102782680ef"></a><!-- doxytag: member="SageInterface::moveStatementsBetweenBlocks" ref="d74e38bddc8dc4d5d0506102782680ef" args="(SgBasicBlock *sourceBlock, SgBasicBlock *targetBlock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::moveStatementsBetweenBlocks           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>sourceBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>targetBlock</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Move statements in first block to the second block (preserves order and rebuilds the symbol table). 
<p>

</div>
</div><p>
<a class="anchor" name="bd2b74fa3c7de0b27066790dfba32ab7"></a><!-- doxytag: member="SageInterface::appendStatement" ref="bd2b74fa3c7de0b27066790dfba32ab7" args="(SgStatement *stmt, SgScopeStatement *scope=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::appendStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append a statement to the end of the current scope, handle side effect of appending statements, e.g. preprocessing info, defining/nondefining pointers etc. 
<p>

</div>
</div><p>
<a class="anchor" name="dc3d212ae841c07933c40e4235b4f0a9"></a><!-- doxytag: member="SageInterface::appendStatementList" ref="dc3d212ae841c07933c40e4235b4f0a9" args="(const std::vector&lt; SgStatement * &gt; &amp;stmt, SgScopeStatement *scope=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::appendStatementList           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgStatement.html">SgStatement</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append a list of statements to the end of the current scope, handle side effect of appending statements, e.g. preprocessing info, defining/nondefining pointers etc. 
<p>

</div>
</div><p>
<a class="anchor" name="6d20d118b27ab3675c748d6adb2ac467"></a><!-- doxytag: member="SageInterface::appendStatementWithDependentDeclaration" ref="6d20d118b27ab3675c748d6adb2ac467" args="(SgDeclarationStatement *decl, SgGlobal *scope, SgStatement *original_statement, bool excludeHeaderFiles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::appendStatementWithDependentDeclaration           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgGlobal.html">SgGlobal</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>original_statement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>excludeHeaderFiles</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append a copy ('decl') of a function ('original_statement') into a 'scope', include any referenced declarations required if the scope is within a compiler generated file. All referenced declarations, including those from headers, are inserted if excludeHeaderFiles is set to true (the new file will not have any headers). 
<p>

</div>
</div><p>
<a class="anchor" name="e9c30cd9d9c2589e9534638c7a79e731"></a><!-- doxytag: member="SageInterface::prependStatement" ref="e9c30cd9d9c2589e9534638c7a79e731" args="(SgStatement *stmt, SgScopeStatement *scope=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::prependStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prepend a statement to the beginning of the current scope, handling side effects as appropriate. 
<p>

</div>
</div><p>
<a class="anchor" name="150082ead31a73a3cd272f7428521823"></a><!-- doxytag: member="SageInterface::prependStatementList" ref="150082ead31a73a3cd272f7428521823" args="(const std::vector&lt; SgStatement * &gt; &amp;stmt, SgScopeStatement *scope=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::prependStatementList           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgStatement.html">SgStatement</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
prepend a list of statements to the beginning of the current scope, handling side effects as appropriate 
<p>

</div>
</div><p>
<a class="anchor" name="e41c86d0aefd60c26c60bd6f0ec4b76b"></a><!-- doxytag: member="SageInterface::hasSimpleChildrenList" ref="e41c86d0aefd60c26c60bd6f0ec4b76b" args="(SgScopeStatement *scope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::hasSimpleChildrenList           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if a scope statement has a simple children statement list so insert additional statements under the scope is straightforward and unambiguous . 
<p>
for example, <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a> has a simple statement list while IfStmt does not. 
</div>
</div><p>
<a class="anchor" name="54e6780cc15a76ce7bc37a1212452e66"></a><!-- doxytag: member="SageInterface::insertStatement" ref="54e6780cc15a76ce7bc37a1212452e66" args="(SgStatement *targetStmt, SgStatement *newStmt, bool insertBefore=true, bool autoMovePreprocessingInfo=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::insertStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>targetStmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>newStmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>insertBefore</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autoMovePreprocessingInfo</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a statement before or after the target statement within the target's scope. Move around preprocessing info automatically. 
<p>

</div>
</div><p>
<a class="anchor" name="07fb69a12095f93a9cbe325fe5a8b7d2"></a><!-- doxytag: member="SageInterface::insertStatementList" ref="07fb69a12095f93a9cbe325fe5a8b7d2" args="(SgStatement *targetStmt, const std::vector&lt; SgStatement * &gt; &amp;newStmts, bool insertBefore=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::insertStatementList           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>targetStmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgStatement.html">SgStatement</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>newStmts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>insertBefore</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a list of statements before or after the target statement within the. 
<p>

</div>
</div><p>
<a class="anchor" name="dab9927218b2709b3d99544db4386dc2"></a><!-- doxytag: member="SageInterface::insertStatementBefore" ref="dab9927218b2709b3d99544db4386dc2" args="(SgStatement *targetStmt, SgStatement *newStmt, bool autoMovePreprocessingInfo=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::insertStatementBefore           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>targetStmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>newStmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autoMovePreprocessingInfo</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a statement before a target statement. 
<p>

</div>
</div><p>
<a class="anchor" name="193b6b847675d342d37b9917bf0a3f43"></a><!-- doxytag: member="SageInterface::insertStatementListBefore" ref="193b6b847675d342d37b9917bf0a3f43" args="(SgStatement *targetStmt, const std::vector&lt; SgStatement * &gt; &amp;newStmts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::insertStatementListBefore           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>targetStmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgStatement.html">SgStatement</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>newStmts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a list of statements before a target statement. 
<p>

</div>
</div><p>
<a class="anchor" name="f43f1edd321a11e4a9d6fd6cf8b4bcd6"></a><!-- doxytag: member="SageInterface::insertStatementAfter" ref="f43f1edd321a11e4a9d6fd6cf8b4bcd6" args="(SgStatement *targetStmt, SgStatement *newStmt, bool autoMovePreprocessingInfo=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::insertStatementAfter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>targetStmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>newStmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autoMovePreprocessingInfo</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a statement after a target statement, Move around preprocessing info automatically by default. 
<p>

</div>
</div><p>
<a class="anchor" name="4c7e8d91522f9c76e28d35bcd76a07e6"></a><!-- doxytag: member="SageInterface::insertStatementListAfter" ref="4c7e8d91522f9c76e28d35bcd76a07e6" args="(SgStatement *targetStmt, const std::vector&lt; SgStatement * &gt; &amp;newStmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::insertStatementListAfter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>targetStmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgStatement.html">SgStatement</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>newStmt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a list of statements after a target statement. 
<p>

</div>
</div><p>
<a class="anchor" name="918939111ad1510bfc0c520156e8d9e9"></a><!-- doxytag: member="SageInterface::insertStatementAfterLastDeclaration" ref="918939111ad1510bfc0c520156e8d9e9" args="(SgStatement *stmt, SgScopeStatement *scope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::insertStatementAfterLastDeclaration           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a statement after the last declaration within a scope. The statement will be prepended to the scope if there is no declaration statement found. 
<p>

</div>
</div><p>
<a class="anchor" name="9c538bc1293c87f89917412d8729f679"></a><!-- doxytag: member="SageInterface::insertStatementAfterLastDeclaration" ref="9c538bc1293c87f89917412d8729f679" args="(std::vector&lt; SgStatement * &gt; stmt_list, SgScopeStatement *scope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::insertStatementAfterLastDeclaration           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSgStatement.html">SgStatement</a> * &gt;&nbsp;</td>
          <td class="paramname"> <em>stmt_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a list of statements after the last declaration within a scope. The statement will be prepended to the scope if there is no declaration statement found. 
<p>

</div>
</div><p>
<a class="anchor" name="f5972a33cb2e9b5723e50ceccdaccb9f"></a><!-- doxytag: member="SageInterface::removeStatement" ref="f5972a33cb2e9b5723e50ceccdaccb9f" args="(SgStatement *stmt, bool autoRelocatePreprocessingInfo=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::removeStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autoRelocatePreprocessingInfo</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove a statement from its attach point of the AST. Automatically keep its associated preprocessing information at the original place after the removal. The statement is still in memory and it is up to the users to decide if the removed one will be inserted somewhere else or released from memory (<a class="el" href="namespaceSageInterface.html#57437bbbb806858dda0cea7444fbafef">deleteAST()</a>). 
<p>

</div>
</div><p>
<a class="anchor" name="03bd60c658db463cfc3791a7bba5017a"></a><!-- doxytag: member="SageInterface::deepDelete" ref="03bd60c658db463cfc3791a7bba5017a" args="(SgNode *root)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::deepDelete           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deep delete a sub AST tree. It uses postorder traversal to delete each child node. Users must take care of any dangling pointers, symbols or types that result. This is identical to <a class="el" href="namespaceSageInterface.html#57437bbbb806858dda0cea7444fbafef">deleteAST()</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="69827cb64e737fdc661a48871c92ec96"></a><!-- doxytag: member="SageInterface::replaceStatement" ref="69827cb64e737fdc661a48871c92ec96" args="(SgStatement *oldStmt, SgStatement *newStmt, bool movePreprocessinInfo=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::replaceStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>oldStmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>newStmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>movePreprocessinInfo</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace a statement with another. Move preprocessing information from oldStmt to newStmt if requested. 
<p>

</div>
</div><p>
<a class="anchor" name="40eb9c7f467b4e0830bae948562d2d89"></a><!-- doxytag: member="SageInterface::replaceWithPattern" ref="40eb9c7f467b4e0830bae948562d2d89" args="(SgNode *anchor, SgNode *new_pattern)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgNode.html">SgNode</a>* SageInterface::replaceWithPattern           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>new_pattern</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace an anchor node with a specified pattern subtree with optional <a class="el" href="classSgVariantExpression.html">SgVariantExpression</a>. All <a class="el" href="classSgVariantExpression.html">SgVariantExpression</a> in the pattern will be replaced with copies of the anchor node. 
<p>

</div>
</div><p>
<a class="anchor" name="8b8089083afe0aca12b1c9ba64d4ddc6"></a><!-- doxytag: member="SageInterface::createTempVariableForExpression" ref="8b8089083afe0aca12b1c9ba64d4ddc6" args="(SgExpression *expression, SgScopeStatement *scope, bool initializeInDeclaration, SgAssignOp **reEvaluate=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a>*, <a class="el" href="classSgExpression.html">SgExpression</a>* &gt; SageInterface::createTempVariableForExpression           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>initializeInDeclaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAssignOp.html">SgAssignOp</a> **&nbsp;</td>
          <td class="paramname"> <em>reEvaluate</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given an expression, generates a temporary variable whose initializer optionally evaluates that expression. 
<p>
Then, the var reference expression returned can be used instead of the original expression. The temporary variable created can be reassigned to the expression by the returned <a class="el" href="classSgAssignOp.html">SgAssignOp</a>; this can be used when the expression the variable represents needs to be evaluated. NOTE: This handles reference types correctly by using pointer types for the temporary. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expression</em>&nbsp;</td><td>Expression which will be replaced by a variable </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scope</em>&nbsp;</td><td>scope in which the temporary variable will be generated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reEvaluate</em>&nbsp;</td><td>an assignment op to reevaluate the expression. Leave NULL if not needed </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>declaration of the temporary variable, and a a variable reference expression to use instead of the original expression. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ef8223b9741c08bb50c4ee85e04bbe16"></a><!-- doxytag: member="SageInterface::appendArg" ref="ef8223b9741c08bb50c4ee85e04bbe16" args="(SgFunctionParameterList *, SgInitializedName *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a>* SageInterface::appendArg           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgInitializedName.html">SgInitializedName</a> *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append an argument to <a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a>, transparently set parent,scope, and symbols for arguments when possible. 
<p>
We recommend to build <a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a> before building a function declaration However, it is still allowed to append new arguments for existing function declarations. <dl compact><dt><b><a class="el" href="todo.html#_todo000144">Todo:</a></b></dt><dd>function type , function symbol also need attention. </dd></dl>

<p>
Referenced by <a class="el" href="sageFunctors_8h-source.html#l00038">sg::_append()</a>.
</div>
</div><p>
<a class="anchor" name="e997b353e050f84a2e1663e2b0945efa"></a><!-- doxytag: member="SageInterface::prependArg" ref="e997b353e050f84a2e1663e2b0945efa" args="(SgFunctionParameterList *, SgInitializedName *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a>* SageInterface::prependArg           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgInitializedName.html">SgInitializedName</a> *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prepend an argument to <a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="e81668e6c7307d8cc9ad38de73282102"></a><!-- doxytag: member="SageInterface::appendExpression" ref="e81668e6c7307d8cc9ad38de73282102" args="(SgExprListExp *, SgExpression *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::appendExpression           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExprListExp.html">SgExprListExp</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append an expression to a <a class="el" href="classSgExprListExp.html">SgExprListExp</a>, set the parent pointer also. 
<p>

<p>
Referenced by <a class="el" href="sageFunctors_8h-source.html#l00031">sg::_append()</a>.
</div>
</div><p>
<a class="anchor" name="19c6d987024cdb9c93f33181928beaff"></a><!-- doxytag: member="SageInterface::appendExpressionList" ref="19c6d987024cdb9c93f33181928beaff" args="(SgExprListExp *, const std::vector&lt; SgExpression * &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::appendExpressionList           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExprListExp.html">SgExprListExp</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgExpression.html">SgExpression</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append an expression list to a <a class="el" href="classSgExprListExp.html">SgExprListExp</a>, set the parent pointers also. 
<p>

</div>
</div><p>
<a class="anchor" name="e4200b6d287e2c5b2d7a4d382f110863"></a><!-- doxytag: member="SageInterface::setParameterList" ref="e4200b6d287e2c5b2d7a4d382f110863" args="(SgFunctionDeclaration *func, SgFunctionParameterList *paralist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::setParameterList           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgFunctionParameterList.html">SgFunctionParameterList</a> *&nbsp;</td>
          <td class="paramname"> <em>paralist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set parameter list for a function declaration, considering existing parameter list etc. 
<p>

</div>
</div><p>
<a class="anchor" name="60d9ec8400d43be2985ea888afb69989"></a><!-- doxytag: member="SageInterface::setPragma" ref="60d9ec8400d43be2985ea888afb69989" args="(SgPragmaDeclaration *decl, SgPragma *pragma)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::setPragma           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgPragmaDeclaration.html">SgPragmaDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgPragma.html">SgPragma</a> *&nbsp;</td>
          <td class="paramname"> <em>pragma</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set a pragma of a pragma declaration. handle memory release for preexisting pragma, and set parent pointer. 
<p>

</div>
</div><p>
<a class="anchor" name="ba697ba095a90c110e020e411fd8158f"></a><!-- doxytag: member="SageInterface::replaceExpression" ref="ba697ba095a90c110e020e411fd8158f" args="(SgExpression *oldExp, SgExpression *newExp, bool keepOldExp=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::replaceExpression           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>oldExp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>newExp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>keepOldExp</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace an expression with another, used for variable reference substitution and others. the old expression can be deleted (default case) or kept. 
<p>

</div>
</div><p>
<a class="anchor" name="d85460fd6c32e78e4dda28984b0ab541"></a><!-- doxytag: member="SageInterface::replaceExpressionWithStatement" ref="d85460fd6c32e78e4dda28984b0ab541" args="(SgExpression *from, SageInterface::StatementGenerator *to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::replaceExpressionWithStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSageInterface_1_1StatementGenerator.html">SageInterface::StatementGenerator</a> *&nbsp;</td>
          <td class="paramname"> <em>to</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace a given expression with a list of statements produced by a generator. 
<p>

</div>
</div><p>
<a class="anchor" name="c8ce4794f2e0212a315bceb252fe93f2"></a><!-- doxytag: member="SageInterface::replaceSubexpressionWithStatement" ref="c8ce4794f2e0212a315bceb252fe93f2" args="(SgExpression *from, SageInterface::StatementGenerator *to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::replaceSubexpressionWithStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSageInterface_1_1StatementGenerator.html">SageInterface::StatementGenerator</a> *&nbsp;</td>
          <td class="paramname"> <em>to</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to replaceExpressionWithStatement, but with more restrictions. 
<p>
Assumptions: from is not within the test of a loop or ifStmt, not currently traversing from or the statement it is in 
</div>
</div><p>
<a class="anchor" name="abfd7a4f3af02dea61f7f808d0e60783"></a><!-- doxytag: member="SageInterface::setOperand" ref="abfd7a4f3af02dea61f7f808d0e60783" args="(SgExpression *target, SgExpression *operand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::setOperand           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>operand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set operands for expressions with single operand, such as unary expressions. handle file info, lvalue, pointer downcasting, parent pointer etc. 
<p>

</div>
</div><p>
<a class="anchor" name="78098fceed35539df0aa51de3baba983"></a><!-- doxytag: member="SageInterface::setLhsOperand" ref="78098fceed35539df0aa51de3baba983" args="(SgExpression *target, SgExpression *lhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::setLhsOperand           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>lhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
set left hand operand for binary expressions, transparently downcasting target expressions when necessary 
<p>

</div>
</div><p>
<a class="anchor" name="c30b58bb417c3b495f24207c81966716"></a><!-- doxytag: member="SageInterface::setRhsOperand" ref="c30b58bb417c3b495f24207c81966716" args="(SgExpression *target, SgExpression *rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::setRhsOperand           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
set left hand operand for binary expression 
<p>

</div>
</div><p>
<a class="anchor" name="76cf388fb6b43807542edf737bb97a96"></a><!-- doxytag: member="SageInterface::removeAllOriginalExpressionTrees" ref="76cf388fb6b43807542edf737bb97a96" args="(SgNode *top)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::removeAllOriginalExpressionTrees           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>top</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set original expression trees to NULL for <a class="el" href="classSgValueExp.html">SgValueExp</a> or <a class="el" href="classSgCastExp.html">SgCastExp</a> expressions, so you can change the value and have it unparsed correctly. 
<p>

</div>
</div><p>
<a class="anchor" name="e348901720d34fdb3f333e552bcd5253"></a><!-- doxytag: member="SageInterface::moveToSubdirectory" ref="e348901720d34fdb3f333e552bcd5253" args="(std::string directoryName, SgFile *file)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::moveToSubdirectory           </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>directoryName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgFile.html">SgFile</a> *&nbsp;</td>
          <td class="paramname"> <em>file</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Move file to be generated in a subdirectory (will be generated by the unparser). 
<p>

</div>
</div><p>
<a class="anchor" name="5b68578da4f96a5e644cfcb129a7e3dd"></a><!-- doxytag: member="SageInterface::findSurroundingStatementFromSameFile" ref="5b68578da4f96a5e644cfcb129a7e3dd" args="(SgStatement *targetStmt, bool &amp;surroundingStatementPreceedsTargetStatement)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgStatement.html">SgStatement</a>* SageInterface::findSurroundingStatementFromSameFile           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>targetStmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>surroundingStatementPreceedsTargetStatement</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Supporting function to comment relocation in <a class="el" href="namespaceSageInterface.html#54e6780cc15a76ce7bc37a1212452e66">insertStatement()</a> and <a class="el" href="namespaceSageInterface.html#f5972a33cb2e9b5723e50ceccdaccb9f">removeStatement()</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="accbb223ed5b025766c10745793d39c6"></a><!-- doxytag: member="SageInterface::moveCommentsToNewStatement" ref="accbb223ed5b025766c10745793d39c6" args="(SgStatement *sourceStatement, const std::vector&lt; int &gt; &amp;indexList, SgStatement *targetStatement, bool surroundingStatementPreceedsTargetStatement)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::moveCommentsToNewStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>sourceStatement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>indexList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>targetStatement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>surroundingStatementPreceedsTargetStatement</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Relocate comments and CPP directives from one statement to another. 
<p>

</div>
</div><p>
<a class="anchor" name="bc07365980c33e6d4f3cca65b2e73970"></a><!-- doxytag: member="SageInterface::fixVariableReferences" ref="bc07365980c33e6d4f3cca65b2e73970" args="(SgNode *root)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SageInterface::fixVariableReferences           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect variable reference to the right variable symbols when feasible, return the number of references being fixed. 
<p>
In AST translation, it is possible to build a variable reference before the variable is being declared. <a class="el" href="group__frontendSageHighLevelInterface.html#gf1b687d6de3eb0bcf76baa27dde46d1f">buildVarRefExp()</a> will use fake initialized name and symbol as placeholders to get the work done. Users should call fixVariableReference() when AST is complete and all variable declarations are in place. 
</div>
</div><p>
<a class="anchor" name="c56e358f18815a86ca4c9ad738733d37"></a><!-- doxytag: member="SageInterface::fixVariableDeclaration" ref="c56e358f18815a86ca4c9ad738733d37" args="(SgVariableDeclaration *varDecl, SgScopeStatement *scope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::fixVariableDeclaration           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>varDecl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Patch up symbol, scope, and parent information when a SgVariableDeclaration's scope is known. 
<p>
It is possible to build a variable declaration without knowing its scope information during bottom-up construction of AST, though top-down construction is recommended in general. In this case, we have to patch up symbol table, scope and parent information when the scope is known. This function is usually used internally within appendStatment(), <a class="el" href="namespaceSageInterface.html#54e6780cc15a76ce7bc37a1212452e66">insertStatement()</a>. 
</div>
</div><p>
<a class="anchor" name="198dfdbeffb7cb4e282c0045de88b29d"></a><!-- doxytag: member="SageInterface::fixStructDeclaration" ref="198dfdbeffb7cb4e282c0045de88b29d" args="(SgClassDeclaration *structDecl, SgScopeStatement *scope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::fixStructDeclaration           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgClassDeclaration.html">SgClassDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>structDecl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fix symbols, parent and scope pointers. Used internally within appendStatment(), <a class="el" href="namespaceSageInterface.html#54e6780cc15a76ce7bc37a1212452e66">insertStatement()</a> etc when a struct declaration was built without knowing its target scope. 
<p>

</div>
</div><p>
<a class="anchor" name="4e2216ac11843189037ddb386cadbe9f"></a><!-- doxytag: member="SageInterface::fixClassDeclaration" ref="4e2216ac11843189037ddb386cadbe9f" args="(SgClassDeclaration *classDecl, SgScopeStatement *scope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::fixClassDeclaration           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgClassDeclaration.html">SgClassDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>classDecl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fix symbols, parent and scope pointers. Used internally within appendStatment(), <a class="el" href="namespaceSageInterface.html#54e6780cc15a76ce7bc37a1212452e66">insertStatement()</a> etc when a class declaration was built without knowing its target scope. 
<p>

</div>
</div><p>
<a class="anchor" name="0605947f38a73309b695c2511a6a008b"></a><!-- doxytag: member="SageInterface::fixNamespaceDeclaration" ref="0605947f38a73309b695c2511a6a008b" args="(SgNamespaceDeclarationStatement *structDecl, SgScopeStatement *scope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::fixNamespaceDeclaration           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNamespaceDeclarationStatement.html">SgNamespaceDeclarationStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>structDecl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fix symbols, parent and scope pointers. Used internally within appendStatment(), <a class="el" href="namespaceSageInterface.html#54e6780cc15a76ce7bc37a1212452e66">insertStatement()</a> etc when a namespace declaration was built without knowing its target scope. 
<p>

</div>
</div><p>
<a class="anchor" name="d8449795585ef098dedd58658b4ea265"></a><!-- doxytag: member="SageInterface::fixLabelStatement" ref="d8449795585ef098dedd58658b4ea265" args="(SgLabelStatement *label_stmt, SgScopeStatement *scope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::fixLabelStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgLabelStatement.html">SgLabelStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>label_stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fix symbol table for <a class="el" href="classSgLabelStatement.html">SgLabelStatement</a>. Used Internally when the label is built without knowing its target scope. Both parameters cannot be NULL. 
<p>

</div>
</div><p>
<a class="anchor" name="221ee5cf1957c22f8e37d2fa1ab96c68"></a><!-- doxytag: member="SageInterface::setFortranNumericLabel" ref="221ee5cf1957c22f8e37d2fa1ab96c68" args="(SgStatement *stmt, int label_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::setFortranNumericLabel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>label_value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set a numerical label for a Fortran statement. The statement should have a enclosing function definition already. <a class="el" href="classSgLabelSymbol.html">SgLabelSymbol</a> and <a class="el" href="classSgLabelRefExp.html">SgLabelRefExp</a> are created transparently as needed. 
<p>

</div>
</div><p>
<a class="anchor" name="79b07f8a7d66fc51a0648df2940a5bf4"></a><!-- doxytag: member="SageInterface::suggestNextNumericLabel" ref="79b07f8a7d66fc51a0648df2940a5bf4" args="(SgFunctionDefinition *func_def)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SageInterface::suggestNextNumericLabel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDefinition.html">SgFunctionDefinition</a> *&nbsp;</td>
          <td class="paramname"> <em>func_def</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Suggest next usable (non-conflicting) numeric label value for a Fortran function definition scope. 
<p>

</div>
</div><p>
<a class="anchor" name="2410a8e2fc7310bd63c24d10b91594a3"></a><!-- doxytag: member="SageInterface::fixStatement" ref="2410a8e2fc7310bd63c24d10b91594a3" args="(SgStatement *stmt, SgScopeStatement *scope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::fixStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A wrapper containing fixes (<a class="el" href="namespaceSageInterface.html#c56e358f18815a86ca4c9ad738733d37">fixVariableDeclaration()</a>,<a class="el" href="namespaceSageInterface.html#198dfdbeffb7cb4e282c0045de88b29d">fixStructDeclaration()</a>, <a class="el" href="namespaceSageInterface.html#d8449795585ef098dedd58658b4ea265">fixLabelStatement()</a>, etc) for all kinds statements. Should be used before attaching the statement into AST. 
<p>

</div>
</div><p>
<a class="anchor" name="7ee71882b367869506de6382d1b09cc2"></a><!-- doxytag: member="SageInterface::updateDefiningNondefiningLinks" ref="7ee71882b367869506de6382d1b09cc2" args="(SgFunctionDeclaration *func, SgScopeStatement *scope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::updateDefiningNondefiningLinks           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgScopeStatement.html">SgScopeStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>scope</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update defining and nondefining links due to a newly introduced function declaration. Should be used after inserting the function into a scope. 
<p>
This function not only set the defining and nondefining links of the newly introduced function declaration inside a scope, but also update other same function declarations' links accordingly if there are any. Assumption: The function has already inserted/appended/prepended into the scope before calling this function. 
</div>
</div><p>
<a class="anchor" name="2f9dadd01d12ecdc779071da95843b83"></a><!-- doxytag: member="SageInterface::collectReadWriteRefs" ref="2f9dadd01d12ecdc779071da95843b83" args="(SgStatement *stmt, std::vector&lt; SgNode * &gt; &amp;readRefs, std::vector&lt; SgNode * &gt; &amp;writeRefs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::collectReadWriteRefs           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>readRefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>writeRefs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Collect all read and write references within stmt, which can be a function, a scope statement, or a single statement. Note that a reference can be both read and written, like i++. 
<p>

</div>
</div><p>
<a class="anchor" name="11498284f603a3a574f02df0f44216b8"></a><!-- doxytag: member="SageInterface::collectReadWriteVariables" ref="11498284f603a3a574f02df0f44216b8" args="(SgStatement *stmt, std::set&lt; SgInitializedName * &gt; &amp;readVars, std::set&lt; SgInitializedName * &gt; &amp;writeVars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::collectReadWriteVariables           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>readVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>writeVars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Collect unique variables which are read or written within a statement. Note that a variable can be both read and written. The statement can be either of a function, a scope, or a single line statement. 
<p>

</div>
</div><p>
<a class="anchor" name="3dc3524267c97a90f85d723b462e4e8a"></a><!-- doxytag: member="SageInterface::collectReadOnlyVariables" ref="3dc3524267c97a90f85d723b462e4e8a" args="(SgStatement *stmt, std::set&lt; SgInitializedName * &gt; &amp;readOnlyVars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::collectReadOnlyVariables           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>readOnlyVars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Collect read only variables within a statement. The statement can be either of a function, a scope, or a single line statement. 
<p>

</div>
</div><p>
<a class="anchor" name="7b50fd79f9c2175fea1fcfd8d66e8a7d"></a><!-- doxytag: member="SageInterface::collectReadOnlySymbols" ref="7b50fd79f9c2175fea1fcfd8d66e8a7d" args="(SgStatement *stmt, std::set&lt; SgVariableSymbol * &gt; &amp;readOnlySymbols)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::collectReadOnlySymbols           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="classSgVariableSymbol.html">SgVariableSymbol</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>readOnlySymbols</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Collect read only variable symbols within a statement. The statement can be either of a function, a scope, or a single line statement. 
<p>

</div>
</div><p>
<a class="anchor" name="b854982b76a15a37881e460327d45b63"></a><!-- doxytag: member="SageInterface::isUseByAddressVariableRef" ref="b854982b76a15a37881e460327d45b63" args="(SgVarRefExp *ref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isUseByAddressVariableRef           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> *&nbsp;</td>
          <td class="paramname"> <em>ref</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if a variable reference is used by its address: including &amp;a expression and foo(a) when type2 foo(Type&amp; parameter) in C++. 
<p>

</div>
</div><p>
<a class="anchor" name="cff1c2e7a141a6360ad735dbe7d4dec8"></a><!-- doxytag: member="SageInterface::collectUseByAddressVariableRefs" ref="cff1c2e7a141a6360ad735dbe7d4dec8" args="(const SgStatement *s, std::set&lt; SgVarRefExp * &gt; &amp;varSetB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::collectUseByAddressVariableRefs           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>varSetB</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Collect variable references involving use by address: including &amp;a expression and foo(a) when type2 foo(Type&amp; parameter) in C++. 
<p>

</div>
</div><p>
<a class="anchor" name="d0fbd473b56e24b39b63f354b7dd61a1"></a><!-- doxytag: member="SageInterface::call_liveness_analysis" ref="d0fbd473b56e24b39b63f354b7dd61a1" args="(SgProject *project, bool debug=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LivenessAnalysis* SageInterface::call_liveness_analysis           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgProject.html">SgProject</a> *&nbsp;</td>
          <td class="paramname"> <em>project</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>debug</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call liveness analysis on an entire project. 
<p>

</div>
</div><p>
<a class="anchor" name="7f94ad31631659aacacfe540a97bcb11"></a><!-- doxytag: member="SageInterface::getLiveVariables" ref="7f94ad31631659aacacfe540a97bcb11" args="(LivenessAnalysis *liv, SgForStatement *loop, std::set&lt; SgInitializedName * &gt; &amp;liveIns, std::set&lt; SgInitializedName * &gt; &amp;liveOuts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::getLiveVariables           </td>
          <td>(</td>
          <td class="paramtype">LivenessAnalysis *&nbsp;</td>
          <td class="paramname"> <em>liv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgForStatement.html">SgForStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>liveIns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>liveOuts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
get liveIn and liveOut variables for a for loop from liveness analysis result liv. 
<p>

</div>
</div><p>
<a class="anchor" name="a3155e7a4a833e87637709baecd5638d"></a><!-- doxytag: member="SageInterface::ReductionRecognition" ref="a3155e7a4a833e87637709baecd5638d" args="(SgForStatement *loop, std::set&lt; std::pair&lt; SgInitializedName *, VariantT &gt; &gt; &amp;results)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::ReductionRecognition           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgForStatement.html">SgForStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::pair&lt; <a class="el" href="classSgInitializedName.html">SgInitializedName</a> *, <a class="el" href="Cxx__Grammar_8h.html#adcb00b11de1167a498bced81d3e3464">VariantT</a> &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>results</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recognize and collect reduction variables and operations within a C/C++ loop, following OpenMP 3.0 specification for allowed reduction variable types and operation types. 
<p>

</div>
</div><p>
<a class="anchor" name="6f1a171284027fd38c91507a33a12023"></a><!-- doxytag: member="SageInterface::constantFolding" ref="6f1a171284027fd38c91507a33a12023" args="(SgNode *r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::constantFolding           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>r</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constant folding an AST subtree rooted at 'r' (replacing its children with their constant values, if applicable). Please be advised that constant folding on floating point computation may decrease the accuracy of floating point computations! 
<p>
It is a wrapper function for ConstantFolding::constantFoldingOptimization(). Note that only r's children are replaced with their corresponding constant values, not the input <a class="el" href="classSgNode.html">SgNode</a> r itself. You have to call this upon an expression's parent node if you want to fold the expression. 
</div>
</div><p>
<a class="anchor" name="4087541939de003c4cfb4a51e8ae4737"></a><!-- doxytag: member="SageInterface::instrumentEndOfFunction" ref="4087541939de003c4cfb4a51e8ae4737" args="(SgFunctionDeclaration *func, SgStatement *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SageInterface::instrumentEndOfFunction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Instrument(Add a statement, often a function call) into a function right before the return points, handle multiple return statements and return expressions with side effects. Return the number of statements inserted. 
<p>
Useful when adding a runtime library call to terminate the runtime system right before the end of a program, especially for OpenMP and UPC runtime systems. Return with complex expressions with side effects are rewritten using an additional assignment statement. 
</div>
</div><p>
<a class="anchor" name="b3b17e2ceead1e6fcbe2671d795859e0"></a><!-- doxytag: member="SageInterface::removeJumpsToNextStatement" ref="b3b17e2ceead1e6fcbe2671d795859e0" args="(SgNode *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::removeJumpsToNextStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove jumps whose label is immediately after the jump. Used to clean up inlined code fragments. 
<p>

</div>
</div><p>
<a class="anchor" name="1cf3641ce21620223f92f3b00477a50b"></a><!-- doxytag: member="SageInterface::removeUnusedLabels" ref="1cf3641ce21620223f92f3b00477a50b" args="(SgNode *top)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::removeUnusedLabels           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>top</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove labels which are not targets of any goto statements. 
<p>

</div>
</div><p>
<a class="anchor" name="e674125d5affe065c68f6540217b544c"></a><!-- doxytag: member="SageInterface::removeConsecutiveLabels" ref="e674125d5affe065c68f6540217b544c" args="(SgNode *top)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::removeConsecutiveLabels           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>top</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove consecutive labels. 
<p>

</div>
</div><p>
<a class="anchor" name="9a28f3454dc1161d208d0eafa27267d5"></a><!-- doxytag: member="SageInterface::splitExpression" ref="9a28f3454dc1161d208d0eafa27267d5" args="(SgExpression *from, std::string newName=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAssignInitializer.html">SgAssignInitializer</a>* SageInterface::splitExpression           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>newName</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace an expression with a temporary variable and an assignment statement. 
<p>
Add a new temporary variable to contain the value of 'from' Change reference to 'from' to use this new variable Assumptions: 'from' is not within the test of a loop or 'if' not currently traversing 'from' or the statement it is in 
</div>
</div><p>
<a class="anchor" name="c6a4105eaf9ecae213078b24d5dfc69f"></a><!-- doxytag: member="SageInterface::splitExpressionIntoBasicBlock" ref="c6a4105eaf9ecae213078b24d5dfc69f" args="(SgExpression *expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::splitExpressionIntoBasicBlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>expr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Split long expressions into blocks of statements. 
<p>

</div>
</div><p>
<a class="anchor" name="72277a774aaa30427c7ba19a5ae0e64e"></a><!-- doxytag: member="SageInterface::removeLabeledGotos" ref="72277a774aaa30427c7ba19a5ae0e64e" args="(SgNode *top)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::removeLabeledGotos           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>top</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove labeled goto statements. 
<p>

</div>
</div><p>
<a class="anchor" name="2e6c3a91ffcb6a4a8e0a26dd39170498"></a><!-- doxytag: member="SageInterface::changeBreakStatementsToGotos" ref="2e6c3a91ffcb6a4a8e0a26dd39170498" args="(SgStatement *loopOrSwitch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::changeBreakStatementsToGotos           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>loopOrSwitch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If the given statement contains any break statements in its body, add a new label below the statement and change the breaks into gotos to that new label. 
<p>

</div>
</div><p>
<a class="anchor" name="a9363b5ef0fa341b6a69f3143010d03f"></a><!-- doxytag: member="SageInterface::ensureBasicBlockAsBodyOfFor" ref="a9363b5ef0fa341b6a69f3143010d03f" args="(SgForStatement *fs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>* SageInterface::ensureBasicBlockAsBodyOfFor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgForStatement.html">SgForStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>fs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if the body of a 'for' statement is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not. 
<p>

</div>
</div><p>
<a class="anchor" name="4b91f29c299fd9d36d23215caca641a9"></a><!-- doxytag: member="SageInterface::ensureBasicBlockAsBodyOfUpcForAll" ref="4b91f29c299fd9d36d23215caca641a9" args="(SgUpcForAllStatement *fs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>* SageInterface::ensureBasicBlockAsBodyOfUpcForAll           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgUpcForAllStatement.html">SgUpcForAllStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>fs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if the body of a 'upc_forall' statement is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not. 
<p>

</div>
</div><p>
<a class="anchor" name="b420709b668cbcb97caaa2ba7a311047"></a><!-- doxytag: member="SageInterface::ensureBasicBlockAsBodyOfWhile" ref="b420709b668cbcb97caaa2ba7a311047" args="(SgWhileStmt *ws)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>* SageInterface::ensureBasicBlockAsBodyOfWhile           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgWhileStmt.html">SgWhileStmt</a> *&nbsp;</td>
          <td class="paramname"> <em>ws</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if the body of a 'while' statement is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not. 
<p>

</div>
</div><p>
<a class="anchor" name="10f7e44426ec5cc6cf4878a9f8f3737b"></a><!-- doxytag: member="SageInterface::ensureBasicBlockAsBodyOfDoWhile" ref="10f7e44426ec5cc6cf4878a9f8f3737b" args="(SgDoWhileStmt *ws)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>* SageInterface::ensureBasicBlockAsBodyOfDoWhile           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgDoWhileStmt.html">SgDoWhileStmt</a> *&nbsp;</td>
          <td class="paramname"> <em>ws</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if the body of a 'do .. while' statement is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not. 
<p>

</div>
</div><p>
<a class="anchor" name="2ee0c40fe00b9aa2e33f07a1f63d1c78"></a><!-- doxytag: member="SageInterface::ensureBasicBlockAsBodyOfSwitch" ref="2ee0c40fe00b9aa2e33f07a1f63d1c78" args="(SgSwitchStatement *ws)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>* SageInterface::ensureBasicBlockAsBodyOfSwitch           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgSwitchStatement.html">SgSwitchStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>ws</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if the body of a 'switch' statement is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not. 
<p>

</div>
</div><p>
<a class="anchor" name="5dddc30ac598e407d4b675b48817321a"></a><!-- doxytag: member="SageInterface::ensureBasicBlockAsTrueBodyOfIf" ref="5dddc30ac598e407d4b675b48817321a" args="(SgIfStmt *ifs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>* SageInterface::ensureBasicBlockAsTrueBodyOfIf           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgIfStmt.html">SgIfStmt</a> *&nbsp;</td>
          <td class="paramname"> <em>ifs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if the true body of a 'if' statement is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not. 
<p>

</div>
</div><p>
<a class="anchor" name="a0d91d1274666339221f3186847d220a"></a><!-- doxytag: member="SageInterface::ensureBasicBlockAsFalseBodyOfIf" ref="a0d91d1274666339221f3186847d220a" args="(SgIfStmt *ifs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>* SageInterface::ensureBasicBlockAsFalseBodyOfIf           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgIfStmt.html">SgIfStmt</a> *&nbsp;</td>
          <td class="paramname"> <em>ifs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if the false body of a 'if' statement is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not. 
<p>

</div>
</div><p>
<a class="anchor" name="273d390c4b54e9dc4c02c4806b3747a5"></a><!-- doxytag: member="SageInterface::ensureBasicBlockAsBodyOfCatch" ref="273d390c4b54e9dc4c02c4806b3747a5" args="(SgCatchOptionStmt *cos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>* SageInterface::ensureBasicBlockAsBodyOfCatch           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgCatchOptionStmt.html">SgCatchOptionStmt</a> *&nbsp;</td>
          <td class="paramname"> <em>cos</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if the body of a 'catch' statement is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not. 
<p>

</div>
</div><p>
<a class="anchor" name="0434e3f30f7426d0ff371c936b2f1e5e"></a><!-- doxytag: member="SageInterface::ensureBasicBlockAsBodyOfOmpBodyStmt" ref="0434e3f30f7426d0ff371c936b2f1e5e" args="(SgOmpBodyStatement *ompbodyStmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>* SageInterface::ensureBasicBlockAsBodyOfOmpBodyStmt           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgOmpBodyStatement.html">SgOmpBodyStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>ompbodyStmt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if the body of a <a class="el" href="classSgOmpBodyStatement.html">SgOmpBodyStatement</a> is a <a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>, create one if not. 
<p>

</div>
</div><p>
<a class="anchor" name="a72050df89f2aa4351288454d544b695"></a><!-- doxytag: member="SageInterface::isBodyStatement" ref="a72050df89f2aa4351288454d544b695" args="(SgStatement *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isBodyStatement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if a statement is a (true or false) body of a container-like parent, such as For, Upc_forall, Do-while, switch, If, Catch, OmpBodyStmt, etc. 
<p>

</div>
</div><p>
<a class="anchor" name="f052fc07989bd2870022a0aa4f075d53"></a><!-- doxytag: member="SageInterface::changeAllBodiesToBlocks" ref="f052fc07989bd2870022a0aa4f075d53" args="(SgNode *top)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::changeAllBodiesToBlocks           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>top</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fix up ifs, loops, while, switch, Catch, OmpBodyStatement, etc. to have blocks as body components. It also adds an empty else body to if statements that don't have them. 
<p>

</div>
</div><p>
<a class="anchor" name="fd793e1727df3c73fbd8384ccc604272"></a><!-- doxytag: member="SageInterface::changeAllLoopBodiesToBlocks" ref="fd793e1727df3c73fbd8384ccc604272" args="(SgNode *top)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::changeAllLoopBodiesToBlocks           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>top</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The same as <a class="el" href="namespaceSageInterface.html#f052fc07989bd2870022a0aa4f075d53">changeAllBodiesToBlocks(SgNode* top)</a>. To be phased out. 
<p>

</div>
</div><p>
<a class="anchor" name="f3cb2f040226ce2af1234b4e94a60d15"></a><!-- doxytag: member="SageInterface::makeSingleStatementBodyToBlock" ref="f3cb2f040226ce2af1234b4e94a60d15" args="(SgStatement *singleStmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgBasicBlock.html">SgBasicBlock</a>* SageInterface::makeSingleStatementBodyToBlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>singleStmt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make a single statement body to be a basic block. Its parent is if, while, catch, or upc_forall etc. 
<p>

</div>
</div><p>
<a class="anchor" name="7c34b2c7c9c66106eb13c6d253217b5e"></a><!-- doxytag: member="SageInterface::getIntegerConstantValue" ref="7c34b2c7c9c66106eb13c6d253217b5e" args="(SgValueExp *expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long SageInterface::getIntegerConstantValue           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgValueExp.html">SgValueExp</a> *&nbsp;</td>
          <td class="paramname"> <em>expr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the constant value from a constant integer expression; abort on everything else. 
<p>
Note that signed long longs are converted to unsigned. 
</div>
</div><p>
<a class="anchor" name="318f7cf455f620d5deecb5f37d41f4fe"></a><!-- doxytag: member="SageInterface::getDependentDeclarations" ref="318f7cf455f620d5deecb5f37d41f4fe" args="(SgStatement *stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSgDeclarationStatement.html">SgDeclarationStatement</a>*&gt; SageInterface::getDependentDeclarations           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a statement's dependent declarations which declares the types used in the statement. The returned vector of declaration statements are sorted according to their appearance order in the original AST. Any reference to a class or template class from a namespace will treated as a reference to the enclosing namespace. 
<p>

</div>
</div><p>
<a class="anchor" name="88ea6b1684ee9c306a48e10e8a13910b"></a><!-- doxytag: member="SageInterface::insertBeforeUsingCommaOp" ref="88ea6b1684ee9c306a48e10e8a13910b" args="(SgExpression *new_exp, SgExpression *anchor_exp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgCommaOpExp.html">SgCommaOpExp</a>* SageInterface::insertBeforeUsingCommaOp           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>new_exp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>anchor_exp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert an expression (new_exp )before another expression (anchor_exp) has possible side effects, without changing the original semantics. This is achieved by using a comma operator: (new_exp, anchor_exp). The comma operator is returned. 
<p>

</div>
</div><p>
<a class="anchor" name="57851892650845148e67407bf2389fd2"></a><!-- doxytag: member="SageInterface::insertAfterUsingCommaOp" ref="57851892650845148e67407bf2389fd2" args="(SgExpression *new_exp, SgExpression *anchor_exp, SgStatement **temp_decl=NULL, SgVarRefExp **temp_ref=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgCommaOpExp.html">SgCommaOpExp</a>* SageInterface::insertAfterUsingCommaOp           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>new_exp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgExpression.html">SgExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>anchor_exp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgStatement.html">SgStatement</a> **&nbsp;</td>
          <td class="paramname"> <em>temp_decl</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgVarRefExp.html">SgVarRefExp</a> **&nbsp;</td>
          <td class="paramname"> <em>temp_ref</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert an expression (new_exp ) after another expression (anchor_exp) has possible side effects, without changing the original semantics. This is done by using two comma operators: type T1; ... ((T1 = anchor_exp, new_exp),T1) )... , where T1 is a temp variable saving the possible side effect of anchor_exp. The top level comma op exp is returned. The reference to T1 in T1 = anchor_exp is saved in temp_ref. 
<p>

</div>
</div><p>
<a class="anchor" name="db9d4a03d11809413cca4cac1dfc18a7"></a><!-- doxytag: member="SageInterface::wrapFunction" ref="db9d4a03d11809413cca4cac1dfc18a7" args="(SgFunctionDeclaration &amp;definingDeclaration, SgName newName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classSgStatement.html">SgStatement</a>*, <a class="el" href="classSgInitializedName.html">SgInitializedName</a>*&gt; SageInterface::wrapFunction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>definingDeclaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgName.html">SgName</a>&nbsp;</td>
          <td class="paramname"> <em>newName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
moves the body of a function f to a new function f`; f's body is replaced with code that forwards the call to f`. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>a pair indicating the statement containing the call of f` and an initialized name refering to the temporary variable holding the result of f`. In case f returns void the initialized name is NULL. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>definingDeclaration</em>&nbsp;</td><td>the defining function declaration of f </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newName</em>&nbsp;</td><td>the name of function f` f's new body becomes { f`(...); } and { int res = f`(...); return res; } for functions returning void and a value, respectively. two function declarations are inserted in f's enclosing scope <div class="fragment"><pre class="fragment">          result_type f`(...);                       &lt;--- (1)
          result_type f (...) { forward call to f` }
          result_type f`(...) { original code }      &lt;--- (2)
</pre></div> Calls to f are not updated, thus in the transformed code all calls will continue calling f (this is also true for recursive function calls from within the body of f`). After the function has created the wrapper, definingDeclaration becomes the wrapper function The definition of f` is the next entry in the statement list; the forward declaration of f` is the previous entry in the statement list. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>definingDeclaration must be a defining declaration of a free standing function. typeid(SgFunctionDeclaration) == typeid(definingDeclaration) i.e., this function is NOT implemented for class member functions, template functions, procedures, etc. </dd></dl>

<p>
Referenced by <a class="el" href="sageInterface_8h-source.html#l01588">wrapFunction()</a>.
</div>
</div><p>
<a class="anchor" name="10d65c1ab5842a8ecb88b24abf0b562c"></a><!-- doxytag: member="SageInterface::wrapFunction" ref="10d65c1ab5842a8ecb88b24abf0b562c" args="(SgFunctionDeclaration &amp;definingDeclaration, NameGen nameGen)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NameGen&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classSgStatement.html">SgStatement</a>*, <a class="el" href="classSgInitializedName.html">SgInitializedName</a>*&gt; SageInterface::wrapFunction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgFunctionDeclaration.html">SgFunctionDeclaration</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>definingDeclaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NameGen&nbsp;</td>
          <td class="paramname"> <em>nameGen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  NameGen functor that generates a new name based on the old name.see wrapFunction for details. 
<p>
interface: <a class="el" href="classSgName.html">SgName</a> nameGen(const SgName&amp;) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nameGen</em>&nbsp;</td><td>name generator </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="sageInterface_8h-source.html#l01588">1588</a> of file <a class="el" href="sageInterface_8h-source.html">sageInterface.h</a>.
<p>
References <a class="el" href="classSgFunctionDeclaration.html#2f8974b0e4100dd1e186c479478d589a">SgFunctionDeclaration::get_name()</a>, and <a class="el" href="namespaceSageInterface.html#db9d4a03d11809413cca4cac1dfc18a7">wrapFunction()</a>.
</div>
</div><p>
<a class="anchor" name="e1fae2ae93d70efe722d0bde9473842e"></a><!-- doxytag: member="SageInterface::getFirstVariable" ref="e1fae2ae93d70efe722d0bde9473842e" args="(SgVariableDeclaration &amp;vardecl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgInitializedName.html">SgInitializedName</a>&amp; SageInterface::getFirstVariable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgVariableDeclaration.html">SgVariableDeclaration</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vardecl</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
convenience function that returns the first initialized name in a list of variable declarations. 
<p>

</div>
</div><p>
<a class="anchor" name="4cc95056575d01624ccf78ebc97329f5"></a><!-- doxytag: member="SageInterface::addComment" ref="4cc95056575d01624ccf78ebc97329f5" args="(SgAsmStatement *stmt, const std::string &amp;input_string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::addComment           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmStatement.html">SgAsmStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>input_string</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f022306442b888ef3560632bd5697dff"></a><!-- doxytag: member="SageInterface::getSection" ref="f022306442b888ef3560632bd5697dff" args="(SgProject *project, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmElfSection.html">SgAsmElfSection</a>* SageInterface::getSection           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgProject.html">SgProject</a> *&nbsp;</td>
          <td class="paramname"> <em>project</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6fafc25ba006fd7d16a89e9e4ecadbc3"></a><!-- doxytag: member="SageInterface::getSection" ref="6fafc25ba006fd7d16a89e9e4ecadbc3" args="(SgProject *project, size_t ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmElfSection.html">SgAsmElfSection</a>* SageInterface::getSection           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgProject.html">SgProject</a> *&nbsp;</td>
          <td class="paramname"> <em>project</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="5231e81126bc1969adf6fb100232ffb3"></a><!-- doxytag: member="SageInterface::getAsmFunction" ref="5231e81126bc1969adf6fb100232ffb3" args="(SgAsmInstruction *asmInstruction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmFunction.html">SgAsmFunction</a>* SageInterface::getAsmFunction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&nbsp;</td>
          <td class="paramname"> <em>asmInstruction</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Traverses AST backwards up the tree along the "parent" edges to the <a class="el" href="classSgAsmFunction.html">SgAsmFunction</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="747672ac53143bd77488c68e2ae1ea1e"></a><!-- doxytag: member="SageInterface::getAsmBlock" ref="747672ac53143bd77488c68e2ae1ea1e" args="(SgAsmInstruction *asmInstruction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a>* SageInterface::getAsmBlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&nbsp;</td>
          <td class="paramname"> <em>asmInstruction</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Traverses AST backwards up the tree along the "parent" edges to the <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="22f9e8f6fd5bc4fc436dce42f021eab0"></a><!-- doxytag: member="SageInterface::getAsmInterpretation" ref="22f9e8f6fd5bc4fc436dce42f021eab0" args="(SgAsmNode *asmNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a>* SageInterface::getAsmInterpretation           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmNode.html">SgAsmNode</a> *&nbsp;</td>
          <td class="paramname"> <em>asmNode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Traverses AST backwards up the tree along the "parent" edges to the <a class="el" href="classSgAsmInterpretation.html">SgAsmInterpretation</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="80f931189467b0b8a729ae2459aa848c"></a><!-- doxytag: member="SageInterface::generateUniqueName" ref="80f931189467b0b8a729ae2459aa848c" args="(size_t value, std::map&lt; size_t, int &gt; &amp;usedOffsets, size_t &amp;counter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::generateUniqueName           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; size_t, int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>usedOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>counter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1eafc1e4f7e80b8ab1a85c5ab6dffe5d"></a><!-- doxytag: member="SageInterface::get_value" ref="1eafc1e4f7e80b8ab1a85c5ab6dffe5d" args="(SgAsmValueExpression *asmValueExpression)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SageInterface::get_value           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmValueExpression.html">SgAsmValueExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>asmValueExpression</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1ac67db23cd773335d146e4d4533e0cd"></a><!-- doxytag: member="SageInterface::get_valueString" ref="1ac67db23cd773335d146e4d4533e0cd" args="(SgAsmValueExpression *asmValueExpression)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SageInterface::get_valueString           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmValueExpression.html">SgAsmValueExpression</a> *&nbsp;</td>
          <td class="paramname"> <em>asmValueExpression</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c8ebd3d59d51a1060d98ce48a0c84d0a"></a><!-- doxytag: member="SageInterface::isMovInstruction" ref="c8ebd3d59d51a1060d98ce48a0c84d0a" args="(SgAsmInstruction *asmInstruction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isMovInstruction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&nbsp;</td>
          <td class="paramname"> <em>asmInstruction</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="fb2b29d4031efe33cd50f5ac4748b6c4"></a><!-- doxytag: member="SageInterface::isInstructionKind" ref="fb2b29d4031efe33cd50f5ac4748b6c4" args="(SgAsmInstruction *asmInstruction, X86InstructionKind instuctionKind)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isInstructionKind           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&nbsp;</td>
          <td class="paramname"> <em>asmInstruction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AssemblerX86Init_8h.html#cb800e57ccb0a3ac5b7a89056bca5571">X86InstructionKind</a>&nbsp;</td>
          <td class="paramname"> <em>instuctionKind</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="bd5aab398d3e64ceaa6f8174470b7279"></a><!-- doxytag: member="SageInterface::equivalenceTest" ref="bd5aab398d3e64ceaa6f8174470b7279" args="(SgNode *x, SgNode *y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::equivalenceTest           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b2e4624607ed5657fc31c021297694d1"></a><!-- doxytag: member="SageInterface::flattenAST" ref="b2e4624607ed5657fc31c021297694d1" args="(SgNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSgNode.html">SgNode</a>*&gt; SageInterface::flattenAST           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6b77bd20707c195fd34c8337bb77c234"></a><!-- doxytag: member="SageInterface::matchAST" ref="6b77bd20707c195fd34c8337bb77c234" args="(SgNode *node, std::vector&lt; SgNode * &gt; &amp;listOfNodes, EquivalenceTestFunctionType equivalenceTest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSgNode.html">SgNode</a>*&gt; SageInterface::matchAST           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>listOfNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSageInterface.html#a50192df1669445c680604f06a73e865">EquivalenceTestFunctionType</a>&nbsp;</td>
          <td class="paramname"> <em>equivalenceTest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ff5394b21cf11cd338671af3a11a7f92"></a><!-- doxytag: member="SageInterface::find" ref="ff5394b21cf11cd338671af3a11a7f92" args="(SgNode *astNode, SgNode *target, EquivalenceTestFunctionType equivalenceTest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSgNode.html">SgNode</a>*&gt; SageInterface::find           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>astNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSageInterface.html#a50192df1669445c680604f06a73e865">EquivalenceTestFunctionType</a>&nbsp;</td>
          <td class="paramname"> <em>equivalenceTest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Referenced by <a class="el" href="PeImportSection_8C-source.html#l00229">SgAsmPEImportSection::add_import_directory()</a>, <a class="el" href="yicesParserLib_8h-source.html#l00434">visitorTraversal::analyzePath()</a>, <a class="el" href="graphProcessing_8h-source.html#l00442">SgGraphTraversal&lt; CFG &gt;::bfsTraversePath()</a>, <a class="el" href="Partitioner_8C-source.html#l02990">Partitioner::detach_thunk()</a>, <a class="el" href="graphProcessingSgIncGraph_8h-source.html#l00531">SgGraphTraversal&lt; CFG &gt;::disjoint()</a>, <a class="el" href="graphProcessingSgIncGraph_8h-source.html#l01059">SgGraphTraversal&lt; CFG &gt;::evaluatePaths()</a>, <a class="el" href="graphProcessingSgIncGraph_8h-source.html#l00694">SgGraphTraversal&lt; CFG &gt;::evaluatePathsPar()</a>, <a class="el" href="SgGraphTemplate_8h-source.html#l00146">getAllNodesAndEdges()</a>, <a class="el" href="Registers_8C-source.html#l00026">RegisterDictionary::insert()</a>, <a class="el" href="attributeListMap_8h-source.html#l00685">AttributeListMap::findDirectiveInList&lt; TokenIterator, DirectiveType &gt;::operator()()</a>, <a class="el" href="GenericFile_8C-source.html#l00289">SgAsmGenericFile::remove_header()</a>, <a class="el" href="GenericFile_8C-source.html#l00320">SgAsmGenericFile::remove_hole()</a>, <a class="el" href="PeImportSection_8C-source.html#l00244">SgAsmPEImportSection::remove_import_directory()</a>, <a class="el" href="GenericHeader_8C-source.html#l00101">SgAsmGenericHeader::remove_section()</a>, <a class="el" href="graphProcessingSgIncGraph_8h-source.html#l01435">SgGraphTraversal&lt; CFG &gt;::solvePaths()</a>, <a class="el" href="Cxx__Grammar_8h-source.html#l73670">StatementListInsertChild()</a>, <a class="el" href="graphProcessing_8h-source.html#l00737">SgGraphTraversal&lt; CFG &gt;::uTraversePath()</a>, <a class="el" href="graphProcessing_8h-source.html#l00337">SgGraphTraversal&lt; CFG &gt;::zipPath()</a>, and <a class="el" href="graphProcessing_8h-source.html#l00311">SgGraphTraversal&lt; CFG &gt;::zipPath2()</a>.
</div>
</div><p>
<a class="anchor" name="414a9168eee41e2f7d7d247c3a49fd4e"></a><!-- doxytag: member="SageInterface::isNOP" ref="414a9168eee41e2f7d7d247c3a49fd4e" args="(SgAsmInstruction *asmInstruction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isNOP           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&nbsp;</td>
          <td class="paramname"> <em>asmInstruction</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test an instruction for if it has no side-effect to the state (is so then it is a NOP). This is a more general test than if it is equivelent to the NOP memonic instruction. 
<p>

</div>
</div><p>
<a class="anchor" name="de96f92f0e96eb8ebabb9220a84e6b4d"></a><!-- doxytag: member="SageInterface::isNOP" ref="de96f92f0e96eb8ebabb9220a84e6b4d" args="(const std::vector&lt; SgAsmInstruction * &gt; &amp;asmInstructionList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SageInterface::isNOP           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>asmInstructionList</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test a sequence of instructions for it they (as a set) have no side-effects to the state (is so then it is a NOP sequence). 
<p>

</div>
</div><p>
<a class="anchor" name="05bfe1145092f64638002356588ee5ab"></a><!-- doxytag: member="SageInterface::find_NOP_sequences" ref="05bfe1145092f64638002356588ee5ab" args="(SgAsmBlock *asmBlock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a>*&gt; &gt; SageInterface::find_NOP_sequences           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>asmBlock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
find sequences of NOP instructions in a <a class="el" href="classSgAsmBlock.html">SgAsmBlock</a> 
<p>

</div>
</div><p>
<a class="anchor" name="1f1f75a3456361008d4e02ec102d5663"></a><!-- doxytag: member="SageInterface::insertInstruction" ref="1f1f75a3456361008d4e02ec102d5663" args="(SgAsmInstruction *targetInstruction, SgAsmInstruction *newInstruction, bool insertBefore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::insertInstruction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&nbsp;</td>
          <td class="paramname"> <em>targetInstruction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&nbsp;</td>
          <td class="paramname"> <em>newInstruction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>insertBefore</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Support for insertion of instruction relative to a target instruction. 
<p>

</div>
</div><p>
<a class="anchor" name="e8257295538bc5792f543719660d08db"></a><!-- doxytag: member="SageInterface::insertInstructionBefore" ref="e8257295538bc5792f543719660d08db" args="(SgAsmInstruction *targetInstruction, SgAsmInstruction *newInstruction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::insertInstructionBefore           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&nbsp;</td>
          <td class="paramname"> <em>targetInstruction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSgAsmInstruction.html">SgAsmInstruction</a> *&nbsp;</td>
          <td class="paramname"> <em>newInstruction</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a instruction before a target instruction. 
<p>

</div>
</div><p>
<a class="anchor" name="cf2e80d430cfcbbb6165adbd6bd0e471"></a><!-- doxytag: member="SageInterface::removeInstruction" ref="cf2e80d430cfcbbb6165adbd6bd0e471" args="(SgAsmStatement *instruction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SageInterface::removeInstruction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgAsmStatement.html">SgAsmStatement</a> *&nbsp;</td>
          <td class="paramname"> <em>instruction</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove a instruction. 
<p>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="c634a179b840b4d55d9b32e0288fb1b4"></a><!-- doxytag: member="SageInterface::gensym_counter" ref="c634a179b840b4d55d9b32e0288fb1b4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespaceSageInterface.html#c634a179b840b4d55d9b32e0288fb1b4">SageInterface::gensym_counter</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
An internal counter for generating unique <a class="el" href="classSgName.html">SgName</a>. 
<p>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
