<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: ROSE_Callbacks::List&lt; T &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceROSE__Callbacks.html">ROSE_Callbacks</a>::<a class="el" href="classROSE__Callbacks_1_1List.html">List</a></div>
<h1>ROSE_Callbacks::List&lt; T &gt; Class Template Reference</h1><!-- doxytag: class="ROSE_Callbacks::List" --><code>#include &lt;<a class="el" href="callbacks_8h-source.html">callbacks.h</a>&gt;</code>
<p>
Inheritance diagram for ROSE_Callbacks::List&lt; T &gt;:<p><center><img src="classROSE__Callbacks_1_1List__inherit__graph.png" border="0" usemap="#ROSE__Callbacks_1_1List_3_01T_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="ROSE__Callbacks_1_1List_3_01T_01_4__inherit__map">
<area href="classROSE__Callbacks_1_1List.html" shape="rect" coords="5,103,400,129" alt="">
<area href="classROSE__Callbacks_1_1List.html" shape="rect" coords="424,103,835,129" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center>Collaboration diagram for ROSE_Callbacks::List&lt; T &gt;:<p><center><img src="classROSE__Callbacks_1_1List__coll__graph.png" border="0" usemap="#ROSE__Callbacks_1_1List_3_01T_01_4__coll__map" alt="Collaboration graph"></center>
<map name="ROSE__Callbacks_1_1List_3_01T_01_4__coll__map">
<area href="structRTS__mutex__t.html" shape="rect" coords="49,7,153,33" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classROSE__Callbacks_1_1List-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T&gt;<br>
 class ROSE_Callbacks::List&lt; T &gt;</h3>

<a class="el" href="classROSE__Callbacks_1_1List.html">List</a> of callback functors. 
<p>
This template defines ordered containers of callback functors and thread-safe functions for accessing the containers.<h2><a class="anchor" name="ROSE_Callbacks_List_Example1">
Example Usage</a></h2>
The first step is to create a functor class having one or more callbacks (operator() methods), each of which takes a struct reference containing the data to which the callback is applied.<p>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyCallback: <span class="keyword">public</span> MyCallbackBase { <span class="comment">//base class optional</span>
  <span class="keyword">public</span>:
      MyCallback(): ncalls(0) {}

      <span class="comment">// Callback argument structure.  Data members can be anything</span>
      <span class="comment">// you want, and you can even have more than one of these</span>
      <span class="comment">// structs--one per callback signature.  The constructor</span>
      <span class="comment">// should generally just assign arguments to data members.</span>
      <span class="keyword">struct </span>Args {
          Args(<a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn, <span class="keywordtype">int</span> callno, <span class="keywordtype">char</span> *name):
              insn(insn), callno(callno), name(name) {}
          <a class="code" href="classSgAsmInstruction.html">SgAsmInstruction</a> *insn;
          <span class="keywordtype">int</span> callno;
          <span class="keywordtype">char</span> *name;
      };

      <span class="comment">// The callback.  You can overload these, but they'll all</span>
      <span class="comment">// take two arguments where the first is a Boolean and the</span>
      <span class="comment">// second is one of the argument types you defined above.</span>
      <span class="keywordtype">bool</span> operator()(<span class="keywordtype">bool</span> b, <span class="keyword">const</span> Args &amp;args) {
          ncalls++;
          printf(stderr,<span class="stringliteral">"%s: %d\n"</span>, args.name, args.callno);
          insns.push_back(args.insn);
          <span class="keywordflow">return</span> b;
      }

      <span class="comment">// Some data members accessible by the callback(s)</span>
      size_t ncalls;
      <span class="keyword">static</span> std::vector&lt;SgAsmInstruction*&gt; insns;
  };
</pre></div><p>
The second step is to create a list to hold these callbacks. Our example callback was derived from a base class, so we'll use that base class as the list element type.<p>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="classROSE__Callbacks_1_1List.html">ROSE_Callbacks::List&lt;MyCallbackBase&gt;</a> MyCallbackList;
  MyCallbackList cbl;
</pre></div><p>
Add some callbacks to the list. We'll just add one for this example.<p>
<div class="fragment"><pre class="fragment">  cbl.append(<span class="keyword">new</span> MyCallback);
</pre></div><p>
Finally, invoke all the callbacks in the list, supplying some arguments that will be used for each callback.<p>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">bool</span> result = cbl.apply(<span class="keyword">true</span>, MyCallback::Args(insn, 5, <span class="stringliteral">"foo"</span>));
</pre></div> 
<p>

<p>
Definition at line <a class="el" href="callbacks_8h-source.html#l00079">79</a> of file <a class="el" href="callbacks_8h-source.html">callbacks.h</a>.<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functor class.  <a href="#244e6c49027c2f28188894be3c7bb094"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::list&lt; <a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROSE__Callbacks_1_1List.html#b9dfb1d8db906488e8f1ca09db6488f7">CBList</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Standard vector of functor pointers.  <a href="#b9dfb1d8db906488e8f1ca09db6488f7"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROSE__Callbacks_1_1List.html#34b5b950b3a6fd4dde403c87e4df1ab9">List</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROSE__Callbacks_1_1List.html#5dd22e48aa66ea9ee14b7623bf9b42fb">List</a> (<a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a> *callback)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROSE__Callbacks_1_1List.html#bd690d301fed14b94dba97be64599e9d">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of callbacks in the list.  <a href="#bd690d301fed14b94dba97be64599e9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROSE__Callbacks_1_1List.html#bff578d0b0455e649e0651d1eb8a6b57">empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Predicate to test whether the list is empty.  <a href="#bff578d0b0455e649e0651d1eb8a6b57"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classROSE__Callbacks_1_1List.html">List</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROSE__Callbacks_1_1List.html#d16bb91466c7407034969bcb4721b1a0">append</a> (<a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a> *cb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a functor to the end of the list without copying it.  <a href="#d16bb91466c7407034969bcb4721b1a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classROSE__Callbacks_1_1List.html">List</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROSE__Callbacks_1_1List.html#d37c05ffc1d74c823990adf35771518e">prepend</a> (<a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a> *cb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepend callback to beginning of list without copying it.  <a href="#d37c05ffc1d74c823990adf35771518e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classROSE__Callbacks_1_1List.html">List</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROSE__Callbacks_1_1List.html#a5dd95c45c1ecad889764c25ca2a2322">after</a> (<a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a> *relative_to, <a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a> *cb, size_t nreplacements=(size_t)(-1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a callback after another.  <a href="#a5dd95c45c1ecad889764c25ca2a2322"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classROSE__Callbacks_1_1List.html">List</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROSE__Callbacks_1_1List.html#9aedbc56baa3a00c3335be06d7d6ebd1">before</a> (<a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a> *relative_to, <a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a> *cb, size_t nreplacements=(size_t)(-1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a callback before another.  <a href="#9aedbc56baa3a00c3335be06d7d6ebd1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classROSE__Callbacks_1_1List.html">List</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROSE__Callbacks_1_1List.html#9bb6ffe81b425ad3f0dc62ac1bfa6e7d">replace</a> (<a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a> *old_cb, <a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a> *new_cb, size_t nreplacements=(size_t)(-1), <a class="el" href="namespaceROSE__Callbacks.html#28718843fbaf9f7bef004777c1750084">Direction</a> dir=FORWARD)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace one callback with another.  <a href="#9bb6ffe81b425ad3f0dc62ac1bfa6e7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROSE__Callbacks_1_1List.html#10fb6d8a1f3567ac5d97d576e19faa88">erase</a> (<a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a> *cb, <a class="el" href="namespaceROSE__Callbacks.html#28718843fbaf9f7bef004777c1750084">Direction</a> dir=FORWARD)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a callback from a list without destroying it.  <a href="#10fb6d8a1f3567ac5d97d576e19faa88"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classROSE__Callbacks_1_1List.html">List</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROSE__Callbacks_1_1List.html#a778088814bc8db53894cbebc55bb21b">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all callbacks from list without destroying them.  <a href="#a778088814bc8db53894cbebc55bb21b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::list&lt; <a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROSE__Callbacks_1_1List.html#319eb86c184def6d385e43ce611eecf1">callbacks</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a copy of the underlying STL vector of functors.  <a href="#319eb86c184def6d385e43ce611eecf1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class ArgumentType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classROSE__Callbacks_1_1List.html#63489d992c7057770eeb5558bcf681aa">apply</a> (bool b, const ArgumentType &amp;args, <a class="el" href="namespaceROSE__Callbacks.html#28718843fbaf9f7bef004777c1750084">Direction</a> dir=FORWARD) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invokes all functors in the callback list.  <a href="#63489d992c7057770eeb5558bcf681aa"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structRTS__mutex__t.html">RTS_mutex_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROSE__Callbacks_1_1List.html#da73bb46caa6fc6093834b6d29bc03b9">mutex</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classROSE__Callbacks_1_1List.html#b9dfb1d8db906488e8f1ca09db6488f7">CBList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classROSE__Callbacks_1_1List.html#1ecce646279c098e233a7503b3a38779">list</a></td></tr>

</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="244e6c49027c2f28188894be3c7bb094"></a><!-- doxytag: member="ROSE_Callbacks::List::CallbackType" ref="244e6c49027c2f28188894be3c7bb094" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classROSE__Callbacks_1_1List.html">ROSE_Callbacks::List</a>&lt; T &gt;::<a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Functor class. 
<p>

<p>
Definition at line <a class="el" href="callbacks_8h-source.html#l00081">81</a> of file <a class="el" href="callbacks_8h-source.html">callbacks.h</a>.
</div>
</div><p>
<a class="anchor" name="b9dfb1d8db906488e8f1ca09db6488f7"></a><!-- doxytag: member="ROSE_Callbacks::List::CBList" ref="b9dfb1d8db906488e8f1ca09db6488f7" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;<a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a>*&gt; <a class="el" href="classROSE__Callbacks_1_1List.html">ROSE_Callbacks::List</a>&lt; T &gt;::<a class="el" href="classROSE__Callbacks_1_1List.html#b9dfb1d8db906488e8f1ca09db6488f7">CBList</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Standard vector of functor pointers. 
<p>

<p>
Definition at line <a class="el" href="callbacks_8h-source.html#l00082">82</a> of file <a class="el" href="callbacks_8h-source.html">callbacks.h</a>.
</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="34b5b950b3a6fd4dde403c87e4df1ab9"></a><!-- doxytag: member="ROSE_Callbacks::List::List" ref="34b5b950b3a6fd4dde403c87e4df1ab9" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROSE__Callbacks_1_1List.html">ROSE_Callbacks::List</a>&lt; T &gt;::<a class="el" href="classROSE__Callbacks_1_1List.html">List</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="callbacks_8h-source.html#l00084">84</a> of file <a class="el" href="callbacks_8h-source.html">callbacks.h</a>.
</div>
</div><p>
<a class="anchor" name="5dd22e48aa66ea9ee14b7623bf9b42fb"></a><!-- doxytag: member="ROSE_Callbacks::List::List" ref="5dd22e48aa66ea9ee14b7623bf9b42fb" args="(CallbackType *callback)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROSE__Callbacks_1_1List.html">ROSE_Callbacks::List</a>&lt; T &gt;::<a class="el" href="classROSE__Callbacks_1_1List.html">List</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="callbacks_8h-source.html#l00088">88</a> of file <a class="el" href="callbacks_8h-source.html">callbacks.h</a>.
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="bd690d301fed14b94dba97be64599e9d"></a><!-- doxytag: member="ROSE_Callbacks::List::size" ref="bd690d301fed14b94dba97be64599e9d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classROSE__Callbacks_1_1List.html">ROSE_Callbacks::List</a>&lt; T &gt;::size           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of callbacks in the list. 
<p>
Thread safety: This method is thread safe. 
<p>
Definition at line <a class="el" href="callbacks_8h-source.html#l00096">96</a> of file <a class="el" href="callbacks_8h-source.html">callbacks.h</a>.
</div>
</div><p>
<a class="anchor" name="bff578d0b0455e649e0651d1eb8a6b57"></a><!-- doxytag: member="ROSE_Callbacks::List::empty" ref="bff578d0b0455e649e0651d1eb8a6b57" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classROSE__Callbacks_1_1List.html">ROSE_Callbacks::List</a>&lt; T &gt;::empty           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Predicate to test whether the list is empty. 
<p>
Returns true if the list is empty, false otherwise.<p>
Thread safety: This method is thread safe. 
<p>
Definition at line <a class="el" href="callbacks_8h-source.html#l00107">107</a> of file <a class="el" href="callbacks_8h-source.html">callbacks.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l01697">Partitioner::scan_interfunc_bytes()</a>, <a class="el" href="Partitioner_8C-source.html#l01591">Partitioner::scan_interfunc_insns()</a>, <a class="el" href="Partitioner_8C-source.html#l01664">Partitioner::scan_intrafunc_bytes()</a>, <a class="el" href="Partitioner_8C-source.html#l01618">Partitioner::scan_intrafunc_insns()</a>, <a class="el" href="Partitioner_8C-source.html#l01643">Partitioner::scan_unassigned_bytes()</a>, and <a class="el" href="Partitioner_8C-source.html#l01560">Partitioner::scan_unassigned_insns()</a>.
</div>
</div><p>
<a class="anchor" name="d16bb91466c7407034969bcb4721b1a0"></a><!-- doxytag: member="ROSE_Callbacks::List::append" ref="d16bb91466c7407034969bcb4721b1a0" args="(CallbackType *cb)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROSE__Callbacks_1_1List.html">List</a>&amp; <a class="el" href="classROSE__Callbacks_1_1List.html">ROSE_Callbacks::List</a>&lt; T &gt;::append           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a> *&nbsp;</td>
          <td class="paramname"> <em>cb</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append a functor to the end of the list without copying it. 
<p>
Functors can be inserted more than once into a list, and each occurrence will be called by the <a class="el" href="classROSE__Callbacks_1_1List.html#63489d992c7057770eeb5558bcf681aa">apply()</a> method.<p>
Thread safety: This method is thread safe. In fact, it is safe to modify the list while <a class="el" href="classROSE__Callbacks_1_1List.html#63489d992c7057770eeb5558bcf681aa">apply()</a> is calling the functors on that list. 
<p>
Definition at line <a class="el" href="callbacks_8h-source.html#l00120">120</a> of file <a class="el" href="callbacks_8h-source.html">callbacks.h</a>.
<p>
Referenced by <a class="el" href="callbacks_8h-source.html#l00088">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::List()</a>.
</div>
</div><p>
<a class="anchor" name="d37c05ffc1d74c823990adf35771518e"></a><!-- doxytag: member="ROSE_Callbacks::List::prepend" ref="d37c05ffc1d74c823990adf35771518e" args="(CallbackType *cb)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROSE__Callbacks_1_1List.html">List</a>&amp; <a class="el" href="classROSE__Callbacks_1_1List.html">ROSE_Callbacks::List</a>&lt; T &gt;::prepend           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a> *&nbsp;</td>
          <td class="paramname"> <em>cb</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prepend callback to beginning of list without copying it. 
<p>
Functors can be inserted more than once into a list, and each occurrence will be called by the <a class="el" href="classROSE__Callbacks_1_1List.html#63489d992c7057770eeb5558bcf681aa">apply()</a> method.<p>
Thread safety: This method is thread safe. In fact, it is safe to modify the list while <a class="el" href="classROSE__Callbacks_1_1List.html#63489d992c7057770eeb5558bcf681aa">apply()</a> is calling the functors on that list. 
<p>
Definition at line <a class="el" href="callbacks_8h-source.html#l00133">133</a> of file <a class="el" href="callbacks_8h-source.html">callbacks.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l01697">Partitioner::scan_interfunc_bytes()</a>, <a class="el" href="Partitioner_8C-source.html#l01591">Partitioner::scan_interfunc_insns()</a>, <a class="el" href="Partitioner_8C-source.html#l01664">Partitioner::scan_intrafunc_bytes()</a>, and <a class="el" href="Partitioner_8C-source.html#l01618">Partitioner::scan_intrafunc_insns()</a>.
</div>
</div><p>
<a class="anchor" name="a5dd95c45c1ecad889764c25ca2a2322"></a><!-- doxytag: member="ROSE_Callbacks::List::after" ref="a5dd95c45c1ecad889764c25ca2a2322" args="(CallbackType *relative_to, CallbackType *cb, size_t nreplacements=(size_t)(-1))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROSE__Callbacks_1_1List.html">List</a>&amp; <a class="el" href="classROSE__Callbacks_1_1List.html">ROSE_Callbacks::List</a>&lt; T &gt;::after           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a> *&nbsp;</td>
          <td class="paramname"> <em>relative_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a> *&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nreplacements</em> = <code>(size_t)(-1)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a callback after another. 
<p>
The callback is inserted after each occurrence of the <code>relative_to</code> callback. Up to <code>nreplacement</code> insertions are made beginning at the front of the list.<p>
Thread safety: This method is thread safe. In fact, it is safe to modify the list while <a class="el" href="classROSE__Callbacks_1_1List.html#63489d992c7057770eeb5558bcf681aa">apply()</a> is calling the functors on that list. 
<p>
Definition at line <a class="el" href="callbacks_8h-source.html#l00146">146</a> of file <a class="el" href="callbacks_8h-source.html">callbacks.h</a>.
</div>
</div><p>
<a class="anchor" name="9aedbc56baa3a00c3335be06d7d6ebd1"></a><!-- doxytag: member="ROSE_Callbacks::List::before" ref="9aedbc56baa3a00c3335be06d7d6ebd1" args="(CallbackType *relative_to, CallbackType *cb, size_t nreplacements=(size_t)(-1))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROSE__Callbacks_1_1List.html">List</a>&amp; <a class="el" href="classROSE__Callbacks_1_1List.html">ROSE_Callbacks::List</a>&lt; T &gt;::before           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a> *&nbsp;</td>
          <td class="paramname"> <em>relative_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a> *&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nreplacements</em> = <code>(size_t)(-1)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a callback before another. 
<p>
The callback is inserted before each occurrence of the <code>relative_to</code> callback. Up to <code>nreplacement</code> insertions are made begin$ning at the front of the list.<p>
Thread safety: This method is thread safe. In fact, it is safe to modify the list while <a class="el" href="classROSE__Callbacks_1_1List.html#63489d992c7057770eeb5558bcf681aa">apply()</a> is calling the functors on that list. 
<p>
Definition at line <a class="el" href="callbacks_8h-source.html#l00164">164</a> of file <a class="el" href="callbacks_8h-source.html">callbacks.h</a>.
</div>
</div><p>
<a class="anchor" name="9bb6ffe81b425ad3f0dc62ac1bfa6e7d"></a><!-- doxytag: member="ROSE_Callbacks::List::replace" ref="9bb6ffe81b425ad3f0dc62ac1bfa6e7d" args="(CallbackType *old_cb, CallbackType *new_cb, size_t nreplacements=(size_t)(-1), Direction dir=FORWARD)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROSE__Callbacks_1_1List.html">List</a>&amp; <a class="el" href="classROSE__Callbacks_1_1List.html">ROSE_Callbacks::List</a>&lt; T &gt;::replace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a> *&nbsp;</td>
          <td class="paramname"> <em>old_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a> *&nbsp;</td>
          <td class="paramname"> <em>new_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nreplacements</em> = <code>(size_t)(-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceROSE__Callbacks.html#28718843fbaf9f7bef004777c1750084">Direction</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em> = <code>FORWARD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace one callback with another. 
<p>
The replaced callback is removed from the list as if by <a class="el" href="classROSE__Callbacks_1_1List.html#10fb6d8a1f3567ac5d97d576e19faa88">erase()</a> without deleting it, and its replacement is inserted at the same position without copying it. At most <code>nreplacements</code> are performed (the default is unlimited). Replacements are performed in the direction specified.<p>
Thread safety: This method is thread safe. In fact, it is safe to modify the list while <a class="el" href="classROSE__Callbacks_1_1List.html#63489d992c7057770eeb5558bcf681aa">apply()</a> is calling the functors on that list. 
<p>
Definition at line <a class="el" href="callbacks_8h-source.html#l00184">184</a> of file <a class="el" href="callbacks_8h-source.html">callbacks.h</a>.
</div>
</div><p>
<a class="anchor" name="10fb6d8a1f3567ac5d97d576e19faa88"></a><!-- doxytag: member="ROSE_Callbacks::List::erase" ref="10fb6d8a1f3567ac5d97d576e19faa88" args="(CallbackType *cb, Direction dir=FORWARD)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classROSE__Callbacks_1_1List.html">ROSE_Callbacks::List</a>&lt; T &gt;::erase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a> *&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceROSE__Callbacks.html#28718843fbaf9f7bef004777c1750084">Direction</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em> = <code>FORWARD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove a callback from a list without destroying it. 
<p>
The list is traversed in the specified direction and the first functor that matches (by pointer comparison) the specified callback is removed from the list. Returns true if a functor was removed, false otherwise.<p>
Thread safety: This method is thread safe. In fact, it is safe to modify the list while <a class="el" href="classROSE__Callbacks_1_1List.html#63489d992c7057770eeb5558bcf681aa">apply()</a> is calling the functors on that list. 
<p>
Definition at line <a class="el" href="callbacks_8h-source.html#l00212">212</a> of file <a class="el" href="callbacks_8h-source.html">callbacks.h</a>.
</div>
</div><p>
<a class="anchor" name="a778088814bc8db53894cbebc55bb21b"></a><!-- doxytag: member="ROSE_Callbacks::List::clear" ref="a778088814bc8db53894cbebc55bb21b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROSE__Callbacks_1_1List.html">List</a>&amp; <a class="el" href="classROSE__Callbacks_1_1List.html">ROSE_Callbacks::List</a>&lt; T &gt;::clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove all callbacks from list without destroying them. 
<p>
Thread safety: This method is thread safe. In fact, it is safe to modify the list while <a class="el" href="classROSE__Callbacks_1_1List.html#63489d992c7057770eeb5558bcf681aa">apply()</a> is calling the functors on that list. 
<p>
Definition at line <a class="el" href="callbacks_8h-source.html#l00240">240</a> of file <a class="el" href="callbacks_8h-source.html">callbacks.h</a>.
</div>
</div><p>
<a class="anchor" name="319eb86c184def6d385e43ce611eecf1"></a><!-- doxytag: member="ROSE_Callbacks::List::callbacks" ref="319eb86c184def6d385e43ce611eecf1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="classROSE__Callbacks_1_1List.html#244e6c49027c2f28188894be3c7bb094">CallbackType</a>*&gt; <a class="el" href="classROSE__Callbacks_1_1List.html">ROSE_Callbacks::List</a>&lt; T &gt;::callbacks           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a copy of the underlying STL vector of functors. 
<p>
Thread safety: This method is thread safe. 
<p>
Definition at line <a class="el" href="callbacks_8h-source.html#l00250">250</a> of file <a class="el" href="callbacks_8h-source.html">callbacks.h</a>.
<p>
Referenced by <a class="el" href="callbacks_8h-source.html#l00269">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::apply()</a>.
</div>
</div><p>
<a class="anchor" name="63489d992c7057770eeb5558bcf681aa"></a><!-- doxytag: member="ROSE_Callbacks::List::apply" ref="63489d992c7057770eeb5558bcf681aa" args="(bool b, const ArgumentType &amp;args, Direction dir=FORWARD) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class ArgumentType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classROSE__Callbacks_1_1List.html">ROSE_Callbacks::List</a>&lt; T &gt;::apply           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArgumentType &amp;&nbsp;</td>
          <td class="paramname"> <em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceROSE__Callbacks.html#28718843fbaf9f7bef004777c1750084">Direction</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em> = <code>FORWARD</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invokes all functors in the callback list. 
<p>
The functors are invoked sequentially in the order specified by calling its operator() method. Two arguments are provided: a boolean value, and an additional argument with parameterized type. The boolean argument for the first callback is the <code>b</code> argument of this method; the boolean argument of the subsequent callbacks is the return value of the previous callback; the return value of this method is the return value of the last callback (or the initial value of <code>b</code> if no callbacks were made).<p>
Thread safety: This method is thread safe. If this list is modified by one or more of the functors on this list or by another thread, those changes do not affect which callbacks are made by this invocation of <a class="el" href="classROSE__Callbacks_1_1List.html#63489d992c7057770eeb5558bcf681aa">apply()</a>. The callbacks should not assume that any particular mutexes or other thread synchronization resources are held. It is possible for a single callback to be invoked concurrently if two or more threads invoke <a class="el" href="classROSE__Callbacks_1_1List.html#63489d992c7057770eeb5558bcf681aa">apply()</a> concurrently. 
<p>
Definition at line <a class="el" href="callbacks_8h-source.html#l00269">269</a> of file <a class="el" href="callbacks_8h-source.html">callbacks.h</a>.
<p>
Referenced by <a class="el" href="Partitioner_8C-source.html#l01539">Partitioner::scan_contiguous_insns()</a>, and <a class="el" href="Partitioner_8C-source.html#l01643">Partitioner::scan_unassigned_bytes()</a>.
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="da73bb46caa6fc6093834b6d29bc03b9"></a><!-- doxytag: member="ROSE_Callbacks::List::mutex" ref="da73bb46caa6fc6093834b6d29bc03b9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRTS__mutex__t.html">RTS_mutex_t</a> <a class="el" href="classROSE__Callbacks_1_1List.html">ROSE_Callbacks::List</a>&lt; T &gt;::<a class="el" href="classmutex.html">mutex</a><code> [mutable, private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="callbacks_8h-source.html#l00284">284</a> of file <a class="el" href="callbacks_8h-source.html">callbacks.h</a>.
</div>
</div><p>
<a class="anchor" name="1ecce646279c098e233a7503b3a38779"></a><!-- doxytag: member="ROSE_Callbacks::List::list" ref="1ecce646279c098e233a7503b3a38779" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classROSE__Callbacks_1_1List.html#b9dfb1d8db906488e8f1ca09db6488f7">CBList</a> <a class="el" href="classROSE__Callbacks_1_1List.html">ROSE_Callbacks::List</a>&lt; T &gt;::<a class="el" href="classROSE__Callbacks_1_1List.html#1ecce646279c098e233a7503b3a38779">list</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="callbacks_8h-source.html#l00285">285</a> of file <a class="el" href="callbacks_8h-source.html">callbacks.h</a>.
<p>
Referenced by <a class="el" href="callbacks_8h-source.html#l00146">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::after()</a>, <a class="el" href="callbacks_8h-source.html#l00120">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::append()</a>, <a class="el" href="callbacks_8h-source.html#l00269">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::apply()</a>, <a class="el" href="callbacks_8h-source.html#l00164">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::before()</a>, <a class="el" href="callbacks_8h-source.html#l00250">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::callbacks()</a>, <a class="el" href="callbacks_8h-source.html#l00240">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::clear()</a>, <a class="el" href="callbacks_8h-source.html#l00107">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::empty()</a>, <a class="el" href="callbacks_8h-source.html#l00212">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::erase()</a>, <a class="el" href="callbacks_8h-source.html#l00133">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::prepend()</a>, <a class="el" href="callbacks_8h-source.html#l00184">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::replace()</a>, and <a class="el" href="callbacks_8h-source.html#l00096">ROSE_Callbacks::List&lt; AsmFunctionIndex::OutputCallback &gt;::size()</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="callbacks_8h-source.html">callbacks.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
