<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: AstFromString.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>AstFromString.h File Reference</h1>
<p>
<code>#include &quot;<a class="el" href="sage3basic_8h-source.html">sage3basic.h</a>&quot;</code><br>
<code>#include &lt;iostream&gt;</code><br>
<code>#include &lt;vector&gt;</code><br>

<p>
Include dependency graph for AstFromString.h:<p><center><img src="AstFromString_8h__incl.png" border="0" usemap="#AstFromString.h_map" alt=""></center>
<map name="AstFromString.h_map">
<area href="sage3basic_8h.html" shape="rect" coords="176,5,283,32" alt="">
</map>

<p>
This graph shows which files directly or indirectly include this file:<p><center><img src="AstFromString_8h__dep__incl.png" border="0" usemap="#AstFromString.hdep_map" alt=""></center>
<map name="AstFromString.hdep_map">
<area href="sage3_8h.html" shape="rect" coords="176,81,248,108" alt="">
<area href="genericDataflowCommon_8h.html" shape="rect" coords="297,5,495,32" alt="">
<area href="partitionedAnalysis_8h.html" shape="rect" coords="545,31,697,57" alt="">
<area href="arrIndexLabeler_8h.html" shape="rect" coords="329,107,463,133" alt="">
<area href="CallGraphTraverse_8h.html" shape="rect" coords="320,157,472,184" alt="">
</map>

<p>
<a href="AstFromString_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html">AstFromString</a></td></tr>

<tr><td colspan="2"><br><h2>Namespace scope variables</h2></td></tr>
<tr><td colspan="2">Semi-global variables <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="AstFromString_8h.html#acaf1aff3ef1217228c89e1067070232">OFS_MAX_LEN</a>&nbsp;&nbsp;&nbsp;256</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maximum length for a buffer for a variable, constant, or pragma construct name  <a href="#acaf1aff3ef1217228c89e1067070232"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#40c060440fd38cf16b94e53c857b0ab8">AstFromString::c_char</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A namespace scope char* to avoid passing and returning a target c string for every and each function current characters being scanned, what is pointed is const, the pointer itself is not const.  <a href="#40c060440fd38cf16b94e53c857b0ab8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#d0a195aa797474256eb6a247c5785096">AstFromString::c_sgnode</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">current anchor <a class="el" href="classSgNode.html">SgNode</a> associated with parsing. It will serve as a start point to find enclosing scopes for resolving identifiers/symbols  <a href="#d0a195aa797474256eb6a247c5785096"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSgNode.html">SgNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#fa86836cff8cafbe2defb54470659310">AstFromString::c_parsed_node</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store the AST substree (expression, statement) generated from a helper function.  <a href="#fa86836cff8cafbe2defb54470659310"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Character check , without side effect on the current position</h2></td></tr>
<tr><td colspan="2">utility functions for checking characters, without changing the current position of the input string being parsed. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#da0d171a30f169d5620272c66d3d5c8c">AstFromString::afs_is_digit</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the current character is a digit. The current position of the input string remains unchanged either way.  <a href="#da0d171a30f169d5620272c66d3d5c8c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#72c0b5acd1cd30df98bb570357c845ea">AstFromString::afs_is_identifier_char</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the current character is a legal identifier character, including letters, digits, '_' and '$' (For fortran). No side effect on the current position.  <a href="#72c0b5acd1cd30df98bb570357c845ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#05677585e184ef8a881a8565a26ffb28">AstFromString::afs_is_letter</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the current character is a letter. No side effect on the current position of the input string.  <a href="#05677585e184ef8a881a8565a26ffb28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#11b24b41cef8d03a45ca8a079c8b2350">AstFromString::afs_is_lower_letter</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the current character is a lower case letter.  <a href="#11b24b41cef8d03a45ca8a079c8b2350"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#ad82524f84140c3e4d595a9e9fb5a132">AstFromString::afs_is_upper_letter</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the current character is a upper case letter.  <a href="#ad82524f84140c3e4d595a9e9fb5a132"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Match with side effects (set c_parsed_node and advance the current position of character) if successful. Return false and have no side effects if the match fails.</h2></td></tr>
<tr><td colspan="2">utility functions for matching string, whitespace, identifiers, const etc. Successful match will advance the current position. entry point, declarations, types Follow the order of <a href="http://www.antlr.org/grammar/1153358328744/C.g">http://www.antlr.org/grammar/1153358328744/C.g</a> <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#3cd96a9a913bdcd74d8872627f43abe6">AstFromString::afs_match_char</a> (char c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">match a char, advance one position if successful.  <a href="#3cd96a9a913bdcd74d8872627f43abe6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#3fa38d1fa399750040b91b8ce7aab969">AstFromString::afs_match_substr</a> (const char *substr, bool checkTrail=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match a sub string: a given sub c string from the input c string, again skip heading space/tabs if any.  <a href="#3fa38d1fa399750040b91b8ce7aab969"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#5abae5c653d5afad4a8706a3048ff8d4">AstFromString::afs_skip_whitespace</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match and skip whitespace.  <a href="#5abae5c653d5afad4a8706a3048ff8d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#be55805eb4a4992b6f6bbca8c991b9ae">AstFromString::afs_match_identifier</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match identifier, move to the next character if successful. The identifier could be a name of a type, function, variable, or label. The resolved identifier (type or variable/function/label name) is stored into c_parsed_node.  <a href="#be55805eb4a4992b6f6bbca8c991b9ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#f71865ace99fdae73e785f40a66e76e3">AstFromString::afs_match_integer_const</a> (int *result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match an integer constant, store it into result.  <a href="#f71865ace99fdae73e785f40a66e76e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#66bf6ffe4a7289d433d9b73b96dfb6a8">AstFromString::afs_match_translation_unit</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match a translation unit. Not yet implemented.  <a href="#66bf6ffe4a7289d433d9b73b96dfb6a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#b8723927c40b380f0ca5db0916aa04b1">AstFromString::afs_match_external_declaration</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match an external declaration. Not yet implemented.  <a href="#b8723927c40b380f0ca5db0916aa04b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#e06f2c046ca13de801fc2880c6445e0d">AstFromString::afs_match_function_definition</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match a function definition. Not yet implemented.  <a href="#e06f2c046ca13de801fc2880c6445e0d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#116fca2a1343fd6caa5ec533c48b210c">AstFromString::afs_match_declaration</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match a declaration. Not yet implemented.  <a href="#116fca2a1343fd6caa5ec533c48b210c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#a2610a30f7c006f42b2f30f265b93e49">AstFromString::afs_match_declaration_specifiers</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match declaration specifiers. Not yet implemented.  <a href="#a2610a30f7c006f42b2f30f265b93e49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#699b8dc8f9b0c6259df7aea73784d45d">AstFromString::afs_match_init_declarator_list</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match an init declarator list. Not yet implemented.  <a href="#699b8dc8f9b0c6259df7aea73784d45d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#85d0ea63479b87f8b0e758b671e19045">AstFromString::afs_match_init_declarator</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match init declarator. Not yet implemented.  <a href="#85d0ea63479b87f8b0e758b671e19045"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#980d054be0a0d7c22f2cdd4947650a43">AstFromString::afs_match_storage_class_specifier</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match a storage class specifier. Not yet implemented.  <a href="#980d054be0a0d7c22f2cdd4947650a43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#11b78ad746fb5b993b3e7c06ca7ccea3">AstFromString::afs_match_type_specifier</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match a type specifier : 'void' | 'char' | 'short' | 'int' | 'long' | 'float' | 'double' | 'signed' | 'unsigned' | struct_or_union_specifier | enum_specifier | type_id. The recognized type is stored in c_parsed_node.  <a href="#11b78ad746fb5b993b3e7c06ca7ccea3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#4e5f1c0435a73d7c7f59a04403648c79">AstFromString::afs_match_specifier_qualifier_list</a> (std::vector&lt; <a class="el" href="classSgNode.html">SgNode</a> * &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match a list of specifiers and qualifiers : : ( type_qualifier | type_specifier )+.  <a href="#4e5f1c0435a73d7c7f59a04403648c79"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#f3a0147793736529720ee0d205eb4605">AstFromString::afs_match_type_qualifier</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match a type qualifier : 'const' | 'volatile'.  <a href="#f3a0147793736529720ee0d205eb4605"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#0d85361a2e72bdb7597bfae44bb9000d">AstFromString::afs_match_type_name</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match a type name : specifier_qualifier_list abstract_declarator?  <a href="#0d85361a2e72bdb7597bfae44bb9000d"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Expression</h2></td></tr>
<tr><td colspan="2">utility functions for parsing expressions and generate AST pieces for them. Successful match will advance the current position. The function names and grammars largely follow the conventions used in <a href="http://www.antlr.org/grammar/1153358328744/C.g.">http://www.antlr.org/grammar/1153358328744/C.g.</a> For example in the grammar shown, | means or, * means 0 or more repetition of the previous term , ? means 0 or 1 occurrence of the previous term. + means 1 or more occurrence. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#b2f7e408ebd42abd6a3f1524a9a40c4f">AstFromString::afs_match_argument_expression_list</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Grammar: argument_expression_list : assignment_expression (',' assignment_expression)* one assignment_expression, followed by optionally arbitrary numbers of (',' assignment_expression).  <a href="#b2f7e408ebd42abd6a3f1524a9a40c4f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#8ff708dd8c6a3b1d4e0ef24435ef57a0">AstFromString::afs_match_additive_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Grammar: additive_expression : (multiplicative_expression) ('+' multiplicative_expression | '-' multiplicative_expression)*.  <a href="#8ff708dd8c6a3b1d4e0ef24435ef57a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#b790e1f12bf6b12d05af38bf858d9f77">AstFromString::afs_match_multiplicative_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">multiplicative_expression : (cast_expression) ('*' cast_expression | '/' cast_expression | '' cast_expression)*  <a href="#b790e1f12bf6b12d05af38bf858d9f77"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#fb9988003ec258d5b1158320db512e6b">AstFromString::afs_match_cast_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">cast_expression : '(' type_name ')' cast_expression | unary_expression  <a href="#fb9988003ec258d5b1158320db512e6b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#f3734616354c3caa2f606209dc5177e8">AstFromString::afs_match_unary_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unary_expression : postfix_expression | INC_OP unary_expression | DEC_OP unary_expression | unary_operator cast_expression | SIZEOF unary_expression | SIZEOF '(' type_name ')'  <a href="#f3734616354c3caa2f606209dc5177e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#15123da9beb78f35c462ed98edca8642">AstFromString::afs_match_postfix_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">postfix_expression : primary_expression ( '[' expression ']' | '(' ')' | '(' argument_expression_list ')' | '.' IDENTIFIER | '-&gt;' IDENTIFIER | '++' | '--' )*  <a href="#15123da9beb78f35c462ed98edca8642"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#f42fbad2937c56dbf426299bc0ea8512">AstFromString::afs_match_primary_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">primary_expression : IDENTIFIER | constant | '(' expression ')'  <a href="#f42fbad2937c56dbf426299bc0ea8512"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#22e93ed03cda1337021b9d19150e6823">AstFromString::afs_match_constant</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Only integer constant is supported for now. Full grammar is constant : HEX_LITERAL | OCTAL_LITERAL | DECIMAL_LITERAL | CHARACTER_LITERAL | STRING_LITERAL | FLOATING_POINT_LITERAL.  <a href="#22e93ed03cda1337021b9d19150e6823"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#5da3da6c00c88c919b7e993859a6a03a">AstFromString::afs_match_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">expression : assignment_expression (',' assignment_expression)*. Match one or more assignment_expression  <a href="#5da3da6c00c88c919b7e993859a6a03a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#db9826b8265782cdc48caea38b4a274d">AstFromString::afs_match_constant_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">constant_expression : conditional_expression  <a href="#db9826b8265782cdc48caea38b4a274d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#0bc445f47d61dd4f000f8f4b9c8847b8">AstFromString::afs_match_assignment_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">assignment_expression : lvalue assignment_operator assignment_expression | conditional_expression  <a href="#0bc445f47d61dd4f000f8f4b9c8847b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#456363ab176f7bd2e416e24a9bb66609">AstFromString::afs_match_lvalue</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">lvalue: unary_expression  <a href="#456363ab176f7bd2e416e24a9bb66609"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#d458e39d03f3b271a7de89ca1be1d700">AstFromString::afs_match_conditional_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">conditional_expression : logical_or_expression ('?' expression ':' conditional_expression)? '?' means 0 or 1 occurrence  <a href="#d458e39d03f3b271a7de89ca1be1d700"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#05197a45404734e6fff0bcf7c1c27891">AstFromString::afs_match_logical_or_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">logical_or_expression : logical_and_expression ('||' logical_and_expression)*  <a href="#05197a45404734e6fff0bcf7c1c27891"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#e5203e84707829c1894962029bec667a">AstFromString::afs_match_logical_and_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">logical_and_expression : inclusive_or_expression ('&amp;&amp;' inclusive_or_expression)*  <a href="#e5203e84707829c1894962029bec667a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#5a44009993b03d6dbffd3804f22b4102">AstFromString::afs_match_inclusive_or_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inclusive_or_expression : exclusive_or_expression ('|' exclusive_or_expression)*  <a href="#5a44009993b03d6dbffd3804f22b4102"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#3dfd5735e6a8b871ab0919e1b7e16b7d">AstFromString::afs_match_exclusive_or_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">exclusive_or_expression : and_expression ('^' and_expression)*  <a href="#3dfd5735e6a8b871ab0919e1b7e16b7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#1c2994badc59ec172a4246a27b1ff8e9">AstFromString::afs_match_and_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">and_expression : equality_expression ('&amp;' equality_expression)*  <a href="#1c2994badc59ec172a4246a27b1ff8e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#3d5da6b7003e1f23f800e4b318a98d67">AstFromString::afs_match_equality_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">equality_expression : relational_expression (('=='|'!=') relational_expression)*  <a href="#3d5da6b7003e1f23f800e4b318a98d67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#841d1f4cd3da31ad6e58e0a6c5df1e82">AstFromString::afs_match_relational_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">relational_expression : shift_expression (('&lt;'|'&gt;'|'&lt;='|'&gt;=') shift_expression)*  <a href="#841d1f4cd3da31ad6e58e0a6c5df1e82"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#2ee5e90fe38fca83e116a6ad5f720b0f">AstFromString::afs_match_shift_expression</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">shift_expression : additive_expression (('&lt;&lt;'|'&gt;&gt;') additive_expression)*  <a href="#2ee5e90fe38fca83e116a6ad5f720b0f"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Statement</h2></td></tr>
<tr><td colspan="2">utility functions to parse a few statements. Successful match will advance the current position. INCOMPLETE now, Don't use them yet! <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#f90e6b9eebdaabd1f7967f8787439634">AstFromString::afs_match_statement</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">match any statement, not complete yet. Don't use it yet . : labeled_statement | compound_statement | expression_statement | selection_statement | iteration_statement | jump_statement  <a href="#f90e6b9eebdaabd1f7967f8787439634"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#341d881e4cb7e51b45642b243e131f54">AstFromString::afs_match_labeled_statement</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match labeled statement : IDENTIFIER ':' statement | 'case' constant_expression ':' statement | 'default' ':' statement.  <a href="#341d881e4cb7e51b45642b243e131f54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#33d1694de5d8c3267437ade0d54503ee">AstFromString::afs_match_compound_statement</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Not yet implemented. Match compound statement: '{' declaration* statement_list? '}'.  <a href="#33d1694de5d8c3267437ade0d54503ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#9f71021a17ce4a74735ce161945aedd3">AstFromString::afs_match_expression_statement</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match expression statement: : ';' | expression ';'.  <a href="#9f71021a17ce4a74735ce161945aedd3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#010c4debe4214c19e8e57d6e9957cbc7">AstFromString::afs_match_selection_statement</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match selection statement: IF '(' expression ')' statement | IF '(' expression ')' statement ELSE statement | SWITCH '(' expression ')' statement.  <a href="#010c4debe4214c19e8e57d6e9957cbc7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#5562f2db0432968a76bad994ebe2eee2">AstFromString::afs_match_iteration_statement</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match an iteration statement: : 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'for' '(' expression_statement expression_statement expression? ')' statement.  <a href="#5562f2db0432968a76bad994ebe2eee2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAstFromString.html#ab86f0076ee748c6509d7388a3a1d77a">AstFromString::afs_match_jump_statement</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match a jump statement : 'goto' IDENTIFIER ';' | 'continue' ';' | 'break' ';' | 'return' ';' | 'return' expression ';'.  <a href="#ab86f0076ee748c6509d7388a3a1d77a"></a><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="acaf1aff3ef1217228c89e1067070232"></a><!-- doxytag: member="AstFromString.h::OFS_MAX_LEN" ref="acaf1aff3ef1217228c89e1067070232" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OFS_MAX_LEN&nbsp;&nbsp;&nbsp;256          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
maximum length for a buffer for a variable, constant, or pragma construct name 
<p>

<p>
Definition at line <a class="el" href="AstFromString_8h-source.html#l00027">27</a> of file <a class="el" href="AstFromString_8h-source.html">AstFromString.h</a>.
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
