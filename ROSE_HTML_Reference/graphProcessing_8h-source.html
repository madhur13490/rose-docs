<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ROSE: graphProcessing.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>graphProcessing.h</h1><a href="graphProcessing_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">FINISH TEMPFLATPATH CODE</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">*/</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 
<a name="l00010"></a><a class="code" href="graphProcessing_8h.html#5b11d088a6ab6484ad47eaa4398e58eb">00010</a> <span class="preprocessor">#define LP 1</span>
<a name="l00011"></a><a class="code" href="graphProcessing_8h.html#bd8ccdf2e0dc7303ecc71cff28d1a650">00011</a> <span class="preprocessor"></span><span class="preprocessor">#define PERFDEBUG 0</span>
<a name="l00012"></a>00012 <span class="preprocessor"></span><span class="comment">//#define FULLDEBUG 1</span>
<a name="l00013"></a>00013 <span class="preprocessor">#ifdef _OPENMP</span>
<a name="l00014"></a>00014 <span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="omp_8h.html">omp.h</a>&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#endif</span>
<a name="l00016"></a>00016 <span class="preprocessor"></span><span class="preprocessor">#include &lt;boost/regex.hpp&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;<a class="code" href="staticCFG_8h.html">staticCFG.h</a>&gt;</span>
<a name="l00022"></a>00022 
<a name="l00054"></a>00054 <span class="preprocessor">#include &lt;boost/graph/adjacency_list.hpp&gt;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &lt;boost/bind.hpp&gt;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &lt;boost/foreach.hpp&gt;</span>
<a name="l00057"></a>00057 <span class="preprocessor">#include &lt;boost/tuple/tuple.hpp&gt;</span>
<a name="l00058"></a>00058 <span class="preprocessor">#include &lt;boost/graph/graphviz.hpp&gt;</span>
<a name="l00059"></a>00059 <span class="preprocessor">#include &lt;boost/graph/dominator_tree.hpp&gt;</span>
<a name="l00060"></a>00060 <span class="preprocessor">#include &lt;boost/graph/reverse_graph.hpp&gt;</span>
<a name="l00061"></a>00061 <span class="preprocessor">#include &lt;boost/graph/transpose_graph.hpp&gt;</span>
<a name="l00062"></a>00062 <span class="preprocessor">#include &lt;boost/algorithm/string.hpp&gt;</span>
<a name="l00063"></a>00063 
<a name="l00064"></a>00064 
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00067"></a>00067 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00068"></a>00068 <span class="preprocessor">#include &lt;utility&gt;</span>
<a name="l00069"></a>00069 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00070"></a>00070 <span class="preprocessor">#include &lt;sys/time.h&gt;</span>
<a name="l00071"></a>00071 <span class="preprocessor">#include &lt;sys/resource.h&gt;</span>
<a name="l00072"></a>00072 <span class="preprocessor">#include &lt;sys/time.h&gt;</span>
<a name="l00073"></a>00073 
<a name="l00074"></a>00074 
<a name="l00075"></a>00075 
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 
<a name="l00079"></a>00079 <span class="keyword">template</span> &lt;<span class="keyword">class</span> CFG&gt;
<a name="l00080"></a><a class="code" href="classSgGraphTraversal.html">00080</a> <span class="keyword">class </span><a class="code" href="classSgGraphTraversal.html">SgGraphTraversal</a>
<a name="l00081"></a>00081 {
<a name="l00082"></a>00082 <span class="keyword">public</span>:
<a name="l00083"></a>00083 
<a name="l00084"></a><a class="code" href="classSgGraphTraversal.html#243280ac8f5990707a305f9bcb095641">00084</a>   <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::graph_traits&lt;CFG&gt;::vertex_descriptor <a class="code" href="structVertex.html">Vertex</a>;
<a name="l00085"></a><a class="code" href="classSgGraphTraversal.html#c526995b61bc9e14690f0c72fc1b7a2b">00085</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::graph_traits&lt;CFG&gt;:: edge_descriptor <a class="code" href="structEdge.html">Edge</a>;
<a name="l00086"></a>00086 
<a name="l00087"></a>00087    <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#112773609abc35a0bb7750e67d5752a7">constructPathAnalyzer</a>(CFG* g, <span class="keywordtype">bool</span> unbounded=<span class="keyword">false</span>, <a class="code" href="structVertex.html">Vertex</a> end=0, <a class="code" href="structVertex.html">Vertex</a> begin=0, <span class="keywordtype">bool</span> ns = <span class="keyword">true</span>);
<a name="l00088"></a>00088    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#eb1854d2cdcd248f7c97d6e20fed6189">analyzePath</a>(std::vector&lt;Vertex&gt;&amp; pth) = 0;
<a name="l00089"></a>00089     std::vector&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#99a605cac4164b6a2e5771eb33d25b67">getInEdges</a>(<span class="keywordtype">int</span>&amp; node, CFG*&amp; g);
<a name="l00090"></a>00090     std::vector&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#ed013c85aba92ce0d5d36cd0d9d16c59">getOutEdges</a>(<span class="keywordtype">int</span>&amp; node, CFG*&amp; g);
<a name="l00091"></a>00091     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#64b5039c3ff06e9271cb85eda9812a38">getTarget</a>(<span class="keywordtype">int</span>&amp; n, CFG*&amp; g);
<a name="l00092"></a>00092     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#2b14dfe2c36b4aa54d74d94a002c9e9d">getSource</a>(<span class="keywordtype">int</span>&amp; n, CFG*&amp; g);
<a name="l00093"></a><a class="code" href="classSgGraphTraversal.html#e16ba093a525ac5f0115ca264f45862f">00093</a>     std::map&lt;Vertex, int&gt; <a class="code" href="classSgGraphTraversal.html#e16ba093a525ac5f0115ca264f45862f">vertintmap</a>;
<a name="l00094"></a><a class="code" href="classSgGraphTraversal.html#e527e01de9e2d0f0cbbe3f6d76efac6c">00094</a>     std::map&lt;Edge, int&gt; <a class="code" href="classSgGraphTraversal.html#e527e01de9e2d0f0cbbe3f6d76efac6c">edgeintmap</a>;
<a name="l00095"></a><a class="code" href="classSgGraphTraversal.html#7c6baf3c51dd37886bfce049ba5393ac">00095</a>     std::map&lt;int, Vertex&gt; <a class="code" href="classSgGraphTraversal.html#7c6baf3c51dd37886bfce049ba5393ac">intvertmap</a>;
<a name="l00096"></a><a class="code" href="classSgGraphTraversal.html#e4b03b4ffca52e346bdc1d3e26f3e208">00096</a>     std::map&lt;int, Edge&gt; <a class="code" href="classSgGraphTraversal.html#e4b03b4ffca52e346bdc1d3e26f3e208">intedgemap</a>;
<a name="l00097"></a>00097    <a class="code" href="classSgGraphTraversal.html#9a20dc8d3bb63d107a81929187c72673">SgGraphTraversal</a>();
<a name="l00098"></a>00098     <span class="keyword">virtual</span> <a class="code" href="classSgGraphTraversal.html#88455ca855d3460510a2d6cfe9cb0b38">~SgGraphTraversal</a>();
<a name="l00099"></a>00099    <a class="code" href="classSgGraphTraversal.html#9a20dc8d3bb63d107a81929187c72673">SgGraphTraversal</a>( <a class="code" href="classSgGraphTraversal.html">SgGraphTraversal</a> &amp;);
<a name="l00100"></a>00100     <a class="code" href="classSgGraphTraversal.html">SgGraphTraversal</a> &amp;<a class="code" href="classSgGraphTraversal.html#ce09153911748bbffc76ad287130d4c0">operator=</a>( <a class="code" href="classSgGraphTraversal.html">SgGraphTraversal</a> &amp;);
<a name="l00101"></a><a class="code" href="classSgGraphTraversal.html#b88ac29234d7d1182af47cd9ee944179">00101</a>    <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#b88ac29234d7d1182af47cd9ee944179">pathnum</a>;
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 
<a name="l00104"></a>00104   <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#eaf76aff61b8693bd3ac560ce73b3d37">firstPrepGraph</a>(CFG*&amp; g);
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 <span class="keyword">private</span>:
<a name="l00107"></a>00107 
<a name="l00108"></a><a class="code" href="classSgGraphTraversal.html#98eb28f60bd7704ec98fcb87e965f4f8">00108</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#98eb28f60bd7704ec98fcb87e965f4f8">normals</a>;
<a name="l00109"></a><a class="code" href="classSgGraphTraversal.html#7cfd1e1490e04cc3838170e3d6b024da">00109</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#7cfd1e1490e04cc3838170e3d6b024da">abnormals</a>;
<a name="l00110"></a><a class="code" href="classSgGraphTraversal.html#fe960262f472d138cff29730d5bc4b2f">00110</a>     <span class="keywordtype">bool</span> <a class="code" href="classSgGraphTraversal.html#fe960262f472d138cff29730d5bc4b2f">needssafety</a>;
<a name="l00111"></a><a class="code" href="classSgGraphTraversal.html#6deeda82e116e7078858091bd6a293a8">00111</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#6deeda82e116e7078858091bd6a293a8">recursed</a>;
<a name="l00112"></a><a class="code" href="classSgGraphTraversal.html#a306f50f82208052c5530cacd844a0c1">00112</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#a306f50f82208052c5530cacd844a0c1">checkedfound</a>;
<a name="l00113"></a>00113  <span class="comment">//   typedef typename boost::graph_traits&lt;CFG&gt;::vertex_descriptor Vertex;</span>
<a name="l00114"></a>00114  <span class="comment">//   typedef typename boost::graph_traits&lt;CFG&gt;:: edge_descriptor Edge;</span>
<a name="l00115"></a>00115    <span class="comment">// std::vector&lt;int&gt; getInEdges(int&amp; node, CFG*&amp; g);</span>
<a name="l00116"></a>00116    <span class="comment">// std::vector&lt;int&gt; getOutEdges(int&amp; node, CFG*&amp; g);</span>
<a name="l00117"></a>00117     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#ea1d243b1bc88eeac8cb335f4d6b9689">prepareGraph</a>(CFG*&amp; g);
<a name="l00118"></a>00118     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#4a8b9778176b8ab06a4ef59f9c0c5b1f">findClosuresAndMarkersAndEnumerate</a>(CFG*&amp; g);
<a name="l00119"></a>00119   <span class="comment">//  void constructPathAnalyzer(CFG* g, bool unbounded=false, Vertex end=0, Vertex begin=0, bool ns = true);</span>
<a name="l00120"></a>00120   <span class="comment">//  virtual void analyzePath(std::vector&lt;Vertex&gt;&amp; pth) = 0;</span>
<a name="l00121"></a>00121   <span class="comment">//  void firstPrepGraph(CFG*&amp; g);</span>
<a name="l00122"></a><a class="code" href="classSgGraphTraversal.html#5b4e5f4cde674c9003f194cc7de4a06b">00122</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#5b4e5f4cde674c9003f194cc7de4a06b">stoppedpaths</a>;
<a name="l00123"></a>00123     std::set&lt;std::vector&lt;int&gt; &gt;  <a class="code" href="classSgGraphTraversal.html#4ca22e7f9aeb40fbdfe1ed3a83294e19">traversePath</a>(<span class="keywordtype">int</span> begin, <span class="keywordtype">int</span> end, CFG*&amp; g, <span class="keywordtype">bool</span> loop=<span class="keyword">false</span>);
<a name="l00124"></a>00124     std::set&lt;std::vector&lt;int&gt; &gt; <a class="code" href="classSgGraphTraversal.html#10a010a60dff2ded6d6f8bb162161b62">uTraversePath</a>(<span class="keywordtype">int</span> begin, <span class="keywordtype">int</span> end, CFG*&amp; g, <span class="keywordtype">bool</span> loop, std::map&lt;<span class="keywordtype">int</span>, std::vector&lt;std::vector&lt;int&gt; &gt; &gt;&amp; localLoops);
<a name="l00125"></a>00125     std::vector&lt;std::vector&lt;int&gt; &gt; <a class="code" href="classSgGraphTraversal.html#ee7385288f2db18bfe67344be346b6b2">bfsTraversePath</a>(<span class="keywordtype">int</span> begin, <span class="keywordtype">int</span> end, CFG*&amp; g, <span class="keywordtype">bool</span> loop=<span class="keyword">false</span>);
<a name="l00126"></a>00126     std::vector&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#0cfbb730aba7b9dfa3380cf8ade9f33d">unzipPath</a>(std::vector&lt;int&gt;&amp;  path, CFG*&amp; g, <span class="keywordtype">int</span> start, <span class="keywordtype">int</span> end);
<a name="l00127"></a>00127     std::vector&lt;int&gt;  <a class="code" href="classSgGraphTraversal.html#95e82f5b64fdcce950c819c1288932b8">zipPath</a>(std::vector&lt;int&gt;&amp; path, CFG*&amp; g, <span class="keywordtype">int</span> start, <span class="keywordtype">int</span> end);
<a name="l00128"></a>00128     std::vector&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#b6f1f8e1fb71bb70df9614d861532cab">zipPath2</a>(std::vector&lt;int&gt;&amp; path, CFG*&amp; g);
<a name="l00129"></a>00129     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#19c5bdaa2f8e4977c399fe1413b67125">printCFGNode</a>(<span class="keywordtype">int</span>&amp; cf, std::ofstream&amp; o);
<a name="l00130"></a>00130     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#feb32651e9e1b075f9d4733718a4789c">printCFGNodeGeneric</a>(<span class="keywordtype">int</span>&amp; cf, std::string prop, std::ofstream&amp; o);
<a name="l00131"></a>00131     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#85a43852b4db1511b03cb2059c8e227b">printCFGEdge</a>(<span class="keywordtype">int</span>&amp; cf, CFG*&amp; <a class="code" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>, std::ofstream&amp; o);
<a name="l00132"></a>00132     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#e979a970b3c79dccda01d11dc4fedecb">printHotness</a>(CFG*&amp; g);
<a name="l00133"></a>00133     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#4f9ec385bcc62d3fef641227080a5def">printPathDot</a>(CFG*&amp; g);
<a name="l00134"></a>00134     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#d812e5f8186bd7b5fa0c48700cebf731">computeOrder</a>(CFG*&amp; g, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; begin);
<a name="l00135"></a>00135     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#a04c72d1150e7e97fee958372e7f0f8c">computeSubGraphs</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; begin, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;end, CFG*&amp; g, <span class="keywordtype">int</span> depthDifferential);
<a name="l00136"></a>00136     <span class="comment">//int getTarget(int&amp; n, CFG*&amp; g);</span>
<a name="l00137"></a>00137     <span class="comment">//int getSource(int&amp; n, CFG*&amp; g);</span>
<a name="l00138"></a><a class="code" href="classSgGraphTraversal.html#cc9903979165779af1e22748d916cc26">00138</a>     std::vector&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#cc9903979165779af1e22748d916cc26">sources</a>;
<a name="l00139"></a><a class="code" href="classSgGraphTraversal.html#8a63b0bc59be3a6111435b10a81c0987">00139</a>     std::vector&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#8a63b0bc59be3a6111435b10a81c0987">sinks</a>;
<a name="l00140"></a><a class="code" href="classSgGraphTraversal.html#50a077905c3afd49ff6071a9b70293c4">00140</a>     std::vector&lt;int&gt;  <a class="code" href="classSgGraphTraversal.html#50a077905c3afd49ff6071a9b70293c4">recursiveLoops</a>;
<a name="l00141"></a><a class="code" href="classSgGraphTraversal.html#2a0dfe20f21e79fbfa92f4da19fe25fc">00141</a>     std::vector&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#2a0dfe20f21e79fbfa92f4da19fe25fc">recurses</a>;
<a name="l00142"></a><a class="code" href="classSgGraphTraversal.html#fe3f39bf70faca2d573f83413c0b3e33">00142</a>     std::map&lt;int, int&gt; <a class="code" href="classSgGraphTraversal.html#fe3f39bf70faca2d573f83413c0b3e33">ptsNum</a>;
<a name="l00143"></a><a class="code" href="classSgGraphTraversal.html#e095c9073a41b2774a96ed1b2adfe660">00143</a>     <span class="keywordtype">bool</span> <a class="code" href="classSgGraphTraversal.html#e095c9073a41b2774a96ed1b2adfe660">borrowed</a>;
<a name="l00144"></a><a class="code" href="classSgGraphTraversal.html#1a382b6f284a1aa976748a0bf3528f87">00144</a>     std::set&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#1a382b6f284a1aa976748a0bf3528f87">badloop</a>;
<a name="l00145"></a><a class="code" href="classSgGraphTraversal.html#6081c11fead88b4ea5c12c2e05e23ca1">00145</a>     std::map&lt;int, std::vector&lt;std::vector&lt;int&gt; &gt; &gt;  <a class="code" href="classSgGraphTraversal.html#6081c11fead88b4ea5c12c2e05e23ca1">totalLoops</a>;
<a name="l00146"></a>00146 <span class="comment">//    int pathnum;</span>
<a name="l00147"></a><a class="code" href="classSgGraphTraversal.html#684135a0b75af543d171fc0eb6411836">00147</a>     std::map&lt;int, std::string&gt; <a class="code" href="classSgGraphTraversal.html#684135a0b75af543d171fc0eb6411836">nodeStrings</a>;
<a name="l00148"></a><a class="code" href="classSgGraphTraversal.html#1a5577095b410bc1259365a92dce8014">00148</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#1a5577095b410bc1259365a92dce8014">sourcenum</a>;
<a name="l00149"></a><a class="code" href="classSgGraphTraversal.html#60b42955fb99a8791a31fc4daa2154f9">00149</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <a class="code" href="classSgGraphTraversal.html#60b42955fb99a8791a31fc4daa2154f9">evaledpaths</a>;
<a name="l00150"></a><a class="code" href="classSgGraphTraversal.html#1e46cf0d71a76af81a0c5cf9feb90ee3">00150</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#1e46cf0d71a76af81a0c5cf9feb90ee3">badpaths</a>;
<a name="l00151"></a><a class="code" href="classSgGraphTraversal.html#649fa4517fcb6ba196450aebb42c2ecf">00151</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#649fa4517fcb6ba196450aebb42c2ecf">workingthreadnum</a>;
<a name="l00152"></a><a class="code" href="classSgGraphTraversal.html#db422e324b7c6338b2b192f462b3a03d">00152</a>     <span class="keywordtype">bool</span> <a class="code" href="classSgGraphTraversal.html#db422e324b7c6338b2b192f462b3a03d">workingthread</a>;
<a name="l00153"></a><a class="code" href="classSgGraphTraversal.html#da70ffb6e85bcaa38628b02ed311231b">00153</a>     std::map&lt;int, std::set&lt;std::vector&lt;int&gt; &gt; &gt; <a class="code" href="classSgGraphTraversal.html#da70ffb6e85bcaa38628b02ed311231b">loopStore</a>;
<a name="l00154"></a><a class="code" href="classSgGraphTraversal.html#3f09e1ff9eca21d25a500e08efbe965a">00154</a>     std::vector&lt;std::vector&lt;int&gt; &gt;  <a class="code" href="classSgGraphTraversal.html#3f09e1ff9eca21d25a500e08efbe965a">pathStore</a>;
<a name="l00155"></a><a class="code" href="classSgGraphTraversal.html#570d7dcbae9073042075ea75c8cf87fd">00155</a>     std::map&lt;int, std::vector&lt;int&gt; &gt; <a class="code" href="classSgGraphTraversal.html#570d7dcbae9073042075ea75c8cf87fd">subpathglobal</a>;
<a name="l00156"></a><a class="code" href="classSgGraphTraversal.html#4815b14f7d3ceaed702a61d463b74014">00156</a>     std::map&lt;std::vector&lt;int&gt;, <span class="keywordtype">int</span>&gt; <a class="code" href="classSgGraphTraversal.html#4815b14f7d3ceaed702a61d463b74014">subpathglobalinv</a>;
<a name="l00157"></a><a class="code" href="classSgGraphTraversal.html#d3cc71c92e55b4b899a9a9d29995f5d5">00157</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#d3cc71c92e55b4b899a9a9d29995f5d5">nextsubpath</a>;
<a name="l00158"></a><a class="code" href="classSgGraphTraversal.html#e782a21b91602c4ec407bcacd88b6b86">00158</a>     std::vector&lt;int&gt;  <a class="code" href="classSgGraphTraversal.html#e782a21b91602c4ec407bcacd88b6b86">orderOfNodes</a>;
<a name="l00159"></a>00159 <span class="comment">//    std::map&lt;Vertex, int&gt; vertintmap;</span>
<a name="l00160"></a>00160 <span class="comment">//    std::map&lt;Edge, int&gt; edgeintmap;</span>
<a name="l00161"></a>00161 <span class="comment">//    std::map&lt;int, Vertex&gt; intvertmap;</span>
<a name="l00162"></a>00162 <span class="comment">//    std::map&lt;int, Edge&gt; intedgemap;</span>
<a name="l00163"></a><a class="code" href="classSgGraphTraversal.html#c12040d0ae76b2c21867d1b55ab2aa12">00163</a>     std::vector&lt;std::map&lt;Vertex, Vertex&gt; &gt; <a class="code" href="classSgGraphTraversal.html#c12040d0ae76b2c21867d1b55ab2aa12">SubGraphGraphMap</a>;
<a name="l00164"></a><a class="code" href="classSgGraphTraversal.html#d67dcbcbbabd3dcf98e16a9465206c1e">00164</a>     std::vector&lt;std::map&lt;Vertex, Vertex&gt; &gt; <a class="code" href="classSgGraphTraversal.html#d67dcbcbbabd3dcf98e16a9465206c1e">GraphSubGraphMap</a>;
<a name="l00165"></a><a class="code" href="classSgGraphTraversal.html#086551ed5b2c0b2494b917941c09665b">00165</a>     std::vector&lt;CFG*&gt; <a class="code" href="classSgGraphTraversal.html#086551ed5b2c0b2494b917941c09665b">subGraphVector</a>;
<a name="l00166"></a>00166     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#5cb8364064494352aaefc69b9183ff4c">getVertexPath</a>(std::vector&lt;int&gt; path, CFG*&amp; g, std::vector&lt;Vertex&gt;&amp; vertexPath );
<a name="l00167"></a>00167     <span class="keywordtype">void</span> <a class="code" href="classSgGraphTraversal.html#28359e18a99e834e73adbe56634379d2">storeCompact</a>(std::vector&lt;int&gt; path);
<a name="l00168"></a><a class="code" href="classSgGraphTraversal.html#c464c8f699bc1c05c815e7857fb0c459">00168</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#c464c8f699bc1c05c815e7857fb0c459">nextNode</a>;
<a name="l00169"></a><a class="code" href="classSgGraphTraversal.html#4ffd1286e256682144d62e61fefc9c0f">00169</a>     <span class="keywordtype">int</span> <a class="code" href="classSgGraphTraversal.html#4ffd1286e256682144d62e61fefc9c0f">nextEdge</a>;
<a name="l00170"></a><a class="code" href="classSgGraphTraversal.html#25558621655ec18a69d8a5df2fea1534">00170</a>     std::vector&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#25558621655ec18a69d8a5df2fea1534">markers</a>;
<a name="l00171"></a><a class="code" href="classSgGraphTraversal.html#4c7e951115097e892e120a967d221fc3">00171</a>     std::vector&lt;int&gt; <a class="code" href="classSgGraphTraversal.html#4c7e951115097e892e120a967d221fc3">closures</a>;
<a name="l00172"></a><a class="code" href="classSgGraphTraversal.html#908f7e3456e9e6512f6efe3511744df6">00172</a>     std::map&lt;int, int&gt; <a class="code" href="classSgGraphTraversal.html#908f7e3456e9e6512f6efe3511744df6">markerIndex</a>;
<a name="l00173"></a><a class="code" href="classSgGraphTraversal.html#152b4fd59b0c3878812646aab1dbf335">00173</a>     std::map&lt;int, std::vector&lt;int&gt; &gt; <a class="code" href="classSgGraphTraversal.html#152b4fd59b0c3878812646aab1dbf335">pathsAtMarkers</a>;
<a name="l00174"></a><a class="code" href="classSgGraphTraversal.html#bd1764411718e5932af95a3274da42cb">00174</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="yicesParserLib_8h.html#01a59c9f4634ace001a235e23a2bc31d">boost::graph_traits&lt;CFG&gt;::vertex_iterator</a> <a class="code" href="classSgGraphTraversal.html#bd1764411718e5932af95a3274da42cb">vertex_iterator</a>;
<a name="l00175"></a><a class="code" href="classSgGraphTraversal.html#5010ce088d47b9d617c858339cedd7ab">00175</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="yicesParserLib_8h.html#e39522b66bd1fadf51820604a43801b0">boost::graph_traits&lt;CFG&gt;::out_edge_iterator</a> <a class="code" href="classSgGraphTraversal.html#5010ce088d47b9d617c858339cedd7ab">out_edge_iterator</a>;
<a name="l00176"></a><a class="code" href="classSgGraphTraversal.html#36f5bc1424f61ded3644b611e8cf3f7d">00176</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="yicesParserLib_8h.html#bea97cfa64faa5d3febde696c16eed04">boost::graph_traits&lt;CFG&gt;::in_edge_iterator</a> <a class="code" href="classSgGraphTraversal.html#36f5bc1424f61ded3644b611e8cf3f7d">in_edge_iterator</a>;
<a name="l00177"></a><a class="code" href="classSgGraphTraversal.html#4ff52d7e02676a9027590d2633b5e0a9">00177</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="yicesParserLib_8h.html#c5f273d32fb3bb35cf86b98e401fe9b6">boost::graph_traits&lt;CFG&gt;::edge_iterator</a> <a class="code" href="classSgGraphTraversal.html#4ff52d7e02676a9027590d2633b5e0a9">edge_iterator</a>;
<a name="l00178"></a><a class="code" href="classSgGraphTraversal.html#867cd3ba00953f545867bcb4ef1f4dd7">00178</a>     <span class="keywordtype">bool</span> <a class="code" href="classSgGraphTraversal.html#867cd3ba00953f545867bcb4ef1f4dd7">bound</a>;
<a name="l00179"></a>00179 <span class="comment">//    SgGraphTraversal();</span>
<a name="l00180"></a>00180 <span class="comment">//    virtual ~SgGraphTraversal();</span>
<a name="l00181"></a>00181 <span class="comment">//   SgGraphTraversal( SgGraphTraversal &amp;);</span>
<a name="l00182"></a>00182 <span class="comment">//    SgGraphTraversal &amp;operator=( SgGraphTraversal &amp;);</span>
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 
<a name="l00185"></a>00185 };
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l00189"></a>00189 <a class="code" href="classSgGraphTraversal.html#9a20dc8d3bb63d107a81929187c72673">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l00190"></a><a class="code" href="classSgGraphTraversal.html#9a20dc8d3bb63d107a81929187c72673">00190</a> <a class="code" href="classSgGraphTraversal.html#9a20dc8d3bb63d107a81929187c72673">SgGraphTraversal</a>()
<a name="l00191"></a>00191 {
<a name="l00192"></a>00192 }
<a name="l00193"></a>00193 
<a name="l00194"></a>00194 
<a name="l00195"></a>00195 
<a name="l00196"></a>00196 <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l00197"></a>00197 <a class="code" href="classSgGraphTraversal.html">SgGraphTraversal&lt;CFG&gt;</a> &amp;
<a name="l00198"></a>00198 <a class="code" href="classSgGraphTraversal.html#ce09153911748bbffc76ad287130d4c0">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l00199"></a><a class="code" href="classSgGraphTraversal.html#ce09153911748bbffc76ad287130d4c0">00199</a> <a class="code" href="classSgGraphTraversal.html#ce09153911748bbffc76ad287130d4c0">operator=</a>( <a class="code" href="classSgGraphTraversal.html">SgGraphTraversal</a> &amp;other)
<a name="l00200"></a>00200 {
<a name="l00201"></a>00201     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00202"></a>00202 }
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 <span class="preprocessor">#ifndef SWIG</span>
<a name="l00205"></a>00205 <span class="preprocessor"></span>
<a name="l00206"></a>00206 <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l00207"></a>00207 <a class="code" href="classSgGraphTraversal.html#88455ca855d3460510a2d6cfe9cb0b38">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l00208"></a><a class="code" href="classSgGraphTraversal.html#88455ca855d3460510a2d6cfe9cb0b38">00208</a> <a class="code" href="classSgGraphTraversal.html#88455ca855d3460510a2d6cfe9cb0b38">~SgGraphTraversal</a>()
<a name="l00209"></a>00209 {
<a name="l00210"></a>00210 }
<a name="l00211"></a>00211 
<a name="l00212"></a>00212 <span class="preprocessor">#endif</span>
<a name="l00213"></a>00213 <span class="preprocessor"></span>
<a name="l00221"></a>00221 <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l00222"></a>00222 <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l00223"></a>00223 <a class="code" href="classSgGraphTraversal.html#2b14dfe2c36b4aa54d74d94a002c9e9d">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l00224"></a><a class="code" href="classSgGraphTraversal.html#2b14dfe2c36b4aa54d74d94a002c9e9d">00224</a> <a class="code" href="classSgGraphTraversal.html#2b14dfe2c36b4aa54d74d94a002c9e9d">getSource</a>(<span class="keywordtype">int</span>&amp; edge, CFG*&amp; g)
<a name="l00225"></a>00225 {
<a name="l00226"></a>00226     <a class="code" href="structEdge.html">Edge</a> e = <a class="code" href="classSgGraphTraversal.html#e4b03b4ffca52e346bdc1d3e26f3e208">intedgemap</a>[edge];
<a name="l00227"></a>00227     <a class="code" href="structVertex.html">Vertex</a> v = boost::source(e, *g);
<a name="l00228"></a>00228     <span class="keywordflow">return</span>(<a class="code" href="classSgGraphTraversal.html#e16ba093a525ac5f0115ca264f45862f">vertintmap</a>[v]);
<a name="l00229"></a>00229 }
<a name="l00230"></a>00230 
<a name="l00240"></a>00240 <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l00241"></a>00241 <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l00242"></a>00242 <a class="code" href="classSgGraphTraversal.html#64b5039c3ff06e9271cb85eda9812a38">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l00243"></a><a class="code" href="classSgGraphTraversal.html#64b5039c3ff06e9271cb85eda9812a38">00243</a> <a class="code" href="classSgGraphTraversal.html#64b5039c3ff06e9271cb85eda9812a38">getTarget</a>(<span class="keywordtype">int</span>&amp; edge, CFG*&amp; g)
<a name="l00244"></a>00244 {
<a name="l00245"></a>00245     <a class="code" href="structEdge.html">Edge</a> e = <a class="code" href="classSgGraphTraversal.html#e4b03b4ffca52e346bdc1d3e26f3e208">intedgemap</a>[edge];
<a name="l00246"></a>00246     <a class="code" href="structVertex.html">Vertex</a> v = boost::target(e, *g);
<a name="l00247"></a>00247     <span class="keywordflow">return</span>(<a class="code" href="classSgGraphTraversal.html#e16ba093a525ac5f0115ca264f45862f">vertintmap</a>[v]);
<a name="l00248"></a>00248 }
<a name="l00249"></a>00249 
<a name="l00258"></a>00258 <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l00259"></a>00259 std::vector&lt;int&gt;
<a name="l00260"></a>00260 <a class="code" href="classSgGraphTraversal.html#99a605cac4164b6a2e5771eb33d25b67">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l00261"></a><a class="code" href="classSgGraphTraversal.html#99a605cac4164b6a2e5771eb33d25b67">00261</a> <a class="code" href="classSgGraphTraversal.html#99a605cac4164b6a2e5771eb33d25b67">getInEdges</a>(<span class="keywordtype">int</span>&amp; node, CFG*&amp; g)
<a name="l00262"></a>00262 {
<a name="l00263"></a>00263     <a class="code" href="structVertex.html">Vertex</a> getIns = <a class="code" href="classSgGraphTraversal.html#7c6baf3c51dd37886bfce049ba5393ac">intvertmap</a>[node];
<a name="l00264"></a>00264     std::vector&lt;int&gt; inedges;
<a name="l00265"></a>00265     <a class="code" href="classSgGraphTraversal.html#36f5bc1424f61ded3644b611e8cf3f7d">in_edge_iterator</a> i, j;
<a name="l00266"></a>00266     <span class="keywordflow">for</span> (boost::tie(i, j) = boost::in_edges(getIns, *g); i != j; ++i)
<a name="l00267"></a>00267     {
<a name="l00268"></a>00268         inedges.push_back(<a class="code" href="classSgGraphTraversal.html#e527e01de9e2d0f0cbbe3f6d76efac6c">edgeintmap</a>[*i]);
<a name="l00269"></a>00269     }
<a name="l00270"></a>00270     <span class="keywordflow">return</span> inedges;
<a name="l00271"></a>00271 }
<a name="l00272"></a>00272 
<a name="l00283"></a>00283 <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l00284"></a>00284 std::vector&lt;int&gt;
<a name="l00285"></a>00285 <a class="code" href="classSgGraphTraversal.html#ed013c85aba92ce0d5d36cd0d9d16c59">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l00286"></a><a class="code" href="classSgGraphTraversal.html#ed013c85aba92ce0d5d36cd0d9d16c59">00286</a> <a class="code" href="classSgGraphTraversal.html#ed013c85aba92ce0d5d36cd0d9d16c59">getOutEdges</a>(<span class="keywordtype">int</span> &amp;node, CFG*&amp; g)
<a name="l00287"></a>00287 {
<a name="l00288"></a>00288     <a class="code" href="structVertex.html">Vertex</a> getOuts = <a class="code" href="classSgGraphTraversal.html#7c6baf3c51dd37886bfce049ba5393ac">intvertmap</a>[node];
<a name="l00289"></a>00289     std::vector&lt;int&gt; outedges;
<a name="l00290"></a>00290     <a class="code" href="classSgGraphTraversal.html#5010ce088d47b9d617c858339cedd7ab">out_edge_iterator</a> i, j;
<a name="l00291"></a>00291     <span class="keywordflow">for</span> (boost::tie(i, j) = boost::out_edges(getOuts, *g); i != j; ++i)
<a name="l00292"></a>00292     {
<a name="l00293"></a>00293         outedges.push_back(<a class="code" href="classSgGraphTraversal.html#e527e01de9e2d0f0cbbe3f6d76efac6c">edgeintmap</a>[*i]);
<a name="l00294"></a>00294     }
<a name="l00295"></a>00295     <span class="keywordflow">return</span> outedges;
<a name="l00296"></a>00296 }
<a name="l00297"></a>00297 
<a name="l00307"></a>00307 <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l00308"></a>00308 <span class="keyword">inline</span>
<a name="l00309"></a>00309 std::vector&lt;int&gt;
<a name="l00310"></a>00310 <a class="code" href="classSgGraphTraversal.html#b6f1f8e1fb71bb70df9614d861532cab">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l00311"></a><a class="code" href="classSgGraphTraversal.html#b6f1f8e1fb71bb70df9614d861532cab">00311</a> <a class="code" href="classSgGraphTraversal.html#b6f1f8e1fb71bb70df9614d861532cab">zipPath2</a>(std::vector&lt;int&gt;&amp; pth, CFG*&amp; g) {
<a name="l00312"></a>00312     std::vector&lt;int&gt; npth;
<a name="l00313"></a>00313     npth.push_back(pth[0]);
<a name="l00314"></a>00314     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; pth.size()-1; i++) {
<a name="l00315"></a>00315        <span class="keywordflow">if</span> (<a class="code" href="namespaceSageInterface.html#ff5394b21cf11cd338671af3a11a7f92">find</a>(<a class="code" href="classSgGraphTraversal.html#4c7e951115097e892e120a967d221fc3">closures</a>.begin(), <a class="code" href="classSgGraphTraversal.html#4c7e951115097e892e120a967d221fc3">closures</a>.end(), pth[i]) != <a class="code" href="classSgGraphTraversal.html#4c7e951115097e892e120a967d221fc3">closures</a>.end()) {
<a name="l00316"></a>00316            npth.push_back(pth[i]);
<a name="l00317"></a>00317        }
<a name="l00318"></a>00318     }
<a name="l00319"></a>00319     npth.push_back(pth.back());
<a name="l00320"></a>00320     <span class="keywordflow">return</span> npth;
<a name="l00321"></a>00321 }
<a name="l00322"></a>00322 
<a name="l00334"></a>00334 <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l00335"></a>00335 std::vector&lt;int&gt;
<a name="l00336"></a>00336 <a class="code" href="classSgGraphTraversal.html#95e82f5b64fdcce950c819c1288932b8">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l00337"></a><a class="code" href="classSgGraphTraversal.html#95e82f5b64fdcce950c819c1288932b8">00337</a> <a class="code" href="classSgGraphTraversal.html#95e82f5b64fdcce950c819c1288932b8">zipPath</a>(std::vector&lt;int&gt;&amp; pth, CFG*&amp; g, <span class="keywordtype">int</span> start, <span class="keywordtype">int</span> end) {
<a name="l00338"></a>00338                         std::vector&lt;int&gt; subpath;
<a name="l00339"></a>00339                         std::vector&lt;int&gt; movepath;
<a name="l00340"></a>00340                         movepath.push_back(pth.front());
<a name="l00341"></a>00341                         movepath.push_back(pth.back());
<a name="l00342"></a>00342                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> qw = 0; qw &lt; pth.size()-1; qw++) {
<a name="l00343"></a>00343                            <span class="keywordflow">if</span> (<a class="code" href="namespaceSageInterface.html#ff5394b21cf11cd338671af3a11a7f92">find</a>(<a class="code" href="classSgGraphTraversal.html#25558621655ec18a69d8a5df2fea1534">markers</a>.begin(), <a class="code" href="classSgGraphTraversal.html#25558621655ec18a69d8a5df2fea1534">markers</a>.end(), pth[qw]) != <a class="code" href="classSgGraphTraversal.html#25558621655ec18a69d8a5df2fea1534">markers</a>.end()) {
<a name="l00344"></a>00344                                std::vector&lt;int&gt; oeds = <a class="code" href="classSgGraphTraversal.html#ed013c85aba92ce0d5d36cd0d9d16c59">getOutEdges</a>(pth[qw], g);
<a name="l00345"></a>00345                                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; oeds.size(); i++) {
<a name="l00346"></a>00346                                    <span class="keywordflow">if</span> (<a class="code" href="classSgGraphTraversal.html#64b5039c3ff06e9271cb85eda9812a38">getTarget</a>(oeds[i], g) == pth[qw+1]) {
<a name="l00347"></a>00347                                        movepath.push_back(oeds[i]);
<a name="l00348"></a>00348                                    }
<a name="l00349"></a>00349                                }
<a name="l00350"></a>00350                             }
<a name="l00351"></a>00351                          }
<a name="l00352"></a>00352                          <span class="keywordflow">return</span> movepath;
<a name="l00353"></a>00353              }
<a name="l00354"></a>00354 
<a name="l00355"></a>00355 
<a name="l00356"></a>00356 
<a name="l00357"></a>00357 
<a name="l00358"></a>00358 
<a name="l00359"></a>00359 
<a name="l00370"></a>00370 <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l00371"></a>00371 std::vector&lt;int&gt;
<a name="l00372"></a>00372 <a class="code" href="classSgGraphTraversal.html#0cfbb730aba7b9dfa3380cf8ade9f33d">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l00373"></a><a class="code" href="classSgGraphTraversal.html#0cfbb730aba7b9dfa3380cf8ade9f33d">00373</a> <a class="code" href="classSgGraphTraversal.html#0cfbb730aba7b9dfa3380cf8ade9f33d">unzipPath</a>(std::vector&lt;int&gt;&amp; pzipped, CFG*&amp; g, <span class="keywordtype">int</span> start, <span class="keywordtype">int</span> end) {
<a name="l00374"></a>00374      ROSE_ASSERT(pzipped[0] == start &amp;&amp; (pzipped[1] == end || end == -1));
<a name="l00375"></a>00375      std::vector&lt;int&gt; zipped;
<a name="l00376"></a>00376      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 2; i &lt; pzipped.size(); i++) {
<a name="l00377"></a>00377          zipped.push_back(pzipped[i]);
<a name="l00378"></a>00378      }
<a name="l00379"></a>00379      std::vector&lt;int&gt; unzipped;
<a name="l00380"></a>00380      unzipped.push_back(start);
<a name="l00381"></a>00381      std::vector&lt;int&gt; oeds = <a class="code" href="classSgGraphTraversal.html#ed013c85aba92ce0d5d36cd0d9d16c59">getOutEdges</a>(start, g);
<a name="l00382"></a>00382      <span class="keywordflow">if</span> (oeds.size() == 0) {
<a name="l00383"></a>00383          <span class="keywordflow">return</span> unzipped;
<a name="l00384"></a>00384      }
<a name="l00385"></a>00385      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; zipped.size(); i++) {
<a name="l00386"></a>00386          oeds = <a class="code" href="classSgGraphTraversal.html#ed013c85aba92ce0d5d36cd0d9d16c59">getOutEdges</a>(unzipped.back(), g);
<a name="l00387"></a>00387          <span class="keywordflow">while</span> (oeds.size() == 1) {
<a name="l00388"></a>00388              <span class="keywordflow">if</span> (<a class="code" href="classSgGraphTraversal.html#64b5039c3ff06e9271cb85eda9812a38">getTarget</a>(oeds[0], g) == end &amp;&amp; unzipped.size() != 1) {
<a name="l00389"></a>00389                   unzipped.push_back(end);
<a name="l00390"></a>00390                   <span class="keywordflow">return</span> unzipped;
<a name="l00391"></a>00391              }
<a name="l00392"></a>00392              unzipped.push_back(<a class="code" href="classSgGraphTraversal.html#64b5039c3ff06e9271cb85eda9812a38">getTarget</a>(oeds[0], g));
<a name="l00393"></a>00393              oeds = <a class="code" href="classSgGraphTraversal.html#ed013c85aba92ce0d5d36cd0d9d16c59">getOutEdges</a>(unzipped.back(), g);
<a name="l00394"></a>00394          }
<a name="l00395"></a>00395          <span class="keywordflow">if</span> (oeds.size() == 0) {
<a name="l00396"></a>00396              <span class="keywordflow">return</span> unzipped;
<a name="l00397"></a>00397          }
<a name="l00398"></a>00398          <span class="keywordflow">if</span> (oeds.size() &gt; 1 &amp;&amp; (unzipped.back() != end || (unzipped.size() == 1 &amp;&amp; unzipped.back() == end))) {
<a name="l00399"></a>00399              ROSE_ASSERT(<a class="code" href="classSgGraphTraversal.html#2b14dfe2c36b4aa54d74d94a002c9e9d">getSource</a>(zipped[i], g) == unzipped.back());
<a name="l00400"></a>00400              unzipped.push_back(<a class="code" href="classSgGraphTraversal.html#64b5039c3ff06e9271cb85eda9812a38">getTarget</a>(zipped[i], g));
<a name="l00401"></a>00401          }
<a name="l00402"></a>00402          
<a name="l00403"></a>00403      }
<a name="l00404"></a>00404      std::vector&lt;int&gt; oeds2 = <a class="code" href="classSgGraphTraversal.html#ed013c85aba92ce0d5d36cd0d9d16c59">getOutEdges</a>(unzipped.back(), g);
<a name="l00405"></a>00405      <span class="keywordflow">if</span> (unzipped.back() != end &amp;&amp; oeds2.size() != 0) { 
<a name="l00406"></a>00406          <span class="keywordflow">while</span> (oeds2.size() == 1 &amp;&amp; unzipped.back() != end) {
<a name="l00407"></a>00407              unzipped.push_back(<a class="code" href="classSgGraphTraversal.html#64b5039c3ff06e9271cb85eda9812a38">getTarget</a>(oeds2[0], g));
<a name="l00408"></a>00408              oeds2 = <a class="code" href="classSgGraphTraversal.html#ed013c85aba92ce0d5d36cd0d9d16c59">getOutEdges</a>(unzipped.back(), g);
<a name="l00409"></a>00409          }
<a name="l00410"></a>00410      }
<a name="l00411"></a>00411      <span class="keywordflow">return</span> unzipped;
<a name="l00412"></a>00412 }
<a name="l00413"></a>00413 
<a name="l00414"></a>00414 <span class="comment">/*</span>
<a name="l00415"></a>00415 <span class="comment">Example Time</span>
<a name="l00416"></a>00416 <span class="comment"></span>
<a name="l00417"></a>00417 <span class="comment">    Example:</span>
<a name="l00418"></a>00418 <span class="comment">             timeval tim;</span>
<a name="l00419"></a>00419 <span class="comment">             gettimeofday(&amp;tim, NULL);</span>
<a name="l00420"></a>00420 <span class="comment">             double t1=tim.tv_sec+(tim.tv_usec/1000000.0);</span>
<a name="l00421"></a>00421 <span class="comment">             do_something_long();</span>
<a name="l00422"></a>00422 <span class="comment">             gettimeofday(&amp;tim, NULL);</span>
<a name="l00423"></a>00423 <span class="comment">             double t2=tim.tv_sec+(tim.tv_usec/1000000.0);</span>
<a name="l00424"></a>00424 <span class="comment">             printf("%.6lf seconds elapsed\n", t2-t1);</span>
<a name="l00425"></a>00425 <span class="comment"></span>
<a name="l00426"></a>00426 <span class="comment">*/</span>
<a name="l00427"></a>00427 
<a name="l00439"></a>00439 <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l00440"></a>00440 std::vector&lt;std::vector&lt;int&gt; &gt;
<a name="l00441"></a>00441 <a class="code" href="classSgGraphTraversal.html#ee7385288f2db18bfe67344be346b6b2">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l00442"></a><a class="code" href="classSgGraphTraversal.html#ee7385288f2db18bfe67344be346b6b2">00442</a> <a class="code" href="classSgGraphTraversal.html#ee7385288f2db18bfe67344be346b6b2">bfsTraversePath</a>(<span class="keywordtype">int</span> begin, <span class="keywordtype">int</span> end, CFG*&amp; g, <span class="keywordtype">bool</span> loop) {
<a name="l00443"></a>00443 <span class="comment">//perfdebug allows for examining the speed of traversal</span>
<a name="l00444"></a>00444 <span class="preprocessor">    #ifdef PERFDEBUG</span>
<a name="l00445"></a>00445 <span class="preprocessor"></span>    timeval tim;
<a name="l00446"></a>00446     gettimeofday(&amp;tim, NULL);
<a name="l00447"></a>00447     <span class="keywordtype">double</span> tim1 = tim.tv_sec+(tim.tv_usec/1000000.0);
<a name="l00448"></a>00448 <span class="preprocessor">    #endif</span>
<a name="l00449"></a>00449 <span class="preprocessor"></span>    <span class="keywordtype">bool</span> recursedloop = loop;
<a name="l00450"></a>00450     std::map&lt;int, std::vector&lt;std::vector&lt;int&gt; &gt; &gt; PtP;
<a name="l00451"></a>00451     std::set&lt;int&gt; nodes;
<a name="l00452"></a>00452     std::vector&lt;std::vector&lt;int&gt; &gt; pathContainer;
<a name="l00453"></a>00453     <span class="comment">//std::vector&lt;std::vector&lt;int&gt; &gt; oldPaths;</span>
<a name="l00454"></a>00454     std::vector&lt;int&gt; completedLoops;
<a name="l00455"></a>00455     std::vector&lt;std::vector&lt;int&gt; &gt; npc;
<a name="l00456"></a>00456     std::vector&lt;int&gt; bgpath;
<a name="l00457"></a>00457     bgpath.push_back(begin);
<a name="l00458"></a>00458     pathContainer.push_back(bgpath);
<a name="l00459"></a>00459     std::vector&lt;std::vector&lt;int&gt; &gt; newPathContainer; 
<a name="l00460"></a>00460     std::vector&lt;std::vector&lt;int&gt; &gt; <a class="code" href="yicesParserLib_8h.html#0ab651cea734fb0eb3ed32cef06b99ec">paths</a>;
<a name="l00461"></a>00461     std::vector&lt;int&gt; localLoops;
<a name="l00462"></a>00462     std::map&lt;int, std::vector&lt;std::vector&lt;int&gt; &gt; &gt; globalLoopPaths;
<a name="l00463"></a>00463      <span class="comment">//std::cout &lt;&lt; "at the while" &lt;&lt; std::endl;</span>
<a name="l00464"></a>00464 <span class="comment">//To keep</span>
<a name="l00465"></a>00465      <span class="keywordflow">while</span> (pathContainer.size() != 0 <span class="comment">/*|| oldPaths.size() != 0*/</span>) {
<a name="l00466"></a>00466 <span class="comment">/*</span>
<a name="l00467"></a>00467 <span class="comment">       unsigned int mpc = 50000;</span>
<a name="l00468"></a>00468 <span class="comment">       if (pathContainer.size() == 0) {</span>
<a name="l00469"></a>00469 <span class="comment">           unsigned int mxl = 0; </span>
<a name="l00470"></a>00470 <span class="comment">           if (oldPaths.size() &gt; mpc) {</span>
<a name="l00471"></a>00471 <span class="comment">               mxl = mpc/2;</span>
<a name="l00472"></a>00472 <span class="comment">           }</span>
<a name="l00473"></a>00473 <span class="comment">           else {</span>
<a name="l00474"></a>00474 <span class="comment">               mxl = oldPaths.size();</span>
<a name="l00475"></a>00475 <span class="comment">           }</span>
<a name="l00476"></a>00476 <span class="comment">           for (unsigned int k = 0; k &lt; mxl; k++) {</span>
<a name="l00477"></a>00477 <span class="comment">               pathContainer.push_back(oldPaths.back());</span>
<a name="l00478"></a>00478 <span class="comment">               oldPaths.pop_back();</span>
<a name="l00479"></a>00479 <span class="comment">           }</span>
<a name="l00480"></a>00480 <span class="comment">       }</span>
<a name="l00481"></a>00481 <span class="comment">       if (pathContainer.size() &gt; mpc) {</span>
<a name="l00482"></a>00482 <span class="comment">           unsigned int j = 0;</span>
<a name="l00483"></a>00483 <span class="comment">           while (j &lt; mpc) {</span>
<a name="l00484"></a>00484 <span class="comment">                npc.push_back(pathContainer.back());</span>
<a name="l00485"></a>00485 <span class="comment">                pathContainer.pop_back();</span>
<a name="l00486"></a>00486 <span class="comment">                j++;</span>
<a name="l00487"></a>00487 <span class="comment">           }</span>
<a name="l00488"></a>00488 <span class="comment">           oldPaths.insert(oldPaths.end(), pathContainer.begin(), pathContainer.end());   </span>
<a name="l00489"></a>00489 <span class="comment">           pathContainer = npc;</span>
<a name="l00490"></a>00490 <span class="comment">           npc.clear();</span>
<a name="l00491"></a>00491 <span class="comment">       }</span>
<a name="l00492"></a>00492 <span class="comment">*/</span>
<a name="l00493"></a>00493 
<a name="l00494"></a>00494 <span class="comment">//iterating through the currently discovered subpaths to build them up</span>
<a name="l00495"></a>00495        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; pathContainer.size(); i++) {
<a name="l00496"></a>00496        std::vector&lt;int&gt; npth = pathContainer[i];
<a name="l00497"></a>00497         std::vector&lt;int&gt; oeds = <a class="code" href="classSgGraphTraversal.html#ed013c85aba92ce0d5d36cd0d9d16c59">getOutEdges</a>(npth.back(), g);
<a name="l00498"></a>00498         std::vector&lt;int&gt; ieds = <a class="code" href="classSgGraphTraversal.html#99a605cac4164b6a2e5771eb33d25b67">getInEdges</a>(npth.back(), g);
<a name="l00499"></a>00499  
<a name="l00500"></a>00500         npth = pathContainer[i];
<a name="l00501"></a>00501         oeds = <a class="code" href="classSgGraphTraversal.html#ed013c85aba92ce0d5d36cd0d9d16c59">getOutEdges</a>(npth.back(), g);
<a name="l00502"></a>00502 
<a name="l00503"></a>00503         <span class="keywordflow">if</span> ((!recursedloop &amp;&amp; ((<a class="code" href="classSgGraphTraversal.html#867cd3ba00953f545867bcb4ef1f4dd7">bound</a> &amp;&amp; npth.back() == end &amp;&amp; npth.size() != 1) || (!<a class="code" href="classSgGraphTraversal.html#867cd3ba00953f545867bcb4ef1f4dd7">bound</a> &amp;&amp; oeds.size() == 0))) || (recursedloop &amp;&amp; npth.back() == end &amp;&amp; npth.size() != 1)) {
<a name="l00504"></a>00504             std::vector&lt;int&gt; newpth;
<a name="l00505"></a>00505             newpth = (pathContainer[i]);
<a name="l00506"></a>00506              std::vector&lt;int&gt; movepath = newpth;<span class="comment">//zipPath(newpth, g);</span>
<a name="l00507"></a>00507              <span class="keywordflow">if</span> (recursedloop &amp;&amp; newpth.back() == end &amp;&amp; newpth.size() != 1) {
<a name="l00508"></a>00508              paths.push_back(movepath);
<a name="l00509"></a>00509              }
<a name="l00510"></a>00510              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!recursedloop) {
<a name="l00511"></a>00511              <span class="keywordflow">if</span> (<a class="code" href="classSgGraphTraversal.html#867cd3ba00953f545867bcb4ef1f4dd7">bound</a> &amp;&amp; newpth.size() != 1 &amp;&amp; newpth.back() == end) {
<a name="l00512"></a>00512              paths.push_back(movepath);
<a name="l00513"></a>00513              }
<a name="l00514"></a>00514              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="classSgGraphTraversal.html#867cd3ba00953f545867bcb4ef1f4dd7">bound</a>) {
<a name="l00515"></a>00515              paths.push_back(movepath);
<a name="l00516"></a>00516              }
<a name="l00517"></a>00517              }
<a name="l00518"></a>00518              
<a name="l00519"></a>00519         }
<a name="l00520"></a>00520         <span class="keywordflow">else</span> {
<a name="l00521"></a>00521 std::vector&lt;int&gt; oeds = <a class="code" href="classSgGraphTraversal.html#ed013c85aba92ce0d5d36cd0d9d16c59">getOutEdges</a>(pathContainer[i].back(), g);
<a name="l00522"></a>00522 
<a name="l00523"></a>00523         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; oeds.size(); j++) {
<a name="l00524"></a>00524 
<a name="l00525"></a>00525 
<a name="l00526"></a>00526 <span class="keywordtype">int</span> tg = <a class="code" href="classSgGraphTraversal.html#64b5039c3ff06e9271cb85eda9812a38">getTarget</a>(oeds[j], g);
<a name="l00527"></a>00527             
<a name="l00528"></a>00528 
<a name="l00529"></a>00529             std::vector&lt;int&gt; newpath = (pathContainer[i]);
<a name="l00530"></a>00530            <span class="comment">//we split up paths into pieces so that they don't take up a lot of memory, basically this is when we run into a path</span>
<a name="l00531"></a>00531            <span class="comment">//more than once, so we attach all paths that go to that path to that particular node via PtP</span>
<a name="l00532"></a>00532             <span class="keywordflow">if</span> (nodes.find(tg) != nodes.end() &amp;&amp; <a class="code" href="namespaceSageInterface.html#ff5394b21cf11cd338671af3a11a7f92">find</a>(newpath.begin(), newpath.end(), tg) == newpath.end() &amp;&amp; tg != end) {
<a name="l00533"></a>00533                 <span class="keywordflow">if</span> (PtP.find(tg) == PtP.end()) {
<a name="l00534"></a>00534                     std::vector&lt;int&gt; nv;
<a name="l00535"></a>00535                     nv.push_back(tg);
<a name="l00536"></a>00536                     newPathContainer.push_back(nv);
<a name="l00537"></a>00537                     PtP[tg].push_back(<span class="comment">/*zipPath(*(*/</span>newpath);<span class="comment">//, g, newpath.front(), newpath.back()));</span>
<a name="l00538"></a>00538                 }
<a name="l00539"></a>00539                 <span class="keywordflow">else</span> {
<a name="l00540"></a>00540                     PtP[tg].push_back(<span class="comment">/*zipPath(*/</span>newpath);<span class="comment">//, g, newpath.front(), newpath.back()));</span>
<a name="l00541"></a>00541                 }
<a name="l00542"></a>00542             }
<a name="l00543"></a>00543             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespaceSageInterface.html#ff5394b21cf11cd338671af3a11a7f92">find</a>(newpath.begin(), newpath.end(), <a class="code" href="classSgGraphTraversal.html#64b5039c3ff06e9271cb85eda9812a38">getTarget</a>(oeds[j], g)) == newpath.end() || <a class="code" href="classSgGraphTraversal.html#64b5039c3ff06e9271cb85eda9812a38">getTarget</a>(oeds[j], g) == end) {
<a name="l00544"></a>00544                 newpath.push_back(tg);
<a name="l00545"></a>00545                 std::vector&lt;int&gt; ieds = <a class="code" href="classSgGraphTraversal.html#99a605cac4164b6a2e5771eb33d25b67">getInEdges</a>(tg, g);
<a name="l00546"></a>00546                 <span class="keywordflow">if</span> (ieds.size() &gt; 1) {<span class="comment">//find(closures.begin(), closures.end(), tg) != closures.end()) {</span>
<a name="l00547"></a>00547                 nodes.insert(tg);
<a name="l00548"></a>00548                 }
<a name="l00549"></a>00549                 newPathContainer.push_back(newpath);
<a name="l00550"></a>00550             }
<a name="l00551"></a>00551             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (tg == end  &amp;&amp; recursedloop) {
<a name="l00552"></a>00552                 newpath.push_back(tg);
<a name="l00553"></a>00553                 newPathContainer.push_back(newpath);
<a name="l00554"></a>00554             }
<a name="l00555"></a>00555             <span class="keywordflow">else</span> {<span class="comment">//if (find(newpath.begin(), newpath.end(), tg) != newpath.end() &amp;&amp; tg != end) { </span>
<a name="l00556"></a>00556                 std::vector&lt;int&gt; ieds = <a class="code" href="classSgGraphTraversal.html#99a605cac4164b6a2e5771eb33d25b67">getInEdges</a>(tg, g);
<a name="l00557"></a>00557                 <span class="keywordflow">if</span> (ieds.size() &gt; 1<span class="comment">/*find(closures.begin(), closures.end(), tg) != closures.end()*/</span> &amp;&amp; <a class="code" href="namespaceSageInterface.html#ff5394b21cf11cd338671af3a11a7f92">find</a>(completedLoops.begin(), completedLoops.end(), tg) == completedLoops.end() <span class="comment">/*&amp;&amp; find(localLoops.begin(), localLoops.end(), tg) == localLoops.end()*/</span> &amp;&amp; <a class="code" href="namespaceSageInterface.html#ff5394b21cf11cd338671af3a11a7f92">find</a>(<a class="code" href="classSgGraphTraversal.html#2a0dfe20f21e79fbfa92f4da19fe25fc">recurses</a>.begin(), <a class="code" href="classSgGraphTraversal.html#2a0dfe20f21e79fbfa92f4da19fe25fc">recurses</a>.end(), tg) == <a class="code" href="classSgGraphTraversal.html#2a0dfe20f21e79fbfa92f4da19fe25fc">recurses</a>.end()) {
<a name="l00558"></a>00558                    localLoops.push_back(tg);
<a name="l00559"></a>00559                    nodes.insert(tg);
<a name="l00560"></a>00560                 }
<a name="l00561"></a>00561                <span class="comment">// else if (find(recurses.begin(), recurses.end(), tg) != recurses.end()) {</span>
<a name="l00562"></a>00562                <span class="comment">// }</span>
<a name="l00563"></a>00563            }
<a name="l00564"></a>00564            <span class="comment">//else {</span>
<a name="l00565"></a>00565            <span class="comment">//    std::cout &lt;&lt; "problem" &lt;&lt; std::endl;</span>
<a name="l00566"></a>00566            <span class="comment">//    ROSE_ASSERT(false);</span>
<a name="l00567"></a>00567           <span class="comment">// }</span>
<a name="l00568"></a>00568         }
<a name="l00569"></a>00569         }
<a name="l00570"></a>00570         }
<a name="l00571"></a>00571         pathContainer = newPathContainer;
<a name="l00572"></a>00572         newPathContainer.clear();
<a name="l00573"></a>00573         }
<a name="l00574"></a>00574        <span class="comment">// std::cout &lt;&lt; "done while" &lt;&lt; std::endl;</span>
<a name="l00575"></a>00575         pathContainer.clear();
<a name="l00576"></a>00576     std::vector&lt;std::vector&lt;int&gt; &gt; finnpts;
<a name="l00577"></a>00577     std::vector&lt;std::vector&lt;int&gt; &gt; npts;
<a name="l00578"></a>00578     <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l00579"></a>00579         <span class="keywordflow">if</span> (paths.size() &gt; 1000000) {
<a name="l00580"></a>00580            std::cout &lt;&lt; <span class="stringliteral">"too many paths, consider a subgraph"</span> &lt;&lt; std::endl;
<a name="l00581"></a>00581            ROSE_ASSERT(<span class="keyword">false</span>);
<a name="l00582"></a>00582        }
<a name="l00583"></a>00583        <span class="comment">//#pragma omp parallel for schedule(guided)</span>
<a name="l00584"></a>00584        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> qq = 0; qq &lt; paths.size(); qq++) {
<a name="l00585"></a>00585             std::vector&lt;int&gt; pq = paths[qq];
<a name="l00586"></a>00586             std::vector&lt;int&gt; qp;
<a name="l00587"></a>00587             <span class="keywordtype">int</span> ppf = paths[qq].front();
<a name="l00588"></a>00588             <span class="keywordflow">if</span> (PtP.find(ppf) != PtP.end()) {
<a name="l00589"></a>00589                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> kk = 0; kk &lt; PtP[ppf].size(); kk++) {
<a name="l00590"></a>00590                     std::vector&lt;int&gt; newpath = <span class="comment">/*unzipPath(*/</span>PtP[ppf][kk];<span class="comment">//, g, PtP[ppf][kk][0], PtP[ppf][kk][1]);</span>
<a name="l00591"></a>00591                     <span class="keywordtype">bool</span> good = <span class="keyword">true</span>;
<a name="l00592"></a>00592                     <span class="keywordflow">if</span> (newpath.back() == newpath.front() &amp;&amp; newpath.front() != begin &amp;&amp; newpath.size() &gt; 1) {
<a name="l00593"></a>00593                         good = <span class="keyword">false</span>;
<a name="l00594"></a>00594                     }
<a name="l00595"></a>00595                     <span class="keywordflow">else</span> {
<a name="l00596"></a>00596 
<a name="l00597"></a>00597                  <span class="comment">//   if (find(pq.begin(), pq.end(), newpath.front()) != pq.end() &amp;&amp; newpath.front() != begin) {</span>
<a name="l00598"></a>00598                  <span class="comment">//         good = false;</span>
<a name="l00599"></a>00599                  <span class="comment">//   }</span>
<a name="l00600"></a>00600 
<a name="l00601"></a>00601 
<a name="l00602"></a>00602                    <span class="comment">// else {</span>
<a name="l00603"></a>00603                     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> kk1 = 0; kk1 &lt; newpath.size(); kk1++) {
<a name="l00604"></a>00604                        
<a name="l00605"></a>00605                       <span class="comment">/*</span>
<a name="l00606"></a>00606 <span class="comment">                       if (newpath.front() == newpath.back()) {</span>
<a name="l00607"></a>00607 <span class="comment">                           good = false;</span>
<a name="l00608"></a>00608 <span class="comment">                           break;</span>
<a name="l00609"></a>00609 <span class="comment">                       }</span>
<a name="l00610"></a>00610 <span class="comment">                       else */</span><span class="keywordflow">if</span> (<a class="code" href="namespaceSageInterface.html#ff5394b21cf11cd338671af3a11a7f92">find</a>(pq.begin(), pq.end(), newpath[kk1]) != pq.end() &amp;&amp; newpath[kk1] != begin) {
<a name="l00611"></a>00611                            good = <span class="keyword">false</span>;
<a name="l00612"></a>00612                            <span class="keywordflow">break</span>;
<a name="l00613"></a>00613                           
<a name="l00614"></a>00614                        }
<a name="l00615"></a>00615                        }
<a name="l00616"></a>00616                     <span class="comment">//}</span>
<a name="l00617"></a>00617                     }
<a name="l00618"></a>00618                     <span class="keywordflow">if</span> (good) {
<a name="l00619"></a>00619                        newpath.insert(newpath.end(), pq.begin(), pq.end());
<a name="l00620"></a>00620 <span class="preprocessor">                       #pragma omp critical</span>
<a name="l00621"></a>00621 <span class="preprocessor"></span>                       {
<a name="l00622"></a>00622                        npts.push_back(newpath);
<a name="l00623"></a>00623                        }
<a name="l00624"></a>00624                     }
<a name="l00625"></a>00625                 }
<a name="l00626"></a>00626             }
<a name="l00627"></a>00627             <span class="keywordflow">else</span> {
<a name="l00628"></a>00628                 std::vector&lt;int&gt; ppq = pq;<span class="comment">// zipPath(pq, g, pq.front(), pq.back());</span>
<a name="l00629"></a>00629 <span class="preprocessor">                #pragma omp critical</span>
<a name="l00630"></a>00630 <span class="preprocessor"></span>                {
<a name="l00631"></a>00631                 finnpts.push_back(ppq);
<a name="l00632"></a>00632                 }
<a name="l00633"></a>00633             }
<a name="l00634"></a>00634         }
<a name="l00635"></a>00635         <span class="keywordflow">if</span> (npts.size() == 0) {
<a name="l00636"></a>00636             <span class="keywordflow">break</span>;
<a name="l00637"></a>00637         }
<a name="l00638"></a>00638         <span class="keywordflow">else</span> {
<a name="l00639"></a>00639             paths = npts;
<a name="l00640"></a>00640             npts.clear();
<a name="l00641"></a>00641         }
<a name="l00642"></a>00642     }
<a name="l00643"></a>00643     paths = finnpts;    
<a name="l00644"></a>00644     finnpts.clear(); 
<a name="l00645"></a>00645     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; localLoops.size(); k++) {
<a name="l00646"></a>00646         <span class="keywordtype">int</span> lk = localLoops[k];
<a name="l00647"></a>00647         std::vector&lt;std::vector&lt;int&gt; &gt; loopp;
<a name="l00648"></a>00648         <span class="keywordflow">if</span> (<a class="code" href="classSgGraphTraversal.html#da70ffb6e85bcaa38628b02ed311231b">loopStore</a>.find(localLoops[k]) != <a class="code" href="classSgGraphTraversal.html#da70ffb6e85bcaa38628b02ed311231b">loopStore</a>.end()) {
<a name="l00649"></a>00649             loopp.insert(loopp.end(), <a class="code" href="classSgGraphTraversal.html#da70ffb6e85bcaa38628b02ed311231b">loopStore</a>[localLoops[k]].begin(), <a class="code" href="classSgGraphTraversal.html#da70ffb6e85bcaa38628b02ed311231b">loopStore</a>[localLoops[k]].end());
<a name="l00650"></a>00650         }
<a name="l00651"></a>00651         <span class="keywordflow">else</span> {
<a name="l00652"></a>00652         std::map&lt;int, std::vector&lt;std::vector&lt;int&gt; &gt; &gt; localLoopPaths;
<a name="l00653"></a>00653         completedLoops.push_back(lk);
<a name="l00654"></a>00654         <a class="code" href="classSgGraphTraversal.html#2a0dfe20f21e79fbfa92f4da19fe25fc">recurses</a>.push_back(lk);
<a name="l00655"></a>00655         loopp = <a class="code" href="classSgGraphTraversal.html#ee7385288f2db18bfe67344be346b6b2">bfsTraversePath</a>(lk, lk, g, <span class="keyword">true</span>);
<a name="l00656"></a>00656         <a class="code" href="classSgGraphTraversal.html#2a0dfe20f21e79fbfa92f4da19fe25fc">recurses</a>.pop_back();
<a name="l00657"></a>00657         }
<a name="l00658"></a>00658         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ik = 0; ik &lt; loopp.size(); ik++) {
<a name="l00659"></a>00659                 
<a name="l00660"></a>00660                 <span class="keywordflow">if</span> (<a class="code" href="namespaceSageInterface.html#ff5394b21cf11cd338671af3a11a7f92">find</a>(globalLoopPaths[lk].begin(), globalLoopPaths[lk].end(), loopp[ik]) == globalLoopPaths[lk].end()) {
<a name="l00661"></a>00661                 globalLoopPaths[localLoops[k]].push_back(loopp[ik]);
<a name="l00662"></a>00662                 }
<a name="l00663"></a>00663         }
<a name="l00664"></a>00664     
<a name="l00665"></a>00665 
<a name="l00666"></a>00666  
<a name="l00667"></a>00667     }
<a name="l00668"></a>00668     <a class="code" href="classSgGraphTraversal.html#e095c9073a41b2774a96ed1b2adfe660">borrowed</a> = <span class="keyword">true</span>;
<a name="l00669"></a>00669     std::vector&lt;std::vector&lt;int&gt; &gt; lps2;
<a name="l00670"></a>00670     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxpaths = 1000;
<a name="l00671"></a>00671     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pathdivisor = 1;<span class="comment">//paths.size()/maxpaths;///paths.size();</span>
<a name="l00672"></a>00672 
<a name="l00673"></a>00673     <span class="comment">//if (pathdivisor &lt; 1) {</span>
<a name="l00674"></a>00674         pathdivisor = 1;
<a name="l00675"></a>00675         maxpaths = paths.size();
<a name="l00676"></a>00676    <span class="comment">// }</span>
<a name="l00677"></a>00677 <span class="comment">/*</span>
<a name="l00678"></a>00678 <span class="comment">    for (unsigned int j = 0; j &lt; pathdivisor+1; j++) {</span>
<a name="l00679"></a>00679 <span class="comment">        std::vector&lt;std::vector&lt;int&gt; &gt; npaths;</span>
<a name="l00680"></a>00680 <span class="comment">        std::vector&lt;int&gt; dummyvec;</span>
<a name="l00681"></a>00681 <span class="comment">        unsigned int mxpths;</span>
<a name="l00682"></a>00682 <span class="comment">        if (j &lt; pathdivisor) {</span>
<a name="l00683"></a>00683 <span class="comment">            mxpths = maxpaths;</span>
<a name="l00684"></a>00684 <span class="comment">        }</span>
<a name="l00685"></a>00685 <span class="comment">        else {</span>
<a name="l00686"></a>00686 <span class="comment">            mxpths = paths.size() % pathdivisor;</span>
<a name="l00687"></a>00687 <span class="comment">        }</span>
<a name="l00688"></a>00688 <span class="comment">        for (unsigned int k = 0; k &lt; mxpths; k++) {</span>
<a name="l00689"></a>00689 <span class="comment">              npaths.push_back(paths.back());//unzipPath(paths.back(), g, begin, end));</span>
<a name="l00690"></a>00690 <span class="comment">              paths.pop_back();</span>
<a name="l00691"></a>00691 <span class="comment">        }</span>
<a name="l00692"></a>00692 <span class="comment">*/</span>
<a name="l00693"></a>00693         <a class="code" href="classSgGraphTraversal.html#3f09e1ff9eca21d25a500e08efbe965a">pathStore</a> = paths;
<a name="l00694"></a>00694         paths.clear();
<a name="l00695"></a>00695     <span class="keywordflow">if</span> (!recursedloop) {
<a name="l00696"></a>00696     <a class="code" href="classSgGraphTraversal.html#10a010a60dff2ded6d6f8bb162161b62">uTraversePath</a>(begin, end, g, <span class="keyword">false</span>, globalLoopPaths);
<a name="l00697"></a>00697     }
<a name="l00698"></a>00698     <span class="keywordflow">else</span> {
<a name="l00699"></a>00699     <a class="code" href="classSgGraphTraversal.html#6deeda82e116e7078858091bd6a293a8">recursed</a>++;
<a name="l00700"></a>00700     
<a name="l00701"></a>00701     std::set&lt;std::vector&lt;int&gt; &gt; lps = <a class="code" href="classSgGraphTraversal.html#10a010a60dff2ded6d6f8bb162161b62">uTraversePath</a>(begin, end, g, <span class="keyword">true</span>, globalLoopPaths);
<a name="l00702"></a>00702     <a class="code" href="classSgGraphTraversal.html#6deeda82e116e7078858091bd6a293a8">recursed</a>--;
<a name="l00703"></a>00703     <span class="keywordflow">for</span> (std::set&lt;std::vector&lt;int&gt; &gt;::iterator ij = lps.begin(); ij != lps.end(); ij++) {
<a name="l00704"></a>00704     std::vector&lt;int&gt; ijk = (*ij);
<a name="l00705"></a>00705     
<a name="l00706"></a>00706     lps2.push_back(*ij);
<a name="l00707"></a>00707     }
<a name="l00708"></a>00708     } 
<a name="l00709"></a>00709     <span class="comment">//}</span>
<a name="l00710"></a>00710 <span class="preprocessor">    #ifdef PERFDEBUG</span>
<a name="l00711"></a>00711 <span class="preprocessor"></span> <span class="comment">//   timeval tim; </span>
<a name="l00712"></a>00712     <span class="comment">//std::cout &lt;&lt; "begin: " &lt;&lt; begin &lt;&lt; " end: " &lt;&lt; end &lt;&lt; std::endl;</span>
<a name="l00713"></a>00713     gettimeofday(&amp;tim, NULL);
<a name="l00714"></a>00714     <span class="keywordtype">double</span> tim2 = tim.tv_sec+(tim.tv_usec/1000000);
<a name="l00715"></a>00715     <span class="keywordtype">double</span> timeRet = tim2 - tim1;
<a name="l00716"></a>00716     <span class="comment">//std::cout &lt;&lt; "bfs time elapsed: " &lt;&lt; timeRet &lt;&lt; std::endl;</span>
<a name="l00717"></a>00717 <span class="preprocessor">    #endif</span>
<a name="l00718"></a>00718 <span class="preprocessor"></span>    <span class="keywordflow">return</span> lps2;
<a name="l00719"></a>00719     
<a name="l00720"></a>00720 }
<a name="l00721"></a>00721              
<a name="l00722"></a>00722         
<a name="l00734"></a>00734 <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l00735"></a>00735 std::set&lt;std::vector&lt;int&gt; &gt;
<a name="l00736"></a>00736 <a class="code" href="classSgGraphTraversal.html#10a010a60dff2ded6d6f8bb162161b62">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l00737"></a><a class="code" href="classSgGraphTraversal.html#10a010a60dff2ded6d6f8bb162161b62">00737</a> <a class="code" href="classSgGraphTraversal.html#10a010a60dff2ded6d6f8bb162161b62">uTraversePath</a>(<span class="keywordtype">int</span> begin, <span class="keywordtype">int</span> end, CFG*&amp; g, <span class="keywordtype">bool</span> loop, std::map&lt;<span class="keywordtype">int</span>, std::vector&lt;std::vector&lt;int&gt; &gt; &gt;&amp; globalLoopPaths) {
<a name="l00738"></a>00738     <span class="comment">//std::cout &lt;&lt; "uTraverse" &lt;&lt; std::endl;</span>
<a name="l00739"></a>00739     <span class="keywordtype">int</span> doubledpaths = 0;
<a name="l00740"></a>00740     <span class="keywordtype">int</span> newmil = 1;
<a name="l00741"></a>00741     <span class="comment">//#ifdef LP</span>
<a name="l00742"></a>00742     <span class="comment">//if (loop &amp;&amp; loopStore.find(begin) != loopStore.end()) {</span>
<a name="l00743"></a>00743     <span class="comment">//    return loopStore[begin];</span>
<a name="l00744"></a>00744     <span class="comment">//}</span>
<a name="l00745"></a>00745     <span class="comment">//#endif</span>
<a name="l00746"></a>00746 <span class="preprocessor">    #ifdef PERFDEBUG</span>
<a name="l00747"></a>00747 <span class="preprocessor"></span>    timeval tim;
<a name="l00748"></a>00748     gettimeofday(&amp;tim, NULL);
<a name="l00749"></a>00749     <span class="keywordtype">double</span> t1 = tim.tv_sec+(tim.tv_usec/1000000);
<a name="l00750"></a>00750 <span class="preprocessor">    #endif</span>
<a name="l00751"></a>00751 <span class="preprocessor"></span>    std::set&lt;std::vector&lt;int&gt; &gt; newpaths;
<a name="l00752"></a>00752     std::set&lt;std::vector&lt;int&gt; &gt; npaths;
<a name="l00753"></a>00753     <a class="code" href="classSgGraphTraversal.html#b88ac29234d7d1182af47cd9ee944179">pathnum</a> = 0;
<a name="l00754"></a>00754     std::vector&lt;int&gt; path;
<a name="l00755"></a>00755     std::vector&lt;std::vector&lt;int&gt; &gt; <a class="code" href="yicesParserLib_8h.html#0ab651cea734fb0eb3ed32cef06b99ec">paths</a>;
<a name="l00756"></a>00756     <span class="keywordtype">int</span> truepaths = 0;
<a name="l00757"></a>00757     std::vector&lt;std::vector&lt;int&gt; &gt; checkpaths;
<a name="l00758"></a>00758     std::vector&lt;std::vector&lt;int&gt; &gt; npathchecker;
<a name="l00759"></a>00759     std::map&lt;int, int&gt; currents;
<a name="l00760"></a>00760     <span class="comment">//int nnumpaths = 0;</span>
<a name="l00761"></a>00761     std::set&lt;std::vector&lt;int&gt; &gt; loopPaths;
<a name="l00762"></a>00762     <span class="comment">//bool threadsafe = true;</span>
<a name="l00763"></a>00763     <span class="keywordtype">bool</span> <a class="code" href="classSgGraphTraversal.html#2998a2a384d6a3f96222d70bbf2d134c">done</a> = <span class="keyword">false</span>;
<a name="l00764"></a>00764     std::set&lt;std::vector&lt;int&gt; &gt; fts;
<a name="l00765"></a>00765     <span class="keywordtype">double</span> ttfors = 0;
<a name="l00766"></a>00766     <span class="keywordtype">double</span> tperms = 0;
<a name="l00767"></a>00767     <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l00768"></a>00768         <span class="comment">//std::cout &lt;&lt; "paths.size() " &lt;&lt; paths.size() &lt;&lt; std::endl;</span>
<a name="l00769"></a>00769         <span class="keywordflow">if</span> (paths.size() &gt; 1000000) {
<a name="l00770"></a>00770             std::cout &lt;&lt; <span class="stringliteral">"nearly 1 million paths with no loops, stopping"</span> &lt;&lt; std::endl;
<a name="l00771"></a>00771             <span class="keywordflow">return</span> loopPaths;
<a name="l00772"></a>00772             std::cout &lt;&lt; <span class="stringliteral">"ended early"</span> &lt;&lt; std::endl;
<a name="l00773"></a>00773         }
<a name="l00774"></a>00774         <span class="keywordflow">if</span> (done || <a class="code" href="classSgGraphTraversal.html#e095c9073a41b2774a96ed1b2adfe660">borrowed</a>) {
<a name="l00775"></a>00775      
<a name="l00776"></a>00776                 <span class="keywordflow">if</span> (<a class="code" href="classSgGraphTraversal.html#e095c9073a41b2774a96ed1b2adfe660">borrowed</a>) {
<a name="l00777"></a>00777                     paths = <a class="code" href="classSgGraphTraversal.html#3f09e1ff9eca21d25a500e08efbe965a">pathStore</a>;
<a name="l00778"></a>00778                     <a class="code" href="classSgGraphTraversal.html#3f09e1ff9eca21d25a500e08efbe965a">pathStore</a>.clear(); 
<a name="l00779"></a>00779                 }   
<a name="l00780"></a>00780                 <span class="comment">//std::cout &lt;&lt; "paths.size(): " &lt;&lt; paths.size() &lt;&lt; std::endl; </span>
<a name="l00781"></a>00781                 <span class="keywordflow">if</span> (paths.size() != 0) {
<a name="l00782"></a>00782                 }
<a name="l00783"></a>00783                 <span class="keywordflow">else</span> {
<a name="l00784"></a>00784                 <span class="keywordflow">return</span> loopPaths;
<a name="l00785"></a>00785                 }
<a name="l00786"></a>00786          
<a name="l00787"></a>00787                <span class="comment">// #pragma omp parallel</span>
<a name="l00788"></a>00788                <span class="comment">// {</span>
<a name="l00789"></a>00789 <span class="preprocessor">                #pragma omp parallel for schedule(guided) </span>
<a name="l00790"></a>00790 <span class="preprocessor"></span>                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> qqq = 0; qqq &lt; paths.size(); qqq++) {
<a name="l00791"></a>00791   <span class="comment">//             std::cout &lt;&lt; "pathcheck" &lt;&lt; std::endl;</span>
<a name="l00792"></a>00792                 <span class="comment">//int pathevals = 0;</span>
<a name="l00793"></a>00793                 <span class="comment">//std::vector&lt;int&gt; zpt = zipPath2(paths[qqq], g); </span>
<a name="l00794"></a>00794                 <span class="comment">//std::set&lt;std::vector&lt;int&gt; &gt; boxpaths;</span>
<a name="l00795"></a>00795                 std::set&lt;std::vector&lt;int&gt; &gt; movepaths;
<a name="l00796"></a>00796                 std::vector&lt;int&gt; path;<span class="comment">// = paths[qqq];</span>
<a name="l00797"></a>00797                 path = paths[qqq];<span class="comment">//unzipPath(paths[qqq], g, begin, end);</span>
<a name="l00798"></a>00798                 truepaths++;
<a name="l00799"></a>00799                    <span class="keywordtype">int</span> permnums = 1;
<a name="l00800"></a>00800                    std::vector&lt;int&gt; perms;
<a name="l00801"></a>00801                     std::vector&lt;unsigned int&gt; qs;
<a name="l00802"></a>00802                     std::map&lt;int, std::vector&lt;std::vector&lt;int&gt; &gt; &gt; localLoops;
<a name="l00803"></a>00803                     std::vector&lt;int&gt; takenLoops;
<a name="l00804"></a>00804                     takenLoops.push_back(path[0]);
<a name="l00805"></a>00805                     <span class="keywordtype">bool</span> taken = <span class="keyword">false</span>;
<a name="l00806"></a>00806                     timeval timfor;
<a name="l00807"></a>00807                     <span class="keywordtype">int</span> lost = 0;
<a name="l00808"></a>00808                     gettimeofday(&amp;timfor, NULL);
<a name="l00809"></a>00809                     <span class="keywordtype">double</span> t1for = timfor.tv_sec + (timfor.tv_usec/1000000); 
<a name="l00810"></a>00810                     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 1; q &lt; path.size()-1; q++) {
<a name="l00811"></a>00811                     <span class="comment">//if (find(closures.begin(), closures.end(), path[q]) != closures.end()) {</span>
<a name="l00812"></a>00812                     <span class="keywordflow">if</span> (globalLoopPaths.find(path[q]) != globalLoopPaths.end() <span class="comment">/*&amp;&amp; find(lloops.begin(), lloops.end(), path[q]) != lloops.end()*/</span> &amp;&amp; globalLoopPaths[path[q]].size() != 0 <span class="comment">/*&amp;&amp; path[q] != begin &amp;&amp; path[q] != end*/</span>) {
<a name="l00813"></a>00813                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> qp1 = 0; qp1 &lt; globalLoopPaths[path[q]].size(); qp1++) {
<a name="l00814"></a>00814                             
<a name="l00815"></a>00815                             std::vector&lt;int&gt; gp = globalLoopPaths[path[q]][qp1]; <span class="comment">//unzipPath(globalLoopPaths[path[q]][qp1],g,path[q],path[q]);</span>
<a name="l00816"></a>00816                            <span class="comment">// std::vector&lt;int&gt; zgp = zipPath2(globalLoopPaths[zpt[q]][qp1], g);</span>
<a name="l00817"></a>00817                             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> qp2 = 0; qp2 &lt; takenLoops.size(); qp2++) {
<a name="l00818"></a>00818                                 <span class="keywordflow">if</span> (<a class="code" href="namespaceSageInterface.html#ff5394b21cf11cd338671af3a11a7f92">find</a>(gp.begin(),gp.end(), takenLoops[qp2]) != gp.end()) {
<a name="l00819"></a>00819                                     taken = <span class="keyword">true</span>;
<a name="l00820"></a>00820                                 }
<a name="l00821"></a>00821                             }
<a name="l00822"></a>00822 
<a name="l00823"></a>00823                             <span class="keywordflow">if</span> (!taken) {
<a name="l00824"></a>00824                                 localLoops[path[q]].push_back(gp);
<a name="l00825"></a>00825                             }
<a name="l00826"></a>00826                             <span class="keywordflow">else</span> {
<a name="l00827"></a>00827                                lost++;
<a name="l00828"></a>00828                                taken = <span class="keyword">false</span>;
<a name="l00829"></a>00829                             }
<a name="l00830"></a>00830                         }
<a name="l00831"></a>00831                         <span class="keywordflow">if</span> (localLoops[path[q]].size() != 0) {
<a name="l00832"></a>00832                         takenLoops.push_back(path[q]);
<a name="l00833"></a>00833                         permnums *= (localLoops[path[q]].size()+1);
<a name="l00834"></a>00834                         perms.push_back(permnums);
<a name="l00835"></a>00835                         qs.push_back(path[q]);
<a name="l00836"></a>00836                         }
<a name="l00837"></a>00837                     }
<a name="l00838"></a>00838                     }
<a name="l00839"></a>00839                     
<a name="l00840"></a>00840                     <span class="comment">//}</span>
<a name="l00841"></a>00841                     <span class="comment">//if (loop) {</span>
<a name="l00842"></a>00842                     <span class="comment">//std::cout &lt;&lt; "lostloop: " &lt;&lt; lost &lt;&lt; std::endl;</span>
<a name="l00843"></a>00843                     <span class="comment">//}</span>
<a name="l00844"></a>00844                     <span class="comment">//else {</span>
<a name="l00845"></a>00845                     <span class="comment">//std::cout &lt;&lt; "lostpath: " &lt;&lt; lost &lt;&lt; std::endl;</span>
<a name="l00846"></a>00846                     <span class="comment">//}</span>
<a name="l00847"></a>00847                     <span class="comment">//std::cout &lt;&lt; "endpathcheck" &lt;&lt; std::endl;</span>
<a name="l00848"></a>00848                     <span class="comment">//std::cout &lt;&lt; "rest" &lt;&lt; std::endl;</span>
<a name="l00849"></a>00849                     <span class="comment">//std::cout &lt;&lt; "permnums: " &lt;&lt; permnums &lt;&lt; std::endl;</span>
<a name="l00850"></a>00850                     gettimeofday(&amp;timfor, NULL);
<a name="l00851"></a>00851                     <span class="keywordtype">double</span> t2for = timfor.tv_sec + (timfor.tv_usec/1000000);
<a name="l00852"></a>00852                     <span class="comment">//double ttfor = t2for - t1for;</span>
<a name="l00853"></a>00853                     <span class="comment">//#pragma omp atomic</span>
<a name="l00854"></a>00854                     <span class="comment">//ttfors += ttfor;</span>
<a name="l00855"></a>00855                     
<a name="l00856"></a>00856                     <span class="comment">//std::set&lt;std::vector&lt;int&gt; &gt; movepaths2;</span>
<a name="l00857"></a>00857                     std::set&lt;std::vector&lt;int&gt; &gt; movepathscheck;
<a name="l00858"></a>00858                     timeval timperms;
<a name="l00859"></a>00859                     gettimeofday(&amp;timperms, NULL);
<a name="l00860"></a>00860                    <span class="comment">// double t1perm = timperms.tv_sec + (timperms.tv_usec/1000000);</span>
<a name="l00861"></a>00861                     std::vector&lt;int&gt; nvec;
<a name="l00862"></a>00862                     std::vector&lt;std::vector&lt;int&gt; &gt; boxpaths(permnums, nvec);
<a name="l00863"></a>00863                     <span class="comment">//#pragma omp parallel for schedule(guided)</span>
<a name="l00864"></a>00864                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= permnums; i++) {
<a name="l00865"></a>00865                         <span class="comment">//bool goodthread = false;</span>
<a name="l00866"></a>00866                         std::vector&lt;int&gt; loopsTaken;
<a name="l00867"></a>00867                         <span class="comment">//bool stop = false;</span>
<a name="l00868"></a>00868                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0;
<a name="l00869"></a>00869                         std::vector&lt;int&gt; npath;
<a name="l00870"></a>00870                         <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l00871"></a>00871                             <span class="keywordflow">if</span> (j == perms.size() || perms[j] &gt; i) {
<a name="l00872"></a>00872                                 <span class="keywordflow">break</span>;
<a name="l00873"></a>00873                             }
<a name="l00874"></a>00874                             <span class="keywordflow">else</span> {
<a name="l00875"></a>00875                                 j++;
<a name="l00876"></a>00876                             }
<a name="l00877"></a>00877                         }
<a name="l00878"></a>00878                         <span class="keywordtype">int</span> pn = i;
<a name="l00879"></a>00879                         std::vector&lt;int&gt; pL;
<a name="l00880"></a>00880                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j1 = 0; j1 &lt;= j; j1++) {
<a name="l00881"></a>00881                             pL.push_back(-1);
<a name="l00882"></a>00882                         }
<a name="l00883"></a>00883                            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = j; k &gt; 0; k--) {
<a name="l00884"></a>00884                                <span class="keywordtype">int</span> l = 1;
<a name="l00885"></a>00885                                <span class="keywordflow">while</span> (perms[k-1]*l &lt; pn) {
<a name="l00886"></a>00886                                    l++;
<a name="l00887"></a>00887                               }
<a name="l00888"></a>00888                                pL[k] = l-2;
<a name="l00889"></a>00889                                pn -= (perms[k-1]*(l-1));
<a name="l00890"></a>00890                            }
<a name="l00891"></a>00891                         pL[0] = pn-2;
<a name="l00892"></a>00892 
<a name="l00893"></a>00893                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q2 = 0;
<a name="l00894"></a>00894                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q1 = 0; q1 &lt; path.size(); q1++) {
<a name="l00895"></a>00895                             <span class="keywordflow">if</span> (q2 &lt; qs.size()) {
<a name="l00896"></a>00896                             <span class="keywordflow">if</span> (qs.size() != 0 &amp;&amp; path[q1] == qs[q2] &amp;&amp; q2 != pL.size()) {
<a name="l00897"></a>00897                                <span class="keywordflow">if</span> (pL[q2] == -1) {
<a name="l00898"></a>00898                                    npath.push_back(path[q1]);
<a name="l00899"></a>00899                                }
<a name="l00900"></a>00900                                <span class="keywordflow">else</span> {
<a name="l00901"></a>00901                                <span class="comment">//   if (!stop) {</span>
<a name="l00902"></a>00902                                    npath.insert(npath.end(), localLoops[path[q1]][pL[q2]].begin(), localLoops[path[q1]][pL[q2]].end());
<a name="l00903"></a>00903                                  <span class="comment">//  }</span>
<a name="l00904"></a>00904                                }
<a name="l00905"></a>00905                                q2++;
<a name="l00906"></a>00906                             }
<a name="l00907"></a>00907                             <span class="keywordflow">else</span> {
<a name="l00908"></a>00908                                npath.push_back(path[q1]);
<a name="l00909"></a>00909                             }
<a name="l00910"></a>00910                             }
<a name="l00911"></a>00911                             <span class="keywordflow">else</span> {
<a name="l00912"></a>00912                                npath.push_back(path[q1]);
<a name="l00913"></a>00913                             }
<a name="l00914"></a>00914                                 
<a name="l00915"></a>00915                         }
<a name="l00916"></a>00916 <span class="preprocessor">                        #ifdef FULLDEBUG</span>
<a name="l00917"></a>00917 <span class="preprocessor"></span>                        std::cout &lt;&lt; <span class="stringliteral">"path: "</span> &lt;&lt; std::endl;
<a name="l00918"></a>00918                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> qe = 0; qe &lt; npath.size(); qe++) {
<a name="l00919"></a>00919                             std::cout &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; npath[qe];
<a name="l00920"></a>00920                         }
<a name="l00921"></a>00921                         std::cout &lt;&lt; std::endl;
<a name="l00922"></a>00922                         std::cout &lt;&lt; <span class="stringliteral">"permnum: "</span> &lt;&lt; i &lt;&lt; std::endl; 
<a name="l00923"></a>00923 <span class="preprocessor">                        #endif</span>
<a name="l00924"></a>00924 <span class="preprocessor"></span>                      <span class="comment">//  bool addit = false;</span>
<a name="l00925"></a>00925                         <span class="comment">//if (!stop) {</span>
<a name="l00926"></a>00926                       <span class="comment">//  if (loop &amp;&amp; npath.front() == npath.back()) {</span>
<a name="l00927"></a>00927                       <span class="comment">//      addit = true;</span>
<a name="l00928"></a>00928                       <span class="comment">//  }</span>
<a name="l00929"></a>00929                       <span class="comment">//  else if (!loop &amp;&amp; bound &amp;&amp; npath.front() == begin &amp;&amp; npath.back() == end &amp;&amp; npath.size() != 1) {</span>
<a name="l00930"></a>00930                       <span class="comment">//      addit = true;</span>
<a name="l00931"></a>00931                       <span class="comment">//  }</span>
<a name="l00932"></a>00932                       <span class="comment">//  else if (!loop &amp;&amp; !bound) {</span>
<a name="l00933"></a>00933                       <span class="comment">//      addit = true;</span>
<a name="l00934"></a>00934                       <span class="comment">//  }</span>
<a name="l00935"></a>00935                       <span class="comment">// if (!addit) {</span>
<a name="l00936"></a>00936                       <span class="comment">//     std::cout &lt;&lt; "bad path" &lt;&lt; std::endl;</span>
<a name="l00937"></a>00937                       <span class="comment">// }</span>
<a name="l00938"></a>00938                        <span class="comment">//bool extra = false;</span>
<a name="l00939"></a>00939                        <span class="comment">//if (addit &amp;&amp; !loop) {</span>
<a name="l00940"></a>00940                             <span class="comment">//if (movepathscheck.find(npath) == movepathscheck.end()) {</span>
<a name="l00941"></a>00941                             <span class="comment">//int mpc = movepathscheck.size();</span>
<a name="l00942"></a>00942                             <span class="comment">//std::set&lt;std::vector&lt;int&gt; &gt; movepathspre = movepathscheck;</span>
<a name="l00943"></a>00943                     <span class="comment">//        movepaths2.insert(npath);</span>
<a name="l00944"></a>00944                             <span class="comment">//movepathscheck.insert(npath);</span>
<a name="l00945"></a>00945                             <span class="comment">//ROSE_ASSERT(movepathscheck.size() == mpc || movepathspre.find(npath) == movepathspre.end());</span>
<a name="l00946"></a>00946                             <span class="comment">//if (movepathscheck.size() == mpc) {</span>
<a name="l00947"></a>00947                             <span class="comment">//    extra = true;</span>
<a name="l00948"></a>00948                            <span class="comment">// }</span>
<a name="l00949"></a>00949                        
<a name="l00950"></a>00950                             <span class="comment">//}</span>
<a name="l00951"></a>00951                             <span class="comment">//else {</span>
<a name="l00952"></a>00952                             <span class="comment">//#pragma omp atomic</span>
<a name="l00953"></a>00953                            <span class="comment">// doubledpaths++;</span>
<a name="l00954"></a>00954                            <span class="comment">// }</span>
<a name="l00955"></a>00955                        <span class="comment">//}</span>
<a name="l00956"></a>00956                             
<a name="l00957"></a>00957                             <span class="comment">//if (!workingthread || threadsafe) {</span>
<a name="l00958"></a>00958                             <span class="comment">//if ((newpaths.size() &gt; 1 || i == permnums || threadsafe)) {</span>
<a name="l00959"></a>00959                            <span class="comment">// }</span>
<a name="l00960"></a>00960                           <span class="comment">// }</span>
<a name="l00961"></a>00961                                
<a name="l00962"></a>00962                        <span class="comment">// }</span>
<a name="l00963"></a>00963                         <span class="comment">//if (!extra)</span>
<a name="l00964"></a>00964                        <span class="comment">// {</span>
<a name="l00965"></a>00965                         <span class="comment">//if (movepaths2.size() &gt; 0) //|| i == permnums || threadsafe)</span>
<a name="l00966"></a>00966                        <span class="comment">// #pragma omp critical</span>
<a name="l00967"></a>00967                       <span class="comment">// {</span>
<a name="l00968"></a>00968                        boxpaths[i-1] = npath;
<a name="l00969"></a>00969                       <span class="comment">// } </span>
<a name="l00970"></a>00970                       <span class="comment">// }</span>
<a name="l00971"></a>00971                        <span class="comment">//std::cout &lt;&lt; "endrest" &lt;&lt; std::endl;</span>
<a name="l00972"></a>00972                        }
<a name="l00973"></a>00973                         
<a name="l00974"></a>00974                        <a class="code" href="classSgGraphTraversal.html#60b42955fb99a8791a31fc4daa2154f9">evaledpaths</a> += boxpaths.size();
<a name="l00975"></a>00975                       <span class="keywordflow">if</span> (<a class="code" href="classSgGraphTraversal.html#60b42955fb99a8791a31fc4daa2154f9">evaledpaths</a> &gt; newmil*100000) {
<a name="l00976"></a>00976                        <span class="comment">//std::cout &lt;&lt; "evaledpaths: " &lt;&lt; evaledpaths &lt;&lt; std::endl;</span>
<a name="l00977"></a>00977                        newmil++;
<a name="l00978"></a>00978                         }
<a name="l00979"></a>00979                        <span class="comment">// #pragma omp critical</span>
<a name="l00980"></a>00980                       <span class="comment">// {</span>
<a name="l00981"></a>00981                        <span class="keywordflow">if</span> (!loop) {
<a name="l00982"></a>00982                        <span class="keywordflow">for</span> (std::vector&lt;std::vector&lt;int&gt; &gt;::iterator box = boxpaths.begin(); box != boxpaths.end(); box++) {
<a name="l00983"></a>00983                        std::vector&lt;Vertex&gt; verts;
<a name="l00984"></a>00984                        <a class="code" href="classSgGraphTraversal.html#5cb8364064494352aaefc69b9183ff4c">getVertexPath</a>((*box), g, verts);
<a name="l00985"></a>00985 <span class="preprocessor">                       #pragma omp critical</span>
<a name="l00986"></a>00986 <span class="preprocessor"></span>                       { 
<a name="l00987"></a>00987                        <a class="code" href="classSgGraphTraversal.html#eb1854d2cdcd248f7c97d6e20fed6189">analyzePath</a>(verts);
<a name="l00988"></a>00988                        }
<a name="l00989"></a>00989                        }
<a name="l00990"></a>00990                        }
<a name="l00991"></a>00991                        <span class="keywordflow">else</span> {
<a name="l00992"></a>00992 <span class="preprocessor">                       #pragma omp critical</span>
<a name="l00993"></a>00993 <span class="preprocessor"></span>                       {
<a name="l00994"></a>00994                        loopPaths.insert(boxpaths.begin(), boxpaths.end());;
<a name="l00995"></a>00995                        }
<a name="l00996"></a>00996                        }
<a name="l00997"></a>00997                        }
<a name="l00998"></a>00998                        }
<a name="l00999"></a>00999                        <span class="comment">//} </span>
<a name="l01000"></a>01000                        
<a name="l01001"></a>01001 <span class="comment">/* </span>
<a name="l01002"></a>01002 <span class="comment">                      #pragma omp atomic</span>
<a name="l01003"></a>01003 <span class="comment">                      evaledpaths++; </span>
<a name="l01004"></a>01004 <span class="comment">                      //pathevals++;</span>
<a name="l01005"></a>01005 <span class="comment">                      if (evaledpaths % 10000 == 0 &amp;&amp; evaledpaths != 0) {</span>
<a name="l01006"></a>01006 <span class="comment">                          std::cout &lt;&lt; "evaled paths: " &lt;&lt; evaledpaths &lt;&lt; std::endl;</span>
<a name="l01007"></a>01007 <span class="comment">                      }</span>
<a name="l01008"></a>01008 <span class="comment">                      if (!loop) {</span>
<a name="l01009"></a>01009 <span class="comment">                          std::vector&lt;Vertex&gt; verts;</span>
<a name="l01010"></a>01010 <span class="comment">                          getVertexPath(npath, g, verts);</span>
<a name="l01011"></a>01011 <span class="comment">                              #pragma omp critical</span>
<a name="l01012"></a>01012 <span class="comment">                              {</span>
<a name="l01013"></a>01013 <span class="comment">                              #ifdef FULLDEBUG</span>
<a name="l01014"></a>01014 <span class="comment">                              for (unsigned int aa = 0; aa &lt; npath.size(); aa++) {</span>
<a name="l01015"></a>01015 <span class="comment">                                  if (ptsNum.find(npath[aa]) != ptsNum.end()) {</span>
<a name="l01016"></a>01016 <span class="comment">                                  ptsNum[npath[aa]] += 1;</span>
<a name="l01017"></a>01017 <span class="comment">                                  }</span>
<a name="l01018"></a>01018 <span class="comment">                                  else {</span>
<a name="l01019"></a>01019 <span class="comment">                                  ptsNum[npath[aa]] = 1;</span>
<a name="l01020"></a>01020 <span class="comment">                                  }</span>
<a name="l01021"></a>01021 <span class="comment">                              }</span>
<a name="l01022"></a>01022 <span class="comment">                              #endif</span>
<a name="l01023"></a>01023 <span class="comment">                              analyzePath(verts);</span>
<a name="l01024"></a>01024 <span class="comment">                              }</span>
<a name="l01025"></a>01025 <span class="comment">                      }</span>
<a name="l01026"></a>01026 <span class="comment">                      else if (loop)</span>
<a name="l01027"></a>01027 <span class="comment">                      { </span>
<a name="l01028"></a>01028 <span class="comment">                          //std::vector&lt;int&gt; zpth = zipPath(npath, g, npath.front(), npath.back());</span>
<a name="l01029"></a>01029 <span class="comment">                          #pragma omp critical</span>
<a name="l01030"></a>01030 <span class="comment">                          {</span>
<a name="l01031"></a>01031 <span class="comment">                          loopPaths.insert(npath);//zipPath(npath, g, npath.front(), npath.back()));</span>
<a name="l01032"></a>01032 <span class="comment">                          }</span>
<a name="l01033"></a>01033 <span class="comment">                      }</span>
<a name="l01034"></a>01034 <span class="comment">                      else {</span>
<a name="l01035"></a>01035 <span class="comment">                      }</span>
<a name="l01036"></a>01036 <span class="comment">                      </span>
<a name="l01037"></a>01037 <span class="comment">                   }</span>
<a name="l01038"></a>01038 <span class="comment">*/</span>
<a name="l01039"></a>01039 
<a name="l01040"></a>01040                   <span class="comment">// movepaths2.clear();</span>
<a name="l01041"></a>01041                   
<a name="l01042"></a>01042                  <span class="comment">// std::cout &lt;&lt; "permnums: " &lt;&lt; permnums &lt;&lt; std::endl;</span>
<a name="l01043"></a>01043                 <span class="comment">//  std::cout &lt;&lt; "evaledpaths final: " &lt;&lt; pathevals &lt;&lt; std::endl;  </span>
<a name="l01044"></a>01044                   <span class="comment">//gettimeofday(&amp;timperms, NULL);</span>
<a name="l01045"></a>01045                   <span class="comment">//double t2perm = timperms.tv_sec+(timperms.tv_usec/1000000);</span>
<a name="l01046"></a>01046                   <span class="comment">//#pragma omp atomic</span>
<a name="l01047"></a>01047                   <span class="comment">//tperms += t2perm - t1perm;</span>
<a name="l01048"></a>01048                  <span class="comment">// }</span>
<a name="l01049"></a>01049                   <span class="comment">//}</span>
<a name="l01050"></a>01050                   <span class="comment">//}</span>
<a name="l01051"></a>01051                   <span class="comment">//}</span>
<a name="l01052"></a>01052                   
<a name="l01053"></a>01053                   
<a name="l01054"></a>01054                   
<a name="l01055"></a>01055                     
<a name="l01056"></a>01056 
<a name="l01057"></a>01057                     
<a name="l01058"></a>01058 <span class="preprocessor">                    #ifdef PERFDEBUG</span>
<a name="l01059"></a>01059 <span class="preprocessor"></span>                    gettimeofday(&amp;tim, NULL);
<a name="l01060"></a>01060                    <span class="comment">// double t2 = tim.tv_sec+(tim.tv_usec/1000000.0);</span>
<a name="l01061"></a>01061                    <span class="comment">// double tperm = t2 - t1perm</span>
<a name="l01062"></a>01062                     <span class="comment">//double tX = t2 - t1;</span>
<a name="l01063"></a>01063                     <span class="comment">//std::cout &lt;&lt; "begin: " &lt;&lt; begin &lt;&lt; " end: " &lt;&lt; end &lt;&lt; std::endl;</span>
<a name="l01064"></a>01064                    <span class="comment">// std::cout &lt;&lt; "uTraverse time: " &lt;&lt; tX &lt;&lt; std::endl;</span>
<a name="l01065"></a>01065                    <span class="comment">// std::cout &lt;&lt; "tperms: " &lt;&lt; tperms &lt;&lt; std::endl;</span>
<a name="l01066"></a>01066                    <span class="comment">// std::cout &lt;&lt; "ttfors: " &lt;&lt; ttfors &lt;&lt; std::endl;</span>
<a name="l01067"></a>01067                    <span class="comment">// std::cout &lt;&lt; "doubledpaths: " &lt;&lt; doubledpaths &lt;&lt; std::endl;</span>
<a name="l01068"></a>01068 <span class="preprocessor">                    #endif</span>
<a name="l01069"></a>01069 <span class="preprocessor"></span><span class="preprocessor">                    #ifdef LP</span>
<a name="l01070"></a>01070 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> (loop) {
<a name="l01071"></a>01071 <span class="preprocessor">                   #ifdef PERFDEBUG</span>
<a name="l01072"></a>01072 <span class="preprocessor"></span>                   <span class="comment">//  std::cout &lt;&lt; "loopPaths: " &lt;&lt; loopPaths.size() &lt;&lt; std::endl;</span>
<a name="l01073"></a>01073 <span class="preprocessor">                   #endif</span>
<a name="l01074"></a>01074 <span class="preprocessor"></span>                    <a class="code" href="classSgGraphTraversal.html#da70ffb6e85bcaa38628b02ed311231b">loopStore</a>[begin] = loopPaths;
<a name="l01075"></a>01075                     }
<a name="l01076"></a>01076 <span class="preprocessor">                    #endif</span>
<a name="l01077"></a>01077 <span class="preprocessor"></span>                    <span class="keywordflow">return</span> loopPaths;
<a name="l01078"></a>01078                     
<a name="l01079"></a>01079                     }
<a name="l01080"></a>01080                     }
<a name="l01081"></a>01081                     
<a name="l01082"></a>01082          
<a name="l01083"></a>01083          
<a name="l01084"></a>01084                     
<a name="l01085"></a>01085             
<a name="l01086"></a>01086 
<a name="l01087"></a>01087 
<a name="l01088"></a>01088 
<a name="l01100"></a>01100 <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l01101"></a>01101 <span class="keywordtype">void</span>
<a name="l01102"></a>01102 <a class="code" href="classSgGraphTraversal.html#112773609abc35a0bb7750e67d5752a7">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l01103"></a><a class="code" href="classSgGraphTraversal.html#112773609abc35a0bb7750e67d5752a7">01103</a> <a class="code" href="classSgGraphTraversal.html#112773609abc35a0bb7750e67d5752a7">constructPathAnalyzer</a>(CFG* g, <span class="keywordtype">bool</span> unbounded, <a class="code" href="structVertex.html">Vertex</a> begin, <a class="code" href="structVertex.html">Vertex</a> end, <span class="keywordtype">bool</span> ns) {
<a name="l01104"></a>01104     <a class="code" href="classSgGraphTraversal.html#7cfd1e1490e04cc3838170e3d6b024da">abnormals</a> = 0;
<a name="l01105"></a>01105     <a class="code" href="classSgGraphTraversal.html#98eb28f60bd7704ec98fcb87e965f4f8">normals</a> = 0;
<a name="l01106"></a>01106     <span class="keywordflow">if</span> (ns) {
<a name="l01107"></a>01107         <a class="code" href="classSgGraphTraversal.html#fe960262f472d138cff29730d5bc4b2f">needssafety</a> = <span class="keyword">true</span>;
<a name="l01108"></a>01108     }
<a name="l01109"></a>01109     <span class="keywordflow">else</span> {
<a name="l01110"></a>01110         <a class="code" href="classSgGraphTraversal.html#fe960262f472d138cff29730d5bc4b2f">needssafety</a> = <span class="keyword">false</span>;
<a name="l01111"></a>01111     }
<a name="l01112"></a>01112     <a class="code" href="classSgGraphTraversal.html#a306f50f82208052c5530cacd844a0c1">checkedfound</a> = 0;
<a name="l01113"></a>01113     <a class="code" href="classSgGraphTraversal.html#6deeda82e116e7078858091bd6a293a8">recursed</a> = 0;
<a name="l01114"></a>01114     <a class="code" href="classSgGraphTraversal.html#d3cc71c92e55b4b899a9a9d29995f5d5">nextsubpath</a> = 0;
<a name="l01115"></a>01115     <a class="code" href="classSgGraphTraversal.html#e095c9073a41b2774a96ed1b2adfe660">borrowed</a> = <span class="keyword">true</span>;
<a name="l01116"></a>01116     <a class="code" href="classSgGraphTraversal.html#5b4e5f4cde674c9003f194cc7de4a06b">stoppedpaths</a> = 0;
<a name="l01117"></a>01117     <a class="code" href="classSgGraphTraversal.html#60b42955fb99a8791a31fc4daa2154f9">evaledpaths</a> = 0;
<a name="l01118"></a>01118     <a class="code" href="classSgGraphTraversal.html#1e46cf0d71a76af81a0c5cf9feb90ee3">badpaths</a> = 0;
<a name="l01119"></a>01119     <a class="code" href="classSgGraphTraversal.html#1a5577095b410bc1259365a92dce8014">sourcenum</a> = 0;
<a name="l01120"></a>01120     <a class="code" href="classSgGraphTraversal.html#ea1d243b1bc88eeac8cb335f4d6b9689">prepareGraph</a>(g);
<a name="l01121"></a>01121     <a class="code" href="classSgGraphTraversal.html#db422e324b7c6338b2b192f462b3a03d">workingthread</a> = <span class="keyword">false</span>;
<a name="l01122"></a>01122     <a class="code" href="classSgGraphTraversal.html#649fa4517fcb6ba196450aebb42c2ecf">workingthreadnum</a> = -1;
<a name="l01123"></a>01123     <span class="comment">//std::cout &lt;&lt; "markers: " &lt;&lt; markers.size() &lt;&lt; std::endl;</span>
<a name="l01124"></a>01124     <span class="comment">//std::cout &lt;&lt; "closures: " &lt;&lt; closures.size() &lt;&lt; std::endl;</span>
<a name="l01125"></a>01125     <span class="comment">//std::cout &lt;&lt; "sources: " &lt;&lt; sources.size() &lt;&lt; std::endl;</span>
<a name="l01126"></a>01126     <span class="comment">//std::cout &lt;&lt; "sinks" &lt;&lt; sinks.size() &lt;&lt; std::endl;</span>
<a name="l01127"></a>01127 <span class="comment">//    printHotness(g);</span>
<a name="l01128"></a>01128     <span class="keywordtype">bool</span> subgraph = <span class="keyword">false</span>;
<a name="l01129"></a>01129     <span class="keywordflow">if</span> (!subgraph) {
<a name="l01130"></a>01130             <span class="keywordflow">if</span> (!unbounded) {
<a name="l01131"></a>01131                 <a class="code" href="classSgGraphTraversal.html#867cd3ba00953f545867bcb4ef1f4dd7">bound</a> = <span class="keyword">true</span>;
<a name="l01132"></a>01132                 <a class="code" href="classSgGraphTraversal.html#50a077905c3afd49ff6071a9b70293c4">recursiveLoops</a>.clear();
<a name="l01133"></a>01133                 <a class="code" href="classSgGraphTraversal.html#2a0dfe20f21e79fbfa92f4da19fe25fc">recurses</a>.clear();
<a name="l01134"></a>01134                 std::vector&lt;std::vector&lt;int&gt; &gt; spaths = <a class="code" href="classSgGraphTraversal.html#ee7385288f2db18bfe67344be346b6b2">bfsTraversePath</a>(<a class="code" href="classSgGraphTraversal.html#e16ba093a525ac5f0115ca264f45862f">vertintmap</a>[begin], <a class="code" href="classSgGraphTraversal.html#e16ba093a525ac5f0115ca264f45862f">vertintmap</a>[end], g);
<a name="l01135"></a>01135       <span class="comment">//          std::cout &lt;&lt; "spaths: " &lt;&lt; spaths.size() &lt;&lt; std::endl;</span>
<a name="l01136"></a>01136             }
<a name="l01137"></a>01137             <span class="keywordflow">else</span> {
<a name="l01138"></a>01138                 std::set&lt;int&gt; usedsources;
<a name="l01139"></a>01139                 <a class="code" href="classSgGraphTraversal.html#867cd3ba00953f545867bcb4ef1f4dd7">bound</a> = <span class="keyword">false</span>;
<a name="l01140"></a>01140                  std::vector&lt;int&gt; localLps;
<a name="l01141"></a>01141                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; <a class="code" href="classSgGraphTraversal.html#cc9903979165779af1e22748d916cc26">sources</a>.size(); j++) {
<a name="l01142"></a>01142                     <a class="code" href="classSgGraphTraversal.html#1a5577095b410bc1259365a92dce8014">sourcenum</a> = <a class="code" href="classSgGraphTraversal.html#cc9903979165779af1e22748d916cc26">sources</a>[j];
<a name="l01143"></a>01143                     <a class="code" href="classSgGraphTraversal.html#50a077905c3afd49ff6071a9b70293c4">recursiveLoops</a>.clear();
<a name="l01144"></a>01144                     <a class="code" href="classSgGraphTraversal.html#2a0dfe20f21e79fbfa92f4da19fe25fc">recurses</a>.clear();
<a name="l01145"></a>01145                     std::vector&lt;std::vector&lt;int&gt; &gt; spaths = <a class="code" href="classSgGraphTraversal.html#ee7385288f2db18bfe67344be346b6b2">bfsTraversePath</a>(<a class="code" href="classSgGraphTraversal.html#cc9903979165779af1e22748d916cc26">sources</a>[j], -1, g);
<a name="l01146"></a>01146                
<a name="l01147"></a>01147                     
<a name="l01148"></a>01148                 }
<a name="l01149"></a>01149            }
<a name="l01150"></a>01150     }
<a name="l01151"></a>01151     <span class="comment">//std::cout &lt;&lt; "checkedfound: " &lt;&lt; checkedfound &lt;&lt; std::endl;</span>
<a name="l01152"></a>01152     <a class="code" href="classSgGraphTraversal.html#e979a970b3c79dccda01d11dc4fedecb">printHotness</a>(g);
<a name="l01153"></a>01153 }
<a name="l01154"></a>01154 
<a name="l01165"></a>01165 <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l01166"></a>01166 <span class="keywordtype">void</span>
<a name="l01167"></a>01167 <a class="code" href="classSgGraphTraversal.html#a04c72d1150e7e97fee958372e7f0f8c">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l01168"></a><a class="code" href="classSgGraphTraversal.html#a04c72d1150e7e97fee958372e7f0f8c">01168</a> <a class="code" href="classSgGraphTraversal.html#a04c72d1150e7e97fee958372e7f0f8c">computeSubGraphs</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; begin, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;end, CFG*&amp; g, <span class="keywordtype">int</span> depthDifferential) {
<a name="l01169"></a>01169         <span class="keywordtype">int</span> minDepth = 0;
<a name="l01170"></a>01170         <span class="keywordtype">int</span> maxDepth = minDepth + depthDifferential;
<a name="l01171"></a>01171         <span class="keywordtype">int</span> currSubGraph = 0;
<a name="l01172"></a>01172         CFG* subGraph;
<a name="l01173"></a>01173         std::set&lt;int&gt; foundNodes;
<a name="l01174"></a>01174         <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l01175"></a>01175             <a class="code" href="structVertex.html">Vertex</a> begin = boost::add_vertex(*<a class="code" href="classSgGraphTraversal.html#086551ed5b2c0b2494b917941c09665b">subGraphVector</a>[currSubGraph]);
<a name="l01176"></a>01176             <a class="code" href="classSgGraphTraversal.html#d67dcbcbbabd3dcf98e16a9465206c1e">GraphSubGraphMap</a>[currSubGraph][<a class="code" href="classSgGraphTraversal.html#7c6baf3c51dd37886bfce049ba5393ac">intvertmap</a>[<a class="code" href="classSgGraphTraversal.html#e782a21b91602c4ec407bcacd88b6b86">orderOfNodes</a>[minDepth]]] = <a class="code" href="classSgGraphTraversal.html#7c6baf3c51dd37886bfce049ba5393ac">intvertmap</a>[begin];
<a name="l01177"></a>01177             <a class="code" href="classSgGraphTraversal.html#c12040d0ae76b2c21867d1b55ab2aa12">SubGraphGraphMap</a>[currSubGraph][<a class="code" href="classSgGraphTraversal.html#7c6baf3c51dd37886bfce049ba5393ac">intvertmap</a>[begin]] = intvertmap[orderOfNodes[minDepth]];
<a name="l01178"></a>01178         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = minDepth; i &lt;= maxDepth; i++) {
<a name="l01179"></a>01179             <a class="code" href="structVertex.html">Vertex</a> v = <a class="code" href="classSgGraphTraversal.html#d67dcbcbbabd3dcf98e16a9465206c1e">GraphSubGraphMap</a>[currSubGraph][intvertmap[orderOfNodes[i]]];
<a name="l01180"></a>01180             std::vector&lt;int&gt; <a class="code" href="namespaceStaticCFG.html#b6db4c881b581bbf831656db30daf0ce">outEdges</a> = <a class="code" href="classSgGraphTraversal.html#ed013c85aba92ce0d5d36cd0d9d16c59">getOutEdges</a>(orderOfNodes[i], g);
<a name="l01181"></a>01181             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; outEdges.size(); j++) {
<a name="l01182"></a>01182                 <a class="code" href="structVertex.html">Vertex</a> u;
<a name="l01183"></a>01183                 <span class="keywordflow">if</span> (foundNodes.find(<a class="code" href="classSgGraphTraversal.html#64b5039c3ff06e9271cb85eda9812a38">getTarget</a>(outEdges[j], g)) == foundNodes.end()) {
<a name="l01184"></a>01184                         u = <a class="code" href="classSgGraphTraversal.html#d67dcbcbbabd3dcf98e16a9465206c1e">GraphSubGraphMap</a>[currSubGraph][intvertmap[<a class="code" href="classSgGraphTraversal.html#64b5039c3ff06e9271cb85eda9812a38">getTarget</a>(outEdges[j], g)]];
<a name="l01185"></a>01185                 }
<a name="l01186"></a>01186                 <span class="keywordflow">else</span> {
<a name="l01187"></a>01187                     u = boost::add_vertex(*<a class="code" href="classSgGraphTraversal.html#086551ed5b2c0b2494b917941c09665b">subGraphVector</a>[currSubGraph]);
<a name="l01188"></a>01188                     foundNodes.insert(<a class="code" href="classSgGraphTraversal.html#64b5039c3ff06e9271cb85eda9812a38">getTarget</a>(outEdges[j], g));
<a name="l01189"></a>01189                     <a class="code" href="classSgGraphTraversal.html#c12040d0ae76b2c21867d1b55ab2aa12">SubGraphGraphMap</a>[currSubGraph][u] = intvertmap[<a class="code" href="classSgGraphTraversal.html#64b5039c3ff06e9271cb85eda9812a38">getTarget</a>(outEdges[j], g)];
<a name="l01190"></a>01190                     <a class="code" href="classSgGraphTraversal.html#d67dcbcbbabd3dcf98e16a9465206c1e">GraphSubGraphMap</a>[currSubGraph][intvertmap[<a class="code" href="classSgGraphTraversal.html#64b5039c3ff06e9271cb85eda9812a38">getTarget</a>(outEdges[j], g)]] = u;
<a name="l01191"></a>01191 
<a name="l01192"></a>01192                 }
<a name="l01193"></a>01193                 <a class="code" href="structEdge.html">Edge</a> edge;
<a name="l01194"></a>01194                 <span class="keywordtype">bool</span> ok;
<a name="l01195"></a>01195                 boost::tie(edge, ok) = boost::add_edge(v,u,*<a class="code" href="classSgGraphTraversal.html#086551ed5b2c0b2494b917941c09665b">subGraphVector</a>[currSubGraph]);
<a name="l01196"></a>01196             }
<a name="l01197"></a>01197         }
<a name="l01198"></a>01198         minDepth = maxDepth;
<a name="l01199"></a>01199         <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) minDepth == orderOfNodes.size()-1) {
<a name="l01200"></a>01200                 <span class="keywordflow">break</span>;
<a name="l01201"></a>01201         }
<a name="l01202"></a>01202         maxDepth += depthDifferential;
<a name="l01203"></a>01203         <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) maxDepth &gt; orderOfNodes.size()-1)
<a name="l01204"></a>01204         {
<a name="l01205"></a>01205                 maxDepth = orderOfNodes.size()-1;
<a name="l01206"></a>01206         }
<a name="l01207"></a>01207         CFG* newSubGraph;
<a name="l01208"></a>01208         <a class="code" href="classSgGraphTraversal.html#086551ed5b2c0b2494b917941c09665b">subGraphVector</a>.push_back(newSubGraph);
<a name="l01209"></a>01209         currSubGraph++;
<a name="l01210"></a>01210         }
<a name="l01211"></a>01211         <span class="keywordflow">return</span>;
<a name="l01212"></a>01212 }
<a name="l01213"></a>01213 
<a name="l01214"></a>01214        
<a name="l01215"></a>01215 <span class="comment">/*</span>
<a name="l01216"></a>01216 <span class="comment">These should NOT be used by the user. They are simply for writing interesting information on the DOT graphs of the CFG</span>
<a name="l01217"></a>01217 <span class="comment">*/</span>
<a name="l01218"></a>01218 
<a name="l01219"></a>01219 
<a name="l01220"></a>01220  
<a name="l01221"></a>01221         <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l01222"></a>01222         <span class="keywordtype">void</span>
<a name="l01223"></a>01223         <a class="code" href="classSgGraphTraversal.html#feb32651e9e1b075f9d4733718a4789c">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l01224"></a><a class="code" href="classSgGraphTraversal.html#feb32651e9e1b075f9d4733718a4789c">01224</a> <a class="code" href="classSgGraphTraversal.html#feb32651e9e1b075f9d4733718a4789c">        printCFGNodeGeneric</a>(<span class="keywordtype">int</span> &amp;cf, std::string prop, std::ofstream&amp; o) {
<a name="l01225"></a>01225             std::string nodeColor = <span class="stringliteral">"black"</span>;
<a name="l01226"></a>01226             o &lt;&lt; cf &lt;&lt; <span class="stringliteral">" [label=\""</span> &lt;&lt; <span class="stringliteral">" num:"</span> &lt;&lt; cf &lt;&lt; <span class="stringliteral">" prop: "</span> &lt;&lt; prop &lt;&lt;  <span class="stringliteral">"\", color=\""</span> &lt;&lt; nodeColor &lt;&lt; <span class="stringliteral">"\", style=\""</span> &lt;&lt; <span class="stringliteral">"solid"</span> &lt;&lt; <span class="stringliteral">"\"];\n"</span>;
<a name="l01227"></a>01227         }
<a name="l01228"></a>01228 
<a name="l01229"></a>01229         <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l01230"></a>01230         <span class="keywordtype">void</span>
<a name="l01231"></a>01231         <a class="code" href="classSgGraphTraversal.html#19c5bdaa2f8e4977c399fe1413b67125">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l01232"></a><a class="code" href="classSgGraphTraversal.html#19c5bdaa2f8e4977c399fe1413b67125">01232</a> <a class="code" href="classSgGraphTraversal.html#19c5bdaa2f8e4977c399fe1413b67125">        printCFGNode</a>(<span class="keywordtype">int</span>&amp; cf, std::ofstream&amp; o)
<a name="l01233"></a>01233         {
<a name="l01234"></a>01234 <span class="preprocessor">            #ifdef FULLDEBUG</span>
<a name="l01235"></a>01235 <span class="preprocessor"></span>            <span class="keywordtype">int</span> pts = <a class="code" href="classSgGraphTraversal.html#fe3f39bf70faca2d573f83413c0b3e33">ptsNum</a>[cf];
<a name="l01236"></a>01236             std::string nodeColor = <span class="stringliteral">"black"</span>;
<a name="l01237"></a>01237             o &lt;&lt; cf &lt;&lt; <span class="stringliteral">" [label=\""</span> &lt;&lt; <span class="stringliteral">" pts: "</span> &lt;&lt; pts &lt;&lt;  <span class="stringliteral">"\", color=\""</span> &lt;&lt; nodeColor &lt;&lt; <span class="stringliteral">"\", style=\""</span> &lt;&lt; <span class="stringliteral">"solid"</span> &lt;&lt; <span class="stringliteral">"\"];\n"</span>;
<a name="l01238"></a>01238 <span class="preprocessor">            #endif</span>
<a name="l01239"></a>01239 <span class="preprocessor"></span><span class="preprocessor">            #ifndef FULLDEBUG</span>
<a name="l01240"></a>01240 <span class="preprocessor"></span>            std::string nodeColor = <span class="stringliteral">"black"</span>;
<a name="l01241"></a>01241             o &lt;&lt; cf &lt;&lt; <span class="stringliteral">" [label=\""</span> &lt;&lt; <span class="stringliteral">" num:"</span> &lt;&lt; cf &lt;&lt; <span class="stringliteral">"\", color=\""</span> &lt;&lt; nodeColor &lt;&lt; <span class="stringliteral">"\", style=\""</span> &lt;&lt; <span class="stringliteral">"solid"</span> &lt;&lt; <span class="stringliteral">"\"];\n"</span>;
<a name="l01242"></a>01242 <span class="preprocessor">            #endif</span>
<a name="l01243"></a>01243 <span class="preprocessor"></span>
<a name="l01244"></a>01244         }
<a name="l01245"></a>01245 
<a name="l01246"></a>01246         <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l01247"></a>01247         <span class="keywordtype">void</span>
<a name="l01248"></a>01248         <a class="code" href="classSgGraphTraversal.html#85a43852b4db1511b03cb2059c8e227b">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l01249"></a><a class="code" href="classSgGraphTraversal.html#85a43852b4db1511b03cb2059c8e227b">01249</a> <a class="code" href="classSgGraphTraversal.html#85a43852b4db1511b03cb2059c8e227b">        printCFGEdge</a>(<span class="keywordtype">int</span>&amp; cf, CFG*&amp; <a class="code" href="yicesParserLib_8h.html#186965467c7391216517a49d187f340c">cfg</a>, std::ofstream&amp; o)
<a name="l01250"></a>01250         {
<a name="l01251"></a>01251             <span class="keywordtype">int</span> src = <a class="code" href="classSgGraphTraversal.html#2b14dfe2c36b4aa54d74d94a002c9e9d">getSource</a>(cf, cfg);
<a name="l01252"></a>01252             <span class="keywordtype">int</span> tar = <a class="code" href="classSgGraphTraversal.html#64b5039c3ff06e9271cb85eda9812a38">getTarget</a>(cf, cfg);
<a name="l01253"></a>01253             o &lt;&lt; src &lt;&lt; <span class="stringliteral">" -&gt; "</span> &lt;&lt; tar &lt;&lt; <span class="stringliteral">" [label=\""</span> &lt;&lt; src &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; tar &lt;&lt; <span class="stringliteral">"\", style=\""</span> &lt;&lt; <span class="stringliteral">"solid"</span> &lt;&lt; <span class="stringliteral">"\"];\n"</span>;
<a name="l01254"></a>01254         }
<a name="l01255"></a>01255 
<a name="l01256"></a>01256         <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l01257"></a>01257         <span class="keywordtype">void</span>
<a name="l01258"></a>01258         <a class="code" href="classSgGraphTraversal.html#e979a970b3c79dccda01d11dc4fedecb">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l01259"></a><a class="code" href="classSgGraphTraversal.html#e979a970b3c79dccda01d11dc4fedecb">01259</a> <a class="code" href="classSgGraphTraversal.html#e979a970b3c79dccda01d11dc4fedecb">        printHotness</a>(CFG*&amp; g)
<a name="l01260"></a>01260         {
<a name="l01261"></a>01261             <span class="keyword">const</span> CFG* gc = g;
<a name="l01262"></a>01262             <span class="keywordtype">int</span> currhot = 0;
<a name="l01263"></a>01263             std::ofstream mf;
<a name="l01264"></a>01264             std::stringstream filenam;
<a name="l01265"></a>01265             filenam &lt;&lt; <span class="stringliteral">"hotness"</span> &lt;&lt; currhot &lt;&lt; <span class="stringliteral">".dot"</span>;
<a name="l01266"></a>01266             currhot++;
<a name="l01267"></a>01267             std::string fn = filenam.str();
<a name="l01268"></a>01268             mf.open(fn.c_str());
<a name="l01269"></a>01269 
<a name="l01270"></a>01270             mf &lt;&lt; <span class="stringliteral">"digraph defaultName { \n"</span>;
<a name="l01271"></a>01271             <a class="code" href="classSgGraphTraversal.html#bd1764411718e5932af95a3274da42cb">vertex_iterator</a> v, vend;
<a name="l01272"></a>01272             <a class="code" href="classSgGraphTraversal.html#4ff52d7e02676a9027590d2633b5e0a9">edge_iterator</a> e, eend;
<a name="l01273"></a>01273             <span class="keywordflow">for</span> (tie(v, vend) = vertices(*gc); v != vend; ++v)
<a name="l01274"></a>01274             {
<a name="l01275"></a>01275                 <a class="code" href="classSgGraphTraversal.html#19c5bdaa2f8e4977c399fe1413b67125">printCFGNode</a>(<a class="code" href="classSgGraphTraversal.html#e16ba093a525ac5f0115ca264f45862f">vertintmap</a>[*v], mf);
<a name="l01276"></a>01276             }
<a name="l01277"></a>01277             <span class="keywordflow">for</span> (tie(e, eend) = edges(*gc); e != eend; ++e)
<a name="l01278"></a>01278             {
<a name="l01279"></a>01279                 <a class="code" href="classSgGraphTraversal.html#85a43852b4db1511b03cb2059c8e227b">printCFGEdge</a>(<a class="code" href="classSgGraphTraversal.html#e527e01de9e2d0f0cbbe3f6d76efac6c">edgeintmap</a>[*e], g, mf);
<a name="l01280"></a>01280             }
<a name="l01281"></a>01281             mf.close();
<a name="l01282"></a>01282         }
<a name="l01283"></a>01283       <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l01284"></a>01284         <span class="keywordtype">void</span>
<a name="l01285"></a>01285         <a class="code" href="classSgGraphTraversal.html#4f9ec385bcc62d3fef641227080a5def">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l01286"></a><a class="code" href="classSgGraphTraversal.html#4f9ec385bcc62d3fef641227080a5def">01286</a> <a class="code" href="classSgGraphTraversal.html#4f9ec385bcc62d3fef641227080a5def">        printPathDot</a>(CFG*&amp; g)
<a name="l01287"></a>01287         {
<a name="l01288"></a>01288             <span class="keyword">const</span> CFG* gc = g;
<a name="l01289"></a>01289             std::ofstream mf;
<a name="l01290"></a>01290             std::stringstream filenam;
<a name="l01291"></a>01291             filenam &lt;&lt; <span class="stringliteral">"pathnums.dot"</span>;
<a name="l01292"></a>01292             std::string fn = filenam.str();
<a name="l01293"></a>01293             mf.open(fn.c_str());
<a name="l01294"></a>01294 
<a name="l01295"></a>01295             mf &lt;&lt; <span class="stringliteral">"digraph defaultName { \n"</span>;
<a name="l01296"></a>01296             <a class="code" href="classSgGraphTraversal.html#bd1764411718e5932af95a3274da42cb">vertex_iterator</a> v, vend;
<a name="l01297"></a>01297             <a class="code" href="classSgGraphTraversal.html#4ff52d7e02676a9027590d2633b5e0a9">edge_iterator</a> e, eend;
<a name="l01298"></a>01298             <span class="keywordflow">for</span> (tie(v, vend) = vertices(*gc); v != vend; ++v)
<a name="l01299"></a>01299             {
<a name="l01300"></a>01300                 <span class="keywordflow">if</span> (<a class="code" href="classSgGraphTraversal.html#684135a0b75af543d171fc0eb6411836">nodeStrings</a>.find(<a class="code" href="classSgGraphTraversal.html#e16ba093a525ac5f0115ca264f45862f">vertintmap</a>[*v]) != <a class="code" href="classSgGraphTraversal.html#684135a0b75af543d171fc0eb6411836">nodeStrings</a>.end()) {
<a name="l01301"></a>01301                     <span class="keywordtype">int</span> nn = <a class="code" href="classSgGraphTraversal.html#e16ba093a525ac5f0115ca264f45862f">vertintmap</a>[*v];
<a name="l01302"></a>01302                     <a class="code" href="classSgGraphTraversal.html#feb32651e9e1b075f9d4733718a4789c">printCFGNodeGeneric</a>(<a class="code" href="classSgGraphTraversal.html#e16ba093a525ac5f0115ca264f45862f">vertintmap</a>[*v], <a class="code" href="classSgGraphTraversal.html#684135a0b75af543d171fc0eb6411836">nodeStrings</a>[nn], mf);
<a name="l01303"></a>01303                 }
<a name="l01304"></a>01304                 <span class="keywordflow">else</span> {
<a name="l01305"></a>01305                     <a class="code" href="classSgGraphTraversal.html#feb32651e9e1b075f9d4733718a4789c">printCFGNodeGeneric</a>(<a class="code" href="classSgGraphTraversal.html#e16ba093a525ac5f0115ca264f45862f">vertintmap</a>[*v], <span class="stringliteral">"noprop"</span>, mf);
<a name="l01306"></a>01306                 }
<a name="l01307"></a>01307             }
<a name="l01308"></a>01308            <span class="keywordflow">for</span> (tie(e, eend) = edges(*gc); e != eend; ++e)
<a name="l01309"></a>01309             {
<a name="l01310"></a>01310                 <a class="code" href="classSgGraphTraversal.html#85a43852b4db1511b03cb2059c8e227b">printCFGEdge</a>(<a class="code" href="classSgGraphTraversal.html#e527e01de9e2d0f0cbbe3f6d76efac6c">edgeintmap</a>[*e], g, mf);
<a name="l01311"></a>01311             }
<a name="l01312"></a>01312 
<a name="l01313"></a>01313             mf.close();
<a name="l01314"></a>01314         }
<a name="l01315"></a>01315 
<a name="l01316"></a>01316 
<a name="l01317"></a>01317 
<a name="l01327"></a>01327 <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l01328"></a>01328 <span class="keywordtype">void</span>
<a name="l01329"></a>01329 <a class="code" href="classSgGraphTraversal.html#ea1d243b1bc88eeac8cb335f4d6b9689">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l01330"></a><a class="code" href="classSgGraphTraversal.html#ea1d243b1bc88eeac8cb335f4d6b9689">01330</a> <a class="code" href="classSgGraphTraversal.html#ea1d243b1bc88eeac8cb335f4d6b9689">prepareGraph</a>(CFG*&amp; g) {
<a name="l01331"></a>01331     <a class="code" href="classSgGraphTraversal.html#c464c8f699bc1c05c815e7857fb0c459">nextNode</a> = 1;
<a name="l01332"></a>01332     <a class="code" href="classSgGraphTraversal.html#4ffd1286e256682144d62e61fefc9c0f">nextEdge</a> = 1;
<a name="l01333"></a>01333     <a class="code" href="classSgGraphTraversal.html#4a8b9778176b8ab06a4ef59f9c0c5b1f">findClosuresAndMarkersAndEnumerate</a>(g);
<a name="l01334"></a>01334 }
<a name="l01335"></a>01335 
<a name="l01336"></a>01336 
<a name="l01348"></a>01348 <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l01349"></a>01349 <span class="keywordtype">void</span>
<a name="l01350"></a>01350 <a class="code" href="classSgGraphTraversal.html#eaf76aff61b8693bd3ac560ce73b3d37">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l01351"></a><a class="code" href="classSgGraphTraversal.html#eaf76aff61b8693bd3ac560ce73b3d37">01351</a> <a class="code" href="classSgGraphTraversal.html#eaf76aff61b8693bd3ac560ce73b3d37">firstPrepGraph</a>(CFG*&amp; g) {
<a name="l01352"></a>01352     <a class="code" href="classSgGraphTraversal.html#c464c8f699bc1c05c815e7857fb0c459">nextNode</a> = 1;
<a name="l01353"></a>01353     <a class="code" href="classSgGraphTraversal.html#4ffd1286e256682144d62e61fefc9c0f">nextEdge</a> = 1;
<a name="l01354"></a>01354     <a class="code" href="classSgGraphTraversal.html#4a8b9778176b8ab06a4ef59f9c0c5b1f">findClosuresAndMarkersAndEnumerate</a>(g);
<a name="l01355"></a>01355 }
<a name="l01356"></a>01356 
<a name="l01368"></a>01368 <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l01369"></a>01369 <span class="keywordtype">void</span>
<a name="l01370"></a>01370 <a class="code" href="classSgGraphTraversal.html#4a8b9778176b8ab06a4ef59f9c0c5b1f">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l01371"></a><a class="code" href="classSgGraphTraversal.html#4a8b9778176b8ab06a4ef59f9c0c5b1f">01371</a> <a class="code" href="classSgGraphTraversal.html#4a8b9778176b8ab06a4ef59f9c0c5b1f">findClosuresAndMarkersAndEnumerate</a>(CFG*&amp; g)
<a name="l01372"></a>01372 {
<a name="l01373"></a>01373     <a class="code" href="classSgGraphTraversal.html#4ff52d7e02676a9027590d2633b5e0a9">edge_iterator</a> e, eend;
<a name="l01374"></a>01374     <span class="keywordflow">for</span> (tie(e, eend) = edges(*g); e != eend; ++e) {
<a name="l01375"></a>01375         <a class="code" href="classSgGraphTraversal.html#e4b03b4ffca52e346bdc1d3e26f3e208">intedgemap</a>[<a class="code" href="classSgGraphTraversal.html#4ffd1286e256682144d62e61fefc9c0f">nextEdge</a>] = *e;
<a name="l01376"></a>01376         <a class="code" href="classSgGraphTraversal.html#e527e01de9e2d0f0cbbe3f6d76efac6c">edgeintmap</a>[*e] = <a class="code" href="classSgGraphTraversal.html#4ffd1286e256682144d62e61fefc9c0f">nextEdge</a>;
<a name="l01377"></a>01377         <a class="code" href="classSgGraphTraversal.html#4ffd1286e256682144d62e61fefc9c0f">nextEdge</a>++;
<a name="l01378"></a>01378     }
<a name="l01379"></a>01379     <a class="code" href="classSgGraphTraversal.html#bd1764411718e5932af95a3274da42cb">vertex_iterator</a> v1, vend1;
<a name="l01380"></a>01380     <span class="keywordflow">for</span> (tie(v1, vend1) = vertices(*g); v1 != vend1; ++v1)
<a name="l01381"></a>01381     {
<a name="l01382"></a>01382         <a class="code" href="classSgGraphTraversal.html#e16ba093a525ac5f0115ca264f45862f">vertintmap</a>[*v1] = <a class="code" href="classSgGraphTraversal.html#c464c8f699bc1c05c815e7857fb0c459">nextNode</a>;
<a name="l01383"></a>01383         <a class="code" href="classSgGraphTraversal.html#7c6baf3c51dd37886bfce049ba5393ac">intvertmap</a>[<a class="code" href="classSgGraphTraversal.html#c464c8f699bc1c05c815e7857fb0c459">nextNode</a>] = *v1;
<a name="l01384"></a>01384         <a class="code" href="classSgGraphTraversal.html#c464c8f699bc1c05c815e7857fb0c459">nextNode</a>++;
<a name="l01385"></a>01385     }
<a name="l01386"></a>01386     <a class="code" href="classSgGraphTraversal.html#bd1764411718e5932af95a3274da42cb">vertex_iterator</a> v, vend;
<a name="l01387"></a>01387     <span class="keywordflow">for</span> (tie(v, vend) = vertices(*g); v != vend; ++v) {
<a name="l01388"></a>01388         std::vector&lt;int&gt; outs = <a class="code" href="classSgGraphTraversal.html#ed013c85aba92ce0d5d36cd0d9d16c59">getOutEdges</a>(<a class="code" href="classSgGraphTraversal.html#e16ba093a525ac5f0115ca264f45862f">vertintmap</a>[*v], g);
<a name="l01389"></a>01389         std::vector&lt;int&gt; ins = <a class="code" href="classSgGraphTraversal.html#99a605cac4164b6a2e5771eb33d25b67">getInEdges</a>(<a class="code" href="classSgGraphTraversal.html#e16ba093a525ac5f0115ca264f45862f">vertintmap</a>[*v], g);
<a name="l01390"></a>01390         <span class="keywordflow">if</span> (outs.size() &gt; 1)
<a name="l01391"></a>01391         {
<a name="l01392"></a>01392             <a class="code" href="classSgGraphTraversal.html#25558621655ec18a69d8a5df2fea1534">markers</a>.push_back(<a class="code" href="classSgGraphTraversal.html#e16ba093a525ac5f0115ca264f45862f">vertintmap</a>[*v]);
<a name="l01393"></a>01393             
<a name="l01394"></a>01394             <a class="code" href="classSgGraphTraversal.html#908f7e3456e9e6512f6efe3511744df6">markerIndex</a>[<a class="code" href="classSgGraphTraversal.html#e16ba093a525ac5f0115ca264f45862f">vertintmap</a>[*v]] = <a class="code" href="classSgGraphTraversal.html#25558621655ec18a69d8a5df2fea1534">markers</a>.size()-1;
<a name="l01395"></a>01395             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; outs.size(); i++) {
<a name="l01396"></a>01396                 <a class="code" href="classSgGraphTraversal.html#152b4fd59b0c3878812646aab1dbf335">pathsAtMarkers</a>[vertintmap[*v]].push_back(<a class="code" href="classSgGraphTraversal.html#64b5039c3ff06e9271cb85eda9812a38">getTarget</a>(outs[i], g));
<a name="l01397"></a>01397             }
<a name="l01398"></a>01398         }
<a name="l01399"></a>01399         <span class="keywordflow">if</span> (ins.size() &gt; 1)
<a name="l01400"></a>01400         {
<a name="l01401"></a>01401             <a class="code" href="classSgGraphTraversal.html#4c7e951115097e892e120a967d221fc3">closures</a>.push_back(<a class="code" href="classSgGraphTraversal.html#e16ba093a525ac5f0115ca264f45862f">vertintmap</a>[*v]);
<a name="l01402"></a>01402         }
<a name="l01403"></a>01403         <span class="keywordflow">if</span> (outs.size() == 0) {
<a name="l01404"></a>01404             <a class="code" href="classSgGraphTraversal.html#8a63b0bc59be3a6111435b10a81c0987">sinks</a>.push_back(<a class="code" href="classSgGraphTraversal.html#e16ba093a525ac5f0115ca264f45862f">vertintmap</a>[*v]);
<a name="l01405"></a>01405         }
<a name="l01406"></a>01406         <span class="keywordflow">if</span> (ins.size() == 0) {
<a name="l01407"></a>01407             <a class="code" href="classSgGraphTraversal.html#cc9903979165779af1e22748d916cc26">sources</a>.push_back(<a class="code" href="classSgGraphTraversal.html#e16ba093a525ac5f0115ca264f45862f">vertintmap</a>[*v]);
<a name="l01408"></a>01408         }
<a name="l01409"></a>01409     }
<a name="l01410"></a>01410     <span class="keywordflow">return</span>;
<a name="l01411"></a>01411 }
<a name="l01412"></a>01412 
<a name="l01413"></a>01413 
<a name="l01414"></a>01414 
<a name="l01421"></a>01421 <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l01422"></a>01422 <span class="keywordtype">void</span>
<a name="l01423"></a>01423 <a class="code" href="classSgGraphTraversal.html#d812e5f8186bd7b5fa0c48700cebf731">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l01424"></a><a class="code" href="classSgGraphTraversal.html#d812e5f8186bd7b5fa0c48700cebf731">01424</a> <a class="code" href="classSgGraphTraversal.html#d812e5f8186bd7b5fa0c48700cebf731">computeOrder</a>(CFG*&amp; g, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; begin) {
<a name="l01425"></a>01425         std::vector&lt;int&gt; currentNodes;
<a name="l01426"></a>01426         std::vector&lt;int&gt; newCurrentNodes;
<a name="l01427"></a>01427         currentNodes.push_back(begin);
<a name="l01428"></a>01428         std::map&lt;int, int&gt; reverseCurrents;
<a name="l01429"></a>01429         <a class="code" href="classSgGraphTraversal.html#e782a21b91602c4ec407bcacd88b6b86">orderOfNodes</a>.push_back(begin);
<a name="l01430"></a>01430         std::set&lt;int&gt; heldBackNodes;
<a name="l01431"></a>01431         <span class="keywordflow">while</span> (currentNodes.size() != 0) {
<a name="l01432"></a>01432                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; currentNodes.size(); j++) {
<a name="l01433"></a>01433                        
<a name="l01434"></a>01434                         std::vector&lt;int&gt; <a class="code" href="namespaceStaticCFG.html#ed5c146d0f80fb458f99e8cf7a700199">inEdges</a> = <a class="code" href="classSgGraphTraversal.html#99a605cac4164b6a2e5771eb33d25b67">getInEdges</a>(currentNodes[j], g);
<a name="l01435"></a>01435                         <span class="keywordflow">if</span> (<a class="code" href="namespaceStaticCFG.html#ed5c146d0f80fb458f99e8cf7a700199">inEdges</a>.size() &gt; 1) {
<a name="l01436"></a>01436                         <span class="keywordflow">if</span> (reverseCurrents.find(currentNodes[j]) == reverseCurrents.end()) {
<a name="l01437"></a>01437                             reverseCurrents[currentNodes[j]] = 0;
<a name="l01438"></a>01438                         }
<a name="l01439"></a>01439                         <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) reverseCurrents[currentNodes[j]] == <a class="code" href="namespaceStaticCFG.html#ed5c146d0f80fb458f99e8cf7a700199">inEdges</a>.size() - 1) {
<a name="l01440"></a>01440                                 heldBackNodes.erase(currentNodes[j]);
<a name="l01441"></a>01441                                 reverseCurrents[currentNodes[j]]++;
<a name="l01442"></a>01442                                 std::vector&lt;int&gt; <a class="code" href="namespaceStaticCFG.html#b6db4c881b581bbf831656db30daf0ce">outEdges</a> = <a class="code" href="classSgGraphTraversal.html#ed013c85aba92ce0d5d36cd0d9d16c59">getOutEdges</a>(currentNodes[j], g);
<a name="l01443"></a>01443                                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; outEdges.size(); k++) {
<a name="l01444"></a>01444                                         newCurrentNodes.push_back(<a class="code" href="classSgGraphTraversal.html#64b5039c3ff06e9271cb85eda9812a38">getTarget</a>(outEdges[k], g));
<a name="l01445"></a>01445                                         <a class="code" href="classSgGraphTraversal.html#e782a21b91602c4ec407bcacd88b6b86">orderOfNodes</a>.push_back(<a class="code" href="classSgGraphTraversal.html#64b5039c3ff06e9271cb85eda9812a38">getTarget</a>(outEdges[k], g));
<a name="l01446"></a>01446                                 }
<a name="l01447"></a>01447                         }
<a name="l01448"></a>01448                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (reverseCurrents[currentNodes[j]] &lt; reverseCurrents.size()) {
<a name="l01449"></a>01449                                 reverseCurrents[currentNodes[j]]++;
<a name="l01450"></a>01450                                 <span class="keywordflow">if</span> (heldBackNodes.find(currentNodes[j]) == heldBackNodes.end()) {
<a name="l01451"></a>01451                                     heldBackNodes.insert(currentNodes[j]);
<a name="l01452"></a>01452                                 }
<a name="l01453"></a>01453                         }
<a name="l01454"></a>01454                         }
<a name="l01455"></a>01455                         <span class="keywordflow">else</span> {
<a name="l01456"></a>01456                                 std::vector&lt;int&gt; <a class="code" href="namespaceStaticCFG.html#b6db4c881b581bbf831656db30daf0ce">outEdges</a> = <a class="code" href="classSgGraphTraversal.html#ed013c85aba92ce0d5d36cd0d9d16c59">getOutEdges</a>(currentNodes[j], g);
<a name="l01457"></a>01457                                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; outEdges.size(); k++) {
<a name="l01458"></a>01458                                         newCurrentNodes.push_back(<a class="code" href="classSgGraphTraversal.html#64b5039c3ff06e9271cb85eda9812a38">getTarget</a>(outEdges[k], g));
<a name="l01459"></a>01459                                         <a class="code" href="classSgGraphTraversal.html#e782a21b91602c4ec407bcacd88b6b86">orderOfNodes</a>.push_back(<a class="code" href="classSgGraphTraversal.html#64b5039c3ff06e9271cb85eda9812a38">getTarget</a>(outEdges[k], g));
<a name="l01460"></a>01460 
<a name="l01461"></a>01461                                 }
<a name="l01462"></a>01462                         }
<a name="l01463"></a>01463                 }
<a name="l01464"></a>01464                 <span class="keywordflow">if</span> (newCurrentNodes.size() == 0 &amp;&amp; heldBackNodes.size() != 0) {
<a name="l01465"></a>01465                     <span class="keywordflow">for</span> (std::set&lt;int&gt;::iterator q = heldBackNodes.begin(); q != heldBackNodes.end(); q++) {
<a name="l01466"></a>01466                         <span class="keywordtype">int</span> qint = *q;
<a name="l01467"></a>01467                         std::vector&lt;int&gt; heldBackOutEdges = <a class="code" href="classSgGraphTraversal.html#ed013c85aba92ce0d5d36cd0d9d16c59">getOutEdges</a>(qint, g);
<a name="l01468"></a>01468                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; heldBackOutEdges.size(); p++) {
<a name="l01469"></a>01469                             newCurrentNodes.push_back(<a class="code" href="classSgGraphTraversal.html#64b5039c3ff06e9271cb85eda9812a38">getTarget</a>(heldBackOutEdges[p], g));
<a name="l01470"></a>01470                         }
<a name="l01471"></a>01471                    }
<a name="l01472"></a>01472                    heldBackNodes.clear();
<a name="l01473"></a>01473                 }
<a name="l01474"></a>01474                 currentNodes = newCurrentNodes;
<a name="l01475"></a>01475                 newCurrentNodes.clear();
<a name="l01476"></a>01476         }
<a name="l01477"></a>01477         <span class="keywordflow">return</span>;
<a name="l01478"></a>01478 }
<a name="l01479"></a>01479 
<a name="l01489"></a>01489 <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l01490"></a>01490 <span class="keywordtype">void</span>
<a name="l01491"></a>01491 <a class="code" href="classSgGraphTraversal.html#5cb8364064494352aaefc69b9183ff4c">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l01492"></a><a class="code" href="classSgGraphTraversal.html#5cb8364064494352aaefc69b9183ff4c">01492</a> <a class="code" href="classSgGraphTraversal.html#5cb8364064494352aaefc69b9183ff4c">getVertexPath</a>(std::vector&lt;int&gt; path, CFG*&amp; g, std::vector&lt;Vertex&gt;&amp; vertexPath) {
<a name="l01493"></a>01493         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; path.size(); i++) {
<a name="l01494"></a>01494                             vertexPath.push_back(<a class="code" href="classSgGraphTraversal.html#7c6baf3c51dd37886bfce049ba5393ac">intvertmap</a>[path[i]]);
<a name="l01495"></a>01495         }
<a name="l01496"></a>01496 
<a name="l01497"></a>01497        
<a name="l01498"></a>01498         
<a name="l01499"></a>01499 }
<a name="l01500"></a>01500 
<a name="l01507"></a>01507 <span class="keyword">template</span>&lt;<span class="keyword">class</span> CFG&gt;
<a name="l01508"></a>01508 <span class="keywordtype">void</span>
<a name="l01509"></a>01509 <a class="code" href="classSgGraphTraversal.html#28359e18a99e834e73adbe56634379d2">SgGraphTraversal&lt;CFG&gt;::</a>
<a name="l01510"></a><a class="code" href="classSgGraphTraversal.html#28359e18a99e834e73adbe56634379d2">01510</a> <a class="code" href="classSgGraphTraversal.html#28359e18a99e834e73adbe56634379d2">storeCompact</a>(std::vector&lt;int&gt; compactPath) {
<a name="l01511"></a>01511 <span class="keywordflow">return</span>;
<a name="l01512"></a>01512 }
<a name="l01513"></a>01513 
<a name="l01514"></a>01514 
<a name="l01515"></a>01515 
<a name="l01516"></a>01516 
<a name="l01517"></a>01517                   
</pre></div><hr size="1"><address style="align: right;"><small>Generated on 20 Jan 2013 for ROSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
